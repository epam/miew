(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const Miew = require('../packages/lib/build/dist/Miew')

window.onload = function () {
  const viewer = new Miew({
    container: document.getElementsByClassName('miew-container')[0],
    load: '1CRN'
  })

  if (viewer.init()) {
    viewer.run()
  }
}

},{"../packages/lib/build/dist/Miew":4}],2:[function(require,module,exports){
(function (global){(function (){
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return _;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.THREE = {}));
}(this, (function (exports) { 'use strict';

	const REVISION = '131';
	const MOUSE = {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2
	};
	const TOUCH = {
		ROTATE: 0,
		PAN: 1,
		DOLLY_PAN: 2,
		DOLLY_ROTATE: 3
	};
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const SmoothShading = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;
	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const RGBEFormat = RGBAFormat;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBIntegerFormat = 1032;
	const RGBAIntegerFormat = 1033;
	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const LogLuvEncoding = 3003;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const ZeroStencilOp = 0;
	const KeepStencilOp = 7680;
	const ReplaceStencilOp = 7681;
	const IncrementStencilOp = 7682;
	const DecrementStencilOp = 7683;
	const IncrementWrapStencilOp = 34055;
	const DecrementWrapStencilOp = 34056;
	const InvertStencilOp = 5386;
	const NeverStencilFunc = 512;
	const LessStencilFunc = 513;
	const EqualStencilFunc = 514;
	const LessEqualStencilFunc = 515;
	const GreaterStencilFunc = 516;
	const NotEqualStencilFunc = 517;
	const GreaterEqualStencilFunc = 518;
	const AlwaysStencilFunc = 519;
	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const StreamDrawUsage = 35040;
	const StaticReadUsage = 35045;
	const DynamicReadUsage = 35049;
	const StreamReadUsage = 35041;
	const StaticCopyUsage = 35046;
	const DynamicCopyUsage = 35050;
	const StreamCopyUsage = 35042;
	const GLSL1 = '100';
	const GLSL3 = '300 es';

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	class EventDispatcher {
		addEventListener(type, listener) {
			if (this._listeners === undefined) this._listeners = {};
			const listeners = this._listeners;

			if (listeners[type] === undefined) {
				listeners[type] = [];
			}

			if (listeners[type].indexOf(listener) === -1) {
				listeners[type].push(listener);
			}
		}

		hasEventListener(type, listener) {
			if (this._listeners === undefined) return false;
			const listeners = this._listeners;
			return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
		}

		removeEventListener(type, listener) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[type];

			if (listenerArray !== undefined) {
				const index = listenerArray.indexOf(listener);

				if (index !== -1) {
					listenerArray.splice(index, 1);
				}
			}
		}

		dispatchEvent(event) {
			if (this._listeners === undefined) return;
			const listeners = this._listeners;
			const listenerArray = listeners[event.type];

			if (listenerArray !== undefined) {
				event.target = this; // Make a copy, in case listeners are removed while iterating.

				const array = listenerArray.slice(0);

				for (let i = 0, l = array.length; i < l; i++) {
					array[i].call(this, event);
				}

				event.target = null;
			}
		}

	}

	const _lut = [];

	for (let i = 0; i < 256; i++) {
		_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
	}

	let _seed = 1234567;
	const DEG2RAD = Math.PI / 180;
	const RAD2DEG = 180 / Math.PI; // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

	function generateUUID() {
		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff]; // .toUpperCase() here flattens concatenated strings to save heap memory space.

		return uuid.toUpperCase();
	}

	function clamp(value, min, max) {
		return Math.max(min, Math.min(max, value));
	} // compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation


	function euclideanModulo(n, m) {
		return (n % m + m) % m;
	} // Linear mapping from range <a1, a2> to range <b1, b2>


	function mapLinear(x, a1, a2, b1, b2) {
		return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	} // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/


	function inverseLerp(x, y, value) {
		if (x !== y) {
			return (value - x) / (y - x);
		} else {
			return 0;
		}
	} // https://en.wikipedia.org/wiki/Linear_interpolation


	function lerp(x, y, t) {
		return (1 - t) * x + t * y;
	} // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/


	function damp(x, y, lambda, dt) {
		return lerp(x, y, 1 - Math.exp(-lambda * dt));
	} // https://www.desmos.com/calculator/vcsjnyz7x4


	function pingpong(x, length = 1) {
		return length - Math.abs(euclideanModulo(x, length * 2) - length);
	} // http://en.wikipedia.org/wiki/Smoothstep


	function smoothstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * (3 - 2 * x);
	}

	function smootherstep(x, min, max) {
		if (x <= min) return 0;
		if (x >= max) return 1;
		x = (x - min) / (max - min);
		return x * x * x * (x * (x * 6 - 15) + 10);
	} // Random integer from <low, high> interval


	function randInt(low, high) {
		return low + Math.floor(Math.random() * (high - low + 1));
	} // Random float from <low, high> interval


	function randFloat(low, high) {
		return low + Math.random() * (high - low);
	} // Random float from <-range/2, range/2> interval


	function randFloatSpread(range) {
		return range * (0.5 - Math.random());
	} // Deterministic pseudo-random float in the interval [ 0, 1 ]


	function seededRandom(s) {
		if (s !== undefined) _seed = s % 2147483647; // Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;
		return (_seed - 1) / 2147483646;
	}

	function degToRad(degrees) {
		return degrees * DEG2RAD;
	}

	function radToDeg(radians) {
		return radians * RAD2DEG;
	}

	function isPowerOfTwo(value) {
		return (value & value - 1) === 0 && value !== 0;
	}

	function ceilPowerOfTwo(value) {
		return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	}

	function floorPowerOfTwo(value) {
		return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	}

	function setQuaternionFromProperEuler(q, a, b, c, order) {
		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians
		const cos = Math.cos;
		const sin = Math.sin;
		const c2 = cos(b / 2);
		const s2 = sin(b / 2);
		const c13 = cos((a + c) / 2);
		const s13 = sin((a + c) / 2);
		const c1_3 = cos((a - c) / 2);
		const s1_3 = sin((a - c) / 2);
		const c3_1 = cos((c - a) / 2);
		const s3_1 = sin((c - a) / 2);

		switch (order) {
			case 'XYX':
				q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
				break;

			case 'YZY':
				q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
				break;

			case 'ZXZ':
				q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
				break;

			case 'XZX':
				q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
				break;

			case 'YXY':
				q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
				break;

			case 'ZYZ':
				q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
				break;

			default:
				console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
		}
	}

	var MathUtils = /*#__PURE__*/Object.freeze({
		__proto__: null,
		DEG2RAD: DEG2RAD,
		RAD2DEG: RAD2DEG,
		generateUUID: generateUUID,
		clamp: clamp,
		euclideanModulo: euclideanModulo,
		mapLinear: mapLinear,
		inverseLerp: inverseLerp,
		lerp: lerp,
		damp: damp,
		pingpong: pingpong,
		smoothstep: smoothstep,
		smootherstep: smootherstep,
		randInt: randInt,
		randFloat: randFloat,
		randFloatSpread: randFloatSpread,
		seededRandom: seededRandom,
		degToRad: degToRad,
		radToDeg: radToDeg,
		isPowerOfTwo: isPowerOfTwo,
		ceilPowerOfTwo: ceilPowerOfTwo,
		floorPowerOfTwo: floorPowerOfTwo,
		setQuaternionFromProperEuler: setQuaternionFromProperEuler
	});

	class Vector2 {
		constructor(x = 0, y = 0) {
			this.x = x;
			this.y = y;
		}

		get width() {
			return this.x;
		}

		set width(value) {
			this.x = value;
		}

		get height() {
			return this.y;
		}

		set height(value) {
			this.y = value;
		}

		set(x, y) {
			this.x = x;
			this.y = y;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			return this;
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6];
			this.y = e[1] * x + e[4] * y + e[7];
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y;
		}

		cross(v) {
			return this.x * v.y - this.y * v.x;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		angle() {
			// computes the angle in radians with respect to the positive x-axis
			const angle = Math.atan2(-this.y, -this.x) + Math.PI;
			return angle;
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y;
			return dx * dx + dy * dy;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			return this;
		}

		rotateAround(center, angle) {
			const c = Math.cos(angle),
						s = Math.sin(angle);
			const x = this.x - center.x;
			const y = this.y - center.y;
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			return this;
		}

	}

	Vector2.prototype.isVector2 = true;

	class Matrix3 {
		constructor() {
			this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			const te = this.elements;
			te[0] = n11;
			te[1] = n21;
			te[2] = n31;
			te[3] = n12;
			te[4] = n22;
			te[5] = n32;
			te[6] = n13;
			te[7] = n23;
			te[8] = n33;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this;
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrix3Column(this, 0);
			yAxis.setFromMatrix3Column(this, 1);
			zAxis.setFromMatrix3Column(this, 2);
			return this;
		}

		setFromMatrix4(m) {
			const me = m.elements;
			this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
			return this;
		}

		multiply(m) {
			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[3],
						a13 = ae[6];
			const a21 = ae[1],
						a22 = ae[4],
						a23 = ae[7];
			const a31 = ae[2],
						a32 = ae[5],
						a33 = ae[8];
			const b11 = be[0],
						b12 = be[3],
						b13 = be[6];
			const b21 = be[1],
						b22 = be[4],
						b23 = be[7];
			const b31 = be[2],
						b32 = be[5],
						b33 = be[8];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31;
			te[3] = a11 * b12 + a12 * b22 + a13 * b32;
			te[6] = a11 * b13 + a12 * b23 + a13 * b33;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31;
			te[4] = a21 * b12 + a22 * b22 + a23 * b32;
			te[7] = a21 * b13 + a22 * b23 + a23 * b33;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31;
			te[5] = a31 * b12 + a32 * b22 + a33 * b32;
			te[8] = a31 * b13 + a32 * b23 + a33 * b33;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[3] *= s;
			te[6] *= s;
			te[1] *= s;
			te[4] *= s;
			te[7] *= s;
			te[2] *= s;
			te[5] *= s;
			te[8] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const a = te[0],
						b = te[1],
						c = te[2],
						d = te[3],
						e = te[4],
						f = te[5],
						g = te[6],
						h = te[7],
						i = te[8];
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
		}

		invert() {
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n12 = te[3],
						n22 = te[4],
						n32 = te[5],
						n13 = te[6],
						n23 = te[7],
						n33 = te[8],
						t11 = n33 * n22 - n32 * n23,
						t12 = n32 * n13 - n33 * n12,
						t13 = n23 * n12 - n22 * n13,
						det = n11 * t11 + n21 * t12 + n31 * t13;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n31 * n23 - n33 * n21) * detInv;
			te[2] = (n32 * n21 - n31 * n22) * detInv;
			te[3] = t12 * detInv;
			te[4] = (n33 * n11 - n31 * n13) * detInv;
			te[5] = (n31 * n12 - n32 * n11) * detInv;
			te[6] = t13 * detInv;
			te[7] = (n21 * n13 - n23 * n11) * detInv;
			te[8] = (n22 * n11 - n21 * n12) * detInv;
			return this;
		}

		transpose() {
			let tmp;
			const m = this.elements;
			tmp = m[1];
			m[1] = m[3];
			m[3] = tmp;
			tmp = m[2];
			m[2] = m[6];
			m[6] = tmp;
			tmp = m[5];
			m[5] = m[7];
			m[7] = tmp;
			return this;
		}

		getNormalMatrix(matrix4) {
			return this.setFromMatrix4(matrix4).invert().transpose();
		}

		transposeIntoArray(r) {
			const m = this.elements;
			r[0] = m[0];
			r[1] = m[3];
			r[2] = m[6];
			r[3] = m[1];
			r[4] = m[4];
			r[5] = m[7];
			r[6] = m[2];
			r[7] = m[5];
			r[8] = m[8];
			return this;
		}

		setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
			const c = Math.cos(rotation);
			const s = Math.sin(rotation);
			this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
			return this;
		}

		scale(sx, sy) {
			const te = this.elements;
			te[0] *= sx;
			te[3] *= sx;
			te[6] *= sx;
			te[1] *= sy;
			te[4] *= sy;
			te[7] *= sy;
			return this;
		}

		rotate(theta) {
			const c = Math.cos(theta);
			const s = Math.sin(theta);
			const te = this.elements;
			const a11 = te[0],
						a12 = te[3],
						a13 = te[6];
			const a21 = te[1],
						a22 = te[4],
						a23 = te[7];
			te[0] = c * a11 + s * a21;
			te[3] = c * a12 + s * a22;
			te[6] = c * a13 + s * a23;
			te[1] = -s * a11 + c * a21;
			te[4] = -s * a12 + c * a22;
			te[7] = -s * a13 + c * a23;
			return this;
		}

		translate(tx, ty) {
			const te = this.elements;
			te[0] += tx * te[2];
			te[3] += tx * te[5];
			te[6] += tx * te[8];
			te[1] += ty * te[2];
			te[4] += ty * te[5];
			te[7] += ty * te[8];
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 9; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 9; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			return array;
		}

		clone() {
			return new this.constructor().fromArray(this.elements);
		}

	}

	Matrix3.prototype.isMatrix3 = true;

	let _canvas;

	class ImageUtils {
		static getDataURL(image) {
			if (/^data:/i.test(image.src)) {
				return image.src;
			}

			if (typeof HTMLCanvasElement == 'undefined') {
				return image.src;
			}

			let canvas;

			if (image instanceof HTMLCanvasElement) {
				canvas = image;
			} else {
				if (_canvas === undefined) _canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext('2d');

				if (image instanceof ImageData) {
					context.putImageData(image, 0, 0);
				} else {
					context.drawImage(image, 0, 0, image.width, image.height);
				}

				canvas = _canvas;
			}

			if (canvas.width > 2048 || canvas.height > 2048) {
				console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
				return canvas.toDataURL('image/jpeg', 0.6);
			} else {
				return canvas.toDataURL('image/png');
			}
		}

	}

	let textureId = 0;

	class Texture extends EventDispatcher {
		constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
			super();
			Object.defineProperty(this, 'id', {
				value: textureId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.image = image;
			this.mipmaps = [];
			this.mapping = mapping;
			this.wrapS = wrapS;
			this.wrapT = wrapT;
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.anisotropy = anisotropy;
			this.format = format;
			this.internalFormat = null;
			this.type = type;
			this.offset = new Vector2(0, 0);
			this.repeat = new Vector2(1, 1);
			this.center = new Vector2(0, 0);
			this.rotation = 0;
			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.

			this.encoding = encoding;
			this.version = 0;
			this.onUpdate = null;
			this.isRenderTargetTexture = false;
		}

		updateMatrix() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice(0);
			this.mapping = source.mapping;
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
			this.anisotropy = source.anisotropy;
			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;
			this.offset.copy(source.offset);
			this.repeat.copy(source.repeat);
			this.center.copy(source.center);
			this.rotation = source.rotation;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy(source.matrix);
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
			return this;
		}

		toJSON(meta) {
			const isRootObject = meta === undefined || typeof meta === 'string';

			if (!isRootObject && meta.textures[this.uuid] !== undefined) {
				return meta.textures[this.uuid];
			}

			const output = {
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};

			if (this.image !== undefined) {
				// TODO: Move to THREE.Image
				const image = this.image;

				if (image.uuid === undefined) {
					image.uuid = generateUUID(); // UGH
				}

				if (!isRootObject && meta.images[image.uuid] === undefined) {
					let url;

					if (Array.isArray(image)) {
						// process array of images e.g. CubeTexture
						url = [];

						for (let i = 0, l = image.length; i < l; i++) {
							// check cube texture with data textures
							if (image[i].isDataTexture) {
								url.push(serializeImage(image[i].image));
							} else {
								url.push(serializeImage(image[i]));
							}
						}
					} else {
						// process single image
						url = serializeImage(image);
					}

					meta.images[image.uuid] = {
						uuid: image.uuid,
						url: url
					};
				}

				output.image = image.uuid;
			}

			if (!isRootObject) {
				meta.textures[this.uuid] = output;
			}

			return output;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		transformUv(uv) {
			if (this.mapping !== UVMapping) return uv;
			uv.applyMatrix3(this.matrix);

			if (uv.x < 0 || uv.x > 1) {
				switch (this.wrapS) {
					case RepeatWrapping:
						uv.x = uv.x - Math.floor(uv.x);
						break;

					case ClampToEdgeWrapping:
						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.x) % 2) === 1) {
							uv.x = Math.ceil(uv.x) - uv.x;
						} else {
							uv.x = uv.x - Math.floor(uv.x);
						}

						break;
				}
			}

			if (uv.y < 0 || uv.y > 1) {
				switch (this.wrapT) {
					case RepeatWrapping:
						uv.y = uv.y - Math.floor(uv.y);
						break;

					case ClampToEdgeWrapping:
						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:
						if (Math.abs(Math.floor(uv.y) % 2) === 1) {
							uv.y = Math.ceil(uv.y) - uv.y;
						} else {
							uv.y = uv.y - Math.floor(uv.y);
						}

						break;
				}
			}

			if (this.flipY) {
				uv.y = 1 - uv.y;
			}

			return uv;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype.isTexture = true;

	function serializeImage(image) {
		if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
			// default images
			return ImageUtils.getDataURL(image);
		} else {
			if (image.data) {
				// images of DataTexture
				return {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};
			} else {
				console.warn('THREE.Texture: Unable to serialize Texture.');
				return {};
			}
		}
	}

	class Vector4 {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}

		get width() {
			return this.z;
		}

		set width(value) {
			this.z = value;
		}

		get height() {
			return this.w;
		}

		set height(value) {
			this.w = value;
		}

		set(x, y, z, w) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setW(w) {
			this.w = w;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				case 3:
					this.w = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				case 3:
					return this.w;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z, this.w);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = v.w !== undefined ? v.w : 1;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this;
		}

		multiply(v) {
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
			return this;
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z,
						w = this.w;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
			this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
			this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
			this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		setAxisAngleFromQuaternion(q) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
			// q is assumed to be normalized
			this.w = 2 * Math.acos(q.w);
			const s = Math.sqrt(1 - q.w * q.w);

			if (s < 0.0001) {
				this.x = 1;
				this.y = 0;
				this.z = 0;
			} else {
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
			}

			return this;
		}

		setAxisAngleFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			let angle, x, y, z; // variables for result

			const epsilon = 0.01,
						// margin to allow for rounding errors
			epsilon2 = 0.1,
						// margin to distinguish between 0 and 180 degrees
			te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
				if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
					// this singularity is identity matrix so angle = 0
					this.set(1, 0, 0, 0);
					return this; // zero angle, arbitrary axis
				} // otherwise this singularity is angle = 180


				angle = Math.PI;
				const xx = (m11 + 1) / 2;
				const yy = (m22 + 1) / 2;
				const zz = (m33 + 1) / 2;
				const xy = (m12 + m21) / 4;
				const xz = (m13 + m31) / 4;
				const yz = (m23 + m32) / 4;

				if (xx > yy && xx > zz) {
					// m11 is the largest diagonal term
					if (xx < epsilon) {
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
					} else {
						x = Math.sqrt(xx);
						y = xy / x;
						z = xz / x;
					}
				} else if (yy > zz) {
					// m22 is the largest diagonal term
					if (yy < epsilon) {
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
					} else {
						y = Math.sqrt(yy);
						x = xy / y;
						z = yz / y;
					}
				} else {
					// m33 is the largest diagonal term so base result on this
					if (zz < epsilon) {
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
					} else {
						z = Math.sqrt(zz);
						x = xz / z;
						y = yz / z;
					}
				}

				this.set(x, y, z, angle);
				return this; // return 180 deg rotation
			} // as we have reached here there are no singularities so we can handle normally


			let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

			if (Math.abs(s) < 0.001) s = 1; // prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = (m32 - m23) / s;
			this.y = (m13 - m31) / s;
			this.z = (m21 - m12) / s;
			this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
			return this;
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			this.w = Math.min(this.w, v.w);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			this.w = Math.max(this.w, v.w);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			this.w = Math.max(min.w, Math.min(max.w, this.w));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			this.w = Math.max(minVal, Math.min(maxVal, this.w));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w = Math.round(this.w);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
		}

		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			this.w += (v.w - this.w) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			this.w = v1.w + (v2.w - v1.w) * alpha;
			return this;
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			this.w = array[offset + 3];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			array[offset + 3] = this.w;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			this.w = attribute.getW(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();
			return this;
		}

	}

	Vector4.prototype.isVector4 = true;

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/

	class WebGLRenderTarget extends EventDispatcher {
		constructor(width, height, options = {}) {
			super();
			this.width = width;
			this.height = height;
			this.depth = 1;
			this.scissor = new Vector4(0, 0, width, height);
			this.scissorTest = false;
			this.viewport = new Vector4(0, 0, width, height);
			this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.image = {
				width: width,
				height: height,
				depth: 1
			};
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
		}

		setTexture(texture) {
			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};
			this.texture = texture;
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;
				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;
				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.copy(source.viewport);
			this.texture = source.texture.clone();
			this.texture.image = { ...this.texture.image
			}; // See #20328.

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	class WebGLMultipleRenderTargets extends WebGLRenderTarget {
		constructor(width, height, count) {
			super(width, height);
			const texture = this.texture;
			this.texture = [];

			for (let i = 0; i < count; i++) {
				this.texture[i] = texture.clone();
			}
		}

		setSize(width, height, depth = 1) {
			if (this.width !== width || this.height !== height || this.depth !== depth) {
				this.width = width;
				this.height = height;
				this.depth = depth;

				for (let i = 0, il = this.texture.length; i < il; i++) {
					this.texture[i].image.width = width;
					this.texture[i].image.height = height;
					this.texture[i].image.depth = depth;
				}

				this.dispose();
			}

			this.viewport.set(0, 0, width, height);
			this.scissor.set(0, 0, width, height);
			return this;
		}

		copy(source) {
			this.dispose();
			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;
			this.viewport.set(0, 0, this.width, this.height);
			this.scissor.set(0, 0, this.width, this.height);
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
			this.texture.length = 0;

			for (let i = 0, il = source.texture.length; i < il; i++) {
				this.texture[i] = source.texture[i].clone();
			}

			return this;
		}

	}

	WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;

	class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
		constructor(width, height, options) {
			super(width, height, options);
			this.samples = 4;
		}

		copy(source) {
			super.copy.call(this, source);
			this.samples = source.samples;
			return this;
		}

	}

	WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

	class Quaternion {
		constructor(x = 0, y = 0, z = 0, w = 1) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
		}

		static slerp(qa, qb, qm, t) {
			console.warn('THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.');
			return qm.slerpQuaternions(qa, qb, t);
		}

		static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
			// fuzz-free, array-based Quaternion SLERP operation
			let x0 = src0[srcOffset0 + 0],
					y0 = src0[srcOffset0 + 1],
					z0 = src0[srcOffset0 + 2],
					w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1 + 0],
						y1 = src1[srcOffset1 + 1],
						z1 = src1[srcOffset1 + 2],
						w1 = src1[srcOffset1 + 3];

			if (t === 0) {
				dst[dstOffset + 0] = x0;
				dst[dstOffset + 1] = y0;
				dst[dstOffset + 2] = z0;
				dst[dstOffset + 3] = w0;
				return;
			}

			if (t === 1) {
				dst[dstOffset + 0] = x1;
				dst[dstOffset + 1] = y1;
				dst[dstOffset + 2] = z1;
				dst[dstOffset + 3] = w1;
				return;
			}

			if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
							dir = cos >= 0 ? 1 : -1,
							sqrSin = 1 - cos * cos; // Skip the Slerp for tiny steps to avoid numeric problems:

				if (sqrSin > Number.EPSILON) {
					const sin = Math.sqrt(sqrSin),
								len = Math.atan2(sin, cos * dir);
					s = Math.sin(s * len) / sin;
					t = Math.sin(t * len) / sin;
				}

				const tDir = t * dir;
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir; // Normalize in case we just did a lerp:

				if (s === 1 - t) {
					const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
				}
			}

			dst[dstOffset] = x0;
			dst[dstOffset + 1] = y0;
			dst[dstOffset + 2] = z0;
			dst[dstOffset + 3] = w0;
		}

		static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
			const x0 = src0[srcOffset0];
			const y0 = src0[srcOffset0 + 1];
			const z0 = src0[srcOffset0 + 2];
			const w0 = src0[srcOffset0 + 3];
			const x1 = src1[srcOffset1];
			const y1 = src1[srcOffset1 + 1];
			const z1 = src1[srcOffset1 + 2];
			const w1 = src1[srcOffset1 + 3];
			dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
			return dst;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get w() {
			return this._w;
		}

		set w(value) {
			this._w = value;

			this._onChangeCallback();
		}

		set(x, y, z, w) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._w);
		}

		copy(quaternion) {
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;
		}

		setFromEuler(euler, update) {
			if (!(euler && euler.isEuler)) {
				throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			const x = euler._x,
						y = euler._y,
						z = euler._z,
						order = euler._order; // http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;
			const c1 = cos(x / 2);
			const c2 = cos(y / 2);
			const c3 = cos(z / 2);
			const s1 = sin(x / 2);
			const s2 = sin(y / 2);
			const s3 = sin(z / 2);

			switch (order) {
				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
			}

			if (update !== false) this._onChangeCallback();
			return this;
		}

		setFromAxisAngle(axis, angle) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
			// assumes axis is normalized
			const halfAngle = angle / 2,
						s = Math.sin(halfAngle);
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos(halfAngle);

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m) {
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements,
						m11 = te[0],
						m12 = te[4],
						m13 = te[8],
						m21 = te[1],
						m22 = te[5],
						m23 = te[9],
						m31 = te[2],
						m32 = te[6],
						m33 = te[10],
						trace = m11 + m22 + m33;

			if (trace > 0) {
				const s = 0.5 / Math.sqrt(trace + 1.0);
				this._w = 0.25 / s;
				this._x = (m32 - m23) * s;
				this._y = (m13 - m31) * s;
				this._z = (m21 - m12) * s;
			} else if (m11 > m22 && m11 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
				this._w = (m32 - m23) / s;
				this._x = 0.25 * s;
				this._y = (m12 + m21) / s;
				this._z = (m13 + m31) / s;
			} else if (m22 > m33) {
				const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
				this._w = (m13 - m31) / s;
				this._x = (m12 + m21) / s;
				this._y = 0.25 * s;
				this._z = (m23 + m32) / s;
			} else {
				const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
				this._w = (m21 - m12) / s;
				this._x = (m13 + m31) / s;
				this._y = (m23 + m32) / s;
				this._z = 0.25 * s;
			}

			this._onChangeCallback();

			return this;
		}

		setFromUnitVectors(vFrom, vTo) {
			// assumes direction vectors vFrom and vTo are normalized
			let r = vFrom.dot(vTo) + 1;

			if (r < Number.EPSILON) {
				// vFrom and vTo point in opposite directions
				r = 0;

				if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
					this._x = -vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;
				} else {
					this._x = 0;
					this._y = -vFrom.z;
					this._z = vFrom.y;
					this._w = r;
				}
			} else {
				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;
			}

			return this.normalize();
		}

		angleTo(q) {
			return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
		}

		rotateTowards(q, step) {
			const angle = this.angleTo(q);
			if (angle === 0) return this;
			const t = Math.min(1, step / angle);
			this.slerp(q, t);
			return this;
		}

		identity() {
			return this.set(0, 0, 0, 1);
		}

		invert() {
			// quaternion is assumed to have unit length
			return this.conjugate();
		}

		conjugate() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;

			this._onChangeCallback();

			return this;
		}

		dot(v) {
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
		}

		lengthSq() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
		}

		length() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
		}

		normalize() {
			let l = this.length();

			if (l === 0) {
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
			} else {
				l = 1 / l;
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
			}

			this._onChangeCallback();

			return this;
		}

		multiply(q, p) {
			if (p !== undefined) {
				console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');
				return this.multiplyQuaternions(q, p);
			}

			return this.multiplyQuaternions(this, q);
		}

		premultiply(q) {
			return this.multiplyQuaternions(q, this);
		}

		multiplyQuaternions(a, b) {
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
			const qax = a._x,
						qay = a._y,
						qaz = a._z,
						qaw = a._w;
			const qbx = b._x,
						qby = b._y,
						qbz = b._z,
						qbw = b._w;
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;
		}

		slerp(qb, t) {
			if (t === 0) return this;
			if (t === 1) return this.copy(qb);
			const x = this._x,
						y = this._y,
						z = this._z,
						w = this._w; // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if (cosHalfTheta < 0) {
				this._w = -qb._w;
				this._x = -qb._x;
				this._y = -qb._y;
				this._z = -qb._z;
				cosHalfTheta = -cosHalfTheta;
			} else {
				this.copy(qb);
			}

			if (cosHalfTheta >= 1.0) {
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
				return this;
			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if (sqrSinHalfTheta <= Number.EPSILON) {
				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
				this.normalize();

				this._onChangeCallback();

				return this;
			}

			const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
			const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
			const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
						ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
			this._w = w * ratioA + this._w * ratioB;
			this._x = x * ratioA + this._x * ratioB;
			this._y = y * ratioA + this._y * ratioB;
			this._z = z * ratioA + this._z * ratioB;

			this._onChangeCallback();

			return this;
		}

		slerpQuaternions(qa, qb, t) {
			this.copy(qa).slerp(qb, t);
		}

		equals(quaternion) {
			return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
		}

		fromArray(array, offset = 0) {
			this._x = array[offset];
			this._y = array[offset + 1];
			this._z = array[offset + 2];
			this._w = array[offset + 3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._w;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this._x = attribute.getX(index);
			this._y = attribute.getY(index);
			this._z = attribute.getZ(index);
			this._w = attribute.getW(index);
			return this;
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Quaternion.prototype.isQuaternion = true;

	class Vector3 {
		constructor(x = 0, y = 0, z = 0) {
			this.x = x;
			this.y = y;
			this.z = z;
		}

		set(x, y, z) {
			if (z === undefined) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;
			return this;
		}

		setScalar(scalar) {
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			return this;
		}

		setX(x) {
			this.x = x;
			return this;
		}

		setY(y) {
			this.y = y;
			return this;
		}

		setZ(z) {
			this.z = z;
			return this;
		}

		setComponent(index, value) {
			switch (index) {
				case 0:
					this.x = value;
					break;

				case 1:
					this.y = value;
					break;

				case 2:
					this.z = value;
					break;

				default:
					throw new Error('index is out of range: ' + index);
			}

			return this;
		}

		getComponent(index) {
			switch (index) {
				case 0:
					return this.x;

				case 1:
					return this.y;

				case 2:
					return this.z;

				default:
					throw new Error('index is out of range: ' + index);
			}
		}

		clone() {
			return new this.constructor(this.x, this.y, this.z);
		}

		copy(v) {
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			return this;
		}

		add(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');
				return this.addVectors(v, w);
			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			return this;
		}

		addScalar(s) {
			this.x += s;
			this.y += s;
			this.z += s;
			return this;
		}

		addVectors(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this;
		}

		addScaledVector(v, s) {
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			return this;
		}

		sub(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');
				return this.subVectors(v, w);
			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			return this;
		}

		subScalar(s) {
			this.x -= s;
			this.y -= s;
			this.z -= s;
			return this;
		}

		subVectors(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this;
		}

		multiply(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');
				return this.multiplyVectors(v, w);
			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			return this;
		}

		multiplyScalar(scalar) {
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			return this;
		}

		multiplyVectors(a, b) {
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this;
		}

		applyEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');
			}

			return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
		}

		applyAxisAngle(axis, angle) {
			return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
		}

		applyMatrix3(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[3] * y + e[6] * z;
			this.y = e[1] * x + e[4] * y + e[7] * z;
			this.z = e[2] * x + e[5] * y + e[8] * z;
			return this;
		}

		applyNormalMatrix(m) {
			return this.applyMatrix3(m).normalize();
		}

		applyMatrix4(m) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
			this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
			this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
			this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
			return this;
		}

		applyQuaternion(q) {
			const x = this.x,
						y = this.y,
						z = this.z;
			const qx = q.x,
						qy = q.y,
						qz = q.z,
						qw = q.w; // calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

			this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
			this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
			this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
			return this;
		}

		project(camera) {
			return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
		}

		unproject(camera) {
			return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
		}

		transformDirection(m) {
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
			const x = this.x,
						y = this.y,
						z = this.z;
			const e = m.elements;
			this.x = e[0] * x + e[4] * y + e[8] * z;
			this.y = e[1] * x + e[5] * y + e[9] * z;
			this.z = e[2] * x + e[6] * y + e[10] * z;
			return this.normalize();
		}

		divide(v) {
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
			return this;
		}

		divideScalar(scalar) {
			return this.multiplyScalar(1 / scalar);
		}

		min(v) {
			this.x = Math.min(this.x, v.x);
			this.y = Math.min(this.y, v.y);
			this.z = Math.min(this.z, v.z);
			return this;
		}

		max(v) {
			this.x = Math.max(this.x, v.x);
			this.y = Math.max(this.y, v.y);
			this.z = Math.max(this.z, v.z);
			return this;
		}

		clamp(min, max) {
			// assumes min < max, componentwise
			this.x = Math.max(min.x, Math.min(max.x, this.x));
			this.y = Math.max(min.y, Math.min(max.y, this.y));
			this.z = Math.max(min.z, Math.min(max.z, this.z));
			return this;
		}

		clampScalar(minVal, maxVal) {
			this.x = Math.max(minVal, Math.min(maxVal, this.x));
			this.y = Math.max(minVal, Math.min(maxVal, this.y));
			this.z = Math.max(minVal, Math.min(maxVal, this.z));
			return this;
		}

		clampLength(min, max) {
			const length = this.length();
			return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
		}

		floor() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this;
		}

		ceil() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this;
		}

		round() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this;
		}

		roundToZero() {
			this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
			return this;
		}

		negate() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this;
		}

		dot(v) {
			return this.x * v.x + this.y * v.y + this.z * v.z;
		} // TODO lengthSquared?


		lengthSq() {
			return this.x * this.x + this.y * this.y + this.z * this.z;
		}

		length() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
		}

		manhattanLength() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
		}

		normalize() {
			return this.divideScalar(this.length() || 1);
		}

		setLength(length) {
			return this.normalize().multiplyScalar(length);
		}

		lerp(v, alpha) {
			this.x += (v.x - this.x) * alpha;
			this.y += (v.y - this.y) * alpha;
			this.z += (v.z - this.z) * alpha;
			return this;
		}

		lerpVectors(v1, v2, alpha) {
			this.x = v1.x + (v2.x - v1.x) * alpha;
			this.y = v1.y + (v2.y - v1.y) * alpha;
			this.z = v1.z + (v2.z - v1.z) * alpha;
			return this;
		}

		cross(v, w) {
			if (w !== undefined) {
				console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');
				return this.crossVectors(v, w);
			}

			return this.crossVectors(this, v);
		}

		crossVectors(a, b) {
			const ax = a.x,
						ay = a.y,
						az = a.z;
			const bx = b.x,
						by = b.y,
						bz = b.z;
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
			return this;
		}

		projectOnVector(v) {
			const denominator = v.lengthSq();
			if (denominator === 0) return this.set(0, 0, 0);
			const scalar = v.dot(this) / denominator;
			return this.copy(v).multiplyScalar(scalar);
		}

		projectOnPlane(planeNormal) {
			_vector$c.copy(this).projectOnVector(planeNormal);

			return this.sub(_vector$c);
		}

		reflect(normal) {
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
			return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
		}

		angleTo(v) {
			const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
			if (denominator === 0) return Math.PI / 2;
			const theta = this.dot(v) / denominator; // clamp, to handle numerical problems

			return Math.acos(clamp(theta, -1, 1));
		}

		distanceTo(v) {
			return Math.sqrt(this.distanceToSquared(v));
		}

		distanceToSquared(v) {
			const dx = this.x - v.x,
						dy = this.y - v.y,
						dz = this.z - v.z;
			return dx * dx + dy * dy + dz * dz;
		}

		manhattanDistanceTo(v) {
			return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
		}

		setFromSpherical(s) {
			return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
		}

		setFromSphericalCoords(radius, phi, theta) {
			const sinPhiRadius = Math.sin(phi) * radius;
			this.x = sinPhiRadius * Math.sin(theta);
			this.y = Math.cos(phi) * radius;
			this.z = sinPhiRadius * Math.cos(theta);
			return this;
		}

		setFromCylindrical(c) {
			return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
		}

		setFromCylindricalCoords(radius, theta, y) {
			this.x = radius * Math.sin(theta);
			this.y = y;
			this.z = radius * Math.cos(theta);
			return this;
		}

		setFromMatrixPosition(m) {
			const e = m.elements;
			this.x = e[12];
			this.y = e[13];
			this.z = e[14];
			return this;
		}

		setFromMatrixScale(m) {
			const sx = this.setFromMatrixColumn(m, 0).length();
			const sy = this.setFromMatrixColumn(m, 1).length();
			const sz = this.setFromMatrixColumn(m, 2).length();
			this.x = sx;
			this.y = sy;
			this.z = sz;
			return this;
		}

		setFromMatrixColumn(m, index) {
			return this.fromArray(m.elements, index * 4);
		}

		setFromMatrix3Column(m, index) {
			return this.fromArray(m.elements, index * 3);
		}

		equals(v) {
			return v.x === this.x && v.y === this.y && v.z === this.z;
		}

		fromArray(array, offset = 0) {
			this.x = array[offset];
			this.y = array[offset + 1];
			this.z = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.x;
			array[offset + 1] = this.y;
			array[offset + 2] = this.z;
			return array;
		}

		fromBufferAttribute(attribute, index, offset) {
			if (offset !== undefined) {
				console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');
			}

			this.x = attribute.getX(index);
			this.y = attribute.getY(index);
			this.z = attribute.getZ(index);
			return this;
		}

		random() {
			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			return this;
		}

	}

	Vector3.prototype.isVector3 = true;

	const _vector$c = /*@__PURE__*/new Vector3();

	const _quaternion$4 = /*@__PURE__*/new Quaternion();

	class Box3 {
		constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromArray(array) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = array.length; i < l; i += 3) {
				const x = array[i];
				const y = array[i + 1];
				const z = array[i + 2];
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromBufferAttribute(attribute) {
			let minX = +Infinity;
			let minY = +Infinity;
			let minZ = +Infinity;
			let maxX = -Infinity;
			let maxY = -Infinity;
			let maxZ = -Infinity;

			for (let i = 0, l = attribute.count; i < l; i++) {
				const x = attribute.getX(i);
				const y = attribute.getY(i);
				const z = attribute.getZ(i);
				if (x < minX) minX = x;
				if (y < minY) minY = y;
				if (z < minZ) minZ = z;
				if (x > maxX) maxX = x;
				if (y > maxY) maxY = y;
				if (z > maxZ) maxZ = z;
			}

			this.min.set(minX, minY, minZ);
			this.max.set(maxX, maxY, maxZ);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$b.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		setFromObject(object) {
			this.makeEmpty();
			return this.expandByObject(object);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = this.min.z = +Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
		}

		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		expandByObject(object) {
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
			object.updateWorldMatrix(false, false);
			const geometry = object.geometry;

			if (geometry !== undefined) {
				if (geometry.boundingBox === null) {
					geometry.computeBoundingBox();
				}

				_box$3.copy(geometry.boundingBox);

				_box$3.applyMatrix4(object.matrixWorld);

				this.union(_box$3);
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				this.expandByObject(children[i]);
			}

			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
		}

		intersectsBox(box) {
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
		}

		intersectsSphere(sphere) {
			// Find the point on the AABB closest to the sphere center.
			this.clampPoint(sphere.center, _vector$b); // If that point is inside the sphere, the AABB and sphere intersect.

			return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
		}

		intersectsPlane(plane) {
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
			let min, max;

			if (plane.normal.x > 0) {
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
			} else {
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
			}

			if (plane.normal.y > 0) {
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
			} else {
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
			}

			if (plane.normal.z > 0) {
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
			} else {
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
			}

			return min <= -plane.constant && max >= -plane.constant;
		}

		intersectsTriangle(triangle) {
			if (this.isEmpty()) {
				return false;
			} // compute box center and extents


			this.getCenter(_center);

			_extents.subVectors(this.max, _center); // translate triangle to aabb origin


			_v0$2.subVectors(triangle.a, _center);

			_v1$7.subVectors(triangle.b, _center);

			_v2$3.subVectors(triangle.c, _center); // compute edge vectors for triangle


			_f0.subVectors(_v1$7, _v0$2);

			_f1.subVectors(_v2$3, _v1$7);

			_f2.subVectors(_v0$2, _v2$3); // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)


			let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // test 3 face normals from the aabb


			axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];

			if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
				return false;
			} // finally testing the face normal of the triangle
			// use already existing triangle edge vectors here


			_triangleNormal.crossVectors(_f0, _f1);

			axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
			return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
		}

		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		getBoundingSphere(target) {
			this.getCenter(target.center);
			target.radius = this.getSize(_vector$b).length() * 0.5;
			return target;
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max); // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.

			if (this.isEmpty()) this.makeEmpty();
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		applyMatrix4(matrix) {
			// transform of empty box is an empty box.
			if (this.isEmpty()) return this; // NOTE: I am using a binary pattern to specify all 2^3 combinations below

			_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000


			_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001


			_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010


			_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011


			_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100


			_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101


			_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110


			_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111


			this.setFromPoints(_points);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box3.prototype.isBox3 = true;
	const _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];

	const _vector$b = /*@__PURE__*/new Vector3();

	const _box$3 = /*@__PURE__*/new Box3(); // triangle centered vertices


	const _v0$2 = /*@__PURE__*/new Vector3();

	const _v1$7 = /*@__PURE__*/new Vector3();

	const _v2$3 = /*@__PURE__*/new Vector3(); // triangle edge vectors


	const _f0 = /*@__PURE__*/new Vector3();

	const _f1 = /*@__PURE__*/new Vector3();

	const _f2 = /*@__PURE__*/new Vector3();

	const _center = /*@__PURE__*/new Vector3();

	const _extents = /*@__PURE__*/new Vector3();

	const _triangleNormal = /*@__PURE__*/new Vector3();

	const _testAxis = /*@__PURE__*/new Vector3();

	function satForAxes(axes, v0, v1, v2, extents) {
		for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
			_testAxis.fromArray(axes, i); // project the aabb onto the seperating axis


			const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z); // project all 3 vertices of the triangle onto the seperating axis

			const p0 = v0.dot(_testAxis);
			const p1 = v1.dot(_testAxis);
			const p2 = v2.dot(_testAxis); // actual test, basically see if either of the most extreme of the triangle points intersects r

			if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;
			}
		}

		return true;
	}

	const _box$2 = /*@__PURE__*/new Box3();

	const _v1$6 = /*@__PURE__*/new Vector3();

	const _toFarthestPoint = /*@__PURE__*/new Vector3();

	const _toPoint = /*@__PURE__*/new Vector3();

	class Sphere {
		constructor(center = new Vector3(), radius = -1) {
			this.center = center;
			this.radius = radius;
		}

		set(center, radius) {
			this.center.copy(center);
			this.radius = radius;
			return this;
		}

		setFromPoints(points, optionalCenter) {
			const center = this.center;

			if (optionalCenter !== undefined) {
				center.copy(optionalCenter);
			} else {
				_box$2.setFromPoints(points).getCenter(center);
			}

			let maxRadiusSq = 0;

			for (let i = 0, il = points.length; i < il; i++) {
				maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
			}

			this.radius = Math.sqrt(maxRadiusSq);
			return this;
		}

		copy(sphere) {
			this.center.copy(sphere.center);
			this.radius = sphere.radius;
			return this;
		}

		isEmpty() {
			return this.radius < 0;
		}

		makeEmpty() {
			this.center.set(0, 0, 0);
			this.radius = -1;
			return this;
		}

		containsPoint(point) {
			return point.distanceToSquared(this.center) <= this.radius * this.radius;
		}

		distanceToPoint(point) {
			return point.distanceTo(this.center) - this.radius;
		}

		intersectsSphere(sphere) {
			const radiusSum = this.radius + sphere.radius;
			return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
		}

		intersectsBox(box) {
			return box.intersectsSphere(this);
		}

		intersectsPlane(plane) {
			return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
		}

		clampPoint(point, target) {
			const deltaLengthSq = this.center.distanceToSquared(point);
			target.copy(point);

			if (deltaLengthSq > this.radius * this.radius) {
				target.sub(this.center).normalize();
				target.multiplyScalar(this.radius).add(this.center);
			}

			return target;
		}

		getBoundingBox(target) {
			if (this.isEmpty()) {
				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;
			}

			target.set(this.center, this.center);
			target.expandByScalar(this.radius);
			return target;
		}

		applyMatrix4(matrix) {
			this.center.applyMatrix4(matrix);
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
			return this;
		}

		translate(offset) {
			this.center.add(offset);
			return this;
		}

		expandByPoint(point) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671
			_toPoint.subVectors(point, this.center);

			const lengthSq = _toPoint.lengthSq();

			if (lengthSq > this.radius * this.radius) {
				const length = Math.sqrt(lengthSq);
				const missingRadiusHalf = (length - this.radius) * 0.5; // Nudge this sphere towards the target point. Add half the missing distance to radius,
				// and the other half to position. This gives a tighter enclosure, instead of if
				// the whole missing distance were just added to radius.

				this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
				this.radius += missingRadiusHalf;
			}

			return this;
		}

		union(sphere) {
			// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769
			// To enclose another sphere into this sphere, we only need to enclose two points:
			// 1) Enclose the farthest point on the other sphere into this sphere.
			// 2) Enclose the opposite point of the farthest point into this sphere.
			_toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);

			this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
			this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
			return this;
		}

		equals(sphere) {
			return sphere.center.equals(this.center) && sphere.radius === this.radius;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$a = /*@__PURE__*/new Vector3();

	const _segCenter = /*@__PURE__*/new Vector3();

	const _segDir = /*@__PURE__*/new Vector3();

	const _diff = /*@__PURE__*/new Vector3();

	const _edge1 = /*@__PURE__*/new Vector3();

	const _edge2 = /*@__PURE__*/new Vector3();

	const _normal$1 = /*@__PURE__*/new Vector3();

	class Ray {
		constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
			this.origin = origin;
			this.direction = direction;
		}

		set(origin, direction) {
			this.origin.copy(origin);
			this.direction.copy(direction);
			return this;
		}

		copy(ray) {
			this.origin.copy(ray.origin);
			this.direction.copy(ray.direction);
			return this;
		}

		at(t, target) {
			return target.copy(this.direction).multiplyScalar(t).add(this.origin);
		}

		lookAt(v) {
			this.direction.copy(v).sub(this.origin).normalize();
			return this;
		}

		recast(t) {
			this.origin.copy(this.at(t, _vector$a));
			return this;
		}

		closestPointToPoint(point, target) {
			target.subVectors(point, this.origin);
			const directionDistance = target.dot(this.direction);

			if (directionDistance < 0) {
				return target.copy(this.origin);
			}

			return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
		}

		distanceToPoint(point) {
			return Math.sqrt(this.distanceSqToPoint(point));
		}

		distanceSqToPoint(point) {
			const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction); // point behind the ray


			if (directionDistance < 0) {
				return this.origin.distanceToSquared(point);
			}

			_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);

			return _vector$a.distanceToSquared(point);
		}

		distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment
			_segCenter.copy(v0).add(v1).multiplyScalar(0.5);

			_segDir.copy(v1).sub(v0).normalize();

			_diff.copy(this.origin).sub(_segCenter);

			const segExtent = v0.distanceTo(v1) * 0.5;
			const a01 = -this.direction.dot(_segDir);

			const b0 = _diff.dot(this.direction);

			const b1 = -_diff.dot(_segDir);

			const c = _diff.lengthSq();

			const det = Math.abs(1 - a01 * a01);
			let s0, s1, sqrDist, extDet;

			if (det > 0) {
				// The ray and segment are not parallel.
				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if (s0 >= 0) {
					if (s1 >= -extDet) {
						if (s1 <= extDet) {
							// region 0
							// Minimum at interior points of ray and segment.
							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
						} else {
							// region 1
							s1 = segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}
					} else {
						// region 5
						s1 = -segExtent;
						s0 = Math.max(0, -(a01 * s1 + b0));
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				} else {
					if (s1 <= -extDet) {
						// region 4
						s0 = Math.max(0, -(-a01 * segExtent + b0));
						s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					} else if (s1 <= extDet) {
						// region 3
						s0 = 0;
						s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = s1 * (s1 + 2 * b1) + c;
					} else {
						// region 2
						s0 = Math.max(0, -(a01 * segExtent + b0));
						s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
						sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
					}
				}
			} else {
				// Ray and segment are parallel.
				s1 = a01 > 0 ? -segExtent : segExtent;
				s0 = Math.max(0, -(a01 * s1 + b0));
				sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
			}

			if (optionalPointOnRay) {
				optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
			}

			if (optionalPointOnSegment) {
				optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
			}

			return sqrDist;
		}

		intersectSphere(sphere, target) {
			_vector$a.subVectors(sphere.center, this.origin);

			const tca = _vector$a.dot(this.direction);

			const d2 = _vector$a.dot(_vector$a) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;
			if (d2 > radius2) return null;
			const thc = Math.sqrt(radius2 - d2); // t0 = first intersect point - entrance on front of sphere

			const t0 = tca - thc; // t1 = second intersect point - exit point on back of sphere

			const t1 = tca + thc; // test to see if both t0 and t1 are behind the ray - if so, return null

			if (t0 < 0 && t1 < 0) return null; // test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.

			if (t0 < 0) return this.at(t1, target); // else t0 is in front of the ray, so return the first collision point scaled by t0

			return this.at(t0, target);
		}

		intersectsSphere(sphere) {
			return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
		}

		distanceToPlane(plane) {
			const denominator = plane.normal.dot(this.direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (plane.distanceToPoint(this.origin) === 0) {
					return 0;
				} // Null is preferable to undefined since undefined means.... it is undefined


				return null;
			}

			const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator; // Return if the ray never intersects the plane

			return t >= 0 ? t : null;
		}

		intersectPlane(plane, target) {
			const t = this.distanceToPlane(plane);

			if (t === null) {
				return null;
			}

			return this.at(t, target);
		}

		intersectsPlane(plane) {
			// check if the ray lies on the plane first
			const distToPoint = plane.distanceToPoint(this.origin);

			if (distToPoint === 0) {
				return true;
			}

			const denominator = plane.normal.dot(this.direction);

			if (denominator * distToPoint < 0) {
				return true;
			} // ray origin is behind the plane (and is pointing behind it)


			return false;
		}

		intersectBox(box, target) {
			let tmin, tmax, tymin, tymax, tzmin, tzmax;
			const invdirx = 1 / this.direction.x,
						invdiry = 1 / this.direction.y,
						invdirz = 1 / this.direction.z;
			const origin = this.origin;

			if (invdirx >= 0) {
				tmin = (box.min.x - origin.x) * invdirx;
				tmax = (box.max.x - origin.x) * invdirx;
			} else {
				tmin = (box.max.x - origin.x) * invdirx;
				tmax = (box.min.x - origin.x) * invdirx;
			}

			if (invdiry >= 0) {
				tymin = (box.min.y - origin.y) * invdiry;
				tymax = (box.max.y - origin.y) * invdiry;
			} else {
				tymin = (box.max.y - origin.y) * invdiry;
				tymax = (box.min.y - origin.y) * invdiry;
			}

			if (tmin > tymax || tymin > tmax) return null; // These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if (tymin > tmin || tmin !== tmin) tmin = tymin;
			if (tymax < tmax || tmax !== tmax) tmax = tymax;

			if (invdirz >= 0) {
				tzmin = (box.min.z - origin.z) * invdirz;
				tzmax = (box.max.z - origin.z) * invdirz;
			} else {
				tzmin = (box.max.z - origin.z) * invdirz;
				tzmax = (box.min.z - origin.z) * invdirz;
			}

			if (tmin > tzmax || tzmin > tmax) return null;
			if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
			if (tzmax < tmax || tmax !== tmax) tmax = tzmax; //return point closest to the ray (positive side)

			if (tmax < 0) return null;
			return this.at(tmin >= 0 ? tmin : tmax, target);
		}

		intersectsBox(box) {
			return this.intersectBox(box, _vector$a) !== null;
		}

		intersectTriangle(a, b, c, backfaceCulling, target) {
			// Compute the offset origin, edges, and normal.
			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
			_edge1.subVectors(b, a);

			_edge2.subVectors(c, a);

			_normal$1.crossVectors(_edge1, _edge2); // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//	 |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//	 |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//	 |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)


			let DdN = this.direction.dot(_normal$1);
			let sign;

			if (DdN > 0) {
				if (backfaceCulling) return null;
				sign = 1;
			} else if (DdN < 0) {
				sign = -1;
				DdN = -DdN;
			} else {
				return null;
			}

			_diff.subVectors(this.origin, a);

			const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2)); // b1 < 0, no intersection

			if (DdQxE2 < 0) {
				return null;
			}

			const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff)); // b2 < 0, no intersection

			if (DdE1xQ < 0) {
				return null;
			} // b1+b2 > 1, no intersection


			if (DdQxE2 + DdE1xQ > DdN) {
				return null;
			} // Line intersects triangle, check if ray does.


			const QdN = -sign * _diff.dot(_normal$1); // t < 0, no intersection


			if (QdN < 0) {
				return null;
			} // Ray intersects triangle.


			return this.at(QdN / DdN, target);
		}

		applyMatrix4(matrix4) {
			this.origin.applyMatrix4(matrix4);
			this.direction.transformDirection(matrix4);
			return this;
		}

		equals(ray) {
			return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class Matrix4 {
		constructor() {
			this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

			if (arguments.length > 0) {
				console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');
			}
		}

		set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			const te = this.elements;
			te[0] = n11;
			te[4] = n12;
			te[8] = n13;
			te[12] = n14;
			te[1] = n21;
			te[5] = n22;
			te[9] = n23;
			te[13] = n24;
			te[2] = n31;
			te[6] = n32;
			te[10] = n33;
			te[14] = n34;
			te[3] = n41;
			te[7] = n42;
			te[11] = n43;
			te[15] = n44;
			return this;
		}

		identity() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		clone() {
			return new Matrix4().fromArray(this.elements);
		}

		copy(m) {
			const te = this.elements;
			const me = m.elements;
			te[0] = me[0];
			te[1] = me[1];
			te[2] = me[2];
			te[3] = me[3];
			te[4] = me[4];
			te[5] = me[5];
			te[6] = me[6];
			te[7] = me[7];
			te[8] = me[8];
			te[9] = me[9];
			te[10] = me[10];
			te[11] = me[11];
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			te[15] = me[15];
			return this;
		}

		copyPosition(m) {
			const te = this.elements,
						me = m.elements;
			te[12] = me[12];
			te[13] = me[13];
			te[14] = me[14];
			return this;
		}

		setFromMatrix3(m) {
			const me = m.elements;
			this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
			return this;
		}

		extractBasis(xAxis, yAxis, zAxis) {
			xAxis.setFromMatrixColumn(this, 0);
			yAxis.setFromMatrixColumn(this, 1);
			zAxis.setFromMatrixColumn(this, 2);
			return this;
		}

		makeBasis(xAxis, yAxis, zAxis) {
			this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
			return this;
		}

		extractRotation(m) {
			// this method does not support reflection matrices
			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();

			const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();

			const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;
			te[3] = 0;
			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;
			te[7] = 0;
			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;
			te[11] = 0;
			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromEuler(euler) {
			if (!(euler && euler.isEuler)) {
				console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');
			}

			const te = this.elements;
			const x = euler.x,
						y = euler.y,
						z = euler.z;
			const a = Math.cos(x),
						b = Math.sin(x);
			const c = Math.cos(y),
						d = Math.sin(y);
			const e = Math.cos(z),
						f = Math.sin(z);

			if (euler.order === 'XYZ') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = -c * f;
				te[8] = d;
				te[1] = af + be * d;
				te[5] = ae - bf * d;
				te[9] = -b * c;
				te[2] = bf - ae * d;
				te[6] = be + af * d;
				te[10] = a * c;
			} else if (euler.order === 'YXZ') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce + df * b;
				te[4] = de * b - cf;
				te[8] = a * d;
				te[1] = a * f;
				te[5] = a * e;
				te[9] = -b;
				te[2] = cf * b - de;
				te[6] = df + ce * b;
				te[10] = a * c;
			} else if (euler.order === 'ZXY') {
				const ce = c * e,
							cf = c * f,
							de = d * e,
							df = d * f;
				te[0] = ce - df * b;
				te[4] = -a * f;
				te[8] = de + cf * b;
				te[1] = cf + de * b;
				te[5] = a * e;
				te[9] = df - ce * b;
				te[2] = -a * d;
				te[6] = b;
				te[10] = a * c;
			} else if (euler.order === 'ZYX') {
				const ae = a * e,
							af = a * f,
							be = b * e,
							bf = b * f;
				te[0] = c * e;
				te[4] = be * d - af;
				te[8] = ae * d + bf;
				te[1] = c * f;
				te[5] = bf * d + ae;
				te[9] = af * d - be;
				te[2] = -d;
				te[6] = b * c;
				te[10] = a * c;
			} else if (euler.order === 'YZX') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = bd - ac * f;
				te[8] = bc * f + ad;
				te[1] = f;
				te[5] = a * e;
				te[9] = -b * e;
				te[2] = -d * e;
				te[6] = ad * f + bc;
				te[10] = ac - bd * f;
			} else if (euler.order === 'XZY') {
				const ac = a * c,
							ad = a * d,
							bc = b * c,
							bd = b * d;
				te[0] = c * e;
				te[4] = -f;
				te[8] = d * e;
				te[1] = ac * f + bd;
				te[5] = a * e;
				te[9] = ad * f - bc;
				te[2] = bc * f - ad;
				te[6] = b * e;
				te[10] = bd * f + ac;
			} // bottom row


			te[3] = 0;
			te[7] = 0;
			te[11] = 0; // last column

			te[12] = 0;
			te[13] = 0;
			te[14] = 0;
			te[15] = 1;
			return this;
		}

		makeRotationFromQuaternion(q) {
			return this.compose(_zero, q, _one);
		}

		lookAt(eye, target, up) {
			const te = this.elements;

			_z.subVectors(eye, target);

			if (_z.lengthSq() === 0) {
				// eye and target are in the same position
				_z.z = 1;
			}

			_z.normalize();

			_x.crossVectors(up, _z);

			if (_x.lengthSq() === 0) {
				// up and z are parallel
				if (Math.abs(up.z) === 1) {
					_z.x += 0.0001;
				} else {
					_z.z += 0.0001;
				}

				_z.normalize();

				_x.crossVectors(up, _z);
			}

			_x.normalize();

			_y.crossVectors(_z, _x);

			te[0] = _x.x;
			te[4] = _y.x;
			te[8] = _z.x;
			te[1] = _x.y;
			te[5] = _y.y;
			te[9] = _z.y;
			te[2] = _x.z;
			te[6] = _y.z;
			te[10] = _z.z;
			return this;
		}

		multiply(m, n) {
			if (n !== undefined) {
				console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');
				return this.multiplyMatrices(m, n);
			}

			return this.multiplyMatrices(this, m);
		}

		premultiply(m) {
			return this.multiplyMatrices(m, this);
		}

		multiplyMatrices(a, b) {
			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;
			const a11 = ae[0],
						a12 = ae[4],
						a13 = ae[8],
						a14 = ae[12];
			const a21 = ae[1],
						a22 = ae[5],
						a23 = ae[9],
						a24 = ae[13];
			const a31 = ae[2],
						a32 = ae[6],
						a33 = ae[10],
						a34 = ae[14];
			const a41 = ae[3],
						a42 = ae[7],
						a43 = ae[11],
						a44 = ae[15];
			const b11 = be[0],
						b12 = be[4],
						b13 = be[8],
						b14 = be[12];
			const b21 = be[1],
						b22 = be[5],
						b23 = be[9],
						b24 = be[13];
			const b31 = be[2],
						b32 = be[6],
						b33 = be[10],
						b34 = be[14];
			const b41 = be[3],
						b42 = be[7],
						b43 = be[11],
						b44 = be[15];
			te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
			te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
			te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
			te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
			return this;
		}

		multiplyScalar(s) {
			const te = this.elements;
			te[0] *= s;
			te[4] *= s;
			te[8] *= s;
			te[12] *= s;
			te[1] *= s;
			te[5] *= s;
			te[9] *= s;
			te[13] *= s;
			te[2] *= s;
			te[6] *= s;
			te[10] *= s;
			te[14] *= s;
			te[3] *= s;
			te[7] *= s;
			te[11] *= s;
			te[15] *= s;
			return this;
		}

		determinant() {
			const te = this.elements;
			const n11 = te[0],
						n12 = te[4],
						n13 = te[8],
						n14 = te[12];
			const n21 = te[1],
						n22 = te[5],
						n23 = te[9],
						n24 = te[13];
			const n31 = te[2],
						n32 = te[6],
						n33 = te[10],
						n34 = te[14];
			const n41 = te[3],
						n42 = te[7],
						n43 = te[11],
						n44 = te[15]; //TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
		}

		transpose() {
			const te = this.elements;
			let tmp;
			tmp = te[1];
			te[1] = te[4];
			te[4] = tmp;
			tmp = te[2];
			te[2] = te[8];
			te[8] = tmp;
			tmp = te[6];
			te[6] = te[9];
			te[9] = tmp;
			tmp = te[3];
			te[3] = te[12];
			te[12] = tmp;
			tmp = te[7];
			te[7] = te[13];
			te[13] = tmp;
			tmp = te[11];
			te[11] = te[14];
			te[14] = tmp;
			return this;
		}

		setPosition(x, y, z) {
			const te = this.elements;

			if (x.isVector3) {
				te[12] = x.x;
				te[13] = x.y;
				te[14] = x.z;
			} else {
				te[12] = x;
				te[13] = y;
				te[14] = z;
			}

			return this;
		}

		invert() {
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,
						n11 = te[0],
						n21 = te[1],
						n31 = te[2],
						n41 = te[3],
						n12 = te[4],
						n22 = te[5],
						n32 = te[6],
						n42 = te[7],
						n13 = te[8],
						n23 = te[9],
						n33 = te[10],
						n43 = te[11],
						n14 = te[12],
						n24 = te[13],
						n34 = te[14],
						n44 = te[15],
						t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
						t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
						t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
						t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
			if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
			const detInv = 1 / det;
			te[0] = t11 * detInv;
			te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
			te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
			te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
			te[4] = t12 * detInv;
			te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
			te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
			te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
			te[8] = t13 * detInv;
			te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
			te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
			te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
			te[12] = t14 * detInv;
			te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
			te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
			te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
			return this;
		}

		scale(v) {
			const te = this.elements;
			const x = v.x,
						y = v.y,
						z = v.z;
			te[0] *= x;
			te[4] *= y;
			te[8] *= z;
			te[1] *= x;
			te[5] *= y;
			te[9] *= z;
			te[2] *= x;
			te[6] *= y;
			te[10] *= z;
			te[3] *= x;
			te[7] *= y;
			te[11] *= z;
			return this;
		}

		getMaxScaleOnAxis() {
			const te = this.elements;
			const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
			const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
			const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
			return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
		}

		makeTranslation(x, y, z) {
			this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
			return this;
		}

		makeRotationX(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationY(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationZ(theta) {
			const c = Math.cos(theta),
						s = Math.sin(theta);
			this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this;
		}

		makeRotationAxis(axis, angle) {
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
			const c = Math.cos(angle);
			const s = Math.sin(angle);
			const t = 1 - c;
			const x = axis.x,
						y = axis.y,
						z = axis.z;
			const tx = t * x,
						ty = t * y;
			this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
			return this;
		}

		makeScale(x, y, z) {
			this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
			return this;
		}

		makeShear(xy, xz, yx, yz, zx, zy) {
			this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
			return this;
		}

		compose(position, quaternion, scale) {
			const te = this.elements;
			const x = quaternion._x,
						y = quaternion._y,
						z = quaternion._z,
						w = quaternion._w;
			const x2 = x + x,
						y2 = y + y,
						z2 = z + z;
			const xx = x * x2,
						xy = x * y2,
						xz = x * z2;
			const yy = y * y2,
						yz = y * z2,
						zz = z * z2;
			const wx = w * x2,
						wy = w * y2,
						wz = w * z2;
			const sx = scale.x,
						sy = scale.y,
						sz = scale.z;
			te[0] = (1 - (yy + zz)) * sx;
			te[1] = (xy + wz) * sx;
			te[2] = (xz - wy) * sx;
			te[3] = 0;
			te[4] = (xy - wz) * sy;
			te[5] = (1 - (xx + zz)) * sy;
			te[6] = (yz + wx) * sy;
			te[7] = 0;
			te[8] = (xz + wy) * sz;
			te[9] = (yz - wx) * sz;
			te[10] = (1 - (xx + yy)) * sz;
			te[11] = 0;
			te[12] = position.x;
			te[13] = position.y;
			te[14] = position.z;
			te[15] = 1;
			return this;
		}

		decompose(position, quaternion, scale) {
			const te = this.elements;

			let sx = _v1$5.set(te[0], te[1], te[2]).length();

			const sy = _v1$5.set(te[4], te[5], te[6]).length();

			const sz = _v1$5.set(te[8], te[9], te[10]).length(); // if determine is negative, we need to invert one scale


			const det = this.determinant();
			if (det < 0) sx = -sx;
			position.x = te[12];
			position.y = te[13];
			position.z = te[14]; // scale the rotation part

			_m1$2.copy(this);

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;
			_m1$2.elements[0] *= invSX;
			_m1$2.elements[1] *= invSX;
			_m1$2.elements[2] *= invSX;
			_m1$2.elements[4] *= invSY;
			_m1$2.elements[5] *= invSY;
			_m1$2.elements[6] *= invSY;
			_m1$2.elements[8] *= invSZ;
			_m1$2.elements[9] *= invSZ;
			_m1$2.elements[10] *= invSZ;
			quaternion.setFromRotationMatrix(_m1$2);
			scale.x = sx;
			scale.y = sy;
			scale.z = sz;
			return this;
		}

		makePerspective(left, right, top, bottom, near, far) {
			if (far === undefined) {
				console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');
			}

			const te = this.elements;
			const x = 2 * near / (right - left);
			const y = 2 * near / (top - bottom);
			const a = (right + left) / (right - left);
			const b = (top + bottom) / (top - bottom);
			const c = -(far + near) / (far - near);
			const d = -2 * far * near / (far - near);
			te[0] = x;
			te[4] = 0;
			te[8] = a;
			te[12] = 0;
			te[1] = 0;
			te[5] = y;
			te[9] = b;
			te[13] = 0;
			te[2] = 0;
			te[6] = 0;
			te[10] = c;
			te[14] = d;
			te[3] = 0;
			te[7] = 0;
			te[11] = -1;
			te[15] = 0;
			return this;
		}

		makeOrthographic(left, right, top, bottom, near, far) {
			const te = this.elements;
			const w = 1.0 / (right - left);
			const h = 1.0 / (top - bottom);
			const p = 1.0 / (far - near);
			const x = (right + left) * w;
			const y = (top + bottom) * h;
			const z = (far + near) * p;
			te[0] = 2 * w;
			te[4] = 0;
			te[8] = 0;
			te[12] = -x;
			te[1] = 0;
			te[5] = 2 * h;
			te[9] = 0;
			te[13] = -y;
			te[2] = 0;
			te[6] = 0;
			te[10] = -2 * p;
			te[14] = -z;
			te[3] = 0;
			te[7] = 0;
			te[11] = 0;
			te[15] = 1;
			return this;
		}

		equals(matrix) {
			const te = this.elements;
			const me = matrix.elements;

			for (let i = 0; i < 16; i++) {
				if (te[i] !== me[i]) return false;
			}

			return true;
		}

		fromArray(array, offset = 0) {
			for (let i = 0; i < 16; i++) {
				this.elements[i] = array[i + offset];
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const te = this.elements;
			array[offset] = te[0];
			array[offset + 1] = te[1];
			array[offset + 2] = te[2];
			array[offset + 3] = te[3];
			array[offset + 4] = te[4];
			array[offset + 5] = te[5];
			array[offset + 6] = te[6];
			array[offset + 7] = te[7];
			array[offset + 8] = te[8];
			array[offset + 9] = te[9];
			array[offset + 10] = te[10];
			array[offset + 11] = te[11];
			array[offset + 12] = te[12];
			array[offset + 13] = te[13];
			array[offset + 14] = te[14];
			array[offset + 15] = te[15];
			return array;
		}

	}

	Matrix4.prototype.isMatrix4 = true;

	const _v1$5 = /*@__PURE__*/new Vector3();

	const _m1$2 = /*@__PURE__*/new Matrix4();

	const _zero = /*@__PURE__*/new Vector3(0, 0, 0);

	const _one = /*@__PURE__*/new Vector3(1, 1, 1);

	const _x = /*@__PURE__*/new Vector3();

	const _y = /*@__PURE__*/new Vector3();

	const _z = /*@__PURE__*/new Vector3();

	const _matrix$1 = /*@__PURE__*/new Matrix4();

	const _quaternion$3 = /*@__PURE__*/new Quaternion();

	class Euler {
		constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;
		}

		get x() {
			return this._x;
		}

		set x(value) {
			this._x = value;

			this._onChangeCallback();
		}

		get y() {
			return this._y;
		}

		set y(value) {
			this._y = value;

			this._onChangeCallback();
		}

		get z() {
			return this._z;
		}

		set z(value) {
			this._z = value;

			this._onChangeCallback();
		}

		get order() {
			return this._order;
		}

		set order(value) {
			this._order = value;

			this._onChangeCallback();
		}

		set(x, y, z, order = this._order) {
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

			this._onChangeCallback();

			return this;
		}

		clone() {
			return new this.constructor(this._x, this._y, this._z, this._order);
		}

		copy(euler) {
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;
		}

		setFromRotationMatrix(m, order = this._order, update = true) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			const te = m.elements;
			const m11 = te[0],
						m12 = te[4],
						m13 = te[8];
			const m21 = te[1],
						m22 = te[5],
						m23 = te[9];
			const m31 = te[2],
						m32 = te[6],
						m33 = te[10];

			switch (order) {
				case 'XYZ':
					this._y = Math.asin(clamp(m13, -1, 1));

					if (Math.abs(m13) < 0.9999999) {
						this._x = Math.atan2(-m23, m33);
						this._z = Math.atan2(-m12, m11);
					} else {
						this._x = Math.atan2(m32, m22);
						this._z = 0;
					}

					break;

				case 'YXZ':
					this._x = Math.asin(-clamp(m23, -1, 1));

					if (Math.abs(m23) < 0.9999999) {
						this._y = Math.atan2(m13, m33);
						this._z = Math.atan2(m21, m22);
					} else {
						this._y = Math.atan2(-m31, m11);
						this._z = 0;
					}

					break;

				case 'ZXY':
					this._x = Math.asin(clamp(m32, -1, 1));

					if (Math.abs(m32) < 0.9999999) {
						this._y = Math.atan2(-m31, m33);
						this._z = Math.atan2(-m12, m22);
					} else {
						this._y = 0;
						this._z = Math.atan2(m21, m11);
					}

					break;

				case 'ZYX':
					this._y = Math.asin(-clamp(m31, -1, 1));

					if (Math.abs(m31) < 0.9999999) {
						this._x = Math.atan2(m32, m33);
						this._z = Math.atan2(m21, m11);
					} else {
						this._x = 0;
						this._z = Math.atan2(-m12, m22);
					}

					break;

				case 'YZX':
					this._z = Math.asin(clamp(m21, -1, 1));

					if (Math.abs(m21) < 0.9999999) {
						this._x = Math.atan2(-m23, m22);
						this._y = Math.atan2(-m31, m11);
					} else {
						this._x = 0;
						this._y = Math.atan2(m13, m33);
					}

					break;

				case 'XZY':
					this._z = Math.asin(-clamp(m12, -1, 1));

					if (Math.abs(m12) < 0.9999999) {
						this._x = Math.atan2(m32, m22);
						this._y = Math.atan2(m13, m11);
					} else {
						this._x = Math.atan2(-m23, m33);
						this._y = 0;
					}

					break;

				default:
					console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
			}

			this._order = order;
			if (update === true) this._onChangeCallback();
			return this;
		}

		setFromQuaternion(q, order, update) {
			_matrix$1.makeRotationFromQuaternion(q);

			return this.setFromRotationMatrix(_matrix$1, order, update);
		}

		setFromVector3(v, order = this._order) {
			return this.set(v.x, v.y, v.z, order);
		}

		reorder(newOrder) {
			// WARNING: this discards revolution information -bhouston
			_quaternion$3.setFromEuler(this);

			return this.setFromQuaternion(_quaternion$3, newOrder);
		}

		equals(euler) {
			return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
		}

		fromArray(array) {
			this._x = array[0];
			this._y = array[1];
			this._z = array[2];
			if (array[3] !== undefined) this._order = array[3];

			this._onChangeCallback();

			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this._x;
			array[offset + 1] = this._y;
			array[offset + 2] = this._z;
			array[offset + 3] = this._order;
			return array;
		}

		toVector3(optionalResult) {
			if (optionalResult) {
				return optionalResult.set(this._x, this._y, this._z);
			} else {
				return new Vector3(this._x, this._y, this._z);
			}
		}

		_onChange(callback) {
			this._onChangeCallback = callback;
			return this;
		}

		_onChangeCallback() {}

	}

	Euler.prototype.isEuler = true;
	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];

	class Layers {
		constructor() {
			this.mask = 1 | 0;
		}

		set(channel) {
			this.mask = 1 << channel | 0;
		}

		enable(channel) {
			this.mask |= 1 << channel | 0;
		}

		enableAll() {
			this.mask = 0xffffffff | 0;
		}

		toggle(channel) {
			this.mask ^= 1 << channel | 0;
		}

		disable(channel) {
			this.mask &= ~(1 << channel | 0);
		}

		disableAll() {
			this.mask = 0;
		}

		test(layers) {
			return (this.mask & layers.mask) !== 0;
		}

	}

	let _object3DId = 0;

	const _v1$4 = /*@__PURE__*/new Vector3();

	const _q1 = /*@__PURE__*/new Quaternion();

	const _m1$1 = /*@__PURE__*/new Matrix4();

	const _target = /*@__PURE__*/new Vector3();

	const _position$3 = /*@__PURE__*/new Vector3();

	const _scale$2 = /*@__PURE__*/new Vector3();

	const _quaternion$2 = /*@__PURE__*/new Quaternion();

	const _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);

	const _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);

	const _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);

	const _addedEvent = {
		type: 'added'
	};
	const _removedEvent = {
		type: 'removed'
	};

	class Object3D extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _object3DId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Object3D';
			this.parent = null;
			this.children = [];
			this.up = Object3D.DefaultUp.clone();
			const position = new Vector3();
			const rotation = new Euler();
			const quaternion = new Quaternion();
			const scale = new Vector3(1, 1, 1);

			function onRotationChange() {
				quaternion.setFromEuler(rotation, false);
			}

			function onQuaternionChange() {
				rotation.setFromQuaternion(quaternion, undefined, false);
			}

			rotation._onChange(onRotationChange);

			quaternion._onChange(onQuaternionChange);

			Object.defineProperties(this, {
				position: {
					configurable: true,
					enumerable: true,
					value: position
				},
				rotation: {
					configurable: true,
					enumerable: true,
					value: rotation
				},
				quaternion: {
					configurable: true,
					enumerable: true,
					value: quaternion
				},
				scale: {
					configurable: true,
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			});
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
			this.layers = new Layers();
			this.visible = true;
			this.castShadow = false;
			this.receiveShadow = false;
			this.frustumCulled = true;
			this.renderOrder = 0;
			this.animations = [];
			this.userData = {};
		}

		onBeforeRender() {}

		onAfterRender() {}

		applyMatrix4(matrix) {
			if (this.matrixAutoUpdate) this.updateMatrix();
			this.matrix.premultiply(matrix);
			this.matrix.decompose(this.position, this.quaternion, this.scale);
		}

		applyQuaternion(q) {
			this.quaternion.premultiply(q);
			return this;
		}

		setRotationFromAxisAngle(axis, angle) {
			// assumes axis is normalized
			this.quaternion.setFromAxisAngle(axis, angle);
		}

		setRotationFromEuler(euler) {
			this.quaternion.setFromEuler(euler, true);
		}

		setRotationFromMatrix(m) {
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
			this.quaternion.setFromRotationMatrix(m);
		}

		setRotationFromQuaternion(q) {
			// assumes q is normalized
			this.quaternion.copy(q);
		}

		rotateOnAxis(axis, angle) {
			// rotate object on axis in object space
			// axis is assumed to be normalized
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.multiply(_q1);
			return this;
		}

		rotateOnWorldAxis(axis, angle) {
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
			_q1.setFromAxisAngle(axis, angle);

			this.quaternion.premultiply(_q1);
			return this;
		}

		rotateX(angle) {
			return this.rotateOnAxis(_xAxis, angle);
		}

		rotateY(angle) {
			return this.rotateOnAxis(_yAxis, angle);
		}

		rotateZ(angle) {
			return this.rotateOnAxis(_zAxis, angle);
		}

		translateOnAxis(axis, distance) {
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
			_v1$4.copy(axis).applyQuaternion(this.quaternion);

			this.position.add(_v1$4.multiplyScalar(distance));
			return this;
		}

		translateX(distance) {
			return this.translateOnAxis(_xAxis, distance);
		}

		translateY(distance) {
			return this.translateOnAxis(_yAxis, distance);
		}

		translateZ(distance) {
			return this.translateOnAxis(_zAxis, distance);
		}

		localToWorld(vector) {
			return vector.applyMatrix4(this.matrixWorld);
		}

		worldToLocal(vector) {
			return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
		}

		lookAt(x, y, z) {
			// This method does not support objects having non-uniformly-scaled parent(s)
			if (x.isVector3) {
				_target.copy(x);
			} else {
				_target.set(x, y, z);
			}

			const parent = this.parent;
			this.updateWorldMatrix(true, false);

			_position$3.setFromMatrixPosition(this.matrixWorld);

			if (this.isCamera || this.isLight) {
				_m1$1.lookAt(_position$3, _target, this.up);
			} else {
				_m1$1.lookAt(_target, _position$3, this.up);
			}

			this.quaternion.setFromRotationMatrix(_m1$1);

			if (parent) {
				_m1$1.extractRotation(parent.matrixWorld);

				_q1.setFromRotationMatrix(_m1$1);

				this.quaternion.premultiply(_q1.invert());
			}
		}

		add(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.add(arguments[i]);
				}

				return this;
			}

			if (object === this) {
				console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
				return this;
			}

			if (object && object.isObject3D) {
				if (object.parent !== null) {
					object.parent.remove(object);
				}

				object.parent = this;
				this.children.push(object);
				object.dispatchEvent(_addedEvent);
			} else {
				console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
			}

			return this;
		}

		remove(object) {
			if (arguments.length > 1) {
				for (let i = 0; i < arguments.length; i++) {
					this.remove(arguments[i]);
				}

				return this;
			}

			const index = this.children.indexOf(object);

			if (index !== -1) {
				object.parent = null;
				this.children.splice(index, 1);
				object.dispatchEvent(_removedEvent);
			}

			return this;
		}

		removeFromParent() {
			const parent = this.parent;

			if (parent !== null) {
				parent.remove(this);
			}

			return this;
		}

		clear() {
			for (let i = 0; i < this.children.length; i++) {
				const object = this.children[i];
				object.parent = null;
				object.dispatchEvent(_removedEvent);
			}

			this.children.length = 0;
			return this;
		}

		attach(object) {
			// adds object as a child of this, while maintaining the object's world transform
			this.updateWorldMatrix(true, false);

			_m1$1.copy(this.matrixWorld).invert();

			if (object.parent !== null) {
				object.parent.updateWorldMatrix(true, false);

				_m1$1.multiply(object.parent.matrixWorld);
			}

			object.applyMatrix4(_m1$1);
			this.add(object);
			object.updateWorldMatrix(false, true);
			return this;
		}

		getObjectById(id) {
			return this.getObjectByProperty('id', id);
		}

		getObjectByName(name) {
			return this.getObjectByProperty('name', name);
		}

		getObjectByProperty(name, value) {
			if (this[name] === value) return this;

			for (let i = 0, l = this.children.length; i < l; i++) {
				const child = this.children[i];
				const object = child.getObjectByProperty(name, value);

				if (object !== undefined) {
					return object;
				}
			}

			return undefined;
		}

		getWorldPosition(target) {
			this.updateWorldMatrix(true, false);
			return target.setFromMatrixPosition(this.matrixWorld);
		}

		getWorldQuaternion(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, target, _scale$2);
			return target;
		}

		getWorldScale(target) {
			this.updateWorldMatrix(true, false);
			this.matrixWorld.decompose(_position$3, _quaternion$2, target);
			return target;
		}

		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(e[8], e[9], e[10]).normalize();
		}

		raycast() {}

		traverse(callback) {
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverse(callback);
			}
		}

		traverseVisible(callback) {
			if (this.visible === false) return;
			callback(this);
			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].traverseVisible(callback);
			}
		}

		traverseAncestors(callback) {
			const parent = this.parent;

			if (parent !== null) {
				callback(parent);
				parent.traverseAncestors(callback);
			}
		}

		updateMatrix() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = true;
		}

		updateMatrixWorld(force) {
			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.matrixWorldNeedsUpdate || force) {
				if (this.parent === null) {
					this.matrixWorld.copy(this.matrix);
				} else {
					this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
				}

				this.matrixWorldNeedsUpdate = false;
				force = true;
			} // update children


			const children = this.children;

			for (let i = 0, l = children.length; i < l; i++) {
				children[i].updateMatrixWorld(force);
			}
		}

		updateWorldMatrix(updateParents, updateChildren) {
			const parent = this.parent;

			if (updateParents === true && parent !== null) {
				parent.updateWorldMatrix(true, false);
			}

			if (this.matrixAutoUpdate) this.updateMatrix();

			if (this.parent === null) {
				this.matrixWorld.copy(this.matrix);
			} else {
				this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
			} // update children


			if (updateChildren === true) {
				const children = this.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateWorldMatrix(false, true);
				}
			}
		}

		toJSON(meta) {
			// meta is a string when called from JSON.stringify
			const isRootObject = meta === undefined || typeof meta === 'string';
			const output = {}; // meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.

			if (isRootObject) {
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
			} // standard Object3D serialization


			const object = {};
			object.uuid = this.uuid;
			object.type = this.type;
			if (this.name !== '') object.name = this.name;
			if (this.castShadow === true) object.castShadow = true;
			if (this.receiveShadow === true) object.receiveShadow = true;
			if (this.visible === false) object.visible = false;
			if (this.frustumCulled === false) object.frustumCulled = false;
			if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
			if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
			if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false; // object specific properties

			if (this.isInstancedMesh) {
				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();
				if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
			} //


			function serialize(library, element) {
				if (library[element.uuid] === undefined) {
					library[element.uuid] = element.toJSON(meta);
				}

				return element.uuid;
			}

			if (this.isScene) {
				if (this.background) {
					if (this.background.isColor) {
						object.background = this.background.toJSON();
					} else if (this.background.isTexture) {
						object.background = this.background.toJSON(meta).uuid;
					}
				}

				if (this.environment && this.environment.isTexture) {
					object.environment = this.environment.toJSON(meta).uuid;
				}
			} else if (this.isMesh || this.isLine || this.isPoints) {
				object.geometry = serialize(meta.geometries, this.geometry);
				const parameters = this.geometry.parameters;

				if (parameters !== undefined && parameters.shapes !== undefined) {
					const shapes = parameters.shapes;

					if (Array.isArray(shapes)) {
						for (let i = 0, l = shapes.length; i < l; i++) {
							const shape = shapes[i];
							serialize(meta.shapes, shape);
						}
					} else {
						serialize(meta.shapes, shapes);
					}
				}
			}

			if (this.isSkinnedMesh) {
				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if (this.skeleton !== undefined) {
					serialize(meta.skeletons, this.skeleton);
					object.skeleton = this.skeleton.uuid;
				}
			}

			if (this.material !== undefined) {
				if (Array.isArray(this.material)) {
					const uuids = [];

					for (let i = 0, l = this.material.length; i < l; i++) {
						uuids.push(serialize(meta.materials, this.material[i]));
					}

					object.material = uuids;
				} else {
					object.material = serialize(meta.materials, this.material);
				}
			} //


			if (this.children.length > 0) {
				object.children = [];

				for (let i = 0; i < this.children.length; i++) {
					object.children.push(this.children[i].toJSON(meta).object);
				}
			} //


			if (this.animations.length > 0) {
				object.animations = [];

				for (let i = 0; i < this.animations.length; i++) {
					const animation = this.animations[i];
					object.animations.push(serialize(meta.animations, animation));
				}
			}

			if (isRootObject) {
				const geometries = extractFromCache(meta.geometries);
				const materials = extractFromCache(meta.materials);
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				const shapes = extractFromCache(meta.shapes);
				const skeletons = extractFromCache(meta.skeletons);
				const animations = extractFromCache(meta.animations);
				if (geometries.length > 0) output.geometries = geometries;
				if (materials.length > 0) output.materials = materials;
				if (textures.length > 0) output.textures = textures;
				if (images.length > 0) output.images = images;
				if (shapes.length > 0) output.shapes = shapes;
				if (skeletons.length > 0) output.skeletons = skeletons;
				if (animations.length > 0) output.animations = animations;
			}

			output.object = object;
			return output; // extract data from the cache hash
			// remove metadata on each item
			// and return as array

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}
		}

		clone(recursive) {
			return new this.constructor().copy(this, recursive);
		}

		copy(source, recursive = true) {
			this.name = source.name;
			this.up.copy(source.up);
			this.position.copy(source.position);
			this.rotation.order = source.rotation.order;
			this.quaternion.copy(source.quaternion);
			this.scale.copy(source.scale);
			this.matrix.copy(source.matrix);
			this.matrixWorld.copy(source.matrixWorld);
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
			this.userData = JSON.parse(JSON.stringify(source.userData));

			if (recursive === true) {
				for (let i = 0; i < source.children.length; i++) {
					const child = source.children[i];
					this.add(child.clone());
				}
			}

			return this;
		}

	}

	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype.isObject3D = true;

	const _v0$1 = /*@__PURE__*/new Vector3();

	const _v1$3 = /*@__PURE__*/new Vector3();

	const _v2$2 = /*@__PURE__*/new Vector3();

	const _v3$1 = /*@__PURE__*/new Vector3();

	const _vab = /*@__PURE__*/new Vector3();

	const _vac = /*@__PURE__*/new Vector3();

	const _vbc = /*@__PURE__*/new Vector3();

	const _vap = /*@__PURE__*/new Vector3();

	const _vbp = /*@__PURE__*/new Vector3();

	const _vcp = /*@__PURE__*/new Vector3();

	class Triangle {
		constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
			this.a = a;
			this.b = b;
			this.c = c;
		}

		static getNormal(a, b, c, target) {
			target.subVectors(c, b);

			_v0$1.subVectors(a, b);

			target.cross(_v0$1);
			const targetLengthSq = target.lengthSq();

			if (targetLengthSq > 0) {
				return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
			}

			return target.set(0, 0, 0);
		} // static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html


		static getBarycoord(point, a, b, c, target) {
			_v0$1.subVectors(c, a);

			_v1$3.subVectors(b, a);

			_v2$2.subVectors(point, a);

			const dot00 = _v0$1.dot(_v0$1);

			const dot01 = _v0$1.dot(_v1$3);

			const dot02 = _v0$1.dot(_v2$2);

			const dot11 = _v1$3.dot(_v1$3);

			const dot12 = _v1$3.dot(_v2$2);

			const denom = dot00 * dot11 - dot01 * dot01; // collinear or singular triangle

			if (denom === 0) {
				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set(-2, -1, -1);
			}

			const invDenom = 1 / denom;
			const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
			const v = (dot00 * dot12 - dot01 * dot02) * invDenom; // barycentric coordinates must always sum to 1

			return target.set(1 - u - v, v, u);
		}

		static containsPoint(point, a, b, c) {
			this.getBarycoord(point, a, b, c, _v3$1);
			return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
		}

		static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
			this.getBarycoord(point, p1, p2, p3, _v3$1);
			target.set(0, 0);
			target.addScaledVector(uv1, _v3$1.x);
			target.addScaledVector(uv2, _v3$1.y);
			target.addScaledVector(uv3, _v3$1.z);
			return target;
		}

		static isFrontFacing(a, b, c, direction) {
			_v0$1.subVectors(c, b);

			_v1$3.subVectors(a, b); // strictly front facing


			return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
		}

		set(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this;
		}

		setFromPointsAndIndices(points, i0, i1, i2) {
			this.a.copy(points[i0]);
			this.b.copy(points[i1]);
			this.c.copy(points[i2]);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(triangle) {
			this.a.copy(triangle.a);
			this.b.copy(triangle.b);
			this.c.copy(triangle.c);
			return this;
		}

		getArea() {
			_v0$1.subVectors(this.c, this.b);

			_v1$3.subVectors(this.a, this.b);

			return _v0$1.cross(_v1$3).length() * 0.5;
		}

		getMidpoint(target) {
			return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
		}

		getNormal(target) {
			return Triangle.getNormal(this.a, this.b, this.c, target);
		}

		getPlane(target) {
			return target.setFromCoplanarPoints(this.a, this.b, this.c);
		}

		getBarycoord(point, target) {
			return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
		}

		getUV(point, uv1, uv2, uv3, target) {
			return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
		}

		containsPoint(point) {
			return Triangle.containsPoint(point, this.a, this.b, this.c);
		}

		isFrontFacing(direction) {
			return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
		}

		intersectsBox(box) {
			return box.intersectsTriangle(this);
		}

		closestPointToPoint(p, target) {
			const a = this.a,
						b = this.b,
						c = this.c;
			let v, w; // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors(b, a);

			_vac.subVectors(c, a);

			_vap.subVectors(p, a);

			const d1 = _vab.dot(_vap);

			const d2 = _vac.dot(_vap);

			if (d1 <= 0 && d2 <= 0) {
				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy(a);
			}

			_vbp.subVectors(p, b);

			const d3 = _vab.dot(_vbp);

			const d4 = _vac.dot(_vbp);

			if (d3 >= 0 && d4 <= d3) {
				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy(b);
			}

			const vc = d1 * d4 - d3 * d2;

			if (vc <= 0 && d1 >= 0 && d3 <= 0) {
				v = d1 / (d1 - d3); // edge region of AB; barycentric coords (1-v, v, 0)

				return target.copy(a).addScaledVector(_vab, v);
			}

			_vcp.subVectors(p, c);

			const d5 = _vab.dot(_vcp);

			const d6 = _vac.dot(_vcp);

			if (d6 >= 0 && d5 <= d6) {
				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy(c);
			}

			const vb = d5 * d2 - d1 * d6;

			if (vb <= 0 && d2 >= 0 && d6 <= 0) {
				w = d2 / (d2 - d6); // edge region of AC; barycentric coords (1-w, 0, w)

				return target.copy(a).addScaledVector(_vac, w);
			}

			const va = d3 * d6 - d5 * d4;

			if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
				_vbc.subVectors(c, b);

				w = (d4 - d3) / (d4 - d3 + (d5 - d6)); // edge region of BC; barycentric coords (0, 1-w, w)

				return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
			} // face region


			const denom = 1 / (va + vb + vc); // u = va * denom

			v = vb * denom;
			w = vc * denom;
			return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
		}

		equals(triangle) {
			return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
		}

	}

	let materialId = 0;

	class Material extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: materialId++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'Material';
			this.fog = true;
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.vertexColors = false;
			this.opacity = 1;
			this.transparent = false;
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
			this.stencilWriteMask = 0xff;
			this.stencilFunc = AlwaysStencilFunc;
			this.stencilRef = 0;
			this.stencilFuncMask = 0xff;
			this.stencilFail = KeepStencilOp;
			this.stencilZFail = KeepStencilOp;
			this.stencilZPass = KeepStencilOp;
			this.stencilWrite = false;
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
			this.shadowSide = null;
			this.colorWrite = true;
			this.precision = null; // override the renderer's default precision for this material

			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
			this.dithering = false;
			this.alphaTest = 0;
			this.alphaToCoverage = false;
			this.premultipliedAlpha = false;
			this.visible = true;
			this.toneMapped = true;
			this.userData = {};
			this.version = 0;
		}

		onBuild()
		/* shaderobject, renderer */
		{}

		onBeforeCompile()
		/* shaderobject, renderer */
		{}

		customProgramCacheKey() {
			return this.onBeforeCompile.toString();
		}

		setValues(values) {
			if (values === undefined) return;

			for (const key in values) {
				const newValue = values[key];

				if (newValue === undefined) {
					console.warn('THREE.Material: \'' + key + '\' parameter is undefined.');
					continue;
				} // for backward compatability if shading is set in the constructor


				if (key === 'shading') {
					console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
					this.flatShading = newValue === FlatShading ? true : false;
					continue;
				}

				const currentValue = this[key];

				if (currentValue === undefined) {
					console.warn('THREE.' + this.type + ': \'' + key + '\' is not a property of this material.');
					continue;
				}

				if (currentValue && currentValue.isColor) {
					currentValue.set(newValue);
				} else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
					currentValue.copy(newValue);
				} else {
					this[key] = newValue;
				}
			}
		}

		toJSON(meta) {
			const isRoot = meta === undefined || typeof meta === 'string';

			if (isRoot) {
				meta = {
					textures: {},
					images: {}
				};
			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			}; // standard Material serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (this.color && this.color.isColor) data.color = this.color.getHex();
			if (this.roughness !== undefined) data.roughness = this.roughness;
			if (this.metalness !== undefined) data.metalness = this.metalness;
			if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
			if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
			if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
			if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
			if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
			if (this.specularTint && this.specularTint.isColor) data.specularTint = this.specularTint.getHex();
			if (this.shininess !== undefined) data.shininess = this.shininess;
			if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
			if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;

			if (this.clearcoatMap && this.clearcoatMap.isTexture) {
				data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
			}

			if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
			}

			if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
			}

			if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
			if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
			if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;

			if (this.lightMap && this.lightMap.isTexture) {
				data.lightMap = this.lightMap.toJSON(meta).uuid;
				data.lightMapIntensity = this.lightMapIntensity;
			}

			if (this.aoMap && this.aoMap.isTexture) {
				data.aoMap = this.aoMap.toJSON(meta).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
			}

			if (this.bumpMap && this.bumpMap.isTexture) {
				data.bumpMap = this.bumpMap.toJSON(meta).uuid;
				data.bumpScale = this.bumpScale;
			}

			if (this.normalMap && this.normalMap.isTexture) {
				data.normalMap = this.normalMap.toJSON(meta).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
			}

			if (this.displacementMap && this.displacementMap.isTexture) {
				data.displacementMap = this.displacementMap.toJSON(meta).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
			}

			if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
			if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
			if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
			if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
			if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
			if (this.specularTintMap && this.specularTintMap.isTexture) data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;

			if (this.envMap && this.envMap.isTexture) {
				data.envMap = this.envMap.toJSON(meta).uuid;
				if (this.combine !== undefined) data.combine = this.combine;
			}

			if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
			if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
			if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;

			if (this.gradientMap && this.gradientMap.isTexture) {
				data.gradientMap = this.gradientMap.toJSON(meta).uuid;
			}

			if (this.transmission !== undefined) data.transmission = this.transmission;
			if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
			if (this.thickness !== undefined) data.thickness = this.thickness;
			if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
			if (this.attenuationDistance !== undefined) data.attenuationDistance = this.attenuationDistance;
			if (this.attenuationTint !== undefined) data.attenuationTint = this.attenuationTint.getHex();
			if (this.size !== undefined) data.size = this.size;
			if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
			if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
			if (this.blending !== NormalBlending) data.blending = this.blending;
			if (this.side !== FrontSide) data.side = this.side;
			if (this.vertexColors) data.vertexColors = true;
			if (this.opacity < 1) data.opacity = this.opacity;
			if (this.transparent === true) data.transparent = this.transparent;
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
			data.colorWrite = this.colorWrite;
			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass; // rotation (SpriteMaterial)

			if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
			if (this.polygonOffset === true) data.polygonOffset = true;
			if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
			if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
			if (this.dashSize !== undefined) data.dashSize = this.dashSize;
			if (this.gapSize !== undefined) data.gapSize = this.gapSize;
			if (this.scale !== undefined) data.scale = this.scale;
			if (this.dithering === true) data.dithering = true;
			if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
			if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
			if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
			if (this.wireframe === true) data.wireframe = this.wireframe;
			if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
			if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
			if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
			if (this.flatShading === true) data.flatShading = this.flatShading;
			if (this.visible === false) data.visible = false;
			if (this.toneMapped === false) data.toneMapped = false;
			if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData; // TODO: Copied from Object3D.toJSON

			function extractFromCache(cache) {
				const values = [];

				for (const key in cache) {
					const data = cache[key];
					delete data.metadata;
					values.push(data);
				}

				return values;
			}

			if (isRoot) {
				const textures = extractFromCache(meta.textures);
				const images = extractFromCache(meta.images);
				if (textures.length > 0) data.textures = textures;
				if (images.length > 0) data.images = images;
			}

			return data;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.name = source.name;
			this.fog = source.fog;
			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;
			this.opacity = source.opacity;
			this.transparent = source.transparent;
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;
			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if (srcPlanes !== null) {
				const n = srcPlanes.length;
				dstPlanes = new Array(n);

				for (let i = 0; i !== n; ++i) {
					dstPlanes[i] = srcPlanes[i].clone();
				}
			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;
			this.shadowSide = source.shadowSide;
			this.colorWrite = source.colorWrite;
			this.precision = source.precision;
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
			this.dithering = source.dithering;
			this.alphaTest = source.alphaTest;
			this.alphaToCoverage = source.alphaToCoverage;
			this.premultipliedAlpha = source.premultipliedAlpha;
			this.visible = source.visible;
			this.toneMapped = source.toneMapped;
			this.userData = JSON.parse(JSON.stringify(source.userData));
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

	}

	Material.prototype.isMaterial = true;

	const _colorKeywords = {
		'aliceblue': 0xF0F8FF,
		'antiquewhite': 0xFAEBD7,
		'aqua': 0x00FFFF,
		'aquamarine': 0x7FFFD4,
		'azure': 0xF0FFFF,
		'beige': 0xF5F5DC,
		'bisque': 0xFFE4C4,
		'black': 0x000000,
		'blanchedalmond': 0xFFEBCD,
		'blue': 0x0000FF,
		'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A,
		'burlywood': 0xDEB887,
		'cadetblue': 0x5F9EA0,
		'chartreuse': 0x7FFF00,
		'chocolate': 0xD2691E,
		'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED,
		'cornsilk': 0xFFF8DC,
		'crimson': 0xDC143C,
		'cyan': 0x00FFFF,
		'darkblue': 0x00008B,
		'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B,
		'darkgray': 0xA9A9A9,
		'darkgreen': 0x006400,
		'darkgrey': 0xA9A9A9,
		'darkkhaki': 0xBDB76B,
		'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F,
		'darkorange': 0xFF8C00,
		'darkorchid': 0x9932CC,
		'darkred': 0x8B0000,
		'darksalmon': 0xE9967A,
		'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B,
		'darkslategray': 0x2F4F4F,
		'darkslategrey': 0x2F4F4F,
		'darkturquoise': 0x00CED1,
		'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493,
		'deepskyblue': 0x00BFFF,
		'dimgray': 0x696969,
		'dimgrey': 0x696969,
		'dodgerblue': 0x1E90FF,
		'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0,
		'forestgreen': 0x228B22,
		'fuchsia': 0xFF00FF,
		'gainsboro': 0xDCDCDC,
		'ghostwhite': 0xF8F8FF,
		'gold': 0xFFD700,
		'goldenrod': 0xDAA520,
		'gray': 0x808080,
		'green': 0x008000,
		'greenyellow': 0xADFF2F,
		'grey': 0x808080,
		'honeydew': 0xF0FFF0,
		'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C,
		'indigo': 0x4B0082,
		'ivory': 0xFFFFF0,
		'khaki': 0xF0E68C,
		'lavender': 0xE6E6FA,
		'lavenderblush': 0xFFF0F5,
		'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD,
		'lightblue': 0xADD8E6,
		'lightcoral': 0xF08080,
		'lightcyan': 0xE0FFFF,
		'lightgoldenrodyellow': 0xFAFAD2,
		'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90,
		'lightgrey': 0xD3D3D3,
		'lightpink': 0xFFB6C1,
		'lightsalmon': 0xFFA07A,
		'lightseagreen': 0x20B2AA,
		'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899,
		'lightslategrey': 0x778899,
		'lightsteelblue': 0xB0C4DE,
		'lightyellow': 0xFFFFE0,
		'lime': 0x00FF00,
		'limegreen': 0x32CD32,
		'linen': 0xFAF0E6,
		'magenta': 0xFF00FF,
		'maroon': 0x800000,
		'mediumaquamarine': 0x66CDAA,
		'mediumblue': 0x0000CD,
		'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB,
		'mediumseagreen': 0x3CB371,
		'mediumslateblue': 0x7B68EE,
		'mediumspringgreen': 0x00FA9A,
		'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585,
		'midnightblue': 0x191970,
		'mintcream': 0xF5FFFA,
		'mistyrose': 0xFFE4E1,
		'moccasin': 0xFFE4B5,
		'navajowhite': 0xFFDEAD,
		'navy': 0x000080,
		'oldlace': 0xFDF5E6,
		'olive': 0x808000,
		'olivedrab': 0x6B8E23,
		'orange': 0xFFA500,
		'orangered': 0xFF4500,
		'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA,
		'palegreen': 0x98FB98,
		'paleturquoise': 0xAFEEEE,
		'palevioletred': 0xDB7093,
		'papayawhip': 0xFFEFD5,
		'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F,
		'pink': 0xFFC0CB,
		'plum': 0xDDA0DD,
		'powderblue': 0xB0E0E6,
		'purple': 0x800080,
		'rebeccapurple': 0x663399,
		'red': 0xFF0000,
		'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1,
		'saddlebrown': 0x8B4513,
		'salmon': 0xFA8072,
		'sandybrown': 0xF4A460,
		'seagreen': 0x2E8B57,
		'seashell': 0xFFF5EE,
		'sienna': 0xA0522D,
		'silver': 0xC0C0C0,
		'skyblue': 0x87CEEB,
		'slateblue': 0x6A5ACD,
		'slategray': 0x708090,
		'slategrey': 0x708090,
		'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F,
		'steelblue': 0x4682B4,
		'tan': 0xD2B48C,
		'teal': 0x008080,
		'thistle': 0xD8BFD8,
		'tomato': 0xFF6347,
		'turquoise': 0x40E0D0,
		'violet': 0xEE82EE,
		'wheat': 0xF5DEB3,
		'white': 0xFFFFFF,
		'whitesmoke': 0xF5F5F5,
		'yellow': 0xFFFF00,
		'yellowgreen': 0x9ACD32
	};
	const _hslA = {
		h: 0,
		s: 0,
		l: 0
	};
	const _hslB = {
		h: 0,
		s: 0,
		l: 0
	};

	function hue2rgb(p, q, t) {
		if (t < 0) t += 1;
		if (t > 1) t -= 1;
		if (t < 1 / 6) return p + (q - p) * 6 * t;
		if (t < 1 / 2) return q;
		if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
		return p;
	}

	function SRGBToLinear(c) {
		return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}

	function LinearToSRGB(c) {
		return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}

	class Color {
		constructor(r, g, b) {
			if (g === undefined && b === undefined) {
				// r is THREE.Color, hex or string
				return this.set(r);
			}

			return this.setRGB(r, g, b);
		}

		set(value) {
			if (value && value.isColor) {
				this.copy(value);
			} else if (typeof value === 'number') {
				this.setHex(value);
			} else if (typeof value === 'string') {
				this.setStyle(value);
			}

			return this;
		}

		setScalar(scalar) {
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
			return this;
		}

		setHex(hex) {
			hex = Math.floor(hex);
			this.r = (hex >> 16 & 255) / 255;
			this.g = (hex >> 8 & 255) / 255;
			this.b = (hex & 255) / 255;
			return this;
		}

		setRGB(r, g, b) {
			this.r = r;
			this.g = g;
			this.b = b;
			return this;
		}

		setHSL(h, s, l) {
			// h,s,l ranges are in 0.0 - 1.0
			h = euclideanModulo(h, 1);
			s = clamp(s, 0, 1);
			l = clamp(l, 0, 1);

			if (s === 0) {
				this.r = this.g = this.b = l;
			} else {
				const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
				const q = 2 * l - p;
				this.r = hue2rgb(q, p, h + 1 / 3);
				this.g = hue2rgb(q, p, h);
				this.b = hue2rgb(q, p, h - 1 / 3);
			}

			return this;
		}

		setStyle(style) {
			function handleAlpha(string) {
				if (string === undefined) return;

				if (parseFloat(string) < 1) {
					console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
				}
			}

			let m;

			if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
				// rgb / hsl
				let color;
				const name = m[1];
				const components = m[2];

				switch (name) {
					case 'rgb':
					case 'rgba':
						if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min(255, parseInt(color[1], 10)) / 255;
							this.g = Math.min(255, parseInt(color[2], 10)) / 255;
							this.b = Math.min(255, parseInt(color[3], 10)) / 255;
							handleAlpha(color[4]);
							return this;
						}

						if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min(100, parseInt(color[1], 10)) / 100;
							this.g = Math.min(100, parseInt(color[2], 10)) / 100;
							this.b = Math.min(100, parseInt(color[3], 10)) / 100;
							handleAlpha(color[4]);
							return this;
						}

						break;

					case 'hsl':
					case 'hsla':
						if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat(color[1]) / 360;
							const s = parseInt(color[2], 10) / 100;
							const l = parseInt(color[3], 10) / 100;
							handleAlpha(color[4]);
							return this.setHSL(h, s, l);
						}

						break;
				}
			} else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
				// hex color
				const hex = m[1];
				const size = hex.length;

				if (size === 3) {
					// #ff0
					this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
					this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
					this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
					return this;
				} else if (size === 6) {
					// #ff0000
					this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
					this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
					this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
					return this;
				}
			}

			if (style && style.length > 0) {
				return this.setColorName(style);
			}

			return this;
		}

		setColorName(style) {
			// color keywords
			const hex = _colorKeywords[style.toLowerCase()];

			if (hex !== undefined) {
				// red
				this.setHex(hex);
			} else {
				// unknown color
				console.warn('THREE.Color: Unknown color ' + style);
			}

			return this;
		}

		clone() {
			return new this.constructor(this.r, this.g, this.b);
		}

		copy(color) {
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
			return this;
		}

		copyGammaToLinear(color, gammaFactor = 2.0) {
			this.r = Math.pow(color.r, gammaFactor);
			this.g = Math.pow(color.g, gammaFactor);
			this.b = Math.pow(color.b, gammaFactor);
			return this;
		}

		copyLinearToGamma(color, gammaFactor = 2.0) {
			const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;
			this.r = Math.pow(color.r, safeInverse);
			this.g = Math.pow(color.g, safeInverse);
			this.b = Math.pow(color.b, safeInverse);
			return this;
		}

		convertGammaToLinear(gammaFactor) {
			this.copyGammaToLinear(this, gammaFactor);
			return this;
		}

		convertLinearToGamma(gammaFactor) {
			this.copyLinearToGamma(this, gammaFactor);
			return this;
		}

		copySRGBToLinear(color) {
			this.r = SRGBToLinear(color.r);
			this.g = SRGBToLinear(color.g);
			this.b = SRGBToLinear(color.b);
			return this;
		}

		copyLinearToSRGB(color) {
			this.r = LinearToSRGB(color.r);
			this.g = LinearToSRGB(color.g);
			this.b = LinearToSRGB(color.b);
			return this;
		}

		convertSRGBToLinear() {
			this.copySRGBToLinear(this);
			return this;
		}

		convertLinearToSRGB() {
			this.copyLinearToSRGB(this);
			return this;
		}

		getHex() {
			return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
		}

		getHexString() {
			return ('000000' + this.getHex().toString(16)).slice(-6);
		}

		getHSL(target) {
			// h,s,l ranges are in 0.0 - 1.0
			const r = this.r,
						g = this.g,
						b = this.b;
			const max = Math.max(r, g, b);
			const min = Math.min(r, g, b);
			let hue, saturation;
			const lightness = (min + max) / 2.0;

			if (min === max) {
				hue = 0;
				saturation = 0;
			} else {
				const delta = max - min;
				saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

				switch (max) {
					case r:
						hue = (g - b) / delta + (g < b ? 6 : 0);
						break;

					case g:
						hue = (b - r) / delta + 2;
						break;

					case b:
						hue = (r - g) / delta + 4;
						break;
				}

				hue /= 6;
			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;
			return target;
		}

		getStyle() {
			return 'rgb(' + (this.r * 255 | 0) + ',' + (this.g * 255 | 0) + ',' + (this.b * 255 | 0) + ')';
		}

		offsetHSL(h, s, l) {
			this.getHSL(_hslA);
			_hslA.h += h;
			_hslA.s += s;
			_hslA.l += l;
			this.setHSL(_hslA.h, _hslA.s, _hslA.l);
			return this;
		}

		add(color) {
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
			return this;
		}

		addColors(color1, color2) {
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
			return this;
		}

		addScalar(s) {
			this.r += s;
			this.g += s;
			this.b += s;
			return this;
		}

		sub(color) {
			this.r = Math.max(0, this.r - color.r);
			this.g = Math.max(0, this.g - color.g);
			this.b = Math.max(0, this.b - color.b);
			return this;
		}

		multiply(color) {
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
			return this;
		}

		multiplyScalar(s) {
			this.r *= s;
			this.g *= s;
			this.b *= s;
			return this;
		}

		lerp(color, alpha) {
			this.r += (color.r - this.r) * alpha;
			this.g += (color.g - this.g) * alpha;
			this.b += (color.b - this.b) * alpha;
			return this;
		}

		lerpColors(color1, color2, alpha) {
			this.r = color1.r + (color2.r - color1.r) * alpha;
			this.g = color1.g + (color2.g - color1.g) * alpha;
			this.b = color1.b + (color2.b - color1.b) * alpha;
			return this;
		}

		lerpHSL(color, alpha) {
			this.getHSL(_hslA);
			color.getHSL(_hslB);
			const h = lerp(_hslA.h, _hslB.h, alpha);
			const s = lerp(_hslA.s, _hslB.s, alpha);
			const l = lerp(_hslA.l, _hslB.l, alpha);
			this.setHSL(h, s, l);
			return this;
		}

		equals(c) {
			return c.r === this.r && c.g === this.g && c.b === this.b;
		}

		fromArray(array, offset = 0) {
			this.r = array[offset];
			this.g = array[offset + 1];
			this.b = array[offset + 2];
			return this;
		}

		toArray(array = [], offset = 0) {
			array[offset] = this.r;
			array[offset + 1] = this.g;
			array[offset + 2] = this.b;
			return array;
		}

		fromBufferAttribute(attribute, index) {
			this.r = attribute.getX(index);
			this.g = attribute.getY(index);
			this.b = attribute.getZ(index);

			if (attribute.normalized === true) {
				// assuming Uint8Array
				this.r /= 255;
				this.g /= 255;
				this.b /= 255;
			}

			return this;
		}

		toJSON() {
			return this.getHex();
		}

	}

	Color.NAMES = _colorKeywords;
	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	depthTest: <bool>,
	 *	depthWrite: <bool>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 * }
	 */

	class MeshBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshBasicMaterial';
			this.color = new Color(0xffffff); // emissive

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	const _vector$9 = /*@__PURE__*/new Vector3();

	const _vector2$1 = /*@__PURE__*/new Vector2();

	class BufferAttribute {
		constructor(array, itemSize, normalized) {
			if (Array.isArray(array)) {
				throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
			}

			this.name = '';
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
		}

		onUploadCallback() {}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.name = source.name;
			this.array = new source.array.constructor(source.array);
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for (let i = 0, l = this.itemSize; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		copyArray(array) {
			this.array.set(array);
			return this;
		}

		copyColorsArray(colors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = colors.length; i < l; i++) {
				let color = colors[i];

				if (color === undefined) {
					console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
					color = new Color();
				}

				array[offset++] = color.r;
				array[offset++] = color.g;
				array[offset++] = color.b;
			}

			return this;
		}

		copyVector2sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
					vector = new Vector2();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
			}

			return this;
		}

		copyVector3sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
					vector = new Vector3();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
			}

			return this;
		}

		copyVector4sArray(vectors) {
			const array = this.array;
			let offset = 0;

			for (let i = 0, l = vectors.length; i < l; i++) {
				let vector = vectors[i];

				if (vector === undefined) {
					console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
					vector = new Vector4();
				}

				array[offset++] = vector.x;
				array[offset++] = vector.y;
				array[offset++] = vector.z;
				array[offset++] = vector.w;
			}

			return this;
		}

		applyMatrix3(m) {
			if (this.itemSize === 2) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector2$1.fromBufferAttribute(this, i);

					_vector2$1.applyMatrix3(m);

					this.setXY(i, _vector2$1.x, _vector2$1.y);
				}
			} else if (this.itemSize === 3) {
				for (let i = 0, l = this.count; i < l; i++) {
					_vector$9.fromBufferAttribute(this, i);

					_vector$9.applyMatrix3(m);

					this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
				}
			}

			return this;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyMatrix4(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.applyNormalMatrix(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$9.x = this.getX(i);
				_vector$9.y = this.getY(i);
				_vector$9.z = this.getZ(i);

				_vector$9.transformDirection(m);

				this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		getX(index) {
			return this.array[index * this.itemSize];
		}

		setX(index, x) {
			this.array[index * this.itemSize] = x;
			return this;
		}

		getY(index) {
			return this.array[index * this.itemSize + 1];
		}

		setY(index, y) {
			this.array[index * this.itemSize + 1] = y;
			return this;
		}

		getZ(index) {
			return this.array[index * this.itemSize + 2];
		}

		setZ(index, z) {
			this.array[index * this.itemSize + 2] = z;
			return this;
		}

		getW(index) {
			return this.array[index * this.itemSize + 3];
		}

		setW(index, w) {
			this.array[index * this.itemSize + 3] = w;
			return this;
		}

		setXY(index, x, y) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index *= this.itemSize;
			this.array[index + 0] = x;
			this.array[index + 1] = y;
			this.array[index + 2] = z;
			this.array[index + 3] = w;
			return this;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		clone() {
			return new this.constructor(this.array, this.itemSize).copy(this);
		}

		toJSON() {
			const data = {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			};
			if (this.name !== '') data.name = this.name;
			if (this.usage !== StaticDrawUsage) data.usage = this.usage;
			if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
			return data;
		}

	}

	BufferAttribute.prototype.isBufferAttribute = true; //

	class Int8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int8Array(array), itemSize, normalized);
		}

	}

	class Uint8BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8Array(array), itemSize, normalized);
		}

	}

	class Uint8ClampedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint8ClampedArray(array), itemSize, normalized);
		}

	}

	class Int16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int16Array(array), itemSize, normalized);
		}

	}

	class Uint16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	class Int32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Int32Array(array), itemSize, normalized);
		}

	}

	class Uint32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint32Array(array), itemSize, normalized);
		}

	}

	class Float16BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Uint16Array(array), itemSize, normalized);
		}

	}

	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	class Float32BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float32Array(array), itemSize, normalized);
		}

	}

	class Float64BufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized) {
			super(new Float64Array(array), itemSize, normalized);
		}

	} //

	function arrayMax(array) {
		if (array.length === 0) return -Infinity;
		let max = array[0];

		for (let i = 1, l = array.length; i < l; ++i) {
			if (array[i] > max) max = array[i];
		}

		return max;
	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray(type, buffer) {
		return new TYPED_ARRAYS[type](buffer);
	}

	let _id = 0;

	const _m1 = /*@__PURE__*/new Matrix4();

	const _obj = /*@__PURE__*/new Object3D();

	const _offset = /*@__PURE__*/new Vector3();

	const _box$1 = /*@__PURE__*/new Box3();

	const _boxMorphTargets = /*@__PURE__*/new Box3();

	const _vector$8 = /*@__PURE__*/new Vector3();

	class BufferGeometry extends EventDispatcher {
		constructor() {
			super();
			Object.defineProperty(this, 'id', {
				value: _id++
			});
			this.uuid = generateUUID();
			this.name = '';
			this.type = 'BufferGeometry';
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.morphTargetsRelative = false;
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
			this.drawRange = {
				start: 0,
				count: Infinity
			};
			this.userData = {};
		}

		getIndex() {
			return this.index;
		}

		setIndex(index) {
			if (Array.isArray(index)) {
				this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
			} else {
				this.index = index;
			}

			return this;
		}

		getAttribute(name) {
			return this.attributes[name];
		}

		setAttribute(name, attribute) {
			this.attributes[name] = attribute;
			return this;
		}

		deleteAttribute(name) {
			delete this.attributes[name];
			return this;
		}

		hasAttribute(name) {
			return this.attributes[name] !== undefined;
		}

		addGroup(start, count, materialIndex = 0) {
			this.groups.push({
				start: start,
				count: count,
				materialIndex: materialIndex
			});
		}

		clearGroups() {
			this.groups = [];
		}

		setDrawRange(start, count) {
			this.drawRange.start = start;
			this.drawRange.count = count;
		}

		applyMatrix4(matrix) {
			const position = this.attributes.position;

			if (position !== undefined) {
				position.applyMatrix4(matrix);
				position.needsUpdate = true;
			}

			const normal = this.attributes.normal;

			if (normal !== undefined) {
				const normalMatrix = new Matrix3().getNormalMatrix(matrix);
				normal.applyNormalMatrix(normalMatrix);
				normal.needsUpdate = true;
			}

			const tangent = this.attributes.tangent;

			if (tangent !== undefined) {
				tangent.transformDirection(matrix);
				tangent.needsUpdate = true;
			}

			if (this.boundingBox !== null) {
				this.computeBoundingBox();
			}

			if (this.boundingSphere !== null) {
				this.computeBoundingSphere();
			}

			return this;
		}

		applyQuaternion(q) {
			_m1.makeRotationFromQuaternion(q);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateX(angle) {
			// rotate geometry around world x-axis
			_m1.makeRotationX(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateY(angle) {
			// rotate geometry around world y-axis
			_m1.makeRotationY(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		rotateZ(angle) {
			// rotate geometry around world z-axis
			_m1.makeRotationZ(angle);

			this.applyMatrix4(_m1);
			return this;
		}

		translate(x, y, z) {
			// translate geometry
			_m1.makeTranslation(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		scale(x, y, z) {
			// scale geometry
			_m1.makeScale(x, y, z);

			this.applyMatrix4(_m1);
			return this;
		}

		lookAt(vector) {
			_obj.lookAt(vector);

			_obj.updateMatrix();

			this.applyMatrix4(_obj.matrix);
			return this;
		}

		center() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(_offset).negate();
			this.translate(_offset.x, _offset.y, _offset.z);
			return this;
		}

		setFromPoints(points) {
			const position = [];

			for (let i = 0, l = points.length; i < l; i++) {
				const point = points[i];
				position.push(point.x, point.y, point.z || 0);
			}

			this.setAttribute('position', new Float32BufferAttribute(position, 3));
			return this;
		}

		computeBoundingBox() {
			if (this.boundingBox === null) {
				this.boundingBox = new Box3();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
				return;
			}

			if (position !== undefined) {
				this.boundingBox.setFromBufferAttribute(position); // process morph attributes if present

				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_box$1.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(this.boundingBox.min, _box$1.min);

							this.boundingBox.expandByPoint(_vector$8);

							_vector$8.addVectors(this.boundingBox.max, _box$1.max);

							this.boundingBox.expandByPoint(_vector$8);
						} else {
							this.boundingBox.expandByPoint(_box$1.min);
							this.boundingBox.expandByPoint(_box$1.max);
						}
					}
				}
			} else {
				this.boundingBox.makeEmpty();
			}

			if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
				console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
			}
		}

		computeBoundingSphere() {
			if (this.boundingSphere === null) {
				this.boundingSphere = new Sphere();
			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if (position && position.isGLBufferAttribute) {
				console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
				this.boundingSphere.set(new Vector3(), Infinity);
				return;
			}

			if (position) {
				// first, find the center of the bounding sphere
				const center = this.boundingSphere.center;

				_box$1.setFromBufferAttribute(position); // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];

						_boxMorphTargets.setFromBufferAttribute(morphAttribute);

						if (this.morphTargetsRelative) {
							_vector$8.addVectors(_box$1.min, _boxMorphTargets.min);

							_box$1.expandByPoint(_vector$8);

							_vector$8.addVectors(_box$1.max, _boxMorphTargets.max);

							_box$1.expandByPoint(_vector$8);
						} else {
							_box$1.expandByPoint(_boxMorphTargets.min);

							_box$1.expandByPoint(_boxMorphTargets.max);
						}
					}
				}

				_box$1.getCenter(center); // second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case


				let maxRadiusSq = 0;

				for (let i = 0, il = position.count; i < il; i++) {
					_vector$8.fromBufferAttribute(position, i);

					maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
				} // process morph attributes if present


				if (morphAttributesPosition) {
					for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
						const morphAttribute = morphAttributesPosition[i];
						const morphTargetsRelative = this.morphTargetsRelative;

						for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
							_vector$8.fromBufferAttribute(morphAttribute, j);

							if (morphTargetsRelative) {
								_offset.fromBufferAttribute(position, j);

								_vector$8.add(_offset);
							}

							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
						}
					}
				}

				this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

				if (isNaN(this.boundingSphere.radius)) {
					console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
				}
			}
		}

		computeFaceNormals() {// backwards compatibility
		}

		computeTangents() {
			const index = this.index;
			const attributes = this.attributes; // based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
				console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
				return;
			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;
			const nVertices = positions.length / 3;

			if (attributes.tangent === undefined) {
				this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * nVertices), 4));
			}

			const tangents = attributes.tangent.array;
			const tan1 = [],
						tan2 = [];

			for (let i = 0; i < nVertices; i++) {
				tan1[i] = new Vector3();
				tan2[i] = new Vector3();
			}

			const vA = new Vector3(),
						vB = new Vector3(),
						vC = new Vector3(),
						uvA = new Vector2(),
						uvB = new Vector2(),
						uvC = new Vector2(),
						sdir = new Vector3(),
						tdir = new Vector3();

			function handleTriangle(a, b, c) {
				vA.fromArray(positions, a * 3);
				vB.fromArray(positions, b * 3);
				vC.fromArray(positions, c * 3);
				uvA.fromArray(uvs, a * 2);
				uvB.fromArray(uvs, b * 2);
				uvC.fromArray(uvs, c * 2);
				vB.sub(vA);
				vC.sub(vA);
				uvB.sub(uvA);
				uvC.sub(uvA);
				const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y); // silently ignore degenerate uv triangles having coincident or colinear vertices

				if (!isFinite(r)) return;
				sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
				tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
				tan1[a].add(sdir);
				tan1[b].add(sdir);
				tan1[c].add(sdir);
				tan2[a].add(tdir);
				tan2[b].add(tdir);
				tan2[c].add(tdir);
			}

			let groups = this.groups;

			if (groups.length === 0) {
				groups = [{
					start: 0,
					count: indices.length
				}];
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
				}
			}

			const tmp = new Vector3(),
						tmp2 = new Vector3();
			const n = new Vector3(),
						n2 = new Vector3();

			function handleVertex(v) {
				n.fromArray(normals, v * 3);
				n2.copy(n);
				const t = tan1[v]; // Gram-Schmidt orthogonalize

				tmp.copy(t);
				tmp.sub(n.multiplyScalar(n.dot(t))).normalize(); // Calculate handedness

				tmp2.crossVectors(n2, t);
				const test = tmp2.dot(tan2[v]);
				const w = test < 0.0 ? -1.0 : 1.0;
				tangents[v * 4] = tmp.x;
				tangents[v * 4 + 1] = tmp.y;
				tangents[v * 4 + 2] = tmp.z;
				tangents[v * 4 + 3] = w;
			}

			for (let i = 0, il = groups.length; i < il; ++i) {
				const group = groups[i];
				const start = group.start;
				const count = group.count;

				for (let j = start, jl = start + count; j < jl; j += 3) {
					handleVertex(indices[j + 0]);
					handleVertex(indices[j + 1]);
					handleVertex(indices[j + 2]);
				}
			}
		}

		computeVertexNormals() {
			const index = this.index;
			const positionAttribute = this.getAttribute('position');

			if (positionAttribute !== undefined) {
				let normalAttribute = this.getAttribute('normal');

				if (normalAttribute === undefined) {
					normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
					this.setAttribute('normal', normalAttribute);
				} else {
					// reset existing normals to zero
					for (let i = 0, il = normalAttribute.count; i < il; i++) {
						normalAttribute.setXYZ(i, 0, 0, 0);
					}
				}

				const pA = new Vector3(),
							pB = new Vector3(),
							pC = new Vector3();
				const nA = new Vector3(),
							nB = new Vector3(),
							nC = new Vector3();
				const cb = new Vector3(),
							ab = new Vector3(); // indexed elements

				if (index) {
					for (let i = 0, il = index.count; i < il; i += 3) {
						const vA = index.getX(i + 0);
						const vB = index.getX(i + 1);
						const vC = index.getX(i + 2);
						pA.fromBufferAttribute(positionAttribute, vA);
						pB.fromBufferAttribute(positionAttribute, vB);
						pC.fromBufferAttribute(positionAttribute, vC);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						nA.fromBufferAttribute(normalAttribute, vA);
						nB.fromBufferAttribute(normalAttribute, vB);
						nC.fromBufferAttribute(normalAttribute, vC);
						nA.add(cb);
						nB.add(cb);
						nC.add(cb);
						normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
						normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
						normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
					}
				} else {
					// non-indexed elements (unconnected triangle soup)
					for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
						pA.fromBufferAttribute(positionAttribute, i + 0);
						pB.fromBufferAttribute(positionAttribute, i + 1);
						pC.fromBufferAttribute(positionAttribute, i + 2);
						cb.subVectors(pC, pB);
						ab.subVectors(pA, pB);
						cb.cross(ab);
						normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
						normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
					}
				}

				this.normalizeNormals();
				normalAttribute.needsUpdate = true;
			}
		}

		merge(geometry, offset) {
			if (!(geometry && geometry.isBufferGeometry)) {
				console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
				return;
			}

			if (offset === undefined) {
				offset = 0;
				console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. ' + 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				if (geometry.attributes[key] === undefined) continue;
				const attribute1 = attributes[key];
				const attributeArray1 = attribute1.array;
				const attribute2 = geometry.attributes[key];
				const attributeArray2 = attribute2.array;
				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

				for (let i = 0, j = attributeOffset; i < length; i++, j++) {
					attributeArray1[j] = attributeArray2[i];
				}
			}

			return this;
		}

		normalizeNormals() {
			const normals = this.attributes.normal;

			for (let i = 0, il = normals.count; i < il; i++) {
				_vector$8.fromBufferAttribute(normals, i);

				_vector$8.normalize();

				normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
			}
		}

		toNonIndexed() {
			function convertBufferAttribute(attribute, indices) {
				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;
				const array2 = new array.constructor(indices.length * itemSize);
				let index = 0,
						index2 = 0;

				for (let i = 0, l = indices.length; i < l; i++) {
					if (attribute.isInterleavedBufferAttribute) {
						index = indices[i] * attribute.data.stride + attribute.offset;
					} else {
						index = indices[i] * itemSize;
					}

					for (let j = 0; j < itemSize; j++) {
						array2[index2++] = array[index++];
					}
				}

				return new BufferAttribute(array2, itemSize, normalized);
			} //


			if (this.index === null) {
				console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
				return this;
			}

			const geometry2 = new BufferGeometry();
			const indices = this.index.array;
			const attributes = this.attributes; // attributes

			for (const name in attributes) {
				const attribute = attributes[name];
				const newAttribute = convertBufferAttribute(attribute, indices);
				geometry2.setAttribute(name, newAttribute);
			} // morph attributes


			const morphAttributes = this.morphAttributes;

			for (const name in morphAttributes) {
				const morphArray = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, il = morphAttribute.length; i < il; i++) {
					const attribute = morphAttribute[i];
					const newAttribute = convertBufferAttribute(attribute, indices);
					morphArray.push(newAttribute);
				}

				geometry2.morphAttributes[name] = morphArray;
			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative; // groups

			const groups = this.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				geometry2.addGroup(group.start, group.count, group.materialIndex);
			}

			return geometry2;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			}; // standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if (this.name !== '') data.name = this.name;
			if (Object.keys(this.userData).length > 0) data.userData = this.userData;

			if (this.parameters !== undefined) {
				const parameters = this.parameters;

				for (const key in parameters) {
					if (parameters[key] !== undefined) data[key] = parameters[key];
				}

				return data;
			} // for simplicity the code assumes attributes are not shared across geometries, see #15811


			data.data = {
				attributes: {}
			};
			const index = this.index;

			if (index !== null) {
				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call(index.array)
				};
			}

			const attributes = this.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				data.data.attributes[key] = attribute.toJSON(data.data);
			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for (const key in this.morphAttributes) {
				const attributeArray = this.morphAttributes[key];
				const array = [];

				for (let i = 0, il = attributeArray.length; i < il; i++) {
					const attribute = attributeArray[i];
					array.push(attribute.toJSON(data.data));
				}

				if (array.length > 0) {
					morphAttributes[key] = array;
					hasMorphAttributes = true;
				}
			}

			if (hasMorphAttributes) {
				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;
			}

			const groups = this.groups;

			if (groups.length > 0) {
				data.data.groups = JSON.parse(JSON.stringify(groups));
			}

			const boundingSphere = this.boundingSphere;

			if (boundingSphere !== null) {
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
			}

			return data;
		}

		clone() {
			/*
			 // Handle primitives
				 const parameters = this.parameters;
				 if ( parameters !== undefined ) {
				 const values = [];
				 for ( const key in parameters ) {
				 values.push( parameters[ key ] );
				 }
				 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
				 }
				 return new this.constructor().copy( this );
			 */
			return new BufferGeometry().copy(this);
		}

		copy(source) {
			// reset
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null; // used for storing cloned, shared data

			const data = {}; // name

			this.name = source.name; // index

			const index = source.index;

			if (index !== null) {
				this.setIndex(index.clone(data));
			} // attributes


			const attributes = source.attributes;

			for (const name in attributes) {
				const attribute = attributes[name];
				this.setAttribute(name, attribute.clone(data));
			} // morph attributes


			const morphAttributes = source.morphAttributes;

			for (const name in morphAttributes) {
				const array = [];
				const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

				for (let i = 0, l = morphAttribute.length; i < l; i++) {
					array.push(morphAttribute[i].clone(data));
				}

				this.morphAttributes[name] = array;
			}

			this.morphTargetsRelative = source.morphTargetsRelative; // groups

			const groups = source.groups;

			for (let i = 0, l = groups.length; i < l; i++) {
				const group = groups[i];
				this.addGroup(group.start, group.count, group.materialIndex);
			} // bounding box


			const boundingBox = source.boundingBox;

			if (boundingBox !== null) {
				this.boundingBox = boundingBox.clone();
			} // bounding sphere


			const boundingSphere = source.boundingSphere;

			if (boundingSphere !== null) {
				this.boundingSphere = boundingSphere.clone();
			} // draw range


			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count; // user data

			this.userData = source.userData;
			return this;
		}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	BufferGeometry.prototype.isBufferGeometry = true;

	const _inverseMatrix$2 = /*@__PURE__*/new Matrix4();

	const _ray$2 = /*@__PURE__*/new Ray();

	const _sphere$3 = /*@__PURE__*/new Sphere();

	const _vA$1 = /*@__PURE__*/new Vector3();

	const _vB$1 = /*@__PURE__*/new Vector3();

	const _vC$1 = /*@__PURE__*/new Vector3();

	const _tempA = /*@__PURE__*/new Vector3();

	const _tempB = /*@__PURE__*/new Vector3();

	const _tempC = /*@__PURE__*/new Vector3();

	const _morphA = /*@__PURE__*/new Vector3();

	const _morphB = /*@__PURE__*/new Vector3();

	const _morphC = /*@__PURE__*/new Vector3();

	const _uvA$1 = /*@__PURE__*/new Vector2();

	const _uvB$1 = /*@__PURE__*/new Vector2();

	const _uvC$1 = /*@__PURE__*/new Vector2();

	const _intersectionPoint = /*@__PURE__*/new Vector3();

	const _intersectionPointWorld = /*@__PURE__*/new Vector3();

	class Mesh extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
			super();
			this.type = 'Mesh';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);

			if (source.morphTargetInfluences !== undefined) {
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
			}

			if (source.morphTargetDictionary !== undefined) {
				this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
			}

			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;
			if (material === undefined) return; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$3.copy(geometry.boundingSphere);

			_sphere$3.applyMatrix4(matrixWorld);

			if (raycaster.ray.intersectsSphere(_sphere$3) === false) return; //

			_inverseMatrix$2.copy(matrixWorld).invert();

			_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2); // Check boundingBox before continuing


			if (geometry.boundingBox !== null) {
				if (_ray$2.intersectsBox(geometry.boundingBox) === false) return;
			}

			let intersection;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if (index !== null) {
					// indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = index.getX(j);
								const b = index.getX(j + 1);
								const c = index.getX(j + 2);
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(index.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = index.getX(i);
							const b = index.getX(i + 1);
							const c = index.getX(i + 2);
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				} else if (position !== undefined) {
					// non-indexed buffer geometry
					if (Array.isArray(material)) {
						for (let i = 0, il = groups.length; i < il; i++) {
							const group = groups[i];
							const groupMaterial = material[group.materialIndex];
							const start = Math.max(group.start, drawRange.start);
							const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);

							for (let j = start, jl = end; j < jl; j += 3) {
								const a = j;
								const b = j + 1;
								const c = j + 2;
								intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

								if (intersection) {
									intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics

									intersection.face.materialIndex = group.materialIndex;
									intersects.push(intersection);
								}
							}
						}
					} else {
						const start = Math.max(0, drawRange.start);
						const end = Math.min(position.count, drawRange.start + drawRange.count);

						for (let i = start, il = end; i < il; i += 3) {
							const a = i;
							const b = i + 1;
							const c = i + 2;
							intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);

							if (intersection) {
								intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics

								intersects.push(intersection);
							}
						}
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

	}

	Mesh.prototype.isMesh = true;

	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
		let intersect;

		if (material.side === BackSide) {
			intersect = ray.intersectTriangle(pC, pB, pA, true, point);
		} else {
			intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
		}

		if (intersect === null) return null;

		_intersectionPointWorld.copy(point);

		_intersectionPointWorld.applyMatrix4(object.matrixWorld);

		const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
		if (distance < raycaster.near || distance > raycaster.far) return null;
		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};
	}

	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
		_vA$1.fromBufferAttribute(position, a);

		_vB$1.fromBufferAttribute(position, b);

		_vC$1.fromBufferAttribute(position, c);

		const morphInfluences = object.morphTargetInfluences;

		if (morphPosition && morphInfluences) {
			_morphA.set(0, 0, 0);

			_morphB.set(0, 0, 0);

			_morphC.set(0, 0, 0);

			for (let i = 0, il = morphPosition.length; i < il; i++) {
				const influence = morphInfluences[i];
				const morphAttribute = morphPosition[i];
				if (influence === 0) continue;

				_tempA.fromBufferAttribute(morphAttribute, a);

				_tempB.fromBufferAttribute(morphAttribute, b);

				_tempC.fromBufferAttribute(morphAttribute, c);

				if (morphTargetsRelative) {
					_morphA.addScaledVector(_tempA, influence);

					_morphB.addScaledVector(_tempB, influence);

					_morphC.addScaledVector(_tempC, influence);
				} else {
					_morphA.addScaledVector(_tempA.sub(_vA$1), influence);

					_morphB.addScaledVector(_tempB.sub(_vB$1), influence);

					_morphC.addScaledVector(_tempC.sub(_vC$1), influence);
				}
			}

			_vA$1.add(_morphA);

			_vB$1.add(_morphB);

			_vC$1.add(_morphC);
		}

		if (object.isSkinnedMesh) {
			object.boneTransform(a, _vA$1);
			object.boneTransform(b, _vB$1);
			object.boneTransform(c, _vC$1);
		}

		const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);

		if (intersection) {
			if (uv) {
				_uvA$1.fromBufferAttribute(uv, a);

				_uvB$1.fromBufferAttribute(uv, b);

				_uvC$1.fromBufferAttribute(uv, c);

				intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			if (uv2) {
				_uvA$1.fromBufferAttribute(uv2, a);

				_uvB$1.fromBufferAttribute(uv2, b);

				_uvC$1.fromBufferAttribute(uv2, c);

				intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
			}

			const face = {
				a: a,
				b: b,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};
			Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
			intersection.face = face;
		}

		return intersection;
	}

	class BoxGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
			super();
			this.type = 'BoxGeometry';
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
			const scope = this; // segments

			widthSegments = Math.floor(widthSegments);
			heightSegments = Math.floor(heightSegments);
			depthSegments = Math.floor(depthSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let numberOfVertices = 0;
			let groupStart = 0; // build each side of the box geometry

			buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px

			buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx

			buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py

			buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny

			buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz

			buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz
			// build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;
				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;
				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;
				let vertexCounter = 0;
				let groupCount = 0;
				const vector = new Vector3(); // generate vertices, normals and uvs

				for (let iy = 0; iy < gridY1; iy++) {
					const y = iy * segmentHeight - heightHalf;

					for (let ix = 0; ix < gridX1; ix++) {
						const x = ix * segmentWidth - widthHalf; // set values to correct vector component

						vector[u] = x * udir;
						vector[v] = y * vdir;
						vector[w] = depthHalf; // now apply vector to vertex buffer

						vertices.push(vector.x, vector.y, vector.z); // set values to correct vector component

						vector[u] = 0;
						vector[v] = 0;
						vector[w] = depth > 0 ? 1 : -1; // now apply vector to normal buffer

						normals.push(vector.x, vector.y, vector.z); // uvs

						uvs.push(ix / gridX);
						uvs.push(1 - iy / gridY); // counters

						vertexCounter += 1;
					}
				} // indices
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment


				for (let iy = 0; iy < gridY; iy++) {
					for (let ix = 0; ix < gridX; ix++) {
						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * (iy + 1);
						const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
						const d = numberOfVertices + (ix + 1) + gridX1 * iy; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // increase counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, materialIndex); // calculate new start value for groups

				groupStart += groupCount; // update total number of vertices

				numberOfVertices += vertexCounter;
			}
		}

		static fromJSON(data) {
			return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
		}

	}

	/**
	 * Uniform Utilities
	 */
	function cloneUniforms(src) {
		const dst = {};

		for (const u in src) {
			dst[u] = {};

			for (const p in src[u]) {
				const property = src[u][p];

				if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
					dst[u][p] = property.clone();
				} else if (Array.isArray(property)) {
					dst[u][p] = property.slice();
				} else {
					dst[u][p] = property;
				}
			}
		}

		return dst;
	}
	function mergeUniforms(uniforms) {
		const merged = {};

		for (let u = 0; u < uniforms.length; u++) {
			const tmp = cloneUniforms(uniforms[u]);

			for (const p in tmp) {
				merged[p] = tmp[p];
			}
		}

		return merged;
	} // Legacy

	const UniformsUtils = {
		clone: cloneUniforms,
		merge: mergeUniforms
	};

	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

	/**
	 * parameters = {
	 *	defines: { "label" : "value" },
	 *	uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *	fragmentShader: <string>,
	 *	vertexShader: <string>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	lights: <bool>
	 * }
	 */

	class ShaderMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShaderMaterial';
			this.defines = {};
			this.uniforms = {};
			this.vertexShader = default_vertex;
			this.fragmentShader = default_fragment;
			this.linewidth = 1;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false; // set to use scene fog

			this.lights = false; // set to use scene lights

			this.clipping = false; // set to use user-defined clipping planes

			this.extensions = {
				derivatives: false,
				// set to use derivatives
				fragDepth: false,
				// set to use fragment depth values
				drawBuffers: false,
				// set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD

			}; // When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.

			this.defaultAttributeValues = {
				'color': [1, 1, 1],
				'uv': [0, 0],
				'uv2': [0, 0]
			};
			this.index0AttributeName = undefined;
			this.uniformsNeedUpdate = false;
			this.glslVersion = null;

			if (parameters !== undefined) {
				if (parameters.attributes !== undefined) {
					console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');
				}

				this.setValues(parameters);
			}
		}

		copy(source) {
			super.copy(source);
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
			this.uniforms = cloneUniforms(source.uniforms);
			this.defines = Object.assign({}, source.defines);
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.lights = source.lights;
			this.clipping = source.clipping;
			this.extensions = Object.assign({}, source.extensions);
			this.glslVersion = source.glslVersion;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.glslVersion = this.glslVersion;
			data.uniforms = {};

			for (const name in this.uniforms) {
				const uniform = this.uniforms[name];
				const value = uniform.value;

				if (value && value.isTexture) {
					data.uniforms[name] = {
						type: 't',
						value: value.toJSON(meta).uuid
					};
				} else if (value && value.isColor) {
					data.uniforms[name] = {
						type: 'c',
						value: value.getHex()
					};
				} else if (value && value.isVector2) {
					data.uniforms[name] = {
						type: 'v2',
						value: value.toArray()
					};
				} else if (value && value.isVector3) {
					data.uniforms[name] = {
						type: 'v3',
						value: value.toArray()
					};
				} else if (value && value.isVector4) {
					data.uniforms[name] = {
						type: 'v4',
						value: value.toArray()
					};
				} else if (value && value.isMatrix3) {
					data.uniforms[name] = {
						type: 'm3',
						value: value.toArray()
					};
				} else if (value && value.isMatrix4) {
					data.uniforms[name] = {
						type: 'm4',
						value: value.toArray()
					};
				} else {
					data.uniforms[name] = {
						value: value
					}; // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
				}
			}

			if (Object.keys(this.defines).length > 0) data.defines = this.defines;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
			const extensions = {};

			for (const key in this.extensions) {
				if (this.extensions[key] === true) extensions[key] = true;
			}

			if (Object.keys(extensions).length > 0) data.extensions = extensions;
			return data;
		}

	}

	ShaderMaterial.prototype.isShaderMaterial = true;

	class Camera extends Object3D {
		constructor() {
			super();
			this.type = 'Camera';
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
			this.projectionMatrixInverse = new Matrix4();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.matrixWorldInverse.copy(source.matrixWorldInverse);
			this.projectionMatrix.copy(source.projectionMatrix);
			this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
			return this;
		}

		getWorldDirection(target) {
			this.updateWorldMatrix(true, false);
			const e = this.matrixWorld.elements;
			return target.set(-e[8], -e[9], -e[10]).normalize();
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		updateWorldMatrix(updateParents, updateChildren) {
			super.updateWorldMatrix(updateParents, updateChildren);
			this.matrixWorldInverse.copy(this.matrixWorld).invert();
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Camera.prototype.isCamera = true;

	class PerspectiveCamera extends Camera {
		constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
			super();
			this.type = 'PerspectiveCamera';
			this.fov = fov;
			this.zoom = 1;
			this.near = near;
			this.far = far;
			this.focus = 10;
			this.aspect = aspect;
			this.view = null;
			this.filmGauge = 35; // width of the film (default in millimeters)

			this.filmOffset = 0; // horizontal film offset (same unit as gauge)

			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.fov = source.fov;
			this.zoom = source.zoom;
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
			return this;
		}
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */


		setFocalLength(focalLength) {
			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
			this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
			this.updateProjectionMatrix();
		}
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */


		getFocalLength() {
			const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
			return 0.5 * this.getFilmHeight() / vExtentSlope;
		}

		getEffectiveFOV() {
			return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
		}

		getFilmWidth() {
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min(this.aspect, 1);
		}

		getFilmHeight() {
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max(this.aspect, 1);
		}
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *	 +---+---+---+
		 *	 | A | B | C |
		 *	 +---+---+---+
		 *	 | D | E | F |
		 *	 +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *	 const w = 1920;
		 *	 const h = 1080;
		 *	 const fullWidth = w * 3;
		 *	 const fullHeight = h * 2;
		 *
		 *	 --A--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *	 --B--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *	 --C--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *	 --D--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *	 --E--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *	 --F--
		 *	 camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *	 Note there is no reason monitors have to be the same size or in a grid.
		 */


		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			this.aspect = fullWidth / fullHeight;

			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const near = this.near;
			let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = -0.5 * width;
			const view = this.view;

			if (this.view !== null && this.view.enabled) {
				const fullWidth = view.fullWidth,
							fullHeight = view.fullHeight;
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
			}

			const skew = this.filmOffset;
			if (skew !== 0) left += near * skew / this.getFilmWidth();
			this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
			data.object.aspect = this.aspect;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
			return data;
		}

	}

	PerspectiveCamera.prototype.isPerspectiveCamera = true;

	const fov = 90,
				aspect = 1;

	class CubeCamera extends Object3D {
		constructor(near, far, renderTarget) {
			super();
			this.type = 'CubeCamera';

			if (renderTarget.isWebGLCubeRenderTarget !== true) {
				console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
				return;
			}

			this.renderTarget = renderTarget;
			const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
			cameraPX.layers = this.layers;
			cameraPX.up.set(0, -1, 0);
			cameraPX.lookAt(new Vector3(1, 0, 0));
			this.add(cameraPX);
			const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
			cameraNX.layers = this.layers;
			cameraNX.up.set(0, -1, 0);
			cameraNX.lookAt(new Vector3(-1, 0, 0));
			this.add(cameraNX);
			const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
			cameraPY.layers = this.layers;
			cameraPY.up.set(0, 0, 1);
			cameraPY.lookAt(new Vector3(0, 1, 0));
			this.add(cameraPY);
			const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
			cameraNY.layers = this.layers;
			cameraNY.up.set(0, 0, -1);
			cameraNY.lookAt(new Vector3(0, -1, 0));
			this.add(cameraNY);
			const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraPZ.layers = this.layers;
			cameraPZ.up.set(0, -1, 0);
			cameraPZ.lookAt(new Vector3(0, 0, 1));
			this.add(cameraPZ);
			const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
			cameraNZ.layers = this.layers;
			cameraNZ.up.set(0, -1, 0);
			cameraNZ.lookAt(new Vector3(0, 0, -1));
			this.add(cameraNZ);
		}

		update(renderer, scene) {
			if (this.parent === null) this.updateMatrixWorld();
			const renderTarget = this.renderTarget;
			const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
			const currentXrEnabled = renderer.xr.enabled;
			const currentRenderTarget = renderer.getRenderTarget();
			renderer.xr.enabled = false;
			const generateMipmaps = renderTarget.texture.generateMipmaps;
			renderTarget.texture.generateMipmaps = false;
			renderer.setRenderTarget(renderTarget, 0);
			renderer.render(scene, cameraPX);
			renderer.setRenderTarget(renderTarget, 1);
			renderer.render(scene, cameraNX);
			renderer.setRenderTarget(renderTarget, 2);
			renderer.render(scene, cameraPY);
			renderer.setRenderTarget(renderTarget, 3);
			renderer.render(scene, cameraNY);
			renderer.setRenderTarget(renderTarget, 4);
			renderer.render(scene, cameraPZ);
			renderTarget.texture.generateMipmaps = generateMipmaps;
			renderer.setRenderTarget(renderTarget, 5);
			renderer.render(scene, cameraNZ);
			renderer.setRenderTarget(currentRenderTarget);
			renderer.xr.enabled = currentXrEnabled;
		}

	}

	class CubeTexture extends Texture {
		constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			format = format !== undefined ? format : RGBFormat;
			super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.flipY = false;
		}

		get images() {
			return this.image;
		}

		set images(value) {
			this.image = value;
		}

	}

	CubeTexture.prototype.isCubeTexture = true;

	class WebGLCubeRenderTarget extends WebGLRenderTarget {
		constructor(size, options, dummy) {
			if (Number.isInteger(options)) {
				console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');
				options = dummy;
			}

			super(size, size, options);
			options = options || {}; // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.
			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
			// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

			this.texture = new CubeTexture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
			this.texture.isRenderTargetTexture = true;
			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
			this.texture._needsFlipEnvMap = false;
		}

		fromEquirectangularTexture(renderer, texture) {
			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859

			this.texture.encoding = texture.encoding;
			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;
			const shader = {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader:
				/* glsl */
				`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
				fragmentShader:
				/* glsl */
				`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};
			const geometry = new BoxGeometry(5, 5, 5);
			const material = new ShaderMaterial({
				name: 'CubemapFromEquirect',
				uniforms: cloneUniforms(shader.uniforms),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending
			});
			material.uniforms.tEquirect.value = texture;
			const mesh = new Mesh(geometry, material);
			const currentMinFilter = texture.minFilter; // Avoid blurred poles

			if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
			const camera = new CubeCamera(1, 10, this);
			camera.update(renderer, mesh);
			texture.minFilter = currentMinFilter;
			mesh.geometry.dispose();
			mesh.material.dispose();
			return this;
		}

		clear(renderer, color, depth, stencil) {
			const currentRenderTarget = renderer.getRenderTarget();

			for (let i = 0; i < 6; i++) {
				renderer.setRenderTarget(this, i);
				renderer.clear(color, depth, stencil);
			}

			renderer.setRenderTarget(currentRenderTarget);
		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	const _vector1 = /*@__PURE__*/new Vector3();

	const _vector2 = /*@__PURE__*/new Vector3();

	const _normalMatrix = /*@__PURE__*/new Matrix3();

	class Plane {
		constructor(normal = new Vector3(1, 0, 0), constant = 0) {
			// normal is assumed to be normalized
			this.normal = normal;
			this.constant = constant;
		}

		set(normal, constant) {
			this.normal.copy(normal);
			this.constant = constant;
			return this;
		}

		setComponents(x, y, z, w) {
			this.normal.set(x, y, z);
			this.constant = w;
			return this;
		}

		setFromNormalAndCoplanarPoint(normal, point) {
			this.normal.copy(normal);
			this.constant = -point.dot(this.normal);
			return this;
		}

		setFromCoplanarPoints(a, b, c) {
			const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize(); // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?


			this.setFromNormalAndCoplanarPoint(normal, a);
			return this;
		}

		copy(plane) {
			this.normal.copy(plane.normal);
			this.constant = plane.constant;
			return this;
		}

		normalize() {
			// Note: will lead to a divide by zero if the plane is invalid.
			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar(inverseNormalLength);
			this.constant *= inverseNormalLength;
			return this;
		}

		negate() {
			this.constant *= -1;
			this.normal.negate();
			return this;
		}

		distanceToPoint(point) {
			return this.normal.dot(point) + this.constant;
		}

		distanceToSphere(sphere) {
			return this.distanceToPoint(sphere.center) - sphere.radius;
		}

		projectPoint(point, target) {
			return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
		}

		intersectLine(line, target) {
			const direction = line.delta(_vector1);
			const denominator = this.normal.dot(direction);

			if (denominator === 0) {
				// line is coplanar, return origin
				if (this.distanceToPoint(line.start) === 0) {
					return target.copy(line.start);
				} // Unsure if this is the correct method to handle this case.


				return null;
			}

			const t = -(line.start.dot(this.normal) + this.constant) / denominator;

			if (t < 0 || t > 1) {
				return null;
			}

			return target.copy(direction).multiplyScalar(t).add(line.start);
		}

		intersectsLine(line) {
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
			const startSign = this.distanceToPoint(line.start);
			const endSign = this.distanceToPoint(line.end);
			return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
		}

		intersectsBox(box) {
			return box.intersectsPlane(this);
		}

		intersectsSphere(sphere) {
			return sphere.intersectsPlane(this);
		}

		coplanarPoint(target) {
			return target.copy(this.normal).multiplyScalar(-this.constant);
		}

		applyMatrix4(matrix, optionalNormalMatrix) {
			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

			const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
			const normal = this.normal.applyMatrix3(normalMatrix).normalize();
			this.constant = -referencePoint.dot(normal);
			return this;
		}

		translate(offset) {
			this.constant -= offset.dot(this.normal);
			return this;
		}

		equals(plane) {
			return plane.normal.equals(this.normal) && plane.constant === this.constant;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	Plane.prototype.isPlane = true;

	const _sphere$2 = /*@__PURE__*/new Sphere();

	const _vector$7 = /*@__PURE__*/new Vector3();

	class Frustum {
		constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
			this.planes = [p0, p1, p2, p3, p4, p5];
		}

		set(p0, p1, p2, p3, p4, p5) {
			const planes = this.planes;
			planes[0].copy(p0);
			planes[1].copy(p1);
			planes[2].copy(p2);
			planes[3].copy(p3);
			planes[4].copy(p4);
			planes[5].copy(p5);
			return this;
		}

		copy(frustum) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				planes[i].copy(frustum.planes[i]);
			}

			return this;
		}

		setFromProjectionMatrix(m) {
			const planes = this.planes;
			const me = m.elements;
			const me0 = me[0],
						me1 = me[1],
						me2 = me[2],
						me3 = me[3];
			const me4 = me[4],
						me5 = me[5],
						me6 = me[6],
						me7 = me[7];
			const me8 = me[8],
						me9 = me[9],
						me10 = me[10],
						me11 = me[11];
			const me12 = me[12],
						me13 = me[13],
						me14 = me[14],
						me15 = me[15];
			planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
			planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
			planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
			planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
			planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
			planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
			return this;
		}

		intersectsObject(object) {
			const geometry = object.geometry;
			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSprite(sprite) {
			_sphere$2.center.set(0, 0, 0);

			_sphere$2.radius = 0.7071067811865476;

			_sphere$2.applyMatrix4(sprite.matrixWorld);

			return this.intersectsSphere(_sphere$2);
		}

		intersectsSphere(sphere) {
			const planes = this.planes;
			const center = sphere.center;
			const negRadius = -sphere.radius;

			for (let i = 0; i < 6; i++) {
				const distance = planes[i].distanceToPoint(center);

				if (distance < negRadius) {
					return false;
				}
			}

			return true;
		}

		intersectsBox(box) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				const plane = planes[i]; // corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if (plane.distanceToPoint(_vector$7) < 0) {
					return false;
				}
			}

			return true;
		}

		containsPoint(point) {
			const planes = this.planes;

			for (let i = 0; i < 6; i++) {
				if (planes[i].distanceToPoint(point) < 0) {
					return false;
				}
			}

			return true;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	function WebGLAnimation() {
		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame(time, frame) {
			animationLoop(time, frame);
			requestId = context.requestAnimationFrame(onAnimationFrame);
		}

		return {
			start: function () {
				if (isAnimating === true) return;
				if (animationLoop === null) return;
				requestId = context.requestAnimationFrame(onAnimationFrame);
				isAnimating = true;
			},
			stop: function () {
				context.cancelAnimationFrame(requestId);
				isAnimating = false;
			},
			setAnimationLoop: function (callback) {
				animationLoop = callback;
			},
			setContext: function (value) {
				context = value;
			}
		};
	}

	function WebGLAttributes(gl, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		const buffers = new WeakMap();

		function createBuffer(attribute, bufferType) {
			const array = attribute.array;
			const usage = attribute.usage;
			const buffer = gl.createBuffer();
			gl.bindBuffer(bufferType, buffer);
			gl.bufferData(bufferType, array, usage);
			attribute.onUploadCallback();
			let type = gl.FLOAT;

			if (array instanceof Float32Array) {
				type = gl.FLOAT;
			} else if (array instanceof Float64Array) {
				console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');
			} else if (array instanceof Uint16Array) {
				if (attribute.isFloat16BufferAttribute) {
					if (isWebGL2) {
						type = gl.HALF_FLOAT;
					} else {
						console.warn('THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.');
					}
				} else {
					type = gl.UNSIGNED_SHORT;
				}
			} else if (array instanceof Int16Array) {
				type = gl.SHORT;
			} else if (array instanceof Uint32Array) {
				type = gl.UNSIGNED_INT;
			} else if (array instanceof Int32Array) {
				type = gl.INT;
			} else if (array instanceof Int8Array) {
				type = gl.BYTE;
			} else if (array instanceof Uint8Array) {
				type = gl.UNSIGNED_BYTE;
			} else if (array instanceof Uint8ClampedArray) {
				type = gl.UNSIGNED_BYTE;
			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
		}

		function updateBuffer(buffer, attribute, bufferType) {
			const array = attribute.array;
			const updateRange = attribute.updateRange;
			gl.bindBuffer(bufferType, buffer);

			if (updateRange.count === -1) {
				// Not using update ranges
				gl.bufferSubData(bufferType, 0, array);
			} else {
				if (isWebGL2) {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
				} else {
					gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
				}

				updateRange.count = -1; // reset range
			}
		} //


		function get(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			return buffers.get(attribute);
		}

		function remove(attribute) {
			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data) {
				gl.deleteBuffer(data.buffer);
				buffers.delete(attribute);
			}
		}

		function update(attribute, bufferType) {
			if (attribute.isGLBufferAttribute) {
				const cached = buffers.get(attribute);

				if (!cached || cached.version < attribute.version) {
					buffers.set(attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					});
				}

				return;
			}

			if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
			const data = buffers.get(attribute);

			if (data === undefined) {
				buffers.set(attribute, createBuffer(attribute, bufferType));
			} else if (data.version < attribute.version) {
				updateBuffer(data.buffer, attribute, bufferType);
				data.version = attribute.version;
			}
		}

		return {
			get: get,
			remove: remove,
			update: update
		};
	}

	class PlaneGeometry extends BufferGeometry {
		constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
			super();
			this.type = 'PlaneGeometry';
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
			const width_half = width / 2;
			const height_half = height / 2;
			const gridX = Math.floor(widthSegments);
			const gridY = Math.floor(heightSegments);
			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;
			const segment_width = width / gridX;
			const segment_height = height / gridY; //

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for (let iy = 0; iy < gridY1; iy++) {
				const y = iy * segment_height - height_half;

				for (let ix = 0; ix < gridX1; ix++) {
					const x = ix * segment_width - width_half;
					vertices.push(x, -y, 0);
					normals.push(0, 0, 1);
					uvs.push(ix / gridX);
					uvs.push(1 - iy / gridY);
				}
			}

			for (let iy = 0; iy < gridY; iy++) {
				for (let ix = 0; ix < gridX; ix++) {
					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * (iy + 1);
					const c = ix + 1 + gridX1 * (iy + 1);
					const d = ix + 1 + gridX1 * iy;
					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			}

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
		}

	}

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "vec3 transformed = vec3( position );";

	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in vec3 f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn ( f90 - f0 ) * fresnel + f0;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in vec3 f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, vec3( 1.0 ), dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

	var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

	var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\t#ifdef SPECULAR\n\t\tvec3 specularIntensityFactor = vec3( specularIntensity );\n\t\tvec3 specularTintFactor = specularTint;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARTINTMAP\n\t\t\tspecularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularColorF90 = mix( specularIntensityFactor, vec3( 1.0 ), metalnessFactor );\n\t#else\n\t\tvec3 specularIntensityFactor = vec3( 1.0 );\n\t\tvec3 specularTintFactor = vec3( 1.0 );\n\t\tmaterial.specularColorF90 = vec3( 1.0 );\n\t#endif\n\tmaterial.specularColor = mix( min( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularColorF90 = vec3( 1.0 );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n\tvec3 specularColorF90;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(		0, 1,		0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), vec3( 1.0 ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularColorF90, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

	var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

	var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t	texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t	f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(	1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,	1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,	1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

	var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition.xyz / vWorldPosition.w;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tfloat ior = ( 1.0 + 0.4 * reflectivity ) / ( 1.0 - 0.4 * reflectivity );\n\tvec3 transmission = transmissionFactor * getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationTint, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission, transmissionFactor );\n#endif";

	var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec4 vWorldPosition;\n\tvec3 getVolumeTransmissionRay(vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix) {\n\t\tvec3 refractionVector = refract(-v, normalize(n), 1.0 / ior);\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length(vec3(modelMatrix[0].xyz));\n\t\tmodelScale.y = length(vec3(modelMatrix[1].xyz));\n\t\tmodelScale.z = length(vec3(modelMatrix[2].xyz));\n\t\treturn normalize(refractionVector) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness(float roughness, float ior) {\n\t\treturn roughness * clamp(ior * 2.0 - 2.0, 0.0, 1.0);\n\t}\n\tvec3 getTransmissionSample(vec2 fragCoord, float roughness, float ior) {\n\t\tfloat framebufferLod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness, ior);\n\t\treturn texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod).rgb;\n\t}\n\tvec3 applyVolumeAttenuation(vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance) {\n\t\tif (attenuationDistance == 0.0) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log(attenuationColor) / attenuationDistance;\n\t\t\tvec3 transmittance = exp(-attenuationCoefficient * transmissionDistance);\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec3 getIBLVolumeRefraction(vec3 n, vec3 v, float perceptualRoughness, vec3 baseColor, vec3 specularColor,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4(refractedRayExit, 1.0);\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec3 transmittedLight = getTransmissionSample(refractionCoords, perceptualRoughness, ior);\n\t\tvec3 attenuatedColor = applyVolumeAttenuation(transmittedLight, length(transmissionRay), attenuationColor, attenuationDistance);\n\t\treturn (1.0 - specularColor) * attenuatedColor * baseColor;\n\t}\n#endif";

	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t\t#ifdef USE_TANGENT\n\t\t\tvTangent = normalize( transformedTangent );\n\t\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t\t#endif\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationTint;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularTint;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARTINTMAP\n\t\tuniform sampler2D specularTintMap;\n\t#endif\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <transmission_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#ifdef USE_TRANSMISSION\n\tvarying vec4 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition;\n#endif\n}";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmission_fragment: transmission_fragment,
		transmission_pars_fragment: transmission_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {
		common: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			map: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			},
			uv2Transform: {
				value: new Matrix3()
			},
			alphaMap: {
				value: null
			}
		},
		specularmap: {
			specularMap: {
				value: null
			}
		},
		envmap: {
			envMap: {
				value: null
			},
			flipEnvMap: {
				value: -1
			},
			reflectivity: {
				value: 1.0
			},
			refractionRatio: {
				value: 0.98
			},
			maxMipLevel: {
				value: 0
			}
		},
		aomap: {
			aoMap: {
				value: null
			},
			aoMapIntensity: {
				value: 1
			}
		},
		lightmap: {
			lightMap: {
				value: null
			},
			lightMapIntensity: {
				value: 1
			}
		},
		emissivemap: {
			emissiveMap: {
				value: null
			}
		},
		bumpmap: {
			bumpMap: {
				value: null
			},
			bumpScale: {
				value: 1
			}
		},
		normalmap: {
			normalMap: {
				value: null
			},
			normalScale: {
				value: new Vector2(1, 1)
			}
		},
		displacementmap: {
			displacementMap: {
				value: null
			},
			displacementScale: {
				value: 1
			},
			displacementBias: {
				value: 0
			}
		},
		roughnessmap: {
			roughnessMap: {
				value: null
			}
		},
		metalnessmap: {
			metalnessMap: {
				value: null
			}
		},
		gradientmap: {
			gradientMap: {
				value: null
			}
		},
		fog: {
			fogDensity: {
				value: 0.00025
			},
			fogNear: {
				value: 1
			},
			fogFar: {
				value: 2000
			},
			fogColor: {
				value: new Color(0xffffff)
			}
		},
		lights: {
			ambientLightColor: {
				value: []
			},
			lightProbe: {
				value: []
			},
			directionalLights: {
				value: [],
				properties: {
					direction: {},
					color: {}
				}
			},
			directionalLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			directionalShadowMap: {
				value: []
			},
			directionalShadowMatrix: {
				value: []
			},
			spotLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {}
				}
			},
			spotLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				}
			},
			spotShadowMap: {
				value: []
			},
			spotShadowMatrix: {
				value: []
			},
			pointLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					decay: {},
					distance: {}
				}
			},
			pointLightShadows: {
				value: [],
				properties: {
					shadowBias: {},
					shadowNormalBias: {},
					shadowRadius: {},
					shadowMapSize: {},
					shadowCameraNear: {},
					shadowCameraFar: {}
				}
			},
			pointShadowMap: {
				value: []
			},
			pointShadowMatrix: {
				value: []
			},
			hemisphereLights: {
				value: [],
				properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				}
			},
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: {
				value: [],
				properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				}
			},
			ltc_1: {
				value: null
			},
			ltc_2: {
				value: null
			}
		},
		points: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			size: {
				value: 1.0
			},
			scale: {
				value: 1.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		},
		sprite: {
			diffuse: {
				value: new Color(0xffffff)
			},
			opacity: {
				value: 1.0
			},
			center: {
				value: new Vector2(0.5, 0.5)
			},
			rotation: {
				value: 0.0
			},
			map: {
				value: null
			},
			alphaMap: {
				value: null
			},
			uvTransform: {
				value: new Matrix3()
			}
		}
	};

	const ShaderLib = {
		basic: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
		},
		lambert: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
		},
		phong: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				specular: {
					value: new Color(0x111111)
				},
				shininess: {
					value: 30
				}
			}]),
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
		},
		standard: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				},
				roughness: {
					value: 1.0
				},
				metalness: {
					value: 0.0
				},
				envMapIntensity: {
					value: 1
				} // temporary

			}]),
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
		},
		toon: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
				emissive: {
					value: new Color(0x000000)
				}
			}]),
			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag
		},
		matcap: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
				matcap: {
					value: null
				}
			}]),
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
		},
		points: {
			uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
		},
		dashed: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
				scale: {
					value: 1
				},
				dashSize: {
					value: 1
				},
				totalSize: {
					value: 2
				}
			}]),
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
		},
		depth: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
		},
		normal: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
		},
		sprite: {
			uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
		},
		background: {
			uniforms: {
				uvTransform: {
					value: new Matrix3()
				},
				t2D: {
					value: null
				}
			},
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
		cube: {
			uniforms: mergeUniforms([UniformsLib.envmap, {
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
		},
		equirect: {
			uniforms: {
				tEquirect: {
					value: null
				}
			},
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
		},
		distanceRGBA: {
			uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
				referencePosition: {
					value: new Vector3()
				},
				nearDistance: {
					value: 1
				},
				farDistance: {
					value: 1000
				}
			}]),
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
		},
		shadow: {
			uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
				color: {
					value: new Color(0x00000)
				},
				opacity: {
					value: 1.0
				}
			}]),
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
		}
	};
	ShaderLib.physical = {
		uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
			clearcoat: {
				value: 0
			},
			clearcoatMap: {
				value: null
			},
			clearcoatRoughness: {
				value: 0
			},
			clearcoatRoughnessMap: {
				value: null
			},
			clearcoatNormalScale: {
				value: new Vector2(1, 1)
			},
			clearcoatNormalMap: {
				value: null
			},
			sheen: {
				value: new Color(0x000000)
			},
			transmission: {
				value: 0
			},
			transmissionMap: {
				value: null
			},
			transmissionSamplerSize: {
				value: new Vector2()
			},
			transmissionSamplerMap: {
				value: null
			},
			thickness: {
				value: 0
			},
			thicknessMap: {
				value: null
			},
			attenuationDistance: {
				value: 0
			},
			attenuationTint: {
				value: new Color(0x000000)
			},
			specularIntensity: {
				value: 0
			},
			specularIntensityMap: {
				value: null
			},
			specularTint: {
				value: new Color(1, 1, 1)
			},
			specularTintMap: {
				value: null
			}
		}]),
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	};

	function WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {
		const clearColor = new Color(0x000000);
		let clearAlpha = 0;
		let planeMesh;
		let boxMesh;
		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render(renderList, scene) {
			let forceClear = false;
			let background = scene.isScene === true ? scene.background : null;

			if (background && background.isTexture) {
				background = cubemaps.get(background);
			} // Ignore background in AR
			// TODO: Reconsider this.


			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if (session && session.environmentBlendMode === 'additive') {
				background = null;
			}

			if (background === null) {
				setClear(clearColor, clearAlpha);
			} else if (background && background.isColor) {
				setClear(background, 1);
				forceClear = true;
			}

			if (renderer.autoClear || forceClear) {
				renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
			}

			if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
				if (boxMesh === undefined) {
					boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms(ShaderLib.cube.uniforms),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					boxMesh.geometry.deleteAttribute('normal');
					boxMesh.geometry.deleteAttribute('uv');

					boxMesh.onBeforeRender = function (renderer, scene, camera) {
						this.matrixWorld.copyPosition(camera.matrixWorld);
					}; // enable code injection for non-built-in material


					Object.defineProperty(boxMesh.material, 'envMap', {
						get: function () {
							return this.uniforms.envMap.value;
						}
					});
					objects.update(boxMesh);
				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					boxMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
			} else if (background && background.isTexture) {
				if (planeMesh === undefined) {
					planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms(ShaderLib.background.uniforms),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					}));
					planeMesh.geometry.deleteAttribute('normal'); // enable code injection for non-built-in material

					Object.defineProperty(planeMesh.material, 'map', {
						get: function () {
							return this.uniforms.t2D.value;
						}
					});
					objects.update(planeMesh);
				}

				planeMesh.material.uniforms.t2D.value = background;

				if (background.matrixAutoUpdate === true) {
					background.updateMatrix();
				}

				planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

				if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
					planeMesh.material.needsUpdate = true;
					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;
				} // push to the pre-sorted opaque render list


				renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
			}
		}

		function setClear(color, alpha) {
			state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
		}

		return {
			getClearColor: function () {
				return clearColor;
			},
			setClearColor: function (color, alpha = 1) {
				clearColor.set(color);
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			getClearAlpha: function () {
				return clearAlpha;
			},
			setClearAlpha: function (alpha) {
				clearAlpha = alpha;
				setClear(clearColor, clearAlpha);
			},
			render: render
		};
	}

	function WebGLBindingStates(gl, extensions, attributes, capabilities) {
		const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const extension = capabilities.isWebGL2 ? null : extensions.get('OES_vertex_array_object');
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;
		const bindingStates = {};
		const defaultState = createBindingState(null);
		let currentState = defaultState;

		function setup(object, material, program, geometry, index) {
			let updateBuffers = false;

			if (vaoAvailable) {
				const state = getBindingState(geometry, program, material);

				if (currentState !== state) {
					currentState = state;
					bindVertexArrayObject(currentState.object);
				}

				updateBuffers = needsUpdate(geometry, index);
				if (updateBuffers) saveCache(geometry, index);
			} else {
				const wireframe = material.wireframe === true;

				if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;
					updateBuffers = true;
				}
			}

			if (object.isInstancedMesh === true) {
				updateBuffers = true;
			}

			if (index !== null) {
				attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
			}

			if (updateBuffers) {
				setupVertexAttributes(object, material, program, geometry);

				if (index !== null) {
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
				}
			}
		}

		function createVertexArrayObject() {
			if (capabilities.isWebGL2) return gl.createVertexArray();
			return extension.createVertexArrayOES();
		}

		function bindVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.bindVertexArray(vao);
			return extension.bindVertexArrayOES(vao);
		}

		function deleteVertexArrayObject(vao) {
			if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);
			return extension.deleteVertexArrayOES(vao);
		}

		function getBindingState(geometry, program, material) {
			const wireframe = material.wireframe === true;
			let programMap = bindingStates[geometry.id];

			if (programMap === undefined) {
				programMap = {};
				bindingStates[geometry.id] = programMap;
			}

			let stateMap = programMap[program.id];

			if (stateMap === undefined) {
				stateMap = {};
				programMap[program.id] = stateMap;
			}

			let state = stateMap[wireframe];

			if (state === undefined) {
				state = createBindingState(createVertexArrayObject());
				stateMap[wireframe] = state;
			}

			return state;
		}

		function createBindingState(vao) {
			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for (let i = 0; i < maxVertexAttributes; i++) {
				newAttributes[i] = 0;
				enabledAttributes[i] = 0;
				attributeDivisors[i] = 0;
			}

			return {
				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,
				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null
			};
		}

		function needsUpdate(geometry, index) {
			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in geometryAttributes) {
				const cachedAttribute = cachedAttributes[key];
				const geometryAttribute = geometryAttributes[key];
				if (cachedAttribute === undefined) return true;
				if (cachedAttribute.attribute !== geometryAttribute) return true;
				if (cachedAttribute.data !== geometryAttribute.data) return true;
				attributesNum++;
			}

			if (currentState.attributesNum !== attributesNum) return true;
			if (currentState.index !== index) return true;
			return false;
		}

		function saveCache(geometry, index) {
			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for (const key in attributes) {
				const attribute = attributes[key];
				const data = {};
				data.attribute = attribute;

				if (attribute.data) {
					data.data = attribute.data;
				}

				cache[key] = data;
				attributesNum++;
			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;
			currentState.index = index;
		}

		function initAttributes() {
			const newAttributes = currentState.newAttributes;

			for (let i = 0, il = newAttributes.length; i < il; i++) {
				newAttributes[i] = 0;
			}
		}

		function enableAttribute(attribute) {
			enableAttributeAndDivisor(attribute, 0);
		}

		function enableAttributeAndDivisor(attribute, meshPerAttribute) {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;
			newAttributes[attribute] = 1;

			if (enabledAttributes[attribute] === 0) {
				gl.enableVertexAttribArray(attribute);
				enabledAttributes[attribute] = 1;
			}

			if (attributeDivisors[attribute] !== meshPerAttribute) {
				const extension = capabilities.isWebGL2 ? gl : extensions.get('ANGLE_instanced_arrays');
				extension[capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'](attribute, meshPerAttribute);
				attributeDivisors[attribute] = meshPerAttribute;
			}
		}

		function disableUnusedAttributes() {
			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for (let i = 0, il = enabledAttributes.length; i < il; i++) {
				if (enabledAttributes[i] !== newAttributes[i]) {
					gl.disableVertexAttribArray(i);
					enabledAttributes[i] = 0;
				}
			}
		}

		function vertexAttribPointer(index, size, type, normalized, stride, offset) {
			if (capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT)) {
				gl.vertexAttribIPointer(index, size, type, stride, offset);
			} else {
				gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
			}
		}

		function setupVertexAttributes(object, material, program, geometry) {
			if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
				if (extensions.get('ANGLE_instanced_arrays') === null) return;
			}

			initAttributes();
			const geometryAttributes = geometry.attributes;
			const programAttributes = program.getAttributes();
			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for (const name in programAttributes) {
				const programAttribute = programAttributes[name];

				if (programAttribute >= 0) {
					const geometryAttribute = geometryAttributes[name];

					if (geometryAttribute !== undefined) {
						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;
						const attribute = attributes.get(geometryAttribute); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if (geometryAttribute.isInterleavedBufferAttribute) {
							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if (data && data.isInstancedInterleavedBuffer) {
								enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = data.meshPerAttribute * data.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
						} else {
							if (geometryAttribute.isInstancedBufferAttribute) {
								enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);

								if (geometry._maxInstanceCount === undefined) {
									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
								}
							} else {
								enableAttribute(programAttribute);
							}

							gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
							vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
						}
					} else if (name === 'instanceMatrix') {
						const attribute = attributes.get(object.instanceMatrix); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						enableAttributeAndDivisor(programAttribute + 0, 1);
						enableAttributeAndDivisor(programAttribute + 1, 1);
						enableAttributeAndDivisor(programAttribute + 2, 1);
						enableAttributeAndDivisor(programAttribute + 3, 1);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
						gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
						gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
						gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
					} else if (name === 'instanceColor') {
						const attribute = attributes.get(object.instanceColor); // TODO Attribute may not be available on context restore

						if (attribute === undefined) continue;
						const buffer = attribute.buffer;
						const type = attribute.type;
						enableAttributeAndDivisor(programAttribute, 1);
						gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
						gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);
					} else if (materialDefaultAttributeValues !== undefined) {
						const value = materialDefaultAttributeValues[name];

						if (value !== undefined) {
							switch (value.length) {
								case 2:
									gl.vertexAttrib2fv(programAttribute, value);
									break;

								case 3:
									gl.vertexAttrib3fv(programAttribute, value);
									break;

								case 4:
									gl.vertexAttrib4fv(programAttribute, value);
									break;

								default:
									gl.vertexAttrib1fv(programAttribute, value);
							}
						}
					}
				}
			}

			disableUnusedAttributes();
		}

		function dispose() {
			reset();

			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];

				for (const programId in programMap) {
					const stateMap = programMap[programId];

					for (const wireframe in stateMap) {
						deleteVertexArrayObject(stateMap[wireframe].object);
						delete stateMap[wireframe];
					}

					delete programMap[programId];
				}

				delete bindingStates[geometryId];
			}
		}

		function releaseStatesOfGeometry(geometry) {
			if (bindingStates[geometry.id] === undefined) return;
			const programMap = bindingStates[geometry.id];

			for (const programId in programMap) {
				const stateMap = programMap[programId];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[programId];
			}

			delete bindingStates[geometry.id];
		}

		function releaseStatesOfProgram(program) {
			for (const geometryId in bindingStates) {
				const programMap = bindingStates[geometryId];
				if (programMap[program.id] === undefined) continue;
				const stateMap = programMap[program.id];

				for (const wireframe in stateMap) {
					deleteVertexArrayObject(stateMap[wireframe].object);
					delete stateMap[wireframe];
				}

				delete programMap[program.id];
			}
		}

		function reset() {
			resetDefaultState();
			if (currentState === defaultState) return;
			currentState = defaultState;
			bindVertexArrayObject(currentState.object);
		} // for backward-compatilibity


		function resetDefaultState() {
			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;
		}

		return {
			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes
		};
	}

	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		function render(start, count) {
			gl.drawArrays(mode, start, count);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawArraysInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawArraysInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, start, count, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLCapabilities(gl, extensions, parameters) {
		let maxAnisotropy;

		function getMaxAnisotropy() {
			if (maxAnisotropy !== undefined) return maxAnisotropy;

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
			} else {
				maxAnisotropy = 0;
			}

			return maxAnisotropy;
		}

		function getMaxPrecision(precision) {
			if (precision === 'highp') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
					return 'highp';
				}

				precision = 'mediump';
			}

			if (precision === 'mediump') {
				if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
					return 'mediump';
				}
			}

			return 'lowp';
		}
		/* eslint-disable no-undef */


		const isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext;
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision(precision);

		if (maxPrecision !== precision) {
			console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
			precision = maxPrecision;
		}

		const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');
		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
		const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
		const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
		const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
		const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
		const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
		const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
		const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
		const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
		const floatVertexTextures = vertexTextures && floatFragmentTextures;
		const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
		return {
			isWebGL2: isWebGL2,
			drawBuffers: drawBuffers,
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
			maxSamples: maxSamples
		};
	}

	function WebGLClipping(properties) {
		const scope = this;
		let globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false;
		const plane = new Plane(),
					viewNormalMatrix = new Matrix3(),
					uniform = {
			value: null,
			needsUpdate: false
		};
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function (planes, enableLocalClipping, camera) {
			const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 || localClippingEnabled;
			localClippingEnabled = enableLocalClipping;
			globalState = projectPlanes(planes, camera, 0);
			numGlobalPlanes = planes.length;
			return enabled;
		};

		this.beginShadows = function () {
			renderingShadows = true;
			projectPlanes(null);
		};

		this.endShadows = function () {
			renderingShadows = false;
			resetGlobalState();
		};

		this.setState = function (material, camera, useCache) {
			const planes = material.clippingPlanes,
						clipIntersection = material.clipIntersection,
						clipShadows = material.clipShadows;
			const materialProperties = properties.get(material);

			if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
				// there's no local clipping
				if (renderingShadows) {
					// there's no global clipping
					projectPlanes(null);
				} else {
					resetGlobalState();
				}
			} else {
				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
							lGlobal = nGlobal * 4;
				let dstArray = materialProperties.clippingState || null;
				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes(planes, camera, lGlobal, useCache);

				for (let i = 0; i !== lGlobal; ++i) {
					dstArray[i] = globalState[i];
				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
			}
		};

		function resetGlobalState() {
			if (uniform.value !== globalState) {
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
		}

		function projectPlanes(planes, camera, dstOffset, skipTransform) {
			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if (nPlanes !== 0) {
				dstArray = uniform.value;

				if (skipTransform !== true || dstArray === null) {
					const flatSize = dstOffset + nPlanes * 4,
								viewMatrix = camera.matrixWorldInverse;
					viewNormalMatrix.getNormalMatrix(viewMatrix);

					if (dstArray === null || dstArray.length < flatSize) {
						dstArray = new Float32Array(flatSize);
					}

					for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
						plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
						plane.normal.toArray(dstArray, i4);
						dstArray[i4 + 3] = plane.constant;
					}
				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;
			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;
			return dstArray;
		}
	}

	function WebGLCubeMaps(renderer) {
		let cubemaps = new WeakMap();

		function mapTextureMapping(texture, mapping) {
			if (mapping === EquirectangularReflectionMapping) {
				texture.mapping = CubeReflectionMapping;
			} else if (mapping === EquirectangularRefractionMapping) {
				texture.mapping = CubeRefractionMapping;
			}

			return texture;
		}

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;

				if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
					if (cubemaps.has(texture)) {
						const cubemap = cubemaps.get(texture).texture;
						return mapTextureMapping(cubemap, texture.mapping);
					} else {
						const image = texture.image;

						if (image && image.height > 0) {
							const currentRenderTarget = renderer.getRenderTarget();
							const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
							renderTarget.fromEquirectangularTexture(renderer, texture);
							cubemaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return mapTextureMapping(renderTarget.texture, texture.mapping);
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemap = cubemaps.get(texture);

			if (cubemap !== undefined) {
				cubemaps.delete(texture);
				cubemap.dispose();
			}
		}

		function dispose() {
			cubemaps = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	class OrthographicCamera extends Camera {
		constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
			super();
			this.type = 'OrthographicCamera';
			this.zoom = 1;
			this.view = null;
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
			this.near = near;
			this.far = far;
			this.updateProjectionMatrix();
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign({}, source.view);
			return this;
		}

		setViewOffset(fullWidth, fullHeight, x, y, width, height) {
			if (this.view === null) {
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
			this.updateProjectionMatrix();
		}

		clearViewOffset() {
			if (this.view !== null) {
				this.view.enabled = false;
			}

			this.updateProjectionMatrix();
		}

		updateProjectionMatrix() {
			const dx = (this.right - this.left) / (2 * this.zoom);
			const dy = (this.top - this.bottom) / (2 * this.zoom);
			const cx = (this.right + this.left) / 2;
			const cy = (this.top + this.bottom) / 2;
			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if (this.view !== null && this.view.enabled) {
				const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
				const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;
			}

			this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
			this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
			if (this.view !== null) data.object.view = Object.assign({}, this.view);
			return data;
		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true;

	class RawShaderMaterial extends ShaderMaterial {
		constructor(parameters) {
			super(parameters);
			this.type = 'RawShaderMaterial';
		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	const LOD_MIN = 4;
	const LOD_MAX = 8;
	const SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are
	// chosen to approximate a Trowbridge-Reitz distribution function times the
	// geometric shadowing function. These sigma values squared must match the
	// variance #defines in cube_uv_reflection_fragment.glsl.js.

	const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer
	// samples and exit early, but not recompile the shader.

	const MAX_SAMPLES = 20;
	const ENCODINGS = {
		[LinearEncoding]: 0,
		[sRGBEncoding]: 1,
		[RGBEEncoding]: 2,
		[RGBM7Encoding]: 3,
		[RGBM16Encoding]: 4,
		[RGBDEncoding]: 5,
		[GammaEncoding]: 6
	};
	const backgroundMaterial = new MeshBasicMaterial({
		side: BackSide,
		depthWrite: false,
		depthTest: false
	});
	const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);

	const _flatCamera = /*@__PURE__*/new OrthographicCamera();

	const {
		_lodPlanes,
		_sizeLods,
		_sigmas
	} = /*@__PURE__*/_createPlanes();

	const _clearColor = /*@__PURE__*/new Color();

	let _oldTarget = null; // Golden Ratio

	const PHI = (1 + Math.sqrt(5)) / 2;
	const INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the
	// same axis), used as axis directions evenly spread on a sphere.

	const _axisDirections = [/*@__PURE__*/new Vector3(1, 1, 1), /*@__PURE__*/new Vector3(-1, 1, 1), /*@__PURE__*/new Vector3(1, 1, -1), /*@__PURE__*/new Vector3(-1, 1, -1), /*@__PURE__*/new Vector3(0, PHI, INV_PHI), /*@__PURE__*/new Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new Vector3(-PHI, INV_PHI, 0)];
	/**
	 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
	 * (PMREM) from a cubeMap environment texture. This allows different levels of
	 * blur to be quickly accessed based on material roughness. It is packed into a
	 * special CubeUV format that allows us to perform custom interpolation so that
	 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
	 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
	 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
	 * higher roughness levels. In this way we maintain resolution to smoothly
	 * interpolate diffuse lighting while limiting sampling computation.
	 *
	 * Paper: Fast, Accurate Image-Based Lighting
	 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
	*/

	function convertLinearToRGBE(color) {
		const maxComponent = Math.max(color.r, color.g, color.b);
		const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128.0), 127.0);
		color.multiplyScalar(Math.pow(2.0, -fExp));
		const alpha = (fExp + 128.0) / 255.0;
		return alpha;
	}

	class PMREMGenerator {
		constructor(renderer) {
			this._renderer = renderer;
			this._pingPongRenderTarget = null;
			this._blurMaterial = _getBlurShader(MAX_SAMPLES);
			this._equirectShader = null;
			this._cubemapShader = null;

			this._compileMaterial(this._blurMaterial);
		}
		/**
		 * Generates a PMREM from a supplied Scene, which can be faster than using an
		 * image if networking bandwidth is low. Optional sigma specifies a blur radius
		 * in radians to be applied to the scene before PMREM generation. Optional near
		 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
		 * is placed at the origin).
		 */


		fromScene(scene, sigma = 0, near = 0.1, far = 100) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets();

			this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);

			if (sigma > 0) {
				this._blur(cubeUVRenderTarget, 0, 0, sigma);
			}

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}
		/**
		 * Generates a PMREM from an equirectangular texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromEquirectangular(equirectangular) {
			return this._fromTexture(equirectangular);
		}
		/**
		 * Generates a PMREM from an cubemap texture, which can be either LDR
		 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
		 * as this matches best with the 256 x 256 cubemap output.
		 */


		fromCubemap(cubemap) {
			return this._fromTexture(cubemap);
		}
		/**
		 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileCubemapShader() {
			if (this._cubemapShader === null) {
				this._cubemapShader = _getCubemapShader();

				this._compileMaterial(this._cubemapShader);
			}
		}
		/**
		 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
		 * your texture's network fetch for increased concurrency.
		 */


		compileEquirectangularShader() {
			if (this._equirectShader === null) {
				this._equirectShader = _getEquirectShader();

				this._compileMaterial(this._equirectShader);
			}
		}
		/**
		 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
		 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
		 * one of them will cause any others to also become unusable.
		 */


		dispose() {
			this._blurMaterial.dispose();

			if (this._cubemapShader !== null) this._cubemapShader.dispose();
			if (this._equirectShader !== null) this._equirectShader.dispose();

			for (let i = 0; i < _lodPlanes.length; i++) {
				_lodPlanes[i].dispose();
			}
		} // private interface


		_cleanup(outputTarget) {
			this._pingPongRenderTarget.dispose();

			this._renderer.setRenderTarget(_oldTarget);

			outputTarget.scissorTest = false;

			_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
		}

		_fromTexture(texture) {
			_oldTarget = this._renderer.getRenderTarget();

			const cubeUVRenderTarget = this._allocateTargets(texture);

			this._textureToCubeUV(texture, cubeUVRenderTarget);

			this._applyPMREM(cubeUVRenderTarget);

			this._cleanup(cubeUVRenderTarget);

			return cubeUVRenderTarget;
		}

		_allocateTargets(texture) {
			// warning: null texture is valid
			const params = {
				magFilter: NearestFilter,
				minFilter: NearestFilter,
				generateMipmaps: false,
				type: UnsignedByteType,
				format: RGBEFormat,
				encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
				depthBuffer: false
			};

			const cubeUVRenderTarget = _createRenderTarget(params);

			cubeUVRenderTarget.depthBuffer = texture ? false : true;
			this._pingPongRenderTarget = _createRenderTarget(params);
			return cubeUVRenderTarget;
		}

		_compileMaterial(material) {
			const tmpMesh = new Mesh(_lodPlanes[0], material);

			this._renderer.compile(tmpMesh, _flatCamera);
		}

		_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
			const fov = 90;
			const aspect = 1;
			const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
			const upSign = [1, -1, 1, 1, 1, 1];
			const forwardSign = [1, 1, 1, -1, -1, -1];
			const renderer = this._renderer;
			const originalAutoClear = renderer.autoClear;
			const outputEncoding = renderer.outputEncoding;
			const toneMapping = renderer.toneMapping;
			renderer.getClearColor(_clearColor);
			renderer.toneMapping = NoToneMapping;
			renderer.outputEncoding = LinearEncoding;
			renderer.autoClear = false;
			let useSolidColor = false;
			const background = scene.background;

			if (background) {
				if (background.isColor) {
					backgroundMaterial.color.copy(background).convertSRGBToLinear();
					scene.background = null;
					const alpha = convertLinearToRGBE(backgroundMaterial.color);
					backgroundMaterial.opacity = alpha;
					useSolidColor = true;
				}
			} else {
				backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();
				const alpha = convertLinearToRGBE(backgroundMaterial.color);
				backgroundMaterial.opacity = alpha;
				useSolidColor = true;
			}

			for (let i = 0; i < 6; i++) {
				const col = i % 3;

				if (col == 0) {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(forwardSign[i], 0, 0);
				} else if (col == 1) {
					cubeCamera.up.set(0, 0, upSign[i]);
					cubeCamera.lookAt(0, forwardSign[i], 0);
				} else {
					cubeCamera.up.set(0, upSign[i], 0);
					cubeCamera.lookAt(0, 0, forwardSign[i]);
				}

				_setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);

				renderer.setRenderTarget(cubeUVRenderTarget);

				if (useSolidColor) {
					renderer.render(backgroundBox, cubeCamera);
				}

				renderer.render(scene, cubeCamera);
			}

			renderer.toneMapping = toneMapping;
			renderer.outputEncoding = outputEncoding;
			renderer.autoClear = originalAutoClear;
		}

		_textureToCubeUV(texture, cubeUVRenderTarget) {
			const renderer = this._renderer;

			if (texture.isCubeTexture) {
				if (this._cubemapShader == null) {
					this._cubemapShader = _getCubemapShader();
				}
			} else {
				if (this._equirectShader == null) {
					this._equirectShader = _getEquirectShader();
				}
			}

			const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
			const mesh = new Mesh(_lodPlanes[0], material);
			const uniforms = material.uniforms;
			uniforms['envMap'].value = texture;

			if (!texture.isCubeTexture) {
				uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);
			}

			uniforms['inputEncoding'].value = ENCODINGS[texture.encoding];
			uniforms['outputEncoding'].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];

			_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

			renderer.setRenderTarget(cubeUVRenderTarget);
			renderer.render(mesh, _flatCamera);
		}

		_applyPMREM(cubeUVRenderTarget) {
			const renderer = this._renderer;
			const autoClear = renderer.autoClear;
			renderer.autoClear = false;

			for (let i = 1; i < TOTAL_LODS; i++) {
				const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
				const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

				this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
			}

			renderer.autoClear = autoClear;
		}
		/**
		 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
		 * vertically and horizontally, but this breaks down on a cube. Here we apply
		 * the blur latitudinally (around the poles), and then longitudinally (towards
		 * the poles) to approximate the orthogonally-separable blur. It is least
		 * accurate at the poles, but still does a decent job.
		 */


		_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
			const pingPongRenderTarget = this._pingPongRenderTarget;

			this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);

			this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
		}

		_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
			const renderer = this._renderer;
			const blurMaterial = this._blurMaterial;

			if (direction !== 'latitudinal' && direction !== 'longitudinal') {
				console.error('blur direction must be either latitudinal or longitudinal!');
			} // Number of standard deviations at which to cut off the discrete approximation.


			const STANDARD_DEVIATIONS = 3;
			const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
			const blurUniforms = blurMaterial.uniforms;
			const pixels = _sizeLods[lodIn] - 1;
			const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
			const sigmaPixels = sigmaRadians / radiansPerPixel;
			const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

			if (samples > MAX_SAMPLES) {
				console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
			}

			const weights = [];
			let sum = 0;

			for (let i = 0; i < MAX_SAMPLES; ++i) {
				const x = i / sigmaPixels;
				const weight = Math.exp(-x * x / 2);
				weights.push(weight);

				if (i == 0) {
					sum += weight;
				} else if (i < samples) {
					sum += 2 * weight;
				}
			}

			for (let i = 0; i < weights.length; i++) {
				weights[i] = weights[i] / sum;
			}

			blurUniforms['envMap'].value = targetIn.texture;
			blurUniforms['samples'].value = samples;
			blurUniforms['weights'].value = weights;
			blurUniforms['latitudinal'].value = direction === 'latitudinal';

			if (poleAxis) {
				blurUniforms['poleAxis'].value = poleAxis;
			}

			blurUniforms['dTheta'].value = radiansPerPixel;
			blurUniforms['mipInt'].value = LOD_MAX - lodIn;
			blurUniforms['inputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			blurUniforms['outputEncoding'].value = ENCODINGS[targetIn.texture.encoding];
			const outputSize = _sizeLods[lodOut];
			const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
			const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

			_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);

			renderer.setRenderTarget(targetOut);
			renderer.render(blurMesh, _flatCamera);
		}

	}

	function _isLDR(texture) {
		if (texture === undefined || texture.type !== UnsignedByteType) return false;
		return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
	}

	function _createPlanes() {
		const _lodPlanes = [];
		const _sizeLods = [];
		const _sigmas = [];
		let lod = LOD_MAX;

		for (let i = 0; i < TOTAL_LODS; i++) {
			const sizeLod = Math.pow(2, lod);

			_sizeLods.push(sizeLod);

			let sigma = 1.0 / sizeLod;

			if (i > LOD_MAX - LOD_MIN) {
				sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
			} else if (i == 0) {
				sigma = 0;
			}

			_sigmas.push(sigma);

			const texelSize = 1.0 / (sizeLod - 1);
			const min = -texelSize / 2;
			const max = 1 + texelSize / 2;
			const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
			const cubeFaces = 6;
			const vertices = 6;
			const positionSize = 3;
			const uvSize = 2;
			const faceIndexSize = 1;
			const position = new Float32Array(positionSize * vertices * cubeFaces);
			const uv = new Float32Array(uvSize * vertices * cubeFaces);
			const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

			for (let face = 0; face < cubeFaces; face++) {
				const x = face % 3 * 2 / 3 - 1;
				const y = face > 2 ? 0 : -1;
				const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
				position.set(coordinates, positionSize * vertices * face);
				uv.set(uv1, uvSize * vertices * face);
				const fill = [face, face, face, face, face, face];
				faceIndex.set(fill, faceIndexSize * vertices * face);
			}

			const planes = new BufferGeometry();
			planes.setAttribute('position', new BufferAttribute(position, positionSize));
			planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
			planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));

			_lodPlanes.push(planes);

			if (lod > LOD_MIN) {
				lod--;
			}
		}

		return {
			_lodPlanes,
			_sizeLods,
			_sigmas
		};
	}

	function _createRenderTarget(params) {
		const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
		cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
		cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
		cubeUVRenderTarget.scissorTest = true;
		return cubeUVRenderTarget;
	}

	function _setViewport(target, x, y, width, height) {
		target.viewport.set(x, y, width, height);
		target.scissor.set(x, y, width, height);
	}

	function _getBlurShader(maxSamples) {
		const weights = new Float32Array(maxSamples);
		const poleAxis = new Vector3(0, 1, 0);
		const shaderMaterial = new RawShaderMaterial({
			name: 'SphericalGaussianBlur',
			defines: {
				'n': maxSamples
			},
			uniforms: {
				'envMap': {
					value: null
				},
				'samples': {
					value: 1
				},
				'weights': {
					value: weights
				},
				'latitudinal': {
					value: false
				},
				'dTheta': {
					value: 0
				},
				'mipInt': {
					value: 0
				},
				'poleAxis': {
					value: poleAxis
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getEquirectShader() {
		const texelSize = new Vector2(1, 1);
		const shaderMaterial = new RawShaderMaterial({
			name: 'EquirectangularToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'texelSize': {
					value: texelSize
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCubemapShader() {
		const shaderMaterial = new RawShaderMaterial({
			name: 'CubemapToCubeUV',
			uniforms: {
				'envMap': {
					value: null
				},
				'inputEncoding': {
					value: ENCODINGS[LinearEncoding]
				},
				'outputEncoding': {
					value: ENCODINGS[LinearEncoding]
				}
			},
			vertexShader: _getCommonVertexShader(),
			fragmentShader:
			/* glsl */
			`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
			blending: NoBlending,
			depthTest: false,
			depthWrite: false
		});
		return shaderMaterial;
	}

	function _getCommonVertexShader() {
		return (
			/* glsl */
			`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
		);
	}

	function _getEncodings() {
		return (
			/* glsl */
			`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`
		);
	}

	function WebGLCubeUVMaps(renderer) {
		let cubeUVmaps = new WeakMap();
		let pmremGenerator = null;

		function get(texture) {
			if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
				const mapping = texture.mapping;
				const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
				const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;

				if (isEquirectMap || isCubeMap) {
					// equirect/cube map to cubeUV conversion
					if (cubeUVmaps.has(texture)) {
						return cubeUVmaps.get(texture).texture;
					} else {
						const image = texture.image;

						if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
							const currentRenderTarget = renderer.getRenderTarget();
							if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
							const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
							cubeUVmaps.set(texture, renderTarget);
							renderer.setRenderTarget(currentRenderTarget);
							texture.addEventListener('dispose', onTextureDispose);
							return renderTarget.texture;
						} else {
							// image not yet ready. try the conversion next frame
							return null;
						}
					}
				}
			}

			return texture;
		}

		function isCubeTextureComplete(image) {
			let count = 0;
			const length = 6;

			for (let i = 0; i < length; i++) {
				if (image[i] !== undefined) count++;
			}

			return count === length;
		}

		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			const cubemapUV = cubeUVmaps.get(texture);

			if (cubemapUV !== undefined) {
				cubemapUV.delete(texture);
				cubemapUV.dispose();
			}
		}

		function dispose() {
			cubeUVmaps = new WeakMap();

			if (pmremGenerator !== null) {
				pmremGenerator.dispose();
				pmremGenerator = null;
			}
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function WebGLExtensions(gl) {
		const extensions = {};

		function getExtension(name) {
			if (extensions[name] !== undefined) {
				return extensions[name];
			}

			let extension;

			switch (name) {
				case 'WEBGL_depth_texture':
					extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
					break;

				default:
					extension = gl.getExtension(name);
			}

			extensions[name] = extension;
			return extension;
		}

		return {
			has: function (name) {
				return getExtension(name) !== null;
			},
			init: function (capabilities) {
				if (capabilities.isWebGL2) {
					getExtension('EXT_color_buffer_float');
				} else {
					getExtension('WEBGL_depth_texture');
					getExtension('OES_texture_float');
					getExtension('OES_texture_half_float');
					getExtension('OES_texture_half_float_linear');
					getExtension('OES_standard_derivatives');
					getExtension('OES_element_index_uint');
					getExtension('OES_vertex_array_object');
					getExtension('ANGLE_instanced_arrays');
				}

				getExtension('OES_texture_float_linear');
				getExtension('EXT_color_buffer_half_float');
			},
			get: function (name) {
				const extension = getExtension(name);

				if (extension === null) {
					console.warn('THREE.WebGLRenderer: ' + name + ' extension not supported.');
				}

				return extension;
			}
		};
	}

	function WebGLGeometries(gl, attributes, info, bindingStates) {
		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose(event) {
			const geometry = event.target;

			if (geometry.index !== null) {
				attributes.remove(geometry.index);
			}

			for (const name in geometry.attributes) {
				attributes.remove(geometry.attributes[name]);
			}

			geometry.removeEventListener('dispose', onGeometryDispose);
			delete geometries[geometry.id];
			const attribute = wireframeAttributes.get(geometry);

			if (attribute) {
				attributes.remove(attribute);
				wireframeAttributes.delete(geometry);
			}

			bindingStates.releaseStatesOfGeometry(geometry);

			if (geometry.isInstancedBufferGeometry === true) {
				delete geometry._maxInstanceCount;
			} //


			info.memory.geometries--;
		}

		function get(object, geometry) {
			if (geometries[geometry.id] === true) return geometry;
			geometry.addEventListener('dispose', onGeometryDispose);
			geometries[geometry.id] = true;
			info.memory.geometries++;
			return geometry;
		}

		function update(geometry) {
			const geometryAttributes = geometry.attributes; // Updating index buffer in VAO now. See WebGLBindingStates.

			for (const name in geometryAttributes) {
				attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
			} // morph targets


			const morphAttributes = geometry.morphAttributes;

			for (const name in morphAttributes) {
				const array = morphAttributes[name];

				for (let i = 0, l = array.length; i < l; i++) {
					attributes.update(array[i], gl.ARRAY_BUFFER);
				}
			}
		}

		function updateWireframeAttribute(geometry) {
			const indices = [];
			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if (geometryIndex !== null) {
				const array = geometryIndex.array;
				version = geometryIndex.version;

				for (let i = 0, l = array.length; i < l; i += 3) {
					const a = array[i + 0];
					const b = array[i + 1];
					const c = array[i + 2];
					indices.push(a, b, b, c, c, a);
				}
			} else {
				const array = geometryPosition.array;
				version = geometryPosition.version;

				for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
					const a = i + 0;
					const b = i + 1;
					const c = i + 2;
					indices.push(a, b, b, c, c, a);
				}
			}

			const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
			attribute.version = version; // Updating index buffer in VAO now. See WebGLBindingStates
			//

			const previousAttribute = wireframeAttributes.get(geometry);
			if (previousAttribute) attributes.remove(previousAttribute); //

			wireframeAttributes.set(geometry, attribute);
		}

		function getWireframeAttribute(geometry) {
			const currentAttribute = wireframeAttributes.get(geometry);

			if (currentAttribute) {
				const geometryIndex = geometry.index;

				if (geometryIndex !== null) {
					// if the attribute is obsolete, create a new one
					if (currentAttribute.version < geometryIndex.version) {
						updateWireframeAttribute(geometry);
					}
				}
			} else {
				updateWireframeAttribute(geometry);
			}

			return wireframeAttributes.get(geometry);
		}

		return {
			get: get,
			update: update,
			getWireframeAttribute: getWireframeAttribute
		};
	}

	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;
		let mode;

		function setMode(value) {
			mode = value;
		}

		let type, bytesPerElement;

		function setIndex(value) {
			type = value.type;
			bytesPerElement = value.bytesPerElement;
		}

		function render(start, count) {
			gl.drawElements(mode, count, type, start * bytesPerElement);
			info.update(count, mode, 1);
		}

		function renderInstances(start, count, primcount) {
			if (primcount === 0) return;
			let extension, methodName;

			if (isWebGL2) {
				extension = gl;
				methodName = 'drawElementsInstanced';
			} else {
				extension = extensions.get('ANGLE_instanced_arrays');
				methodName = 'drawElementsInstancedANGLE';

				if (extension === null) {
					console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');
					return;
				}
			}

			extension[methodName](mode, count, type, start * bytesPerElement, primcount);
			info.update(count, mode, primcount);
		} //


		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	}

	function WebGLInfo(gl) {
		const memory = {
			geometries: 0,
			textures: 0
		};
		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update(count, mode, instanceCount) {
			render.calls++;

			switch (mode) {
				case gl.TRIANGLES:
					render.triangles += instanceCount * (count / 3);
					break;

				case gl.LINES:
					render.lines += instanceCount * (count / 2);
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * (count - 1);
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
					break;
			}
		}

		function reset() {
			render.frame++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	}

	function numericalSort(a, b) {
		return a[0] - b[0];
	}

	function absNumericalSort(a, b) {
		return Math.abs(b[1]) - Math.abs(a[1]);
	}

	function WebGLMorphtargets(gl) {
		const influencesList = {};
		const morphInfluences = new Float32Array(8);
		const workInfluences = [];

		for (let i = 0; i < 8; i++) {
			workInfluences[i] = [i, 0];
		}

		function update(object, geometry, material, program) {
			const objectInfluences = object.morphTargetInfluences; // When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;
			let influences = influencesList[geometry.id];

			if (influences === undefined || influences.length !== length) {
				// initialise list
				influences = [];

				for (let i = 0; i < length; i++) {
					influences[i] = [i, 0];
				}

				influencesList[geometry.id] = influences;
			} // Collect influences


			for (let i = 0; i < length; i++) {
				const influence = influences[i];
				influence[0] = i;
				influence[1] = objectInfluences[i];
			}

			influences.sort(absNumericalSort);

			for (let i = 0; i < 8; i++) {
				if (i < length && influences[i][1]) {
					workInfluences[i][0] = influences[i][0];
					workInfluences[i][1] = influences[i][1];
				} else {
					workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
					workInfluences[i][1] = 0;
				}
			}

			workInfluences.sort(numericalSort);
			const morphTargets = geometry.morphAttributes.position;
			const morphNormals = geometry.morphAttributes.normal;
			let morphInfluencesSum = 0;

			for (let i = 0; i < 8; i++) {
				const influence = workInfluences[i];
				const index = influence[0];
				const value = influence[1];

				if (index !== Number.MAX_SAFE_INTEGER && value) {
					if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {
						geometry.setAttribute('morphTarget' + i, morphTargets[index]);
					}

					if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {
						geometry.setAttribute('morphNormal' + i, morphNormals[index]);
					}

					morphInfluences[i] = value;
					morphInfluencesSum += value;
				} else {
					if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {
						geometry.deleteAttribute('morphTarget' + i);
					}

					if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {
						geometry.deleteAttribute('morphNormal' + i);
					}

					morphInfluences[i] = 0;
				}
			} // GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)


			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
			program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
			program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);
		}

		return {
			update: update
		};
	}

	function WebGLObjects(gl, geometries, attributes, info) {
		let updateMap = new WeakMap();

		function update(object) {
			const frame = info.render.frame;
			const geometry = object.geometry;
			const buffergeometry = geometries.get(object, geometry); // Update once per frame

			if (updateMap.get(buffergeometry) !== frame) {
				geometries.update(buffergeometry);
				updateMap.set(buffergeometry, frame);
			}

			if (object.isInstancedMesh) {
				if (object.hasEventListener('dispose', onInstancedMeshDispose) === false) {
					object.addEventListener('dispose', onInstancedMeshDispose);
				}

				attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);

				if (object.instanceColor !== null) {
					attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
				}
			}

			return buffergeometry;
		}

		function dispose() {
			updateMap = new WeakMap();
		}

		function onInstancedMeshDispose(event) {
			const instancedMesh = event.target;
			instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
			attributes.remove(instancedMesh.instanceMatrix);
			if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
		}

		return {
			update: update,
			dispose: dispose
		};
	}

	class DataTexture2DArray extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	class DataTexture3D extends Texture {
		constructor(data = null, width = 1, height = 1, depth = 1) {
			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839
			super(null);
			this.image = {
				data,
				width,
				height,
				depth
			};
			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;
			this.wrapR = ClampToEdgeWrapping;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *		the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with	name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	const emptyTexture = new Texture();
	const emptyTexture2dArray = new DataTexture2DArray();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture(); // --- Utilities ---
	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = []; // Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array(16);
	const mat3array = new Float32Array(9);
	const mat2array = new Float32Array(4); // Flattening for arrays of vectors and matrices

	function flatten(array, nBlocks, blockSize) {
		const firstElem = array[0];
		if (firstElem <= 0 || firstElem > 0) return array; // unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[n];

		if (r === undefined) {
			r = new Float32Array(n);
			arrayCacheF32[n] = r;
		}

		if (nBlocks !== 0) {
			firstElem.toArray(r, 0);

			for (let i = 1, offset = 0; i !== nBlocks; ++i) {
				offset += blockSize;
				array[i].toArray(r, offset);
			}
		}

		return r;
	}

	function arraysEqual(a, b) {
		if (a.length !== b.length) return false;

		for (let i = 0, l = a.length; i < l; i++) {
			if (a[i] !== b[i]) return false;
		}

		return true;
	}

	function copyArray(a, b) {
		for (let i = 0, l = b.length; i < l; i++) {
			a[i] = b[i];
		}
	} // Texture unit allocation


	function allocTexUnits(textures, n) {
		let r = arrayCacheI32[n];

		if (r === undefined) {
			r = new Int32Array(n);
			arrayCacheI32[n] = r;
		}

		for (let i = 0; i !== n; ++i) {
			r[i] = textures.allocateTextureUnit();
		}

		return r;
	} // --- Setters ---
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	// Single scalar


	function setValueV1f(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1f(this.addr, v);
		cache[0] = v;
	} // Single float vector (from flat array or THREE.VectorN)


	function setValueV2f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y) {
				gl.uniform2f(this.addr, v.x, v.y);
				cache[0] = v.x;
				cache[1] = v.y;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform2fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV3f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
				gl.uniform3f(this.addr, v.x, v.y, v.z);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
			}
		} else if (v.r !== undefined) {
			if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
				gl.uniform3f(this.addr, v.r, v.g, v.b);
				cache[0] = v.r;
				cache[1] = v.g;
				cache[2] = v.b;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform3fv(this.addr, v);
			copyArray(cache, v);
		}
	}

	function setValueV4f(gl, v) {
		const cache = this.cache;

		if (v.x !== undefined) {
			if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
				gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
				cache[0] = v.x;
				cache[1] = v.y;
				cache[2] = v.z;
				cache[3] = v.w;
			}
		} else {
			if (arraysEqual(cache, v)) return;
			gl.uniform4fv(this.addr, v);
			copyArray(cache, v);
		}
	} // Single matrix (from flat array or THREE.MatrixN)


	function setValueM2(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix2fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat2array.set(elements);
			gl.uniformMatrix2fv(this.addr, false, mat2array);
			copyArray(cache, elements);
		}
	}

	function setValueM3(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix3fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat3array.set(elements);
			gl.uniformMatrix3fv(this.addr, false, mat3array);
			copyArray(cache, elements);
		}
	}

	function setValueM4(gl, v) {
		const cache = this.cache;
		const elements = v.elements;

		if (elements === undefined) {
			if (arraysEqual(cache, v)) return;
			gl.uniformMatrix4fv(this.addr, false, v);
			copyArray(cache, v);
		} else {
			if (arraysEqual(cache, elements)) return;
			mat4array.set(elements);
			gl.uniformMatrix4fv(this.addr, false, mat4array);
			copyArray(cache, elements);
		}
	} // Single integer / boolean


	function setValueV1i(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1i(this.addr, v);
		cache[0] = v;
	} // Single integer / boolean vector (from flat array)


	function setValueV2i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3iv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4i(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4iv(this.addr, v);
		copyArray(cache, v);
	} // Single unsigned integer


	function setValueV1ui(gl, v) {
		const cache = this.cache;
		if (cache[0] === v) return;
		gl.uniform1ui(this.addr, v);
		cache[0] = v;
	} // Single unsigned integer vector (from flat array)


	function setValueV2ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform2uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV3ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform3uiv(this.addr, v);
		copyArray(cache, v);
	}

	function setValueV4ui(gl, v) {
		const cache = this.cache;
		if (arraysEqual(cache, v)) return;
		gl.uniform4uiv(this.addr, v);
		copyArray(cache, v);
	} // Single texture (2D / Cube)


	function setValueT1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTexture2D(v || emptyTexture, unit);
	}

	function setValueT3D1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture3D(v || emptyTexture3d, unit);
	}

	function setValueT6(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	}

	function setValueT2DArray1(gl, v, textures) {
		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if (cache[0] !== unit) {
			gl.uniform1i(this.addr, unit);
			cache[0] = unit;
		}

		textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	} // Helper to pick the right setter for the singular case


	function getSingularSetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1f;
			// FLOAT

			case 0x8b50:
				return setValueV2f;
			// _VEC2

			case 0x8b51:
				return setValueV3f;
			// _VEC3

			case 0x8b52:
				return setValueV4f;
			// _VEC4

			case 0x8b5a:
				return setValueM2;
			// _MAT2

			case 0x8b5b:
				return setValueM3;
			// _MAT3

			case 0x8b5c:
				return setValueM4;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1i;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2i;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3i;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4i;
			// _VEC4

			case 0x1405:
				return setValueV1ui;
			// UINT

			case 0x8dc6:
				return setValueV2ui;
			// _VEC2

			case 0x8dc7:
				return setValueV3ui;
			// _VEC3

			case 0x8dc8:
				return setValueV4ui;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D

			case 0x8dcb: // INT_SAMPLER_3D

			case 0x8dd3:
				// UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY

			case 0x8dcf: // INT_SAMPLER_2D_ARRAY

			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY

			case 0x8dc4:
				// SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;
		}
	} // Array of scalars


	function setValueV1fArray(gl, v) {
		gl.uniform1fv(this.addr, v);
	} // Array of vectors (from flat array or array of THREE.VectorN)


	function setValueV2fArray(gl, v) {
		const data = flatten(v, this.size, 2);
		gl.uniform2fv(this.addr, data);
	}

	function setValueV3fArray(gl, v) {
		const data = flatten(v, this.size, 3);
		gl.uniform3fv(this.addr, data);
	}

	function setValueV4fArray(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniform4fv(this.addr, data);
	} // Array of matrices (from flat array or array of THREE.MatrixN)


	function setValueM2Array(gl, v) {
		const data = flatten(v, this.size, 4);
		gl.uniformMatrix2fv(this.addr, false, data);
	}

	function setValueM3Array(gl, v) {
		const data = flatten(v, this.size, 9);
		gl.uniformMatrix3fv(this.addr, false, data);
	}

	function setValueM4Array(gl, v) {
		const data = flatten(v, this.size, 16);
		gl.uniformMatrix4fv(this.addr, false, data);
	} // Array of integer / boolean


	function setValueV1iArray(gl, v) {
		gl.uniform1iv(this.addr, v);
	} // Array of integer / boolean vectors (from flat array)


	function setValueV2iArray(gl, v) {
		gl.uniform2iv(this.addr, v);
	}

	function setValueV3iArray(gl, v) {
		gl.uniform3iv(this.addr, v);
	}

	function setValueV4iArray(gl, v) {
		gl.uniform4iv(this.addr, v);
	} // Array of unsigned integer


	function setValueV1uiArray(gl, v) {
		gl.uniform1uiv(this.addr, v);
	} // Array of unsigned integer vectors (from flat array)


	function setValueV2uiArray(gl, v) {
		gl.uniform2uiv(this.addr, v);
	}

	function setValueV3uiArray(gl, v) {
		gl.uniform3uiv(this.addr, v);
	}

	function setValueV4uiArray(gl, v) {
		gl.uniform4uiv(this.addr, v);
	} // Array of textures (2D / Cube)


	function setValueT1Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
		}
	}

	function setValueT6Array(gl, v, textures) {
		const n = v.length;
		const units = allocTexUnits(textures, n);
		gl.uniform1iv(this.addr, units);

		for (let i = 0; i !== n; ++i) {
			textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
		}
	} // Helper to pick the right setter for a pure (bottom-level) array


	function getPureArraySetter(type) {
		switch (type) {
			case 0x1406:
				return setValueV1fArray;
			// FLOAT

			case 0x8b50:
				return setValueV2fArray;
			// _VEC2

			case 0x8b51:
				return setValueV3fArray;
			// _VEC3

			case 0x8b52:
				return setValueV4fArray;
			// _VEC4

			case 0x8b5a:
				return setValueM2Array;
			// _MAT2

			case 0x8b5b:
				return setValueM3Array;
			// _MAT3

			case 0x8b5c:
				return setValueM4Array;
			// _MAT4

			case 0x1404:
			case 0x8b56:
				return setValueV1iArray;
			// INT, BOOL

			case 0x8b53:
			case 0x8b57:
				return setValueV2iArray;
			// _VEC2

			case 0x8b54:
			case 0x8b58:
				return setValueV3iArray;
			// _VEC3

			case 0x8b55:
			case 0x8b59:
				return setValueV4iArray;
			// _VEC4

			case 0x1405:
				return setValueV1uiArray;
			// UINT

			case 0x8dc6:
				return setValueV2uiArray;
			// _VEC2

			case 0x8dc7:
				return setValueV3uiArray;
			// _VEC3

			case 0x8dc8:
				return setValueV4uiArray;
			// _VEC4

			case 0x8b5e: // SAMPLER_2D

			case 0x8d66: // SAMPLER_EXTERNAL_OES

			case 0x8dca: // INT_SAMPLER_2D

			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D

			case 0x8b62:
				// SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE

			case 0x8dcc: // INT_SAMPLER_CUBE

			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE

			case 0x8dc5:
				// SAMPLER_CUBE_SHADOW
				return setValueT6Array;
		}
	} // --- Uniform Classes ---


	function SingleUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	function PureArrayUniform(id, activeInfo, addr) {
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter(activeInfo.type); // this.path = activeInfo.name; // DEBUG
	}

	PureArrayUniform.prototype.updateCache = function (data) {
		const cache = this.cache;

		if (data instanceof Float32Array && cache.length !== data.length) {
			this.cache = new Float32Array(data.length);
		}

		copyArray(cache, data);
	};

	function StructuredUniform(id) {
		this.id = id;
		this.seq = [];
		this.map = {};
	}

	StructuredUniform.prototype.setValue = function (gl, value, textures) {
		const seq = this.seq;

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			u.setValue(gl, value[u.id], textures);
		}
	}; // --- Top-level ---
	// Parser - builds up the property tree from the path strings


	const RePathPart = /(\w+)(\])?(\[|\.)?/g; // extracts
	// 	- the identifier (member name or array index)
	//	- followed by an optional right bracket (found when array index)
	//	- followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform(container, uniformObject) {
		container.seq.push(uniformObject);
		container.map[uniformObject.id] = uniformObject;
	}

	function parseUniform(activeInfo, addr, container) {
		const path = activeInfo.name,
					pathLength = path.length; // reset RegExp object, because of the early exit of a previous run

		RePathPart.lastIndex = 0;

		while (true) {
			const match = RePathPart.exec(path),
						matchEnd = RePathPart.lastIndex;
			let id = match[1];
			const idIsIndex = match[2] === ']',
						subscript = match[3];
			if (idIsIndex) id = id | 0; // convert to integer

			if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
				// bare name or "pure" bottom-level array "[0]" suffix
				addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
				break;
			} else {
				// step into inner node / create it in case it doesn't exist
				const map = container.map;
				let next = map[id];

				if (next === undefined) {
					next = new StructuredUniform(id);
					addUniform(container, next);
				}

				container = next;
			}
		}
	} // Root Container


	function WebGLUniforms(gl, program) {
		this.seq = [];
		this.map = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

		for (let i = 0; i < n; ++i) {
			const info = gl.getActiveUniform(program, i),
						addr = gl.getUniformLocation(program, info.name);
			parseUniform(info, addr, this);
		}
	}

	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
		const u = this.map[name];
		if (u !== undefined) u.setValue(gl, value, textures);
	};

	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
		const v = object[name];
		if (v !== undefined) this.setValue(gl, name, v);
	}; // Static interface


	WebGLUniforms.upload = function (gl, seq, values, textures) {
		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i],
						v = values[u.id];

			if (v.needsUpdate !== false) {
				// note: always updating when .needsUpdate is undefined
				u.setValue(gl, v.value, textures);
			}
		}
	};

	WebGLUniforms.seqWithValue = function (seq, values) {
		const r = [];

		for (let i = 0, n = seq.length; i !== n; ++i) {
			const u = seq[i];
			if (u.id in values) r.push(u);
		}

		return r;
	};

	function WebGLShader(gl, type, string) {
		const shader = gl.createShader(type);
		gl.shaderSource(shader, string);
		gl.compileShader(shader);
		return shader;
	}

	let programIdCount = 0;

	function addLineNumbers(string) {
		const lines = string.split('\n');

		for (let i = 0; i < lines.length; i++) {
			lines[i] = i + 1 + ': ' + lines[i];
		}

		return lines.join('\n');
	}

	function getEncodingComponents(encoding) {
		switch (encoding) {
			case LinearEncoding:
				return ['Linear', '( value )'];

			case sRGBEncoding:
				return ['sRGB', '( value )'];

			case RGBEEncoding:
				return ['RGBE', '( value )'];

			case RGBM7Encoding:
				return ['RGBM', '( value, 7.0 )'];

			case RGBM16Encoding:
				return ['RGBM', '( value, 16.0 )'];

			case RGBDEncoding:
				return ['RGBD', '( value, 256.0 )'];

			case GammaEncoding:
				return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];

			case LogLuvEncoding:
				return ['LogLuv', '( value )'];

			default:
				console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
				return ['Linear', '( value )'];
		}
	}

	function getShaderErrors(gl, shader, type) {
		const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
		const log = gl.getShaderInfoLog(shader).trim();
		if (status && log === '') return ''; // --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource(shader);
		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers(source);
	}

	function getTexelDecodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[0] + 'ToLinear' + components[1] + '; }';
	}

	function getTexelEncodingFunction(functionName, encoding) {
		const components = getEncodingComponents(encoding);
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[0] + components[1] + '; }';
	}

	function getToneMappingFunction(functionName, toneMapping) {
		let toneMappingName;

		switch (toneMapping) {
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
				toneMappingName = 'Linear';
		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	}

	function generateExtensions(parameters) {
		const chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ? '#extension GL_OES_standard_derivatives : enable' : '', (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '', parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? '#extension GL_EXT_draw_buffers : require' : '', (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission > 0.0) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''];
		return chunks.filter(filterEmptyLine).join('\n');
	}

	function generateDefines(defines) {
		const chunks = [];

		for (const name in defines) {
			const value = defines[name];
			if (value === false) continue;
			chunks.push('#define ' + name + ' ' + value);
		}

		return chunks.join('\n');
	}

	function fetchAttributeLocations(gl, program) {
		const attributes = {};
		const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

		for (let i = 0; i < n; i++) {
			const info = gl.getActiveAttrib(program, i);
			const name = info.name; // console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[name] = gl.getAttribLocation(program, name);
		}

		return attributes;
	}

	function filterEmptyLine(string) {
		return string !== '';
	}

	function replaceLightNums(string, parameters) {
		return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}

	function replaceClippingPlaneNums(string, parameters) {
		return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	} // Resolve Includes


	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes(string) {
		return string.replace(includePattern, includeReplacer);
	}

	function includeReplacer(match, include) {
		const string = ShaderChunk[include];

		if (string === undefined) {
			throw new Error('Can not resolve #include <' + include + '>');
		}

		return resolveIncludes(string);
	} // Unroll Loops


	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops(string) {
		return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
	}

	function deprecatedLoopReplacer(match, start, end, snippet) {
		console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');
		return loopReplacer(match, start, end, snippet);
	}

	function loopReplacer(match, start, end, snippet) {
		let string = '';

		for (let i = parseInt(start); i < parseInt(end); i++) {
			string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i);
		}

		return string;
	} //


	function generatePrecision(parameters) {
		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if (parameters.precision === 'highp') {
			precisionstring += '\n#define HIGH_PRECISION';
		} else if (parameters.precision === 'mediump') {
			precisionstring += '\n#define MEDIUM_PRECISION';
		} else if (parameters.precision === 'lowp') {
			precisionstring += '\n#define LOW_PRECISION';
		}

		return precisionstring;
	}

	function generateShadowMapTypeDefine(parameters) {
		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if (parameters.shadowMapType === PCFShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
		} else if (parameters.shadowMapType === PCFSoftShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
		} else if (parameters.shadowMapType === VSMShadowMap) {
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
		}

		return shadowMapTypeDefine;
	}

	function generateEnvMapTypeDefine(parameters) {
		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
			}
		}

		return envMapTypeDefine;
	}

	function generateEnvMapModeDefine(parameters) {
		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if (parameters.envMap) {
			switch (parameters.envMapMode) {
				case CubeRefractionMapping:
				case CubeUVRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
			}
		}

		return envMapModeDefine;
	}

	function generateEnvMapBlendingDefine(parameters) {
		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if (parameters.envMap) {
			switch (parameters.combine) {
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
			}
		}

		return envMapBlendingDefine;
	}

	function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
		const gl = renderer.getContext();
		const defines = parameters.defines;
		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;
		const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
		const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
		const envMapModeDefine = generateEnvMapModeDefine(parameters);
		const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
		const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;
		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions(parameters);
		const customDefines = generateDefines(defines);
		const program = gl.createProgram();
		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if (parameters.isRawShaderMaterial) {
			prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

			if (prefixVertex.length > 0) {
				prefixVertex += '\n';
			}

			prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join('\n');

			if (prefixFragment.length > 0) {
				prefixFragment += '\n';
			}
		} else {
			prefixVertex = [generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '', '#define GAMMA_FACTOR ' + gammaFactorDefine, '#define MAX_BONES ' + parameters.maxBones, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.useVertexTexture ? '#define BONE_TEXTURE' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_MORPHTARGETS', '	attribute vec3 morphTarget0;', '	attribute vec3 morphTarget1;', '	attribute vec3 morphTarget2;', '	attribute vec3 morphTarget3;', '	#ifdef USE_MORPHNORMALS', '		attribute vec3 morphNormal0;', '		attribute vec3 morphNormal1;', '		attribute vec3 morphNormal2;', '		attribute vec3 morphNormal3;', '	#else', '		attribute vec3 morphTarget4;', '		attribute vec3 morphTarget5;', '		attribute vec3 morphTarget6;', '		attribute vec3 morphTarget7;', '	#endif', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
			prefixFragment = [customExtensions, generatePrecision(parameters), '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + (parameters.alphaTest % 1 ? '' : '.0') : '', // add '.0' if integer
			'#define GAMMA_FACTOR ' + gammaFactorDefine, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMap && parameters.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '', parameters.normalMap && parameters.tangentSpaceNormalMap ? '#define TANGENTSPACE_NORMALMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '', parameters.specularTintMap ? '#define USE_SPECULARTINTMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUvs ? '#define USE_UV' : '', parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '', (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? '#define TEXTURE_LOD_EXT' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '', parameters.toneMapping !== NoToneMapping ? ShaderChunk['tonemapping_pars_fragment'] : '', // this code is required here because it is used by the toneMapping() function defined below
			parameters.toneMapping !== NoToneMapping ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', ShaderChunk['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding) : '', parameters.matcap ? getTexelDecodingFunction('matcapTexelToLinear', parameters.matcapEncoding) : '', parameters.envMap ? getTexelDecodingFunction('envMapTexelToLinear', parameters.envMapEncoding) : '', parameters.emissiveMap ? getTexelDecodingFunction('emissiveMapTexelToLinear', parameters.emissiveMapEncoding) : '', parameters.specularTintMap ? getTexelDecodingFunction('specularTintMapTexelToLinear', parameters.specularTintMapEncoding) : '', parameters.lightMap ? getTexelDecodingFunction('lightMapTexelToLinear', parameters.lightMapEncoding) : '', getTexelEncodingFunction('linearToOutputTexel', parameters.outputEncoding), parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n');
		}

		vertexShader = resolveIncludes(vertexShader);
		vertexShader = replaceLightNums(vertexShader, parameters);
		vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
		fragmentShader = resolveIncludes(fragmentShader);
		fragmentShader = replaceLightNums(fragmentShader, parameters);
		fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
		vertexShader = unrollLoops(vertexShader);
		fragmentShader = unrollLoops(fragmentShader);

		if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
			// GLSL 3.0 conversion for built-in materials and ShaderMaterial
			versionString = '#version 300 es\n';
			prefixVertex = ['#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
			prefixFragment = ['#define varying in', parameters.glslVersion === GLSL3 ? '' : 'out highp vec4 pc_fragColor;', parameters.glslVersion === GLSL3 ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment;
		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader; // console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
		const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
		gl.attachShader(program, glVertexShader);
		gl.attachShader(program, glFragmentShader); // Force a particular attribute to index 0.

		if (parameters.index0AttributeName !== undefined) {
			gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
		} else if (parameters.morphTargets === true) {
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation(program, 0, 'position');
		}

		gl.linkProgram(program); // check for link errors

		if (renderer.debug.checkShaderErrors) {
			const programLog = gl.getProgramInfoLog(program).trim();
			const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
			const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
			let runnable = true;
			let haveDiagnostics = true;

			if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
				runnable = false;
				const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
				const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
				console.error('THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors);
			} else if (programLog !== '') {
				console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', programLog);
			} else if (vertexLog === '' || fragmentLog === '') {
				haveDiagnostics = false;
			}

			if (haveDiagnostics) {
				this.diagnostics = {
					runnable: runnable,
					programLog: programLog,
					vertexShader: {
						log: vertexLog,
						prefix: prefixVertex
					},
					fragmentShader: {
						log: fragmentLog,
						prefix: prefixFragment
					}
				};
			}
		} // Clean up
		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );


		gl.deleteShader(glVertexShader);
		gl.deleteShader(glFragmentShader); // set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {
			if (cachedUniforms === undefined) {
				cachedUniforms = new WebGLUniforms(gl, program);
			}

			return cachedUniforms;
		}; // set up caching for attribute locations


		let cachedAttributes;

		this.getAttributes = function () {
			if (cachedAttributes === undefined) {
				cachedAttributes = fetchAttributeLocations(gl, program);
			}

			return cachedAttributes;
		}; // free resource


		this.destroy = function () {
			bindingStates.releaseStatesOfProgram(this);
			gl.deleteProgram(program);
			this.program = undefined;
		}; //


		this.name = parameters.shaderName;
		this.id = programIdCount++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
		return this;
	}

	function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
		const programs = [];
		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;
		let precision = capabilities.precision;
		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
		const parameterNames = ['precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor', 'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV', 'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap', 'specularIntensityMap', 'specularTintMap', 'specularTintMapEncoding', 'roughnessMap', 'metalnessMap', 'gradientMap', 'alphaMap', 'combine', 'vertexColors', 'vertexAlphas', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2', 'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning', 'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals', 'premultipliedAlpha', 'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights', 'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows', 'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights', 'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering', 'sheen', 'transmission', 'transmissionMap', 'thicknessMap'];

		function getMaxBones(object) {
			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if (floatVertexTextures) {
				return 1024;
			} else {
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//	- leave some extra space for other uniforms
				//	- limit here is ANGLE's 254 max uniform vectors
				//		(up to 54 should be safe)
				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
				const maxBones = Math.min(nVertexMatrices, bones.length);

				if (maxBones < bones.length) {
					console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');
					return 0;
				}

				return maxBones;
			}
		}

		function getTextureEncodingFromMap(map) {
			let encoding;

			if (map && map.isTexture) {
				encoding = map.encoding;
			} else if (map && map.isWebGLRenderTarget) {
				console.warn('THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.');
				encoding = map.texture.encoding;
			} else {
				encoding = LinearEncoding;
			}

			return encoding;
		}

		function getParameters(material, lights, shadows, scene, object) {
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

			if (material.precision !== null) {
				precision = capabilities.getMaxPrecision(material.precision);

				if (precision !== material.precision) {
					console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');
				}
			}

			let vertexShader, fragmentShader;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;
			} else {
				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;
			}

			const currentRenderTarget = renderer.getRenderTarget();
			const parameters = {
				isWebGL2: isWebGL2,
				shaderID: shaderID,
				shaderName: material.type,
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,
				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,
				precision: precision,
				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
				supportsVertexTextures: vertexTextures,
				outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
				map: !!material.map,
				mapEncoding: getTextureEncodingFromMap(material.map),
				matcap: !!material.matcap,
				matcapEncoding: getTextureEncodingFromMap(material.matcap),
				envMap: !!envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap(envMap),
				envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
				lightMap: !!material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
				aoMap: !!material.aoMap,
				emissiveMap: !!material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
				bumpMap: !!material.bumpMap,
				normalMap: !!material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !!material.clearcoatMap,
				clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,
				clearcoatNormalMap: !!material.clearcoatNormalMap,
				displacementMap: !!material.displacementMap,
				roughnessMap: !!material.roughnessMap,
				metalnessMap: !!material.metalnessMap,
				specularMap: !!material.specularMap,
				specularIntensityMap: !!material.specularIntensityMap,
				specularTintMap: !!material.specularTintMap,
				specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
				alphaMap: !!material.alphaMap,
				gradientMap: !!material.gradientMap,
				sheen: !!material.sheen,
				transmission: !!material.transmission,
				transmissionMap: !!material.transmissionMap,
				thicknessMap: !!material.thicknessMap,
				combine: material.combine,
				vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
				vertexColors: material.vertexColors,
				vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
				vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
				uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmission || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,
				fog: !!fog,
				useFog: material.fog,
				fogExp2: fog && fog.isFogExp2,
				flatShading: !!material.flatShading,
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
				skinning: object.isSkinnedMesh === true && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,
				morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
				morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,
				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,
				dithering: material.dithering,
				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
				premultipliedAlpha: material.premultipliedAlpha,
				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
				depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
				index0AttributeName: material.index0AttributeName,
				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
				rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),
				customProgramCacheKey: material.customProgramCacheKey()
			};
			return parameters;
		}

		function getProgramCacheKey(parameters) {
			const array = [];

			if (parameters.shaderID) {
				array.push(parameters.shaderID);
			} else {
				array.push(parameters.fragmentShader);
				array.push(parameters.vertexShader);
			}

			if (parameters.defines !== undefined) {
				for (const name in parameters.defines) {
					array.push(name);
					array.push(parameters.defines[name]);
				}
			}

			if (parameters.isRawShaderMaterial === false) {
				for (let i = 0; i < parameterNames.length; i++) {
					array.push(parameters[parameterNames[i]]);
				}

				array.push(renderer.outputEncoding);
				array.push(renderer.gammaFactor);
			}

			array.push(parameters.customProgramCacheKey);
			return array.join();
		}

		function getUniforms(material) {
			const shaderID = shaderIDs[material.type];
			let uniforms;

			if (shaderID) {
				const shader = ShaderLib[shaderID];
				uniforms = UniformsUtils.clone(shader.uniforms);
			} else {
				uniforms = material.uniforms;
			}

			return uniforms;
		}

		function acquireProgram(parameters, cacheKey) {
			let program; // Check if code has been already compiled

			for (let p = 0, pl = programs.length; p < pl; p++) {
				const preexistingProgram = programs[p];

				if (preexistingProgram.cacheKey === cacheKey) {
					program = preexistingProgram;
					++program.usedTimes;
					break;
				}
			}

			if (program === undefined) {
				program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
				programs.push(program);
			}

			return program;
		}

		function releaseProgram(program) {
			if (--program.usedTimes === 0) {
				// Remove from unordered set
				const i = programs.indexOf(program);
				programs[i] = programs[programs.length - 1];
				programs.pop(); // Free WebGL resources

				program.destroy();
			}
		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};
	}

	function WebGLProperties() {
		let properties = new WeakMap();

		function get(object) {
			let map = properties.get(object);

			if (map === undefined) {
				map = {};
				properties.set(object, map);
			}

			return map;
		}

		function remove(object) {
			properties.delete(object);
		}

		function update(object, key, value) {
			properties.get(object)[key] = value;
		}

		function dispose() {
			properties = new WeakMap();
		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	}

	function painterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.program !== b.program) {
			return a.program.id - b.program.id;
		} else if (a.material.id !== b.material.id) {
			return a.material.id - b.material.id;
		} else if (a.z !== b.z) {
			return a.z - b.z;
		} else {
			return a.id - b.id;
		}
	}

	function reversePainterSortStable(a, b) {
		if (a.groupOrder !== b.groupOrder) {
			return a.groupOrder - b.groupOrder;
		} else if (a.renderOrder !== b.renderOrder) {
			return a.renderOrder - b.renderOrder;
		} else if (a.z !== b.z) {
			return b.z - a.z;
		} else {
			return a.id - b.id;
		}
	}

	function WebGLRenderList(properties) {
		const renderItems = [];
		let renderItemsIndex = 0;
		const opaque = [];
		const transmissive = [];
		const transparent = [];
		const defaultProgram = {
			id: -1
		};

		function init() {
			renderItemsIndex = 0;
			opaque.length = 0;
			transmissive.length = 0;
			transparent.length = 0;
		}

		function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
			let renderItem = renderItems[renderItemsIndex];
			const materialProperties = properties.get(material);

			if (renderItem === undefined) {
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
				renderItems[renderItemsIndex] = renderItem;
			} else {
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
			}

			renderItemsIndex++;
			return renderItem;
		}

		function push(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.push(renderItem);
			} else if (material.transparent === true) {
				transparent.push(renderItem);
			} else {
				opaque.push(renderItem);
			}
		}

		function unshift(object, geometry, material, groupOrder, z, group) {
			const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);

			if (material.transmission > 0.0) {
				transmissive.unshift(renderItem);
			} else if (material.transparent === true) {
				transparent.unshift(renderItem);
			} else {
				opaque.unshift(renderItem);
			}
		}

		function sort(customOpaqueSort, customTransparentSort) {
			if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
			if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
			if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
		}

		function finish() {
			// Clear references from inactive renderItems in the list
			for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
				const renderItem = renderItems[i];
				if (renderItem.id === null) break;
				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;
			}
		}

		return {
			opaque: opaque,
			transmissive: transmissive,
			transparent: transparent,
			init: init,
			push: push,
			unshift: unshift,
			finish: finish,
			sort: sort
		};
	}

	function WebGLRenderLists(properties) {
		let lists = new WeakMap();

		function get(scene, renderCallDepth) {
			let list;

			if (lists.has(scene) === false) {
				list = new WebGLRenderList(properties);
				lists.set(scene, [list]);
			} else {
				if (renderCallDepth >= lists.get(scene).length) {
					list = new WebGLRenderList(properties);
					lists.get(scene).push(list);
				} else {
					list = lists.get(scene)[renderCallDepth];
				}
			}

			return list;
		}

		function dispose() {
			lists = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	function UniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	function ShadowUniformsCache() {
		const lights = {};
		return {
			get: function (light) {
				if (lights[light.id] !== undefined) {
					return lights[light.id];
				}

				let uniforms;

				switch (light.type) {
					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
					// TODO (abelnation): set RectAreaLight shadow uniforms
				}

				lights[light.id] = uniforms;
				return uniforms;
			}
		};
	}

	let nextVersion = 0;

	function shadowCastingLightsFirst(lightA, lightB) {
		return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}

	function WebGLLights(extensions, capabilities) {
		const cache = new UniformsCache();
		const shadowCache = ShadowUniformsCache();
		const state = {
			version: 0,
			hash: {
				directionalLength: -1,
				pointLength: -1,
				spotLength: -1,
				rectAreaLength: -1,
				hemiLength: -1,
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			},
			ambient: [0, 0, 0],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
		};

		for (let i = 0; i < 9; i++) state.probe.push(new Vector3());

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup(lights) {
			let r = 0,
					g = 0,
					b = 0;

			for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;
			lights.sort(shadowCastingLightsFirst);

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];
				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;
				const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;

				if (light.isAmbientLight) {
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
				} else if (light.isLightProbe) {
					for (let j = 0; j < 9; j++) {
						state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
					}
				} else if (light.isDirectionalLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.directionalShadow[directionalLength] = shadowUniforms;
						state.directionalShadowMap[directionalLength] = shadowMap;
						state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
						numDirectionalShadows++;
					}

					state.directional[directionalLength] = uniforms;
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = cache.get(light);
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.distance = distance;
					uniforms.coneCos = Math.cos(light.angle);
					uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						state.spotShadow[spotLength] = shadowUniforms;
						state.spotShadowMap[spotLength] = shadowMap;
						state.spotShadowMatrix[spotLength] = light.shadow.matrix;
						numSpotShadows++;
					}

					state.spot[spotLength] = uniforms;
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = cache.get(light); // (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
					// (b) intensity is the brightness of the light

					uniforms.color.copy(color).multiplyScalar(intensity);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					state.rectArea[rectAreaLength] = uniforms;
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = cache.get(light);
					uniforms.color.copy(light.color).multiplyScalar(light.intensity);
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if (light.castShadow) {
						const shadow = light.shadow;
						const shadowUniforms = shadowCache.get(light);
						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;
						state.pointShadow[pointLength] = shadowUniforms;
						state.pointShadowMap[pointLength] = shadowMap;
						state.pointShadowMatrix[pointLength] = light.shadow.matrix;
						numPointShadows++;
					}

					state.point[pointLength] = uniforms;
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = cache.get(light);
					uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
					uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
					state.hemi[hemiLength] = uniforms;
					hemiLength++;
				}
			}

			if (rectAreaLength > 0) {
				if (capabilities.isWebGL2) {
					// WebGL 2
					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
				} else {
					// WebGL 1
					if (extensions.has('OES_texture_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
					} else if (extensions.has('OES_texture_half_float_linear') === true) {
						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
					} else {
						console.error('THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.');
					}
				}
			}

			state.ambient[0] = r;
			state.ambient[1] = g;
			state.ambient[2] = b;
			const hash = state.hash;

			if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;
				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;
				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;
				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;
				state.version = nextVersion++;
			}
		}

		function setupView(lights, camera) {
			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;
			const viewMatrix = camera.matrixWorldInverse;

			for (let i = 0, l = lights.length; i < l; i++) {
				const light = lights[i];

				if (light.isDirectionalLight) {
					const uniforms = state.directional[directionalLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					directionalLength++;
				} else if (light.isSpotLight) {
					const uniforms = state.spot[spotLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					vector3.setFromMatrixPosition(light.target.matrixWorld);
					uniforms.direction.sub(vector3);
					uniforms.direction.transformDirection(viewMatrix);
					spotLength++;
				} else if (light.isRectAreaLight) {
					const uniforms = state.rectArea[rectAreaLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix); // extract local rotation of light to derive width/height half vectors

					matrix42.identity();
					matrix4.copy(light.matrixWorld);
					matrix4.premultiply(viewMatrix);
					matrix42.extractRotation(matrix4);
					uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
					uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
					uniforms.halfWidth.applyMatrix4(matrix42);
					uniforms.halfHeight.applyMatrix4(matrix42);
					rectAreaLength++;
				} else if (light.isPointLight) {
					const uniforms = state.point[pointLength];
					uniforms.position.setFromMatrixPosition(light.matrixWorld);
					uniforms.position.applyMatrix4(viewMatrix);
					pointLength++;
				} else if (light.isHemisphereLight) {
					const uniforms = state.hemi[hemiLength];
					uniforms.direction.setFromMatrixPosition(light.matrixWorld);
					uniforms.direction.transformDirection(viewMatrix);
					uniforms.direction.normalize();
					hemiLength++;
				}
			}
		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};
	}

	function WebGLRenderState(extensions, capabilities) {
		const lights = new WebGLLights(extensions, capabilities);
		const lightsArray = [];
		const shadowsArray = [];

		function init() {
			lightsArray.length = 0;
			shadowsArray.length = 0;
		}

		function pushLight(light) {
			lightsArray.push(light);
		}

		function pushShadow(shadowLight) {
			shadowsArray.push(shadowLight);
		}

		function setupLights() {
			lights.setup(lightsArray);
		}

		function setupLightsView(camera) {
			lights.setupView(lightsArray, camera);
		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			lights: lights
		};
		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	}

	function WebGLRenderStates(extensions, capabilities) {
		let renderStates = new WeakMap();

		function get(scene, renderCallDepth = 0) {
			let renderState;

			if (renderStates.has(scene) === false) {
				renderState = new WebGLRenderState(extensions, capabilities);
				renderStates.set(scene, [renderState]);
			} else {
				if (renderCallDepth >= renderStates.get(scene).length) {
					renderState = new WebGLRenderState(extensions, capabilities);
					renderStates.get(scene).push(renderState);
				} else {
					renderState = renderStates.get(scene)[renderCallDepth];
				}
			}

			return renderState;
		}

		function dispose() {
			renderStates = new WeakMap();
		}

		return {
			get: get,
			dispose: dispose
		};
	}

	/**
	 * parameters = {
	 *
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 * }
	 */

	class MeshDepthMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDepthMaterial';
			this.depthPacking = BasicDepthPacking;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.depthPacking = source.depthPacking;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			return this;
		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *	referencePosition: <float>,
	 *	nearDistance: <float>,
	 *	farDistance: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>
	 *
	 * }
	 */

	class MeshDistanceMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshDistanceMaterial';
			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;
			this.map = null;
			this.alphaMap = null;
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.fog = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.referencePosition.copy(source.referencePosition);
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			return this;
		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

	function WebGLShadowMap(_renderer, _objects, _capabilities) {
		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
					_viewportSize = new Vector2(),
					_viewport = new Vector4(),
					_depthMaterial = new MeshDepthMaterial({
			depthPacking: RGBADepthPacking
		}),
					_distanceMaterial = new MeshDistanceMaterial(),
					_materialCache = {},
					_maxTextureSize = _capabilities.maxTextureSize;

		const shadowSide = {
			0: BackSide,
			1: FrontSide,
			2: DoubleSide
		};
		const shadowMaterialVertical = new ShaderMaterial({
			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},
			uniforms: {
				shadow_pass: {
					value: null
				},
				resolution: {
					value: new Vector2()
				},
				radius: {
					value: 4.0
				}
			},
			vertexShader: vsm_vert,
			fragmentShader: vsm_frag
		});
		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
		const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
		const scope = this;
		this.enabled = false;
		this.autoUpdate = true;
		this.needsUpdate = false;
		this.type = PCFShadowMap;

		this.render = function (lights, scene, camera) {
			if (scope.enabled === false) return;
			if (scope.autoUpdate === false && scope.needsUpdate === false) return;
			if (lights.length === 0) return;

			const currentRenderTarget = _renderer.getRenderTarget();

			const activeCubeFace = _renderer.getActiveCubeFace();

			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state; // Set GL state for depth map.

			_state.setBlending(NoBlending);

			_state.buffers.color.setClear(1, 1, 1, 1);

			_state.buffers.depth.setTest(true);

			_state.setScissorTest(false); // render depth map


			for (let i = 0, il = lights.length; i < il; i++) {
				const light = lights[i];
				const shadow = light.shadow;

				if (shadow === undefined) {
					console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
					continue;
				}

				if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

				_shadowMapSize.copy(shadow.mapSize);

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply(shadowFrameExtents);

				_viewportSize.copy(shadow.mapSize);

				if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
					if (_shadowMapSize.x > _maxTextureSize) {
						_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;
					}

					if (_shadowMapSize.y > _maxTextureSize) {
						_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;
					}
				}

				if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
					const pars = {
						minFilter: LinearFilter,
						magFilter: LinearFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.camera.updateProjectionMatrix();
				}

				if (shadow.map === null) {
					const pars = {
						minFilter: NearestFilter,
						magFilter: NearestFilter,
						format: RGBAFormat
					};
					shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
					shadow.map.texture.name = light.name + '.shadowMap';
					shadow.camera.updateProjectionMatrix();
				}

				_renderer.setRenderTarget(shadow.map);

				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for (let vp = 0; vp < viewportCount; vp++) {
					const viewport = shadow.getViewport(vp);

					_viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);

					_state.viewport(_viewport);

					shadow.updateMatrices(light, vp);
					_frustum = shadow.getFrustum();
					renderObject(scene, camera, shadow.camera, light, this.type);
				} // do blur pass for VSM


				if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
					VSMPass(shadow, camera);
				}

				shadow.needsUpdate = false;
			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
		};

		function VSMPass(shadow, camera) {
			const geometry = _objects.update(fullScreenMesh); // vertical pass


			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.mapPass);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null); // horizontal pass


			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;

			_renderer.setRenderTarget(shadow.map);

			_renderer.clear();

			_renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
		}

		function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {
			let result = null;
			const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;

			if (customMaterial !== undefined) {
				result = customMaterial;
			} else {
				result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
			}

			if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
				// in this case we need a unique material instance reflecting the
				// appropriate state
				const keyA = result.uuid,
							keyB = material.uuid;
				let materialsForVariant = _materialCache[keyA];

				if (materialsForVariant === undefined) {
					materialsForVariant = {};
					_materialCache[keyA] = materialsForVariant;
				}

				let cachedMaterial = materialsForVariant[keyB];

				if (cachedMaterial === undefined) {
					cachedMaterial = result.clone();
					materialsForVariant[keyB] = cachedMaterial;
				}

				result = cachedMaterial;
			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if (type === VSMShadowMap) {
				result.side = material.shadowSide !== null ? material.shadowSide : material.side;
			} else {
				result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
				result.referencePosition.setFromMatrixPosition(light.matrixWorld);
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
			}

			return result;
		}

		function renderObject(object, camera, shadowCamera, light, type) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible && (object.isMesh || object.isLine || object.isPoints)) {
				if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
					object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);

					const geometry = _objects.update(object);

					const material = object.material;

					if (Array.isArray(material)) {
						const groups = geometry.groups;

						for (let k = 0, kl = groups.length; k < kl; k++) {
							const group = groups[k];
							const groupMaterial = material[group.materialIndex];

							if (groupMaterial && groupMaterial.visible) {
								const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);

								_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
							}
						}
					} else if (material.visible) {
						const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);

						_renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				renderObject(children[i], camera, shadowCamera, light, type);
			}
		}
	}

	function WebGLState(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {
			let locked = false;
			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4(0, 0, 0, 0);
			return {
				setMask: function (colorMask) {
					if (currentColorMask !== colorMask && !locked) {
						gl.colorMask(colorMask, colorMask, colorMask, colorMask);
						currentColorMask = colorMask;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (r, g, b, a, premultipliedAlpha) {
					if (premultipliedAlpha === true) {
						r *= a;
						g *= a;
						b *= a;
					}

					color.set(r, g, b, a);

					if (currentColorClear.equals(color) === false) {
						gl.clearColor(r, g, b, a);
						currentColorClear.copy(color);
					}
				},
				reset: function () {
					locked = false;
					currentColorMask = null;
					currentColorClear.set(-1, 0, 0, 0); // set to invalid state
				}
			};
		}

		function DepthBuffer() {
			let locked = false;
			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;
			return {
				setTest: function (depthTest) {
					if (depthTest) {
						enable(gl.DEPTH_TEST);
					} else {
						disable(gl.DEPTH_TEST);
					}
				},
				setMask: function (depthMask) {
					if (currentDepthMask !== depthMask && !locked) {
						gl.depthMask(depthMask);
						currentDepthMask = depthMask;
					}
				},
				setFunc: function (depthFunc) {
					if (currentDepthFunc !== depthFunc) {
						if (depthFunc) {
							switch (depthFunc) {
								case NeverDepth:
									gl.depthFunc(gl.NEVER);
									break;

								case AlwaysDepth:
									gl.depthFunc(gl.ALWAYS);
									break;

								case LessDepth:
									gl.depthFunc(gl.LESS);
									break;

								case LessEqualDepth:
									gl.depthFunc(gl.LEQUAL);
									break;

								case EqualDepth:
									gl.depthFunc(gl.EQUAL);
									break;

								case GreaterEqualDepth:
									gl.depthFunc(gl.GEQUAL);
									break;

								case GreaterDepth:
									gl.depthFunc(gl.GREATER);
									break;

								case NotEqualDepth:
									gl.depthFunc(gl.NOTEQUAL);
									break;

								default:
									gl.depthFunc(gl.LEQUAL);
							}
						} else {
							gl.depthFunc(gl.LEQUAL);
						}

						currentDepthFunc = depthFunc;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (depth) {
					if (currentDepthClear !== depth) {
						gl.clearDepth(depth);
						currentDepthClear = depth;
					}
				},
				reset: function () {
					locked = false;
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
				}
			};
		}

		function StencilBuffer() {
			let locked = false;
			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;
			return {
				setTest: function (stencilTest) {
					if (!locked) {
						if (stencilTest) {
							enable(gl.STENCIL_TEST);
						} else {
							disable(gl.STENCIL_TEST);
						}
					}
				},
				setMask: function (stencilMask) {
					if (currentStencilMask !== stencilMask && !locked) {
						gl.stencilMask(stencilMask);
						currentStencilMask = stencilMask;
					}
				},
				setFunc: function (stencilFunc, stencilRef, stencilMask) {
					if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
						gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
					}
				},
				setOp: function (stencilFail, stencilZFail, stencilZPass) {
					if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
						gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
					}
				},
				setLocked: function (lock) {
					locked = lock;
				},
				setClear: function (stencil) {
					if (currentStencilClear !== stencil) {
						gl.clearStencil(stencil);
						currentStencilClear = stencil;
					}
				},
				reset: function () {
					locked = false;
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
				}
			};
		} //


		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();
		let enabledCapabilities = {};
		let xrFramebuffer = null;
		let currentBoundFramebuffers = {};
		let currentProgram = null;
		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;
		let currentFlipSided = null;
		let currentCullFace = null;
		let currentLineWidth = null;
		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;
		const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter(gl.VERSION);

		if (glVersion.indexOf('WebGL') !== -1) {
			version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 1.0;
		} else if (glVersion.indexOf('OpenGL ES') !== -1) {
			version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
			lineWidthAvailable = version >= 2.0;
		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};
		const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
		const viewportParam = gl.getParameter(gl.VIEWPORT);
		const currentScissor = new Vector4().fromArray(scissorParam);
		const currentViewport = new Vector4().fromArray(viewportParam);

		function createTexture(type, target, count) {
			const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.

			const texture = gl.createTexture();
			gl.bindTexture(type, texture);
			gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

			for (let i = 0; i < count; i++) {
				gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
			}

			return texture;
		}

		const emptyTextures = {};
		emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
		emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6); // init

		colorBuffer.setClear(0, 0, 0, 1);
		depthBuffer.setClear(1);
		stencilBuffer.setClear(0);
		enable(gl.DEPTH_TEST);
		depthBuffer.setFunc(LessEqualDepth);
		setFlipSided(false);
		setCullFace(CullFaceBack);
		enable(gl.CULL_FACE);
		setBlending(NoBlending); //

		function enable(id) {
			if (enabledCapabilities[id] !== true) {
				gl.enable(id);
				enabledCapabilities[id] = true;
			}
		}

		function disable(id) {
			if (enabledCapabilities[id] !== false) {
				gl.disable(id);
				enabledCapabilities[id] = false;
			}
		}

		function bindXRFramebuffer(framebuffer) {
			if (framebuffer !== xrFramebuffer) {
				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
				xrFramebuffer = framebuffer;
			}
		}

		function bindFramebuffer(target, framebuffer) {
			if (framebuffer === null && xrFramebuffer !== null) framebuffer = xrFramebuffer; // use active XR framebuffer if available

			if (currentBoundFramebuffers[target] !== framebuffer) {
				gl.bindFramebuffer(target, framebuffer);
				currentBoundFramebuffers[target] = framebuffer;

				if (isWebGL2) {
					// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER
					if (target === gl.DRAW_FRAMEBUFFER) {
						currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
					}

					if (target === gl.FRAMEBUFFER) {
						currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
					}
				}

				return true;
			}

			return false;
		}

		function useProgram(program) {
			if (currentProgram !== program) {
				gl.useProgram(program);
				currentProgram = program;
				return true;
			}

			return false;
		}

		const equationToGL = {
			[AddEquation]: gl.FUNC_ADD,
			[SubtractEquation]: gl.FUNC_SUBTRACT,
			[ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
		};

		if (isWebGL2) {
			equationToGL[MinEquation] = gl.MIN;
			equationToGL[MaxEquation] = gl.MAX;
		} else {
			const extension = extensions.get('EXT_blend_minmax');

			if (extension !== null) {
				equationToGL[MinEquation] = extension.MIN_EXT;
				equationToGL[MaxEquation] = extension.MAX_EXT;
			}
		}

		const factorToGL = {
			[ZeroFactor]: gl.ZERO,
			[OneFactor]: gl.ONE,
			[SrcColorFactor]: gl.SRC_COLOR,
			[SrcAlphaFactor]: gl.SRC_ALPHA,
			[SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
			[DstColorFactor]: gl.DST_COLOR,
			[DstAlphaFactor]: gl.DST_ALPHA,
			[OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
			[OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
			[OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
			[OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
			if (blending === NoBlending) {
				if (currentBlendingEnabled === true) {
					disable(gl.BLEND);
					currentBlendingEnabled = false;
				}

				return;
			}

			if (currentBlendingEnabled === false) {
				enable(gl.BLEND);
				currentBlendingEnabled = true;
			}

			if (blending !== CustomBlending) {
				if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
					if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
						gl.blendEquation(gl.FUNC_ADD);
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
					}

					if (premultipliedAlpha) {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.ONE, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					} else {
						switch (blending) {
							case NormalBlending:
								gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
								break;

							case AdditiveBlending:
								gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
								break;

							case SubtractiveBlending:
								gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
								break;

							case MultiplyBlending:
								gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
								break;

							default:
								console.error('THREE.WebGLState: Invalid blending: ', blending);
								break;
						}
					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
				}

				return;
			} // custom blending


			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
				gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
			}

			if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
				gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
			}

			currentBlending = blending;
			currentPremultipledAlpha = null;
		}

		function setMaterial(material, frontFaceCW) {
			material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
			let flipSided = material.side === BackSide;
			if (frontFaceCW) flipSided = !flipSided;
			setFlipSided(flipSided);
			material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
			depthBuffer.setFunc(material.depthFunc);
			depthBuffer.setTest(material.depthTest);
			depthBuffer.setMask(material.depthWrite);
			colorBuffer.setMask(material.colorWrite);
			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest(stencilWrite);

			if (stencilWrite) {
				stencilBuffer.setMask(material.stencilWriteMask);
				stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
				stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
			}

			setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
			material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
		} //


		function setFlipSided(flipSided) {
			if (currentFlipSided !== flipSided) {
				if (flipSided) {
					gl.frontFace(gl.CW);
				} else {
					gl.frontFace(gl.CCW);
				}

				currentFlipSided = flipSided;
			}
		}

		function setCullFace(cullFace) {
			if (cullFace !== CullFaceNone) {
				enable(gl.CULL_FACE);

				if (cullFace !== currentCullFace) {
					if (cullFace === CullFaceBack) {
						gl.cullFace(gl.BACK);
					} else if (cullFace === CullFaceFront) {
						gl.cullFace(gl.FRONT);
					} else {
						gl.cullFace(gl.FRONT_AND_BACK);
					}
				}
			} else {
				disable(gl.CULL_FACE);
			}

			currentCullFace = cullFace;
		}

		function setLineWidth(width) {
			if (width !== currentLineWidth) {
				if (lineWidthAvailable) gl.lineWidth(width);
				currentLineWidth = width;
			}
		}

		function setPolygonOffset(polygonOffset, factor, units) {
			if (polygonOffset) {
				enable(gl.POLYGON_OFFSET_FILL);

				if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
					gl.polygonOffset(factor, units);
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
				}
			} else {
				disable(gl.POLYGON_OFFSET_FILL);
			}
		}

		function setScissorTest(scissorTest) {
			if (scissorTest) {
				enable(gl.SCISSOR_TEST);
			} else {
				disable(gl.SCISSOR_TEST);
			}
		} // texture


		function activeTexture(webglSlot) {
			if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if (currentTextureSlot !== webglSlot) {
				gl.activeTexture(webglSlot);
				currentTextureSlot = webglSlot;
			}
		}

		function bindTexture(webglType, webglTexture) {
			if (currentTextureSlot === null) {
				activeTexture();
			}

			let boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture === undefined) {
				boundTexture = {
					type: undefined,
					texture: undefined
				};
				currentBoundTextures[currentTextureSlot] = boundTexture;
			}

			if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
				gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
			}
		}

		function unbindTexture() {
			const boundTexture = currentBoundTextures[currentTextureSlot];

			if (boundTexture !== undefined && boundTexture.type !== undefined) {
				gl.bindTexture(boundTexture.type, null);
				boundTexture.type = undefined;
				boundTexture.texture = undefined;
			}
		}

		function compressedTexImage2D() {
			try {
				gl.compressedTexImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage2D() {
			try {
				gl.texImage2D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		}

		function texImage3D() {
			try {
				gl.texImage3D.apply(gl, arguments);
			} catch (error) {
				console.error('THREE.WebGLState:', error);
			}
		} //


		function scissor(scissor) {
			if (currentScissor.equals(scissor) === false) {
				gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
				currentScissor.copy(scissor);
			}
		}

		function viewport(viewport) {
			if (currentViewport.equals(viewport) === false) {
				gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
				currentViewport.copy(viewport);
			}
		} //


		function reset() {
			// reset state
			gl.disable(gl.BLEND);
			gl.disable(gl.CULL_FACE);
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.POLYGON_OFFSET_FILL);
			gl.disable(gl.SCISSOR_TEST);
			gl.disable(gl.STENCIL_TEST);
			gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
			gl.blendEquation(gl.FUNC_ADD);
			gl.blendFunc(gl.ONE, gl.ZERO);
			gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
			gl.colorMask(true, true, true, true);
			gl.clearColor(0, 0, 0, 0);
			gl.depthMask(true);
			gl.depthFunc(gl.LESS);
			gl.clearDepth(1);
			gl.stencilMask(0xffffffff);
			gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
			gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
			gl.clearStencil(0);
			gl.cullFace(gl.BACK);
			gl.frontFace(gl.CCW);
			gl.polygonOffset(0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			if (isWebGL2 === true) {
				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
			}

			gl.useProgram(null);
			gl.lineWidth(1);
			gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // reset internals

			enabledCapabilities = {};
			currentTextureSlot = null;
			currentBoundTextures = {};
			xrFramebuffer = null;
			currentBoundFramebuffers = {};
			currentProgram = null;
			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;
			currentFlipSided = null;
			currentCullFace = null;
			currentLineWidth = null;
			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;
			currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
			currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
		}

		return {
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
			enable: enable,
			disable: disable,
			bindFramebuffer: bindFramebuffer,
			bindXRFramebuffer: bindXRFramebuffer,
			useProgram: useProgram,
			setBlending: setBlending,
			setMaterial: setMaterial,
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
			setScissorTest: setScissorTest,
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
			scissor: scissor,
			viewport: viewport,
			reset: reset
		};
	}

	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;

		const _videoTextures = new WeakMap();

		let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).


		let useOffscreenCanvas = false;

		try {
			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;
		} catch (err) {// Ignore any errors
		}

		function createCanvas(width, height) {
			// Use OffscreenCanvas when available. Specially needed in web workers
			return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		}

		function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
			let scale = 1; // handle case if texture exceeds max size

			if (image.width > maxSize || image.height > maxSize) {
				scale = maxSize / Math.max(image.width, image.height);
			} // only perform resize if necessary


			if (scale < 1 || needsPowerOfTwo === true) {
				// only perform resize for certain image types
				if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
					const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
					const width = floor(scale * image.width);
					const height = floor(scale * image.height);
					if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
					canvas.width = width;
					canvas.height = height;
					const context = canvas.getContext('2d');
					context.drawImage(image, 0, 0, width, height);
					console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');
					return canvas;
				} else {
					if ('data' in image) {
						console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');
					}

					return image;
				}
			}

			return image;
		}

		function isPowerOfTwo$1(image) {
			return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
		}

		function textureNeedsPowerOfTwo(texture) {
			if (isWebGL2) return false;
			return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function textureNeedsGenerateMipmaps(texture, supportsMips) {
			return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
		}

		function generateMipmap(target, texture, width, height, depth = 1) {
			_gl.generateMipmap(target);

			const textureProperties = properties.get(texture);
			textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
		}

		function getInternalFormat(internalFormatName, glFormat, glType) {
			if (isWebGL2 === false) return glFormat;

			if (internalFormatName !== null) {
				if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
				console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
			}

			let internalFormat = glFormat;

			if (glFormat === _gl.RED) {
				if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
			}

			if (glFormat === _gl.RGB) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
			}

			if (glFormat === _gl.RGBA) {
				if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
				if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
				if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8;
			}

			if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
				extensions.get('EXT_color_buffer_float');
			}

			return internalFormat;
		} // Fallback filters for non-power-of-2 textures


		function filterFallback(f) {
			if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
				return _gl.NEAREST;
			}

			return _gl.LINEAR;
		} //


		function onTextureDispose(event) {
			const texture = event.target;
			texture.removeEventListener('dispose', onTextureDispose);
			deallocateTexture(texture);

			if (texture.isVideoTexture) {
				_videoTextures.delete(texture);
			}

			info.memory.textures--;
		}

		function onRenderTargetDispose(event) {
			const renderTarget = event.target;
			renderTarget.removeEventListener('dispose', onRenderTargetDispose);
			deallocateRenderTarget(renderTarget);
		} //


		function deallocateTexture(texture) {
			const textureProperties = properties.get(texture);
			if (textureProperties.__webglInit === undefined) return;

			_gl.deleteTexture(textureProperties.__webglTexture);

			properties.remove(texture);
		}

		function deallocateRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			if (!renderTarget) return;

			if (textureProperties.__webglTexture !== undefined) {
				_gl.deleteTexture(textureProperties.__webglTexture);

				info.memory.textures--;
			}

			if (renderTarget.depthTexture) {
				renderTarget.depthTexture.dispose();
			}

			if (renderTarget.isWebGLCubeRenderTarget) {
				for (let i = 0; i < 6; i++) {
					_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);

					if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
				}
			} else {
				_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);

				if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
				if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
				if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
				if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
			}

			if (renderTarget.isWebGLMultipleRenderTargets) {
				for (let i = 0, il = texture.length; i < il; i++) {
					const attachmentProperties = properties.get(texture[i]);

					if (attachmentProperties.__webglTexture) {
						_gl.deleteTexture(attachmentProperties.__webglTexture);

						info.memory.textures--;
					}

					properties.remove(texture[i]);
				}
			}

			properties.remove(texture);
			properties.remove(renderTarget);
		} //


		let textureUnits = 0;

		function resetTextureUnits() {
			textureUnits = 0;
		}

		function allocateTextureUnit() {
			const textureUnit = textureUnits;

			if (textureUnit >= maxTextures) {
				console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);
			}

			textureUnits += 1;
			return textureUnit;
		} //


		function setTexture2D(texture, slot) {
			const textureProperties = properties.get(texture);
			if (texture.isVideoTexture) updateVideoTexture(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				const image = texture.image;

				if (image === undefined) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');
				} else if (image.complete === false) {
					console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');
				} else {
					uploadTexture(textureProperties, texture, slot);
					return;
				}
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
		}

		function setTexture2DArray(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
		}

		function setTexture3D(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
		}

		function setTextureCube(texture, slot) {
			const textureProperties = properties.get(texture);

			if (texture.version > 0 && textureProperties.__version !== texture.version) {
				uploadCubeTexture(textureProperties, texture, slot);
				return;
			}

			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
		}

		const wrappingToGL = {
			[RepeatWrapping]: _gl.REPEAT,
			[ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
			[MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
		};
		const filterToGL = {
			[NearestFilter]: _gl.NEAREST,
			[NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
			[NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
			[LinearFilter]: _gl.LINEAR,
			[LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
			[LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters(textureType, texture, supportsMips) {
			if (supportsMips) {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
			} else {
				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);

				_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

				if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
					_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
				}

				if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');
				}

				_gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));

				_gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));

				if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
					console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');
				}
			}

			if (extensions.has('EXT_texture_filter_anisotropic') === true) {
				const extension = extensions.get('EXT_texture_filter_anisotropic');
				if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

				if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only

				if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
					_gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));

					properties.get(texture).__currentAnisotropy = texture.anisotropy;
				}
			}
		}

		function initTexture(textureProperties, texture) {
			if (textureProperties.__webglInit === undefined) {
				textureProperties.__webglInit = true;
				texture.addEventListener('dispose', onTextureDispose);
				textureProperties.__webglTexture = _gl.createTexture();
				info.memory.textures++;
			}
		}

		function uploadTexture(textureProperties, texture, slot) {
			let textureType = _gl.TEXTURE_2D;
			if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
			if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(textureType, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
			const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
			const supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format);
			let glType = utils.convert(texture.type),
					glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(textureType, texture, supportsMips);
			let mipmap;
			const mipmaps = texture.mipmaps;

			if (texture.isDepthTexture) {
				// populate depth texture with dummy data
				glInternalFormat = _gl.DEPTH_COMPONENT;

				if (isWebGL2) {
					if (texture.type === FloatType) {
						glInternalFormat = _gl.DEPTH_COMPONENT32F;
					} else if (texture.type === UnsignedIntType) {
						glInternalFormat = _gl.DEPTH_COMPONENT24;
					} else if (texture.type === UnsignedInt248Type) {
						glInternalFormat = _gl.DEPTH24_STENCIL8;
					} else {
						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
					}
				} else {
					if (texture.type === FloatType) {
						console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');
					}
				} // validation checks for WebGL 1


				if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
						console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');
						texture.type = UnsignedShortType;
						glType = utils.convert(texture.type);
					}
				}

				if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)

					if (texture.type !== UnsignedInt248Type) {
						console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');
						texture.type = UnsignedInt248Type;
						glType = utils.convert(texture.type);
					}
				} //


				state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
			} else if (texture.isDataTexture) {
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
					textureProperties.__maxMipLevel = 0;
				}
			} else if (texture.isCompressedTexture) {
				for (let i = 0, il = mipmaps.length; i < il; i++) {
					mipmap = mipmaps[i];

					if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
						if (glFormat !== null) {
							state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
						} else {
							console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
						}
					} else {
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else if (texture.isDataTexture2DArray) {
				state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else if (texture.isDataTexture3D) {
				state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
				textureProperties.__maxMipLevel = 0;
			} else {
				// regular Texture (image, video, canvas)
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
				if (mipmaps.length > 0 && supportsMips) {
					for (let i = 0, il = mipmaps.length; i < il; i++) {
						mipmap = mipmaps[i];
						state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
				} else {
					state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
					textureProperties.__maxMipLevel = 0;
				}
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				generateMipmap(textureType, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		}

		function uploadCubeTexture(textureProperties, texture, slot) {
			if (texture.image.length !== 6) return;
			initTexture(textureProperties, texture);
			state.activeTexture(_gl.TEXTURE0 + slot);
			state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);

			_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

			const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
			const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
			const cubeImage = [];

			for (let i = 0; i < 6; i++) {
				if (!isCompressed && !isDataTexture) {
					cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
				} else {
					cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
				}
			}

			const image = cubeImage[0],
						supportsMips = isPowerOfTwo$1(image) || isWebGL2,
						glFormat = utils.convert(texture.format),
						glType = utils.convert(texture.type),
						glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
			setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
			let mipmaps;

			if (isCompressed) {
				for (let i = 0; i < 6; i++) {
					mipmaps = cubeImage[i].mipmaps;

					for (let j = 0; j < mipmaps.length; j++) {
						const mipmap = mipmaps[j];

						if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
							if (glFormat !== null) {
								state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
							} else {
								console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');
							}
						} else {
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;
			} else {
				mipmaps = texture.mipmaps;

				for (let i = 0; i < 6; i++) {
					if (isDataTexture) {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							const mipmapImage = mipmap.image[i].image;
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
						}
					} else {
						state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);

						for (let j = 0; j < mipmaps.length; j++) {
							const mipmap = mipmaps[j];
							state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
						}
					}
				}

				textureProperties.__maxMipLevel = mipmaps.length;
			}

			if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
				// We assume images for cube map have the same size.
				generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
			}

			textureProperties.__version = texture.version;
			if (texture.onUpdate) texture.onUpdate(texture);
		} // Render targets
		// Setup storage for target texture and bind it to correct framebuffer


		function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
			const glFormat = utils.convert(texture.format);
			const glType = utils.convert(texture.type);
			const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

			if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
				state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
			} else {
				state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			_gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Setup storage for internal depth/stencil buffers and bind to correct framebuffer


		function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
			_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

			if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if (isMultisample) {
					const depthTexture = renderTarget.depthTexture;

					if (depthTexture && depthTexture.isDepthTexture) {
						if (depthTexture.type === FloatType) {
							glInternalFormat = _gl.DEPTH_COMPONENT32F;
						} else if (depthTexture.type === UnsignedIntType) {
							glInternalFormat = _gl.DEPTH_COMPONENT24;
						}
					}

					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
				}

				_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
			} else {
				// Use the first texture for MRT so far
				const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
				const glFormat = utils.convert(texture.format);
				const glType = utils.convert(texture.type);
				const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);

				if (isMultisample) {
					const samples = getRenderTargetSamples(renderTarget);

					_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
				} else {
					_gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
				}
			}

			_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
		} // Setup resources for a Depth Texture for a FBO (needs an extension)


		function setupDepthTexture(framebuffer, renderTarget) {
			const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
			if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
			state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
				throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
			} // upload an empty depth texture with framebuffer size


			if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
			}

			setTexture2D(renderTarget.depthTexture, 0);

			const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;

			if (renderTarget.depthTexture.format === DepthFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else if (renderTarget.depthTexture.format === DepthStencilFormat) {
				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
			} else {
				throw new Error('Unknown depthTexture format');
			}
		} // Setup GL resources for a non-texture depth buffer


		function setupDepthRenderbuffer(renderTarget) {
			const renderTargetProperties = properties.get(renderTarget);
			const isCube = renderTarget.isWebGLCubeRenderTarget === true;

			if (renderTarget.depthTexture) {
				if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
				setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
			} else {
				if (isCube) {
					renderTargetProperties.__webglDepthbuffer = [];

					for (let i = 0; i < 6; i++) {
						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
						renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
						setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
					}
				} else {
					state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
				}
			}

			state.bindFramebuffer(_gl.FRAMEBUFFER, null);
		} // Set up GL resources for the render target


		function setupRenderTarget(renderTarget) {
			const texture = renderTarget.texture;
			const renderTargetProperties = properties.get(renderTarget);
			const textureProperties = properties.get(texture);
			renderTarget.addEventListener('dispose', onRenderTargetDispose);

			if (renderTarget.isWebGLMultipleRenderTargets !== true) {
				textureProperties.__webglTexture = _gl.createTexture();
				textureProperties.__version = texture.version;
				info.memory.textures++;
			}

			const isCube = renderTarget.isWebGLCubeRenderTarget === true;
			const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
			const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2; // Handles WebGL2 RGBFormat fallback - #18858

			if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
				texture.format = RGBAFormat;
				console.warn('THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.');
			} // Setup framebuffer


			if (isCube) {
				renderTargetProperties.__webglFramebuffer = [];

				for (let i = 0; i < 6; i++) {
					renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
				}
			} else {
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if (isMultipleRenderTargets) {
					if (capabilities.drawBuffers) {
						const textures = renderTarget.texture;

						for (let i = 0, il = textures.length; i < il; i++) {
							const attachmentProperties = properties.get(textures[i]);

							if (attachmentProperties.__webglTexture === undefined) {
								attachmentProperties.__webglTexture = _gl.createTexture();
								info.memory.textures++;
							}
						}
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');
					}
				} else if (isMultisample) {
					if (isWebGL2) {
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						const glFormat = utils.convert(texture.format);
						const glType = utils.convert(texture.type);
						const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
						const samples = getRenderTargetSamples(renderTarget);

						_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);

						state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);

						_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

						if (renderTarget.depthBuffer) {
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					} else {
						console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
					}
				}
			} // Setup color buffer


			if (isCube) {
				state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
				setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

				for (let i = 0; i < 6; i++) {
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);
				}

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height);
				}

				state.bindTexture(_gl.TEXTURE_CUBE_MAP, null);
			} else if (isMultipleRenderTargets) {
				const textures = renderTarget.texture;

				for (let i = 0, il = textures.length; i < il; i++) {
					const attachment = textures[i];
					const attachmentProperties = properties.get(attachment);
					state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
					setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
					setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);

					if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
						generateMipmap(_gl.TEXTURE_2D, attachment, renderTarget.width, renderTarget.height);
					}
				}

				state.bindTexture(_gl.TEXTURE_2D, null);
			} else {
				let glTextureType = _gl.TEXTURE_2D;

				if (isRenderTarget3D) {
					// Render targets containing layers, i.e: Texture 3D and 2d arrays
					if (isWebGL2) {
						const isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
					} else {
						console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');
					}
				}

				state.bindTexture(glTextureType, textureProperties.__webglTexture);
				setTextureParameters(glTextureType, texture, supportsMips);
				setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
				}

				state.bindTexture(glTextureType, null);
			} // Setup depth and stencil buffers


			if (renderTarget.depthBuffer) {
				setupDepthRenderbuffer(renderTarget);
			}
		}

		function updateRenderTargetMipmap(renderTarget) {
			const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
			const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];

			for (let i = 0, il = textures.length; i < il; i++) {
				const texture = textures[i];

				if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
					const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;

					const webglTexture = properties.get(texture).__webglTexture;

					state.bindTexture(target, webglTexture);
					generateMipmap(target, texture, renderTarget.width, renderTarget.height);
					state.bindTexture(target, null);
				}
			}
		}

		function updateMultisampleRenderTarget(renderTarget) {
			if (renderTarget.isWebGLMultisampleRenderTarget) {
				if (isWebGL2) {
					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;
					if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
					if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
					const renderTargetProperties = properties.get(renderTarget);
					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);

					_gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);

					state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
					state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
				} else {
					console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');
				}
			}
		}

		function getRenderTargetSamples(renderTarget) {
			return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
		}

		function updateVideoTexture(texture) {
			const frame = info.render.frame; // Check the last frame we updated the VideoTexture

			if (_videoTextures.get(texture) !== frame) {
				_videoTextures.set(texture, frame);

				texture.update();
			}
		} // backwards compatibility


		let warnedTexture2D = false;
		let warnedTextureCube = false;

		function safeSetTexture2D(texture, slot) {
			if (texture && texture.isWebGLRenderTarget) {
				if (warnedTexture2D === false) {
					console.warn('THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.');
					warnedTexture2D = true;
				}

				texture = texture.texture;
			}

			setTexture2D(texture, slot);
		}

		function safeSetTextureCube(texture, slot) {
			if (texture && texture.isWebGLCubeRenderTarget) {
				if (warnedTextureCube === false) {
					console.warn('THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.');
					warnedTextureCube = true;
				}

				texture = texture.texture;
			}

			setTextureCube(texture, slot);
		} //


		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;
		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;
	}

	function WebGLUtils(gl, extensions, capabilities) {
		const isWebGL2 = capabilities.isWebGL2;

		function convert(p) {
			let extension;
			if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
			if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
			if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
			if (p === UnsignedShort565Type) return gl.UNSIGNED_SHORT_5_6_5;
			if (p === ByteType) return gl.BYTE;
			if (p === ShortType) return gl.SHORT;
			if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
			if (p === IntType) return gl.INT;
			if (p === UnsignedIntType) return gl.UNSIGNED_INT;
			if (p === FloatType) return gl.FLOAT;

			if (p === HalfFloatType) {
				if (isWebGL2) return gl.HALF_FLOAT;
				extension = extensions.get('OES_texture_half_float');

				if (extension !== null) {
					return extension.HALF_FLOAT_OES;
				} else {
					return null;
				}
			}

			if (p === AlphaFormat) return gl.ALPHA;
			if (p === RGBFormat) return gl.RGB;
			if (p === RGBAFormat) return gl.RGBA;
			if (p === LuminanceFormat) return gl.LUMINANCE;
			if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
			if (p === DepthFormat) return gl.DEPTH_COMPONENT;
			if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
			if (p === RedFormat) return gl.RED; // WebGL2 formats.

			if (p === RedIntegerFormat) return gl.RED_INTEGER;
			if (p === RGFormat) return gl.RG;
			if (p === RGIntegerFormat) return gl.RG_INTEGER;
			if (p === RGBIntegerFormat) return gl.RGB_INTEGER;
			if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;

			if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
				extension = extensions.get('WEBGL_compressed_texture_s3tc');

				if (extension !== null) {
					if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
				} else {
					return null;
				}
			}

			if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_pvrtc');

				if (extension !== null) {
					if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC1_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc1');

				if (extension !== null) {
					return extension.COMPRESSED_RGB_ETC1_WEBGL;
				} else {
					return null;
				}
			}

			if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
				extension = extensions.get('WEBGL_compressed_texture_etc');

				if (extension !== null) {
					if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
					if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
				}
			}

			if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
				extension = extensions.get('WEBGL_compressed_texture_astc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === RGBA_BPTC_Format) {
				extension = extensions.get('EXT_texture_compression_bptc');

				if (extension !== null) {
					// TODO Complete?
					return p;
				} else {
					return null;
				}
			}

			if (p === UnsignedInt248Type) {
				if (isWebGL2) return gl.UNSIGNED_INT_24_8;
				extension = extensions.get('WEBGL_depth_texture');

				if (extension !== null) {
					return extension.UNSIGNED_INT_24_8_WEBGL;
				} else {
					return null;
				}
			}
		}

		return {
			convert: convert
		};
	}

	class ArrayCamera extends PerspectiveCamera {
		constructor(array = []) {
			super();
			this.cameras = array;
		}

	}

	ArrayCamera.prototype.isArrayCamera = true;

	class Group extends Object3D {
		constructor() {
			super();
			this.type = 'Group';
		}

	}

	Group.prototype.isGroup = true;

	const _moveEvent = {
		type: 'move'
	};

	class WebXRController {
		constructor() {
			this._targetRay = null;
			this._grip = null;
			this._hand = null;
		}

		getHandSpace() {
			if (this._hand === null) {
				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;
				this._hand.joints = {};
				this._hand.inputState = {
					pinching: false
				};
			}

			return this._hand;
		}

		getTargetRaySpace() {
			if (this._targetRay === null) {
				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;
				this._targetRay.hasLinearVelocity = false;
				this._targetRay.linearVelocity = new Vector3();
				this._targetRay.hasAngularVelocity = false;
				this._targetRay.angularVelocity = new Vector3();
			}

			return this._targetRay;
		}

		getGripSpace() {
			if (this._grip === null) {
				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;
				this._grip.hasLinearVelocity = false;
				this._grip.linearVelocity = new Vector3();
				this._grip.hasAngularVelocity = false;
				this._grip.angularVelocity = new Vector3();
			}

			return this._grip;
		}

		dispatchEvent(event) {
			if (this._targetRay !== null) {
				this._targetRay.dispatchEvent(event);
			}

			if (this._grip !== null) {
				this._grip.dispatchEvent(event);
			}

			if (this._hand !== null) {
				this._hand.dispatchEvent(event);
			}

			return this;
		}

		disconnect(inputSource) {
			this.dispatchEvent({
				type: 'disconnected',
				data: inputSource
			});

			if (this._targetRay !== null) {
				this._targetRay.visible = false;
			}

			if (this._grip !== null) {
				this._grip.visible = false;
			}

			if (this._hand !== null) {
				this._hand.visible = false;
			}

			return this;
		}

		update(inputSource, frame, referenceSpace) {
			let inputPose = null;
			let gripPose = null;
			let handPose = null;
			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
				if (targetRay !== null) {
					inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);

					if (inputPose !== null) {
						targetRay.matrix.fromArray(inputPose.transform.matrix);
						targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);

						if (inputPose.linearVelocity) {
							targetRay.hasLinearVelocity = true;
							targetRay.linearVelocity.copy(inputPose.linearVelocity);
						} else {
							targetRay.hasLinearVelocity = false;
						}

						if (inputPose.angularVelocity) {
							targetRay.hasAngularVelocity = true;
							targetRay.angularVelocity.copy(inputPose.angularVelocity);
						} else {
							targetRay.hasAngularVelocity = false;
						}

						this.dispatchEvent(_moveEvent);
					}
				}

				if (hand && inputSource.hand) {
					handPose = true;

					for (const inputjoint of inputSource.hand.values()) {
						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose(inputjoint, referenceSpace);

						if (hand.joints[inputjoint.jointName] === undefined) {
							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[inputjoint.jointName] = joint; // ??

							hand.add(joint);
						}

						const joint = hand.joints[inputjoint.jointName];

						if (jointPose !== null) {
							joint.matrix.fromArray(jointPose.transform.matrix);
							joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
							joint.jointRadius = jointPose.radius;
						}

						joint.visible = jointPose !== null;
					} // Custom events
					// Check pinchz


					const indexTip = hand.joints['index-finger-tip'];
					const thumbTip = hand.joints['thumb-tip'];
					const distance = indexTip.position.distanceTo(thumbTip.position);
					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
						hand.inputState.pinching = false;
						this.dispatchEvent({
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						});
					} else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
						hand.inputState.pinching = true;
						this.dispatchEvent({
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						});
					}
				} else {
					if (grip !== null && inputSource.gripSpace) {
						gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);

						if (gripPose !== null) {
							grip.matrix.fromArray(gripPose.transform.matrix);
							grip.matrix.decompose(grip.position, grip.rotation, grip.scale);

							if (gripPose.linearVelocity) {
								grip.hasLinearVelocity = true;
								grip.linearVelocity.copy(gripPose.linearVelocity);
							} else {
								grip.hasLinearVelocity = false;
							}

							if (gripPose.angularVelocity) {
								grip.hasAngularVelocity = true;
								grip.angularVelocity.copy(gripPose.angularVelocity);
							} else {
								grip.hasAngularVelocity = false;
							}
						}
					}
				}
			}

			if (targetRay !== null) {
				targetRay.visible = inputPose !== null;
			}

			if (grip !== null) {
				grip.visible = gripPose !== null;
			}

			if (hand !== null) {
				hand.visible = handPose !== null;
			}

			return this;
		}

	}

	class WebXRManager extends EventDispatcher {
		constructor(renderer, gl) {
			super();
			const scope = this;
			const state = renderer.state;
			let session = null;
			let framebufferScaleFactor = 1.0;
			let referenceSpace = null;
			let referenceSpaceType = 'local-floor';
			let pose = null;
			let glBinding = null;
			let glFramebuffer = null;
			let glProjLayer = null;
			let glBaseLayer = null;
			const controllers = [];
			const inputSourcesMap = new Map(); //

			const cameraL = new PerspectiveCamera();
			cameraL.layers.enable(1);
			cameraL.viewport = new Vector4();
			const cameraR = new PerspectiveCamera();
			cameraR.layers.enable(2);
			cameraR.viewport = new Vector4();
			const cameras = [cameraL, cameraR];
			const cameraVR = new ArrayCamera();
			cameraVR.layers.enable(1);
			cameraVR.layers.enable(2);
			let _currentDepthNear = null;
			let _currentDepthFar = null; //

			this.cameraAutoUpdate = true;
			this.enabled = false;
			this.isPresenting = false;

			this.getController = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getTargetRaySpace();
			};

			this.getControllerGrip = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getGripSpace();
			};

			this.getHand = function (index) {
				let controller = controllers[index];

				if (controller === undefined) {
					controller = new WebXRController();
					controllers[index] = controller;
				}

				return controller.getHandSpace();
			}; //


			function onSessionEvent(event) {
				const controller = inputSourcesMap.get(event.inputSource);

				if (controller) {
					controller.dispatchEvent({
						type: event.type,
						data: event.inputSource
					});
				}
			}

			function onSessionEnd() {
				inputSourcesMap.forEach(function (controller, inputSource) {
					controller.disconnect(inputSource);
				});
				inputSourcesMap.clear();
				_currentDepthNear = null;
				_currentDepthFar = null; // restore framebuffer/rendering state

				state.bindXRFramebuffer(null);
				renderer.setRenderTarget(renderer.getRenderTarget()); //

				animation.stop();
				scope.isPresenting = false;
				scope.dispatchEvent({
					type: 'sessionend'
				});
			}

			this.setFramebufferScaleFactor = function (value) {
				framebufferScaleFactor = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.');
				}
			};

			this.setReferenceSpaceType = function (value) {
				referenceSpaceType = value;

				if (scope.isPresenting === true) {
					console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.');
				}
			};

			this.getReferenceSpace = function () {
				return referenceSpace;
			};

			this.getSession = function () {
				return session;
			};

			this.setSession = async function (value) {
				session = value;

				if (session !== null) {
					session.addEventListener('select', onSessionEvent);
					session.addEventListener('selectstart', onSessionEvent);
					session.addEventListener('selectend', onSessionEvent);
					session.addEventListener('squeeze', onSessionEvent);
					session.addEventListener('squeezestart', onSessionEvent);
					session.addEventListener('squeezeend', onSessionEvent);
					session.addEventListener('end', onSessionEnd);
					session.addEventListener('inputsourceschange', onInputSourcesChange);
					const attributes = gl.getContextAttributes();

					if (attributes.xrCompatible !== true) {
						await gl.makeXRCompatible();
					}

					if (session.renderState.layers === undefined) {
						const layerInit = {
							antialias: attributes.antialias,
							alpha: attributes.alpha,
							depth: attributes.depth,
							stencil: attributes.stencil,
							framebufferScaleFactor: framebufferScaleFactor
						};
						glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
						session.updateRenderState({
							baseLayer: glBaseLayer
						});
					} else {
						let depthFormat = 0; // for anti-aliased output, use classic webgllayer for now

						if (attributes.antialias) {
							const layerInit = {
								antialias: true,
								alpha: attributes.alpha,
								depth: attributes.depth,
								stencil: attributes.stencil,
								framebufferScaleFactor: framebufferScaleFactor
							};
							glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
							session.updateRenderState({
								layers: [glBaseLayer]
							});
						} else {
							if (attributes.depth) {
								depthFormat = attributes.stencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
							}

							const projectionlayerInit = {
								colorFormat: attributes.alpha ? gl.RGBA : gl.RGB,
								depthFormat: depthFormat,
								scaleFactor: framebufferScaleFactor
							};
							glBinding = new XRWebGLBinding(session, gl);
							glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
							glFramebuffer = gl.createFramebuffer();
							session.updateRenderState({
								layers: [glProjLayer]
							});
						}
					}

					referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
					animation.setContext(session);
					animation.start();
					scope.isPresenting = true;
					scope.dispatchEvent({
						type: 'sessionstart'
					});
				}
			};

			function onInputSourcesChange(event) {
				const inputSources = session.inputSources; // Assign inputSources to available controllers

				for (let i = 0; i < controllers.length; i++) {
					inputSourcesMap.set(inputSources[i], controllers[i]);
				} // Notify disconnected


				for (let i = 0; i < event.removed.length; i++) {
					const inputSource = event.removed[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'disconnected',
							data: inputSource
						});
						inputSourcesMap.delete(inputSource);
					}
				} // Notify connected


				for (let i = 0; i < event.added.length; i++) {
					const inputSource = event.added[i];
					const controller = inputSourcesMap.get(inputSource);

					if (controller) {
						controller.dispatchEvent({
							type: 'connected',
							data: inputSource
						});
					}
				}
			} //


			const cameraLPos = new Vector3();
			const cameraRPos = new Vector3();
			/**
			 * Assumes 2 cameras that are parallel and share an X-axis, and that
			 * the cameras' projection and world matrices have already been set.
			 * And that near and far planes are identical for both cameras.
			 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
			 */

			function setProjectionFromUnion(camera, cameraL, cameraR) {
				cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
				cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
				const ipd = cameraLPos.distanceTo(cameraRPos);
				const projL = cameraL.projectionMatrix.elements;
				const projR = cameraR.projectionMatrix.elements; // VR systems will have identical far and near planes, and
				// most likely identical top and bottom frustum extents.
				// Use the left camera for these values.

				const near = projL[14] / (projL[10] - 1);
				const far = projL[14] / (projL[10] + 1);
				const topFov = (projL[9] + 1) / projL[5];
				const bottomFov = (projL[9] - 1) / projL[5];
				const leftFov = (projL[8] - 1) / projL[0];
				const rightFov = (projR[8] + 1) / projR[0];
				const left = near * leftFov;
				const right = near * rightFov; // Calculate the new camera's position offset from the
				// left camera. xOffset should be roughly half `ipd`.

				const zOffset = ipd / (-leftFov + rightFov);
				const xOffset = zOffset * -leftFov; // TODO: Better way to apply this offset?

				cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
				camera.translateX(xOffset);
				camera.translateZ(zOffset);
				camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
				camera.matrixWorldInverse.copy(camera.matrixWorld).invert(); // Find the union of the frustum values of the cameras and scale
				// the values so that the near plane's position does not change in world space,
				// although must now be relative to the new union camera.

				const near2 = near + zOffset;
				const far2 = far + zOffset;
				const left2 = left - xOffset;
				const right2 = right + (ipd - xOffset);
				const top2 = topFov * far / far2 * near2;
				const bottom2 = bottomFov * far / far2 * near2;
				camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
			}

			function updateCamera(camera, parent) {
				if (parent === null) {
					camera.matrixWorld.copy(camera.matrix);
				} else {
					camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
				}

				camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
			}

			this.updateCamera = function (camera) {
				if (session === null) return;
				cameraVR.near = cameraR.near = cameraL.near = camera.near;
				cameraVR.far = cameraR.far = cameraL.far = camera.far;

				if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
					// Note that the new renderState won't apply until the next frame. See #18320
					session.updateRenderState({
						depthNear: cameraVR.near,
						depthFar: cameraVR.far
					});
					_currentDepthNear = cameraVR.near;
					_currentDepthFar = cameraVR.far;
				}

				const parent = camera.parent;
				const cameras = cameraVR.cameras;
				updateCamera(cameraVR, parent);

				for (let i = 0; i < cameras.length; i++) {
					updateCamera(cameras[i], parent);
				}

				cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale); // update user camera and its children

				camera.position.copy(cameraVR.position);
				camera.quaternion.copy(cameraVR.quaternion);
				camera.scale.copy(cameraVR.scale);
				camera.matrix.copy(cameraVR.matrix);
				camera.matrixWorld.copy(cameraVR.matrixWorld);
				const children = camera.children;

				for (let i = 0, l = children.length; i < l; i++) {
					children[i].updateMatrixWorld(true);
				} // update projection matrix for proper view frustum culling


				if (cameras.length === 2) {
					setProjectionFromUnion(cameraVR, cameraL, cameraR);
				} else {
					// assume single camera setup (AR)
					cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
				}
			};

			this.getCamera = function () {
				return cameraVR;
			};

			this.getFoveation = function () {
				if (glProjLayer !== null) {
					return glProjLayer.fixedFoveation;
				}

				if (glBaseLayer !== null) {
					return glBaseLayer.fixedFoveation;
				}

				return undefined;
			};

			this.setFoveation = function (foveation) {
				// 0 = no foveation = full resolution
				// 1 = maximum foveation = the edges render at lower resolution
				if (glProjLayer !== null) {
					glProjLayer.fixedFoveation = foveation;
				}

				if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
					glBaseLayer.fixedFoveation = foveation;
				}
			}; // Animation Loop


			let onAnimationFrameCallback = null;

			function onAnimationFrame(time, frame) {
				pose = frame.getViewerPose(referenceSpace);

				if (pose !== null) {
					const views = pose.views;

					if (glBaseLayer !== null) {
						state.bindXRFramebuffer(glBaseLayer.framebuffer);
					}

					let cameraVRNeedsUpdate = false; // check if it's necessary to rebuild cameraVR's camera list

					if (views.length !== cameraVR.cameras.length) {
						cameraVR.cameras.length = 0;
						cameraVRNeedsUpdate = true;
					}

					for (let i = 0; i < views.length; i++) {
						const view = views[i];
						let viewport = null;

						if (glBaseLayer !== null) {
							viewport = glBaseLayer.getViewport(view);
						} else {
							const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
							state.bindXRFramebuffer(glFramebuffer);

							if (glSubImage.depthStencilTexture !== undefined) {
								gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, glSubImage.depthStencilTexture, 0);
							}

							gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, glSubImage.colorTexture, 0);
							viewport = glSubImage.viewport;
						}

						const camera = cameras[i];
						camera.matrix.fromArray(view.transform.matrix);
						camera.projectionMatrix.fromArray(view.projectionMatrix);
						camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);

						if (i === 0) {
							cameraVR.matrix.copy(camera.matrix);
						}

						if (cameraVRNeedsUpdate === true) {
							cameraVR.cameras.push(camera);
						}
					}
				} //


				const inputSources = session.inputSources;

				for (let i = 0; i < controllers.length; i++) {
					const controller = controllers[i];
					const inputSource = inputSources[i];
					controller.update(inputSource, frame, referenceSpace);
				}

				if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
			}

			const animation = new WebGLAnimation();
			animation.setAnimationLoop(onAnimationFrame);

			this.setAnimationLoop = function (callback) {
				onAnimationFrameCallback = callback;
			};

			this.dispose = function () {};
		}

	}

	function WebGLMaterials(properties) {
		function refreshFogUniforms(uniforms, fog) {
			uniforms.fogColor.value.copy(fog.color);

			if (fog.isFog) {
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
			} else if (fog.isFogExp2) {
				uniforms.fogDensity.value = fog.density;
			}
		}

		function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
			if (material.isMeshBasicMaterial) {
				refreshUniformsCommon(uniforms, material);
			} else if (material.isMeshLambertMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsLambert(uniforms, material);
			} else if (material.isMeshToonMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsToon(uniforms, material);
			} else if (material.isMeshPhongMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsPhong(uniforms, material);
			} else if (material.isMeshStandardMaterial) {
				refreshUniformsCommon(uniforms, material);

				if (material.isMeshPhysicalMaterial) {
					refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
				} else {
					refreshUniformsStandard(uniforms, material);
				}
			} else if (material.isMeshMatcapMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsMatcap(uniforms, material);
			} else if (material.isMeshDepthMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDepth(uniforms, material);
			} else if (material.isMeshDistanceMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsDistance(uniforms, material);
			} else if (material.isMeshNormalMaterial) {
				refreshUniformsCommon(uniforms, material);
				refreshUniformsNormal(uniforms, material);
			} else if (material.isLineBasicMaterial) {
				refreshUniformsLine(uniforms, material);

				if (material.isLineDashedMaterial) {
					refreshUniformsDash(uniforms, material);
				}
			} else if (material.isPointsMaterial) {
				refreshUniformsPoints(uniforms, material, pixelRatio, height);
			} else if (material.isSpriteMaterial) {
				refreshUniformsSprites(uniforms, material);
			} else if (material.isShadowMaterial) {
				uniforms.color.value.copy(material.color);
				uniforms.opacity.value = material.opacity;
			} else if (material.isShaderMaterial) {
				material.uniformsNeedUpdate = false; // #15581
			}
		}

		function refreshUniformsCommon(uniforms, material) {
			uniforms.opacity.value = material.opacity;

			if (material.color) {
				uniforms.diffuse.value.copy(material.color);
			}

			if (material.emissive) {
				uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
			}

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			}

			if (material.specularMap) {
				uniforms.specularMap.value = material.specularMap;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				uniforms.envMap.value = envMap;
				uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				const maxMipLevel = properties.get(envMap).__maxMipLevel;

				if (maxMipLevel !== undefined) {
					uniforms.maxMipLevel.value = maxMipLevel;
				}
			}

			if (material.lightMap) {
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
			}

			if (material.aoMap) {
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map
			// 13. specular intensity map
			// 14. specular tint map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.specularMap) {
				uvScaleMap = material.specularMap;
			} else if (material.displacementMap) {
				uvScaleMap = material.displacementMap;
			} else if (material.normalMap) {
				uvScaleMap = material.normalMap;
			} else if (material.bumpMap) {
				uvScaleMap = material.bumpMap;
			} else if (material.roughnessMap) {
				uvScaleMap = material.roughnessMap;
			} else if (material.metalnessMap) {
				uvScaleMap = material.metalnessMap;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			} else if (material.emissiveMap) {
				uvScaleMap = material.emissiveMap;
			} else if (material.clearcoatMap) {
				uvScaleMap = material.clearcoatMap;
			} else if (material.clearcoatNormalMap) {
				uvScaleMap = material.clearcoatNormalMap;
			} else if (material.clearcoatRoughnessMap) {
				uvScaleMap = material.clearcoatRoughnessMap;
			} else if (material.specularIntensityMap) {
				uvScaleMap = material.specularIntensityMap;
			} else if (material.specularTintMap) {
				uvScaleMap = material.specularTintMap;
			}

			if (uvScaleMap !== undefined) {
				// backwards compatibility
				if (uvScaleMap.isWebGLRenderTarget) {
					uvScaleMap = uvScaleMap.texture;
				}

				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			} // uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map


			let uv2ScaleMap;

			if (material.aoMap) {
				uv2ScaleMap = material.aoMap;
			} else if (material.lightMap) {
				uv2ScaleMap = material.lightMap;
			}

			if (uv2ScaleMap !== undefined) {
				// backwards compatibility
				if (uv2ScaleMap.isWebGLRenderTarget) {
					uv2ScaleMap = uv2ScaleMap.texture;
				}

				if (uv2ScaleMap.matrixAutoUpdate === true) {
					uv2ScaleMap.updateMatrix();
				}

				uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
			}
		}

		function refreshUniformsLine(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
		}

		function refreshUniformsDash(uniforms, material) {
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
		}

		function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsSprites(uniforms, material) {
			uniforms.diffuse.value.copy(material.color);
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if (material.map) {
				uniforms.map.value = material.map;
			}

			if (material.alphaMap) {
				uniforms.alphaMap.value = material.alphaMap;
			} // uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map


			let uvScaleMap;

			if (material.map) {
				uvScaleMap = material.map;
			} else if (material.alphaMap) {
				uvScaleMap = material.alphaMap;
			}

			if (uvScaleMap !== undefined) {
				if (uvScaleMap.matrixAutoUpdate === true) {
					uvScaleMap.updateMatrix();
				}

				uniforms.uvTransform.value.copy(uvScaleMap.matrix);
			}
		}

		function refreshUniformsLambert(uniforms, material) {
			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}
		}

		function refreshUniformsPhong(uniforms, material) {
			uniforms.specular.value.copy(material.specular);
			uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsToon(uniforms, material) {
			if (material.gradientMap) {
				uniforms.gradientMap.value = material.gradientMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsStandard(uniforms, material) {
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if (material.roughnessMap) {
				uniforms.roughnessMap.value = material.roughnessMap;
			}

			if (material.metalnessMap) {
				uniforms.metalnessMap.value = material.metalnessMap;
			}

			if (material.emissiveMap) {
				uniforms.emissiveMap.value = material.emissiveMap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			const envMap = properties.get(material).envMap;

			if (envMap) {
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
			}
		}

		function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
			refreshUniformsStandard(uniforms, material);
			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if (material.sheen) uniforms.sheen.value.copy(material.sheen);

			if (material.clearcoatMap) {
				uniforms.clearcoatMap.value = material.clearcoatMap;
			}

			if (material.clearcoatRoughnessMap) {
				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
			}

			if (material.clearcoatNormalMap) {
				uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if (material.side === BackSide) {
					uniforms.clearcoatNormalScale.value.negate();
				}
			}

			uniforms.transmission.value = material.transmission;

			if (material.transmissionMap) {
				uniforms.transmissionMap.value = material.transmissionMap;
			}

			if (material.transmission > 0.0) {
				uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
				uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
			}

			uniforms.thickness.value = material.thickness;

			if (material.thicknessMap) {
				uniforms.thicknessMap.value = material.thicknessMap;
			}

			uniforms.attenuationDistance.value = material.attenuationDistance;
			uniforms.attenuationTint.value.copy(material.attenuationTint);
			uniforms.specularIntensity.value = material.specularIntensity;
			uniforms.specularTint.value.copy(material.specularTint);

			if (material.specularIntensityMap) {
				uniforms.specularIntensityMap.value = material.specularIntensityMap;
			}

			if (material.specularTintMap) {
				uniforms.specularTintMap.value = material.specularTintMap;
			}
		}

		function refreshUniformsMatcap(uniforms, material) {
			if (material.matcap) {
				uniforms.matcap.value = material.matcap;
			}

			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDepth(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		function refreshUniformsDistance(uniforms, material) {
			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}

			uniforms.referencePosition.value.copy(material.referencePosition);
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
		}

		function refreshUniformsNormal(uniforms, material) {
			if (material.bumpMap) {
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if (material.side === BackSide) uniforms.bumpScale.value *= -1;
			}

			if (material.normalMap) {
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy(material.normalScale);
				if (material.side === BackSide) uniforms.normalScale.value.negate();
			}

			if (material.displacementMap) {
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
			}
		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};
	}

	function createCanvasElement() {
		const canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
		canvas.style.display = 'block';
		return canvas;
	}

	function WebGLRenderer(parameters = {}) {
		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
					_context = parameters.context !== undefined ? parameters.context : null,
					_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
					_depth = parameters.depth !== undefined ? parameters.depth : true,
					_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
					_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
					_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
					_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
					_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
					_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let currentRenderList = null;
		let currentRenderState = null; // render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = []; // public properties

		this.domElement = _canvas; // Debug configuration container

		this.debug = {
			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		}; // clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true; // scene graph

		this.sortObjects = true; // user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false; // physically based shading

		this.gammaFactor = 2.0; // for backwards compatibility

		this.outputEncoding = LinearEncoding; // physical lights

		this.physicallyCorrectLights = false; // tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0; // internal properties

		const _this = this;

		let _isContextLost = false; // internal state cache

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;

		let _currentMaterialId = -1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();

		const _currentScissor = new Vector4();

		let _currentScissorTest = null; //

		let _width = _canvas.width;
		let _height = _canvas.height;
		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4(0, 0, _width, _height);

		const _scissor = new Vector4(0, 0, _width, _height);

		let _scissorTest = false; //

		const _currentDrawBuffers = []; // frustum

		const _frustum = new Frustum(); // clipping


		let _clippingEnabled = false;
		let _localClippingEnabled = false; // transmission

		let _transmissionRenderTarget = null; // camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = {
			background: null,
			fog: null,
			environment: null,
			overrideMaterial: null,
			isScene: true
		};

		function getTargetPixelRatio() {
			return _currentRenderTarget === null ? _pixelRatio : 1;
		} // initialize


		let _gl = _context;

		function getContext(contextNames, contextAttributes) {
			for (let i = 0; i < contextNames.length; i++) {
				const contextName = contextNames[i];

				const context = _canvas.getContext(contextName, contextAttributes);

				if (context !== null) return context;
			}

			return null;
		}

		try {
			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			}; // event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener('webglcontextlost', onContextLost, false);

			_canvas.addEventListener('webglcontextrestored', onContextRestore, false);

			if (_gl === null) {
				const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

				if (_this.isWebGL1Renderer === true) {
					contextNames.shift();
				}

				_gl = getContext(contextNames, contextAttributes);

				if (_gl === null) {
					if (getContext(contextNames)) {
						throw new Error('Error creating WebGL context with your selected attributes.');
					} else {
						throw new Error('Error creating WebGL context.');
					}
				}
			} // Some experimental-webgl implementations do not have getShaderPrecisionFormat


			if (_gl.getShaderPrecisionFormat === undefined) {
				_gl.getShaderPrecisionFormat = function () {
					return {
						'rangeMin': 1,
						'rangeMax': 1,
						'precision': 1
					};
				};
			}
		} catch (error) {
			console.error('THREE.WebGLRenderer: ' + error.message);
			throw error;
		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping, shadowMap;
		let background, morphtargets, bufferRenderer, indexedBufferRenderer;
		let utils, bindingStates;

		function initGLContext() {
			extensions = new WebGLExtensions(_gl);
			capabilities = new WebGLCapabilities(_gl, extensions, parameters);
			extensions.init(capabilities);
			utils = new WebGLUtils(_gl, extensions, capabilities);
			state = new WebGLState(_gl, extensions, capabilities);
			_currentDrawBuffers[0] = _gl.BACK;
			info = new WebGLInfo(_gl);
			properties = new WebGLProperties();
			textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
			cubemaps = new WebGLCubeMaps(_this);
			cubeuvmaps = new WebGLCubeUVMaps(_this);
			attributes = new WebGLAttributes(_gl, capabilities);
			bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
			geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
			objects = new WebGLObjects(_gl, geometries, attributes, info);
			morphtargets = new WebGLMorphtargets(_gl);
			clipping = new WebGLClipping(properties);
			programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
			materials = new WebGLMaterials(properties);
			renderLists = new WebGLRenderLists(properties);
			renderStates = new WebGLRenderStates(extensions, capabilities);
			background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);
			shadowMap = new WebGLShadowMap(_this, objects, capabilities);
			bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
			indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
			info.programs = programCache.programs;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.shadowMap = shadowMap;
			_this.state = state;
			_this.info = info;
		}

		initGLContext(); // xr

		const xr = new WebXRManager(_this, _gl);
		this.xr = xr; // API

		this.getContext = function () {
			return _gl;
		};

		this.getContextAttributes = function () {
			return _gl.getContextAttributes();
		};

		this.forceContextLoss = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.loseContext();
		};

		this.forceContextRestore = function () {
			const extension = extensions.get('WEBGL_lose_context');
			if (extension) extension.restoreContext();
		};

		this.getPixelRatio = function () {
			return _pixelRatio;
		};

		this.setPixelRatio = function (value) {
			if (value === undefined) return;
			_pixelRatio = value;
			this.setSize(_width, _height, false);
		};

		this.getSize = function (target) {
			return target.set(_width, _height);
		};

		this.setSize = function (width, height, updateStyle) {
			if (xr.isPresenting) {
				console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
				return;
			}

			_width = width;
			_height = height;
			_canvas.width = Math.floor(width * _pixelRatio);
			_canvas.height = Math.floor(height * _pixelRatio);

			if (updateStyle !== false) {
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
			}

			this.setViewport(0, 0, width, height);
		};

		this.getDrawingBufferSize = function (target) {
			return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
		};

		this.setDrawingBufferSize = function (width, height, pixelRatio) {
			_width = width;
			_height = height;
			_pixelRatio = pixelRatio;
			_canvas.width = Math.floor(width * pixelRatio);
			_canvas.height = Math.floor(height * pixelRatio);
			this.setViewport(0, 0, width, height);
		};

		this.getCurrentViewport = function (target) {
			return target.copy(_currentViewport);
		};

		this.getViewport = function (target) {
			return target.copy(_viewport);
		};

		this.setViewport = function (x, y, width, height) {
			if (x.isVector4) {
				_viewport.set(x.x, x.y, x.z, x.w);
			} else {
				_viewport.set(x, y, width, height);
			}

			state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissor = function (target) {
			return target.copy(_scissor);
		};

		this.setScissor = function (x, y, width, height) {
			if (x.isVector4) {
				_scissor.set(x.x, x.y, x.z, x.w);
			} else {
				_scissor.set(x, y, width, height);
			}

			state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
		};

		this.getScissorTest = function () {
			return _scissorTest;
		};

		this.setScissorTest = function (boolean) {
			state.setScissorTest(_scissorTest = boolean);
		};

		this.setOpaqueSort = function (method) {
			_opaqueSort = method;
		};

		this.setTransparentSort = function (method) {
			_transparentSort = method;
		}; // Clearing


		this.getClearColor = function (target) {
			return target.copy(background.getClearColor());
		};

		this.setClearColor = function () {
			background.setClearColor.apply(background, arguments);
		};

		this.getClearAlpha = function () {
			return background.getClearAlpha();
		};

		this.setClearAlpha = function () {
			background.setClearAlpha.apply(background, arguments);
		};

		this.clear = function (color, depth, stencil) {
			let bits = 0;
			if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
			if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
			if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear(bits);
		};

		this.clearColor = function () {
			this.clear(true, false, false);
		};

		this.clearDepth = function () {
			this.clear(false, true, false);
		};

		this.clearStencil = function () {
			this.clear(false, false, true);
		}; //


		this.dispose = function () {
			_canvas.removeEventListener('webglcontextlost', onContextLost, false);

			_canvas.removeEventListener('webglcontextrestored', onContextRestore, false);

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			cubeuvmaps.dispose();
			objects.dispose();
			bindingStates.dispose();
			xr.dispose();
			xr.removeEventListener('sessionstart', onXRSessionStart);
			xr.removeEventListener('sessionend', onXRSessionEnd);

			if (_transmissionRenderTarget) {
				_transmissionRenderTarget.dispose();

				_transmissionRenderTarget = null;
			}

			animation.stop();
		}; // Events


		function onContextLost(event) {
			event.preventDefault();
			console.log('THREE.WebGLRenderer: Context Lost.');
			_isContextLost = true;
		}

		function onContextRestore()
		/* event */
		{
			console.log('THREE.WebGLRenderer: Context Restored.');
			_isContextLost = false;
			const infoAutoReset = info.autoReset;
			const shadowMapEnabled = shadowMap.enabled;
			const shadowMapAutoUpdate = shadowMap.autoUpdate;
			const shadowMapNeedsUpdate = shadowMap.needsUpdate;
			const shadowMapType = shadowMap.type;
			initGLContext();
			info.autoReset = infoAutoReset;
			shadowMap.enabled = shadowMapEnabled;
			shadowMap.autoUpdate = shadowMapAutoUpdate;
			shadowMap.needsUpdate = shadowMapNeedsUpdate;
			shadowMap.type = shadowMapType;
		}

		function onMaterialDispose(event) {
			const material = event.target;
			material.removeEventListener('dispose', onMaterialDispose);
			deallocateMaterial(material);
		} // Buffer deallocation


		function deallocateMaterial(material) {
			releaseMaterialProgramReferences(material);
			properties.remove(material);
		}

		function releaseMaterialProgramReferences(material) {
			const programs = properties.get(material).programs;

			if (programs !== undefined) {
				programs.forEach(function (program) {
					programCache.releaseProgram(program);
				});
			}
		} // Buffer rendering


		function renderObjectImmediate(object, program) {
			object.render(function (object) {
				_this.renderBufferImmediate(object, program);
			});
		}

		this.renderBufferImmediate = function (object, program) {
			bindingStates.initAttributes();
			const buffers = properties.get(object);
			if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
			if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
			if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
			if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
			const programAttributes = program.getAttributes();

			if (object.hasPositions) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.position);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.position);

				_gl.vertexAttribPointer(programAttributes.position, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasNormals) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.normal);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.normal);

				_gl.vertexAttribPointer(programAttributes.normal, 3, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasUvs) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.uv);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.uv);

				_gl.vertexAttribPointer(programAttributes.uv, 2, _gl.FLOAT, false, 0, 0);
			}

			if (object.hasColors) {
				_gl.bindBuffer(_gl.ARRAY_BUFFER, buffers.color);

				_gl.bufferData(_gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW);

				bindingStates.enableAttribute(programAttributes.color);

				_gl.vertexAttribPointer(programAttributes.color, 3, _gl.FLOAT, false, 0, 0);
			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays(_gl.TRIANGLES, 0, object.count);

			object.count = 0;
		};

		this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
			if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
			const program = setProgram(camera, scene, material, object);
			state.setMaterial(material, frontFaceCW); //

			let index = geometry.index;
			const position = geometry.attributes.position; //

			if (index === null) {
				if (position === undefined || position.count === 0) return;
			} else if (index.count === 0) {
				return;
			} //


			let rangeFactor = 1;

			if (material.wireframe === true) {
				index = geometries.getWireframeAttribute(geometry);
				rangeFactor = 2;
			}

			if (geometry.morphAttributes.position !== undefined || geometry.morphAttributes.normal !== undefined) {
				morphtargets.update(object, geometry, material, program);
			}

			bindingStates.setup(object, material, program, geometry, index);
			let attribute;
			let renderer = bufferRenderer;

			if (index !== null) {
				attribute = attributes.get(index);
				renderer = indexedBufferRenderer;
				renderer.setIndex(attribute);
			} //


			const dataCount = index !== null ? index.count : position.count;
			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;
			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;
			const drawStart = Math.max(rangeStart, groupStart);
			const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
			const drawCount = Math.max(0, drawEnd - drawStart + 1);
			if (drawCount === 0) return; //

			if (object.isMesh) {
				if (material.wireframe === true) {
					state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
					renderer.setMode(_gl.LINES);
				} else {
					renderer.setMode(_gl.TRIANGLES);
				}
			} else if (object.isLine) {
				let lineWidth = material.linewidth;
				if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

				state.setLineWidth(lineWidth * getTargetPixelRatio());

				if (object.isLineSegments) {
					renderer.setMode(_gl.LINES);
				} else if (object.isLineLoop) {
					renderer.setMode(_gl.LINE_LOOP);
				} else {
					renderer.setMode(_gl.LINE_STRIP);
				}
			} else if (object.isPoints) {
				renderer.setMode(_gl.POINTS);
			} else if (object.isSprite) {
				renderer.setMode(_gl.TRIANGLES);
			}

			if (object.isInstancedMesh) {
				renderer.renderInstances(drawStart, drawCount, object.count);
			} else if (geometry.isInstancedBufferGeometry) {
				const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
				renderer.renderInstances(drawStart, drawCount, instanceCount);
			} else {
				renderer.render(drawStart, drawCount);
			}
		}; // Compile


		this.compile = function (scene, camera) {
			currentRenderState = renderStates.get(scene);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);
			scene.traverseVisible(function (object) {
				if (object.isLight && object.layers.test(camera.layers)) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				}
			});
			currentRenderState.setupLights();
			scene.traverse(function (object) {
				const material = object.material;

				if (material) {
					if (Array.isArray(material)) {
						for (let i = 0; i < material.length; i++) {
							const material2 = material[i];
							getProgram(material2, scene, object);
						}
					} else {
						getProgram(material, scene, object);
					}
				}
			});
			renderStateStack.pop();
			currentRenderState = null;
		}; // Animation Loop


		let onAnimationFrameCallback = null;

		function onAnimationFrame(time) {
			if (onAnimationFrameCallback) onAnimationFrameCallback(time);
		}

		function onXRSessionStart() {
			animation.stop();
		}

		function onXRSessionEnd() {
			animation.start();
		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop(onAnimationFrame);
		if (typeof window !== 'undefined') animation.setContext(window);

		this.setAnimationLoop = function (callback) {
			onAnimationFrameCallback = callback;
			xr.setAnimationLoop(callback);
			callback === null ? animation.stop() : animation.start();
		};

		xr.addEventListener('sessionstart', onXRSessionStart);
		xr.addEventListener('sessionend', onXRSessionEnd); // Rendering

		this.render = function (scene, camera) {
			if (camera !== undefined && camera.isCamera !== true) {
				console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
				return;
			}

			if (_isContextLost === true) return; // update scene graph

			if (scene.autoUpdate === true) scene.updateMatrixWorld(); // update camera matrices and frustum

			if (camera.parent === null) camera.updateMatrixWorld();

			if (xr.enabled === true && xr.isPresenting === true) {
				if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
				camera = xr.getCamera(); // use XR camera for rendering
			} //


			if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
			currentRenderState = renderStates.get(scene, renderStateStack.length);
			currentRenderState.init();
			renderStateStack.push(currentRenderState);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			_frustum.setFromProjectionMatrix(_projScreenMatrix);

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
			currentRenderList = renderLists.get(scene, renderListStack.length);
			currentRenderList.init();
			renderListStack.push(currentRenderList);
			projectObject(scene, camera, 0, _this.sortObjects);
			currentRenderList.finish();

			if (_this.sortObjects === true) {
				currentRenderList.sort(_opaqueSort, _transparentSort);
			} //


			if (_clippingEnabled === true) clipping.beginShadows();
			const shadowsArray = currentRenderState.state.shadowsArray;
			shadowMap.render(shadowsArray, scene, camera);
			currentRenderState.setupLights();
			currentRenderState.setupLightsView(camera);
			if (_clippingEnabled === true) clipping.endShadows(); //

			if (this.info.autoReset === true) this.info.reset(); //

			background.render(currentRenderList, scene); // render scene

			const opaqueObjects = currentRenderList.opaque;
			const transmissiveObjects = currentRenderList.transmissive;
			const transparentObjects = currentRenderList.transparent;
			if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
			if (transmissiveObjects.length > 0) renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera);
			if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera); //

			if (_currentRenderTarget !== null) {
				// resolve multisample renderbuffers to a single-sample texture if necessary
				textures.updateMultisampleRenderTarget(_currentRenderTarget); // Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap(_currentRenderTarget);
			} //


			if (scene.isScene === true) scene.onAfterRender(_this, scene, camera); // Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest(true);
			state.buffers.depth.setMask(true);
			state.buffers.color.setMask(true);
			state.setPolygonOffset(false); // _gl.finish();

			bindingStates.resetDefaultState();
			_currentMaterialId = -1;
			_currentCamera = null;
			renderStateStack.pop();

			if (renderStateStack.length > 0) {
				currentRenderState = renderStateStack[renderStateStack.length - 1];
			} else {
				currentRenderState = null;
			}

			renderListStack.pop();

			if (renderListStack.length > 0) {
				currentRenderList = renderListStack[renderListStack.length - 1];
			} else {
				currentRenderList = null;
			}
		};

		function projectObject(object, camera, groupOrder, sortObjects) {
			if (object.visible === false) return;
			const visible = object.layers.test(camera.layers);

			if (visible) {
				if (object.isGroup) {
					groupOrder = object.renderOrder;
				} else if (object.isLOD) {
					if (object.autoUpdate === true) object.update(camera);
				} else if (object.isLight) {
					currentRenderState.pushLight(object);

					if (object.castShadow) {
						currentRenderState.pushShadow(object);
					}
				} else if (object.isSprite) {
					if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				} else if (object.isImmediateRenderObject) {
					if (sortObjects) {
						_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
					}

					currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
				} else if (object.isMesh || object.isLine || object.isPoints) {
					if (object.isSkinnedMesh) {
						// update skeleton only once in a frame
						if (object.skeleton.frame !== info.render.frame) {
							object.skeleton.update();
							object.skeleton.frame = info.render.frame;
						}
					}

					if (!object.frustumCulled || _frustum.intersectsObject(object)) {
						if (sortObjects) {
							_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
						}

						const geometry = objects.update(object);
						const material = object.material;

						if (Array.isArray(material)) {
							const groups = geometry.groups;

							for (let i = 0, l = groups.length; i < l; i++) {
								const group = groups[i];
								const groupMaterial = material[group.materialIndex];

								if (groupMaterial && groupMaterial.visible) {
									currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
								}
							}
						} else if (material.visible) {
							currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
						}
					}
				}
			}

			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				projectObject(children[i], camera, groupOrder, sortObjects);
			}
		}

		function renderTransmissiveObjects(opaqueObjects, transmissiveObjects, scene, camera) {
			if (_transmissionRenderTarget === null) {
				const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
				const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
				_transmissionRenderTarget = new renderTargetType(1024, 1024, {
					generateMipmaps: true,
					type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
					minFilter: LinearMipmapLinearFilter,
					magFilter: NearestFilter,
					wrapS: ClampToEdgeWrapping,
					wrapT: ClampToEdgeWrapping
				});
			}

			const currentRenderTarget = _this.getRenderTarget();

			_this.setRenderTarget(_transmissionRenderTarget);

			_this.clear(); // Turn off the features which can affect the frag color for opaque objects pass.
			// Otherwise they are applied twice in opaque objects pass and transmission objects pass.


			const currentToneMapping = _this.toneMapping;
			_this.toneMapping = NoToneMapping;
			renderObjects(opaqueObjects, scene, camera);
			_this.toneMapping = currentToneMapping;
			textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
			textures.updateRenderTargetMipmap(_transmissionRenderTarget);

			_this.setRenderTarget(currentRenderTarget);

			renderObjects(transmissiveObjects, scene, camera);
		}

		function renderObjects(renderList, scene, camera) {
			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			if (camera.isArrayCamera) {
				const cameras = camera.cameras;

				for (let i = 0, l = cameras.length; i < l; i++) {
					const camera2 = cameras[i];
					state.viewport(_currentViewport.copy(camera2.viewport));
					currentRenderState.setupLightsView(camera2);

					for (let j = 0, jl = renderList.length; j < jl; j++) {
						const renderItem = renderList[j];
						const object = renderItem.object;
						const geometry = renderItem.geometry;
						const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
						const group = renderItem.group;

						if (object.layers.test(camera2.layers)) {
							renderObject(object, scene, camera2, geometry, material, group);
						}
					}
				}
			} else {
				for (let j = 0, jl = renderList.length; j < jl; j++) {
					const renderItem = renderList[j];
					const object = renderItem.object;
					const geometry = renderItem.geometry;
					const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
					const group = renderItem.group;
					renderObject(object, scene, camera, geometry, material, group);
				}
			}
		}

		function renderObject(object, scene, camera, geometry, material, group) {
			object.onBeforeRender(_this, scene, camera, geometry, material, group);
			object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
			object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

			if (object.isImmediateRenderObject) {
				const program = setProgram(camera, scene, material, object);
				state.setMaterial(material);
				bindingStates.reset();
				renderObjectImmediate(object, program);
			} else {
				if (material.transparent === true && material.side === DoubleSide) {
					material.side = BackSide;
					material.needsUpdate = true;

					_this.renderBufferDirect(camera, scene, geometry, material, object, group);

					material.side = FrontSide;
					material.needsUpdate = true;

					_this.renderBufferDirect(camera, scene, geometry, material, object, group);

					material.side = DoubleSide;
				} else {
					_this.renderBufferDirect(camera, scene, geometry, material, object, group);
				}
			}

			object.onAfterRender(_this, scene, camera, geometry, material, group);
		}

		function getProgram(material, scene, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;
			const lightsStateVersion = lights.state.version;
			const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
			const programCacheKey = programCache.getProgramCacheKey(parameters);
			let programs = materialProperties.programs; // always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);

			if (programs === undefined) {
				// new material
				material.addEventListener('dispose', onMaterialDispose);
				programs = new Map();
				materialProperties.programs = programs;
			}

			let program = programs.get(programCacheKey);

			if (program !== undefined) {
				// early out if program and light state is identical
				if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
					updateCommonMaterialProperties(material, parameters);
					return program;
				}
			} else {
				parameters.uniforms = programCache.getUniforms(material);
				material.onBuild(parameters, _this);
				material.onBeforeCompile(parameters, _this);
				program = programCache.acquireProgram(parameters, programCacheKey);
				programs.set(programCacheKey, program);
				materialProperties.uniforms = parameters.uniforms;
			}

			const uniforms = materialProperties.uniforms;

			if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
				uniforms.clippingPlanes = clipping.uniform;
			}

			updateCommonMaterialProperties(material, parameters); // store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights(material);
			materialProperties.lightsStateVersion = lightsStateVersion;

			if (materialProperties.needsLights) {
				// wire up the material to this renderer's lighting state
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix; // TODO (abelnation): add area lights shadow info to uniforms
			}

			const progUniforms = program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
			materialProperties.currentProgram = program;
			materialProperties.uniformsList = uniformsList;
			return program;
		}

		function updateCommonMaterialProperties(material, parameters) {
			const materialProperties = properties.get(material);
			materialProperties.outputEncoding = parameters.outputEncoding;
			materialProperties.instancing = parameters.instancing;
			materialProperties.skinning = parameters.skinning;
			materialProperties.morphTargets = parameters.morphTargets;
			materialProperties.morphNormals = parameters.morphNormals;
			materialProperties.numClippingPlanes = parameters.numClippingPlanes;
			materialProperties.numIntersection = parameters.numClipIntersection;
			materialProperties.vertexAlphas = parameters.vertexAlphas;
			materialProperties.vertexTangents = parameters.vertexTangents;
		}

		function setProgram(camera, scene, material, object) {
			if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();
			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
			const vertexAlphas = material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;
			const vertexTangents = !!object.geometry && !!object.geometry.attributes.tangent;
			const morphTargets = !!object.geometry && !!object.geometry.morphAttributes.position;
			const morphNormals = !!object.geometry && !!object.geometry.morphAttributes.normal;
			const materialProperties = properties.get(material);
			const lights = currentRenderState.state.lights;

			if (_clippingEnabled === true) {
				if (_localClippingEnabled === true || camera !== _currentCamera) {
					const useCache = camera === _currentCamera && material.id === _currentMaterialId; // we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)

					clipping.setState(material, camera, useCache);
				}
			} //


			let needsProgramChange = false;

			if (material.version === materialProperties.__version) {
				if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
					needsProgramChange = true;
				} else if (materialProperties.outputEncoding !== encoding) {
					needsProgramChange = true;
				} else if (object.isInstancedMesh && materialProperties.instancing === false) {
					needsProgramChange = true;
				} else if (!object.isInstancedMesh && materialProperties.instancing === true) {
					needsProgramChange = true;
				} else if (object.isSkinnedMesh && materialProperties.skinning === false) {
					needsProgramChange = true;
				} else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
					needsProgramChange = true;
				} else if (materialProperties.envMap !== envMap) {
					needsProgramChange = true;
				} else if (material.fog && materialProperties.fog !== fog) {
					needsProgramChange = true;
				} else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
					needsProgramChange = true;
				} else if (materialProperties.vertexAlphas !== vertexAlphas) {
					needsProgramChange = true;
				} else if (materialProperties.vertexTangents !== vertexTangents) {
					needsProgramChange = true;
				} else if (materialProperties.morphTargets !== morphTargets) {
					needsProgramChange = true;
				} else if (materialProperties.morphNormals !== morphNormals) {
					needsProgramChange = true;
				}
			} else {
				needsProgramChange = true;
				materialProperties.__version = material.version;
			} //


			let program = materialProperties.currentProgram;

			if (needsProgramChange === true) {
				program = getProgram(material, scene, object);
			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;
			const p_uniforms = program.getUniforms(),
						m_uniforms = materialProperties.uniforms;

			if (state.useProgram(program.program)) {
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
			}

			if (material.id !== _currentMaterialId) {
				_currentMaterialId = material.id;
				refreshMaterial = true;
			}

			if (refreshProgram || _currentCamera !== camera) {
				p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

				if (capabilities.logarithmicDepthBuffer) {
					p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2));
				}

				if (_currentCamera !== camera) {
					_currentCamera = camera; // lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true; // set to true on material change

					refreshLights = true; // remains set until update done
				} // load material specific uniforms
				// (shader material also gets them for the sake of genericity)


				if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
					const uCamPos = p_uniforms.map.cameraPosition;

					if (uCamPos !== undefined) {
						uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
					}
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
					p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === true);
				}

				if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
					p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
				}
			} // skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures


			if (object.isSkinnedMesh) {
				p_uniforms.setOptional(_gl, object, 'bindMatrix');
				p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
				const skeleton = object.skeleton;

				if (skeleton) {
					if (capabilities.floatVertexTextures) {
						if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
						p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures);
						p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
					} else {
						p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
					}
				}
			}

			if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
			}

			if (refreshMaterial) {
				p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);

				if (materialProperties.needsLights) {
					// the current material requires lighting info
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
					markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
				} // refresh uniforms common to several materials


				if (fog && material.fog) {
					materials.refreshFogUniforms(m_uniforms, fog);
				}

				materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
			}

			if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
				WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
				material.uniformsNeedUpdate = false;
			}

			if (material.isSpriteMaterial) {
				p_uniforms.setValue(_gl, 'center', object.center);
			} // common matrices


			p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
			p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
			p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
			return program;
		} // If uniforms are marked as clean, they don't need to be loaded to the GPU.


		function markUniformsLightsNeedsUpdate(uniforms, value) {
			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;
			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
		}

		function materialNeedsLights(material) {
			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
		}

		this.getActiveCubeFace = function () {
			return _currentActiveCubeFace;
		};

		this.getActiveMipmapLevel = function () {
			return _currentActiveMipmapLevel;
		};

		this.getRenderTarget = function () {
			return _currentRenderTarget;
		};

		this.setRenderTarget = function (renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
				textures.setupRenderTarget(renderTarget);
			}

			let framebuffer = null;
			let isCube = false;
			let isRenderTarget3D = false;

			if (renderTarget) {
				const texture = renderTarget.texture;

				if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
					isRenderTarget3D = true;
				}

				const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;

				if (renderTarget.isWebGLCubeRenderTarget) {
					framebuffer = __webglFramebuffer[activeCubeFace];
					isCube = true;
				} else if (renderTarget.isWebGLMultisampleRenderTarget) {
					framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
				} else {
					framebuffer = __webglFramebuffer;
				}

				_currentViewport.copy(renderTarget.viewport);

				_currentScissor.copy(renderTarget.scissor);

				_currentScissorTest = renderTarget.scissorTest;
			} else {
				_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();

				_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();

				_currentScissorTest = _scissorTest;
			}

			const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

			if (framebufferBound && capabilities.drawBuffers) {
				let needsUpdate = false;

				if (renderTarget) {
					if (renderTarget.isWebGLMultipleRenderTargets) {
						const textures = renderTarget.texture;

						if (_currentDrawBuffers.length !== textures.length || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							for (let i = 0, il = textures.length; i < il; i++) {
								_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;
							}

							_currentDrawBuffers.length = textures.length;
							needsUpdate = true;
						}
					} else {
						if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0) {
							_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
							_currentDrawBuffers.length = 1;
							needsUpdate = true;
						}
					}
				} else {
					if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== _gl.BACK) {
						_currentDrawBuffers[0] = _gl.BACK;
						_currentDrawBuffers.length = 1;
						needsUpdate = true;
					}
				}

				if (needsUpdate) {
					if (capabilities.isWebGL2) {
						_gl.drawBuffers(_currentDrawBuffers);
					} else {
						extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(_currentDrawBuffers);
					}
				}
			}

			state.viewport(_currentViewport);
			state.scissor(_currentScissor);
			state.setScissorTest(_currentScissorTest);

			if (isCube) {
				const textureProperties = properties.get(renderTarget.texture);

				_gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
			} else if (isRenderTarget3D) {
				const textureProperties = properties.get(renderTarget.texture);
				const layer = activeCubeFace || 0;

				_gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
			}
		};

		this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
			if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
				console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
				return;
			}

			let framebuffer = properties.get(renderTarget).__webglFramebuffer;

			if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
				framebuffer = framebuffer[activeCubeFaceIndex];
			}

			if (framebuffer) {
				state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

				try {
					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
						return;
					}

					const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has('EXT_color_buffer_half_float') || capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float'));

					if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
					!(textureType === FloatType && (capabilities.isWebGL2 || extensions.has('OES_texture_float') || extensions.has('WEBGL_color_buffer_float'))) && // Chrome Mac >= 52 and Firefox
					!halfFloatSupportedByExt) {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
						return;
					}

					if (_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) === _gl.FRAMEBUFFER_COMPLETE) {
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
						if (x >= 0 && x <= renderTarget.width - width && y >= 0 && y <= renderTarget.height - height) {
							_gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
						}
					} else {
						console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');
					}
				} finally {
					// restore framebuffer of current render target if necessary
					const framebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
					state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
				}
			}
		};

		this.copyFramebufferToTexture = function (position, texture, level = 0) {
			const levelScale = Math.pow(2, -level);
			const width = Math.floor(texture.image.width * levelScale);
			const height = Math.floor(texture.image.height * levelScale);
			let glFormat = utils.convert(texture.format);

			if (capabilities.isWebGL2) {
				// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
				// Not needed in Chrome 93+
				if (glFormat === _gl.RGB) glFormat = _gl.RGB8;
				if (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;
			}

			textures.setTexture2D(texture, 0);

			_gl.copyTexImage2D(_gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0);

			state.unbindTexture();
		};

		this.copyTextureToTexture = function (position, srcTexture, dstTexture, level = 0) {
			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			textures.setTexture2D(dstTexture, 0); // As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			if (srcTexture.isDataTexture) {
				_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					_gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
				} else {
					_gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
				}
			} // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
			state.unbindTexture();
		};

		this.copyTextureToTexture3D = function (sourceBox, position, srcTexture, dstTexture, level = 0) {
			if (_this.isWebGL1Renderer) {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.');
				return;
			}

			const width = sourceBox.max.x - sourceBox.min.x + 1;
			const height = sourceBox.max.y - sourceBox.min.y + 1;
			const depth = sourceBox.max.z - sourceBox.min.z + 1;
			const glFormat = utils.convert(dstTexture.format);
			const glType = utils.convert(dstTexture.type);
			let glTarget;

			if (dstTexture.isDataTexture3D) {
				textures.setTexture3D(dstTexture, 0);
				glTarget = _gl.TEXTURE_3D;
			} else if (dstTexture.isDataTexture2DArray) {
				textures.setTexture2DArray(dstTexture, 0);
				glTarget = _gl.TEXTURE_2D_ARRAY;
			} else {
				console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
				return;
			}

			_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);

			_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);

			_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

			const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);

			const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);

			const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);

			const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);

			const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);

			const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);

			if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
				_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
			} else {
				if (srcTexture.isCompressedTexture) {
					console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.');

					_gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
				} else {
					_gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
				}
			}

			_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);

			_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);

			_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);

			_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);

			_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages); // Generate mipmaps only when copying level 0


			if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
			state.unbindTexture();
		};

		this.initTexture = function (texture) {
			textures.setTexture2D(texture, 0);
			state.unbindTexture();
		};

		this.resetState = function () {
			_currentActiveCubeFace = 0;
			_currentActiveMipmapLevel = 0;
			_currentRenderTarget = null;
			state.reset();
			bindingStates.reset();
		};

		if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
			__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
				detail: this
			})); // eslint-disable-line no-undef

		}
	}

	class WebGL1Renderer extends WebGLRenderer {}

	WebGL1Renderer.prototype.isWebGL1Renderer = true;

	class FogExp2 {
		constructor(color, density = 0.00025) {
			this.name = '';
			this.color = new Color(color);
			this.density = density;
		}

		clone() {
			return new FogExp2(this.color, this.density);
		}

		toJSON()
		/* meta */
		{
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
		}

	}

	FogExp2.prototype.isFogExp2 = true;

	class Fog {
		constructor(color, near = 1, far = 1000) {
			this.name = '';
			this.color = new Color(color);
			this.near = near;
			this.far = far;
		}

		clone() {
			return new Fog(this.color, this.near, this.far);
		}

		toJSON()
		/* meta */
		{
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
		}

	}

	Fog.prototype.isFog = true;

	class Scene extends Object3D {
		constructor() {
			super();
			this.type = 'Scene';
			this.background = null;
			this.environment = null;
			this.fog = null;
			this.overrideMaterial = null;
			this.autoUpdate = true; // checked by the renderer

			if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
				__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
					detail: this
				})); // eslint-disable-line no-undef

			}
		}

		copy(source, recursive) {
			super.copy(source, recursive);
			if (source.background !== null) this.background = source.background.clone();
			if (source.environment !== null) this.environment = source.environment.clone();
			if (source.fog !== null) this.fog = source.fog.clone();
			if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.fog !== null) data.object.fog = this.fog.toJSON();
			return data;
		}

	}

	Scene.prototype.isScene = true;

	class InterleavedBuffer {
		constructor(array, stride) {
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
			this.usage = StaticDrawUsage;
			this.updateRange = {
				offset: 0,
				count: -1
			};
			this.version = 0;
			this.uuid = generateUUID();
		}

		onUploadCallback() {}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setUsage(value) {
			this.usage = value;
			return this;
		}

		copy(source) {
			this.array = new source.array.constructor(source.array);
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;
			return this;
		}

		copyAt(index1, attribute, index2) {
			index1 *= this.stride;
			index2 *= attribute.stride;

			for (let i = 0, l = this.stride; i < l; i++) {
				this.array[index1 + i] = attribute.array[index2 + i];
			}

			return this;
		}

		set(value, offset = 0) {
			this.array.set(value, offset);
			return this;
		}

		clone(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			}

			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
			}

			const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
			const ib = new this.constructor(array, this.stride);
			ib.setUsage(this.usage);
			return ib;
		}

		onUpload(callback) {
			this.onUploadCallback = callback;
			return this;
		}

		toJSON(data) {
			if (data.arrayBuffers === undefined) {
				data.arrayBuffers = {};
			} // generate UUID for array buffer if necessary


			if (this.array.buffer._uuid === undefined) {
				this.array.buffer._uuid = generateUUID();
			}

			if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
				data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
			} //


			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};
		}

	}

	InterleavedBuffer.prototype.isInterleavedBuffer = true;

	const _vector$6 = /*@__PURE__*/new Vector3();

	class InterleavedBufferAttribute {
		constructor(interleavedBuffer, itemSize, offset, normalized = false) {
			this.name = '';
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
			this.normalized = normalized === true;
		}

		get count() {
			return this.data.count;
		}

		get array() {
			return this.data.array;
		}

		set needsUpdate(value) {
			this.data.needsUpdate = value;
		}

		applyMatrix4(m) {
			for (let i = 0, l = this.data.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyMatrix4(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		applyNormalMatrix(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.applyNormalMatrix(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		transformDirection(m) {
			for (let i = 0, l = this.count; i < l; i++) {
				_vector$6.x = this.getX(i);
				_vector$6.y = this.getY(i);
				_vector$6.z = this.getZ(i);

				_vector$6.transformDirection(m);

				this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
			}

			return this;
		}

		setX(index, x) {
			this.data.array[index * this.data.stride + this.offset] = x;
			return this;
		}

		setY(index, y) {
			this.data.array[index * this.data.stride + this.offset + 1] = y;
			return this;
		}

		setZ(index, z) {
			this.data.array[index * this.data.stride + this.offset + 2] = z;
			return this;
		}

		setW(index, w) {
			this.data.array[index * this.data.stride + this.offset + 3] = w;
			return this;
		}

		getX(index) {
			return this.data.array[index * this.data.stride + this.offset];
		}

		getY(index) {
			return this.data.array[index * this.data.stride + this.offset + 1];
		}

		getZ(index) {
			return this.data.array[index * this.data.stride + this.offset + 2];
		}

		getW(index) {
			return this.data.array[index * this.data.stride + this.offset + 3];
		}

		setXY(index, x, y) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			return this;
		}

		setXYZ(index, x, y, z) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			return this;
		}

		setXYZW(index, x, y, z, w) {
			index = index * this.data.stride + this.offset;
			this.data.array[index + 0] = x;
			this.data.array[index + 1] = y;
			this.data.array[index + 2] = z;
			this.data.array[index + 3] = w;
			return this;
		}

		clone(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				}

				return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
			} else {
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
				}

				return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
			}
		}

		toJSON(data) {
			if (data === undefined) {
				console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');
				const array = [];

				for (let i = 0; i < this.count; i++) {
					const index = i * this.data.stride + this.offset;

					for (let j = 0; j < this.itemSize; j++) {
						array.push(this.data.array[index + j]);
					}
				} // deinterleave data and save it as an ordinary buffer attribute for now


				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};
			} else {
				// save as true interlaved attribtue
				if (data.interleavedBuffers === undefined) {
					data.interleavedBuffers = {};
				}

				if (data.interleavedBuffers[this.data.uuid] === undefined) {
					data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};
			}
		}

	}

	InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *	rotation: <float>,
	 *	sizeAttenuation: <bool>
	 * }
	 */

	class SpriteMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'SpriteMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.rotation = 0;
			this.sizeAttenuation = true;
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.rotation = source.rotation;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true;

	let _geometry;

	const _intersectPoint = /*@__PURE__*/new Vector3();

	const _worldScale = /*@__PURE__*/new Vector3();

	const _mvPosition = /*@__PURE__*/new Vector3();

	const _alignedPosition = /*@__PURE__*/new Vector2();

	const _rotatedPosition = /*@__PURE__*/new Vector2();

	const _viewWorldMatrix = /*@__PURE__*/new Matrix4();

	const _vA = /*@__PURE__*/new Vector3();

	const _vB = /*@__PURE__*/new Vector3();

	const _vC = /*@__PURE__*/new Vector3();

	const _uvA = /*@__PURE__*/new Vector2();

	const _uvB = /*@__PURE__*/new Vector2();

	const _uvC = /*@__PURE__*/new Vector2();

	class Sprite extends Object3D {
		constructor(material) {
			super();
			this.type = 'Sprite';

			if (_geometry === undefined) {
				_geometry = new BufferGeometry();
				const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
				const interleavedBuffer = new InterleavedBuffer(float32Array, 5);

				_geometry.setIndex([0, 1, 2, 0, 2, 3]);

				_geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

				_geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
			}

			this.geometry = _geometry;
			this.material = material !== undefined ? material : new SpriteMaterial();
			this.center = new Vector2(0.5, 0.5);
		}

		raycast(raycaster, intersects) {
			if (raycaster.camera === null) {
				console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			}

			_worldScale.setFromMatrixScale(this.matrixWorld);

			_viewWorldMatrix.copy(raycaster.camera.matrixWorld);

			this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);

			_mvPosition.setFromMatrixPosition(this.modelViewMatrix);

			if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
				_worldScale.multiplyScalar(-_mvPosition.z);
			}

			const rotation = this.material.rotation;
			let sin, cos;

			if (rotation !== 0) {
				cos = Math.cos(rotation);
				sin = Math.sin(rotation);
			}

			const center = this.center;
			transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
			transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

			_uvA.set(0, 0);

			_uvB.set(1, 0);

			_uvC.set(1, 1); // check first triangle


			let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);

			if (intersect === null) {
				// check second triangle
				transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);

				_uvB.set(0, 1);

				intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);

				if (intersect === null) {
					return;
				}
			}

			const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
				face: null,
				object: this
			});
		}

		copy(source) {
			super.copy(source);
			if (source.center !== undefined) this.center.copy(source.center);
			this.material = source.material;
			return this;
		}

	}

	Sprite.prototype.isSprite = true;

	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
		// compute position in camera space
		_alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale); // to check if rotation is not zero


		if (sin !== undefined) {
			_rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
			_rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
		} else {
			_rotatedPosition.copy(_alignedPosition);
		}

		vertexPosition.copy(mvPosition);
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y; // transform to world space

		vertexPosition.applyMatrix4(_viewWorldMatrix);
	}

	const _v1$2 = /*@__PURE__*/new Vector3();

	const _v2$1 = /*@__PURE__*/new Vector3();

	class LOD extends Object3D {
		constructor() {
			super();
			this._currentLevel = 0;
			this.type = 'LOD';
			Object.defineProperties(this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true
				}
			});
			this.autoUpdate = true;
		}

		copy(source) {
			super.copy(source, false);
			const levels = source.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				this.addLevel(level.object.clone(), level.distance);
			}

			this.autoUpdate = source.autoUpdate;
			return this;
		}

		addLevel(object, distance = 0) {
			distance = Math.abs(distance);
			const levels = this.levels;
			let l;

			for (l = 0; l < levels.length; l++) {
				if (distance < levels[l].distance) {
					break;
				}
			}

			levels.splice(l, 0, {
				distance: distance,
				object: object
			});
			this.add(object);
			return this;
		}

		getCurrentLevel() {
			return this._currentLevel;
		}

		getObjectForDistance(distance) {
			const levels = this.levels;

			if (levels.length > 0) {
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance < levels[i].distance) {
						break;
					}
				}

				return levels[i - 1].object;
			}

			return null;
		}

		raycast(raycaster, intersects) {
			const levels = this.levels;

			if (levels.length > 0) {
				_v1$2.setFromMatrixPosition(this.matrixWorld);

				const distance = raycaster.ray.origin.distanceTo(_v1$2);
				this.getObjectForDistance(distance).raycast(raycaster, intersects);
			}
		}

		update(camera) {
			const levels = this.levels;

			if (levels.length > 1) {
				_v1$2.setFromMatrixPosition(camera.matrixWorld);

				_v2$1.setFromMatrixPosition(this.matrixWorld);

				const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
				levels[0].object.visible = true;
				let i, l;

				for (i = 1, l = levels.length; i < l; i++) {
					if (distance >= levels[i].distance) {
						levels[i - 1].object.visible = false;
						levels[i].object.visible = true;
					} else {
						break;
					}
				}

				this._currentLevel = i - 1;

				for (; i < l; i++) {
					levels[i].object.visible = false;
				}
			}
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			if (this.autoUpdate === false) data.object.autoUpdate = false;
			data.object.levels = [];
			const levels = this.levels;

			for (let i = 0, l = levels.length; i < l; i++) {
				const level = levels[i];
				data.object.levels.push({
					object: level.object.uuid,
					distance: level.distance
				});
			}

			return data;
		}

	}

	const _basePosition = /*@__PURE__*/new Vector3();

	const _skinIndex = /*@__PURE__*/new Vector4();

	const _skinWeight = /*@__PURE__*/new Vector4();

	const _vector$5 = /*@__PURE__*/new Vector3();

	const _matrix = /*@__PURE__*/new Matrix4();

	class SkinnedMesh extends Mesh {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'SkinnedMesh';
			this.bindMode = 'attached';
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
		}

		copy(source) {
			super.copy(source);
			this.bindMode = source.bindMode;
			this.bindMatrix.copy(source.bindMatrix);
			this.bindMatrixInverse.copy(source.bindMatrixInverse);
			this.skeleton = source.skeleton;
			return this;
		}

		bind(skeleton, bindMatrix) {
			this.skeleton = skeleton;

			if (bindMatrix === undefined) {
				this.updateMatrixWorld(true);
				this.skeleton.calculateInverses();
				bindMatrix = this.matrixWorld;
			}

			this.bindMatrix.copy(bindMatrix);
			this.bindMatrixInverse.copy(bindMatrix).invert();
		}

		pose() {
			this.skeleton.pose();
		}

		normalizeSkinWeights() {
			const vector = new Vector4();
			const skinWeight = this.geometry.attributes.skinWeight;

			for (let i = 0, l = skinWeight.count; i < l; i++) {
				vector.x = skinWeight.getX(i);
				vector.y = skinWeight.getY(i);
				vector.z = skinWeight.getZ(i);
				vector.w = skinWeight.getW(i);
				const scale = 1.0 / vector.manhattanLength();

				if (scale !== Infinity) {
					vector.multiplyScalar(scale);
				} else {
					vector.set(1, 0, 0, 0); // do something reasonable
				}

				skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
			}
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);

			if (this.bindMode === 'attached') {
				this.bindMatrixInverse.copy(this.matrixWorld).invert();
			} else if (this.bindMode === 'detached') {
				this.bindMatrixInverse.copy(this.bindMatrix).invert();
			} else {
				console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
			}
		}

		boneTransform(index, target) {
			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);

			_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

			_basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);

			target.set(0, 0, 0);

			for (let i = 0; i < 4; i++) {
				const weight = _skinWeight.getComponent(i);

				if (weight !== 0) {
					const boneIndex = _skinIndex.getComponent(i);

					_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);

					target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
				}
			}

			return target.applyMatrix4(this.bindMatrixInverse);
		}

	}

	SkinnedMesh.prototype.isSkinnedMesh = true;

	class Bone extends Object3D {
		constructor() {
			super();
			this.type = 'Bone';
		}

	}

	Bone.prototype.isBone = true;

	class DataTexture extends Texture {
		constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				data: data,
				width: width,
				height: height
			};
			this.magFilter = magFilter;
			this.minFilter = minFilter;
			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;
			this.needsUpdate = true;
		}

	}

	DataTexture.prototype.isDataTexture = true;

	const _offsetMatrix = /*@__PURE__*/new Matrix4();

	const _identityMatrix = /*@__PURE__*/new Matrix4();

	class Skeleton {
		constructor(bones = [], boneInverses = []) {
			this.uuid = generateUUID();
			this.bones = bones.slice(0);
			this.boneInverses = boneInverses;
			this.boneMatrices = null;
			this.boneTexture = null;
			this.boneTextureSize = 0;
			this.frame = -1;
			this.init();
		}

		init() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			this.boneMatrices = new Float32Array(bones.length * 16); // calculate inverse bone matrices if necessary

			if (boneInverses.length === 0) {
				this.calculateInverses();
			} else {
				// handle special case
				if (bones.length !== boneInverses.length) {
					console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
					this.boneInverses = [];

					for (let i = 0, il = this.bones.length; i < il; i++) {
						this.boneInverses.push(new Matrix4());
					}
				}
			}
		}

		calculateInverses() {
			this.boneInverses.length = 0;

			for (let i = 0, il = this.bones.length; i < il; i++) {
				const inverse = new Matrix4();

				if (this.bones[i]) {
					inverse.copy(this.bones[i].matrixWorld).invert();
				}

				this.boneInverses.push(inverse);
			}
		}

		pose() {
			// recover the bind-time world matrices
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					bone.matrixWorld.copy(this.boneInverses[i]).invert();
				}
			} // compute the local matrices, positions, rotations and scales


			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone) {
					if (bone.parent && bone.parent.isBone) {
						bone.matrix.copy(bone.parent.matrixWorld).invert();
						bone.matrix.multiply(bone.matrixWorld);
					} else {
						bone.matrix.copy(bone.matrixWorld);
					}

					bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
				}
			}
		}

		update() {
			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture; // flatten bone matrices to array

			for (let i = 0, il = bones.length; i < il; i++) {
				// compute the offset between the current and the original transform
				const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);

				_offsetMatrix.toArray(boneMatrices, i * 16);
			}

			if (boneTexture !== null) {
				boneTexture.needsUpdate = true;
			}
		}

		clone() {
			return new Skeleton(this.bones, this.boneInverses);
		}

		computeBoneTexture() {
			// layout (1 matrix = 4 pixels)
			//			RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//	with	8x8	pixel texture max	 16 bones * 4 pixels =	(8 * 8)
			//			 16x16 pixel texture max	 64 bones * 4 pixels = (16 * 16)
			//			 32x32 pixel texture max	256 bones * 4 pixels = (32 * 32)
			//			 64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
			let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix

			size = ceilPowerOfTwo(size);
			size = Math.max(size, 4);
			const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel

			boneMatrices.set(this.boneMatrices); // copy current values

			const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
			this.boneMatrices = boneMatrices;
			this.boneTexture = boneTexture;
			this.boneTextureSize = size;
			return this;
		}

		getBoneByName(name) {
			for (let i = 0, il = this.bones.length; i < il; i++) {
				const bone = this.bones[i];

				if (bone.name === name) {
					return bone;
				}
			}

			return undefined;
		}

		dispose() {
			if (this.boneTexture !== null) {
				this.boneTexture.dispose();
				this.boneTexture = null;
			}
		}

		fromJSON(json, bones) {
			this.uuid = json.uuid;

			for (let i = 0, l = json.bones.length; i < l; i++) {
				const uuid = json.bones[i];
				let bone = bones[uuid];

				if (bone === undefined) {
					console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
					bone = new Bone();
				}

				this.bones.push(bone);
				this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
			}

			this.init();
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};
			data.uuid = this.uuid;
			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for (let i = 0, l = bones.length; i < l; i++) {
				const bone = bones[i];
				data.bones.push(bone.uuid);
				const boneInverse = boneInverses[i];
				data.boneInverses.push(boneInverse.toArray());
			}

			return data;
		}

	}

	const _instanceLocalMatrix = /*@__PURE__*/new Matrix4();

	const _instanceWorldMatrix = /*@__PURE__*/new Matrix4();

	const _instanceIntersects = [];

	const _mesh = /*@__PURE__*/new Mesh();

	class InstancedMesh extends Mesh {
		constructor(geometry, material, count) {
			super(geometry, material);
			this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
			this.instanceColor = null;
			this.count = count;
			this.frustumCulled = false;
		}

		copy(source) {
			super.copy(source);
			this.instanceMatrix.copy(source.instanceMatrix);
			if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
			this.count = source.count;
			return this;
		}

		getColorAt(index, color) {
			color.fromArray(this.instanceColor.array, index * 3);
		}

		getMatrixAt(index, matrix) {
			matrix.fromArray(this.instanceMatrix.array, index * 16);
		}

		raycast(raycaster, intersects) {
			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;
			_mesh.geometry = this.geometry;
			_mesh.material = this.material;
			if (_mesh.material === undefined) return;

			for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
				// calculate the world matrix for each instance
				this.getMatrixAt(instanceId, _instanceLocalMatrix);

				_instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix); // the mesh represents this single instance


				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast(raycaster, _instanceIntersects); // process the result of raycast


				for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
					const intersect = _instanceIntersects[i];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push(intersect);
				}

				_instanceIntersects.length = 0;
			}
		}

		setColorAt(index, color) {
			if (this.instanceColor === null) {
				this.instanceColor = new BufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
			}

			color.toArray(this.instanceColor.array, index * 3);
		}

		setMatrixAt(index, matrix) {
			matrix.toArray(this.instanceMatrix.array, index * 16);
		}

		updateMorphTargets() {}

		dispose() {
			this.dispatchEvent({
				type: 'dispose'
			});
		}

	}

	InstancedMesh.prototype.isInstancedMesh = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *	linecap: "round",
	 *	linejoin: "round"
	 * }
	 */

	class LineBasicMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'LineBasicMaterial';
			this.color = new Color(0xffffff);
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
			return this;
		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	const _start$1 = /*@__PURE__*/new Vector3();

	const _end$1 = /*@__PURE__*/new Vector3();

	const _inverseMatrix$1 = /*@__PURE__*/new Matrix4();

	const _ray$1 = /*@__PURE__*/new Ray();

	const _sphere$1 = /*@__PURE__*/new Sphere();

	class Line extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
			super();
			this.type = 'Line';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [0];

					for (let i = 1, l = positionAttribute.count; i < l; i++) {
						_start$1.fromBufferAttribute(positionAttribute, i - 1);

						_end$1.fromBufferAttribute(positionAttribute, i);

						lineDistances[i] = lineDistances[i - 1];
						lineDistances[i] += _start$1.distanceTo(_end$1);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere$1.copy(geometry.boundingSphere);

			_sphere$1.applyMatrix4(matrixWorld);

			_sphere$1.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere$1) === false) return; //

			_inverseMatrix$1.copy(matrixWorld).invert();

			_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;
			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						const a = index.getX(i);
						const b = index.getX(i + 1);
						vStart.fromBufferAttribute(positionAttribute, a);
						vEnd.fromBufferAttribute(positionAttribute, b);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end - 1; i < l; i += step) {
						vStart.fromBufferAttribute(positionAttribute, i);
						vEnd.fromBufferAttribute(positionAttribute, i + 1);

						const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);

						if (distSq > localThresholdSq) continue;
						interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo(interRay);
						if (distance < raycaster.near || distance > raycaster.far) continue;
						intersects.push({
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4(this.matrixWorld),
							index: i,
							face: null,
							faceIndex: null,
							object: this
						});
					}
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Line.prototype.isLine = true;

	const _start = /*@__PURE__*/new Vector3();

	const _end = /*@__PURE__*/new Vector3();

	class LineSegments extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineSegments';
		}

		computeLineDistances() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				// we assume non-indexed geometry
				if (geometry.index === null) {
					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
						_start.fromBufferAttribute(positionAttribute, i);

						_end.fromBufferAttribute(positionAttribute, i + 1);

						lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
						lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
					}

					geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
				} else {
					console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
				}
			} else if (geometry.isGeometry) {
				console.error('THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}

			return this;
		}

	}

	LineSegments.prototype.isLineSegments = true;

	class LineLoop extends Line {
		constructor(geometry, material) {
			super(geometry, material);
			this.type = 'LineLoop';
		}

	}

	LineLoop.prototype.isLineLoop = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *	map: new THREE.Texture( <Image> ),
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	size: <float>,
	 *	sizeAttenuation: <bool>
	 *
	 * }
	 */

	class PointsMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'PointsMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.alphaMap = null;
			this.size = 1;
			this.sizeAttenuation = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.alphaMap = source.alphaMap;
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
			return this;
		}

	}

	PointsMaterial.prototype.isPointsMaterial = true;

	const _inverseMatrix = /*@__PURE__*/new Matrix4();

	const _ray = /*@__PURE__*/new Ray();

	const _sphere = /*@__PURE__*/new Sphere();

	const _position$2 = /*@__PURE__*/new Vector3();

	class Points extends Object3D {
		constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
			super();
			this.type = 'Points';
			this.geometry = geometry;
			this.material = material;
			this.updateMorphTargets();
		}

		copy(source) {
			super.copy(source);
			this.material = source.material;
			this.geometry = source.geometry;
			return this;
		}

		raycast(raycaster, intersects) {
			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;
			const drawRange = geometry.drawRange; // Checking boundingSphere distance to ray

			if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

			_sphere.copy(geometry.boundingSphere);

			_sphere.applyMatrix4(matrixWorld);

			_sphere.radius += threshold;
			if (raycaster.ray.intersectsSphere(_sphere) === false) return; //

			_inverseMatrix.copy(matrixWorld).invert();

			_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

			const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
			const localThresholdSq = localThreshold * localThreshold;

			if (geometry.isBufferGeometry) {
				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if (index !== null) {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(index.count, drawRange.start + drawRange.count);

					for (let i = start, il = end; i < il; i++) {
						const a = index.getX(i);

						_position$2.fromBufferAttribute(positionAttribute, a);

						testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				} else {
					const start = Math.max(0, drawRange.start);
					const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);

					for (let i = start, l = end; i < l; i++) {
						_position$2.fromBufferAttribute(positionAttribute, i);

						testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
					}
				}
			} else {
				console.error('THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
			}
		}

		updateMorphTargets() {
			const geometry = this.geometry;

			if (geometry.isBufferGeometry) {
				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys(morphAttributes);

				if (keys.length > 0) {
					const morphAttribute = morphAttributes[keys[0]];

					if (morphAttribute !== undefined) {
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
							const name = morphAttribute[m].name || String(m);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[name] = m;
						}
					}
				}
			} else {
				const morphTargets = geometry.morphTargets;

				if (morphTargets !== undefined && morphTargets.length > 0) {
					console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');
				}
			}
		}

	}

	Points.prototype.isPoints = true;

	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
		const rayPointDistanceSq = _ray.distanceSqToPoint(point);

		if (rayPointDistanceSq < localThresholdSq) {
			const intersectPoint = new Vector3();

			_ray.closestPointToPoint(point, intersectPoint);

			intersectPoint.applyMatrix4(matrixWorld);
			const distance = raycaster.ray.origin.distanceTo(intersectPoint);
			if (distance < raycaster.near || distance > raycaster.far) return;
			intersects.push({
				distance: distance,
				distanceToRay: Math.sqrt(rayPointDistanceSq),
				point: intersectPoint,
				index: index,
				face: null,
				object: object
			});
		}
	}

	class VideoTexture extends Texture {
		constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.format = format !== undefined ? format : RGBFormat;
			this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.generateMipmaps = false;
			const scope = this;

			function updateVideo() {
				scope.needsUpdate = true;
				video.requestVideoFrameCallback(updateVideo);
			}

			if ('requestVideoFrameCallback' in video) {
				video.requestVideoFrameCallback(updateVideo);
			}
		}

		clone() {
			return new this.constructor(this.image).copy(this);
		}

		update() {
			const video = this.image;
			const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);

			if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
				this.needsUpdate = true;
			}
		}

	}

	VideoTexture.prototype.isVideoTexture = true;

	class CompressedTexture extends Texture {
		constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
			this.image = {
				width: width,
				height: height
			};
			this.mipmaps = mipmaps; // no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false; // can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;
		}

	}

	CompressedTexture.prototype.isCompressedTexture = true;

	class CanvasTexture extends Texture {
		constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
			super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.needsUpdate = true;
		}

	}

	CanvasTexture.prototype.isCanvasTexture = true;

	class DepthTexture extends Texture {
		constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
			format = format !== undefined ? format : DepthFormat;

			if (format !== DepthFormat && format !== DepthStencilFormat) {
				throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
			}

			if (type === undefined && format === DepthFormat) type = UnsignedShortType;
			if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
			super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
			this.image = {
				width: width,
				height: height
			};
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
			this.flipY = false;
			this.generateMipmaps = false;
		}

	}

	DepthTexture.prototype.isDepthTexture = true;

	class CircleGeometry extends BufferGeometry {
		constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CircleGeometry';
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			segments = Math.max(3, segments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const uv = new Vector2(); // center point

			vertices.push(0, 0, 0);
			normals.push(0, 0, 1);
			uvs.push(0.5, 0.5);

			for (let s = 0, i = 3; s <= segments; s++, i += 3) {
				const segment = thetaStart + s / segments * thetaLength; // vertex

				vertex.x = radius * Math.cos(segment);
				vertex.y = radius * Math.sin(segment);
				vertices.push(vertex.x, vertex.y, vertex.z); // normal

				normals.push(0, 0, 1); // uvs

				uv.x = (vertices[i] / radius + 1) / 2;
				uv.y = (vertices[i + 1] / radius + 1) / 2;
				uvs.push(uv.x, uv.y);
			} // indices


			for (let i = 1; i <= segments; i++) {
				indices.push(i, i + 1, 0);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
		}

	}

	class CylinderGeometry extends BufferGeometry {
		constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'CylinderGeometry';
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			const scope = this;
			radialSegments = Math.floor(radialSegments);
			heightSegments = Math.floor(heightSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0; // generate geometry

			generateTorso();

			if (openEnded === false) {
				if (radiusTop > 0) generateCap(true);
				if (radiusBottom > 0) generateCap(false);
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

			function generateTorso() {
				const normal = new Vector3();
				const vertex = new Vector3();
				let groupCount = 0; // this will be used to calculate the normal

				const slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs

				for (let y = 0; y <= heightSegments; y++) {
					const indexRow = [];
					const v = y / heightSegments; // calculate the radius of the current row

					const radius = v * (radiusBottom - radiusTop) + radiusTop;

					for (let x = 0; x <= radialSegments; x++) {
						const u = x / radialSegments;
						const theta = u * thetaLength + thetaStart;
						const sinTheta = Math.sin(theta);
						const cosTheta = Math.cos(theta); // vertex

						vertex.x = radius * sinTheta;
						vertex.y = -v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push(vertex.x, vertex.y, vertex.z); // normal

						normal.set(sinTheta, slope, cosTheta).normalize();
						normals.push(normal.x, normal.y, normal.z); // uv

						uvs.push(u, 1 - v); // save index of vertex in respective row

						indexRow.push(index++);
					} // now save vertices of the row in our index array


					indexArray.push(indexRow);
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					for (let y = 0; y < heightSegments; y++) {
						// we use the index array to access the correct indices
						const a = indexArray[y][x];
						const b = indexArray[y + 1][x];
						const c = indexArray[y + 1][x + 1];
						const d = indexArray[y][x + 1]; // faces

						indices.push(a, b, d);
						indices.push(b, c, d); // update group counter

						groupCount += 6;
					}
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, 0); // calculate new start value for groups

				groupStart += groupCount;
			}

			function generateCap(top) {
				// save the index of the first center vertex
				const centerIndexStart = index;
				const uv = new Vector2();
				const vertex = new Vector3();
				let groupCount = 0;
				const radius = top === true ? radiusTop : radiusBottom;
				const sign = top === true ? 1 : -1; // first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for (let x = 1; x <= radialSegments; x++) {
					// vertex
					vertices.push(0, halfHeight * sign, 0); // normal

					normals.push(0, sign, 0); // uv

					uvs.push(0.5, 0.5); // increase index

					index++;
				} // save the index of the last center vertex


				const centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs

				for (let x = 0; x <= radialSegments; x++) {
					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;
					const cosTheta = Math.cos(theta);
					const sinTheta = Math.sin(theta); // vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, sign, 0); // uv

					uv.x = cosTheta * 0.5 + 0.5;
					uv.y = sinTheta * 0.5 * sign + 0.5;
					uvs.push(uv.x, uv.y); // increase index

					index++;
				} // generate indices


				for (let x = 0; x < radialSegments; x++) {
					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if (top === true) {
						// face top
						indices.push(i, i + 1, c);
					} else {
						// face bottom
						indices.push(i + 1, i, c);
					}

					groupCount += 3;
				} // add a group to the geometry. this will ensure multi material support


				scope.addGroup(groupStart, groupCount, top === true ? 1 : 2); // calculate new start value for groups

				groupStart += groupCount;
			}
		}

		static fromJSON(data) {
			return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}

	}

	class ConeGeometry extends CylinderGeometry {
		constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
			super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
			this.type = 'ConeGeometry';
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
		}

		static fromJSON(data) {
			return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
		}

	}

	class PolyhedronGeometry extends BufferGeometry {
		constructor(vertices, indices, radius = 1, detail = 0) {
			super();
			this.type = 'PolyhedronGeometry';
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			}; // default buffer data

			const vertexBuffer = [];
			const uvBuffer = []; // the subdivision creates the vertex buffer data

			subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius

			applyRadius(radius); // finally, create the uv data

			generateUVs(); // build non-indexed geometry

			this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
			this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));

			if (detail === 0) {
				this.computeVertexNormals(); // flat normals
			} else {
				this.normalizeNormals(); // smooth normals
			} // helper functions


			function subdivide(detail) {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3(); // iterate over all faces and apply a subdivison with the given detail value

				for (let i = 0; i < indices.length; i += 3) {
					// get the vertices of the face
					getVertexByIndex(indices[i + 0], a);
					getVertexByIndex(indices[i + 1], b);
					getVertexByIndex(indices[i + 2], c); // perform subdivision

					subdivideFace(a, b, c, detail);
				}
			}

			function subdivideFace(a, b, c, detail) {
				const cols = detail + 1; // we use this multidimensional array as a data structure for creating the subdivision

				const v = []; // construct all of the vertices for this subdivision

				for (let i = 0; i <= cols; i++) {
					v[i] = [];
					const aj = a.clone().lerp(c, i / cols);
					const bj = b.clone().lerp(c, i / cols);
					const rows = cols - i;

					for (let j = 0; j <= rows; j++) {
						if (j === 0 && i === cols) {
							v[i][j] = aj;
						} else {
							v[i][j] = aj.clone().lerp(bj, j / rows);
						}
					}
				} // construct all of the faces


				for (let i = 0; i < cols; i++) {
					for (let j = 0; j < 2 * (cols - i) - 1; j++) {
						const k = Math.floor(j / 2);

						if (j % 2 === 0) {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k]);
							pushVertex(v[i][k]);
						} else {
							pushVertex(v[i][k + 1]);
							pushVertex(v[i + 1][k + 1]);
							pushVertex(v[i + 1][k]);
						}
					}
				}
			}

			function applyRadius(radius) {
				const vertex = new Vector3(); // iterate over the entire buffer and apply the radius to each vertex

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					vertex.normalize().multiplyScalar(radius);
					vertexBuffer[i + 0] = vertex.x;
					vertexBuffer[i + 1] = vertex.y;
					vertexBuffer[i + 2] = vertex.z;
				}
			}

			function generateUVs() {
				const vertex = new Vector3();

				for (let i = 0; i < vertexBuffer.length; i += 3) {
					vertex.x = vertexBuffer[i + 0];
					vertex.y = vertexBuffer[i + 1];
					vertex.z = vertexBuffer[i + 2];
					const u = azimuth(vertex) / 2 / Math.PI + 0.5;
					const v = inclination(vertex) / Math.PI + 0.5;
					uvBuffer.push(u, 1 - v);
				}

				correctUVs();
				correctSeam();
			}

			function correctSeam() {
				// handle case when face straddles the seam, see #3269
				for (let i = 0; i < uvBuffer.length; i += 6) {
					// uv data of a single face
					const x0 = uvBuffer[i + 0];
					const x1 = uvBuffer[i + 2];
					const x2 = uvBuffer[i + 4];
					const max = Math.max(x0, x1, x2);
					const min = Math.min(x0, x1, x2); // 0.9 is somewhat arbitrary

					if (max > 0.9 && min < 0.1) {
						if (x0 < 0.2) uvBuffer[i + 0] += 1;
						if (x1 < 0.2) uvBuffer[i + 2] += 1;
						if (x2 < 0.2) uvBuffer[i + 4] += 1;
					}
				}
			}

			function pushVertex(vertex) {
				vertexBuffer.push(vertex.x, vertex.y, vertex.z);
			}

			function getVertexByIndex(index, vertex) {
				const stride = index * 3;
				vertex.x = vertices[stride + 0];
				vertex.y = vertices[stride + 1];
				vertex.z = vertices[stride + 2];
			}

			function correctUVs() {
				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();
				const centroid = new Vector3();
				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
					a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
					b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
					c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
					uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
					uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
					uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
					centroid.copy(a).add(b).add(c).divideScalar(3);
					const azi = azimuth(centroid);
					correctUV(uvA, j + 0, a, azi);
					correctUV(uvB, j + 2, b, azi);
					correctUV(uvC, j + 4, c, azi);
				}
			}

			function correctUV(uv, stride, vector, azimuth) {
				if (azimuth < 0 && uv.x === 1) {
					uvBuffer[stride] = uv.x - 1;
				}

				if (vector.x === 0 && vector.z === 0) {
					uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
				}
			} // Angle around the Y axis, counter-clockwise when looking from above.


			function azimuth(vector) {
				return Math.atan2(vector.z, -vector.x);
			} // Angle above the XZ plane.


			function inclination(vector) {
				return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
			}
		}

		static fromJSON(data) {
			return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const r = 1 / t;
			const vertices = [// (1, 1, 1)
			-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, // (0, 1/, )
			0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, // (1/, , 0)
			-r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, // (, 0, 1/)
			-t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
			const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
			super(vertices, indices, radius, detail);
			this.type = 'DodecahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new DodecahedronGeometry(data.radius, data.detail);
		}

	}

	const _v0 = new Vector3();

	const _v1$1 = new Vector3();

	const _normal = new Vector3();

	const _triangle = new Triangle();

	class EdgesGeometry extends BufferGeometry {
		constructor(geometry, thresholdAngle) {
			super();
			this.type = 'EdgesGeometry';
			this.parameters = {
				thresholdAngle: thresholdAngle
			};
			thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;

			if (geometry.isGeometry === true) {
				console.error('THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return;
			}

			const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute('position');
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
			const indexArr = [0, 0, 0];
			const vertKeys = ['a', 'b', 'c'];
			const hashes = new Array(3);
			const edgeData = {};
			const vertices = [];

			for (let i = 0; i < indexCount; i += 3) {
				if (indexAttr) {
					indexArr[0] = indexAttr.getX(i);
					indexArr[1] = indexAttr.getX(i + 1);
					indexArr[2] = indexAttr.getX(i + 2);
				} else {
					indexArr[0] = i;
					indexArr[1] = i + 1;
					indexArr[2] = i + 2;
				}

				const {
					a,
					b,
					c
				} = _triangle;
				a.fromBufferAttribute(positionAttr, indexArr[0]);
				b.fromBufferAttribute(positionAttr, indexArr[1]);
				c.fromBufferAttribute(positionAttr, indexArr[2]);

				_triangle.getNormal(_normal); // create hashes for the edge from the vertices


				hashes[0] = `${a.x},${a.y},${a.z}`;
				hashes[1] = `${b.x},${b.y},${b.z}`;
				hashes[2] = `${c.x},${c.y},${c.z}`; // skip degenerate triangles

				if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
					continue;
				} // iterate over every edge


				for (let j = 0; j < 3; j++) {
					// get the first and next vertex making up the edge
					const jNext = (j + 1) % 3;
					const vecHash0 = hashes[j];
					const vecHash1 = hashes[jNext];
					const v0 = _triangle[vertKeys[j]];
					const v1 = _triangle[vertKeys[jNext]];
					const hash = `${vecHash0}_${vecHash1}`;
					const reverseHash = `${vecHash1}_${vecHash0}`;

					if (reverseHash in edgeData && edgeData[reverseHash]) {
						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
							vertices.push(v0.x, v0.y, v0.z);
							vertices.push(v1.x, v1.y, v1.z);
						}

						edgeData[reverseHash] = null;
					} else if (!(hash in edgeData)) {
						// if we've already got an edge here then skip adding a new one
						edgeData[hash] = {
							index0: indexArr[j],
							index1: indexArr[jNext],
							normal: _normal.clone()
						};
					}
				}
			} // iterate over all remaining, unmatched edges and add them to the vertex array


			for (const key in edgeData) {
				if (edgeData[key]) {
					const {
						index0,
						index1
					} = edgeData[key];

					_v0.fromBufferAttribute(positionAttr, index0);

					_v1$1.fromBufferAttribute(positionAttr, index1);

					vertices.push(_v0.x, _v0.y, _v0.z);
					vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
				}
			}

			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	class Curve {
		constructor() {
			this.type = 'Curve';
			this.arcLengthDivisions = 200;
		} // Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]


		getPoint()
		/* t, optionalTarget */
		{
			console.warn('THREE.Curve: .getPoint() not implemented.');
			return null;
		} // Get point at relative position in curve according to arc length
		// - u [0 .. 1]


		getPointAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getPoint(t, optionalTarget);
		} // Get sequence of points using getPoint( t )


		getPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPoint(d / divisions));
			}

			return points;
		} // Get sequence of points using getPointAt( u )


		getSpacedPoints(divisions = 5) {
			const points = [];

			for (let d = 0; d <= divisions; d++) {
				points.push(this.getPointAt(d / divisions));
			}

			return points;
		} // Get total curve arc length


		getLength() {
			const lengths = this.getLengths();
			return lengths[lengths.length - 1];
		} // Get list of cumulative segment lengths


		getLengths(divisions = this.arcLengthDivisions) {
			if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
				return this.cacheArcLengths;
			}

			this.needsUpdate = false;
			const cache = [];
			let current,
					last = this.getPoint(0);
			let sum = 0;
			cache.push(0);

			for (let p = 1; p <= divisions; p++) {
				current = this.getPoint(p / divisions);
				sum += current.distanceTo(last);
				cache.push(sum);
				last = current;
			}

			this.cacheArcLengths = cache;
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
		}

		updateArcLengths() {
			this.needsUpdate = true;
			this.getLengths();
		} // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant


		getUtoTmapping(u, distance) {
			const arcLengths = this.getLengths();
			let i = 0;
			const il = arcLengths.length;
			let targetArcLength; // The targeted u distance value to get

			if (distance) {
				targetArcLength = distance;
			} else {
				targetArcLength = u * arcLengths[il - 1];
			} // binary search for the index with largest value smaller than target u distance


			let low = 0,
					high = il - 1,
					comparison;

			while (low <= high) {
				i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[i] - targetArcLength;

				if (comparison < 0) {
					low = i + 1;
				} else if (comparison > 0) {
					high = i - 1;
				} else {
					high = i;
					break; // DONE
				}
			}

			i = high;

			if (arcLengths[i] === targetArcLength) {
				return i / (il - 1);
			} // we could get finer grain at lengths, or use simple interpolation between two points


			const lengthBefore = arcLengths[i];
			const lengthAfter = arcLengths[i + 1];
			const segmentLength = lengthAfter - lengthBefore; // determine where we are between the 'before' and 'after' points

			const segmentFraction = (targetArcLength - lengthBefore) / segmentLength; // add that fractional amount to t

			const t = (i + segmentFraction) / (il - 1);
			return t;
		} // Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation


		getTangent(t, optionalTarget) {
			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta; // Capping in case of danger

			if (t1 < 0) t1 = 0;
			if (t2 > 1) t2 = 1;
			const pt1 = this.getPoint(t1);
			const pt2 = this.getPoint(t2);
			const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
			tangent.copy(pt2).sub(pt1).normalize();
			return tangent;
		}

		getTangentAt(u, optionalTarget) {
			const t = this.getUtoTmapping(u);
			return this.getTangent(t, optionalTarget);
		}

		computeFrenetFrames(segments, closed) {
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
			const normal = new Vector3();
			const tangents = [];
			const normals = [];
			const binormals = [];
			const vec = new Vector3();
			const mat = new Matrix4(); // compute the tangent vectors for each segment on the curve

			for (let i = 0; i <= segments; i++) {
				const u = i / segments;
				tangents[i] = this.getTangentAt(u, new Vector3());
				tangents[i].normalize();
			} // select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component


			normals[0] = new Vector3();
			binormals[0] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs(tangents[0].x);
			const ty = Math.abs(tangents[0].y);
			const tz = Math.abs(tangents[0].z);

			if (tx <= min) {
				min = tx;
				normal.set(1, 0, 0);
			}

			if (ty <= min) {
				min = ty;
				normal.set(0, 1, 0);
			}

			if (tz <= min) {
				normal.set(0, 0, 1);
			}

			vec.crossVectors(tangents[0], normal).normalize();
			normals[0].crossVectors(tangents[0], vec);
			binormals[0].crossVectors(tangents[0], normals[0]); // compute the slowly-varying normal and binormal vectors for each segment on the curve

			for (let i = 1; i <= segments; i++) {
				normals[i] = normals[i - 1].clone();
				binormals[i] = binormals[i - 1].clone();
				vec.crossVectors(tangents[i - 1], tangents[i]);

				if (vec.length() > Number.EPSILON) {
					vec.normalize();
					const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1)); // clamp for floating pt errors

					normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
				}

				binormals[i].crossVectors(tangents[i], normals[i]);
			} // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same


			if (closed === true) {
				let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
				theta /= segments;

				if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
					theta = -theta;
				}

				for (let i = 1; i <= segments; i++) {
					// twist a little...
					normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
					binormals[i].crossVectors(tangents[i], normals[i]);
				}
			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(source) {
			this.arcLengthDivisions = source.arcLengthDivisions;
			return this;
		}

		toJSON() {
			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
			return data;
		}

		fromJSON(json) {
			this.arcLengthDivisions = json.arcLengthDivisions;
			return this;
		}

	}

	class EllipseCurve extends Curve {
		constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
			super();
			this.type = 'EllipseCurve';
			this.aX = aX;
			this.aY = aY;
			this.xRadius = xRadius;
			this.yRadius = yRadius;
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
			this.aClockwise = aClockwise;
			this.aRotation = aRotation;
		}

		getPoint(t, optionalTarget) {
			const point = optionalTarget || new Vector2();
			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs(deltaAngle) < Number.EPSILON; // ensures that deltaAngle is 0 .. 2 PI

			while (deltaAngle < 0) deltaAngle += twoPi;

			while (deltaAngle > twoPi) deltaAngle -= twoPi;

			if (deltaAngle < Number.EPSILON) {
				if (samePoints) {
					deltaAngle = 0;
				} else {
					deltaAngle = twoPi;
				}
			}

			if (this.aClockwise === true && !samePoints) {
				if (deltaAngle === twoPi) {
					deltaAngle = -twoPi;
				} else {
					deltaAngle = deltaAngle - twoPi;
				}
			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos(angle);
			let y = this.aY + this.yRadius * Math.sin(angle);

			if (this.aRotation !== 0) {
				const cos = Math.cos(this.aRotation);
				const sin = Math.sin(this.aRotation);
				const tx = x - this.aX;
				const ty = y - this.aY; // Rotate the point about the center of the ellipse.

				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
			}

			return point.set(x, y);
		}

		copy(source) {
			super.copy(source);
			this.aX = source.aX;
			this.aY = source.aY;
			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;
			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;
			this.aClockwise = source.aClockwise;
			this.aRotation = source.aRotation;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.aX = this.aX;
			data.aY = this.aY;
			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;
			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;
			data.aClockwise = this.aClockwise;
			data.aRotation = this.aRotation;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.aX = json.aX;
			this.aY = json.aY;
			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;
			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;
			this.aClockwise = json.aClockwise;
			this.aRotation = json.aRotation;
			return this;
		}

	}

	EllipseCurve.prototype.isEllipseCurve = true;

	class ArcCurve extends EllipseCurve {
		constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			this.type = 'ArcCurve';
		}

	}

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {
		let c0 = 0,
				c1 = 0,
				c2 = 0,
				c3 = 0;
		/*
		 * Compute coefficients for a cubic polynomial
		 *	 p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *	 p(0) = x0, p(1) = x1
		 *	and
		 *	 p'(0) = t0, p'(1) = t1.
		 */

		function init(x0, x1, t0, t1) {
			c0 = x0;
			c1 = t0;
			c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
		}

		return {
			initCatmullRom: function (x0, x1, x2, x3, tension) {
				init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
			},
			initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
				// compute tangents when parameterized in [t1,t2]
				let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
				let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2; // rescale tangents for parametrization in [0,1]

				t1 *= dt1;
				t2 *= dt1;
				init(x1, x2, t1, t2);
			},
			calc: function (t) {
				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
			}
		};
	} //


	const tmp = new Vector3();
	const px = new CubicPoly(),
				py = new CubicPoly(),
				pz = new CubicPoly();

	class CatmullRomCurve3 extends Curve {
		constructor(points = [], closed = false, curveType = 'centripetal', tension = 0.5) {
			super();
			this.type = 'CatmullRomCurve3';
			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const points = this.points;
			const l = points.length;
			const p = (l - (this.closed ? 0 : 1)) * t;
			let intPoint = Math.floor(p);
			let weight = p - intPoint;

			if (this.closed) {
				intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
			} else if (weight === 0 && intPoint === l - 1) {
				intPoint = l - 2;
				weight = 1;
			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if (this.closed || intPoint > 0) {
				p0 = points[(intPoint - 1) % l];
			} else {
				// extrapolate first point
				tmp.subVectors(points[0], points[1]).add(points[0]);
				p0 = tmp;
			}

			const p1 = points[intPoint % l];
			const p2 = points[(intPoint + 1) % l];

			if (this.closed || intPoint + 2 < l) {
				p3 = points[(intPoint + 2) % l];
			} else {
				// extrapolate last point
				tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
				p3 = tmp;
			}

			if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
				let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
				let dt2 = Math.pow(p2.distanceToSquared(p3), pow); // safety check for repeated points

				if (dt1 < 1e-4) dt1 = 1.0;
				if (dt0 < 1e-4) dt0 = dt1;
				if (dt2 < 1e-4) dt2 = dt1;
				px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
				py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
				pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
			} else if (this.curveType === 'catmullrom') {
				px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
				py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
				pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
			}

			point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector3().fromArray(point));
			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;
			return this;
		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */
	function CatmullRom(t, p0, p1, p2, p3) {
		const v0 = (p2 - p0) * 0.5;
		const v1 = (p3 - p1) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	} //


	function QuadraticBezierP0(t, p) {
		const k = 1 - t;
		return k * k * p;
	}

	function QuadraticBezierP1(t, p) {
		return 2 * (1 - t) * t * p;
	}

	function QuadraticBezierP2(t, p) {
		return t * t * p;
	}

	function QuadraticBezier(t, p0, p1, p2) {
		return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	} //


	function CubicBezierP0(t, p) {
		const k = 1 - t;
		return k * k * k * p;
	}

	function CubicBezierP1(t, p) {
		const k = 1 - t;
		return 3 * k * k * t * p;
	}

	function CubicBezierP2(t, p) {
		return 3 * (1 - t) * t * t * p;
	}

	function CubicBezierP3(t, p) {
		return t * t * t * p;
	}

	function CubicBezier(t, p0, p1, p2, p3) {
		return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}

	class CubicBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
			super();
			this.type = 'CubicBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	class CubicBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
			super();
			this.type = 'CubicBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2,
						v3 = this.v3;
			point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			this.v3.copy(source.v3);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			this.v3.fromArray(json.v3);
			return this;
		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	class LineCurve extends Curve {
		constructor(v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'LineCurve';
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		getTangent(t, optionalTarget) {
			const tangent = optionalTarget || new Vector2();
			tangent.copy(this.v2).sub(this.v1).normalize();
			return tangent;
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	LineCurve.prototype.isLineCurve = true;

	class LineCurve3 extends Curve {
		constructor(v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'LineCurve3';
			this.isLineCurve3 = true;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;

			if (t === 1) {
				point.copy(this.v2);
			} else {
				point.copy(this.v2).sub(this.v1);
				point.multiplyScalar(t).add(this.v1);
			}

			return point;
		} // Line curve is linear, so we can overwrite default getPointAt


		getPointAt(u, optionalTarget) {
			return this.getPoint(u, optionalTarget);
		}

		copy(source) {
			super.copy(source);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	class QuadraticBezierCurve extends Curve {
		constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
			super();
			this.type = 'QuadraticBezierCurve';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	class QuadraticBezierCurve3 extends Curve {
		constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
			super();
			this.type = 'QuadraticBezierCurve3';
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
		}

		getPoint(t, optionalTarget = new Vector3()) {
			const point = optionalTarget;
			const v0 = this.v0,
						v1 = this.v1,
						v2 = this.v2;
			point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.v0.copy(source.v0);
			this.v1.copy(source.v1);
			this.v2.copy(source.v2);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.v0.fromArray(json.v0);
			this.v1.fromArray(json.v1);
			this.v2.fromArray(json.v2);
			return this;
		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	class SplineCurve extends Curve {
		constructor(points = []) {
			super();
			this.type = 'SplineCurve';
			this.points = points;
		}

		getPoint(t, optionalTarget = new Vector2()) {
			const point = optionalTarget;
			const points = this.points;
			const p = (points.length - 1) * t;
			const intPoint = Math.floor(p);
			const weight = p - intPoint;
			const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
			const p1 = points[intPoint];
			const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
			const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
			point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
			return point;
		}

		copy(source) {
			super.copy(source);
			this.points = [];

			for (let i = 0, l = source.points.length; i < l; i++) {
				const point = source.points[i];
				this.points.push(point.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.points = [];

			for (let i = 0, l = this.points.length; i < l; i++) {
				const point = this.points[i];
				data.points.push(point.toArray());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.points = [];

			for (let i = 0, l = json.points.length; i < l; i++) {
				const point = json.points[i];
				this.points.push(new Vector2().fromArray(point));
			}

			return this;
		}

	}

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */
	const Earcut = {
		triangulate: function (data, holeIndices, dim = 2) {
			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
			let outerNode = linkedList(data, 0, outerLen, dim, true);
			const triangles = [];
			if (!outerNode || outerNode.next === outerNode.prev) return triangles;
			let minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];

				for (let i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				} // minX, minY and invSize are later used to transform coords into integers for z-order calculation


				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}

			earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}
	}; // create a circular doubly linked list from polygon points in the specified winding order

	function linkedList(data, start, end, dim, clockwise) {
		let i, last;

		if (clockwise === signedArea(data, start, end, dim) > 0) {
			for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
		} else {
			for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
		}

		if (last && equals(last, last.next)) {
			removeNode(last);
			last = last.next;
		}

		return last;
	} // eliminate colinear or duplicate points


	function filterPoints(start, end) {
		if (!start) return start;
		if (!end) end = start;
		let p = start,
				again;

		do {
			again = false;

			if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
				removeNode(p);
				p = end = p.prev;
				if (p === p.next) break;
				again = true;
			} else {
				p = p.next;
			}
		} while (again || p !== end);

		return end;
	} // main ear slicing loop which triangulates a polygon (given as a linked list)


	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
		if (!ear) return; // interlink polygon nodes in z-order

		if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
		let stop = ear,
				prev,
				next; // iterate through ears, slicing them one by one

		while (ear.prev !== ear.next) {
			prev = ear.prev;
			next = ear.next;

			if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
				// cut off the triangle
				triangles.push(prev.i / dim);
				triangles.push(ear.i / dim);
				triangles.push(next.i / dim);
				removeNode(ear); // skipping the next vertex leads to less sliver triangles

				ear = next.next;
				stop = next.next;
				continue;
			}

			ear = next; // if we looped through the whole remaining polygon and can't find any more ears

			if (ear === stop) {
				// try filtering points and slicing again
				if (!pass) {
					earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
				} else if (pass === 1) {
					ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
					earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
				} else if (pass === 2) {
					splitEarcut(ear, triangles, dim, minX, minY, invSize);
				}

				break;
			}
		}
	} // check whether a polygon node forms a valid ear with adjacent nodes


	function isEar(ear) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// now make sure we don't have other points inside the potential ear

		let p = ear.next.next;

		while (p !== ear.prev) {
			if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.next;
		}

		return true;
	}

	function isEarHashed(ear, minX, minY, invSize) {
		const a = ear.prev,
					b = ear,
					c = ear.next;
		if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
		// triangle bbox; min & max are calculated like this for speed

		const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
					minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
					maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
					maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

		const minZ = zOrder(minTX, minTY, minX, minY, invSize),
					maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
		let p = ear.prevZ,
				n = ear.nextZ; // look for points inside the triangle in both directions

		while (p && p.z >= minZ && n && n.z <= maxZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		} // look for remaining points in decreasing z-order


		while (p && p.z >= minZ) {
			if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
			p = p.prevZ;
		} // look for remaining points in increasing z-order


		while (n && n.z <= maxZ) {
			if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
			n = n.nextZ;
		}

		return true;
	} // go through all polygon nodes and cure small local self-intersections


	function cureLocalIntersections(start, triangles, dim) {
		let p = start;

		do {
			const a = p.prev,
						b = p.next.next;

			if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
				triangles.push(a.i / dim);
				triangles.push(p.i / dim);
				triangles.push(b.i / dim); // remove two nodes involved

				removeNode(p);
				removeNode(p.next);
				p = start = b;
			}

			p = p.next;
		} while (p !== start);

		return filterPoints(p);
	} // try splitting polygon into two and triangulate them independently


	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
		// look for a valid diagonal that divides the polygon into two
		let a = start;

		do {
			let b = a.next.next;

			while (b !== a.prev) {
				if (a.i !== b.i && isValidDiagonal(a, b)) {
					// split the polygon in two by the diagonal
					let c = splitPolygon(a, b); // filter colinear points around the cuts

					a = filterPoints(a, a.next);
					c = filterPoints(c, c.next); // run earcut on each half

					earcutLinked(a, triangles, dim, minX, minY, invSize);
					earcutLinked(c, triangles, dim, minX, minY, invSize);
					return;
				}

				b = b.next;
			}

			a = a.next;
		} while (a !== start);
	} // link every hole into the outer loop, producing a single-ring polygon without holes


	function eliminateHoles(data, holeIndices, outerNode, dim) {
		const queue = [];
		let i, len, start, end, list;

		for (i = 0, len = holeIndices.length; i < len; i++) {
			start = holeIndices[i] * dim;
			end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
			list = linkedList(data, start, end, dim, false);
			if (list === list.next) list.steiner = true;
			queue.push(getLeftmost(list));
		}

		queue.sort(compareX); // process holes from left to right

		for (i = 0; i < queue.length; i++) {
			eliminateHole(queue[i], outerNode);
			outerNode = filterPoints(outerNode, outerNode.next);
		}

		return outerNode;
	}

	function compareX(a, b) {
		return a.x - b.x;
	} // find a bridge between vertices that connects hole with an outer ring and and link it


	function eliminateHole(hole, outerNode) {
		outerNode = findHoleBridge(hole, outerNode);

		if (outerNode) {
			const b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

			filterPoints(outerNode, outerNode.next);
			filterPoints(b, b.next);
		}
	} // David Eberly's algorithm for finding a bridge between hole and outer polygon


	function findHoleBridge(hole, outerNode) {
		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = -Infinity,
				m; // find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {
			if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
				const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

				if (x <= hx && x > qx) {
					qx = x;

					if (x === hx) {
						if (hy === p.y) return p;
						if (hy === p.next.y) return p.next;
					}

					m = p.x < p.next.x ? p : p.next;
				}
			}

			p = p.next;
		} while (p !== outerNode);

		if (!m) return null;
		if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
					mx = m.x,
					my = m.y;
		let tanMin = Infinity,
				tan;
		p = m;

		do {
			if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
				tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

				if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
					m = p;
					tanMin = tan;
				}
			}

			p = p.next;
		} while (p !== stop);

		return m;
	} // whether sector in vertex m contains sector in vertex p in the same coordinates


	function sectorContainsSector(m, p) {
		return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
	} // interlink polygon nodes in z-order


	function indexCurve(start, minX, minY, invSize) {
		let p = start;

		do {
			if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
		} while (p !== start);

		p.prevZ.nextZ = null;
		p.prevZ = null;
		sortLinked(p);
	} // Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


	function sortLinked(list) {
		let i,
				p,
				q,
				e,
				tail,
				numMerges,
				pSize,
				qSize,
				inSize = 1;

		do {
			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while (p) {
				numMerges++;
				q = p;
				pSize = 0;

				for (i = 0; i < inSize; i++) {
					pSize++;
					q = q.nextZ;
					if (!q) break;
				}

				qSize = inSize;

				while (pSize > 0 || qSize > 0 && q) {
					if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
						e = p;
						p = p.nextZ;
						pSize--;
					} else {
						e = q;
						q = q.nextZ;
						qSize--;
					}

					if (tail) tail.nextZ = e;else list = e;
					e.prevZ = tail;
					tail = e;
				}

				p = q;
			}

			tail.nextZ = null;
			inSize *= 2;
		} while (numMerges > 1);

		return list;
	} // z-order of a point given coords and inverse of the longer side of data bbox


	function zOrder(x, y, minX, minY, invSize) {
		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * (x - minX) * invSize;
		y = 32767 * (y - minY) * invSize;
		x = (x | x << 8) & 0x00FF00FF;
		x = (x | x << 4) & 0x0F0F0F0F;
		x = (x | x << 2) & 0x33333333;
		x = (x | x << 1) & 0x55555555;
		y = (y | y << 8) & 0x00FF00FF;
		y = (y | y << 4) & 0x0F0F0F0F;
		y = (y | y << 2) & 0x33333333;
		y = (y | y << 1) & 0x55555555;
		return x | y << 1;
	} // find the leftmost node of a polygon ring


	function getLeftmost(start) {
		let p = start,
				leftmost = start;

		do {
			if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
			p = p.next;
		} while (p !== start);

		return leftmost;
	} // check if a point lies within a convex triangle


	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
		return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	} // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


	function isValidDiagonal(a, b) {
		return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
		locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
		area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
		equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
	} // signed area of a triangle


	function area(p, q, r) {
		return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	} // check if two points are equal


	function equals(p1, p2) {
		return p1.x === p2.x && p1.y === p2.y;
	} // check if two segments intersect


	function intersects(p1, q1, p2, q2) {
		const o1 = sign(area(p1, q1, p2));
		const o2 = sign(area(p1, q1, q2));
		const o3 = sign(area(p2, q2, p1));
		const o4 = sign(area(p2, q2, q1));
		if (o1 !== o2 && o3 !== o4) return true; // general case

		if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

		if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

		if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

		if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;
	} // for collinear points p, q, r, check if point q lies on segment pr


	function onSegment(p, q, r) {
		return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
	}

	function sign(num) {
		return num > 0 ? 1 : num < 0 ? -1 : 0;
	} // check if a polygon diagonal intersects any polygon segments


	function intersectsPolygon(a, b) {
		let p = a;

		do {
			if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
			p = p.next;
		} while (p !== a);

		return false;
	} // check if a polygon diagonal is locally inside the polygon


	function locallyInside(a, b) {
		return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	} // check if the middle point of a polygon diagonal is inside the polygon


	function middleInside(a, b) {
		let p = a,
				inside = false;
		const px = (a.x + b.x) / 2,
					py = (a.y + b.y) / 2;

		do {
			if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
			p = p.next;
		} while (p !== a);

		return inside;
	} // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring


	function splitPolygon(a, b) {
		const a2 = new Node(a.i, a.x, a.y),
					b2 = new Node(b.i, b.x, b.y),
					an = a.next,
					bp = b.prev;
		a.next = b;
		b.prev = a;
		a2.next = an;
		an.prev = a2;
		b2.next = a2;
		a2.prev = b2;
		bp.next = b2;
		b2.prev = bp;
		return b2;
	} // create a node and optionally link it with previous one (in a circular doubly linked list)


	function insertNode(i, x, y, last) {
		const p = new Node(i, x, y);

		if (!last) {
			p.prev = p;
			p.next = p;
		} else {
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
		}

		return p;
	}

	function removeNode(p) {
		p.next.prev = p.prev;
		p.prev.next = p.next;
		if (p.prevZ) p.prevZ.nextZ = p.nextZ;
		if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}

	function Node(i, x, y) {
		// vertex index in coordinates array
		this.i = i; // vertex coordinates

		this.x = x;
		this.y = y; // previous and next vertex nodes in a polygon ring

		this.prev = null;
		this.next = null; // z-order curve value

		this.z = null; // previous and next nodes in z-order

		this.prevZ = null;
		this.nextZ = null; // indicates whether this is a steiner point

		this.steiner = false;
	}

	function signedArea(data, start, end, dim) {
		let sum = 0;

		for (let i = start, j = end - dim; i < end; i += dim) {
			sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
			j = i;
		}

		return sum;
	}

	class ShapeUtils {
		// calculate area of the contour polygon
		static area(contour) {
			const n = contour.length;
			let a = 0.0;

			for (let p = n - 1, q = 0; q < n; p = q++) {
				a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
			}

			return a * 0.5;
		}

		static isClockWise(pts) {
			return ShapeUtils.area(pts) < 0;
		}

		static triangulateShape(contour, holes) {
			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]

			const holeIndices = []; // array of hole indices

			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts(contour);
			addContour(vertices, contour); //

			let holeIndex = contour.length;
			holes.forEach(removeDupEndPts);

			for (let i = 0; i < holes.length; i++) {
				holeIndices.push(holeIndex);
				holeIndex += holes[i].length;
				addContour(vertices, holes[i]);
			} //


			const triangles = Earcut.triangulate(vertices, holeIndices); //

			for (let i = 0; i < triangles.length; i += 3) {
				faces.push(triangles.slice(i, i + 3));
			}

			return faces;
		}

	}

	function removeDupEndPts(points) {
		const l = points.length;

		if (l > 2 && points[l - 1].equals(points[0])) {
			points.pop();
		}
	}

	function addContour(vertices, contour) {
		for (let i = 0; i < contour.length; i++) {
			vertices.push(contour[i].x);
			vertices.push(contour[i].y);
		}
	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *	curveSegments: <int>, // number of points on the curves
	 *	steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *	depth: <float>, // Depth to extrude the shape
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into the original shape bevel goes
	 *	bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *	bevelOffset: <float>, // how far from shape outline does bevel start
	 *	bevelSegments: <int>, // number of bevel layers
	 *
	 *	extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *	UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {
		constructor(shapes, options) {
			super();
			this.type = 'ExtrudeGeometry';
			this.parameters = {
				shapes: shapes,
				options: options
			};
			shapes = Array.isArray(shapes) ? shapes : [shapes];
			const scope = this;
			const verticesArray = [];
			const uvArray = [];

			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				addShape(shape);
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
			this.computeVertexNormals(); // functions

			function addShape(shape) {
				const placeholder = []; // options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				let depth = options.depth !== undefined ? options.depth : 100;
				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
				const extrudePath = options.extrudePath;
				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator; // deprecated options

				if (options.amount !== undefined) {
					console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');
					depth = options.amount;
				} //


				let extrudePts,
						extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if (extrudePath) {
					extrudePts = extrudePath.getSpacedPoints(steps);
					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion
					// SETUP TNB variables
					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames(steps, false); // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();
				} // Safeguards if bevels are not enabled


				if (!bevelEnabled) {
					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;
				} // Variables initialization


				const shapePoints = shape.extractPoints(curveSegments);
				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;
				const reverse = !ShapeUtils.isClockWise(vertices);

				if (reverse) {
					vertices = vertices.reverse(); // Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];

						if (ShapeUtils.isClockWise(ahole)) {
							holes[h] = ahole.reverse();
						}
					}
				}

				const faces = ShapeUtils.triangulateShape(vertices, holes);
				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					vertices = vertices.concat(ahole);
				}

				function scalePt2(pt, vec, size) {
					if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
					return vec.clone().multiplyScalar(size).add(pt);
				}

				const vlen = vertices.length,
							flen = faces.length; // Find directions for point movement

				function getBevelVec(inPt, inPrev, inNext) {
					// computes for inPt the corresponding point inPt' on a new contour
					//	 shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//	adjacent edges of inPt at a distance of 1 unit on the left side.
					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
								v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
								v_next_y = inNext.y - inPt.y;
					const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y; // check for collinear edges

					const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;

					if (Math.abs(collinear0) > Number.EPSILON) {
						// not collinear
						// length of vectors for normalizing
						const v_prev_len = Math.sqrt(v_prev_lensq);
						const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y); // shift adjacent points by unit vectors to the left

						const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
						const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
						const ptNextShift_x = inNext.x - v_next_y / v_next_len;
						const ptNextShift_y = inNext.y + v_next_x / v_next_len; // scaling factor for v_prev to intersection point

						const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x); // vector from inPt to intersection point

						v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
						v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y; // Don't normalize!, otherwise sharp corners become ugly
						//	but prevent crazy spikes

						const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;

						if (v_trans_lensq <= 2) {
							return new Vector2(v_trans_x, v_trans_y);
						} else {
							shrink_by = Math.sqrt(v_trans_lensq / 2);
						}
					} else {
						// handle special case of collinear edges
						let direction_eq = false; // assumes: opposite

						if (v_prev_x > Number.EPSILON) {
							if (v_next_x > Number.EPSILON) {
								direction_eq = true;
							}
						} else {
							if (v_prev_x < -Number.EPSILON) {
								if (v_next_x < -Number.EPSILON) {
									direction_eq = true;
								}
							} else {
								if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
									direction_eq = true;
								}
							}
						}

						if (direction_eq) {
							// console.log("Warning: lines are a straight sequence");
							v_trans_x = -v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt(v_prev_lensq);
						} else {
							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt(v_prev_lensq / 2);
						}
					}

					return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
				}

				const contourMovements = [];

				for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
					if (j === il) j = 0;
					if (k === il) k = 0; //	(j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
				}

				const holesMovements = [];
				let oneHoleMovements,
						verticesMovements = contourMovements.concat();

				for (let h = 0, hl = holes.length; h < hl; h++) {
					const ahole = holes[h];
					oneHoleMovements = [];

					for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
						if (j === il) j = 0;
						if (k === il) k = 0; //	(j)---(i)---(k)

						oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
					}

					holesMovements.push(oneHoleMovements);
					verticesMovements = verticesMovements.concat(oneHoleMovements);
				} // Loop bevelSegments, 1 for the front, 1 for the back


				for (let b = 0; b < bevelSegments; b++) {
					//for ( b = bevelSegments; b > 0; b -- ) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, -z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
							v(vert.x, vert.y, -z);
						}
					}
				}

				const bs = bevelSize + bevelOffset; // Back facing vertices

				for (let i = 0; i < vlen; i++) {
					const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

					if (!extrudeByPath) {
						v(vert.x, vert.y, 0);
					} else {
						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
						normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
						binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
						position2.copy(extrudePts[0]).add(normal).add(binormal);
						v(position2.x, position2.y, position2.z);
					}
				} // Add stepped vertices...
				// Including front facing vertices


				for (let s = 1; s <= steps; s++) {
					for (let i = 0; i < vlen; i++) {
						const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];

						if (!extrudeByPath) {
							v(vert.x, vert.y, depth / steps * s);
						} else {
							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
							normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
							binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
							position2.copy(extrudePts[s]).add(normal).add(binormal);
							v(position2.x, position2.y, position2.z);
						}
					}
				} // Add bevel segments planes
				//for ( b = 1; b <= bevelSegments; b ++ ) {


				for (let b = bevelSegments - 1; b >= 0; b--) {
					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos(t * Math.PI / 2);
					const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset; // contract shape

					for (let i = 0, il = contour.length; i < il; i++) {
						const vert = scalePt2(contour[i], contourMovements[i], bs);
						v(vert.x, vert.y, depth + z);
					} // expand holes


					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						oneHoleMovements = holesMovements[h];

						for (let i = 0, il = ahole.length; i < il; i++) {
							const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);

							if (!extrudeByPath) {
								v(vert.x, vert.y, depth + z);
							} else {
								v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
							}
						}
					}
				}
				/* Faces */
				// Top and bottom faces


				buildLidFaces(); // Sides faces

				buildSideFaces(); /////	Internal functions

				function buildLidFaces() {
					const start = verticesArray.length / 3;

					if (bevelEnabled) {
						let layer = 0; // steps + 1

						let offset = vlen * layer; // Bottom faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2] + offset, face[1] + offset, face[0] + offset);
						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer; // Top faces

						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + offset, face[1] + offset, face[2] + offset);
						}
					} else {
						// Bottom faces
						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[2], face[1], face[0]);
						} // Top faces


						for (let i = 0; i < flen; i++) {
							const face = faces[i];
							f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
						}
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 0);
				} // Create faces for the z-sides of the shape


				function buildSideFaces() {
					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls(contour, layeroffset);
					layeroffset += contour.length;

					for (let h = 0, hl = holes.length; h < hl; h++) {
						const ahole = holes[h];
						sidewalls(ahole, layeroffset); //, true

						layeroffset += ahole.length;
					}

					scope.addGroup(start, verticesArray.length / 3 - start, 1);
				}

				function sidewalls(contour, layeroffset) {
					let i = contour.length;

					while (--i >= 0) {
						const j = i;
						let k = i - 1;
						if (k < 0) k = contour.length - 1; //console.log('b', i,j, i-1, k,vertices.length);

						for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
							const slen1 = vlen * s;
							const slen2 = vlen * (s + 1);
							const a = layeroffset + j + slen1,
										b = layeroffset + k + slen1,
										c = layeroffset + k + slen2,
										d = layeroffset + j + slen2;
							f4(a, b, c, d);
						}
					}
				}

				function v(x, y, z) {
					placeholder.push(x);
					placeholder.push(y);
					placeholder.push(z);
				}

				function f3(a, b, c) {
					addVertex(a);
					addVertex(b);
					addVertex(c);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[2]);
				}

				function f4(a, b, c, d) {
					addVertex(a);
					addVertex(b);
					addVertex(d);
					addVertex(b);
					addVertex(c);
					addVertex(d);
					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
					addUV(uvs[0]);
					addUV(uvs[1]);
					addUV(uvs[3]);
					addUV(uvs[1]);
					addUV(uvs[2]);
					addUV(uvs[3]);
				}

				function addVertex(index) {
					verticesArray.push(placeholder[index * 3 + 0]);
					verticesArray.push(placeholder[index * 3 + 1]);
					verticesArray.push(placeholder[index * 3 + 2]);
				}

				function addUV(vector2) {
					uvArray.push(vector2.x);
					uvArray.push(vector2.y);
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			const options = this.parameters.options;
			return toJSON$1(shapes, options, data);
		}

		static fromJSON(data, shapes) {
			const geometryShapes = [];

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			const extrudePath = data.options.extrudePath;

			if (extrudePath !== undefined) {
				data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
			}

			return new ExtrudeGeometry(geometryShapes, data.options);
		}

	}

	const WorldUVGenerator = {
		generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
		},
		generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
			const a_x = vertices[indexA * 3];
			const a_y = vertices[indexA * 3 + 1];
			const a_z = vertices[indexA * 3 + 2];
			const b_x = vertices[indexB * 3];
			const b_y = vertices[indexB * 3 + 1];
			const b_z = vertices[indexB * 3 + 2];
			const c_x = vertices[indexC * 3];
			const c_y = vertices[indexC * 3 + 1];
			const c_z = vertices[indexC * 3 + 2];
			const d_x = vertices[indexD * 3];
			const d_y = vertices[indexD * 3 + 1];
			const d_z = vertices[indexD * 3 + 2];

			if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
				return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
			} else {
				return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
			}
		}
	};

	function toJSON$1(shapes, options, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
		return data;
	}

	class IcosahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const t = (1 + Math.sqrt(5)) / 2;
			const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
			const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
			super(vertices, indices, radius, detail);
			this.type = 'IcosahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new IcosahedronGeometry(data.radius, data.detail);
		}

	}

	class LatheGeometry extends BufferGeometry {
		constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
			super();
			this.type = 'LatheGeometry';
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
			segments = Math.floor(segments); // clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = clamp(phiLength, 0, Math.PI * 2); // buffers

			const indices = [];
			const vertices = [];
			const uvs = []; // helper variables

			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices and uvs

			for (let i = 0; i <= segments; i++) {
				const phi = phiStart + i * inverseSegments * phiLength;
				const sin = Math.sin(phi);
				const cos = Math.cos(phi);

				for (let j = 0; j <= points.length - 1; j++) {
					// vertex
					vertex.x = points[j].x * sin;
					vertex.y = points[j].y;
					vertex.z = points[j].x * cos;
					vertices.push(vertex.x, vertex.y, vertex.z); // uv

					uv.x = i / segments;
					uv.y = j / (points.length - 1);
					uvs.push(uv.x, uv.y);
				}
			} // indices


			for (let i = 0; i < segments; i++) {
				for (let j = 0; j < points.length - 1; j++) {
					const base = j + i * points.length;
					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // generate normals

			this.computeVertexNormals(); // if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if (phiLength === Math.PI * 2) {
				const normals = this.attributes.normal.array;
				const n1 = new Vector3();
				const n2 = new Vector3();
				const n = new Vector3(); // this is the buffer offset for the last line of vertices

				const base = segments * points.length * 3;

				for (let i = 0, j = 0; i < points.length; i++, j += 3) {
					// select the normal of the vertex in the first line
					n1.x = normals[j + 0];
					n1.y = normals[j + 1];
					n1.z = normals[j + 2]; // select the normal of the vertex in the last line

					n2.x = normals[base + j + 0];
					n2.y = normals[base + j + 1];
					n2.z = normals[base + j + 2]; // average normals

					n.addVectors(n1, n2).normalize(); // assign the new values to both normals

					normals[j + 0] = normals[base + j + 0] = n.x;
					normals[j + 1] = normals[base + j + 1] = n.y;
					normals[j + 2] = normals[base + j + 2] = n.z;
				}
			}
		}

		static fromJSON(data) {
			return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
			const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
			super(vertices, indices, radius, detail);
			this.type = 'OctahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new OctahedronGeometry(data.radius, data.detail);
		}

	}

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	class ParametricGeometry extends BufferGeometry {
		constructor(func, slices, stacks) {
			super();
			this.type = 'ParametricGeometry';
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];
			const EPS = 0.00001;
			const normal = new Vector3();
			const p0 = new Vector3(),
						p1 = new Vector3();
			const pu = new Vector3(),
						pv = new Vector3();

			if (func.length < 3) {
				console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');
			} // generate vertices, normals and uvs


			const sliceCount = slices + 1;

			for (let i = 0; i <= stacks; i++) {
				const v = i / stacks;

				for (let j = 0; j <= slices; j++) {
					const u = j / slices; // vertex

					func(u, v, p0);
					vertices.push(p0.x, p0.y, p0.z); // normal
					// approximate tangent vectors via finite differences

					if (u - EPS >= 0) {
						func(u - EPS, v, p1);
						pu.subVectors(p0, p1);
					} else {
						func(u + EPS, v, p1);
						pu.subVectors(p1, p0);
					}

					if (v - EPS >= 0) {
						func(u, v - EPS, p1);
						pv.subVectors(p0, p1);
					} else {
						func(u, v + EPS, p1);
						pv.subVectors(p1, p0);
					} // cross product of tangent vectors returns surface normal


					normal.crossVectors(pu, pv).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u, v);
				}
			} // generate indices


			for (let i = 0; i < stacks; i++) {
				for (let j = 0; j < slices; j++) {
					const a = i * sliceCount + j;
					const b = i * sliceCount + j + 1;
					const c = (i + 1) * sliceCount + j + 1;
					const d = (i + 1) * sliceCount + j; // faces one and two

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

	}

	class RingGeometry extends BufferGeometry {
		constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
			super();
			this.type = 'RingGeometry';
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			thetaSegments = Math.max(3, thetaSegments);
			phiSegments = Math.max(1, phiSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // some helper variables

			let radius = innerRadius;
			const radiusStep = (outerRadius - innerRadius) / phiSegments;
			const vertex = new Vector3();
			const uv = new Vector2(); // generate vertices, normals and uvs

			for (let j = 0; j <= phiSegments; j++) {
				for (let i = 0; i <= thetaSegments; i++) {
					// values are generate from the inside of the ring to the outside
					const segment = thetaStart + i / thetaSegments * thetaLength; // vertex

					vertex.x = radius * Math.cos(segment);
					vertex.y = radius * Math.sin(segment);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normals.push(0, 0, 1); // uv

					uv.x = (vertex.x / outerRadius + 1) / 2;
					uv.y = (vertex.y / outerRadius + 1) / 2;
					uvs.push(uv.x, uv.y);
				} // increase the radius for next row of vertices


				radius += radiusStep;
			} // indices


			for (let j = 0; j < phiSegments; j++) {
				const thetaSegmentLevel = j * (thetaSegments + 1);

				for (let i = 0; i < thetaSegments; i++) {
					const segment = i + thetaSegmentLevel;
					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
		}

	}

	class ShapeGeometry extends BufferGeometry {
		constructor(shapes, curveSegments = 12) {
			super();
			this.type = 'ShapeGeometry';
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			}; // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			let groupStart = 0;
			let groupCount = 0; // allow single and array values for "shapes" parameter

			if (Array.isArray(shapes) === false) {
				addShape(shapes);
			} else {
				for (let i = 0; i < shapes.length; i++) {
					addShape(shapes[i]);
					this.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // helper functions

			function addShape(shape) {
				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints(curveSegments);
				let shapeVertices = points.shape;
				const shapeHoles = points.holes; // check direction of vertices

				if (ShapeUtils.isClockWise(shapeVertices) === false) {
					shapeVertices = shapeVertices.reverse();
				}

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];

					if (ShapeUtils.isClockWise(shapeHole) === true) {
						shapeHoles[i] = shapeHole.reverse();
					}
				}

				const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles); // join vertices of inner and outer paths to a single array

				for (let i = 0, l = shapeHoles.length; i < l; i++) {
					const shapeHole = shapeHoles[i];
					shapeVertices = shapeVertices.concat(shapeHole);
				} // vertices, normals, uvs


				for (let i = 0, l = shapeVertices.length; i < l; i++) {
					const vertex = shapeVertices[i];
					vertices.push(vertex.x, vertex.y, 0);
					normals.push(0, 0, 1);
					uvs.push(vertex.x, vertex.y); // world uvs
				} // incides


				for (let i = 0, l = faces.length; i < l; i++) {
					const face = faces[i];
					const a = face[0] + indexOffset;
					const b = face[1] + indexOffset;
					const c = face[2] + indexOffset;
					indices.push(a, b, c);
					groupCount += 3;
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			const shapes = this.parameters.shapes;
			return toJSON(shapes, data);
		}

		static fromJSON(data, shapes) {
			const geometryShapes = [];

			for (let j = 0, jl = data.shapes.length; j < jl; j++) {
				const shape = shapes[data.shapes[j]];
				geometryShapes.push(shape);
			}

			return new ShapeGeometry(geometryShapes, data.curveSegments);
		}

	}

	function toJSON(shapes, data) {
		data.shapes = [];

		if (Array.isArray(shapes)) {
			for (let i = 0, l = shapes.length; i < l; i++) {
				const shape = shapes[i];
				data.shapes.push(shape.uuid);
			}
		} else {
			data.shapes.push(shapes.uuid);
		}

		return data;
	}

	class SphereGeometry extends BufferGeometry {
		constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
			super();
			this.type = 'SphereGeometry';
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
			widthSegments = Math.max(3, Math.floor(widthSegments));
			heightSegments = Math.max(2, Math.floor(heightSegments));
			const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
			let index = 0;
			const grid = [];
			const vertex = new Vector3();
			const normal = new Vector3(); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // generate vertices, normals and uvs

			for (let iy = 0; iy <= heightSegments; iy++) {
				const verticesRow = [];
				const v = iy / heightSegments; // special case for the poles

				let uOffset = 0;

				if (iy == 0 && thetaStart == 0) {
					uOffset = 0.5 / widthSegments;
				} else if (iy == heightSegments && thetaEnd == Math.PI) {
					uOffset = -0.5 / widthSegments;
				}

				for (let ix = 0; ix <= widthSegments; ix++) {
					const u = ix / widthSegments; // vertex

					vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
					vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					normal.copy(vertex).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(u + uOffset, 1 - v);
					verticesRow.push(index++);
				}

				grid.push(verticesRow);
			} // indices


			for (let iy = 0; iy < heightSegments; iy++) {
				for (let ix = 0; ix < widthSegments; ix++) {
					const a = grid[iy][ix + 1];
					const b = grid[iy][ix];
					const c = grid[iy + 1][ix];
					const d = grid[iy + 1][ix + 1];
					if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
					if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {
		constructor(radius = 1, detail = 0) {
			const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
			const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
			super(vertices, indices, radius, detail);
			this.type = 'TetrahedronGeometry';
			this.parameters = {
				radius: radius,
				detail: detail
			};
		}

		static fromJSON(data) {
			return new TetrahedronGeometry(data.radius, data.detail);
		}

	}

	/**
	 * Text = 3D Text
	 *
	 * parameters = {
	 *	font: <THREE.Font>, // font
	 *
	 *	size: <float>, // size of the text
	 *	height: <float>, // thickness to extrude text
	 *	curveSegments: <int>, // number of points on the curves
	 *
	 *	bevelEnabled: <bool>, // turn on bevel
	 *	bevelThickness: <float>, // how deep into text bevel goes
	 *	bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
	 *	bevelOffset: <float> // how far from text outline does bevel start
	 * }
	 */

	class TextGeometry extends ExtrudeGeometry {
		constructor(text, parameters = {}) {
			const font = parameters.font;

			if (!(font && font.isFont)) {
				console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');
				return new BufferGeometry();
			}

			const shapes = font.generateShapes(text, parameters.size); // translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50; // defaults

			if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
			if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
			if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
			super(shapes, parameters);
			this.type = 'TextGeometry';
		}

	}

	class TorusGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
			super();
			this.type = 'TorusGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
			radialSegments = Math.floor(radialSegments);
			tubularSegments = Math.floor(tubularSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3(); // generate vertices, normals and uvs

			for (let j = 0; j <= radialSegments; j++) {
				for (let i = 0; i <= tubularSegments; i++) {
					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2; // vertex

					vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
					vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
					vertex.z = tube * Math.sin(v);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal

					center.x = radius * Math.cos(u);
					center.y = radius * Math.sin(u);
					normal.subVectors(vertex, center).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= radialSegments; j++) {
				for (let i = 1; i <= tubularSegments; i++) {
					// indices
					const a = (tubularSegments + 1) * j + i - 1;
					const b = (tubularSegments + 1) * (j - 1) + i - 1;
					const c = (tubularSegments + 1) * (j - 1) + i;
					const d = (tubularSegments + 1) * j + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
		}

		static fromJSON(data) {
			return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
		}

	}

	class TorusKnotGeometry extends BufferGeometry {
		constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
			super();
			this.type = 'TorusKnotGeometry';
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
			tubularSegments = Math.floor(tubularSegments);
			radialSegments = Math.floor(radialSegments); // buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = []; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const P1 = new Vector3();
			const P2 = new Vector3();
			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3(); // generate vertices, normals and uvs

			for (let i = 0; i <= tubularSegments; ++i) {
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
				const u = i / tubularSegments * p * Math.PI * 2; // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve(u, p, q, radius, P1);
				calculatePositionOnCurve(u + 0.01, p, q, radius, P2); // calculate orthonormal basis

				T.subVectors(P2, P1);
				N.addVectors(P2, P1);
				B.crossVectors(T, N);
				N.crossVectors(B, T); // normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for (let j = 0; j <= radialSegments; ++j) {
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
					const v = j / radialSegments * Math.PI * 2;
					const cx = -tube * Math.cos(v);
					const cy = tube * Math.sin(v); // now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + (cx * N.x + cy * B.x);
					vertex.y = P1.y + (cx * N.y + cy * B.y);
					vertex.z = P1.z + (cx * N.z + cy * B.z);
					vertices.push(vertex.x, vertex.y, vertex.z); // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors(vertex, P1).normalize();
					normals.push(normal.x, normal.y, normal.z); // uv

					uvs.push(i / tubularSegments);
					uvs.push(j / radialSegments);
				}
			} // generate indices


			for (let j = 1; j <= tubularSegments; j++) {
				for (let i = 1; i <= radialSegments; i++) {
					// indices
					const a = (radialSegments + 1) * (j - 1) + (i - 1);
					const b = (radialSegments + 1) * j + (i - 1);
					const c = (radialSegments + 1) * j + i;
					const d = (radialSegments + 1) * (j - 1) + i; // faces

					indices.push(a, b, d);
					indices.push(b, c, d);
				}
			} // build geometry


			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // this function calculates the current position on the torus curve

			function calculatePositionOnCurve(u, p, q, radius, position) {
				const cu = Math.cos(u);
				const su = Math.sin(u);
				const quOverP = q / p * u;
				const cs = Math.cos(quOverP);
				position.x = radius * (2 + cs) * 0.5 * cu;
				position.y = radius * (2 + cs) * su * 0.5;
				position.z = radius * Math.sin(quOverP) * 0.5;
			}
		}

		static fromJSON(data) {
			return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
		}

	}

	class TubeGeometry extends BufferGeometry {
		constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
			super();
			this.type = 'TubeGeometry';
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
			const frames = path.computeFrenetFrames(tubularSegments, closed); // expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals; // helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3(); // buffer

			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = []; // create buffer data

			generateBufferData(); // build geometry

			this.setIndex(indices);
			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
			this.setAttribute('uv', new Float32BufferAttribute(uvs, 2)); // functions

			function generateBufferData() {
				for (let i = 0; i < tubularSegments; i++) {
					generateSegment(i);
				} // if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)


				generateSegment(closed === false ? tubularSegments : 0); // uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs(); // finally create faces

				generateIndices();
			}

			function generateSegment(i) {
				// we use getPointAt to sample evenly distributed points from the given path
				P = path.getPointAt(i / tubularSegments, P); // retrieve corresponding normal and binormal

				const N = frames.normals[i];
				const B = frames.binormals[i]; // generate normals and vertices for the current segment

				for (let j = 0; j <= radialSegments; j++) {
					const v = j / radialSegments * Math.PI * 2;
					const sin = Math.sin(v);
					const cos = -Math.cos(v); // normal

					normal.x = cos * N.x + sin * B.x;
					normal.y = cos * N.y + sin * B.y;
					normal.z = cos * N.z + sin * B.z;
					normal.normalize();
					normals.push(normal.x, normal.y, normal.z); // vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
					vertices.push(vertex.x, vertex.y, vertex.z);
				}
			}

			function generateIndices() {
				for (let j = 1; j <= tubularSegments; j++) {
					for (let i = 1; i <= radialSegments; i++) {
						const a = (radialSegments + 1) * (j - 1) + (i - 1);
						const b = (radialSegments + 1) * j + (i - 1);
						const c = (radialSegments + 1) * j + i;
						const d = (radialSegments + 1) * (j - 1) + i; // faces

						indices.push(a, b, d);
						indices.push(b, c, d);
					}
				}
			}

			function generateUVs() {
				for (let i = 0; i <= tubularSegments; i++) {
					for (let j = 0; j <= radialSegments; j++) {
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
						uvs.push(uv.x, uv.y);
					}
				}
			}
		}

		toJSON() {
			const data = super.toJSON();
			data.path = this.parameters.path.toJSON();
			return data;
		}

		static fromJSON(data) {
			// This only works for built-in curves (e.g. CatmullRomCurve3).
			// User defined curves or instances of CurvePath will not be deserialized.
			return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
		}

	}

	class WireframeGeometry extends BufferGeometry {
		constructor(geometry) {
			super();
			this.type = 'WireframeGeometry';

			if (geometry.isGeometry === true) {
				console.error('THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');
				return;
			} // buffer


			const vertices = [];
			const edges = new Set(); // helper variables

			const start = new Vector3();
			const end = new Vector3();

			if (geometry.index !== null) {
				// indexed BufferGeometry
				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if (groups.length === 0) {
					groups = [{
						start: 0,
						count: indices.count,
						materialIndex: 0
					}];
				} // create a data structure that contains all eges without duplicates


				for (let o = 0, ol = groups.length; o < ol; ++o) {
					const group = groups[o];
					const groupStart = group.start;
					const groupCount = group.count;

					for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
						for (let j = 0; j < 3; j++) {
							const index1 = indices.getX(i + j);
							const index2 = indices.getX(i + (j + 1) % 3);
							start.fromBufferAttribute(position, index1);
							end.fromBufferAttribute(position, index2);

							if (isUniqueEdge(start, end, edges) === true) {
								vertices.push(start.x, start.y, start.z);
								vertices.push(end.x, end.y, end.z);
							}
						}
					}
				}
			} else {
				// non-indexed BufferGeometry
				const position = geometry.attributes.position;

				for (let i = 0, l = position.count / 3; i < l; i++) {
					for (let j = 0; j < 3; j++) {
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
						const index1 = 3 * i + j;
						const index2 = 3 * i + (j + 1) % 3;
						start.fromBufferAttribute(position, index1);
						end.fromBufferAttribute(position, index2);

						if (isUniqueEdge(start, end, edges) === true) {
							vertices.push(start.x, start.y, start.z);
							vertices.push(end.x, end.y, end.z);
						}
					}
				}
			} // build geometry


			this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
		}

	}

	function isUniqueEdge(start, end, edges) {
		const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
		const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

		if (edges.has(hash1) === true || edges.has(hash2) === true) {
			return false;
		} else {
			edges.add(hash1, hash2);
			return true;
		}
	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	/**
	 * parameters = {
	 *	color: <THREE.Color>
	 * }
	 */

	class ShadowMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'ShadowMaterial';
			this.color = new Color(0x000000);
			this.transparent = true;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			return this;
		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	roughness: <float>,
	 *	metalness: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *	metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	envMapIntensity: <float>
	 *
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshStandardMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': ''
			};
			this.type = 'MeshStandardMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.roughness = 1.0;
			this.metalness = 0.0;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.roughnessMap = null;
			this.metalnessMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.envMapIntensity = 1.0;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': ''
			};
			this.color.copy(source.color);
			this.roughness = source.roughness;
			this.metalness = source.metalness;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.roughnessMap = source.roughnessMap;
			this.metalnessMap = source.metalnessMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	/**
	 * parameters = {
	 *	clearcoat: <float>,
	 *	clearcoatMap: new THREE.Texture( <Image> ),
	 *	clearcoatRoughness: <float>,
	 *	clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *	clearcoatNormalScale: <Vector2>,
	 *	clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *	reflectivity: <float>,
	 *	ior: <float>,
	 *
	 *	sheen: <Color>,
	 *
	 *	transmission: <float>,
	 *	transmissionMap: new THREE.Texture( <Image> ),
	 *
	 *	thickness: <float>,
	 *	thicknessMap: new THREE.Texture( <Image> ),
	 *	attenuationDistance: <float>,
	 *	attenuationTint: <Color>,
	 *
	 *	specularIntensity: <float>,
	 *	specularIntensityhMap: new THREE.Texture( <Image> ),
	 *	specularTint: <Color>,
	 *	specularTintMap: new THREE.Texture( <Image> )
	 * }
	 */

	class MeshPhysicalMaterial extends MeshStandardMaterial {
		constructor(parameters) {
			super();
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.type = 'MeshPhysicalMaterial';
			this.clearcoat = 0.0;
			this.clearcoatMap = null;
			this.clearcoatRoughness = 0.0;
			this.clearcoatRoughnessMap = null;
			this.clearcoatNormalScale = new Vector2(1, 1);
			this.clearcoatNormalMap = null;
			this.reflectivity = 0.5; // maps to F0 = 0.04

			Object.defineProperty(this, 'ior', {
				get: function () {
					return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);
				},
				set: function (ior) {
					this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);
				}
			});
			this.sheen = null; // null will disable sheen bsdf

			this.transmission = 0.0;
			this.transmissionMap = null;
			this.thickness = 0.01;
			this.thicknessMap = null;
			this.attenuationDistance = 0.0;
			this.attenuationTint = new Color(1, 1, 1);
			this.specularIntensity = 1.0;
			this.specularIntensityMap = null;
			this.specularTint = new Color(1, 1, 1);
			this.specularTintMap = null;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'STANDARD': '',
				'PHYSICAL': ''
			};
			this.clearcoat = source.clearcoat;
			this.clearcoatMap = source.clearcoatMap;
			this.clearcoatRoughness = source.clearcoatRoughness;
			this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
			this.clearcoatNormalMap = source.clearcoatNormalMap;
			this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
			this.reflectivity = source.reflectivity;

			if (source.sheen) {
				this.sheen = (this.sheen || new Color()).copy(source.sheen);
			} else {
				this.sheen = null;
			}

			this.transmission = source.transmission;
			this.transmissionMap = source.transmissionMap;
			this.thickness = source.thickness;
			this.thicknessMap = source.thicknessMap;
			this.attenuationDistance = source.attenuationDistance;
			this.attenuationTint.copy(source.attenuationTint);
			this.specularIntensity = source.specularIntensity;
			this.specularIntensityMap = source.specularIntensityMap;
			this.specularTint.copy(source.specularTint);
			this.specularTintMap = source.specularTintMap;
			return this;
		}

	}

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	specular: <hex>,
	 *	shininess: <float>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.MultiplyOperation,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshPhongMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshPhongMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.specular = new Color(0x111111);
			this.shininess = 30;
			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.specular.copy(source.specular);
			this.shininess = source.shininess;
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *	gradientMap: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshToonMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'TOON': ''
			};
			this.type = 'MeshToonMaterial';
			this.color = new Color(0xffffff);
			this.map = null;
			this.gradientMap = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.gradientMap = source.gradientMap;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *	opacity: <float>,
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshNormalMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshNormalMaterial';
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.fog = false;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	lightMap: new THREE.Texture( <Image> ),
	 *	lightMapIntensity: <float>
	 *
	 *	aoMap: new THREE.Texture( <Image> ),
	 *	aoMapIntensity: <float>
	 *
	 *	emissive: <hex>,
	 *	emissiveIntensity: <float>
	 *	emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *	specularMap: new THREE.Texture( <Image> ),
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *	combine: THREE.Multiply,
	 *	reflectivity: <float>,
	 *	refractionRatio: <float>,
	 *
	 *	wireframe: <boolean>,
	 *	wireframeLinewidth: <float>,
	 *
	 * }
	 */

	class MeshLambertMaterial extends Material {
		constructor(parameters) {
			super();
			this.type = 'MeshLambertMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.map = null;
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
			this.emissive = new Color(0x000000);
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
			this.specularMap = null;
			this.alphaMap = null;
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.map = source.map;
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
			this.emissive.copy(source.emissive);
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
			this.specularMap = source.specularMap;
			this.alphaMap = source.alphaMap;
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
			return this;
		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	matcap: new THREE.Texture( <Image> ),
	 *
	 *	map: new THREE.Texture( <Image> ),
	 *
	 *	bumpMap: new THREE.Texture( <Image> ),
	 *	bumpScale: <float>,
	 *
	 *	normalMap: new THREE.Texture( <Image> ),
	 *	normalMapType: THREE.TangentSpaceNormalMap,
	 *	normalScale: <Vector2>,
	 *
	 *	displacementMap: new THREE.Texture( <Image> ),
	 *	displacementScale: <float>,
	 *	displacementBias: <float>,
	 *
	 *	alphaMap: new THREE.Texture( <Image> ),
	 *
	 *	flatShading: <bool>
	 * }
	 */

	class MeshMatcapMaterial extends Material {
		constructor(parameters) {
			super();
			this.defines = {
				'MATCAP': ''
			};
			this.type = 'MeshMatcapMaterial';
			this.color = new Color(0xffffff); // diffuse

			this.matcap = null;
			this.map = null;
			this.bumpMap = null;
			this.bumpScale = 1;
			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2(1, 1);
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
			this.alphaMap = null;
			this.flatShading = false;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.defines = {
				'MATCAP': ''
			};
			this.color.copy(source.color);
			this.matcap = source.matcap;
			this.map = source.map;
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy(source.normalScale);
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
			this.alphaMap = source.alphaMap;
			this.flatShading = source.flatShading;
			return this;
		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *	color: <hex>,
	 *	opacity: <float>,
	 *
	 *	linewidth: <float>,
	 *
	 *	scale: <float>,
	 *	dashSize: <float>,
	 *	gapSize: <float>
	 * }
	 */

	class LineDashedMaterial extends LineBasicMaterial {
		constructor(parameters) {
			super();
			this.type = 'LineDashedMaterial';
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
			this.setValues(parameters);
		}

		copy(source) {
			super.copy(source);
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
			return this;
		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	const AnimationUtils = {
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function (array, from, to) {
			if (AnimationUtils.isTypedArray(array)) {
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
			}

			return array.slice(from, to);
		},
		// converts an array to a specific type
		convertArray: function (array, type, forceClone) {
			if (!array || // let 'undefined' and 'null' pass
			!forceClone && array.constructor === type) return array;

			if (typeof type.BYTES_PER_ELEMENT === 'number') {
				return new type(array); // create typed array
			}

			return Array.prototype.slice.call(array); // create Array
		},
		isTypedArray: function (object) {
			return ArrayBuffer.isView(object) && !(object instanceof DataView);
		},
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function (times) {
			function compareTime(i, j) {
				return times[i] - times[j];
			}

			const n = times.length;
			const result = new Array(n);

			for (let i = 0; i !== n; ++i) result[i] = i;

			result.sort(compareTime);
			return result;
		},
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function (values, stride, order) {
			const nValues = values.length;
			const result = new values.constructor(nValues);

			for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
				const srcOffset = order[i] * stride;

				for (let j = 0; j !== stride; ++j) {
					result[dstOffset++] = values[srcOffset + j];
				}
			}

			return result;
		},
		// function for parsing AOS keyframe formats
		flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
			let i = 1,
					key = jsonKeys[0];

			while (key !== undefined && key[valuePropertyName] === undefined) {
				key = jsonKeys[i++];
			}

			if (key === undefined) return; // no data

			let value = key[valuePropertyName];
			if (value === undefined) return; // no data

			if (Array.isArray(value)) {
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push.apply(values, value); // push all elements
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else if (value.toArray !== undefined) {
				// ...assume THREE.Math-ish
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						value.toArray(values, values.length);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			} else {
				// otherwise push as-is
				do {
					value = key[valuePropertyName];

					if (value !== undefined) {
						times.push(key.time);
						values.push(value);
					}

					key = jsonKeys[i++];
				} while (key !== undefined);
			}
		},
		subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
			const clip = sourceClip.clone();
			clip.name = name;
			const tracks = [];

			for (let i = 0; i < clip.tracks.length; ++i) {
				const track = clip.tracks[i];
				const valueSize = track.getValueSize();
				const times = [];
				const values = [];

				for (let j = 0; j < track.times.length; ++j) {
					const frame = track.times[j] * fps;
					if (frame < startFrame || frame >= endFrame) continue;
					times.push(track.times[j]);

					for (let k = 0; k < valueSize; ++k) {
						values.push(track.values[j * valueSize + k]);
					}
				}

				if (times.length === 0) continue;
				track.times = AnimationUtils.convertArray(times, track.times.constructor);
				track.values = AnimationUtils.convertArray(values, track.values.constructor);
				tracks.push(track);
			}

			clip.tracks = tracks; // find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity;

			for (let i = 0; i < clip.tracks.length; ++i) {
				if (minStartTime > clip.tracks[i].times[0]) {
					minStartTime = clip.tracks[i].times[0];
				}
			} // shift all tracks such that clip begins at t=0


			for (let i = 0; i < clip.tracks.length; ++i) {
				clip.tracks[i].shift(-1 * minStartTime);
			}

			clip.resetDuration();
			return clip;
		},
		makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
			if (fps <= 0) fps = 30;
			const numTracks = referenceClip.tracks.length;
			const referenceTime = referenceFrame / fps; // Make each track's values relative to the values at the reference frame

			for (let i = 0; i < numTracks; ++i) {
				const referenceTrack = referenceClip.tracks[i];
				const referenceTrackType = referenceTrack.ValueTypeName; // Skip this track if it's non-numeric

				if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue; // Find the track in the target clip whose name and type matches the reference track

				const targetTrack = targetClip.tracks.find(function (track) {
					return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
				});
				if (targetTrack === undefined) continue;
				let referenceOffset = 0;
				const referenceValueSize = referenceTrack.getValueSize();

				if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					referenceOffset = referenceValueSize / 3;
				}

				let targetOffset = 0;
				const targetValueSize = targetTrack.getValueSize();

				if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
					targetOffset = targetValueSize / 3;
				}

				const lastIndex = referenceTrack.times.length - 1;
				let referenceValue; // Find the value to subtract out of the track

				if (referenceTime <= referenceTrack.times[0]) {
					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else if (referenceTime >= referenceTrack.times[lastIndex]) {
					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset;
					const endIndex = startIndex + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
				} else {
					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant();
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					interpolant.evaluate(referenceTime);
					referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
				} // Conjugate the quaternion


				if (referenceTrackType === 'quaternion') {
					const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
					referenceQuat.toArray(referenceValue);
				} // Subtract the reference value from all of the track values


				const numTimes = targetTrack.times.length;

				for (let j = 0; j < numTimes; ++j) {
					const valueStart = j * targetValueSize + targetOffset;

					if (referenceTrackType === 'quaternion') {
						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
					} else {
						const valueEnd = targetValueSize - targetOffset * 2; // Subtract each value for all other numeric track types

						for (let k = 0; k < valueEnd; ++k) {
							targetTrack.values[valueStart + k] -= referenceValue[k];
						}
					}
				}
			}

			targetClip.blendMode = AdditiveAnimationBlendMode;
			return targetClip;
		}
	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */
	class Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
			this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
			this.settings = null;
			this.DefaultSettings_ = {};
		}

		evaluate(t) {
			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
					t1 = pp[i1],
					t0 = pp[i1 - 1];

			validate_interval: {
				seek: {
					let right;

					linear_scan: {
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if (!(t < t1)) {
							for (let giveUpAt = i1 + 2;;) {
								if (t1 === undefined) {
									if (t < t0) break forward_scan; // after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t, t0);
								}

								if (i1 === giveUpAt) break; // this loop

								t0 = t1;
								t1 = pp[++i1];

								if (t < t1) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the right side of the index


							right = pp.length;
							break linear_scan;
						} //- slower code:
						//-					if ( t < t0 || t0 === undefined ) {


						if (!(t >= t0)) {
							// looping?
							const t1global = pp[1];

							if (t < t1global) {
								i1 = 2; // + 1, using the scan for the details

								t0 = t1global;
							} // linear reverse scan


							for (let giveUpAt = i1 - 2;;) {
								if (t0 === undefined) {
									// before start
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (i1 === giveUpAt) break; // this loop

								t1 = t0;
								t0 = pp[--i1 - 1];

								if (t >= t0) {
									// we have arrived at the sought interval
									break seek;
								}
							} // prepare binary search on the left side of the index


							right = i1;
							i1 = 0;
							break linear_scan;
						} // the interval is valid


						break validate_interval;
					} // linear scan
					// binary search


					while (i1 < right) {
						const mid = i1 + right >>> 1;

						if (t < pp[mid]) {
							right = mid;
						} else {
							i1 = mid + 1;
						}
					}

					t1 = pp[i1];
					t0 = pp[i1 - 1]; // check boundary cases, again

					if (t0 === undefined) {
						this._cachedIndex = 0;
						return this.beforeStart_(0, t, t1);
					}

					if (t1 === undefined) {
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_(i1 - 1, t0, t);
					}
				} // seek


				this._cachedIndex = i1;
				this.intervalChanged_(i1, t0, t1);
			} // validate_interval


			return this.interpolate_(i1, t0, t, t1);
		}

		getSettings_() {
			return this.settings || this.DefaultSettings_;
		}

		copySampleValue_(index) {
			// copies a sample value to the result buffer
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset = index * stride;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset + i];
			}

			return result;
		} // Template methods for derived classes:


		interpolate_()
		/* i1, t0, t, t1 */
		{
			throw new Error('call to abstract method'); // implementations shall return this.resultBuffer
		}

		intervalChanged_()
		/* i1, t0, t1 */
		{// empty
		}

	} // ALIAS DEFINITIONS


	Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
	Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	class CubicInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
			this.DefaultSettings_ = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};
		}

		intervalChanged_(i1, t0, t1) {
			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
					iNext = i1 + 1,
					tPrev = pp[iPrev],
					tNext = pp[iNext];

			if (tPrev === undefined) {
				switch (this.getSettings_().endingStart) {
					case ZeroSlopeEnding:
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
				}
			}

			if (tNext === undefined) {
				switch (this.getSettings_().endingEnd) {
					case ZeroSlopeEnding:
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
						break;

					case WrapAroundEnding:
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[1] - pp[0];
						break;

					default:
						// ZeroCurvatureEnding
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
				}
			}

			const halfDt = (t1 - t0) * 0.5,
						stride = this.valueSize;
			this._weightPrev = halfDt / (t0 - tPrev);
			this._weightNext = halfDt / (tNext - t1);
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						o1 = i1 * stride,
						o0 = o1 - stride,
						oP = this._offsetPrev,
						oN = this._offsetNext,
						wP = this._weightPrev,
						wN = this._weightNext,
						p = (t - t0) / (t1 - t0),
						pp = p * p,
						ppp = pp * p; // evaluate polynomials

			const sP = -wP * ppp + 2 * wP * pp - wP * p;
			const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
			const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp; // combine data linearly

			for (let i = 0; i !== stride; ++i) {
				result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
			}

			return result;
		}

	}

	class LinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						offset1 = i1 * stride,
						offset0 = offset1 - stride,
						weight1 = (t - t0) / (t1 - t0),
						weight0 = 1 - weight1;

			for (let i = 0; i !== stride; ++i) {
				result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
			}

			return result;
		}

	}

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	class DiscreteInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1
		/*, t0, t, t1 */
		) {
			return this.copySampleValue_(i1 - 1);
		}

	}

	class KeyframeTrack {
		constructor(name, times, values, interpolation) {
			if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
			if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
			this.name = name;
			this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
			this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
			this.setInterpolation(interpolation || this.DefaultInterpolation);
		} // Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):


		static toJSON(track) {
			const trackType = track.constructor;
			let json; // derived classes can define a static toJSON method

			if (trackType.toJSON !== this.toJSON) {
				json = trackType.toJSON(track);
			} else {
				// by default, we assume the data can be serialized as-is
				json = {
					'name': track.name,
					'times': AnimationUtils.convertArray(track.times, Array),
					'values': AnimationUtils.convertArray(track.values, Array)
				};
				const interpolation = track.getInterpolation();

				if (interpolation !== track.DefaultInterpolation) {
					json.interpolation = interpolation;
				}
			}

			json.type = track.ValueTypeName; // mandatory

			return json;
		}

		InterpolantFactoryMethodDiscrete(result) {
			return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodLinear(result) {
			return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		InterpolantFactoryMethodSmooth(result) {
			return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
		}

		setInterpolation(interpolation) {
			let factoryMethod;

			switch (interpolation) {
				case InterpolateDiscrete:
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
					break;

				case InterpolateLinear:
					factoryMethod = this.InterpolantFactoryMethodLinear;
					break;

				case InterpolateSmooth:
					factoryMethod = this.InterpolantFactoryMethodSmooth;
					break;
			}

			if (factoryMethod === undefined) {
				const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;

				if (this.createInterpolant === undefined) {
					// fall back to default, unless the default itself is messed up
					if (interpolation !== this.DefaultInterpolation) {
						this.setInterpolation(this.DefaultInterpolation);
					} else {
						throw new Error(message); // fatal, in this case
					}
				}

				console.warn('THREE.KeyframeTrack:', message);
				return this;
			}

			this.createInterpolant = factoryMethod;
			return this;
		}

		getInterpolation() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:
					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:
					return InterpolateSmooth;
			}
		}

		getValueSize() {
			return this.values.length / this.times.length;
		} // move all keyframes either forwards or backwards in time


		shift(timeOffset) {
			if (timeOffset !== 0.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] += timeOffset;
				}
			}

			return this;
		} // scale all keyframe times by a factor (useful for frame <-> seconds conversions)


		scale(timeScale) {
			if (timeScale !== 1.0) {
				const times = this.times;

				for (let i = 0, n = times.length; i !== n; ++i) {
					times[i] *= timeScale;
				}
			}

			return this;
		} // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values


		trim(startTime, endTime) {
			const times = this.times,
						nKeys = times.length;
			let from = 0,
					to = nKeys - 1;

			while (from !== nKeys && times[from] < startTime) {
				++from;
			}

			while (to !== -1 && times[to] > endTime) {
				--to;
			}

			++to; // inclusive -> exclusive bound

			if (from !== 0 || to !== nKeys) {
				// empty tracks are forbidden, so keep at least one keyframe
				if (from >= to) {
					to = Math.max(to, 1);
					from = to - 1;
				}

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice(times, from, to);
				this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
			}

			return this;
		} // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable


		validate() {
			let valid = true;
			const valueSize = this.getValueSize();

			if (valueSize - Math.floor(valueSize) !== 0) {
				console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
				valid = false;
			}

			const times = this.times,
						values = this.values,
						nKeys = times.length;

			if (nKeys === 0) {
				console.error('THREE.KeyframeTrack: Track is empty.', this);
				valid = false;
			}

			let prevTime = null;

			for (let i = 0; i !== nKeys; i++) {
				const currTime = times[i];

				if (typeof currTime === 'number' && isNaN(currTime)) {
					console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
					valid = false;
					break;
				}

				if (prevTime !== null && prevTime > currTime) {
					console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
					valid = false;
					break;
				}

				prevTime = currTime;
			}

			if (values !== undefined) {
				if (AnimationUtils.isTypedArray(values)) {
					for (let i = 0, n = values.length; i !== n; ++i) {
						const value = values[i];

						if (isNaN(value)) {
							console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
							valid = false;
							break;
						}
					}
				}
			}

			return valid;
		} // removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)


		optimize() {
			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice(this.times),
						values = AnimationUtils.arraySlice(this.values),
						stride = this.getValueSize(),
						smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
						lastIndex = times.length - 1;
			let writeIndex = 1;

			for (let i = 1; i < lastIndex; ++i) {
				let keep = false;
				const time = times[i];
				const timeNext = times[i + 1]; // remove adjacent keyframes scheduled at the same time

				if (time !== timeNext && (i !== 1 || time !== times[0])) {
					if (!smoothInterpolation) {
						// remove unnecessary keyframes same as their neighbors
						const offset = i * stride,
									offsetP = offset - stride,
									offsetN = offset + stride;

						for (let j = 0; j !== stride; ++j) {
							const value = values[offset + j];

							if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
								keep = true;
								break;
							}
						}
					} else {
						keep = true;
					}
				} // in-place compaction


				if (keep) {
					if (i !== writeIndex) {
						times[writeIndex] = times[i];
						const readOffset = i * stride,
									writeOffset = writeIndex * stride;

						for (let j = 0; j !== stride; ++j) {
							values[writeOffset + j] = values[readOffset + j];
						}
					}

					++writeIndex;
				}
			} // flush last keyframe (compaction looks ahead)


			if (lastIndex > 0) {
				times[writeIndex] = times[lastIndex];

				for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
					values[writeOffset + j] = values[readOffset + j];
				}

				++writeIndex;
			}

			if (writeIndex !== times.length) {
				this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
				this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
			} else {
				this.times = times;
				this.values = values;
			}

			return this;
		}

		clone() {
			const times = AnimationUtils.arraySlice(this.times, 0);
			const values = AnimationUtils.arraySlice(this.values, 0);
			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack(this.name, times, values); // Interpolant argument to constructor is not saved, so copy the factory method directly.

			track.createInterpolant = this.createInterpolant;
			return track;
		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */

	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined; // Note: Actually this track could have a optimized / compressed

	/**
	 * A Track of keyframe values that represent color.
	 */

	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color'; // ValueBufferType is inherited

	/**
	 * A Track of numeric keyframe values.
	 */

	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number'; // ValueBufferType is inherited

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	class QuaternionLinearInterpolant extends Interpolant {
		constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
			super(parameterPositions, sampleValues, sampleSize, resultBuffer);
		}

		interpolate_(i1, t0, t, t1) {
			const result = this.resultBuffer,
						values = this.sampleValues,
						stride = this.valueSize,
						alpha = (t - t0) / (t1 - t0);
			let offset = i1 * stride;

			for (let end = offset + stride; offset !== end; offset += 4) {
				Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
			}

			return result;
		}

	}

	/**
	 * A Track of quaternion keyframe values.
	 */

	class QuaternionKeyframeTrack extends KeyframeTrack {
		InterpolantFactoryMethodLinear(result) {
			return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'; // ValueBufferType is inherited

	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */

	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */

	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector'; // ValueBufferType is inherited

	class AnimationClip {
		constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;
			this.uuid = generateUUID(); // this means it should figure out its duration by scanning the tracks

			if (this.duration < 0) {
				this.resetDuration();
			}
		}

		static parse(json) {
			const tracks = [],
						jsonTracks = json.tracks,
						frameTime = 1.0 / (json.fps || 1.0);

			for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
				tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
			}

			const clip = new this(json.name, json.duration, tracks, json.blendMode);
			clip.uuid = json.uuid;
			return clip;
		}

		static toJSON(clip) {
			const tracks = [],
						clipTracks = clip.tracks;
			const json = {
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode
			};

			for (let i = 0, n = clipTracks.length; i !== n; ++i) {
				tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
			}

			return json;
		}

		static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for (let i = 0; i < numMorphTargets; i++) {
				let times = [];
				let values = [];
				times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
				values.push(0, 1, 0);
				const order = AnimationUtils.getKeyframeOrder(times);
				times = AnimationUtils.sortedArray(times, 1, order);
				values = AnimationUtils.sortedArray(values, 1, order); // if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.

				if (!noLoop && times[0] === 0) {
					times.push(numMorphTargets);
					values.push(values[0]);
				}

				tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
			}

			return new this(name, -1, tracks);
		}

		static findByName(objectOrClipArray, name) {
			let clipArray = objectOrClipArray;

			if (!Array.isArray(objectOrClipArray)) {
				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
			}

			for (let i = 0; i < clipArray.length; i++) {
				if (clipArray[i].name === name) {
					return clipArray[i];
				}
			}

			return null;
		}

		static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
			const animationToMorphTargets = {}; // tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059

			const pattern = /^([\w-]*?)([\d]+)$/; // sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002

			for (let i = 0, il = morphTargets.length; i < il; i++) {
				const morphTarget = morphTargets[i];
				const parts = morphTarget.name.match(pattern);

				if (parts && parts.length > 1) {
					const name = parts[1];
					let animationMorphTargets = animationToMorphTargets[name];

					if (!animationMorphTargets) {
						animationToMorphTargets[name] = animationMorphTargets = [];
					}

					animationMorphTargets.push(morphTarget);
				}
			}

			const clips = [];

			for (const name in animationToMorphTargets) {
				clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
			}

			return clips;
		} // parse the animation.hierarchy format


		static parseAnimation(animation, bones) {
			if (!animation) {
				console.error('THREE.AnimationClip: No animation in JSONLoader data.');
				return null;
			}

			const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
				// only return track if there are actually keys.
				if (animationKeys.length !== 0) {
					const times = [];
					const values = [];
					AnimationUtils.flattenJSON(animationKeys, times, values, propertyName); // empty keys are filtered out, so check again

					if (times.length !== 0) {
						destTracks.push(new trackType(trackName, times, values));
					}
				}
			};

			const tracks = [];
			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode; // automatic length determination in AnimationClip.

			let duration = animation.length || -1;
			const hierarchyTracks = animation.hierarchy || [];

			for (let h = 0; h < hierarchyTracks.length; h++) {
				const animationKeys = hierarchyTracks[h].keys; // skip empty tracks

				if (!animationKeys || animationKeys.length === 0) continue; // process morph targets

				if (animationKeys[0].morphTargets) {
					// figure out all morph targets used in this track
					const morphTargetNames = {};
					let k;

					for (k = 0; k < animationKeys.length; k++) {
						if (animationKeys[k].morphTargets) {
							for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
								morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
							}
						}
					} // create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.


					for (const morphTargetName in morphTargetNames) {
						const times = [];
						const values = [];

						for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
							const animationKey = animationKeys[k];
							times.push(animationKey.time);
							values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
						}

						tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
					}

					duration = morphTargetNames.length * (fps || 1.0);
				} else {
					// ...assume skeletal animation
					const boneName = '.bones[' + bones[h].name + ']';
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
					addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
					addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
				}
			}

			if (tracks.length === 0) {
				return null;
			}

			const clip = new this(clipName, duration, tracks, blendMode);
			return clip;
		}

		resetDuration() {
			const tracks = this.tracks;
			let duration = 0;

			for (let i = 0, n = tracks.length; i !== n; ++i) {
				const track = this.tracks[i];
				duration = Math.max(duration, track.times[track.times.length - 1]);
			}

			this.duration = duration;
			return this;
		}

		trim() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].trim(0, this.duration);
			}

			return this;
		}

		validate() {
			let valid = true;

			for (let i = 0; i < this.tracks.length; i++) {
				valid = valid && this.tracks[i].validate();
			}

			return valid;
		}

		optimize() {
			for (let i = 0; i < this.tracks.length; i++) {
				this.tracks[i].optimize();
			}

			return this;
		}

		clone() {
			const tracks = [];

			for (let i = 0; i < this.tracks.length; i++) {
				tracks.push(this.tracks[i].clone());
			}

			return new this.constructor(this.name, this.duration, tracks, this.blendMode);
		}

		toJSON() {
			return this.constructor.toJSON(this);
		}

	}

	function getTrackTypeForValueTypeName(typeName) {
		switch (typeName.toLowerCase()) {
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
				return VectorKeyframeTrack;

			case 'color':
				return ColorKeyframeTrack;

			case 'quaternion':
				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':
				return BooleanKeyframeTrack;

			case 'string':
				return StringKeyframeTrack;
		}

		throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
	}

	function parseKeyframeTrack(json) {
		if (json.type === undefined) {
			throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
		}

		const trackType = getTrackTypeForValueTypeName(json.type);

		if (json.times === undefined) {
			const times = [],
						values = [];
			AnimationUtils.flattenJSON(json.keys, times, values, 'value');
			json.times = times;
			json.values = values;
		} // derived classes can define a static parse method


		if (trackType.parse !== undefined) {
			return trackType.parse(json);
		} else {
			// by default, we assume a constructor compatible with the base
			return new trackType(json.name, json.times, json.values, json.interpolation);
		}
	}

	const Cache = {
		enabled: false,
		files: {},
		add: function (key, file) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[key] = file;
		},
		get: function (key) {
			if (this.enabled === false) return; // console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[key];
		},
		remove: function (key) {
			delete this.files[key];
		},
		clear: function () {
			this.files = {};
		}
	};

	class LoadingManager {
		constructor(onLoad, onProgress, onError) {
			const scope = this;
			let isLoading = false;
			let itemsLoaded = 0;
			let itemsTotal = 0;
			let urlModifier = undefined;
			const handlers = []; // Refer to #5689 for the reason why we don't set .onStart
			// in the constructor

			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;

			this.itemStart = function (url) {
				itemsTotal++;

				if (isLoading === false) {
					if (scope.onStart !== undefined) {
						scope.onStart(url, itemsLoaded, itemsTotal);
					}
				}

				isLoading = true;
			};

			this.itemEnd = function (url) {
				itemsLoaded++;

				if (scope.onProgress !== undefined) {
					scope.onProgress(url, itemsLoaded, itemsTotal);
				}

				if (itemsLoaded === itemsTotal) {
					isLoading = false;

					if (scope.onLoad !== undefined) {
						scope.onLoad();
					}
				}
			};

			this.itemError = function (url) {
				if (scope.onError !== undefined) {
					scope.onError(url);
				}
			};

			this.resolveURL = function (url) {
				if (urlModifier) {
					return urlModifier(url);
				}

				return url;
			};

			this.setURLModifier = function (transform) {
				urlModifier = transform;
				return this;
			};

			this.addHandler = function (regex, loader) {
				handlers.push(regex, loader);
				return this;
			};

			this.removeHandler = function (regex) {
				const index = handlers.indexOf(regex);

				if (index !== -1) {
					handlers.splice(index, 2);
				}

				return this;
			};

			this.getHandler = function (file) {
				for (let i = 0, l = handlers.length; i < l; i += 2) {
					const regex = handlers[i];
					const loader = handlers[i + 1];
					if (regex.global) regex.lastIndex = 0; // see #17920

					if (regex.test(file)) {
						return loader;
					}
				}

				return null;
			};
		}

	}

	const DefaultLoadingManager = new LoadingManager();

	class Loader {
		constructor(manager) {
			this.manager = manager !== undefined ? manager : DefaultLoadingManager;
			this.crossOrigin = 'anonymous';
			this.withCredentials = false;
			this.path = '';
			this.resourcePath = '';
			this.requestHeader = {};
		}

		load()
		/* url, onLoad, onProgress, onError */
		{}

		loadAsync(url, onProgress) {
			const scope = this;
			return new Promise(function (resolve, reject) {
				scope.load(url, resolve, onProgress, reject);
			});
		}

		parse()
		/* data */
		{}

		setCrossOrigin(crossOrigin) {
			this.crossOrigin = crossOrigin;
			return this;
		}

		setWithCredentials(value) {
			this.withCredentials = value;
			return this;
		}

		setPath(path) {
			this.path = path;
			return this;
		}

		setResourcePath(resourcePath) {
			this.resourcePath = resourcePath;
			return this;
		}

		setRequestHeader(requestHeader) {
			this.requestHeader = requestHeader;
			return this;
		}

	}

	const loading = {};

	class FileLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			} // Check if request is duplicate


			if (loading[url] !== undefined) {
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				return;
			} // Check for data: URI


			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			const dataUriRegexResult = url.match(dataUriRegex);
			let request; // Safari can not handle Data URIs through XMLHttpRequest so process manually

			if (dataUriRegexResult) {
				const mimeType = dataUriRegexResult[1];
				const isBase64 = !!dataUriRegexResult[2];
				let data = dataUriRegexResult[3];
				data = decodeURIComponent(data);
				if (isBase64) data = atob(data);

				try {
					let response;
					const responseType = (this.responseType || '').toLowerCase();

					switch (responseType) {
						case 'arraybuffer':
						case 'blob':
							const view = new Uint8Array(data.length);

							for (let i = 0; i < data.length; i++) {
								view[i] = data.charCodeAt(i);
							}

							if (responseType === 'blob') {
								response = new Blob([view.buffer], {
									type: mimeType
								});
							} else {
								response = view.buffer;
							}

							break;

						case 'document':
							const parser = new DOMParser();
							response = parser.parseFromString(data, mimeType);
							break;

						case 'json':
							response = JSON.parse(data);
							break;

						default:
							// 'text' or other
							response = data;
							break;
					} // Wait for next browser tick like standard XMLHttpRequest event dispatching does


					setTimeout(function () {
						if (onLoad) onLoad(response);
						scope.manager.itemEnd(url);
					}, 0);
				} catch (error) {
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout(function () {
						if (onError) onError(error);
						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}, 0);
				}
			} else {
				// Initialise array for duplicate requests
				loading[url] = [];
				loading[url].push({
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
				});
				request = new XMLHttpRequest();
				request.open('GET', url, true);
				request.addEventListener('load', function (event) {
					const response = this.response;
					const callbacks = loading[url];
					delete loading[url];

					if (this.status === 200 || this.status === 0) {
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
						if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.'); // Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.

						Cache.add(url, response);

						for (let i = 0, il = callbacks.length; i < il; i++) {
							const callback = callbacks[i];
							if (callback.onLoad) callback.onLoad(response);
						}

						scope.manager.itemEnd(url);
					} else {
						for (let i = 0, il = callbacks.length; i < il; i++) {
							const callback = callbacks[i];
							if (callback.onError) callback.onError(event);
						}

						scope.manager.itemError(url);
						scope.manager.itemEnd(url);
					}
				}, false);
				request.addEventListener('progress', function (event) {
					const callbacks = loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onProgress) callback.onProgress(event);
					}
				}, false);
				request.addEventListener('error', function (event) {
					const callbacks = loading[url];
					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				request.addEventListener('abort', function (event) {
					const callbacks = loading[url];
					delete loading[url];

					for (let i = 0, il = callbacks.length; i < il; i++) {
						const callback = callbacks[i];
						if (callback.onError) callback.onError(event);
					}

					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				}, false);
				if (this.responseType !== undefined) request.responseType = this.responseType;
				if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
				if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

				for (const header in this.requestHeader) {
					request.setRequestHeader(header, this.requestHeader[header]);
				}

				request.send(null);
			}

			scope.manager.itemStart(url);
			return request;
		}

		setResponseType(value) {
			this.responseType = value;
			return this;
		}

		setMimeType(value) {
			this.mimeType = value;
			return this;
		}

	}

	class AnimationLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const animations = [];

			for (let i = 0; i < json.length; i++) {
				const clip = AnimationClip.parse(json[i]);
				animations.push(clip);
			}

			return animations;
		}

	}

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class CompressedTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const images = [];
			const texture = new CompressedTexture();
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(url[i], function (buffer) {
					const texDatas = scope.parse(buffer, true);
					images[i] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
					loaded += 1;

					if (loaded === 6) {
						if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, onProgress, onError);
			}

			if (Array.isArray(url)) {
				for (let i = 0, il = url.length; i < il; ++i) {
					loadTexture(i);
				}
			} else {
				// compressed cubemap texture stored in a single DDS file
				loader.load(url, function (buffer) {
					const texDatas = scope.parse(buffer, true);

					if (texDatas.isCubemap) {
						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for (let f = 0; f < faces; f++) {
							images[f] = {
								mipmaps: []
							};

							for (let i = 0; i < texDatas.mipmapCount; i++) {
								images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
								images[f].format = texDatas.format;
								images[f].width = texDatas.width;
								images[f].height = texDatas.height;
							}
						}

						texture.image = images;
					} else {
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
					}

					if (texDatas.mipmapCount === 1) {
						texture.minFilter = LinearFilter;
					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;
					if (onLoad) onLoad(texture);
				}, onProgress, onError);
			}

			return texture;
		}

	}

	class ImageLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const image = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');

			function onImageLoad() {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				Cache.add(url, this);
				if (onLoad) onLoad(this);
				scope.manager.itemEnd(url);
			}

			function onImageError(event) {
				image.removeEventListener('load', onImageLoad, false);
				image.removeEventListener('error', onImageError, false);
				if (onError) onError(event);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			}

			image.addEventListener('load', onImageLoad, false);
			image.addEventListener('error', onImageError, false);

			if (url.substr(0, 5) !== 'data:') {
				if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
			}

			scope.manager.itemStart(url);
			image.src = url;
			return image;
		}

	}

	class CubeTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(urls, onLoad, onProgress, onError) {
			const texture = new CubeTexture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			let loaded = 0;

			function loadTexture(i) {
				loader.load(urls[i], function (image) {
					texture.images[i] = image;
					loaded++;

					if (loaded === 6) {
						texture.needsUpdate = true;
						if (onLoad) onLoad(texture);
					}
				}, undefined, onError);
			}

			for (let i = 0; i < urls.length; ++i) {
				loadTexture(i);
			}

			return texture;
		}

	}

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	class DataTextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const texture = new DataTexture();
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setRequestHeader(this.requestHeader);
			loader.setPath(this.path);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (buffer) {
				const texData = scope.parse(buffer);
				if (!texData) return;

				if (texData.image !== undefined) {
					texture.image = texData.image;
				} else if (texData.data !== undefined) {
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if (texData.encoding !== undefined) {
					texture.encoding = texData.encoding;
				}

				if (texData.flipY !== undefined) {
					texture.flipY = texData.flipY;
				}

				if (texData.format !== undefined) {
					texture.format = texData.format;
				}

				if (texData.type !== undefined) {
					texture.type = texData.type;
				}

				if (texData.mipmaps !== undefined) {
					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...
				}

				if (texData.mipmapCount === 1) {
					texture.minFilter = LinearFilter;
				}

				if (texData.generateMipmaps !== undefined) {
					texture.generateMipmaps = texData.generateMipmaps;
				}

				texture.needsUpdate = true;
				if (onLoad) onLoad(texture, texData);
			}, onProgress, onError);
			return texture;
		}

	}

	class TextureLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const texture = new Texture();
			const loader = new ImageLoader(this.manager);
			loader.setCrossOrigin(this.crossOrigin);
			loader.setPath(this.path);
			loader.load(url, function (image) {
				texture.image = image; // JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.

				const isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if (onLoad !== undefined) {
					onLoad(texture);
				}
			}, onProgress, onError);
			return texture;
		}

	}

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *	curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {
		constructor() {
			super();
			this.type = 'CurvePath';
			this.curves = [];
			this.autoClose = false; // Automatically closes the path
		}

		add(curve) {
			this.curves.push(curve);
		}

		closePath() {
			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[0].getPoint(0);
			const endPoint = this.curves[this.curves.length - 1].getPoint(1);

			if (!startPoint.equals(endPoint)) {
				this.curves.push(new LineCurve(endPoint, startPoint));
			}
		} // To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')


		getPoint(t) {
			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0; // To think about boundaries points.

			while (i < curveLengths.length) {
				if (curveLengths[i] >= d) {
					const diff = curveLengths[i] - d;
					const curve = this.curves[i];
					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
					return curve.getPointAt(u);
				}

				i++;
			}

			return null; // loop where sum != 0, sum > d , sum+1 <d
		} // We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength


		getLength() {
			const lens = this.getCurveLengths();
			return lens[lens.length - 1];
		} // cacheLengths must be recalculated.


		updateArcLengths() {
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
		} // Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.


		getCurveLengths() {
			// We use cache values if curves and cache array are same length
			if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
				return this.cacheLengths;
			} // Get length of sub-curve
			// Push sums into cached array


			const lengths = [];
			let sums = 0;

			for (let i = 0, l = this.curves.length; i < l; i++) {
				sums += this.curves[i].getLength();
				lengths.push(sums);
			}

			this.cacheLengths = lengths;
			return lengths;
		}

		getSpacedPoints(divisions = 40) {
			const points = [];

			for (let i = 0; i <= divisions; i++) {
				points.push(this.getPoint(i / divisions));
			}

			if (this.autoClose) {
				points.push(points[0]);
			}

			return points;
		}

		getPoints(divisions = 12) {
			const points = [];
			let last;

			for (let i = 0, curves = this.curves; i < curves.length; i++) {
				const curve = curves[i];
				const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
				const pts = curve.getPoints(resolution);

				for (let j = 0; j < pts.length; j++) {
					const point = pts[j];
					if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

					points.push(point);
					last = point;
				}
			}

			if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
				points.push(points[0]);
			}

			return points;
		}

		copy(source) {
			super.copy(source);
			this.curves = [];

			for (let i = 0, l = source.curves.length; i < l; i++) {
				const curve = source.curves[i];
				this.curves.push(curve.clone());
			}

			this.autoClose = source.autoClose;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.autoClose = this.autoClose;
			data.curves = [];

			for (let i = 0, l = this.curves.length; i < l; i++) {
				const curve = this.curves[i];
				data.curves.push(curve.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.autoClose = json.autoClose;
			this.curves = [];

			for (let i = 0, l = json.curves.length; i < l; i++) {
				const curve = json.curves[i];
				this.curves.push(new Curves[curve.type]().fromJSON(curve));
			}

			return this;
		}

	}

	class Path extends CurvePath {
		constructor(points) {
			super();
			this.type = 'Path';
			this.currentPoint = new Vector2();

			if (points) {
				this.setFromPoints(points);
			}
		}

		setFromPoints(points) {
			this.moveTo(points[0].x, points[0].y);

			for (let i = 1, l = points.length; i < l; i++) {
				this.lineTo(points[i].x, points[i].y);
			}

			return this;
		}

		moveTo(x, y) {
			this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

			return this;
		}

		lineTo(x, y) {
			const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
			this.curves.push(curve);
			this.currentPoint.set(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
			this.curves.push(curve);
			this.currentPoint.set(aX, aY);
			return this;
		}

		splineThru(pts
		/*Array of Vector*/
		) {
			const npts = [this.currentPoint.clone()].concat(pts);
			const curve = new SplineCurve(npts);
			this.curves.push(curve);
			this.currentPoint.copy(pts[pts.length - 1]);
			return this;
		}

		arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
			this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
			return this;
		}

		ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;
			this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
			return this;
		}

		absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
			const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);

			if (this.curves.length > 0) {
				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint(0);

				if (!firstPoint.equals(this.currentPoint)) {
					this.lineTo(firstPoint.x, firstPoint.y);
				}
			}

			this.curves.push(curve);
			const lastPoint = curve.getPoint(1);
			this.currentPoint.copy(lastPoint);
			return this;
		}

		copy(source) {
			super.copy(source);
			this.currentPoint.copy(source.currentPoint);
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.currentPoint = this.currentPoint.toArray();
			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.currentPoint.fromArray(json.currentPoint);
			return this;
		}

	}

	class Shape extends Path {
		constructor(points) {
			super(points);
			this.uuid = generateUUID();
			this.type = 'Shape';
			this.holes = [];
		}

		getPointsHoles(divisions) {
			const holesPts = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				holesPts[i] = this.holes[i].getPoints(divisions);
			}

			return holesPts;
		} // get points of shape and holes (keypoints based on segments parameter)


		extractPoints(divisions) {
			return {
				shape: this.getPoints(divisions),
				holes: this.getPointsHoles(divisions)
			};
		}

		copy(source) {
			super.copy(source);
			this.holes = [];

			for (let i = 0, l = source.holes.length; i < l; i++) {
				const hole = source.holes[i];
				this.holes.push(hole.clone());
			}

			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.uuid = this.uuid;
			data.holes = [];

			for (let i = 0, l = this.holes.length; i < l; i++) {
				const hole = this.holes[i];
				data.holes.push(hole.toJSON());
			}

			return data;
		}

		fromJSON(json) {
			super.fromJSON(json);
			this.uuid = json.uuid;
			this.holes = [];

			for (let i = 0, l = json.holes.length; i < l; i++) {
				const hole = json.holes[i];
				this.holes.push(new Path().fromJSON(hole));
			}

			return this;
		}

	}

	class Light extends Object3D {
		constructor(color, intensity = 1) {
			super();
			this.type = 'Light';
			this.color = new Color(color);
			this.intensity = intensity;
		}

		dispose() {// Empty here in base class; some subclasses override.
		}

		copy(source) {
			super.copy(source);
			this.color.copy(source.color);
			this.intensity = source.intensity;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
			if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
			if (this.distance !== undefined) data.object.distance = this.distance;
			if (this.angle !== undefined) data.object.angle = this.angle;
			if (this.decay !== undefined) data.object.decay = this.decay;
			if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
			if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
			return data;
		}

	}

	Light.prototype.isLight = true;

	class HemisphereLight extends Light {
		constructor(skyColor, groundColor, intensity) {
			super(skyColor, intensity);
			this.type = 'HemisphereLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.groundColor = new Color(groundColor);
		}

		copy(source) {
			Light.prototype.copy.call(this, source);
			this.groundColor.copy(source.groundColor);
			return this;
		}

	}

	HemisphereLight.prototype.isHemisphereLight = true;

	const _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld$1 = /*@__PURE__*/new Vector3();

	const _lookTarget$1 = /*@__PURE__*/new Vector3();

	class LightShadow {
		constructor(camera) {
			this.camera = camera;
			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;
			this.mapSize = new Vector2(512, 512);
			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();
			this.autoUpdate = true;
			this.needsUpdate = false;
			this._frustum = new Frustum();
			this._frameExtents = new Vector2(1, 1);
			this._viewportCount = 1;
			this._viewports = [new Vector4(0, 0, 1, 1)];
		}

		getViewportCount() {
			return this._viewportCount;
		}

		getFrustum() {
			return this._frustum;
		}

		updateMatrices(light) {
			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);

			shadowCamera.position.copy(_lightPositionWorld$1);

			_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);

			shadowCamera.lookAt(_lookTarget$1);
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);

			shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
			shadowMatrix.multiply(shadowCamera.projectionMatrix);
			shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
		}

		getViewport(viewportIndex) {
			return this._viewports[viewportIndex];
		}

		getFrameExtents() {
			return this._frameExtents;
		}

		dispose() {
			if (this.map) {
				this.map.dispose();
			}

			if (this.mapPass) {
				this.mapPass.dispose();
			}
		}

		copy(source) {
			this.camera = source.camera.clone();
			this.bias = source.bias;
			this.radius = source.radius;
			this.mapSize.copy(source.mapSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const object = {};
			if (this.bias !== 0) object.bias = this.bias;
			if (this.normalBias !== 0) object.normalBias = this.normalBias;
			if (this.radius !== 1) object.radius = this.radius;
			if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
			object.camera = this.camera.toJSON(false).object;
			delete object.camera.matrix;
			return object;
		}

	}

	class SpotLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(50, 1, 0.5, 500));
			this.focus = 1;
		}

		updateMatrices(light) {
			const camera = this.camera;
			const fov = RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			super.updateMatrices(light);
		}

		copy(source) {
			super.copy(source);
			this.focus = source.focus;
			return this;
		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true;

	class SpotLight extends Light {
		constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
			super(color, intensity);
			this.type = 'SpotLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();
		}

		get power() {
			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;
		}

		set power(power) {
			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	SpotLight.prototype.isSpotLight = true;

	const _projScreenMatrix = /*@__PURE__*/new Matrix4();

	const _lightPositionWorld = /*@__PURE__*/new Vector3();

	const _lookTarget = /*@__PURE__*/new Vector3();

	class PointLightShadow extends LightShadow {
		constructor() {
			super(new PerspectiveCamera(90, 1, 0.5, 500));
			this._frameExtents = new Vector2(4, 2);
			this._viewportCount = 6;
			this._viewports = [// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//	xzXZ
			//	 y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction
			// positive X
			new Vector4(2, 1, 1, 1), // negative X
			new Vector4(0, 1, 1, 1), // positive Z
			new Vector4(3, 1, 1, 1), // negative Z
			new Vector4(1, 1, 1, 1), // positive Y
			new Vector4(3, 0, 1, 1), // negative Y
			new Vector4(1, 0, 1, 1)];
			this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
			this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
		}

		updateMatrices(light, viewportIndex = 0) {
			const camera = this.camera;
			const shadowMatrix = this.matrix;
			const far = light.distance || camera.far;

			if (far !== camera.far) {
				camera.far = far;
				camera.updateProjectionMatrix();
			}

			_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);

			camera.position.copy(_lightPositionWorld);

			_lookTarget.copy(camera.position);

			_lookTarget.add(this._cubeDirections[viewportIndex]);

			camera.up.copy(this._cubeUps[viewportIndex]);
			camera.lookAt(_lookTarget);
			camera.updateMatrixWorld();
			shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);

			_projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

			this._frustum.setFromProjectionMatrix(_projScreenMatrix);
		}

	}

	PointLightShadow.prototype.isPointLightShadow = true;

	class PointLight extends Light {
		constructor(color, intensity, distance = 0, decay = 1) {
			super(color, intensity);
			this.type = 'PointLight';
			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();
		}

		get power() {
			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;
		}

		set power(power) {
			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / (4 * Math.PI);
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.distance = source.distance;
			this.decay = source.decay;
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	PointLight.prototype.isPointLight = true;

	class DirectionalLightShadow extends LightShadow {
		constructor() {
			super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	class DirectionalLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'DirectionalLight';
			this.position.copy(Object3D.DefaultUp);
			this.updateMatrix();
			this.target = new Object3D();
			this.shadow = new DirectionalLightShadow();
		}

		dispose() {
			this.shadow.dispose();
		}

		copy(source) {
			super.copy(source);
			this.target = source.target.clone();
			this.shadow = source.shadow.clone();
			return this;
		}

	}

	DirectionalLight.prototype.isDirectionalLight = true;

	class AmbientLight extends Light {
		constructor(color, intensity) {
			super(color, intensity);
			this.type = 'AmbientLight';
		}

	}

	AmbientLight.prototype.isAmbientLight = true;

	class RectAreaLight extends Light {
		constructor(color, intensity, width = 10, height = 10) {
			super(color, intensity);
			this.type = 'RectAreaLight';
			this.width = width;
			this.height = height;
		}

		copy(source) {
			super.copy(source);
			this.width = source.width;
			this.height = source.height;
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.width = this.width;
			data.object.height = this.height;
			return data;
		}

	}

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *	 https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *	 https://www.ppsloan.org/publications/StupidSH36.pdf
	 */
	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {
		constructor() {
			this.coefficients = [];

			for (let i = 0; i < 9; i++) {
				this.coefficients.push(new Vector3());
			}
		}

		set(coefficients) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].copy(coefficients[i]);
			}

			return this;
		}

		zero() {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].set(0, 0, 0);
			}

			return this;
		} // get the radiance in the direction of the normal
		// target is a Vector3


		getAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.282095); // band 1

			target.addScaledVector(coeff[1], 0.488603 * y);
			target.addScaledVector(coeff[2], 0.488603 * z);
			target.addScaledVector(coeff[3], 0.488603 * x); // band 2

			target.addScaledVector(coeff[4], 1.092548 * (x * y));
			target.addScaledVector(coeff[5], 1.092548 * (y * z));
			target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
			target.addScaledVector(coeff[7], 1.092548 * (x * z));
			target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
			return target;
		} // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf


		getIrradianceAt(normal, target) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z;
			const coeff = this.coefficients; // band 0

			target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095
			// band 1

			target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603

			target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
			target.addScaledVector(coeff[3], 2.0 * 0.511664 * x); // band 2

			target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548

			target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
			target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3

			target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
			target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274

			return target;
		}

		add(sh) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].add(sh.coefficients[i]);
			}

			return this;
		}

		addScaledSH(sh, s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].addScaledVector(sh.coefficients[i], s);
			}

			return this;
		}

		scale(s) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].multiplyScalar(s);
			}

			return this;
		}

		lerp(sh, alpha) {
			for (let i = 0; i < 9; i++) {
				this.coefficients[i].lerp(sh.coefficients[i], alpha);
			}

			return this;
		}

		equals(sh) {
			for (let i = 0; i < 9; i++) {
				if (!this.coefficients[i].equals(sh.coefficients[i])) {
					return false;
				}
			}

			return true;
		}

		copy(sh) {
			return this.set(sh.coefficients);
		}

		clone() {
			return new this.constructor().copy(this);
		}

		fromArray(array, offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].fromArray(array, offset + i * 3);
			}

			return this;
		}

		toArray(array = [], offset = 0) {
			const coefficients = this.coefficients;

			for (let i = 0; i < 9; i++) {
				coefficients[i].toArray(array, offset + i * 3);
			}

			return array;
		} // evaluate the basis functions
		// shBasis is an Array[ 9 ]


		static getBasisAt(normal, shBasis) {
			// normal is assumed to be unit length
			const x = normal.x,
						y = normal.y,
						z = normal.z; // band 0

			shBasis[0] = 0.282095; // band 1

			shBasis[1] = 0.488603 * y;
			shBasis[2] = 0.488603 * z;
			shBasis[3] = 0.488603 * x; // band 2

			shBasis[4] = 1.092548 * x * y;
			shBasis[5] = 1.092548 * y * z;
			shBasis[6] = 0.315392 * (3 * z * z - 1);
			shBasis[7] = 1.092548 * x * z;
			shBasis[8] = 0.546274 * (x * x - y * y);
		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	class LightProbe extends Light {
		constructor(sh = new SphericalHarmonics3(), intensity = 1) {
			super(undefined, intensity);
			this.sh = sh;
		}

		copy(source) {
			super.copy(source);
			this.sh.copy(source.sh);
			return this;
		}

		fromJSON(json) {
			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();

			this.sh.fromArray(json.sh);
			return this;
		}

		toJSON(meta) {
			const data = super.toJSON(meta);
			data.object.sh = this.sh.toArray();
			return data;
		}

	}

	LightProbe.prototype.isLightProbe = true;

	class MaterialLoader extends Loader {
		constructor(manager) {
			super(manager);
			this.textures = {};
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const textures = this.textures;

			function getTexture(name) {
				if (textures[name] === undefined) {
					console.warn('THREE.MaterialLoader: Undefined texture', name);
				}

				return textures[name];
			}

			const material = new Materials[json.type]();
			if (json.uuid !== undefined) material.uuid = json.uuid;
			if (json.name !== undefined) material.name = json.name;
			if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
			if (json.roughness !== undefined) material.roughness = json.roughness;
			if (json.metalness !== undefined) material.metalness = json.metalness;
			if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
			if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
			if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
			if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
			if (json.specularTint !== undefined && material.specularTint !== undefined) material.specularTint.setHex(json.specularTint);
			if (json.shininess !== undefined) material.shininess = json.shininess;
			if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
			if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
			if (json.transmission !== undefined) material.transmission = json.transmission;
			if (json.thickness !== undefined) material.thickness = json.thickness;
			if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
			if (json.attenuationTint !== undefined && material.attenuationTint !== undefined) material.attenuationTint.setHex(json.attenuationTint);
			if (json.fog !== undefined) material.fog = json.fog;
			if (json.flatShading !== undefined) material.flatShading = json.flatShading;
			if (json.blending !== undefined) material.blending = json.blending;
			if (json.combine !== undefined) material.combine = json.combine;
			if (json.side !== undefined) material.side = json.side;
			if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
			if (json.opacity !== undefined) material.opacity = json.opacity;
			if (json.transparent !== undefined) material.transparent = json.transparent;
			if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
			if (json.depthTest !== undefined) material.depthTest = json.depthTest;
			if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
			if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
			if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
			if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
			if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
			if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
			if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
			if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
			if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
			if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
			if (json.wireframe !== undefined) material.wireframe = json.wireframe;
			if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
			if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
			if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
			if (json.rotation !== undefined) material.rotation = json.rotation;
			if (json.linewidth !== 1) material.linewidth = json.linewidth;
			if (json.dashSize !== undefined) material.dashSize = json.dashSize;
			if (json.gapSize !== undefined) material.gapSize = json.gapSize;
			if (json.scale !== undefined) material.scale = json.scale;
			if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
			if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
			if (json.dithering !== undefined) material.dithering = json.dithering;
			if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
			if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
			if (json.visible !== undefined) material.visible = json.visible;
			if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
			if (json.userData !== undefined) material.userData = json.userData;

			if (json.vertexColors !== undefined) {
				if (typeof json.vertexColors === 'number') {
					material.vertexColors = json.vertexColors > 0 ? true : false;
				} else {
					material.vertexColors = json.vertexColors;
				}
			} // Shader Material


			if (json.uniforms !== undefined) {
				for (const name in json.uniforms) {
					const uniform = json.uniforms[name];
					material.uniforms[name] = {};

					switch (uniform.type) {
						case 't':
							material.uniforms[name].value = getTexture(uniform.value);
							break;

						case 'c':
							material.uniforms[name].value = new Color().setHex(uniform.value);
							break;

						case 'v2':
							material.uniforms[name].value = new Vector2().fromArray(uniform.value);
							break;

						case 'v3':
							material.uniforms[name].value = new Vector3().fromArray(uniform.value);
							break;

						case 'v4':
							material.uniforms[name].value = new Vector4().fromArray(uniform.value);
							break;

						case 'm3':
							material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
							break;

						case 'm4':
							material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
							break;

						default:
							material.uniforms[name].value = uniform.value;
					}
				}
			}

			if (json.defines !== undefined) material.defines = json.defines;
			if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
			if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;

			if (json.extensions !== undefined) {
				for (const key in json.extensions) {
					material.extensions[key] = json.extensions[key];
				}
			} // Deprecated


			if (json.shading !== undefined) material.flatShading = json.shading === 1; // THREE.FlatShading
			// for PointsMaterial

			if (json.size !== undefined) material.size = json.size;
			if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation; // maps

			if (json.map !== undefined) material.map = getTexture(json.map);
			if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
			if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
			if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
			if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
			if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
			if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;

			if (json.normalScale !== undefined) {
				let normalScale = json.normalScale;

				if (Array.isArray(normalScale) === false) {
					// Blender exporter used to export a scalar. See #7459
					normalScale = [normalScale, normalScale];
				}

				material.normalScale = new Vector2().fromArray(normalScale);
			}

			if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
			if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
			if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
			if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
			if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
			if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
			if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
			if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
			if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
			if (json.specularTintMap !== undefined) material.specularTintMap = getTexture(json.specularTintMap);
			if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
			if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
			if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
			if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
			if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
			if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
			if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
			if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
			if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
			if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
			if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
			if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
			if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
			if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
			if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
			return material;
		}

		setTextures(value) {
			this.textures = value;
			return this;
		}

	}

	class LoaderUtils {
		static decodeText(array) {
			if (typeof TextDecoder !== 'undefined') {
				return new TextDecoder().decode(array);
			} // Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.


			let s = '';

			for (let i = 0, il = array.length; i < il; i++) {
				// Implicitly assumes little-endian.
				s += String.fromCharCode(array[i]);
			}

			try {
				// merges multi-byte utf-8 characters.
				return decodeURIComponent(escape(s));
			} catch (e) {
				// see #16358
				return s;
			}
		}

		static extractUrlBase(url) {
			const index = url.lastIndexOf('/');
			if (index === -1) return './';
			return url.substr(0, index + 1);
		}

	}

	class InstancedBufferGeometry extends BufferGeometry {
		constructor() {
			super();
			this.type = 'InstancedBufferGeometry';
			this.instanceCount = Infinity;
		}

		copy(source) {
			super.copy(source);
			this.instanceCount = source.instanceCount;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		toJSON() {
			const data = super.toJSON(this);
			data.instanceCount = this.instanceCount;
			data.isInstancedBufferGeometry = true;
			return data;
		}

	}

	InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

	class InstancedBufferAttribute extends BufferAttribute {
		constructor(array, itemSize, normalized, meshPerAttribute = 1) {
			if (typeof normalized === 'number') {
				meshPerAttribute = normalized;
				normalized = false;
				console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');
			}

			super(array, itemSize, normalized);
			this.meshPerAttribute = meshPerAttribute;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		toJSON() {
			const data = super.toJSON();
			data.meshPerAttribute = this.meshPerAttribute;
			data.isInstancedBufferAttribute = true;
			return data;
		}

	}

	InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

	class BufferGeometryLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(scope.manager);
			loader.setPath(scope.path);
			loader.setRequestHeader(scope.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				try {
					onLoad(scope.parse(JSON.parse(text)));
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

		parse(json) {
			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer(json, uuid) {
				if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[uuid];
				const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
				const array = getTypedArray(interleavedBuffer.type, buffer);
				const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
				ib.uuid = interleavedBuffer.uuid;
				interleavedBufferMap[uuid] = ib;
				return ib;
			}

			function getArrayBuffer(json, uuid) {
				if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[uuid];
				const ab = new Uint32Array(arrayBuffer).buffer;
				arrayBufferMap[uuid] = ab;
				return ab;
			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
			const index = json.data.index;

			if (index !== undefined) {
				const typedArray = getTypedArray(index.type, index.array);
				geometry.setIndex(new BufferAttribute(typedArray, 1));
			}

			const attributes = json.data.attributes;

			for (const key in attributes) {
				const attribute = attributes[key];
				let bufferAttribute;

				if (attribute.isInterleavedBufferAttribute) {
					const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
					bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
				} else {
					const typedArray = getTypedArray(attribute.type, attribute.array);
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
				}

				if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
				if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);

				if (attribute.updateRange !== undefined) {
					bufferAttribute.updateRange.offset = attribute.updateRange.offset;
					bufferAttribute.updateRange.count = attribute.updateRange.count;
				}

				geometry.setAttribute(key, bufferAttribute);
			}

			const morphAttributes = json.data.morphAttributes;

			if (morphAttributes) {
				for (const key in morphAttributes) {
					const attributeArray = morphAttributes[key];
					const array = [];

					for (let i = 0, il = attributeArray.length; i < il; i++) {
						const attribute = attributeArray[i];
						let bufferAttribute;

						if (attribute.isInterleavedBufferAttribute) {
							const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
							bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
						} else {
							const typedArray = getTypedArray(attribute.type, attribute.array);
							bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
						}

						if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
						array.push(bufferAttribute);
					}

					geometry.morphAttributes[key] = array;
				}
			}

			const morphTargetsRelative = json.data.morphTargetsRelative;

			if (morphTargetsRelative) {
				geometry.morphTargetsRelative = true;
			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if (groups !== undefined) {
				for (let i = 0, n = groups.length; i !== n; ++i) {
					const group = groups[i];
					geometry.addGroup(group.start, group.count, group.materialIndex);
				}
			}

			const boundingSphere = json.data.boundingSphere;

			if (boundingSphere !== undefined) {
				const center = new Vector3();

				if (boundingSphere.center !== undefined) {
					center.fromArray(boundingSphere.center);
				}

				geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
			}

			if (json.name) geometry.name = json.name;
			if (json.userData) geometry.userData = json.userData;
			return geometry;
		}

	}

	class ObjectLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (text) {
				let json = null;

				try {
					json = JSON.parse(text);
				} catch (error) {
					if (onError !== undefined) onError(error);
					console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
					return;
				}

				const metadata = json.metadata;

				if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
					console.error('THREE.ObjectLoader: Can\'t load ' + url);
					return;
				}

				scope.parse(json, onLoad);
			}, onProgress, onError);
		}

		async loadAsync(url, onProgress) {
			const scope = this;
			const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
			this.resourcePath = this.resourcePath || path;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			const text = await loader.loadAsync(url, onProgress);
			const json = JSON.parse(text);
			const metadata = json.metadata;

			if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
				throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
			}

			return await scope.parseAsync(json);
		}

		parse(json, onLoad) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = this.parseImages(json.images, function () {
				if (onLoad !== undefined) onLoad(object);
			});
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons); //

			if (onLoad !== undefined) {
				let hasImages = false;

				for (const uuid in images) {
					if (images[uuid] instanceof HTMLImageElement) {
						hasImages = true;
						break;
					}
				}

				if (hasImages === false) onLoad(object);
			}

			return object;
		}

		async parseAsync(json) {
			const animations = this.parseAnimations(json.animations);
			const shapes = this.parseShapes(json.shapes);
			const geometries = this.parseGeometries(json.geometries, shapes);
			const images = await this.parseImagesAsync(json.images);
			const textures = this.parseTextures(json.textures, images);
			const materials = this.parseMaterials(json.materials, textures);
			const object = this.parseObject(json.object, geometries, materials, textures, animations);
			const skeletons = this.parseSkeletons(json.skeletons, object);
			this.bindSkeletons(object, skeletons);
			return object;
		}

		parseShapes(json) {
			const shapes = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const shape = new Shape().fromJSON(json[i]);
					shapes[shape.uuid] = shape;
				}
			}

			return shapes;
		}

		parseSkeletons(json, object) {
			const skeletons = {};
			const bones = {}; // generate bone lookup table

			object.traverse(function (child) {
				if (child.isBone) bones[child.uuid] = child;
			}); // create skeletons

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const skeleton = new Skeleton().fromJSON(json[i], bones);
					skeletons[skeleton.uuid] = skeleton;
				}
			}

			return skeletons;
		}

		parseGeometries(json, shapes) {
			const geometries = {};

			if (json !== undefined) {
				const bufferGeometryLoader = new BufferGeometryLoader();

				for (let i = 0, l = json.length; i < l; i++) {
					let geometry;
					const data = json[i];

					switch (data.type) {
						case 'BufferGeometry':
						case 'InstancedBufferGeometry':
							geometry = bufferGeometryLoader.parse(data);
							break;

						case 'Geometry':
							console.error('THREE.ObjectLoader: The legacy Geometry type is no longer supported.');
							break;

						default:
							if (data.type in Geometries) {
								geometry = Geometries[data.type].fromJSON(data, shapes);
							} else {
								console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
							}

					}

					geometry.uuid = data.uuid;
					if (data.name !== undefined) geometry.name = data.name;
					if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
					geometries[data.uuid] = geometry;
				}
			}

			return geometries;
		}

		parseMaterials(json, textures) {
			const cache = {}; // MultiMaterial

			const materials = {};

			if (json !== undefined) {
				const loader = new MaterialLoader();
				loader.setTextures(textures);

				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.type === 'MultiMaterial') {
						// Deprecated
						const array = [];

						for (let j = 0; j < data.materials.length; j++) {
							const material = data.materials[j];

							if (cache[material.uuid] === undefined) {
								cache[material.uuid] = loader.parse(material);
							}

							array.push(cache[material.uuid]);
						}

						materials[data.uuid] = array;
					} else {
						if (cache[data.uuid] === undefined) {
							cache[data.uuid] = loader.parse(data);
						}

						materials[data.uuid] = cache[data.uuid];
					}
				}
			}

			return materials;
		}

		parseAnimations(json) {
			const animations = {};

			if (json !== undefined) {
				for (let i = 0; i < json.length; i++) {
					const data = json[i];
					const clip = AnimationClip.parse(data);
					animations[clip.uuid] = clip;
				}
			}

			return animations;
		}

		parseImages(json, onLoad) {
			const scope = this;
			const images = {};
			let loader;

			function loadImage(url) {
				scope.manager.itemStart(url);
				return loader.load(url, function () {
					scope.manager.itemEnd(url);
				}, undefined, function () {
					scope.manager.itemError(url);
					scope.manager.itemEnd(url);
				});
			}

			function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return loadImage(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				const manager = new LoadingManager(onLoad);
				loader = new ImageLoader(manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		async parseImagesAsync(json) {
			const scope = this;
			const images = {};
			let loader;

			async function deserializeImage(image) {
				if (typeof image === 'string') {
					const url = image;
					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
					return await loader.loadAsync(path);
				} else {
					if (image.data) {
						return {
							data: getTypedArray(image.type, image.data),
							width: image.width,
							height: image.height
						};
					} else {
						return null;
					}
				}
			}

			if (json !== undefined && json.length > 0) {
				loader = new ImageLoader(this.manager);
				loader.setCrossOrigin(this.crossOrigin);

				for (let i = 0, il = json.length; i < il; i++) {
					const image = json[i];
					const url = image.url;

					if (Array.isArray(url)) {
						// load array of images e.g CubeTexture
						images[image.uuid] = [];

						for (let j = 0, jl = url.length; j < jl; j++) {
							const currentUrl = url[j];
							const deserializedImage = await deserializeImage(currentUrl);

							if (deserializedImage !== null) {
								if (deserializedImage instanceof HTMLImageElement) {
									images[image.uuid].push(deserializedImage);
								} else {
									// special case: handle array of data textures for cube textures
									images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
								}
							}
						}
					} else {
						// load single image
						const deserializedImage = await deserializeImage(image.url);

						if (deserializedImage !== null) {
							images[image.uuid] = deserializedImage;
						}
					}
				}
			}

			return images;
		}

		parseTextures(json, images) {
			function parseConstant(value, type) {
				if (typeof value === 'number') return value;
				console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
				return type[value];
			}

			const textures = {};

			if (json !== undefined) {
				for (let i = 0, l = json.length; i < l; i++) {
					const data = json[i];

					if (data.image === undefined) {
						console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
					}

					if (images[data.image] === undefined) {
						console.warn('THREE.ObjectLoader: Undefined image', data.image);
					}

					let texture;
					const image = images[data.image];

					if (Array.isArray(image)) {
						texture = new CubeTexture(image);
						if (image.length === 6) texture.needsUpdate = true;
					} else {
						if (image && image.data) {
							texture = new DataTexture(image.data, image.width, image.height);
						} else {
							texture = new Texture(image);
						}

						if (image) texture.needsUpdate = true; // textures can have undefined image data
					}

					texture.uuid = data.uuid;
					if (data.name !== undefined) texture.name = data.name;
					if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
					if (data.offset !== undefined) texture.offset.fromArray(data.offset);
					if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
					if (data.center !== undefined) texture.center.fromArray(data.center);
					if (data.rotation !== undefined) texture.rotation = data.rotation;

					if (data.wrap !== undefined) {
						texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
						texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
					}

					if (data.format !== undefined) texture.format = data.format;
					if (data.type !== undefined) texture.type = data.type;
					if (data.encoding !== undefined) texture.encoding = data.encoding;
					if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
					if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
					if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
					if (data.flipY !== undefined) texture.flipY = data.flipY;
					if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
					if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
					textures[data.uuid] = texture;
				}
			}

			return textures;
		}

		parseObject(data, geometries, materials, textures, animations) {
			let object;

			function getGeometry(name) {
				if (geometries[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined geometry', name);
				}

				return geometries[name];
			}

			function getMaterial(name) {
				if (name === undefined) return undefined;

				if (Array.isArray(name)) {
					const array = [];

					for (let i = 0, l = name.length; i < l; i++) {
						const uuid = name[i];

						if (materials[uuid] === undefined) {
							console.warn('THREE.ObjectLoader: Undefined material', uuid);
						}

						array.push(materials[uuid]);
					}

					return array;
				}

				if (materials[name] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined material', name);
				}

				return materials[name];
			}

			function getTexture(uuid) {
				if (textures[uuid] === undefined) {
					console.warn('THREE.ObjectLoader: Undefined texture', uuid);
				}

				return textures[uuid];
			}

			let geometry, material;

			switch (data.type) {
				case 'Scene':
					object = new Scene();

					if (data.background !== undefined) {
						if (Number.isInteger(data.background)) {
							object.background = new Color(data.background);
						} else {
							object.background = getTexture(data.background);
						}
					}

					if (data.environment !== undefined) {
						object.environment = getTexture(data.environment);
					}

					if (data.fog !== undefined) {
						if (data.fog.type === 'Fog') {
							object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
						} else if (data.fog.type === 'FogExp2') {
							object.fog = new FogExp2(data.fog.color, data.fog.density);
						}
					}

					break;

				case 'PerspectiveCamera':
					object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
					if (data.focus !== undefined) object.focus = data.focus;
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
					if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'OrthographicCamera':
					object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
					if (data.zoom !== undefined) object.zoom = data.zoom;
					if (data.view !== undefined) object.view = Object.assign({}, data.view);
					break;

				case 'AmbientLight':
					object = new AmbientLight(data.color, data.intensity);
					break;

				case 'DirectionalLight':
					object = new DirectionalLight(data.color, data.intensity);
					break;

				case 'PointLight':
					object = new PointLight(data.color, data.intensity, data.distance, data.decay);
					break;

				case 'RectAreaLight':
					object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
					break;

				case 'SpotLight':
					object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
					break;

				case 'HemisphereLight':
					object = new HemisphereLight(data.color, data.groundColor, data.intensity);
					break;

				case 'LightProbe':
					object = new LightProbe().fromJSON(data);
					break;

				case 'SkinnedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new SkinnedMesh(geometry, material);
					if (data.bindMode !== undefined) object.bindMode = data.bindMode;
					if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
					if (data.skeleton !== undefined) object.skeleton = data.skeleton;
					break;

				case 'Mesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					object = new Mesh(geometry, material);
					break;

				case 'InstancedMesh':
					geometry = getGeometry(data.geometry);
					material = getMaterial(data.material);
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;
					const instanceColor = data.instanceColor;
					object = new InstancedMesh(geometry, material, count);
					object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
					if (instanceColor !== undefined) object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
					break;

				case 'LOD':
					object = new LOD();
					break;

				case 'Line':
					object = new Line(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineLoop':
					object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'LineSegments':
					object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'PointCloud':
				case 'Points':
					object = new Points(getGeometry(data.geometry), getMaterial(data.material));
					break;

				case 'Sprite':
					object = new Sprite(getMaterial(data.material));
					break;

				case 'Group':
					object = new Group();
					break;

				case 'Bone':
					object = new Bone();
					break;

				default:
					object = new Object3D();
			}

			object.uuid = data.uuid;
			if (data.name !== undefined) object.name = data.name;

			if (data.matrix !== undefined) {
				object.matrix.fromArray(data.matrix);
				if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
			} else {
				if (data.position !== undefined) object.position.fromArray(data.position);
				if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
				if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
				if (data.scale !== undefined) object.scale.fromArray(data.scale);
			}

			if (data.castShadow !== undefined) object.castShadow = data.castShadow;
			if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;

			if (data.shadow) {
				if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
				if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
				if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
				if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
				if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
			}

			if (data.visible !== undefined) object.visible = data.visible;
			if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
			if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
			if (data.userData !== undefined) object.userData = data.userData;
			if (data.layers !== undefined) object.layers.mask = data.layers;

			if (data.children !== undefined) {
				const children = data.children;

				for (let i = 0; i < children.length; i++) {
					object.add(this.parseObject(children[i], geometries, materials, textures, animations));
				}
			}

			if (data.animations !== undefined) {
				const objectAnimations = data.animations;

				for (let i = 0; i < objectAnimations.length; i++) {
					const uuid = objectAnimations[i];
					object.animations.push(animations[uuid]);
				}
			}

			if (data.type === 'LOD') {
				if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
				const levels = data.levels;

				for (let l = 0; l < levels.length; l++) {
					const level = levels[l];
					const child = object.getObjectByProperty('uuid', level.object);

					if (child !== undefined) {
						object.addLevel(child, level.distance);
					}
				}
			}

			return object;
		}

		bindSkeletons(object, skeletons) {
			if (Object.keys(skeletons).length === 0) return;
			object.traverse(function (child) {
				if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
					const skeleton = skeletons[child.skeleton];

					if (skeleton === undefined) {
						console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
					} else {
						child.bind(skeleton, child.bindMatrix);
					}
				}
			});
		}
		/* DEPRECATED */


		setTexturePath(value) {
			console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');
			return this.setResourcePath(value);
		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	class ImageBitmapLoader extends Loader {
		constructor(manager) {
			super(manager);

			if (typeof createImageBitmap === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
			}

			if (typeof fetch === 'undefined') {
				console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
			}

			this.options = {
				premultiplyAlpha: 'none'
			};
		}

		setOptions(options) {
			this.options = options;
			return this;
		}

		load(url, onLoad, onProgress, onError) {
			if (url === undefined) url = '';
			if (this.path !== undefined) url = this.path + url;
			url = this.manager.resolveURL(url);
			const scope = this;
			const cached = Cache.get(url);

			if (cached !== undefined) {
				scope.manager.itemStart(url);
				setTimeout(function () {
					if (onLoad) onLoad(cached);
					scope.manager.itemEnd(url);
				}, 0);
				return cached;
			}

			const fetchOptions = {};
			fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
			fetchOptions.headers = this.requestHeader;
			fetch(url, fetchOptions).then(function (res) {
				return res.blob();
			}).then(function (blob) {
				return createImageBitmap(blob, Object.assign(scope.options, {
					colorSpaceConversion: 'none'
				}));
			}).then(function (imageBitmap) {
				Cache.add(url, imageBitmap);
				if (onLoad) onLoad(imageBitmap);
				scope.manager.itemEnd(url);
			}).catch(function (e) {
				if (onError) onError(e);
				scope.manager.itemError(url);
				scope.manager.itemEnd(url);
			});
			scope.manager.itemStart(url);
		}

	}

	ImageBitmapLoader.prototype.isImageBitmapLoader = true;

	class ShapePath {
		constructor() {
			this.type = 'ShapePath';
			this.color = new Color();
			this.subPaths = [];
			this.currentPath = null;
		}

		moveTo(x, y) {
			this.currentPath = new Path();
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(x, y);
			return this;
		}

		lineTo(x, y) {
			this.currentPath.lineTo(x, y);
			return this;
		}

		quadraticCurveTo(aCPx, aCPy, aX, aY) {
			this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
			return this;
		}

		bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
			this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
			return this;
		}

		splineThru(pts) {
			this.currentPath.splineThru(pts);
			return this;
		}

		toShapes(isCCW, noHoles) {
			function toShapesNoHoles(inSubpaths) {
				const shapes = [];

				for (let i = 0, l = inSubpaths.length; i < l; i++) {
					const tmpPath = inSubpaths[i];
					const tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push(tmpShape);
				}

				return shapes;
			}

			function isPointInsidePolygon(inPt, inPolygon) {
				const polyLen = inPolygon.length; // inPt on polygon contour => immediate success		or
				// toggling of inside/outside at every single! intersection point of an edge
				//	with the horizontal line through inPt, left of inPt
				//	not counting lowerY endpoints of edges and whole edges on that line

				let inside = false;

				for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
					let edgeLowPt = inPolygon[p];
					let edgeHighPt = inPolygon[q];
					let edgeDx = edgeHighPt.x - edgeLowPt.x;
					let edgeDy = edgeHighPt.y - edgeLowPt.y;

					if (Math.abs(edgeDy) > Number.EPSILON) {
						// not parallel
						if (edgeDy < 0) {
							edgeLowPt = inPolygon[q];
							edgeDx = -edgeDx;
							edgeHighPt = inPolygon[p];
							edgeDy = -edgeDy;
						}

						if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;

						if (inPt.y === edgeLowPt.y) {
							if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
						} else {
							const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
							if (perpEdge === 0) return true; // inPt is on contour ?

							if (perpEdge < 0) continue;
							inside = !inside; // true intersection left of inPt
						}
					} else {
						// parallel or collinear
						if (inPt.y !== edgeLowPt.y) continue; // parallel
						// edge lies on the same horizontal line as inPt

						if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
						// continue;
					}
				}

				return inside;
			}

			const isClockWise = ShapeUtils.isClockWise;
			const subPaths = this.subPaths;
			if (subPaths.length === 0) return [];
			if (noHoles === true) return toShapesNoHoles(subPaths);
			let solid, tmpPath, tmpShape;
			const shapes = [];

			if (subPaths.length === 1) {
				tmpPath = subPaths[0];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push(tmpShape);
				return shapes;
			}

			let holesFirst = !isClockWise(subPaths[0].getPoints());
			holesFirst = isCCW ? !holesFirst : holesFirst; // console.log("Holes first", holesFirst);

			const betterShapeHoles = [];
			const newShapes = [];
			let newShapeHoles = [];
			let mainIdx = 0;
			let tmpPoints;
			newShapes[mainIdx] = undefined;
			newShapeHoles[mainIdx] = [];

			for (let i = 0, l = subPaths.length; i < l; i++) {
				tmpPath = subPaths[i];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise(tmpPoints);
				solid = isCCW ? !solid : solid;

				if (solid) {
					if (!holesFirst && newShapes[mainIdx]) mainIdx++;
					newShapes[mainIdx] = {
						s: new Shape(),
						p: tmpPoints
					};
					newShapes[mainIdx].s.curves = tmpPath.curves;
					if (holesFirst) mainIdx++;
					newShapeHoles[mainIdx] = []; //console.log('cw', i);
				} else {
					newShapeHoles[mainIdx].push({
						h: tmpPath,
						p: tmpPoints[0]
					}); //console.log('ccw', i);
				}
			} // only Holes? -> probably all Shapes with wrong orientation


			if (!newShapes[0]) return toShapesNoHoles(subPaths);

			if (newShapes.length > 1) {
				let ambiguous = false;
				const toChange = [];

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					betterShapeHoles[sIdx] = [];
				}

				for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
					const sho = newShapeHoles[sIdx];

					for (let hIdx = 0; hIdx < sho.length; hIdx++) {
						const ho = sho[hIdx];
						let hole_unassigned = true;

						for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
							if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
								if (sIdx !== s2Idx) toChange.push({
									froms: sIdx,
									tos: s2Idx,
									hole: hIdx
								});

								if (hole_unassigned) {
									hole_unassigned = false;
									betterShapeHoles[s2Idx].push(ho);
								} else {
									ambiguous = true;
								}
							}
						}

						if (hole_unassigned) {
							betterShapeHoles[sIdx].push(ho);
						}
					}
				} // console.log("ambiguous: ", ambiguous);


				if (toChange.length > 0) {
					// console.log("to change: ", toChange);
					if (!ambiguous) newShapeHoles = betterShapeHoles;
				}
			}

			let tmpHoles;

			for (let i = 0, il = newShapes.length; i < il; i++) {
				tmpShape = newShapes[i].s;
				shapes.push(tmpShape);
				tmpHoles = newShapeHoles[i];

				for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
					tmpShape.holes.push(tmpHoles[j].h);
				}
			} //console.log("shape", shapes);


			return shapes;
		}

	}

	class Font {
		constructor(data) {
			this.type = 'Font';
			this.data = data;
		}

		generateShapes(text, size = 100) {
			const shapes = [];
			const paths = createPaths(text, size, this.data);

			for (let p = 0, pl = paths.length; p < pl; p++) {
				Array.prototype.push.apply(shapes, paths[p].toShapes());
			}

			return shapes;
		}

	}

	function createPaths(text, size, data) {
		const chars = Array.from(text);
		const scale = size / data.resolution;
		const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
		const paths = [];
		let offsetX = 0,
				offsetY = 0;

		for (let i = 0; i < chars.length; i++) {
			const char = chars[i];

			if (char === '\n') {
				offsetX = 0;
				offsetY -= line_height;
			} else {
				const ret = createPath(char, scale, offsetX, offsetY, data);
				offsetX += ret.offsetX;
				paths.push(ret.path);
			}
		}

		return paths;
	}

	function createPath(char, scale, offsetX, offsetY, data) {
		const glyph = data.glyphs[char] || data.glyphs['?'];

		if (!glyph) {
			console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.');
			return;
		}

		const path = new ShapePath();
		let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if (glyph.o) {
			const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));

			for (let i = 0, l = outline.length; i < l;) {
				const action = outline[i++];

				switch (action) {
					case 'm':
						// moveTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.moveTo(x, y);
						break;

					case 'l':
						// lineTo
						x = outline[i++] * scale + offsetX;
						y = outline[i++] * scale + offsetY;
						path.lineTo(x, y);
						break;

					case 'q':
						// quadraticCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
						break;

					case 'b':
						// bezierCurveTo
						cpx = outline[i++] * scale + offsetX;
						cpy = outline[i++] * scale + offsetY;
						cpx1 = outline[i++] * scale + offsetX;
						cpy1 = outline[i++] * scale + offsetY;
						cpx2 = outline[i++] * scale + offsetX;
						cpy2 = outline[i++] * scale + offsetY;
						path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
						break;
				}
			}
		}

		return {
			offsetX: glyph.ha * scale,
			path: path
		};
	}

	Font.prototype.isFont = true;

	class FontLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(scope.withCredentials);
			loader.load(url, function (text) {
				let json;

				try {
					json = JSON.parse(text);
				} catch (e) {
					console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');
					json = JSON.parse(text.substring(65, text.length - 2));
				}

				const font = scope.parse(json);
				if (onLoad) onLoad(font);
			}, onProgress, onError);
		}

		parse(json) {
			return new Font(json);
		}

	}

	let _context;

	const AudioContext = {
		getContext: function () {
			if (_context === undefined) {
				_context = new (window.AudioContext || window.webkitAudioContext)();
			}

			return _context;
		},
		setContext: function (value) {
			_context = value;
		}
	};

	class AudioLoader extends Loader {
		constructor(manager) {
			super(manager);
		}

		load(url, onLoad, onProgress, onError) {
			const scope = this;
			const loader = new FileLoader(this.manager);
			loader.setResponseType('arraybuffer');
			loader.setPath(this.path);
			loader.setRequestHeader(this.requestHeader);
			loader.setWithCredentials(this.withCredentials);
			loader.load(url, function (buffer) {
				try {
					// Create a copy of the buffer. The `decodeAudioData` method
					// detaches the buffer when complete, preventing reuse.
					const bufferCopy = buffer.slice(0);
					const context = AudioContext.getContext();
					context.decodeAudioData(bufferCopy, function (audioBuffer) {
						onLoad(audioBuffer);
					});
				} catch (e) {
					if (onError) {
						onError(e);
					} else {
						console.error(e);
					}

					scope.manager.itemError(url);
				}
			}, onProgress, onError);
		}

	}

	class HemisphereLightProbe extends LightProbe {
		constructor(skyColor, groundColor, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(skyColor);
			const color2 = new Color().set(groundColor);
			const sky = new Vector3(color1.r, color1.g, color1.b);
			const ground = new Vector3(color2.r, color2.g, color2.b); // without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );

			const c0 = Math.sqrt(Math.PI);
			const c1 = c0 * Math.sqrt(0.75);
			this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
			this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
		}

	}

	HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

	class AmbientLightProbe extends LightProbe {
		constructor(color, intensity = 1) {
			super(undefined, intensity);
			const color1 = new Color().set(color); // without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );

			this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
		}

	}

	AmbientLightProbe.prototype.isAmbientLightProbe = true;

	const _eyeRight = /*@__PURE__*/new Matrix4();

	const _eyeLeft = /*@__PURE__*/new Matrix4();

	class StereoCamera {
		constructor() {
			this.type = 'StereoCamera';
			this.aspect = 1;
			this.eyeSep = 0.064;
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable(1);
			this.cameraL.matrixAutoUpdate = false;
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable(2);
			this.cameraR.matrixAutoUpdate = false;
			this._cache = {
				focus: null,
				fov: null,
				aspect: null,
				near: null,
				far: null,
				zoom: null,
				eyeSep: null
			};
		}

		update(camera) {
			const cache = this._cache;
			const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if (needsUpdate) {
				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep; // Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				const projectionMatrix = camera.projectionMatrix.clone();
				const eyeSepHalf = cache.eyeSep / 2;
				const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
				let xmin, xmax; // translate xOffset

				_eyeLeft.elements[12] = -eyeSepHalf;
				_eyeRight.elements[12] = eyeSepHalf; // for left eye

				xmin = -ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraL.projectionMatrix.copy(projectionMatrix); // for right eye

				xmin = -ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;
				projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
				projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
				this.cameraR.projectionMatrix.copy(projectionMatrix);
			}

			this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
			this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
		}

	}

	class Clock {
		constructor(autoStart = true) {
			this.autoStart = autoStart;
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
			this.running = false;
		}

		start() {
			this.startTime = now();
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
		}

		stop() {
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
		}

		getElapsedTime() {
			this.getDelta();
			return this.elapsedTime;
		}

		getDelta() {
			let diff = 0;

			if (this.autoStart && !this.running) {
				this.start();
				return 0;
			}

			if (this.running) {
				const newTime = now();
				diff = (newTime - this.oldTime) / 1000;
				this.oldTime = newTime;
				this.elapsedTime += diff;
			}

			return diff;
		}

	}

	function now() {
		return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732
	}

	const _position$1 = /*@__PURE__*/new Vector3();

	const _quaternion$1 = /*@__PURE__*/new Quaternion();

	const _scale$1 = /*@__PURE__*/new Vector3();

	const _orientation$1 = /*@__PURE__*/new Vector3();

	class AudioListener extends Object3D {
		constructor() {
			super();
			this.type = 'AudioListener';
			this.context = AudioContext.getContext();
			this.gain = this.context.createGain();
			this.gain.connect(this.context.destination);
			this.filter = null;
			this.timeDelta = 0; // private

			this._clock = new Clock();
		}

		getInput() {
			return this.gain;
		}

		removeFilter() {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
				this.gain.connect(this.context.destination);
				this.filter = null;
			}

			return this;
		}

		getFilter() {
			return this.filter;
		}

		setFilter(value) {
			if (this.filter !== null) {
				this.gain.disconnect(this.filter);
				this.filter.disconnect(this.context.destination);
			} else {
				this.gain.disconnect(this.context.destination);
			}

			this.filter = value;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this;
		}

		getMasterVolume() {
			return this.gain.gain.value;
		}

		setMasterVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			const listener = this.context.listener;
			const up = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);

			_orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);

			if (listener.positionX) {
				// code path for Chrome (see #14393)
				const endTime = this.context.currentTime + this.timeDelta;
				listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
				listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
				listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
				listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
				listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
				listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
				listener.upX.linearRampToValueAtTime(up.x, endTime);
				listener.upY.linearRampToValueAtTime(up.y, endTime);
				listener.upZ.linearRampToValueAtTime(up.z, endTime);
			} else {
				listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
				listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
			}
		}

	}

	class Audio extends Object3D {
		constructor(listener) {
			super();
			this.type = 'Audio';
			this.listener = listener;
			this.context = listener.context;
			this.gain = this.context.createGain();
			this.gain.connect(listener.getInput());
			this.autoplay = false;
			this.buffer = null;
			this.detune = 0;
			this.loop = false;
			this.loopStart = 0;
			this.loopEnd = 0;
			this.offset = 0;
			this.duration = undefined;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.source = null;
			this.sourceType = 'empty';
			this._startedAt = 0;
			this._progress = 0;
			this._connected = false;
			this.filters = [];
		}

		getOutput() {
			return this.gain;
		}

		setNodeSource(audioNode) {
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
			return this;
		}

		setMediaElementSource(mediaElement) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource(mediaElement);
			this.connect();
			return this;
		}

		setMediaStreamSource(mediaStream) {
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource(mediaStream);
			this.connect();
			return this;
		}

		setBuffer(audioBuffer) {
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
			if (this.autoplay) this.play();
			return this;
		}

		play(delay = 0) {
			if (this.isPlaying === true) {
				console.warn('THREE.Audio: Audio is already playing.');
				return;
			}

			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._startedAt = this.context.currentTime + delay;
			const source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind(this);
			source.start(this._startedAt, this._progress + this.offset, this.duration);
			this.isPlaying = true;
			this.source = source;
			this.setDetune(this.detune);
			this.setPlaybackRate(this.playbackRate);
			return this.connect();
		}

		pause() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			if (this.isPlaying === true) {
				// update current progress
				this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;

				if (this.loop === true) {
					// ensure _progress does not exceed duration with looped audios
					this._progress = this._progress % (this.duration || this.buffer.duration);
				}

				this.source.stop();
				this.source.onended = null;
				this.isPlaying = false;
			}

			return this;
		}

		stop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this._progress = 0;
			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;
			return this;
		}

		connect() {
			if (this.filters.length > 0) {
				this.source.connect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].connect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].connect(this.getOutput());
			} else {
				this.source.connect(this.getOutput());
			}

			this._connected = true;
			return this;
		}

		disconnect() {
			if (this.filters.length > 0) {
				this.source.disconnect(this.filters[0]);

				for (let i = 1, l = this.filters.length; i < l; i++) {
					this.filters[i - 1].disconnect(this.filters[i]);
				}

				this.filters[this.filters.length - 1].disconnect(this.getOutput());
			} else {
				this.source.disconnect(this.getOutput());
			}

			this._connected = false;
			return this;
		}

		getFilters() {
			return this.filters;
		}

		setFilters(value) {
			if (!value) value = [];

			if (this._connected === true) {
				this.disconnect();
				this.filters = value.slice();
				this.connect();
			} else {
				this.filters = value.slice();
			}

			return this;
		}

		setDetune(value) {
			this.detune = value;
			if (this.source.detune === undefined) return; // only set detune when available

			if (this.isPlaying === true) {
				this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
			}

			return this;
		}

		getDetune() {
			return this.detune;
		}

		getFilter() {
			return this.getFilters()[0];
		}

		setFilter(filter) {
			return this.setFilters(filter ? [filter] : []);
		}

		setPlaybackRate(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.playbackRate = value;

			if (this.isPlaying === true) {
				this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
			}

			return this;
		}

		getPlaybackRate() {
			return this.playbackRate;
		}

		onEnded() {
			this.isPlaying = false;
		}

		getLoop() {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return false;
			}

			return this.loop;
		}

		setLoop(value) {
			if (this.hasPlaybackControl === false) {
				console.warn('THREE.Audio: this Audio has no playback control.');
				return;
			}

			this.loop = value;

			if (this.isPlaying === true) {
				this.source.loop = this.loop;
			}

			return this;
		}

		setLoopStart(value) {
			this.loopStart = value;
			return this;
		}

		setLoopEnd(value) {
			this.loopEnd = value;
			return this;
		}

		getVolume() {
			return this.gain.gain.value;
		}

		setVolume(value) {
			this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
			return this;
		}

	}

	const _position = /*@__PURE__*/new Vector3();

	const _quaternion = /*@__PURE__*/new Quaternion();

	const _scale = /*@__PURE__*/new Vector3();

	const _orientation = /*@__PURE__*/new Vector3();

	class PositionalAudio extends Audio {
		constructor(listener) {
			super(listener);
			this.panner = this.context.createPanner();
			this.panner.panningModel = 'HRTF';
			this.panner.connect(this.gain);
		}

		getOutput() {
			return this.panner;
		}

		getRefDistance() {
			return this.panner.refDistance;
		}

		setRefDistance(value) {
			this.panner.refDistance = value;
			return this;
		}

		getRolloffFactor() {
			return this.panner.rolloffFactor;
		}

		setRolloffFactor(value) {
			this.panner.rolloffFactor = value;
			return this;
		}

		getDistanceModel() {
			return this.panner.distanceModel;
		}

		setDistanceModel(value) {
			this.panner.distanceModel = value;
			return this;
		}

		getMaxDistance() {
			return this.panner.maxDistance;
		}

		setMaxDistance(value) {
			this.panner.maxDistance = value;
			return this;
		}

		setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
			return this;
		}

		updateMatrixWorld(force) {
			super.updateMatrixWorld(force);
			if (this.hasPlaybackControl === true && this.isPlaying === false) return;
			this.matrixWorld.decompose(_position, _quaternion, _scale);

			_orientation.set(0, 0, 1).applyQuaternion(_quaternion);

			const panner = this.panner;

			if (panner.positionX) {
				// code path for Chrome and Firefox (see #14393)
				const endTime = this.context.currentTime + this.listener.timeDelta;
				panner.positionX.linearRampToValueAtTime(_position.x, endTime);
				panner.positionY.linearRampToValueAtTime(_position.y, endTime);
				panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
				panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
				panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
				panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
			} else {
				panner.setPosition(_position.x, _position.y, _position.z);
				panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
			}
		}

	}

	class AudioAnalyser {
		constructor(audio, fftSize = 2048) {
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize;
			this.data = new Uint8Array(this.analyser.frequencyBinCount);
			audio.getOutput().connect(this.analyser);
		}

		getFrequencyData() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data;
		}

		getAverageFrequency() {
			let value = 0;
			const data = this.getFrequencyData();

			for (let i = 0; i < data.length; i++) {
				value += data[i];
			}

			return value / data.length;
		}

	}

	class PropertyMixer {
		constructor(binding, typeName, valueSize) {
			this.binding = binding;
			this.valueSize = valueSize;
			let mixFunction, mixFunctionAdditive, setIdentity; // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch (typeName) {
				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;
					this.buffer = new Float64Array(valueSize * 6);
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select; // Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types

					mixFunctionAdditive = this._select;
					setIdentity = this._setAdditiveIdentityOther;
					this.buffer = new Array(valueSize * 5);
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;
					this.buffer = new Float64Array(valueSize * 5);
			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
			this.useCount = 0;
			this.referenceCount = 0;
		} // accumulate data in the 'incoming' region into 'accu<i>'


		accumulate(accuIndex, weight) {
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = accuIndex * stride + stride;
			let currentWeight = this.cumulativeWeight;

			if (currentWeight === 0) {
				// accuN := incoming * weight
				for (let i = 0; i !== stride; ++i) {
					buffer[offset + i] = buffer[i];
				}

				currentWeight = weight;
			} else {
				// accuN := accuN + incoming * weight
				currentWeight += weight;
				const mix = weight / currentWeight;

				this._mixBufferRegion(buffer, offset, 0, mix, stride);
			}

			this.cumulativeWeight = currentWeight;
		} // accumulate data in the 'incoming' region into 'add'


		accumulateAdditive(weight) {
			const buffer = this.buffer,
						stride = this.valueSize,
						offset = stride * this._addIndex;

			if (this.cumulativeWeightAdditive === 0) {
				// add = identity
				this._setIdentity();
			} // add := add + incoming * weight


			this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);

			this.cumulativeWeightAdditive += weight;
		} // apply the state of 'accu<i>' to the binding when accus differ


		apply(accuIndex) {
			const stride = this.valueSize,
						buffer = this.buffer,
						offset = accuIndex * stride + stride,
						weight = this.cumulativeWeight,
						weightAdditive = this.cumulativeWeightAdditive,
						binding = this.binding;
			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if (weight < 1) {
				// accuN := accuN + original * ( 1 - cumulativeWeight )
				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
			}

			if (weightAdditive > 0) {
				// accuN := accuN + additive accuN
				this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
			}

			for (let i = stride, e = stride + stride; i !== e; ++i) {
				if (buffer[i] !== buffer[i + stride]) {
					// value has changed -> update scene graph
					binding.setValue(buffer, offset);
					break;
				}
			}
		} // remember the state of the bound property and copy it to both accus


		saveOriginalState() {
			const binding = this.binding;
			const buffer = this.buffer,
						stride = this.valueSize,
						originalValueOffset = stride * this._origIndex;
			binding.getValue(buffer, originalValueOffset); // accu[0..1] := orig -- initially detect changes against the original

			for (let i = stride, e = originalValueOffset; i !== e; ++i) {
				buffer[i] = buffer[originalValueOffset + i % stride];
			} // Add to identity for additive


			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;
		} // apply the state previously taken via 'saveOriginalState' to the binding


		restoreOriginalState() {
			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue(this.buffer, originalValueOffset);
		}

		_setAdditiveIdentityNumeric() {
			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for (let i = startIndex; i < endIndex; i++) {
				this.buffer[i] = 0;
			}
		}

		_setAdditiveIdentityQuaternion() {
			this._setAdditiveIdentityNumeric();

			this.buffer[this._addIndex * this.valueSize + 3] = 1;
		}

		_setAdditiveIdentityOther() {
			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for (let i = 0; i < this.valueSize; i++) {
				this.buffer[targetIndex + i] = this.buffer[startIndex + i];
			}
		} // mix functions


		_select(buffer, dstOffset, srcOffset, t, stride) {
			if (t >= 0.5) {
				for (let i = 0; i !== stride; ++i) {
					buffer[dstOffset + i] = buffer[srcOffset + i];
				}
			}
		}

		_slerp(buffer, dstOffset, srcOffset, t) {
			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
		}

		_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			const workOffset = this._workIndex * stride; // Store result in intermediate buffer offset

			Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset); // Slerp to the intermediate result

			Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
		}

		_lerp(buffer, dstOffset, srcOffset, t, stride) {
			const s = 1 - t;

			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
			}
		}

		_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
			for (let i = 0; i !== stride; ++i) {
				const j = dstOffset + i;
				buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
			}
		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g'); // Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.


	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';

	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'; // Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.


	const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar); // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.


	const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot); // Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.


	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar); // Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.


	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

	const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');

	const _supportedObjectNames = ['material', 'materials', 'bones'];

	class Composite {
		constructor(targetGroup, path, optionalParsedPath) {
			const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_(path, parsedPath);
		}

		getValue(array, offset) {
			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
						binding = this._bindings[firstValidIndex]; // and only call .getValue on the first

			if (binding !== undefined) binding.getValue(array, offset);
		}

		setValue(array, offset) {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].setValue(array, offset);
			}
		}

		bind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].bind();
			}
		}

		unbind() {
			const bindings = this._bindings;

			for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
				bindings[i].unbind();
			}
		}

	} // Note: This class uses a State pattern on a per-method basis:
	// 'bind' sets 'this.getValue' / 'setValue' and shadows the
	// prototype version of these methods with one that represents
	// the bound state. When the property is not found, the methods
	// become no-ops.


	class PropertyBinding {
		constructor(rootNode, path, parsedPath) {
			this.path = path;
			this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
			this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
			this.rootNode = rootNode; // initial state of these methods that calls 'bind'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

		static create(root, path, parsedPath) {
			if (!(root && root.isAnimationObjectGroup)) {
				return new PropertyBinding(root, path, parsedPath);
			} else {
				return new PropertyBinding.Composite(root, path, parsedPath);
			}
		}
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */


		static sanitizeNodeName(name) {
			return name.replace(/\s/g, '_').replace(_reservedRe, '');
		}

		static parseTrackName(trackName) {
			const matches = _trackRe.exec(trackName);

			if (!matches) {
				throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[2],
				objectName: matches[3],
				objectIndex: matches[4],
				propertyName: matches[5],
				// required
				propertyIndex: matches[6]
			};
			const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

			if (lastDot !== undefined && lastDot !== -1) {
				const objectName = results.nodeName.substring(lastDot + 1); // Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).

				if (_supportedObjectNames.indexOf(objectName) !== -1) {
					results.nodeName = results.nodeName.substring(0, lastDot);
					results.objectName = objectName;
				}
			}

			if (results.propertyName === null || results.propertyName.length === 0) {
				throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
			}

			return results;
		}

		static findNode(root, nodeName) {
			if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
				return root;
			} // search into skeleton bones.


			if (root.skeleton) {
				const bone = root.skeleton.getBoneByName(nodeName);

				if (bone !== undefined) {
					return bone;
				}
			} // search into node subtree.


			if (root.children) {
				const searchNodeSubtree = function (children) {
					for (let i = 0; i < children.length; i++) {
						const childNode = children[i];

						if (childNode.name === nodeName || childNode.uuid === nodeName) {
							return childNode;
						}

						const result = searchNodeSubtree(childNode.children);
						if (result) return result;
					}

					return null;
				};

				const subTreeNode = searchNodeSubtree(root.children);

				if (subTreeNode) {
					return subTreeNode;
				}
			}

			return null;
		} // these are used to "bind" a nonexistent property


		_getValue_unavailable() {}

		_setValue_unavailable() {} // Getters


		_getValue_direct(buffer, offset) {
			buffer[offset] = this.node[this.propertyName];
		}

		_getValue_array(buffer, offset) {
			const source = this.resolvedProperty;

			for (let i = 0, n = source.length; i !== n; ++i) {
				buffer[offset++] = source[i];
			}
		}

		_getValue_arrayElement(buffer, offset) {
			buffer[offset] = this.resolvedProperty[this.propertyIndex];
		}

		_getValue_toArray(buffer, offset) {
			this.resolvedProperty.toArray(buffer, offset);
		} // Direct


		_setValue_direct(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
		}

		_setValue_direct_setNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.targetObject[this.propertyName] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // EntireArray


		_setValue_array(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}
		}

		_setValue_array_setNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.needsUpdate = true;
		}

		_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
			const dest = this.resolvedProperty;

			for (let i = 0, n = dest.length; i !== n; ++i) {
				dest[i] = buffer[offset++];
			}

			this.targetObject.matrixWorldNeedsUpdate = true;
		} // ArrayElement


		_setValue_arrayElement(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
		}

		_setValue_arrayElement_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.needsUpdate = true;
		}

		_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty[this.propertyIndex] = buffer[offset];
			this.targetObject.matrixWorldNeedsUpdate = true;
		} // HasToFromArray


		_setValue_fromArray(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
		}

		_setValue_fromArray_setNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.needsUpdate = true;
		}

		_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
			this.resolvedProperty.fromArray(buffer, offset);
			this.targetObject.matrixWorldNeedsUpdate = true;
		}

		_getValue_unbound(targetArray, offset) {
			this.bind();
			this.getValue(targetArray, offset);
		}

		_setValue_unbound(sourceArray, offset) {
			this.bind();
			this.setValue(sourceArray, offset);
		} // create getter / setter pair for a property in the scene graph


		bind() {
			let targetObject = this.node;
			const parsedPath = this.parsedPath;
			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if (!targetObject) {
				targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
				this.node = targetObject;
			} // set fail state so we can just 'return' on error


			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable; // ensure there is a value node

			if (!targetObject) {
				console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
				return;
			}

			if (objectName) {
				let objectIndex = parsedPath.objectIndex; // special cases were we need to reach deeper into the hierarchy to get the face materials....

				switch (objectName) {
					case 'materials':
						if (!targetObject.material) {
							console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
							return;
						}

						if (!targetObject.material.materials) {
							console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
							return;
						}

						targetObject = targetObject.material.materials;
						break;

					case 'bones':
						if (!targetObject.skeleton) {
							console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
							return;
						} // potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.


						targetObject = targetObject.skeleton.bones; // support resolving morphTarget names into indices.

						for (let i = 0; i < targetObject.length; i++) {
							if (targetObject[i].name === objectIndex) {
								objectIndex = i;
								break;
							}
						}

						break;

					default:
						if (targetObject[objectName] === undefined) {
							console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
							return;
						}

						targetObject = targetObject[objectName];
				}

				if (objectIndex !== undefined) {
					if (targetObject[objectIndex] === undefined) {
						console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
						return;
					}

					targetObject = targetObject[objectIndex];
				}
			} // resolve property


			const nodeProperty = targetObject[propertyName];

			if (nodeProperty === undefined) {
				const nodeName = parsedPath.nodeName;
				console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
				return;
			} // determine versioning scheme


			let versioning = this.Versioning.None;
			this.targetObject = targetObject;

			if (targetObject.needsUpdate !== undefined) {
				// material
				versioning = this.Versioning.NeedsUpdate;
			} else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
				// node transform
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
			} // determine how the property gets bound


			let bindingType = this.BindingType.Direct;

			if (propertyIndex !== undefined) {
				// access a sub element of the property array (only primitives are supported right now)
				if (propertyName === 'morphTargetInfluences') {
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
					// support resolving morphTarget names into indices.
					if (!targetObject.geometry) {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
						return;
					}

					if (targetObject.geometry.isBufferGeometry) {
						if (!targetObject.geometry.morphAttributes) {
							console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
							return;
						}

						if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
							propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
						}
					} else {
						console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
						return;
					}
				}

				bindingType = this.BindingType.ArrayElement;
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
			} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
				// must use copy for Object3D.Euler/Quaternion
				bindingType = this.BindingType.HasFromToArray;
				this.resolvedProperty = nodeProperty;
			} else if (Array.isArray(nodeProperty)) {
				bindingType = this.BindingType.EntireArray;
				this.resolvedProperty = nodeProperty;
			} else {
				this.propertyName = propertyName;
			} // select getter / setter


			this.getValue = this.GetterByBindingType[bindingType];
			this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
		}

		unbind() {
			this.node = null; // back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'

			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
		}

	}

	PropertyBinding.Composite = Composite;
	PropertyBinding.prototype.BindingType = {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	};
	PropertyBinding.prototype.Versioning = {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	};
	PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
	PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[// Direct
	PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [// EntireArray
	PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [// ArrayElement
	PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [// HasToFromArray
	PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *	- Add objects you would otherwise pass as 'root' to the
	 *		constructor or the .clipAction method of AnimationMixer.
	 *
	 *	- Instead pass this object as 'root'.
	 *
	 *	- You can also add and remove objects later when the mixer
	 *		is running.
	 *
	 * Note:
	 *
	 *		Objects of this class appear as one object to the mixer,
	 *		so cache control of the individual objects must be done
	 *		on the group.
	 *
	 * Limitation:
	 *
	 *	- The animated properties must be compatible among the
	 *		all objects in the group.
	 *
	 *	- A single property can either be controlled through a
	 *		target group or directly, but not both.
	 */

	class AnimationObjectGroup {
		constructor() {
			this.uuid = generateUUID(); // cached objects followed by the active ones

			this._objects = Array.prototype.slice.call(arguments);
			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				indices[arguments[i].uuid] = i;
			}

			this._paths = []; // inside: string

			this._parsedPaths = []; // inside: { we don't care, here }

			this._bindings = []; // inside: Array< PropertyBinding >

			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			const scope = this;
			this.stats = {
				objects: {
					get total() {
						return scope._objects.length;
					},

					get inUse() {
						return this.total - scope.nCachedObjects_;
					}

				},

				get bindingsPerObject() {
					return scope._bindings.length;
				}

			};
		}

		add() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						nBindings = bindings.length;
			let knownObject = undefined,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid;
				let index = indicesByUUID[uuid];

				if (index === undefined) {
					// unknown object -> add it to the ACTIVE region
					index = nObjects++;
					indicesByUUID[uuid] = index;
					objects.push(object); // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
					}
				} else if (index < nCachedObjects) {
					knownObject = objects[index]; // move existing object to the ACTIVE region

					const firstActiveIndex = --nCachedObjects,
								lastCachedObject = objects[firstActiveIndex];
					indicesByUUID[lastCachedObject.uuid] = index;
					objects[index] = lastCachedObject;
					indicesByUUID[uuid] = firstActiveIndex;
					objects[firstActiveIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									lastCached = bindingsForPath[firstActiveIndex];
						let binding = bindingsForPath[index];
						bindingsForPath[index] = lastCached;

						if (binding === undefined) {
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
							binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
						}

						bindingsForPath[firstActiveIndex] = binding;
					}
				} else if (objects[index] !== knownObject) {
					console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
				} // else the object is already where we want it to be

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		}

		remove() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined && index >= nCachedObjects) {
					// move existing object into the CACHED region
					const lastCachedIndex = nCachedObjects++,
								firstActiveObject = objects[lastCachedIndex];
					indicesByUUID[firstActiveObject.uuid] = index;
					objects[index] = firstActiveObject;
					indicesByUUID[uuid] = lastCachedIndex;
					objects[lastCachedIndex] = object; // accounting is done, now do the same for all bindings

					for (let j = 0, m = nBindings; j !== m; ++j) {
						const bindingsForPath = bindings[j],
									firstActive = bindingsForPath[lastCachedIndex],
									binding = bindingsForPath[index];
						bindingsForPath[index] = firstActive;
						bindingsForPath[lastCachedIndex] = binding;
					}
				}
			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // remove & forget


		uncache() {
			const objects = this._objects,
						indicesByUUID = this._indicesByUUID,
						bindings = this._bindings,
						nBindings = bindings.length;
			let nCachedObjects = this.nCachedObjects_,
					nObjects = objects.length;

			for (let i = 0, n = arguments.length; i !== n; ++i) {
				const object = arguments[i],
							uuid = object.uuid,
							index = indicesByUUID[uuid];

				if (index !== undefined) {
					delete indicesByUUID[uuid];

					if (index < nCachedObjects) {
						// object is cached, shrink the CACHED region
						const firstActiveIndex = --nCachedObjects,
									lastCachedObject = objects[firstActiveIndex],
									lastIndex = --nObjects,
									lastObject = objects[lastIndex]; // last cached object takes this object's place

						indicesByUUID[lastCachedObject.uuid] = index;
						objects[index] = lastCachedObject; // last object goes to the activated slot and pop

						indicesByUUID[lastObject.uuid] = firstActiveIndex;
						objects[firstActiveIndex] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j],
										lastCached = bindingsForPath[firstActiveIndex],
										last = bindingsForPath[lastIndex];
							bindingsForPath[index] = lastCached;
							bindingsForPath[firstActiveIndex] = last;
							bindingsForPath.pop();
						}
					} else {
						// object is active, just swap with the last and pop
						const lastIndex = --nObjects,
									lastObject = objects[lastIndex];

						if (lastIndex > 0) {
							indicesByUUID[lastObject.uuid] = index;
						}

						objects[index] = lastObject;
						objects.pop(); // accounting is done, now do the same for all bindings

						for (let j = 0, m = nBindings; j !== m; ++j) {
							const bindingsForPath = bindings[j];
							bindingsForPath[index] = bindingsForPath[lastIndex];
							bindingsForPath.pop();
						}
					} // cached or active

				} // if object is known

			} // for arguments


			this.nCachedObjects_ = nCachedObjects;
		} // Internal interface used by befriended PropertyBinding.Composite:


		subscribe_(path, parsedPath) {
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[path];
			const bindings = this._bindings;
			if (index !== undefined) return bindings[index];
			const paths = this._paths,
						parsedPaths = this._parsedPaths,
						objects = this._objects,
						nObjects = objects.length,
						nCachedObjects = this.nCachedObjects_,
						bindingsForPath = new Array(nObjects);
			index = bindings.length;
			indicesByPath[path] = index;
			paths.push(path);
			parsedPaths.push(parsedPath);
			bindings.push(bindingsForPath);

			for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
				const object = objects[i];
				bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
			}

			return bindingsForPath;
		}

		unsubscribe_(path) {
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
			const indicesByPath = this._bindingsIndicesByPath,
						index = indicesByPath[path];

			if (index !== undefined) {
				const paths = this._paths,
							parsedPaths = this._parsedPaths,
							bindings = this._bindings,
							lastBindingsIndex = bindings.length - 1,
							lastBindings = bindings[lastBindingsIndex],
							lastBindingsPath = path[lastBindingsIndex];
				indicesByPath[lastBindingsPath] = index;
				bindings[index] = lastBindings;
				bindings.pop();
				parsedPaths[index] = parsedPaths[lastBindingsIndex];
				parsedPaths.pop();
				paths[index] = paths[lastBindingsIndex];
				paths.pop();
			}
		}

	}

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

	class AnimationAction {
		constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;
			const tracks = clip.tracks,
						nTracks = tracks.length,
						interpolants = new Array(nTracks);
			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for (let i = 0; i !== nTracks; ++i) {
				const interpolant = tracks[i].createInterpolant(null);
				interpolants[i] = interpolant;
				interpolant.settings = interpolantSettings;
			}

			this._interpolantSettings = interpolantSettings;
			this._interpolants = interpolants; // bound by the mixer
			// inside: PropertyMixer (managed by the mixer)

			this._propertyBindings = new Array(nTracks);
			this._cacheIndex = null; // for the memory manager

			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
			this.loop = LoopRepeat;
			this._loopCount = -1; // global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action

			this._startTime = null; // scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop

			this.time = 0;
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
			this.weight = 1;
			this._effectiveWeight = 1;
			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale

			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false; // keep feeding the last frame?

			this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate

			this.zeroSlopeAtEnd = true; // clips for start, loop and end
		} // State & Scheduling


		play() {
			this._mixer._activateAction(this);

			return this;
		}

		stop() {
			this._mixer._deactivateAction(this);

			return this.reset();
		}

		reset() {
			this.paused = false;
			this.enabled = true;
			this.time = 0; // restart clip

			this._loopCount = -1; // forget previous loops

			this._startTime = null; // forget scheduling

			return this.stopFading().stopWarping();
		}

		isRunning() {
			return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
		} // return true when play has been called


		isScheduled() {
			return this._mixer._isActiveAction(this);
		}

		startAt(time) {
			this._startTime = time;
			return this;
		}

		setLoop(mode, repetitions) {
			this.loop = mode;
			this.repetitions = repetitions;
			return this;
		} // Weight
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing


		setEffectiveWeight(weight) {
			this.weight = weight; // note: same logic as when updated at runtime

			this._effectiveWeight = this.enabled ? weight : 0;
			return this.stopFading();
		} // return the weight considering fading and .enabled


		getEffectiveWeight() {
			return this._effectiveWeight;
		}

		fadeIn(duration) {
			return this._scheduleFading(duration, 0, 1);
		}

		fadeOut(duration) {
			return this._scheduleFading(duration, 1, 0);
		}

		crossFadeFrom(fadeOutAction, duration, warp) {
			fadeOutAction.fadeOut(duration);
			this.fadeIn(duration);

			if (warp) {
				const fadeInDuration = this._clip.duration,
							fadeOutDuration = fadeOutAction._clip.duration,
							startEndRatio = fadeOutDuration / fadeInDuration,
							endStartRatio = fadeInDuration / fadeOutDuration;
				fadeOutAction.warp(1.0, startEndRatio, duration);
				this.warp(endStartRatio, 1.0, duration);
			}

			return this;
		}

		crossFadeTo(fadeInAction, duration, warp) {
			return fadeInAction.crossFadeFrom(this, duration, warp);
		}

		stopFading() {
			const weightInterpolant = this._weightInterpolant;

			if (weightInterpolant !== null) {
				this._weightInterpolant = null;

				this._mixer._takeBackControlInterpolant(weightInterpolant);
			}

			return this;
		} // Time Scale Control
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing


		setEffectiveTimeScale(timeScale) {
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
			return this.stopWarping();
		} // return the time scale considering warping and .paused


		getEffectiveTimeScale() {
			return this._effectiveTimeScale;
		}

		setDuration(duration) {
			this.timeScale = this._clip.duration / duration;
			return this.stopWarping();
		}

		syncWith(action) {
			this.time = action.time;
			this.timeScale = action.timeScale;
			return this.stopWarping();
		}

		halt(duration) {
			return this.warp(this._effectiveTimeScale, 0, duration);
		}

		warp(startTimeScale, endTimeScale, duration) {
			const mixer = this._mixer,
						now = mixer.time,
						timeScale = this.timeScale;
			let interpolant = this._timeScaleInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			times[1] = now + duration;
			values[0] = startTimeScale / timeScale;
			values[1] = endTimeScale / timeScale;
			return this;
		}

		stopWarping() {
			const timeScaleInterpolant = this._timeScaleInterpolant;

			if (timeScaleInterpolant !== null) {
				this._timeScaleInterpolant = null;

				this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
			}

			return this;
		} // Object Accessors


		getMixer() {
			return this._mixer;
		}

		getClip() {
			return this._clip;
		}

		getRoot() {
			return this._localRoot || this._mixer._root;
		} // Interna


		_update(time, deltaTime, timeDirection, accuIndex) {
			// called by the mixer
			if (!this.enabled) {
				// call ._updateWeight() to update ._effectiveWeight
				this._updateWeight(time);

				return;
			}

			const startTime = this._startTime;

			if (startTime !== null) {
				// check for scheduled start of action
				const timeRunning = (time - startTime) * timeDirection;

				if (timeRunning < 0 || timeDirection === 0) {
					return; // yet to come / don't decide when delta = 0
				} // start


				this._startTime = null; // unschedule

				deltaTime = timeDirection * timeRunning;
			} // apply time scale and advance time


			deltaTime *= this._updateTimeScale(time);

			const clipTime = this._updateTime(deltaTime); // note: _updateTime may disable the action resulting in
			// an effective weight of 0


			const weight = this._updateWeight(time);

			if (weight > 0) {
				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch (this.blendMode) {
					case AdditiveAnimationBlendMode:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulateAdditive(weight);
						}

						break;

					case NormalAnimationBlendMode:
					default:
						for (let j = 0, m = interpolants.length; j !== m; ++j) {
							interpolants[j].evaluate(clipTime);
							propertyMixers[j].accumulate(accuIndex, weight);
						}

				}
			}
		}

		_updateWeight(time) {
			let weight = 0;

			if (this.enabled) {
				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					weight *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopFading();

						if (interpolantValue === 0) {
							// faded out, disable
							this.enabled = false;
						}
					}
				}
			}

			this._effectiveWeight = weight;
			return weight;
		}

		_updateTimeScale(time) {
			let timeScale = 0;

			if (!this.paused) {
				timeScale = this.timeScale;
				const interpolant = this._timeScaleInterpolant;

				if (interpolant !== null) {
					const interpolantValue = interpolant.evaluate(time)[0];
					timeScale *= interpolantValue;

					if (time > interpolant.parameterPositions[1]) {
						this.stopWarping();

						if (timeScale === 0) {
							// motion has halted, pause
							this.paused = true;
						} else {
							// warp done - apply final time scale
							this.timeScale = timeScale;
						}
					}
				}
			}

			this._effectiveTimeScale = timeScale;
			return timeScale;
		}

		_updateTime(deltaTime) {
			const duration = this._clip.duration;
			const loop = this.loop;
			let time = this.time + deltaTime;
			let loopCount = this._loopCount;
			const pingPong = loop === LoopPingPong;

			if (deltaTime === 0) {
				if (loopCount === -1) return time;
				return pingPong && (loopCount & 1) === 1 ? duration - time : time;
			}

			if (loop === LoopOnce) {
				if (loopCount === -1) {
					// just started
					this._loopCount = 0;

					this._setEndings(true, true, false);
				}

				handle_stop: {
					if (time >= duration) {
						time = duration;
					} else if (time < 0) {
						time = 0;
					} else {
						this.time = time;
						break handle_stop;
					}

					if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
					this.time = time;

					this._mixer.dispatchEvent({
						type: 'finished',
						action: this,
						direction: deltaTime < 0 ? -1 : 1
					});
				}
			} else {
				// repetitive Repeat or PingPong
				if (loopCount === -1) {
					// just started
					if (deltaTime >= 0) {
						loopCount = 0;

						this._setEndings(true, this.repetitions === 0, pingPong);
					} else {
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
						this._setEndings(this.repetitions === 0, true, pingPong);
					}
				}

				if (time >= duration || time < 0) {
					// wrap around
					const loopDelta = Math.floor(time / duration); // signed

					time -= duration * loopDelta;
					loopCount += Math.abs(loopDelta);
					const pending = this.repetitions - loopCount;

					if (pending <= 0) {
						// have to stop (switch state, clamp time, fire event)
						if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
						time = deltaTime > 0 ? duration : 0;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'finished',
							action: this,
							direction: deltaTime > 0 ? 1 : -1
						});
					} else {
						// keep running
						if (pending === 1) {
							// entering the last round
							const atStart = deltaTime < 0;

							this._setEndings(atStart, !atStart, pingPong);
						} else {
							this._setEndings(false, false, pingPong);
						}

						this._loopCount = loopCount;
						this.time = time;

						this._mixer.dispatchEvent({
							type: 'loop',
							action: this,
							loopDelta: loopDelta
						});
					}
				} else {
					this.time = time;
				}

				if (pingPong && (loopCount & 1) === 1) {
					// invert time for the "pong round"
					return duration - time;
				}
			}

			return time;
		}

		_setEndings(atStart, atEnd, pingPong) {
			const settings = this._interpolantSettings;

			if (pingPong) {
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
			} else {
				// assuming for LoopOnce atStart == atEnd == true
				if (atStart) {
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingStart = WrapAroundEnding;
				}

				if (atEnd) {
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
				} else {
					settings.endingEnd = WrapAroundEnding;
				}
			}
		}

		_scheduleFading(duration, weightNow, weightThen) {
			const mixer = this._mixer,
						now = mixer.time;
			let interpolant = this._weightInterpolant;

			if (interpolant === null) {
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
			}

			const times = interpolant.parameterPositions,
						values = interpolant.sampleValues;
			times[0] = now;
			values[0] = weightNow;
			times[1] = now + duration;
			values[1] = weightThen;
			return this;
		}

	}

	class AnimationMixer extends EventDispatcher {
		constructor(root) {
			super();
			this._root = root;

			this._initMemoryManager();

			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;
		}

		_bindAction(action, prototypeAction) {
			const root = action._localRoot || this._root,
						tracks = action._clip.tracks,
						nTracks = tracks.length,
						bindings = action._propertyBindings,
						interpolants = action._interpolants,
						rootUuid = root.uuid,
						bindingsByRoot = this._bindingsByRootAndName;
			let bindingsByName = bindingsByRoot[rootUuid];

			if (bindingsByName === undefined) {
				bindingsByName = {};
				bindingsByRoot[rootUuid] = bindingsByName;
			}

			for (let i = 0; i !== nTracks; ++i) {
				const track = tracks[i],
							trackName = track.name;
				let binding = bindingsByName[trackName];

				if (binding !== undefined) {
					bindings[i] = binding;
				} else {
					binding = bindings[i];

					if (binding !== undefined) {
						// existing binding, make sure the cache knows
						if (binding._cacheIndex === null) {
							++binding.referenceCount;

							this._addInactiveBinding(binding, rootUuid, trackName);
						}

						continue;
					}

					const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
					binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
					++binding.referenceCount;

					this._addInactiveBinding(binding, rootUuid, trackName);

					bindings[i] = binding;
				}

				interpolants[i].resultBuffer = binding.buffer;
			}
		}

		_activateAction(action) {
			if (!this._isActiveAction(action)) {
				if (action._cacheIndex === null) {
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
					const rootUuid = (action._localRoot || this._root).uuid,
								clipUuid = action._clip.uuid,
								actionsForClip = this._actionsByClip[clipUuid];

					this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);

					this._addInactiveAction(action, clipUuid, rootUuid);
				}

				const bindings = action._propertyBindings; // increment reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (binding.useCount++ === 0) {
						this._lendBinding(binding);

						binding.saveOriginalState();
					}
				}

				this._lendAction(action);
			}
		}

		_deactivateAction(action) {
			if (this._isActiveAction(action)) {
				const bindings = action._propertyBindings; // decrement reference counts / sort out state

				for (let i = 0, n = bindings.length; i !== n; ++i) {
					const binding = bindings[i];

					if (--binding.useCount === 0) {
						binding.restoreOriginalState();

						this._takeBackBinding(binding);
					}
				}

				this._takeBackAction(action);
			}
		} // Memory manager


		_initMemoryManager() {
			this._actions = []; // 'nActiveActions' followed by inactive ones

			this._nActiveActions = 0;
			this._actionsByClip = {}; // inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }

			this._bindings = []; // 'nActiveBindings' followed by inactive ones

			this._nActiveBindings = 0;
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

			this._controlInterpolants = []; // same game as above

			this._nActiveControlInterpolants = 0;
			const scope = this;
			this.stats = {
				actions: {
					get total() {
						return scope._actions.length;
					},

					get inUse() {
						return scope._nActiveActions;
					}

				},
				bindings: {
					get total() {
						return scope._bindings.length;
					},

					get inUse() {
						return scope._nActiveBindings;
					}

				},
				controlInterpolants: {
					get total() {
						return scope._controlInterpolants.length;
					},

					get inUse() {
						return scope._nActiveControlInterpolants;
					}

				}
			};
		} // Memory management for AnimationAction objects


		_isActiveAction(action) {
			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
		}

		_addInactiveAction(action, clipUuid, rootUuid) {
			const actions = this._actions,
						actionsByClip = this._actionsByClip;
			let actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip === undefined) {
				actionsForClip = {
					knownActions: [action],
					actionByRoot: {}
				};
				action._byClipCacheIndex = 0;
				actionsByClip[clipUuid] = actionsForClip;
			} else {
				const knownActions = actionsForClip.knownActions;
				action._byClipCacheIndex = knownActions.length;
				knownActions.push(action);
			}

			action._cacheIndex = actions.length;
			actions.push(action);
			actionsForClip.actionByRoot[rootUuid] = action;
		}

		_removeInactiveAction(action) {
			const actions = this._actions,
						lastInactiveAction = actions[actions.length - 1],
						cacheIndex = action._cacheIndex;
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[cacheIndex] = lastInactiveAction;
			actions.pop();
			action._cacheIndex = null;
			const clipUuid = action._clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid],
						knownActionsForClip = actionsForClip.knownActions,
						lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
						byClipCacheIndex = action._byClipCacheIndex;
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[byClipCacheIndex] = lastKnownAction;
			knownActionsForClip.pop();
			action._byClipCacheIndex = null;
			const actionByRoot = actionsForClip.actionByRoot,
						rootUuid = (action._localRoot || this._root).uuid;
			delete actionByRoot[rootUuid];

			if (knownActionsForClip.length === 0) {
				delete actionsByClip[clipUuid];
			}

			this._removeInactiveBindingsForAction(action);
		}

		_removeInactiveBindingsForAction(action) {
			const bindings = action._propertyBindings;

			for (let i = 0, n = bindings.length; i !== n; ++i) {
				const binding = bindings[i];

				if (--binding.referenceCount === 0) {
					this._removeInactiveBinding(binding);
				}
			}
		}

		_lendAction(action) {
			// [ active actions |	inactive actions	]
			// [	active actions >| inactive actions ]
			//								 s				a
			//									<-swap->
			//								 a				s
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						lastActiveIndex = this._nActiveActions++,
						firstInactiveAction = actions[lastActiveIndex];
			action._cacheIndex = lastActiveIndex;
			actions[lastActiveIndex] = action;
			firstInactiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = firstInactiveAction;
		}

		_takeBackAction(action) {
			// [	active actions	| inactive actions ]
			// [ active actions |< inactive actions	]
			//				a				s
			//				 <-swap->
			//				s				a
			const actions = this._actions,
						prevIndex = action._cacheIndex,
						firstInactiveIndex = --this._nActiveActions,
						lastActiveAction = actions[firstInactiveIndex];
			action._cacheIndex = firstInactiveIndex;
			actions[firstInactiveIndex] = action;
			lastActiveAction._cacheIndex = prevIndex;
			actions[prevIndex] = lastActiveAction;
		} // Memory management for PropertyMixer objects


		_addInactiveBinding(binding, rootUuid, trackName) {
			const bindingsByRoot = this._bindingsByRootAndName,
						bindings = this._bindings;
			let bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName === undefined) {
				bindingByName = {};
				bindingsByRoot[rootUuid] = bindingByName;
			}

			bindingByName[trackName] = binding;
			binding._cacheIndex = bindings.length;
			bindings.push(binding);
		}

		_removeInactiveBinding(binding) {
			const bindings = this._bindings,
						propBinding = binding.binding,
						rootUuid = propBinding.rootNode.uuid,
						trackName = propBinding.path,
						bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid],
						lastInactiveBinding = bindings[bindings.length - 1],
						cacheIndex = binding._cacheIndex;
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[cacheIndex] = lastInactiveBinding;
			bindings.pop();
			delete bindingByName[trackName];

			if (Object.keys(bindingByName).length === 0) {
				delete bindingsByRoot[rootUuid];
			}
		}

		_lendBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						lastActiveIndex = this._nActiveBindings++,
						firstInactiveBinding = bindings[lastActiveIndex];
			binding._cacheIndex = lastActiveIndex;
			bindings[lastActiveIndex] = binding;
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = firstInactiveBinding;
		}

		_takeBackBinding(binding) {
			const bindings = this._bindings,
						prevIndex = binding._cacheIndex,
						firstInactiveIndex = --this._nActiveBindings,
						lastActiveBinding = bindings[firstInactiveIndex];
			binding._cacheIndex = firstInactiveIndex;
			bindings[firstInactiveIndex] = binding;
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[prevIndex] = lastActiveBinding;
		} // Memory management of Interpolants for weight and time scale


		_lendControlInterpolant() {
			const interpolants = this._controlInterpolants,
						lastActiveIndex = this._nActiveControlInterpolants++;
			let interpolant = interpolants[lastActiveIndex];

			if (interpolant === undefined) {
				interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[lastActiveIndex] = interpolant;
			}

			return interpolant;
		}

		_takeBackControlInterpolant(interpolant) {
			const interpolants = this._controlInterpolants,
						prevIndex = interpolant.__cacheIndex,
						firstInactiveIndex = --this._nActiveControlInterpolants,
						lastActiveInterpolant = interpolants[firstInactiveIndex];
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[firstInactiveIndex] = interpolant;
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[prevIndex] = lastActiveInterpolant;
		} // return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)


		clipAction(clip, optionalRoot, blendMode) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid;
			let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
			const clipUuid = clipObject !== null ? clipObject.uuid : clip;
			const actionsForClip = this._actionsByClip[clipUuid];
			let prototypeAction = null;

			if (blendMode === undefined) {
				if (clipObject !== null) {
					blendMode = clipObject.blendMode;
				} else {
					blendMode = NormalAnimationBlendMode;
				}
			}

			if (actionsForClip !== undefined) {
				const existingAction = actionsForClip.actionByRoot[rootUuid];

				if (existingAction !== undefined && existingAction.blendMode === blendMode) {
					return existingAction;
				} // we know the clip, so we don't have to parse all
				// the bindings again but can just copy


				prototypeAction = actionsForClip.knownActions[0]; // also, take the clip from the prototype action

				if (clipObject === null) clipObject = prototypeAction._clip;
			} // clip must be known when specified via string


			if (clipObject === null) return null; // allocate all resources required to run it

			const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);

			this._bindAction(newAction, prototypeAction); // and make the action known to the memory manager


			this._addInactiveAction(newAction, clipUuid, rootUuid);

			return newAction;
		} // get an existing action


		existingAction(clip, optionalRoot) {
			const root = optionalRoot || this._root,
						rootUuid = root.uuid,
						clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
						clipUuid = clipObject ? clipObject.uuid : clip,
						actionsForClip = this._actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				return actionsForClip.actionByRoot[rootUuid] || null;
			}

			return null;
		} // deactivates all previously scheduled actions


		stopAllAction() {
			const actions = this._actions,
						nActions = this._nActiveActions;

			for (let i = nActions - 1; i >= 0; --i) {
				actions[i].stop();
			}

			return this;
		} // advance the time and update apply the animation


		update(deltaTime) {
			deltaTime *= this.timeScale;
			const actions = this._actions,
						nActions = this._nActiveActions,
						time = this.time += deltaTime,
						timeDirection = Math.sign(deltaTime),
						accuIndex = this._accuIndex ^= 1; // run active actions

			for (let i = 0; i !== nActions; ++i) {
				const action = actions[i];

				action._update(time, deltaTime, timeDirection, accuIndex);
			} // update scene graph


			const bindings = this._bindings,
						nBindings = this._nActiveBindings;

			for (let i = 0; i !== nBindings; ++i) {
				bindings[i].apply(accuIndex);
			}

			return this;
		} // Allows you to seek to a specific time in an animation.


		setTime(timeInSeconds) {
			this.time = 0; // Zero out time attribute for AnimationMixer object;

			for (let i = 0; i < this._actions.length; i++) {
				this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
			}

			return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
		} // return this mixer's root target object


		getRoot() {
			return this._root;
		} // free all resources specific to a particular clip


		uncacheClip(clip) {
			const actions = this._actions,
						clipUuid = clip.uuid,
						actionsByClip = this._actionsByClip,
						actionsForClip = actionsByClip[clipUuid];

			if (actionsForClip !== undefined) {
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
				const actionsToRemove = actionsForClip.knownActions;

				for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
					const action = actionsToRemove[i];

					this._deactivateAction(action);

					const cacheIndex = action._cacheIndex,
								lastInactiveAction = actions[actions.length - 1];
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[cacheIndex] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction(action);
				}

				delete actionsByClip[clipUuid];
			}
		} // free all resources specific to a particular root target object


		uncacheRoot(root) {
			const rootUuid = root.uuid,
						actionsByClip = this._actionsByClip;

			for (const clipUuid in actionsByClip) {
				const actionByRoot = actionsByClip[clipUuid].actionByRoot,
							action = actionByRoot[rootUuid];

				if (action !== undefined) {
					this._deactivateAction(action);

					this._removeInactiveAction(action);
				}
			}

			const bindingsByRoot = this._bindingsByRootAndName,
						bindingByName = bindingsByRoot[rootUuid];

			if (bindingByName !== undefined) {
				for (const trackName in bindingByName) {
					const binding = bindingByName[trackName];
					binding.restoreOriginalState();

					this._removeInactiveBinding(binding);
				}
			}
		} // remove a targeted clip from the cache


		uncacheAction(clip, optionalRoot) {
			const action = this.existingAction(clip, optionalRoot);

			if (action !== null) {
				this._deactivateAction(action);

				this._removeInactiveAction(action);
			}
		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);

	class Uniform {
		constructor(value) {
			if (typeof value === 'string') {
				console.warn('THREE.Uniform: Type parameter is no longer needed.');
				value = arguments[1];
			}

			this.value = value;
		}

		clone() {
			return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
		}

	}

	class InstancedInterleavedBuffer extends InterleavedBuffer {
		constructor(array, stride, meshPerAttribute = 1) {
			super(array, stride);
			this.meshPerAttribute = meshPerAttribute;
		}

		copy(source) {
			super.copy(source);
			this.meshPerAttribute = source.meshPerAttribute;
			return this;
		}

		clone(data) {
			const ib = super.clone(data);
			ib.meshPerAttribute = this.meshPerAttribute;
			return ib;
		}

		toJSON(data) {
			const json = super.toJSON(data);
			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;
			return json;
		}

	}

	InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

	class GLBufferAttribute {
		constructor(buffer, type, itemSize, elementSize, count) {
			this.buffer = buffer;
			this.type = type;
			this.itemSize = itemSize;
			this.elementSize = elementSize;
			this.count = count;
			this.version = 0;
		}

		set needsUpdate(value) {
			if (value === true) this.version++;
		}

		setBuffer(buffer) {
			this.buffer = buffer;
			return this;
		}

		setType(type, elementSize) {
			this.type = type;
			this.elementSize = elementSize;
			return this;
		}

		setItemSize(itemSize) {
			this.itemSize = itemSize;
			return this;
		}

		setCount(count) {
			this.count = count;
			return this;
		}

	}

	GLBufferAttribute.prototype.isGLBufferAttribute = true;

	class Raycaster {
		constructor(origin, direction, near = 0, far = Infinity) {
			this.ray = new Ray(origin, direction); // direction is assumed to be normalized (for accurate distance calculations)

			this.near = near;
			this.far = far;
			this.camera = null;
			this.layers = new Layers();
			this.params = {
				Mesh: {},
				Line: {
					threshold: 1
				},
				LOD: {},
				Points: {
					threshold: 1
				},
				Sprite: {}
			};
		}

		set(origin, direction) {
			// direction is assumed to be normalized (for accurate distance calculations)
			this.ray.set(origin, direction);
		}

		setFromCamera(coords, camera) {
			if (camera && camera.isPerspectiveCamera) {
				this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
				this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
				this.camera = camera;
			} else if (camera && camera.isOrthographicCamera) {
				this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

				this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
				this.camera = camera;
			} else {
				console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
			}
		}

		intersectObject(object, recursive = false, intersects = []) {
			intersectObject(object, this, intersects, recursive);
			intersects.sort(ascSort);
			return intersects;
		}

		intersectObjects(objects, recursive = false, intersects = []) {
			for (let i = 0, l = objects.length; i < l; i++) {
				intersectObject(objects[i], this, intersects, recursive);
			}

			intersects.sort(ascSort);
			return intersects;
		}

	}

	function ascSort(a, b) {
		return a.distance - b.distance;
	}

	function intersectObject(object, raycaster, intersects, recursive) {
		if (object.layers.test(raycaster.layers)) {
			object.raycast(raycaster, intersects);
		}

		if (recursive === true) {
			const children = object.children;

			for (let i = 0, l = children.length; i < l; i++) {
				intersectObject(children[i], raycaster, intersects, true);
			}
		}
	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {
		constructor(radius = 1, phi = 0, theta = 0) {
			this.radius = radius;
			this.phi = phi; // polar angle

			this.theta = theta; // azimuthal angle

			return this;
		}

		set(radius, phi, theta) {
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
			return this;
		} // restrict phi to be betwee EPS and PI-EPS


		makeSafe() {
			const EPS = 0.000001;
			this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + y * y + z * z);

			if (this.radius === 0) {
				this.theta = 0;
				this.phi = 0;
			} else {
				this.theta = Math.atan2(x, z);
				this.phi = Math.acos(clamp(y / this.radius, -1, 1));
			}

			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */
	class Cylindrical {
		constructor(radius = 1, theta = 0, y = 0) {
			this.radius = radius; // distance from the origin to a point in the x-z plane

			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis

			this.y = y; // height above the x-z plane

			return this;
		}

		set(radius, theta, y) {
			this.radius = radius;
			this.theta = theta;
			this.y = y;
			return this;
		}

		copy(other) {
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
			return this;
		}

		setFromVector3(v) {
			return this.setFromCartesianCoords(v.x, v.y, v.z);
		}

		setFromCartesianCoords(x, y, z) {
			this.radius = Math.sqrt(x * x + z * z);
			this.theta = Math.atan2(x, z);
			this.y = y;
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	const _vector$4 = /*@__PURE__*/new Vector2();

	class Box2 {
		constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
			this.min = min;
			this.max = max;
		}

		set(min, max) {
			this.min.copy(min);
			this.max.copy(max);
			return this;
		}

		setFromPoints(points) {
			this.makeEmpty();

			for (let i = 0, il = points.length; i < il; i++) {
				this.expandByPoint(points[i]);
			}

			return this;
		}

		setFromCenterAndSize(center, size) {
			const halfSize = _vector$4.copy(size).multiplyScalar(0.5);

			this.min.copy(center).sub(halfSize);
			this.max.copy(center).add(halfSize);
			return this;
		}

		clone() {
			return new this.constructor().copy(this);
		}

		copy(box) {
			this.min.copy(box.min);
			this.max.copy(box.max);
			return this;
		}

		makeEmpty() {
			this.min.x = this.min.y = +Infinity;
			this.max.x = this.max.y = -Infinity;
			return this;
		}

		isEmpty() {
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
			return this.max.x < this.min.x || this.max.y < this.min.y;
		}

		getCenter(target) {
			return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
		}

		getSize(target) {
			return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
		}

		expandByPoint(point) {
			this.min.min(point);
			this.max.max(point);
			return this;
		}

		expandByVector(vector) {
			this.min.sub(vector);
			this.max.add(vector);
			return this;
		}

		expandByScalar(scalar) {
			this.min.addScalar(-scalar);
			this.max.addScalar(scalar);
			return this;
		}

		containsPoint(point) {
			return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
		}

		containsBox(box) {
			return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
		}

		getParameter(point, target) {
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
			return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
		}

		intersectsBox(box) {
			// using 4 splitting planes to rule out intersections
			return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
		}

		clampPoint(point, target) {
			return target.copy(point).clamp(this.min, this.max);
		}

		distanceToPoint(point) {
			const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);

			return clampedPoint.sub(point).length();
		}

		intersect(box) {
			this.min.max(box.min);
			this.max.min(box.max);
			return this;
		}

		union(box) {
			this.min.min(box.min);
			this.max.max(box.max);
			return this;
		}

		translate(offset) {
			this.min.add(offset);
			this.max.add(offset);
			return this;
		}

		equals(box) {
			return box.min.equals(this.min) && box.max.equals(this.max);
		}

	}

	Box2.prototype.isBox2 = true;

	const _startP = /*@__PURE__*/new Vector3();

	const _startEnd = /*@__PURE__*/new Vector3();

	class Line3 {
		constructor(start = new Vector3(), end = new Vector3()) {
			this.start = start;
			this.end = end;
		}

		set(start, end) {
			this.start.copy(start);
			this.end.copy(end);
			return this;
		}

		copy(line) {
			this.start.copy(line.start);
			this.end.copy(line.end);
			return this;
		}

		getCenter(target) {
			return target.addVectors(this.start, this.end).multiplyScalar(0.5);
		}

		delta(target) {
			return target.subVectors(this.end, this.start);
		}

		distanceSq() {
			return this.start.distanceToSquared(this.end);
		}

		distance() {
			return this.start.distanceTo(this.end);
		}

		at(t, target) {
			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		closestPointToPointParameter(point, clampToLine) {
			_startP.subVectors(point, this.start);

			_startEnd.subVectors(this.end, this.start);

			const startEnd2 = _startEnd.dot(_startEnd);

			const startEnd_startP = _startEnd.dot(_startP);

			let t = startEnd_startP / startEnd2;

			if (clampToLine) {
				t = clamp(t, 0, 1);
			}

			return t;
		}

		closestPointToPoint(point, clampToLine, target) {
			const t = this.closestPointToPointParameter(point, clampToLine);
			return this.delta(target).multiplyScalar(t).add(this.start);
		}

		applyMatrix4(matrix) {
			this.start.applyMatrix4(matrix);
			this.end.applyMatrix4(matrix);
			return this;
		}

		equals(line) {
			return line.start.equals(this.start) && line.end.equals(this.end);
		}

		clone() {
			return new this.constructor().copy(this);
		}

	}

	class ImmediateRenderObject extends Object3D {
		constructor(material) {
			super();
			this.material = material;

			this.render = function ()
			/* renderCallback */
			{};

			this.hasPositions = false;
			this.hasNormals = false;
			this.hasColors = false;
			this.hasUvs = false;
			this.positionArray = null;
			this.normalArray = null;
			this.colorArray = null;
			this.uvArray = null;
			this.count = 0;
		}

	}

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	const _vector$3 = /*@__PURE__*/new Vector3();

	class SpotLightHelper extends Object3D {
		constructor(light, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new BufferGeometry();
			const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];

			for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
				const p1 = i / l * Math.PI * 2;
				const p2 = j / l * Math.PI * 2;
				positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.cone = new LineSegments(geometry, material);
			this.add(this.cone);
			this.update();
		}

		dispose() {
			this.cone.geometry.dispose();
			this.cone.material.dispose();
		}

		update() {
			this.light.updateMatrixWorld();
			const coneLength = this.light.distance ? this.light.distance : 1000;
			const coneWidth = coneLength * Math.tan(this.light.angle);
			this.cone.scale.set(coneWidth, coneWidth, coneLength);

			_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);

			this.cone.lookAt(_vector$3);

			if (this.color !== undefined) {
				this.cone.material.color.set(this.color);
			} else {
				this.cone.material.color.copy(this.light.color);
			}
		}

	}

	const _vector$2 = /*@__PURE__*/new Vector3();

	const _boneMatrix = /*@__PURE__*/new Matrix4();

	const _matrixWorldInv = /*@__PURE__*/new Matrix4();

	class SkeletonHelper extends LineSegments {
		constructor(object) {
			const bones = getBoneList(object);
			const geometry = new BufferGeometry();
			const vertices = [];
			const colors = [];
			const color1 = new Color(0, 0, 1);
			const color2 = new Color(0, 1, 0);

			for (let i = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					vertices.push(0, 0, 0);
					vertices.push(0, 0, 0);
					colors.push(color1.r, color1.g, color1.b);
					colors.push(color2.r, color2.g, color2.b);
				}
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				depthTest: false,
				depthWrite: false,
				toneMapped: false,
				transparent: true
			});
			super(geometry, material);
			this.type = 'SkeletonHelper';
			this.isSkeletonHelper = true;
			this.root = object;
			this.bones = bones;
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
		}

		updateMatrixWorld(force) {
			const bones = this.bones;
			const geometry = this.geometry;
			const position = geometry.getAttribute('position');

			_matrixWorldInv.copy(this.root.matrixWorld).invert();

			for (let i = 0, j = 0; i < bones.length; i++) {
				const bone = bones[i];

				if (bone.parent && bone.parent.isBone) {
					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);

					_boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);

					_vector$2.setFromMatrixPosition(_boneMatrix);

					position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
					j += 2;
				}
			}

			geometry.getAttribute('position').needsUpdate = true;
			super.updateMatrixWorld(force);
		}

	}

	function getBoneList(object) {
		const boneList = [];

		if (object && object.isBone) {
			boneList.push(object);
		}

		for (let i = 0; i < object.children.length; i++) {
			boneList.push.apply(boneList, getBoneList(object.children[i]));
		}

		return boneList;
	}

	class PointLightHelper extends Mesh {
		constructor(light, sphereSize, color) {
			const geometry = new SphereGeometry(sphereSize, 4, 2);
			const material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			super(geometry, material);
			this.light = light;
			this.light.updateMatrixWorld();
			this.color = color;
			this.type = 'PointLightHelper';
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.update();
			/*
			// TODO: delete this comment?
			const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
			const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
			const d = light.distance;
			if ( d === 0.0 ) {
				this.lightDistance.visible = false;
			} else {
				this.lightDistance.scale.set( d, d, d );
			}
			this.add( this.lightDistance );
			*/
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

		update() {
			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				this.material.color.copy(this.light.color);
			}
			/*
			const d = this.light.distance;
				if ( d === 0.0 ) {
					this.lightDistance.visible = false;
				} else {
					this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
				}
			*/

		}

	}

	const _vector$1 = /*@__PURE__*/new Vector3();

	const _color1 = /*@__PURE__*/new Color();

	const _color2 = /*@__PURE__*/new Color();

	class HemisphereLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			const geometry = new OctahedronGeometry(size);
			geometry.rotateY(Math.PI * 0.5);
			this.material = new MeshBasicMaterial({
				wireframe: true,
				fog: false,
				toneMapped: false
			});
			if (this.color === undefined) this.material.vertexColors = true;
			const position = geometry.getAttribute('position');
			const colors = new Float32Array(position.count * 3);
			geometry.setAttribute('color', new BufferAttribute(colors, 3));
			this.add(new Mesh(geometry, this.material));
			this.update();
		}

		dispose() {
			this.children[0].geometry.dispose();
			this.children[0].material.dispose();
		}

		update() {
			const mesh = this.children[0];

			if (this.color !== undefined) {
				this.material.color.set(this.color);
			} else {
				const colors = mesh.geometry.getAttribute('color');

				_color1.copy(this.light.color);

				_color2.copy(this.light.groundColor);

				for (let i = 0, l = colors.count; i < l; i++) {
					const color = i < l / 2 ? _color1 : _color2;
					colors.setXYZ(i, color.r, color.g, color.b);
				}

				colors.needsUpdate = true;
			}

			mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
		}

	}

	class GridHelper extends LineSegments {
		constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const center = divisions / 2;
			const step = size / divisions;
			const halfSize = size / 2;
			const vertices = [],
						colors = [];

			for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
				vertices.push(-halfSize, 0, k, halfSize, 0, k);
				vertices.push(k, 0, -halfSize, k, 0, halfSize);
				const color = i === center ? color1 : color2;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
				color.toArray(colors, j);
				j += 3;
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'GridHelper';
		}

	}

	class PolarGridHelper extends LineSegments {
		constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
			color1 = new Color(color1);
			color2 = new Color(color2);
			const vertices = [];
			const colors = []; // create the radials

			for (let i = 0; i <= radials; i++) {
				const v = i / radials * (Math.PI * 2);
				const x = Math.sin(v) * radius;
				const z = Math.cos(v) * radius;
				vertices.push(0, 0, 0);
				vertices.push(x, 0, z);
				const color = i & 1 ? color1 : color2;
				colors.push(color.r, color.g, color.b);
				colors.push(color.r, color.g, color.b);
			} // create the circles


			for (let i = 0; i <= circles; i++) {
				const color = i & 1 ? color1 : color2;
				const r = radius - radius / circles * i;

				for (let j = 0; j < divisions; j++) {
					// first vertex
					let v = j / divisions * (Math.PI * 2);
					let x = Math.sin(v) * r;
					let z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b); // second vertex

					v = (j + 1) / divisions * (Math.PI * 2);
					x = Math.sin(v) * r;
					z = Math.cos(v) * r;
					vertices.push(x, 0, z);
					colors.push(color.r, color.g, color.b);
				}
			}

			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'PolarGridHelper';
		}

	}

	const _v1 = /*@__PURE__*/new Vector3();

	const _v2 = /*@__PURE__*/new Vector3();

	const _v3 = /*@__PURE__*/new Vector3();

	class DirectionalLightHelper extends Object3D {
		constructor(light, size, color) {
			super();
			this.light = light;
			this.light.updateMatrixWorld();
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
			this.color = color;
			if (size === undefined) size = 1;
			let geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
			const material = new LineBasicMaterial({
				fog: false,
				toneMapped: false
			});
			this.lightPlane = new Line(geometry, material);
			this.add(this.lightPlane);
			geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
			this.targetLine = new Line(geometry, material);
			this.add(this.targetLine);
			this.update();
		}

		dispose() {
			this.lightPlane.geometry.dispose();
			this.lightPlane.material.dispose();
			this.targetLine.geometry.dispose();
			this.targetLine.material.dispose();
		}

		update() {
			_v1.setFromMatrixPosition(this.light.matrixWorld);

			_v2.setFromMatrixPosition(this.light.target.matrixWorld);

			_v3.subVectors(_v2, _v1);

			this.lightPlane.lookAt(_v2);

			if (this.color !== undefined) {
				this.lightPlane.material.color.set(this.color);
				this.targetLine.material.color.set(this.color);
			} else {
				this.lightPlane.material.color.copy(this.light.color);
				this.targetLine.material.color.copy(this.light.color);
			}

			this.targetLine.lookAt(_v2);
			this.targetLine.scale.z = _v3.length();
		}

	}

	const _vector = /*@__PURE__*/new Vector3();

	const _camera = /*@__PURE__*/new Camera();
	/**
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */


	class CameraHelper extends LineSegments {
		constructor(camera) {
			const geometry = new BufferGeometry();
			const material = new LineBasicMaterial({
				color: 0xffffff,
				vertexColors: true,
				toneMapped: false
			});
			const vertices = [];
			const colors = [];
			const pointMap = {}; // colors

			const colorFrustum = new Color(0xffaa00);
			const colorCone = new Color(0xff0000);
			const colorUp = new Color(0x00aaff);
			const colorTarget = new Color(0xffffff);
			const colorCross = new Color(0x333333); // near

			addLine('n1', 'n2', colorFrustum);
			addLine('n2', 'n4', colorFrustum);
			addLine('n4', 'n3', colorFrustum);
			addLine('n3', 'n1', colorFrustum); // far

			addLine('f1', 'f2', colorFrustum);
			addLine('f2', 'f4', colorFrustum);
			addLine('f4', 'f3', colorFrustum);
			addLine('f3', 'f1', colorFrustum); // sides

			addLine('n1', 'f1', colorFrustum);
			addLine('n2', 'f2', colorFrustum);
			addLine('n3', 'f3', colorFrustum);
			addLine('n4', 'f4', colorFrustum); // cone

			addLine('p', 'n1', colorCone);
			addLine('p', 'n2', colorCone);
			addLine('p', 'n3', colorCone);
			addLine('p', 'n4', colorCone); // up

			addLine('u1', 'u2', colorUp);
			addLine('u2', 'u3', colorUp);
			addLine('u3', 'u1', colorUp); // target

			addLine('c', 't', colorTarget);
			addLine('p', 'c', colorCross); // cross

			addLine('cn1', 'cn2', colorCross);
			addLine('cn3', 'cn4', colorCross);
			addLine('cf1', 'cf2', colorCross);
			addLine('cf3', 'cf4', colorCross);

			function addLine(a, b, color) {
				addPoint(a, color);
				addPoint(b, color);
			}

			function addPoint(id, color) {
				vertices.push(0, 0, 0);
				colors.push(color.r, color.g, color.b);

				if (pointMap[id] === undefined) {
					pointMap[id] = [];
				}

				pointMap[id].push(vertices.length / 3 - 1);
			}

			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			super(geometry, material);
			this.type = 'CameraHelper';
			this.camera = camera;
			if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
			this.pointMap = pointMap;
			this.update();
		}

		update() {
			const geometry = this.geometry;
			const pointMap = this.pointMap;
			const w = 1,
						h = 1; // we need just camera projection matrix inverse
			// world matrix must be identity

			_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse); // center / target


			setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
			setPoint('t', pointMap, geometry, _camera, 0, 0, 1); // near

			setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
			setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
			setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
			setPoint('n4', pointMap, geometry, _camera, w, h, -1); // far

			setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
			setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
			setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
			setPoint('f4', pointMap, geometry, _camera, w, h, 1); // up

			setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
			setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
			setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1); // cross

			setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
			setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
			setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
			setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
			setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
			setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
			setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
			setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
			geometry.getAttribute('position').needsUpdate = true;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	function setPoint(point, pointMap, geometry, camera, x, y, z) {
		_vector.set(x, y, z).unproject(camera);

		const points = pointMap[point];

		if (points !== undefined) {
			const position = geometry.getAttribute('position');

			for (let i = 0, l = points.length; i < l; i++) {
				position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
			}
		}
	}

	const _box = /*@__PURE__*/new Box3();

	class BoxHelper extends LineSegments {
		constructor(object, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = new Float32Array(8 * 3);
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.object = object;
			this.type = 'BoxHelper';
			this.matrixAutoUpdate = false;
			this.update();
		}

		update(object) {
			if (object !== undefined) {
				console.warn('THREE.BoxHelper: .update() has no longer arguments.');
			}

			if (this.object !== undefined) {
				_box.setFromObject(this.object);
			}

			if (_box.isEmpty()) return;
			const min = _box.min;
			const max = _box.max;
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
				0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position;
			const array = position.array;
			array[0] = max.x;
			array[1] = max.y;
			array[2] = max.z;
			array[3] = min.x;
			array[4] = max.y;
			array[5] = max.z;
			array[6] = min.x;
			array[7] = min.y;
			array[8] = max.z;
			array[9] = max.x;
			array[10] = min.y;
			array[11] = max.z;
			array[12] = max.x;
			array[13] = max.y;
			array[14] = min.z;
			array[15] = min.x;
			array[16] = max.y;
			array[17] = min.z;
			array[18] = min.x;
			array[19] = min.y;
			array[20] = min.z;
			array[21] = max.x;
			array[22] = min.y;
			array[23] = min.z;
			position.needsUpdate = true;
			this.geometry.computeBoundingSphere();
		}

		setFromObject(object) {
			this.object = object;
			this.update();
			return this;
		}

		copy(source) {
			LineSegments.prototype.copy.call(this, source);
			this.object = source.object;
			return this;
		}

	}

	class Box3Helper extends LineSegments {
		constructor(box, color = 0xffff00) {
			const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
			const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
			const geometry = new BufferGeometry();
			geometry.setIndex(new BufferAttribute(indices, 1));
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.box = box;
			this.type = 'Box3Helper';
			this.geometry.computeBoundingSphere();
		}

		updateMatrixWorld(force) {
			const box = this.box;
			if (box.isEmpty()) return;
			box.getCenter(this.position);
			box.getSize(this.scale);
			this.scale.multiplyScalar(0.5);
			super.updateMatrixWorld(force);
		}

	}

	class PlaneHelper extends Line {
		constructor(plane, size = 1, hex = 0xffff00) {
			const color = hex;
			const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
			geometry.computeBoundingSphere();
			super(geometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.type = 'PlaneHelper';
			this.plane = plane;
			this.size = size;
			const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
			const geometry2 = new BufferGeometry();
			geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
			geometry2.computeBoundingSphere();
			this.add(new Mesh(geometry2, new MeshBasicMaterial({
				color: color,
				opacity: 0.2,
				transparent: true,
				depthWrite: false,
				toneMapped: false
			})));
		}

		updateMatrixWorld(force) {
			let scale = -this.plane.constant;
			if (Math.abs(scale) < 1e-8) scale = 1e-8; // sign does not matter

			this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
			this.children[0].material.side = scale < 0 ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

			this.lookAt(this.plane.normal);
			super.updateMatrixWorld(force);
		}

	}

	const _axis = /*@__PURE__*/new Vector3();

	let _lineGeometry, _coneGeometry;

	class ArrowHelper extends Object3D {
		// dir is assumed to be normalized
		constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
			super();
			this.type = 'ArrowHelper';

			if (_lineGeometry === undefined) {
				_lineGeometry = new BufferGeometry();

				_lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));

				_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);

				_coneGeometry.translate(0, -0.5, 0);
			}

			this.position.copy(origin);
			this.line = new Line(_lineGeometry, new LineBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.line.matrixAutoUpdate = false;
			this.add(this.line);
			this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
				color: color,
				toneMapped: false
			}));
			this.cone.matrixAutoUpdate = false;
			this.add(this.cone);
			this.setDirection(dir);
			this.setLength(length, headLength, headWidth);
		}

		setDirection(dir) {
			// dir is assumed to be normalized
			if (dir.y > 0.99999) {
				this.quaternion.set(0, 0, 0, 1);
			} else if (dir.y < -0.99999) {
				this.quaternion.set(1, 0, 0, 0);
			} else {
				_axis.set(dir.z, 0, -dir.x).normalize();

				const radians = Math.acos(dir.y);
				this.quaternion.setFromAxisAngle(_axis, radians);
			}
		}

		setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
			this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458

			this.line.updateMatrix();
			this.cone.scale.set(headWidth, headLength, headWidth);
			this.cone.position.y = length;
			this.cone.updateMatrix();
		}

		setColor(color) {
			this.line.material.color.set(color);
			this.cone.material.color.set(color);
		}

		copy(source) {
			super.copy(source, false);
			this.line.copy(source.line);
			this.cone.copy(source.cone);
			return this;
		}

	}

	class AxesHelper extends LineSegments {
		constructor(size = 1) {
			const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
			const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
			const geometry = new BufferGeometry();
			geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
			geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
			const material = new LineBasicMaterial({
				vertexColors: true,
				toneMapped: false
			});
			super(geometry, material);
			this.type = 'AxesHelper';
		}

		setColors(xAxisColor, yAxisColor, zAxisColor) {
			const color = new Color();
			const array = this.geometry.attributes.color.array;
			color.set(xAxisColor);
			color.toArray(array, 0);
			color.toArray(array, 3);
			color.set(yAxisColor);
			color.toArray(array, 6);
			color.toArray(array, 9);
			color.set(zAxisColor);
			color.toArray(array, 12);
			color.toArray(array, 15);
			this.geometry.attributes.color.needsUpdate = true;
			return this;
		}

		dispose() {
			this.geometry.dispose();
			this.material.dispose();
		}

	}

	const _floatView = new Float32Array(1);

	const _int32View = new Int32Array(_floatView.buffer);

	class DataUtils {
		// Converts float32 to float16 (stored as uint16 value).
		static toHalfFloat(val) {
			// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

			/* This method is faster than the OpenEXR implementation (very often
			* used, eg. in Ogre), with the additional benefit of rounding, inspired
			* by James Tursa?s half-precision code. */
			_floatView[0] = val;
			const x = _int32View[0];
			let bits = x >> 16 & 0x8000;
			/* Get the sign */

			let m = x >> 12 & 0x07ff;
			/* Keep one extra bit for rounding */

			const e = x >> 23 & 0xff;
			/* Using int is faster here */

			/* If zero, or denormal, or exponent underflows too much for a denormal
				* half, return signed zero. */

			if (e < 103) return bits;
			/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */

			if (e > 142) {
				bits |= 0x7c00;
				/* If exponent was 0xff and one mantissa bit was set, it means NaN,
							* not Inf, so make sure we set one mantissa bit too. */

				bits |= (e == 255 ? 0 : 1) && x & 0x007fffff;
				return bits;
			}
			/* If exponent underflows but not too much, return a denormal */


			if (e < 113) {
				m |= 0x0800;
				/* Extra rounding may overflow and set mantissa to 0 and exponent
					* to 1, which is OK. */

				bits |= (m >> 114 - e) + (m >> 113 - e & 1);
				return bits;
			}

			bits |= e - 112 << 10 | m >> 1;
			/* Extra rounding. An overflow will set mantissa to 0 and increment
				* the exponent, which is OK. */

			bits += m & 1;
			return bits;
		}

	}

	const LineStrip = 0;
	const LinePieces = 1;
	const NoColors = 0;
	const FaceColors = 1;
	const VertexColors = 2;
	function MeshFaceMaterial(materials) {
		console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');
		return materials;
	}
	function MultiMaterial(materials = []) {
		console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');
		materials.isMultiMaterial = true;
		materials.materials = materials;

		materials.clone = function () {
			return materials.slice();
		};

		return materials;
	}
	function PointCloud(geometry, material) {
		console.warn('THREE.PointCloud has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function Particle(material) {
		console.warn('THREE.Particle has been renamed to THREE.Sprite.');
		return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
		console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');
		return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
		console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
		console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
		console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');
		return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
		console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');
		return new Vector3(x, y, z);
	} //

	function DynamicBufferAttribute(array, itemSize) {
		console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');
		return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
		console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');
		return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
		console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');
		return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
		console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');
		return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
		console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');
		return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
		console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');
		return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
		console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');
		return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
		console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');
		return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
		console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');
		return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
		console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');
		return new Float64BufferAttribute(array, itemSize);
	} //

	Curve.create = function (construct, getPoint) {
		console.log('THREE.Curve.create() has been deprecated');
		construct.prototype = Object.create(Curve.prototype);
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
		return construct;
	}; //


	Path.prototype.fromPoints = function (points) {
		console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');
		return this.setFromPoints(points);
	}; //


	function AxisHelper(size) {
		console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');
		return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
		console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');
		return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
		console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');
		return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	}

	GridHelper.prototype.setColors = function () {
		console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');
	};

	SkeletonHelper.prototype.update = function () {
		console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
	};

	function WireframeHelper(object, hex) {
		console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');
		return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
			color: hex !== undefined ? hex : 0xffffff
		}));
	} //

	Loader.prototype.extractUrlBase = function (url) {
		console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');
		return LoaderUtils.extractUrlBase(url);
	};

	Loader.Handlers = {
		add: function ()
		/* regex, loader */
		{
			console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');
		},
		get: function ()
		/* file */
		{
			console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');
		}
	};
	function XHRLoader(manager) {
		console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');
		return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
		console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');
		return new DataTextureLoader(manager);
	} //

	Box2.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box2: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box2.prototype.empty = function () {
		console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box2.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box2.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box2: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Box3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Box3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	};

	Box3.prototype.empty = function () {
		console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	};

	Box3.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Box3.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	};

	Box3.prototype.size = function (optionalTarget) {
		console.warn('THREE.Box3: .size() has been renamed to .getSize().');
		return this.getSize(optionalTarget);
	}; //


	Sphere.prototype.empty = function () {
		console.warn('THREE.Sphere: .empty() has been renamed to .isEmpty().');
		return this.isEmpty();
	}; //


	Frustum.prototype.setFromMatrix = function (m) {
		console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');
		return this.setFromProjectionMatrix(m);
	}; //


	Line3.prototype.center = function (optionalTarget) {
		console.warn('THREE.Line3: .center() has been renamed to .getCenter().');
		return this.getCenter(optionalTarget);
	}; //


	Matrix3.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix3.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');
		return vector.applyMatrix3(this);
	};

	Matrix3.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
	};

	Matrix3.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');
		return attribute.applyMatrix3(this);
	};

	Matrix3.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
	};

	Matrix3.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Matrix4.prototype.extractPosition = function (m) {
		console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');
		return this.copyPosition(m);
	};

	Matrix4.prototype.flattenToArrayOffset = function (array, offset) {
		console.warn('THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.');
		return this.toArray(array, offset);
	};

	Matrix4.prototype.getPosition = function () {
		console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');
		return new Vector3().setFromMatrixColumn(this, 3);
	};

	Matrix4.prototype.setRotationFromQuaternion = function (q) {
		console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');
		return this.makeRotationFromQuaternion(q);
	};

	Matrix4.prototype.multiplyToArray = function () {
		console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
	};

	Matrix4.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector4 = function (vector) {
		console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.multiplyVector3Array = function ()
	/* a */
	{
		console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
	};

	Matrix4.prototype.rotateAxis = function (v) {
		console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');
		v.transformDirection(this);
	};

	Matrix4.prototype.crossVector = function (vector) {
		console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');
		return vector.applyMatrix4(this);
	};

	Matrix4.prototype.translate = function () {
		console.error('THREE.Matrix4: .translate() has been removed.');
	};

	Matrix4.prototype.rotateX = function () {
		console.error('THREE.Matrix4: .rotateX() has been removed.');
	};

	Matrix4.prototype.rotateY = function () {
		console.error('THREE.Matrix4: .rotateY() has been removed.');
	};

	Matrix4.prototype.rotateZ = function () {
		console.error('THREE.Matrix4: .rotateZ() has been removed.');
	};

	Matrix4.prototype.rotateByAxis = function () {
		console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
	};

	Matrix4.prototype.applyToBufferAttribute = function (attribute) {
		console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');
		return attribute.applyMatrix4(this);
	};

	Matrix4.prototype.applyToVector3Array = function ()
	/* array, offset, length */
	{
		console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
	};

	Matrix4.prototype.makeFrustum = function (left, right, bottom, top, near, far) {
		console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');
		return this.makePerspective(left, right, top, bottom, near, far);
	};

	Matrix4.prototype.getInverse = function (matrix) {
		console.warn('THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.');
		return this.copy(matrix).invert();
	}; //


	Plane.prototype.isIntersectionLine = function (line) {
		console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');
		return this.intersectsLine(line);
	}; //


	Quaternion.prototype.multiplyVector3 = function (vector) {
		console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');
		return vector.applyQuaternion(this);
	};

	Quaternion.prototype.inverse = function () {
		console.warn('THREE.Quaternion: .inverse() has been renamed to invert().');
		return this.invert();
	}; //


	Ray.prototype.isIntersectionBox = function (box) {
		console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');
		return this.intersectsBox(box);
	};

	Ray.prototype.isIntersectionPlane = function (plane) {
		console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');
		return this.intersectsPlane(plane);
	};

	Ray.prototype.isIntersectionSphere = function (sphere) {
		console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');
		return this.intersectsSphere(sphere);
	}; //


	Triangle.prototype.area = function () {
		console.warn('THREE.Triangle: .area() has been renamed to .getArea().');
		return this.getArea();
	};

	Triangle.prototype.barycoordFromPoint = function (point, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return this.getBarycoord(point, target);
	};

	Triangle.prototype.midpoint = function (target) {
		console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');
		return this.getMidpoint(target);
	};

	Triangle.prototypenormal = function (target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return this.getNormal(target);
	};

	Triangle.prototype.plane = function (target) {
		console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');
		return this.getPlane(target);
	};

	Triangle.barycoordFromPoint = function (point, a, b, c, target) {
		console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');
		return Triangle.getBarycoord(point, a, b, c, target);
	};

	Triangle.normal = function (a, b, c, target) {
		console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');
		return Triangle.getNormal(a, b, c, target);
	}; //


	Shape.prototype.extractAllPoints = function (divisions) {
		console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');
		return this.extractPoints(divisions);
	};

	Shape.prototype.extrude = function (options) {
		console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');
		return new ExtrudeGeometry(this, options);
	};

	Shape.prototype.makeGeometry = function (options) {
		console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');
		return new ShapeGeometry(this, options);
	}; //


	Vector2.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector2.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector2.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector3.prototype.setEulerFromRotationMatrix = function () {
		console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');
	};

	Vector3.prototype.setEulerFromQuaternion = function () {
		console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');
	};

	Vector3.prototype.getPositionFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');
		return this.setFromMatrixPosition(m);
	};

	Vector3.prototype.getScaleFromMatrix = function (m) {
		console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');
		return this.setFromMatrixScale(m);
	};

	Vector3.prototype.getColumnFromMatrix = function (index, matrix) {
		console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');
		return this.setFromMatrixColumn(matrix, index);
	};

	Vector3.prototype.applyProjection = function (m) {
		console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');
		return this.applyMatrix4(m);
	};

	Vector3.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector3.prototype.distanceToManhattan = function (v) {
		console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');
		return this.manhattanDistanceTo(v);
	};

	Vector3.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Vector4.prototype.fromAttribute = function (attribute, index, offset) {
		console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');
		return this.fromBufferAttribute(attribute, index, offset);
	};

	Vector4.prototype.lengthManhattan = function () {
		console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');
		return this.manhattanLength();
	}; //


	Object3D.prototype.getChildByName = function (name) {
		console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');
		return this.getObjectByName(name);
	};

	Object3D.prototype.renderDepth = function () {
		console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');
	};

	Object3D.prototype.translate = function (distance, axis) {
		console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');
		return this.translateOnAxis(axis, distance);
	};

	Object3D.prototype.getWorldRotation = function () {
		console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');
	};

	Object3D.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(Object3D.prototype, {
		eulerOrder: {
			get: function () {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				return this.rotation.order;
			},
			set: function (value) {
				console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');
				this.rotation.order = value;
			}
		},
		useQuaternion: {
			get: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			},
			set: function () {
				console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');
			}
		}
	});

	Mesh.prototype.setDrawMode = function () {
		console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
	};

	Object.defineProperties(Mesh.prototype, {
		drawMode: {
			get: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');
				return TrianglesDrawMode;
			},
			set: function () {
				console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');
			}
		}
	});

	SkinnedMesh.prototype.initBones = function () {
		console.error('THREE.SkinnedMesh: initBones() has been removed.');
	}; //


	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
		console.warn('THREE.PerspectiveCamera.setLens is deprecated. ' + 'Use .setFocalLength and .filmGauge for a photographic setup.');
		if (filmGauge !== undefined) this.filmGauge = filmGauge;
		this.setFocalLength(focalLength);
	}; //


	Object.defineProperties(Light.prototype, {
		onlyShadow: {
			set: function () {
				console.warn('THREE.Light: .onlyShadow has been removed.');
			}
		},
		shadowCameraFov: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');
				this.shadow.camera.fov = value;
			}
		},
		shadowCameraLeft: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');
				this.shadow.camera.left = value;
			}
		},
		shadowCameraRight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');
				this.shadow.camera.right = value;
			}
		},
		shadowCameraTop: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');
				this.shadow.camera.top = value;
			}
		},
		shadowCameraBottom: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');
				this.shadow.camera.bottom = value;
			}
		},
		shadowCameraNear: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');
				this.shadow.camera.near = value;
			}
		},
		shadowCameraFar: {
			set: function (value) {
				console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');
				this.shadow.camera.far = value;
			}
		},
		shadowCameraVisible: {
			set: function () {
				console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');
			}
		},
		shadowBias: {
			set: function (value) {
				console.warn('THREE.Light: .shadowBias is now .shadow.bias.');
				this.shadow.bias = value;
			}
		},
		shadowDarkness: {
			set: function () {
				console.warn('THREE.Light: .shadowDarkness has been removed.');
			}
		},
		shadowMapWidth: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');
				this.shadow.mapSize.width = value;
			}
		},
		shadowMapHeight: {
			set: function (value) {
				console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');
				this.shadow.mapSize.height = value;
			}
		}
	}); //

	Object.defineProperties(BufferAttribute.prototype, {
		length: {
			get: function () {
				console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');
				return this.array.length;
			}
		},
		dynamic: {
			get: function () {
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				return this.usage === DynamicDrawUsage;
			},
			set: function ()
			/* value */
			{
				console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');
				this.setUsage(DynamicDrawUsage);
			}
		}
	});

	BufferAttribute.prototype.setDynamic = function (value) {
		console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	BufferAttribute.prototype.copyIndicesArray = function ()
	/* indices */
	{
		console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
	}, BufferAttribute.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //

	BufferGeometry.prototype.addIndex = function (index) {
		console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');
		this.setIndex(index);
	};

	BufferGeometry.prototype.addAttribute = function (name, attribute) {
		console.warn('THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().');

		if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
			console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');
			return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
		}

		if (name === 'index') {
			console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');
			this.setIndex(attribute);
			return this;
		}

		return this.setAttribute(name, attribute);
	};

	BufferGeometry.prototype.addDrawCall = function (start, count, indexOffset) {
		if (indexOffset !== undefined) {
			console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');
		}

		console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');
		this.addGroup(start, count);
	};

	BufferGeometry.prototype.clearDrawCalls = function () {
		console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');
		this.clearGroups();
	};

	BufferGeometry.prototype.computeOffsets = function () {
		console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
	};

	BufferGeometry.prototype.removeAttribute = function (name) {
		console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');
		return this.deleteAttribute(name);
	};

	BufferGeometry.prototype.applyMatrix = function (matrix) {
		console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');
		return this.applyMatrix4(matrix);
	};

	Object.defineProperties(BufferGeometry.prototype, {
		drawcalls: {
			get: function () {
				console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');
				return this.groups;
			}
		},
		offsets: {
			get: function () {
				console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');
				return this.groups;
			}
		}
	});

	InterleavedBuffer.prototype.setDynamic = function (value) {
		console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');
		this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
		return this;
	};

	InterleavedBuffer.prototype.setArray = function ()
	/* array */
	{
		console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');
	}; //


	ExtrudeGeometry.prototype.getArrays = function () {
		console.error('THREE.ExtrudeGeometry: .getArrays() has been removed.');
	};

	ExtrudeGeometry.prototype.addShapeList = function () {
		console.error('THREE.ExtrudeGeometry: .addShapeList() has been removed.');
	};

	ExtrudeGeometry.prototype.addShape = function () {
		console.error('THREE.ExtrudeGeometry: .addShape() has been removed.');
	}; //


	Scene.prototype.dispose = function () {
		console.error('THREE.Scene: .dispose() has been removed.');
	}; //


	Uniform.prototype.onUpdate = function () {
		console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');
		return this;
	}; //


	Object.defineProperties(Material.prototype, {
		wrapAround: {
			get: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .wrapAround has been removed.');
			}
		},
		overdraw: {
			get: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			},
			set: function () {
				console.warn('THREE.Material: .overdraw has been removed.');
			}
		},
		wrapRGB: {
			get: function () {
				console.warn('THREE.Material: .wrapRGB has been removed.');
				return new Color();
			}
		},
		shading: {
			get: function () {
				console.error('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.');
				this.flatShading = value === FlatShading;
			}
		},
		stencilMask: {
			get: function () {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				return this.stencilFuncMask;
			},
			set: function (value) {
				console.warn('THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.');
				this.stencilFuncMask = value;
			}
		},
		vertexTangents: {
			get: function () {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			},
			set: function () {
				console.warn('THREE.' + this.type + ': .vertexTangents has been removed.');
			}
		}
	});
	Object.defineProperties(ShaderMaterial.prototype, {
		derivatives: {
			get: function () {
				console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				return this.extensions.derivatives;
			},
			set: function (value) {
				console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');
				this.extensions.derivatives = value;
			}
		}
	}); //

	WebGLRenderer.prototype.clearTarget = function (renderTarget, color, depth, stencil) {
		console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');
		this.setRenderTarget(renderTarget);
		this.clear(color, depth, stencil);
	};

	WebGLRenderer.prototype.animate = function (callback) {
		console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');
		this.setAnimationLoop(callback);
	};

	WebGLRenderer.prototype.getCurrentRenderTarget = function () {
		console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');
		return this.getRenderTarget();
	};

	WebGLRenderer.prototype.getMaxAnisotropy = function () {
		console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');
		return this.capabilities.getMaxAnisotropy();
	};

	WebGLRenderer.prototype.getPrecision = function () {
		console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');
		return this.capabilities.precision;
	};

	WebGLRenderer.prototype.resetGLState = function () {
		console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');
		return this.state.reset();
	};

	WebGLRenderer.prototype.supportsFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');
		return this.extensions.get('OES_texture_float');
	};

	WebGLRenderer.prototype.supportsHalfFloatTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');
		return this.extensions.get('OES_texture_half_float');
	};

	WebGLRenderer.prototype.supportsStandardDerivatives = function () {
		console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');
		return this.extensions.get('OES_standard_derivatives');
	};

	WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_s3tc');
	};

	WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {
		console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');
		return this.extensions.get('WEBGL_compressed_texture_pvrtc');
	};

	WebGLRenderer.prototype.supportsBlendMinMax = function () {
		console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');
		return this.extensions.get('EXT_blend_minmax');
	};

	WebGLRenderer.prototype.supportsVertexTextures = function () {
		console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');
		return this.capabilities.vertexTextures;
	};

	WebGLRenderer.prototype.supportsInstancedArrays = function () {
		console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');
		return this.extensions.get('ANGLE_instanced_arrays');
	};

	WebGLRenderer.prototype.enableScissorTest = function (boolean) {
		console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');
		this.setScissorTest(boolean);
	};

	WebGLRenderer.prototype.initMaterial = function () {
		console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
	};

	WebGLRenderer.prototype.addPrePlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
	};

	WebGLRenderer.prototype.addPostPlugin = function () {
		console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
	};

	WebGLRenderer.prototype.updateShadowMap = function () {
		console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
	};

	WebGLRenderer.prototype.setFaceCulling = function () {
		console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
	};

	WebGLRenderer.prototype.allocTextureUnit = function () {
		console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');
	};

	WebGLRenderer.prototype.setTexture = function () {
		console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');
	};

	WebGLRenderer.prototype.setTexture2D = function () {
		console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');
	};

	WebGLRenderer.prototype.setTextureCube = function () {
		console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');
	};

	WebGLRenderer.prototype.getActiveMipMapLevel = function () {
		console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');
		return this.getActiveMipmapLevel();
	};

	Object.defineProperties(WebGLRenderer.prototype, {
		shadowMapEnabled: {
			get: function () {
				return this.shadowMap.enabled;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');
				this.shadowMap.enabled = value;
			}
		},
		shadowMapType: {
			get: function () {
				return this.shadowMap.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');
				this.shadowMap.type = value;
			}
		},
		shadowMapCullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function ()
			/* value */
			{
				console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		context: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');
				return this.getContext();
			}
		},
		vr: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');
				return this.xr;
			}
		},
		gammaInput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
				return false;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');
			}
		},
		gammaOutput: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				return false;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');
				this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
			}
		},
		toneMappingWhitePoint: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
				return 1.0;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.');
			}
		}
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
		cullFace: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function ()
			/* cullFace */
			{
				console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');
			}
		},
		renderReverseSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');
			}
		},
		renderSingleSided: {
			get: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
				return undefined;
			},
			set: function () {
				console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');
			}
		}
	});
	function WebGLRenderTargetCube(width, height, options) {
		console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');
		return new WebGLCubeRenderTarget(width, options);
	} //

	Object.defineProperties(WebGLRenderTarget.prototype, {
		wrapS: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				return this.texture.wrapS;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');
				this.texture.wrapS = value;
			}
		},
		wrapT: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				return this.texture.wrapT;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');
				this.texture.wrapT = value;
			}
		},
		magFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				return this.texture.magFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');
				this.texture.magFilter = value;
			}
		},
		minFilter: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				return this.texture.minFilter;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');
				this.texture.minFilter = value;
			}
		},
		anisotropy: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				return this.texture.anisotropy;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');
				this.texture.anisotropy = value;
			}
		},
		offset: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				return this.texture.offset;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');
				this.texture.offset = value;
			}
		},
		repeat: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				return this.texture.repeat;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');
				this.texture.repeat = value;
			}
		},
		format: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				return this.texture.format;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');
				this.texture.format = value;
			}
		},
		type: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				return this.texture.type;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');
				this.texture.type = value;
			}
		},
		generateMipmaps: {
			get: function () {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				return this.texture.generateMipmaps;
			},
			set: function (value) {
				console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');
				this.texture.generateMipmaps = value;
			}
		}
	}); //

	Audio.prototype.load = function (file) {
		console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');
		const scope = this;
		const audioLoader = new AudioLoader();
		audioLoader.load(file, function (buffer) {
			scope.setBuffer(buffer);
		});
		return this;
	};

	AudioAnalyser.prototype.getData = function () {
		console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');
		return this.getFrequencyData();
	}; //


	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
		console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');
		return this.update(renderer, scene);
	};

	CubeCamera.prototype.clear = function (renderer, color, depth, stencil) {
		console.warn('THREE.CubeCamera: .clear() is now .renderTarget.clear().');
		return this.renderTarget.clear(renderer, color, depth, stencil);
	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');
		const loader = new TextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(url, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
		console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');
		const loader = new CubeTextureLoader();
		loader.setCrossOrigin(this.crossOrigin);
		const texture = loader.load(urls, onLoad, undefined, onError);
		if (mapping) texture.mapping = mapping;
		return texture;
	};

	ImageUtils.loadCompressedTexture = function () {
		console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');
	};

	ImageUtils.loadCompressedTextureCube = function () {
		console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');
	}; //


	function CanvasRenderer() {
		console.error('THREE.CanvasRenderer has been removed');
	} //

	function JSONLoader() {
		console.error('THREE.JSONLoader has been removed.');
	} //

	const SceneUtils = {
		createMultiMaterialObject: function ()
		/* geometry, materials */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		detach: function ()
		/* child, parent, scene */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		},
		attach: function ()
		/* child, scene, parent */
		{
			console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');
		}
	}; //

	function LensFlare() {
		console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');
	}

	if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
			detail: {
				revision: REVISION
			}
		}));
		/* eslint-enable no-undef */

	}

	if (typeof window !== 'undefined') {
		if (window.__THREE__) {
			console.warn('WARNING: Multiple instances of Three.js being imported.');
		} else {
			window.__THREE__ = REVISION;
		}
	}

	exports.ACESFilmicToneMapping = ACESFilmicToneMapping;
	exports.AddEquation = AddEquation;
	exports.AddOperation = AddOperation;
	exports.AdditiveAnimationBlendMode = AdditiveAnimationBlendMode;
	exports.AdditiveBlending = AdditiveBlending;
	exports.AlphaFormat = AlphaFormat;
	exports.AlwaysDepth = AlwaysDepth;
	exports.AlwaysStencilFunc = AlwaysStencilFunc;
	exports.AmbientLight = AmbientLight;
	exports.AmbientLightProbe = AmbientLightProbe;
	exports.AnimationClip = AnimationClip;
	exports.AnimationLoader = AnimationLoader;
	exports.AnimationMixer = AnimationMixer;
	exports.AnimationObjectGroup = AnimationObjectGroup;
	exports.AnimationUtils = AnimationUtils;
	exports.ArcCurve = ArcCurve;
	exports.ArrayCamera = ArrayCamera;
	exports.ArrowHelper = ArrowHelper;
	exports.Audio = Audio;
	exports.AudioAnalyser = AudioAnalyser;
	exports.AudioContext = AudioContext;
	exports.AudioListener = AudioListener;
	exports.AudioLoader = AudioLoader;
	exports.AxesHelper = AxesHelper;
	exports.AxisHelper = AxisHelper;
	exports.BackSide = BackSide;
	exports.BasicDepthPacking = BasicDepthPacking;
	exports.BasicShadowMap = BasicShadowMap;
	exports.BinaryTextureLoader = BinaryTextureLoader;
	exports.Bone = Bone;
	exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
	exports.BoundingBoxHelper = BoundingBoxHelper;
	exports.Box2 = Box2;
	exports.Box3 = Box3;
	exports.Box3Helper = Box3Helper;
	exports.BoxBufferGeometry = BoxGeometry;
	exports.BoxGeometry = BoxGeometry;
	exports.BoxHelper = BoxHelper;
	exports.BufferAttribute = BufferAttribute;
	exports.BufferGeometry = BufferGeometry;
	exports.BufferGeometryLoader = BufferGeometryLoader;
	exports.ByteType = ByteType;
	exports.Cache = Cache;
	exports.Camera = Camera;
	exports.CameraHelper = CameraHelper;
	exports.CanvasRenderer = CanvasRenderer;
	exports.CanvasTexture = CanvasTexture;
	exports.CatmullRomCurve3 = CatmullRomCurve3;
	exports.CineonToneMapping = CineonToneMapping;
	exports.CircleBufferGeometry = CircleGeometry;
	exports.CircleGeometry = CircleGeometry;
	exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
	exports.Clock = Clock;
	exports.Color = Color;
	exports.ColorKeyframeTrack = ColorKeyframeTrack;
	exports.CompressedTexture = CompressedTexture;
	exports.CompressedTextureLoader = CompressedTextureLoader;
	exports.ConeBufferGeometry = ConeGeometry;
	exports.ConeGeometry = ConeGeometry;
	exports.CubeCamera = CubeCamera;
	exports.CubeReflectionMapping = CubeReflectionMapping;
	exports.CubeRefractionMapping = CubeRefractionMapping;
	exports.CubeTexture = CubeTexture;
	exports.CubeTextureLoader = CubeTextureLoader;
	exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
	exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
	exports.CubicBezierCurve = CubicBezierCurve;
	exports.CubicBezierCurve3 = CubicBezierCurve3;
	exports.CubicInterpolant = CubicInterpolant;
	exports.CullFaceBack = CullFaceBack;
	exports.CullFaceFront = CullFaceFront;
	exports.CullFaceFrontBack = CullFaceFrontBack;
	exports.CullFaceNone = CullFaceNone;
	exports.Curve = Curve;
	exports.CurvePath = CurvePath;
	exports.CustomBlending = CustomBlending;
	exports.CustomToneMapping = CustomToneMapping;
	exports.CylinderBufferGeometry = CylinderGeometry;
	exports.CylinderGeometry = CylinderGeometry;
	exports.Cylindrical = Cylindrical;
	exports.DataTexture = DataTexture;
	exports.DataTexture2DArray = DataTexture2DArray;
	exports.DataTexture3D = DataTexture3D;
	exports.DataTextureLoader = DataTextureLoader;
	exports.DataUtils = DataUtils;
	exports.DecrementStencilOp = DecrementStencilOp;
	exports.DecrementWrapStencilOp = DecrementWrapStencilOp;
	exports.DefaultLoadingManager = DefaultLoadingManager;
	exports.DepthFormat = DepthFormat;
	exports.DepthStencilFormat = DepthStencilFormat;
	exports.DepthTexture = DepthTexture;
	exports.DirectionalLight = DirectionalLight;
	exports.DirectionalLightHelper = DirectionalLightHelper;
	exports.DiscreteInterpolant = DiscreteInterpolant;
	exports.DodecahedronBufferGeometry = DodecahedronGeometry;
	exports.DodecahedronGeometry = DodecahedronGeometry;
	exports.DoubleSide = DoubleSide;
	exports.DstAlphaFactor = DstAlphaFactor;
	exports.DstColorFactor = DstColorFactor;
	exports.DynamicBufferAttribute = DynamicBufferAttribute;
	exports.DynamicCopyUsage = DynamicCopyUsage;
	exports.DynamicDrawUsage = DynamicDrawUsage;
	exports.DynamicReadUsage = DynamicReadUsage;
	exports.EdgesGeometry = EdgesGeometry;
	exports.EdgesHelper = EdgesHelper;
	exports.EllipseCurve = EllipseCurve;
	exports.EqualDepth = EqualDepth;
	exports.EqualStencilFunc = EqualStencilFunc;
	exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
	exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
	exports.Euler = Euler;
	exports.EventDispatcher = EventDispatcher;
	exports.ExtrudeBufferGeometry = ExtrudeGeometry;
	exports.ExtrudeGeometry = ExtrudeGeometry;
	exports.FaceColors = FaceColors;
	exports.FileLoader = FileLoader;
	exports.FlatShading = FlatShading;
	exports.Float16BufferAttribute = Float16BufferAttribute;
	exports.Float32Attribute = Float32Attribute;
	exports.Float32BufferAttribute = Float32BufferAttribute;
	exports.Float64Attribute = Float64Attribute;
	exports.Float64BufferAttribute = Float64BufferAttribute;
	exports.FloatType = FloatType;
	exports.Fog = Fog;
	exports.FogExp2 = FogExp2;
	exports.Font = Font;
	exports.FontLoader = FontLoader;
	exports.FrontSide = FrontSide;
	exports.Frustum = Frustum;
	exports.GLBufferAttribute = GLBufferAttribute;
	exports.GLSL1 = GLSL1;
	exports.GLSL3 = GLSL3;
	exports.GammaEncoding = GammaEncoding;
	exports.GreaterDepth = GreaterDepth;
	exports.GreaterEqualDepth = GreaterEqualDepth;
	exports.GreaterEqualStencilFunc = GreaterEqualStencilFunc;
	exports.GreaterStencilFunc = GreaterStencilFunc;
	exports.GridHelper = GridHelper;
	exports.Group = Group;
	exports.HalfFloatType = HalfFloatType;
	exports.HemisphereLight = HemisphereLight;
	exports.HemisphereLightHelper = HemisphereLightHelper;
	exports.HemisphereLightProbe = HemisphereLightProbe;
	exports.IcosahedronBufferGeometry = IcosahedronGeometry;
	exports.IcosahedronGeometry = IcosahedronGeometry;
	exports.ImageBitmapLoader = ImageBitmapLoader;
	exports.ImageLoader = ImageLoader;
	exports.ImageUtils = ImageUtils;
	exports.ImmediateRenderObject = ImmediateRenderObject;
	exports.IncrementStencilOp = IncrementStencilOp;
	exports.IncrementWrapStencilOp = IncrementWrapStencilOp;
	exports.InstancedBufferAttribute = InstancedBufferAttribute;
	exports.InstancedBufferGeometry = InstancedBufferGeometry;
	exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
	exports.InstancedMesh = InstancedMesh;
	exports.Int16Attribute = Int16Attribute;
	exports.Int16BufferAttribute = Int16BufferAttribute;
	exports.Int32Attribute = Int32Attribute;
	exports.Int32BufferAttribute = Int32BufferAttribute;
	exports.Int8Attribute = Int8Attribute;
	exports.Int8BufferAttribute = Int8BufferAttribute;
	exports.IntType = IntType;
	exports.InterleavedBuffer = InterleavedBuffer;
	exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
	exports.Interpolant = Interpolant;
	exports.InterpolateDiscrete = InterpolateDiscrete;
	exports.InterpolateLinear = InterpolateLinear;
	exports.InterpolateSmooth = InterpolateSmooth;
	exports.InvertStencilOp = InvertStencilOp;
	exports.JSONLoader = JSONLoader;
	exports.KeepStencilOp = KeepStencilOp;
	exports.KeyframeTrack = KeyframeTrack;
	exports.LOD = LOD;
	exports.LatheBufferGeometry = LatheGeometry;
	exports.LatheGeometry = LatheGeometry;
	exports.Layers = Layers;
	exports.LensFlare = LensFlare;
	exports.LessDepth = LessDepth;
	exports.LessEqualDepth = LessEqualDepth;
	exports.LessEqualStencilFunc = LessEqualStencilFunc;
	exports.LessStencilFunc = LessStencilFunc;
	exports.Light = Light;
	exports.LightProbe = LightProbe;
	exports.Line = Line;
	exports.Line3 = Line3;
	exports.LineBasicMaterial = LineBasicMaterial;
	exports.LineCurve = LineCurve;
	exports.LineCurve3 = LineCurve3;
	exports.LineDashedMaterial = LineDashedMaterial;
	exports.LineLoop = LineLoop;
	exports.LinePieces = LinePieces;
	exports.LineSegments = LineSegments;
	exports.LineStrip = LineStrip;
	exports.LinearEncoding = LinearEncoding;
	exports.LinearFilter = LinearFilter;
	exports.LinearInterpolant = LinearInterpolant;
	exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
	exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
	exports.LinearMipmapLinearFilter = LinearMipmapLinearFilter;
	exports.LinearMipmapNearestFilter = LinearMipmapNearestFilter;
	exports.LinearToneMapping = LinearToneMapping;
	exports.Loader = Loader;
	exports.LoaderUtils = LoaderUtils;
	exports.LoadingManager = LoadingManager;
	exports.LogLuvEncoding = LogLuvEncoding;
	exports.LoopOnce = LoopOnce;
	exports.LoopPingPong = LoopPingPong;
	exports.LoopRepeat = LoopRepeat;
	exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
	exports.LuminanceFormat = LuminanceFormat;
	exports.MOUSE = MOUSE;
	exports.Material = Material;
	exports.MaterialLoader = MaterialLoader;
	exports.Math = MathUtils;
	exports.MathUtils = MathUtils;
	exports.Matrix3 = Matrix3;
	exports.Matrix4 = Matrix4;
	exports.MaxEquation = MaxEquation;
	exports.Mesh = Mesh;
	exports.MeshBasicMaterial = MeshBasicMaterial;
	exports.MeshDepthMaterial = MeshDepthMaterial;
	exports.MeshDistanceMaterial = MeshDistanceMaterial;
	exports.MeshFaceMaterial = MeshFaceMaterial;
	exports.MeshLambertMaterial = MeshLambertMaterial;
	exports.MeshMatcapMaterial = MeshMatcapMaterial;
	exports.MeshNormalMaterial = MeshNormalMaterial;
	exports.MeshPhongMaterial = MeshPhongMaterial;
	exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
	exports.MeshStandardMaterial = MeshStandardMaterial;
	exports.MeshToonMaterial = MeshToonMaterial;
	exports.MinEquation = MinEquation;
	exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
	exports.MixOperation = MixOperation;
	exports.MultiMaterial = MultiMaterial;
	exports.MultiplyBlending = MultiplyBlending;
	exports.MultiplyOperation = MultiplyOperation;
	exports.NearestFilter = NearestFilter;
	exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
	exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
	exports.NearestMipmapLinearFilter = NearestMipmapLinearFilter;
	exports.NearestMipmapNearestFilter = NearestMipmapNearestFilter;
	exports.NeverDepth = NeverDepth;
	exports.NeverStencilFunc = NeverStencilFunc;
	exports.NoBlending = NoBlending;
	exports.NoColors = NoColors;
	exports.NoToneMapping = NoToneMapping;
	exports.NormalAnimationBlendMode = NormalAnimationBlendMode;
	exports.NormalBlending = NormalBlending;
	exports.NotEqualDepth = NotEqualDepth;
	exports.NotEqualStencilFunc = NotEqualStencilFunc;
	exports.NumberKeyframeTrack = NumberKeyframeTrack;
	exports.Object3D = Object3D;
	exports.ObjectLoader = ObjectLoader;
	exports.ObjectSpaceNormalMap = ObjectSpaceNormalMap;
	exports.OctahedronBufferGeometry = OctahedronGeometry;
	exports.OctahedronGeometry = OctahedronGeometry;
	exports.OneFactor = OneFactor;
	exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
	exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
	exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
	exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
	exports.OrthographicCamera = OrthographicCamera;
	exports.PCFShadowMap = PCFShadowMap;
	exports.PCFSoftShadowMap = PCFSoftShadowMap;
	exports.PMREMGenerator = PMREMGenerator;
	exports.ParametricBufferGeometry = ParametricGeometry;
	exports.ParametricGeometry = ParametricGeometry;
	exports.Particle = Particle;
	exports.ParticleBasicMaterial = ParticleBasicMaterial;
	exports.ParticleSystem = ParticleSystem;
	exports.ParticleSystemMaterial = ParticleSystemMaterial;
	exports.Path = Path;
	exports.PerspectiveCamera = PerspectiveCamera;
	exports.Plane = Plane;
	exports.PlaneBufferGeometry = PlaneGeometry;
	exports.PlaneGeometry = PlaneGeometry;
	exports.PlaneHelper = PlaneHelper;
	exports.PointCloud = PointCloud;
	exports.PointCloudMaterial = PointCloudMaterial;
	exports.PointLight = PointLight;
	exports.PointLightHelper = PointLightHelper;
	exports.Points = Points;
	exports.PointsMaterial = PointsMaterial;
	exports.PolarGridHelper = PolarGridHelper;
	exports.PolyhedronBufferGeometry = PolyhedronGeometry;
	exports.PolyhedronGeometry = PolyhedronGeometry;
	exports.PositionalAudio = PositionalAudio;
	exports.PropertyBinding = PropertyBinding;
	exports.PropertyMixer = PropertyMixer;
	exports.QuadraticBezierCurve = QuadraticBezierCurve;
	exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
	exports.Quaternion = Quaternion;
	exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
	exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
	exports.REVISION = REVISION;
	exports.RGBADepthPacking = RGBADepthPacking;
	exports.RGBAFormat = RGBAFormat;
	exports.RGBAIntegerFormat = RGBAIntegerFormat;
	exports.RGBA_ASTC_10x10_Format = RGBA_ASTC_10x10_Format;
	exports.RGBA_ASTC_10x5_Format = RGBA_ASTC_10x5_Format;
	exports.RGBA_ASTC_10x6_Format = RGBA_ASTC_10x6_Format;
	exports.RGBA_ASTC_10x8_Format = RGBA_ASTC_10x8_Format;
	exports.RGBA_ASTC_12x10_Format = RGBA_ASTC_12x10_Format;
	exports.RGBA_ASTC_12x12_Format = RGBA_ASTC_12x12_Format;
	exports.RGBA_ASTC_4x4_Format = RGBA_ASTC_4x4_Format;
	exports.RGBA_ASTC_5x4_Format = RGBA_ASTC_5x4_Format;
	exports.RGBA_ASTC_5x5_Format = RGBA_ASTC_5x5_Format;
	exports.RGBA_ASTC_6x5_Format = RGBA_ASTC_6x5_Format;
	exports.RGBA_ASTC_6x6_Format = RGBA_ASTC_6x6_Format;
	exports.RGBA_ASTC_8x5_Format = RGBA_ASTC_8x5_Format;
	exports.RGBA_ASTC_8x6_Format = RGBA_ASTC_8x6_Format;
	exports.RGBA_ASTC_8x8_Format = RGBA_ASTC_8x8_Format;
	exports.RGBA_BPTC_Format = RGBA_BPTC_Format;
	exports.RGBA_ETC2_EAC_Format = RGBA_ETC2_EAC_Format;
	exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
	exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
	exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
	exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
	exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
	exports.RGBDEncoding = RGBDEncoding;
	exports.RGBEEncoding = RGBEEncoding;
	exports.RGBEFormat = RGBEFormat;
	exports.RGBFormat = RGBFormat;
	exports.RGBIntegerFormat = RGBIntegerFormat;
	exports.RGBM16Encoding = RGBM16Encoding;
	exports.RGBM7Encoding = RGBM7Encoding;
	exports.RGB_ETC1_Format = RGB_ETC1_Format;
	exports.RGB_ETC2_Format = RGB_ETC2_Format;
	exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
	exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
	exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
	exports.RGFormat = RGFormat;
	exports.RGIntegerFormat = RGIntegerFormat;
	exports.RawShaderMaterial = RawShaderMaterial;
	exports.Ray = Ray;
	exports.Raycaster = Raycaster;
	exports.RectAreaLight = RectAreaLight;
	exports.RedFormat = RedFormat;
	exports.RedIntegerFormat = RedIntegerFormat;
	exports.ReinhardToneMapping = ReinhardToneMapping;
	exports.RepeatWrapping = RepeatWrapping;
	exports.ReplaceStencilOp = ReplaceStencilOp;
	exports.ReverseSubtractEquation = ReverseSubtractEquation;
	exports.RingBufferGeometry = RingGeometry;
	exports.RingGeometry = RingGeometry;
	exports.SRGB8_ALPHA8_ASTC_10x10_Format = SRGB8_ALPHA8_ASTC_10x10_Format;
	exports.SRGB8_ALPHA8_ASTC_10x5_Format = SRGB8_ALPHA8_ASTC_10x5_Format;
	exports.SRGB8_ALPHA8_ASTC_10x6_Format = SRGB8_ALPHA8_ASTC_10x6_Format;
	exports.SRGB8_ALPHA8_ASTC_10x8_Format = SRGB8_ALPHA8_ASTC_10x8_Format;
	exports.SRGB8_ALPHA8_ASTC_12x10_Format = SRGB8_ALPHA8_ASTC_12x10_Format;
	exports.SRGB8_ALPHA8_ASTC_12x12_Format = SRGB8_ALPHA8_ASTC_12x12_Format;
	exports.SRGB8_ALPHA8_ASTC_4x4_Format = SRGB8_ALPHA8_ASTC_4x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x4_Format = SRGB8_ALPHA8_ASTC_5x4_Format;
	exports.SRGB8_ALPHA8_ASTC_5x5_Format = SRGB8_ALPHA8_ASTC_5x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x5_Format = SRGB8_ALPHA8_ASTC_6x5_Format;
	exports.SRGB8_ALPHA8_ASTC_6x6_Format = SRGB8_ALPHA8_ASTC_6x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x5_Format = SRGB8_ALPHA8_ASTC_8x5_Format;
	exports.SRGB8_ALPHA8_ASTC_8x6_Format = SRGB8_ALPHA8_ASTC_8x6_Format;
	exports.SRGB8_ALPHA8_ASTC_8x8_Format = SRGB8_ALPHA8_ASTC_8x8_Format;
	exports.Scene = Scene;
	exports.SceneUtils = SceneUtils;
	exports.ShaderChunk = ShaderChunk;
	exports.ShaderLib = ShaderLib;
	exports.ShaderMaterial = ShaderMaterial;
	exports.ShadowMaterial = ShadowMaterial;
	exports.Shape = Shape;
	exports.ShapeBufferGeometry = ShapeGeometry;
	exports.ShapeGeometry = ShapeGeometry;
	exports.ShapePath = ShapePath;
	exports.ShapeUtils = ShapeUtils;
	exports.ShortType = ShortType;
	exports.Skeleton = Skeleton;
	exports.SkeletonHelper = SkeletonHelper;
	exports.SkinnedMesh = SkinnedMesh;
	exports.SmoothShading = SmoothShading;
	exports.Sphere = Sphere;
	exports.SphereBufferGeometry = SphereGeometry;
	exports.SphereGeometry = SphereGeometry;
	exports.Spherical = Spherical;
	exports.SphericalHarmonics3 = SphericalHarmonics3;
	exports.SplineCurve = SplineCurve;
	exports.SpotLight = SpotLight;
	exports.SpotLightHelper = SpotLightHelper;
	exports.Sprite = Sprite;
	exports.SpriteMaterial = SpriteMaterial;
	exports.SrcAlphaFactor = SrcAlphaFactor;
	exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
	exports.SrcColorFactor = SrcColorFactor;
	exports.StaticCopyUsage = StaticCopyUsage;
	exports.StaticDrawUsage = StaticDrawUsage;
	exports.StaticReadUsage = StaticReadUsage;
	exports.StereoCamera = StereoCamera;
	exports.StreamCopyUsage = StreamCopyUsage;
	exports.StreamDrawUsage = StreamDrawUsage;
	exports.StreamReadUsage = StreamReadUsage;
	exports.StringKeyframeTrack = StringKeyframeTrack;
	exports.SubtractEquation = SubtractEquation;
	exports.SubtractiveBlending = SubtractiveBlending;
	exports.TOUCH = TOUCH;
	exports.TangentSpaceNormalMap = TangentSpaceNormalMap;
	exports.TetrahedronBufferGeometry = TetrahedronGeometry;
	exports.TetrahedronGeometry = TetrahedronGeometry;
	exports.TextBufferGeometry = TextGeometry;
	exports.TextGeometry = TextGeometry;
	exports.Texture = Texture;
	exports.TextureLoader = TextureLoader;
	exports.TorusBufferGeometry = TorusGeometry;
	exports.TorusGeometry = TorusGeometry;
	exports.TorusKnotBufferGeometry = TorusKnotGeometry;
	exports.TorusKnotGeometry = TorusKnotGeometry;
	exports.Triangle = Triangle;
	exports.TriangleFanDrawMode = TriangleFanDrawMode;
	exports.TriangleStripDrawMode = TriangleStripDrawMode;
	exports.TrianglesDrawMode = TrianglesDrawMode;
	exports.TubeBufferGeometry = TubeGeometry;
	exports.TubeGeometry = TubeGeometry;
	exports.UVMapping = UVMapping;
	exports.Uint16Attribute = Uint16Attribute;
	exports.Uint16BufferAttribute = Uint16BufferAttribute;
	exports.Uint32Attribute = Uint32Attribute;
	exports.Uint32BufferAttribute = Uint32BufferAttribute;
	exports.Uint8Attribute = Uint8Attribute;
	exports.Uint8BufferAttribute = Uint8BufferAttribute;
	exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
	exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
	exports.Uniform = Uniform;
	exports.UniformsLib = UniformsLib;
	exports.UniformsUtils = UniformsUtils;
	exports.UnsignedByteType = UnsignedByteType;
	exports.UnsignedInt248Type = UnsignedInt248Type;
	exports.UnsignedIntType = UnsignedIntType;
	exports.UnsignedShort4444Type = UnsignedShort4444Type;
	exports.UnsignedShort5551Type = UnsignedShort5551Type;
	exports.UnsignedShort565Type = UnsignedShort565Type;
	exports.UnsignedShortType = UnsignedShortType;
	exports.VSMShadowMap = VSMShadowMap;
	exports.Vector2 = Vector2;
	exports.Vector3 = Vector3;
	exports.Vector4 = Vector4;
	exports.VectorKeyframeTrack = VectorKeyframeTrack;
	exports.Vertex = Vertex;
	exports.VertexColors = VertexColors;
	exports.VideoTexture = VideoTexture;
	exports.WebGL1Renderer = WebGL1Renderer;
	exports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;
	exports.WebGLMultipleRenderTargets = WebGLMultipleRenderTargets;
	exports.WebGLMultisampleRenderTarget = WebGLMultisampleRenderTarget;
	exports.WebGLRenderTarget = WebGLRenderTarget;
	exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
	exports.WebGLRenderer = WebGLRenderer;
	exports.WebGLUtils = WebGLUtils;
	exports.WireframeGeometry = WireframeGeometry;
	exports.WireframeHelper = WireframeHelper;
	exports.WrapAroundEnding = WrapAroundEnding;
	exports.XHRLoader = XHRLoader;
	exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
	exports.ZeroFactor = ZeroFactor;
	exports.ZeroSlopeEnding = ZeroSlopeEnding;
	exports.ZeroStencilOp = ZeroStencilOp;
	exports.sRGBEncoding = sRGBEncoding;

	Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],4:[function(require,module,exports){
(function (global){(function (){
/** Miew - 3D Molecular Viewer v0.9.0+20211214.103700.4bffefe-mod Copyright (c) 2015-2021 EPAM Systems, Inc. */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('lodash'), require('three')) :
  typeof define === 'function' && define.amd ? define(['lodash', 'three'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Miew = factory(global._, global.THREE));
})(this, (function (_, THREE) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var ___default = /*#__PURE__*/_interopDefaultLegacy(_);
  var THREE__namespace = /*#__PURE__*/_interopNamespace(THREE);

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }

  var __assign = (undefined && undefined.__assign) || function () {
      __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
              s = arguments[i];
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                  t[p] = s[p];
          }
          return t;
      };
      return __assign.apply(this, arguments);
  };
  var defaults$1 = {
      lines: 12,
      length: 7,
      width: 5,
      radius: 10,
      scale: 1.0,
      corners: 1,
      color: '#000',
      fadeColor: 'transparent',
      animation: 'spinner-line-fade-default',
      rotate: 0,
      direction: 1,
      speed: 1,
      zIndex: 2e9,
      className: 'spinner',
      top: '50%',
      left: '50%',
      shadow: '0 0 1px transparent',
      position: 'absolute',
  };
  var Spinner = /** @class */ (function () {
      function Spinner(opts) {
          if (opts === void 0) { opts = {}; }
          this.opts = __assign(__assign({}, defaults$1), opts);
      }
      /**
       * Adds the spinner to the given target element. If this instance is already
       * spinning, it is automatically removed from its previous target by calling
       * stop() internally.
       */
      Spinner.prototype.spin = function (target) {
          this.stop();
          this.el = document.createElement('div');
          this.el.className = this.opts.className;
          this.el.setAttribute('role', 'progressbar');
          css(this.el, {
              position: this.opts.position,
              width: 0,
              zIndex: this.opts.zIndex,
              left: this.opts.left,
              top: this.opts.top,
              transform: "scale(" + this.opts.scale + ")",
          });
          if (target) {
              target.insertBefore(this.el, target.firstChild || null);
          }
          drawLines(this.el, this.opts);
          return this;
      };
      /**
       * Stops and removes the Spinner.
       * Stopped spinners may be reused by calling spin() again.
       */
      Spinner.prototype.stop = function () {
          if (this.el) {
              if (typeof requestAnimationFrame !== 'undefined') {
                  cancelAnimationFrame(this.animateId);
              }
              else {
                  clearTimeout(this.animateId);
              }
              if (this.el.parentNode) {
                  this.el.parentNode.removeChild(this.el);
              }
              this.el = undefined;
          }
          return this;
      };
      return Spinner;
  }());
  /**
   * Sets multiple style properties at once.
   */
  function css(el, props) {
      for (var prop in props) {
          el.style[prop] = props[prop];
      }
      return el;
  }
  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
      return typeof color == 'string' ? color : color[idx % color.length];
  }
  /**
   * Internal method that draws the individual lines.
   */
  function drawLines(el, opts) {
      var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
      var shadow = 'none';
      if (opts.shadow === true) {
          shadow = '0 2px 4px #000'; // default shadow
      }
      else if (typeof opts.shadow === 'string') {
          shadow = opts.shadow;
      }
      var shadows = parseBoxShadow(shadow);
      for (var i = 0; i < opts.lines; i++) {
          var degrees = ~~(360 / opts.lines * i + opts.rotate);
          var backgroundLine = css(document.createElement('div'), {
              position: 'absolute',
              top: -opts.width / 2 + "px",
              width: (opts.length + opts.width) + 'px',
              height: opts.width + 'px',
              background: getColor(opts.fadeColor, i),
              borderRadius: borderRadius,
              transformOrigin: 'left',
              transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
          });
          var delay = i * opts.direction / opts.lines / opts.speed;
          delay -= 1 / opts.speed; // so initial animation state will include trail
          var line = css(document.createElement('div'), {
              width: '100%',
              height: '100%',
              background: getColor(opts.color, i),
              borderRadius: borderRadius,
              boxShadow: normalizeShadow(shadows, degrees),
              animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
          });
          backgroundLine.appendChild(line);
          el.appendChild(backgroundLine);
      }
  }
  function parseBoxShadow(boxShadow) {
      var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
      var shadows = [];
      for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
          var shadow = _a[_i];
          var matches = shadow.match(regex);
          if (matches === null) {
              continue; // invalid syntax
          }
          var x = +matches[2];
          var y = +matches[5];
          var xUnits = matches[4];
          var yUnits = matches[7];
          if (x === 0 && !xUnits) {
              xUnits = yUnits;
          }
          if (y === 0 && !yUnits) {
              yUnits = xUnits;
          }
          if (xUnits !== yUnits) {
              continue; // units must match to use as coordinates
          }
          shadows.push({
              prefix: matches[1] || '',
              x: x,
              y: y,
              xUnits: xUnits,
              yUnits: yUnits,
              end: matches[8],
          });
      }
      return shadows;
  }
  /**
   * Modify box-shadow x/y offsets to counteract rotation
   */
  function normalizeShadow(shadows, degrees) {
      var normalized = [];
      for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
          var shadow = shadows_1[_i];
          var xy = convertOffset(shadow.x, shadow.y, degrees);
          normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
      }
      return normalized.join(', ');
  }
  function convertOffset(x, y, degrees) {
      var radians = degrees * Math.PI / 180;
      var sin = Math.sin(radians);
      var cos = Math.cos(radians);
      return [
          Math.round((x * cos + y * sin) * 1000) / 1000,
          Math.round((-x * sin + y * cos) * 1000) / 1000,
      ];
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var Timer = /*#__PURE__*/function () {
    function Timer() {
      _classCallCheck(this, Timer);

      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }

    _createClass(Timer, [{
      key: "start",
      value: function start() {
        this.startTime = Timer.now();
        this.oldTime = this.startTime;
        this.running = true;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.getElapsedTime();
        this.running = false;
      }
    }, {
      key: "getElapsedTime",
      value: function getElapsedTime() {
        this.update();
        return this.elapsedTime;
      }
    }, {
      key: "update",
      value: function update() {
        var delta = 0;

        if (this.running) {
          var newTime = Timer.now();
          delta = 0.001 * (newTime - this.oldTime);
          this.oldTime = newTime;
          this.elapsedTime += delta;
        }

        return delta;
      }
    }]);

    return Timer;
  }();

  Timer.now = function () {
    var p = typeof window !== 'undefined' && window.performance;
    return p && p.now ? p.now.bind(p) : Date.now;
  }();

  var now = Timer.now;

  function createElement$2(tag, id, css) {
    var element = document.createElement(tag);
    element.id = id;
    element.style.cssText = css;
    return element;
  }

  var Stats = /*#__PURE__*/function () {
    function Stats() {
      _classCallCheck(this, Stats);

      this.domElement = createElement$2('div', 'stats', 'padding:8px');
      this._text = createElement$2('p', 'fps', 'margin:0;color:silver;font-size:large');
      this.domElement.appendChild(this._text);
      this._startTime = now();
      this._prevTime = this._startTime;
      this._deltas = new Array(20);
      this._index = 0;
      this._total = 0.0;
      this._count = 0;
    }

    _createClass(Stats, [{
      key: "end",
      value: function end() {
        var time = now();
        var delta = time - this._startTime;

        if (this._count < this._deltas.length) {
          this._count++;
        } else {
          this._total -= this._deltas[this._index];
        }

        this._total += delta;
        this._deltas[this._index] = delta;
        this._index = (this._index + 1) % this._deltas.length;
        this.ms = this._total / this._count;
        this.fps = 1000 / this.ms;

        if (time > this._prevTime + 1000) {
          this._text.textContent = this.fps.toPrecision(2);
          this._prevTime = time;
        }

        return time;
      }
    }, {
      key: "update",
      value: function update() {
        this._startTime = this.end();
      }
    }, {
      key: "show",
      value: function show(on) {
        if (on === undefined) {
          on = true;
        }

        this.domElement.style.display = on ? 'block' : 'none';
      }
    }]);

    return Stats;
  }();

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _isNativeReflectConstruct$22() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$22()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function isUndefOrEqual(param, value) {
    return !param || param === value;
  }

  function EventDispatcher() {
    this._handlers = {};
  }

  EventDispatcher.prototype.addEventListener = function (type, callback, context) {
    var handlers = this._handlers[type];

    if (!handlers) {
      this._handlers[type] = [];
      handlers = this._handlers[type];
    }

    var params = [callback, context];

    function _checkPar(par) {
      return par[0] === params[0] && par[1] === params[1];
    }

    if (___default["default"].find(handlers, _checkPar) === undefined) {
      handlers.push(params);
    }
  };

  EventDispatcher.prototype.removeEventListener = function (type, callback, context) {
    var self = this;

    ___default["default"].forEach(self._handlers, function (handler, ev) {
      ___default["default"].remove(handler, function (values) {
        return isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self);
      });
    });

    this._handlers = ___default["default"].omitBy(self._handlers, function (handler) {
      return handler.length === 0;
    });
  };

  EventDispatcher.prototype.dispatchEvent = function (event) {
    var self = this;

    ___default["default"].forEach(this._handlers[event.type], function (callback) {
      var context = callback[1] || self;
      callback[0].apply(context, [event]);
    });
  };

  var priorities = {
    debug: 0,
    info: 1,
    report: 2,
    warn: 3,
    error: 4
  };

  function Logger() {
    EventDispatcher.call(this);
    this.console = false;
    this._priority = priorities.warn;
  }

  Logger.prototype = Object.create(EventDispatcher.prototype);
  Logger.prototype.constructor = Logger;

  Logger.prototype.instantiate = function () {
    return new Logger();
  };

  function verify(number) {
    if (!___default["default"].isNumber(number)) {
      throw new Error('Wrong log level specified!');
    }

    return number;
  }

  Object.defineProperty(Logger.prototype, 'level', {
    get: function get() {
      var _this = this;

      return ___default["default"].findKey(priorities, function (value) {
        return value === _this._priority;
      });
    },
    set: function set(level) {
      this._priority = verify(priorities[level]);
    }
  });

  Logger.prototype.levels = function () {
    return Object.keys(priorities);
  };

  Logger.prototype.message = function (level, message) {
    var priority = verify(priorities[level]);

    this._message(priority, message);
  };

  Logger.prototype.debug = function (message) {
    this._message(priorities.debug, message);
  };

  Logger.prototype.info = function (message) {
    this._message(priorities.info, message);
  };

  Logger.prototype.report = function (message) {
    this._message(priorities.report, message);
  };

  Logger.prototype.warn = function (message) {
    this._message(priorities.warn, message);
  };

  Logger.prototype.error = function (message) {
    this._message(priorities.error, message);
  };

  Logger.prototype._message = function (priority, message) {
    if (priority < this._priority) {
      return;
    }

    var level = ___default["default"].findKey(priorities, function (value) {
      return value === priority;
    });

    message = String(message);

    if (this.console) {
      var output = "miew:".concat(level, ": ").concat(message);

      if (level === 'error') {
        console.error(output);
      } else if (level === 'warn') {
        console.warn(output);
      } else {
        console.log(output);
      }
    }

    this.dispatchEvent({
      type: 'message',
      level: level,
      message: message
    });
  };

  var logger = new Logger();

  function _createSuper$21(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$21(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$21() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var browserType = {
    DEFAULT: 0,
    SAFARI: 1
  };

  function encodeQueryComponent(text, excludeExp) {
    var encode = function encode(code) {
      return String.fromCharCode(parseInt(code.substr(1), 16));
    };

    return encodeURIComponent(text).replace(excludeExp, encode).replace(/%20/g, '+');
  }

  function decodeQueryComponent(text) {
    return decodeURIComponent(text.replace(/\+/g, ' '));
  }

  function getUrlParameters(url) {
    url = url || window.location.search;
    var query = url.substring(url.indexOf('?') + 1);
    var search = /([^&=]+)=?([^&]*)/g;
    var result = [];
    var match;

    while ((match = search.exec(query)) !== null) {
      result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
    }

    return result;
  }

  function getUrlParametersAsDict(url) {
    var result = {};
    var a = getUrlParameters(url);

    for (var i = 0; i < a.length; ++i) {
      var _a$i = _slicedToArray(a[i], 2),
          key = _a$i[0],
          value = _a$i[1];

      result[key] = value;
    }

    return result;
  }

  function resolveURL(str) {
    if (typeof URL !== 'undefined') {
      try {
        if (typeof window !== 'undefined') {
          return new URL(str, window.location).href;
        }

        return new URL(str).href;
      } catch (error) {}
    }

    if (typeof document !== 'undefined') {
      var anchor = document.createElement('a');
      anchor.href = str;
      return anchor.href;
    }

    return str;
  }

  function generateRegExp(symbolStr) {
    var symbolList = [];

    for (var i = 0, n = symbolStr.length; i < n; ++i) {
      symbolList[symbolList.length] = symbolStr[i].charCodeAt(0).toString(16);
    }

    var listStr = symbolList.join('|');
    return new RegExp("%(?:".concat(listStr, ")"), 'gi');
  }

  function createElement$1(tag, attrs, content) {
    var element = document.createElement(tag);
    var i;
    var n;

    if (attrs) {
      var keys = Object.keys(attrs);

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        element.setAttribute(key, attrs[key]);
      }
    }

    if (content) {
      if (!(content instanceof Array)) {
        content = [content];
      }

      for (i = 0, n = content.length; i < n; ++i) {
        var child = content[i];

        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child));
        } else if (child instanceof HTMLElement) {
          element.appendChild(child);
        }
      }
    }

    return element;
  }

  function deriveClass(cls, base, members, statics) {
    cls.prototype = ___default["default"].assign(Object.create(base.prototype), {
      constructor: cls
    }, members);

    if (statics) {
      ___default["default"].assign(cls, statics);
    }

    return cls;
  }

  function deriveDeep(obj, needZeroOwnProperties) {
    var res = obj;
    var i;
    var n;

    if (obj instanceof Array) {
      res = new Array(obj.length);

      for (i = 0, n = obj.length; i < n; ++i) {
        res[i] = deriveDeep(obj[i]);
      }
    } else if (obj instanceof Object) {
      res = Object.create(obj);
      var keys = Object.keys(obj);

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i];
        var value = obj[key];
        var copy = deriveDeep(value);

        if (copy !== value) {
          res[key] = copy;
        }
      }

      if (needZeroOwnProperties && Object.keys(res).length > 0) {
        res = Object.create(res);
      }
    }

    return res;
  }

  function hexColor(color) {
    var hex = "0000000".concat(color.toString(16)).substr(-6);
    return "#".concat(hex);
  }

  function DebugTracer(namespace) {
    var enabled = false;

    this.enable = function (on) {
      enabled = on;
    };

    var indent = 0;
    var methods = Object.keys(namespace);

    function wrap(method_, name_) {
      return function () {
        var spaces = DebugTracer.spaces.substr(0, indent * 2);

        if (enabled) {
          logger.debug("".concat(spaces + name_, " {"));
        }

        indent++;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var result = method_.apply(this, args);
        indent--;

        if (enabled) {
          logger.debug("".concat(spaces, "} // ").concat(name_));
        }

        return result;
      };
    }

    for (var i = 0, n = methods.length; i < n; ++i) {
      var name = methods[i];
      var method = namespace[name];

      if (method instanceof Function && name !== 'constructor') {
        namespace[name] = wrap(method, name);
      }
    }
  }

  DebugTracer.spaces = '                                                                                          ';

  var OutOfMemoryError = /*#__PURE__*/function (_Error) {
    _inherits(OutOfMemoryError, _Error);

    var _super = _createSuper$21(OutOfMemoryError);

    function OutOfMemoryError(message) {
      var _this;

      _classCallCheck(this, OutOfMemoryError);

      _this = _super.call(this);
      _this.name = 'OutOfMemoryError';
      _this.message = message;
      return _this;
    }

    return OutOfMemoryError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function allocateTyped(TypedArrayName, size) {
    var result = null;

    try {
      result = new TypedArrayName(size);
    } catch (e) {
      if (e instanceof RangeError) {
        throw new OutOfMemoryError(e.message);
      } else {
        throw e;
      }
    }

    return result;
  }

  function bytesToBase64(buffer) {
    var bytes = new Uint8Array(buffer);
    var binary = '';

    for (var i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }

    return window.btoa(binary);
  }

  function bytesFromBase64(str) {
    var binary = window.atob(str);
    var bytes = new Uint8Array(binary.length);

    for (var i = 0; i < bytes.length; ++i) {
      bytes[i] = binary[i].charCodeAt(0);
    }

    return bytes.buffer;
  }

  function arrayToBase64(array, TypedArrayClass) {
    return bytesToBase64(new TypedArrayClass(array).buffer);
  }

  function arrayFromBase64(str, TypedArrayClass) {
    return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
  }

  function compareOptionsWithDefaults(opts, defOpts) {
    var optsStr = [];

    if (defOpts && opts) {
      var keys = Object.keys(opts);

      for (var p = 0; p < keys.length; ++p) {
        var key = keys[p];
        var value = opts[key];

        if (!(value instanceof Object) && typeof defOpts[key] !== 'undefined' && defOpts[key] !== value) {
          optsStr.push("".concat(key, ":").concat(value));
        }
      }

      if (optsStr.length > 0) {
        return "!".concat(optsStr.join());
      }
    }

    return '';
  }

  function isAlmostPlainObject(o) {
    if (___default["default"].isPlainObject(o)) {
      return true;
    }

    var proto = o && Object.getPrototypeOf(o);
    return !!proto && !proto.hasOwnProperty('constructor') && isAlmostPlainObject(proto);
  }

  function objectsDiff(src, dst) {
    var diff = {};

    ___default["default"].forIn(src, function (srcValue, key) {
      var dstValue = dst[key];

      if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
        var deepDiff = objectsDiff(srcValue, dstValue);

        if (!___default["default"].isEmpty(deepDiff)) {
          diff[key] = deepDiff;
        }
      } else if (!___default["default"].isEqual(srcValue, dstValue)) {
        diff[key] = srcValue;
      }
    });

    return diff;
  }

  function forInRecursive(object, callback) {
    function iterateThrough(obj, prefix) {
      ___default["default"].forIn(obj, function (value, key) {
        var newPref = prefix + (prefix.length > 0 ? '.' : '');

        if (value instanceof Object) {
          iterateThrough(value, newPref + key);
        } else if (value !== undefined) {
          callback(value, newPref + key);
        }
      });
    }

    iterateThrough(object, '');
  }

  function enquoteString(value) {
    if (___default["default"].isString(value)) {
      return "\"".concat(value.replace(/"/g, '\\"'), "\"");
    }

    return value;
  }

  function unquoteString(value) {
    if (!___default["default"].isString(value)) {
      return value;
    }

    if (value[0] === '"' && value[value.length - 1] === '"') {
      value = value.slice(1, value.length - 1);
      return value.replace(/\\"/g, '"');
    }

    if (value[0] === "'" && value[value.length - 1] === "'") {
      value = value.slice(1, value.length - 1);
      return value.replace(/\\'/g, "'");
    }

    throw new SyntaxError("Incorrect string format, can't unqute it");
  }

  function getFileExtension(fileName) {
    return fileName.slice(Math.max(0, fileName.lastIndexOf('.')) || Infinity);
  }

  function splitFileName(fileName) {
    var ext = getFileExtension(fileName);
    var name = fileName.slice(0, fileName.length - ext.length);
    return [name, ext];
  }

  function dataUrlToBlob(url) {
    var parts = url.split(/[:;,]/);
    var partsCount = parts.length;

    if (partsCount >= 3 && parts[partsCount - 2] === 'base64') {
      return new Blob([bytesFromBase64(parts[partsCount - 1])]);
    }

    return null;
  }

  function getBrowser() {
    if (navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') === -1 && navigator.userAgent.indexOf('FxiOS') === -1) {
      return browserType.SAFARI;
    }

    return browserType.DEFAULT;
  }

  function shotOpen(url) {
    if (typeof window !== 'undefined') {
      window.open().document.write("<body style=\"margin:0\"><img src=\"".concat(url, "\" /></body>"));
    }
  }

  function shotDownload(dataUrl, filename) {
    if (!dataUrl || dataUrl.substr(0, 5) !== 'data:') {
      return;
    }

    if (!filename) {
      filename = ['screenshot-', +new Date(), '.png'].join('');
    }

    if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a');
      link.download = filename;
      link.innerHTML = 'download';
      link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  function download(data, filename, type) {
    var blobData = new Blob([data]);

    if (!filename) {
      filename = ['data', +new Date()].join('');
    }

    if (!type) {
      filename += blobData.type || '.bin';
    } else {
      filename += ".".concat(type);
    }

    if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
      window.navigator.msSaveBlob(blobData, filename);
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a');
      link.download = filename;
      link.innerHTML = 'download';
      link.href = window.URL.createObjectURL(blobData);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  }

  function copySubArrays$2(src, dst, indices, itemSize) {
    for (var i = 0, n = indices.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        dst[i * itemSize + j] = src[indices[i] * itemSize + j];
      }
    }
  }

  function shallowCloneNode(node) {
    var newNode = node.cloneNode(true);
    newNode.worldPos = node.worldPos;
    return newNode;
  }

  var unquotedStringRE = /^[a-zA-Z0-9_]*$/;
  var enquoteHelper = ['"', '', '"'];

  function correctSelectorIdentifier(value) {
    if (unquotedStringRE.test(value)) {
      return value;
    }

    enquoteHelper[1] = value;
    return enquoteHelper.join('');
  }

  function concatTypedArraysUnsafe(first, second) {
    var result = new first.constructor(first.length + second.length);
    result.set(first);
    result.set(second, first.length);
    return result;
  }

  function mergeTypedArraysUnsafe(array) {
    if (array.length <= 0) {
      return null;
    }

    var size = array.reduce(function (acc, cur) {
      return acc + cur.length;
    }, 0);
    var result = new array[0].constructor(size);

    for (var i = 0, start = 0; i < array.length; i++) {
      var count = array[i].length;
      result.set(array[i], start);
      start += count;
    }

    return result;
  }

  var utils = {
    browserType: browserType,
    encodeQueryComponent: encodeQueryComponent,
    decodeQueryComponent: decodeQueryComponent,
    getUrlParameters: getUrlParameters,
    getUrlParametersAsDict: getUrlParametersAsDict,
    resolveURL: resolveURL,
    generateRegExp: generateRegExp,
    createElement: createElement$1,
    deriveClass: deriveClass,
    deriveDeep: deriveDeep,
    hexColor: hexColor,
    DebugTracer: DebugTracer,
    OutOfMemoryError: OutOfMemoryError,
    allocateTyped: allocateTyped,
    bytesFromBase64: bytesFromBase64,
    bytesToBase64: bytesToBase64,
    arrayFromBase64: arrayFromBase64,
    arrayToBase64: arrayToBase64,
    compareOptionsWithDefaults: compareOptionsWithDefaults,
    objectsDiff: objectsDiff,
    forInRecursive: forInRecursive,
    enquoteString: enquoteString,
    unquoteString: unquoteString,
    getBrowser: getBrowser,
    shotOpen: shotOpen,
    shotDownload: shotDownload,
    copySubArrays: copySubArrays$2,
    shallowCloneNode: shallowCloneNode,
    correctSelectorIdentifier: correctSelectorIdentifier,
    getFileExtension: getFileExtension,
    splitFileName: splitFileName,
    download: download,
    concatTypedArraysUnsafe: concatTypedArraysUnsafe,
    mergeTypedArraysUnsafe: mergeTypedArraysUnsafe
  };

  function _createSuper$20(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$20(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$20() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var JobHandle = /*#__PURE__*/function (_EventDispatcher) {
    _inherits(JobHandle, _EventDispatcher);

    var _super = _createSuper$20(JobHandle);

    function JobHandle() {
      var _this;

      _classCallCheck(this, JobHandle);

      _this = _super.call(this);
      _this._shouldCancel = false;
      return _this;
    }

    _createClass(JobHandle, [{
      key: "cancel",
      value: function cancel() {
        this._shouldCancel = true;
        this.dispatchEvent({
          type: 'cancel'
        });
      }
    }, {
      key: "shouldCancel",
      value: function shouldCancel() {
        return this._shouldCancel;
      }
    }, {
      key: "notify",
      value: function notify(event) {
        this.dispatchEvent({
          type: 'notification',
          slaveEvent: event
        });
      }
    }]);

    return JobHandle;
  }(EventDispatcher);

  var VERSION = 0;
  var defaults = {
    modes: {
      BS: {
        atom: 0.23,
        bond: 0.15,
        space: 0.5,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      VW: {
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 8,
          high: 16,
          ultra: 32
        }
      },
      LN: {
        multibond: true,
        showarom: true,
        offsarom: 0.2,
        chunkarom: 10,
        atom: 0.23,
        lineWidth: 2
      },
      LC: {
        bond: 0.2,
        space: 0.0,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      SA: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      SE: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      QS: {
        isoValue: 0.5,
        gaussLim: {
          poor: 1.5,
          low: 2.0,
          medium: 2.5,
          high: 3.0,
          ultra: 4.0
        },
        scale: 1.0,
        wireframe: false,
        gridSpacing: {
          poor: 2,
          low: 1.5,
          medium: 1,
          high: 0.5,
          ultra: 0.25
        },
        subset: '',
        zClip: false
      },
      CS: {
        probeRadius: 1.4,
        isoValue: 1.5,
        wireframe: false,
        probePositions: 30,
        polyComplexity: {
          poor: 0.5,
          low: 1.0,
          medium: 1.5,
          high: 1.75,
          ultra: 2.0
        },
        subset: '',
        zClip: false
      },
      TR: {
        radius: 0.3,
        polyComplexity: {
          poor: 12,
          low: 16,
          medium: 32,
          high: 64,
          ultra: 64
        }
      },
      TU: {
        radius: 0.3,
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      CA: {
        radius: 0.3,
        depth: 0.25,
        ss: {
          helix: {
            width: 1.0,
            arrow: 2.0
          },
          strand: {
            width: 1.0,
            arrow: 2.0
          }
        },
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      TX: {
        template: '{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}',
        horizontalAlign: 'center',
        verticalAlign: 'middle',
        dx: 0,
        dy: 0,
        dz: 1,
        fg: 'none',
        bg: '0x202020',
        showBg: true
      },
      VD: {
        kSigma: 1.0,
        kSigmaMed: 2.0,
        kSigmaMax: 4.0,
        frame: true,
        isoMode: false,
        polyComplexity: {
          poor: 2,
          low: 3,
          medium: 4,
          high: 8,
          ultra: 10
        }
      }
    },
    colorers: {
      EL: {
        carbon: -1
      },
      UN: {
        color: 0xffffff
      },
      CO: {
        subset: 'charged',
        color: 0xff0000,
        baseColor: 0xffffff
      },
      CB: {
        color: 0x909090,
        factor: 0.6
      },
      SQ: {
        gradient: 'rainbow'
      },
      TM: {
        gradient: 'temp',
        min: 5,
        max: 40
      },
      OC: {
        gradient: 'reds'
      },
      HY: {
        gradient: 'blue-red'
      },
      MO: {
        gradient: 'rainbow'
      }
    },
    antialias: true,
    camFov: 45.0,
    camNear: 0.5,
    camFar: 100.0,
    camDistance: 2.5,
    radiusToFit: 1.0,
    fogNearFactor: 0.5,
    fogFarFactor: 1,
    fogAlpha: 1.0,
    fogColor: 0x000000,
    fogColorEnable: false,
    palette: 'JM',
    resolution: 'medium',
    autoResolution: false,
    autoPreset: true,
    preset: 'default',
    presets: {
      default: [{
        mode: 'BS',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      empty: [],
      wire: [{
        mode: 'LN',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      small: [{
        mode: 'BS',
        colorer: 'EL',
        selector: 'all',
        material: 'SF'
      }],
      macro: [{
        mode: 'CA',
        colorer: 'SS',
        selector: 'not hetatm',
        material: 'SF'
      }, {
        mode: 'BS',
        colorer: 'EL',
        selector: 'hetatm and not water',
        material: 'SF'
      }]
    },
    objects: {
      line: {
        color: 0xffffffff,
        dashSize: 0.3,
        gapSize: 0.05
      }
    },
    bg: {
      color: 0x202020,
      transparent: false
    },
    draft: {
      clipPlane: false,
      clipPlaneFactor: 0.5,
      clipPlaneSpeed: 0.00003
    },
    plugins: {},
    axes: true,
    fog: true,
    fps: true,
    zSprites: true,
    isoSurfaceFakeOpacity: true,
    suspendRender: true,
    nowater: false,
    autobuild: true,
    fxaa: true,
    outline: {
      on: false,
      color: 0x000000,
      threshold: 0.1,
      thickness: 1
    },
    ao: false,
    shadow: {
      on: false,
      type: 'random',
      radius: 1.0
    },
    autoRotation: 0.0,
    maxfps: 30,
    fbxprec: 4,
    autoRotationAxisFixed: true,
    zooming: true,
    picking: true,
    pick: 'atom',
    editing: false,
    aromatic: false,
    singleUnit: true,
    stereo: 'NONE',
    interpolateViews: true,
    transparency: 'prepass',
    translationSpeed: 2,
    debug: {
      example: 3.5,
      text: 'hello!',
      good: true,
      ssaoKernelRadius: 0.7,
      ssaoFactor: 0.7,
      stereoBarrel: 0.25
    },
    use: {
      multiFile: false
    }
  };

  function Settings() {
    EventDispatcher.call(this);
    this.old = null;
    this.now = {};
    this._changed = {};
    this.reset();
  }

  utils.deriveClass(Settings, EventDispatcher, {
    defaults: defaults,
    set: function set(path, value) {
      if (___default["default"].isString(path)) {
        var oldValue = ___default["default"].get(this.now, path);

        if (oldValue !== value) {
          ___default["default"].set(this.now, path, value);

          this._notifyChange(path, value);
        }
      } else {
        var diff = utils.objectsDiff(path, this.now);

        if (!___default["default"].isEmpty(diff)) {
          ___default["default"].merge(this.now, diff);

          this._notifyChanges(diff);
        }
      }
    },
    get: function get(path, defaultValue) {
      return ___default["default"].get(this.now, path, defaultValue);
    },
    reset: function reset() {
      var diff = utils.objectsDiff(defaults, this.now);
      this.now = ___default["default"].cloneDeep(defaults);
      this.old = null;

      this._notifyChanges(diff);

      this._changed = {};
    },
    checkpoint: function checkpoint() {
      this.old = ___default["default"].cloneDeep(this.now);
      this._changed = {};
    },
    _notifyChange: function _notifyChange(path, value) {
      this._changed[path] = true;
      this.dispatchEvent({
        type: "change:".concat(path),
        value: value
      });
    },
    _notifyChanges: function _notifyChanges(diff) {
      var _this = this;

      utils.forInRecursive(diff, function (deepValue, deepPath) {
        _this._notifyChange(deepPath, deepValue);
      });
    },
    changed: function changed() {
      if (!this.old) {
        return [];
      }

      var old = this.old,
          now = this.now;

      var keys = ___default["default"].filter(Object.keys(this._changed), function (key) {
        return ___default["default"].get(old, key) !== ___default["default"].get(now, key);
      });

      return keys;
    },
    applyDiffs: function applyDiffs(diffs) {
      if (diffs.hasOwnProperty('VERSION') && diffs.VERSION !== VERSION) {
        throw new Error('Settings version does not match!');
      }

      delete diffs.VERSION;
      this.reset();
      this.set(diffs);
    },
    getDiffs: function getDiffs(versioned) {
      var diffs = utils.objectsDiff(this.now, defaults);

      if (versioned) {
        diffs.VERSION = VERSION;
      }

      return diffs;
    },
    setPluginOpts: function setPluginOpts(plugin, opts) {
      defaults.plugins[plugin] = ___default["default"].cloneDeep(opts);
      this.now.plugins[plugin] = ___default["default"].cloneDeep(opts);
    }
  });
  var settings$1 = new Settings();

  var repIndex = 0;

  function asBoolean(value) {
    return !(!value || value === '0' || ___default["default"].isString(value) && value.toLowerCase() === 'false');
  }

  var adapters = {
    string: String,
    number: Number,
    boolean: asBoolean
  };
  var cL1Ass = '=';
  var cOptsSep = '!';
  var cL2Ass = ':';
  var cLSep = ',';
  var cCommonIgnoreSymbols = '$;@/?';

  function getLevel1ExcludedExpr() {
    var cLevel1Ignores = ':,';
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
  }

  function getLevel2ExcludedExpr() {
    var cLevel2Ignores = ' ';
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
  }

  var cL1ExclExpr = getLevel1ExcludedExpr();

  function encodeQueryComponentL1(value) {
    return utils.encodeQueryComponent(value, cL1ExclExpr);
  }

  var cL2ExclExpr = getLevel2ExcludedExpr();

  function encodeQueryComponentL2(value) {
    return utils.encodeQueryComponent(value, cL2ExclExpr);
  }

  function ensureRepList(opts) {
    var reps = opts.reps;

    if (!reps) {
      var presets = settings$1.now.presets;
      var preset = opts.preset || settings$1.now.preset;
      reps = presets[preset];

      if (!reps) {
        logger.warn("Unknown preset \"".concat(preset, "\""));

        var _Object$keys = Object.keys(presets);

        var _Object$keys2 = _slicedToArray(_Object$keys, 1);

        preset = _Object$keys2[0];
        reps = presets[preset];
      }

      opts.preset = preset;
      opts.reps = utils.deriveDeep(reps, true);
    }
  }

  function ensureRepAssign(opts, prop, value) {
    ensureRepList(opts);
    var rep = opts.reps[repIndex];

    if (rep.hasOwnProperty(prop)) {
      repIndex = opts.reps.length;
      opts.reps[repIndex] = utils.deriveDeep(rep, true);
    }

    if (value !== undefined) {
      opts.reps[repIndex][prop] = value;
    }
  }

  function addObject(opts, params, options) {
    if (opts._objects === undefined) {
      opts._objects = [];
    }

    var _options = _slicedToArray(options, 2),
        type = _options[0],
        newOpts = _options[1];

    var newObj = {
      type: type,
      params: params
    };

    if (newOpts !== undefined) {
      newObj.opts = newOpts;
    }

    opts._objects[opts._objects.length] = newObj;
  }

  function parseParams(str, params) {
    var sep = str.indexOf(',');

    if (sep >= 0) {
      params.push(str.substr(sep + 1).split(','));
      return str.substr(0, sep);
    }

    return str;
  }

  function extractArgs(input, defaultsDict, params) {
    if (input) {
      var bang = input.indexOf(cOptsSep);
      var inputVal = parseParams(input.substr(0, bang >= 0 ? bang : undefined), params);

      if (bang >= 0) {
        var args = input.substr(bang + 1).split(cLSep);
        input = inputVal;

        if (defaultsDict) {
          var defaults = defaultsDict[input];
          var opts = utils.deriveDeep(defaults, true);
          args.forEach(function (arg) {
            var pair = arg.split(cL2Ass, 2);
            var key = decodeURIComponent(pair[0]);
            var value = decodeURIComponent(pair[1]);

            var adapter = adapters[_typeof(___default["default"].get(defaults, key))];

            if (adapter) {
              ___default["default"].set(opts, key, adapter(value));
            } else {
              logger.warn("Unknown argument \"".concat(key, "\" for option \"").concat(input, "\""));
            }
          });

          if (Object.keys(opts).length > 0) {
            input = [input, opts];
          }
        }
      } else {
        input = inputVal;
      }
    }

    return input;
  }

  var actions = {
    l: 'load',
    load: String,
    t: 'type',
    type: String,
    v: 'view',
    view: String,
    u: 'unit',
    unit: Number,
    menu: asBoolean,
    o: 'object',
    object: function object(value, opts) {
      var params = [];
      var options = extractArgs(value, settings$1.defaults.objects, params);

      if (!Array.isArray(options)) {
        options = [options];
      }

      addObject(opts, params[0], options);
    },
    p: 'preset',
    preset: function preset(value, opts) {
      opts.preset = value;
      opts.reps = null;
      ensureRepList(opts);
    },
    r: 'rep',
    rep: function rep(value, opts) {
      ensureRepList(opts);
      repIndex = Number(value);
      repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length;

      if (repIndex === opts.reps.length) {
        opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings$1.defaults.presets.default[0], true);
      }
    },
    s: 'select',
    select: function select(value, opts) {
      ensureRepAssign(opts, 'selector', value);
    },
    m: 'mode',
    mode: function mode(value, opts) {
      ensureRepAssign(opts, 'mode', extractArgs(value, settings$1.defaults.modes));
    },
    c: 'color',
    color: function color(value, opts) {
      ensureRepAssign(opts, 'colorer', extractArgs(value, settings$1.defaults.colorers));
    },
    mt: 'material',
    material: function material(value, opts) {
      ensureRepAssign(opts, 'material', extractArgs(value, settings$1.defaults.materials));
    },
    dup: function dup(value, opts) {
      ensureRepList(opts);
      var reps = opts.reps;
      var rep = reps[repIndex];
      repIndex = reps.length;
      reps[repIndex] = utils.deriveDeep(rep, true);
    },
    ar: 'autoResolution'
  };

  function _fromArray(entries) {
    repIndex = 0;
    var opts = {};

    for (var i = 0, n = entries.length; i < n; ++i) {
      var entry = entries[i];
      var key = entry[0];
      var value = entry[1];
      var action = actions[key];

      while (___default["default"].isString(action)) {
        key = action;
        action = actions[key];
      }

      if (!action) {
        var adapter = adapters[_typeof(___default["default"].get(settings$1.defaults, key))];

        if (adapter) {
          ___default["default"].set(opts, "settings.".concat(key), adapter(value));
        } else {
          logger.warn("Unknown option \"".concat(key, "\""));
        }
      } else if (___default["default"].isFunction(action)) {
        var result = action(value, opts);

        if (result !== undefined) {
          opts[key] = result;
        }
      }
    }

    return opts;
  }

  function fromAttr(attr) {
    return _fromArray(utils.getUrlParameters("?".concat(attr || '')));
  }

  function fromURL(url) {
    return _fromArray(utils.getUrlParameters(url));
  }

  function _processOptsForURL(opts) {
    var str = [];
    var i = 0;
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
    });
    return str.join(cLSep);
  }

  function _processArgsForURL(args) {
    if (!___default["default"].isArray(args)) {
      return args;
    }

    if (args.length < 2) {
      return args[0];
    }

    return "".concat(args[0]).concat(cOptsSep).concat(_processOptsForURL(args[1]));
  }

  function _processObjForURL(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined;
    }

    var res = objOpts.type;

    if (___default["default"].isArray(objOpts.params) && objOpts.params.length > 0) {
      res += ",".concat(objOpts.params.join(','));
    }

    if (objOpts.opts) {
      res += cOptsSep + _processOptsForURL(objOpts.opts);
    }

    return res;
  }

  function toURL(opts) {
    var stringList = [];
    var idx = 0;

    function checkAndAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        stringList[idx++] = encodeQueryComponentL1(prefix) + cL1Ass + encodeQueryComponentL1(value);
      }
    }

    function addReps(repList) {
      if (!repList) {
        return;
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        if (___default["default"].isEmpty(repList[i])) {
          continue;
        }

        checkAndAdd('r', i);
        checkAndAdd('s', repList[i].selector);
        checkAndAdd('m', _processArgsForURL(repList[i].mode));
        checkAndAdd('c', _processArgsForURL(repList[i].colorer));
        checkAndAdd('mt', _processArgsForURL(repList[i].material));
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return;
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('o', _processObjForURL(objList[i]));
      }
    }

    checkAndAdd('l', opts.load);
    checkAndAdd('u', opts.unit);
    checkAndAdd('p', opts.preset);
    addReps(opts.reps);
    addObjects(opts._objects);
    checkAndAdd('v', opts.view);
    utils.forInRecursive(opts.settings, function (value, key) {
      if (key === 'preset') {
        return;
      }

      checkAndAdd(key, value);
    });
    var url = '';

    if (typeof window !== 'undefined') {
      var _window = window,
          location = _window.location;
      url = "".concat(location.protocol, "//").concat(location.host).concat(location.pathname);
    }

    if (stringList.length > 0) {
      url += "?".concat(stringList.join('&'));
    }

    return url;
  }

  function _processOptsForScript(opts) {
    var str = [];
    var i = 0;
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = "".concat(key, "=").concat(utils.enquoteString(value));
    });
    return str.join(' ');
  }

  function _processArgsForScript(args) {
    if (!___default["default"].isArray(args)) {
      return args;
    }

    if (args.length < 2) {
      return args[0];
    }

    return "".concat(args[0], " ").concat(_processOptsForScript(args[1]));
  }

  function _processObjForScript(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined;
    }

    var res = objOpts.type;

    if (___default["default"].isArray(objOpts.params) && objOpts.params.length > 0) {
      res += " ".concat(objOpts.params.map(utils.enquoteString).join(' '));
    }

    if (objOpts.opts) {
      res += " ".concat(_processOptsForScript(objOpts.opts));
    }

    return res;
  }

  function _processRepsForScript(rep, index) {
    var repString = [];
    var strIdx = 0;

    function localAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        repString[strIdx++] = prefix + value;
      }
    }

    if (___default["default"].isEmpty(rep)) {
      return null;
    }

    localAdd('', index);
    localAdd('s=', utils.enquoteString(rep.selector));
    localAdd('m=', _processArgsForScript(rep.mode));
    localAdd('c=', _processArgsForScript(rep.colorer));
    localAdd('mt=', _processArgsForScript(rep.material));
    return repString.join(' ');
  }

  function toScript(opts) {
    var commandsList = [];
    var idx = 0;

    function checkAndAdd(command, value, saveQuotes) {
      if (value !== null && value !== undefined) {
        var quote = typeof value === 'string' && saveQuotes ? '"' : '';
        commandsList[idx++] = "".concat(command, " ").concat(quote).concat(value).concat(quote).trim();
      }
    }

    function addReps(repList) {
      if (!repList) {
        return;
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        checkAndAdd('rep', _processRepsForScript(repList[i], i));
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return;
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('', _processObjForScript(objList[i]));
      }
    }

    checkAndAdd('set', 'autobuild false');
    checkAndAdd('load', opts.load, true);
    checkAndAdd('unit', opts.unit);
    checkAndAdd('preset', opts.preset);
    addReps(opts.reps);
    addObjects(opts._objects);
    utils.forInRecursive(opts.settings, function (value, key) {
      if (key === 'preset') {
        return;
      }

      checkAndAdd("set ".concat(key), value, true);
    });
    checkAndAdd('view', opts.view);
    checkAndAdd('set', 'autobuild true');
    return commandsList.join('\n');
  }

  var options$1 = {
    fromURL: fromURL,
    fromAttr: fromAttr,
    adapters: adapters,
    toURL: toURL,
    toScript: toScript
  };

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var Atom$2 = /*#__PURE__*/function () {
    function Atom(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
      _classCallCheck(this, Atom);

      this.index = -1;
      this.residue = residue;
      this.name = name;
      this.element = type;
      this.position = position;
      this.role = role;
      this.mask = 1 | 0;
      this.het = het;
      this.serial = serial;
      this.location = (location || ' ').charCodeAt(0);
      this.occupancy = occupancy || 1;
      this.temperature = temperature;
      this.charge = charge;
      this.hydrogenCount = -1;
      this.radicalCount = 0;
      this.valence = -1;
      this.bonds = [];
      this.flags = 0x0000;

      if (type.name === 'H') {
        this.flags |= Atom.Flags.HYDROGEN;
      } else if (type.name === 'C') {
        this.flags |= Atom.Flags.CARBON;
      }
    }

    _createClass(Atom, [{
      key: "isHet",
      value: function isHet() {
        return this.het;
      }
    }, {
      key: "isHydrogen",
      value: function isHydrogen() {
        return this.element.number === 1;
      }
    }, {
      key: "getVisualName",
      value: function getVisualName() {
        var name = this.name;

        if (name.length > 0) {
          return name;
        }

        return this.element.name.trim();
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]);
        }
      }
    }, {
      key: "getFullName",
      value: function getFullName() {
        var name = '';

        if (this.residue !== null) {
          if (this.residue._chain !== null) {
            name += "".concat(this.residue._chain.getName(), ".");
          }

          name += "".concat(this.residue._sequence, ".");
        }

        name += this.name;
        return name;
      }
    }]);

    return Atom;
  }();

  _defineProperty(Atom$2, "Flags", {
    CARBON: 0x0001,
    HYDROGEN: 0x0008,
    NONPOLARH: 0x1008
  });

  var Element$a = function Element(number, name, fullName, weight, radius, radiusBonding, hValency) {
    _classCallCheck(this, Element);

    this.number = number;
    this.name = name;
    this.fullName = fullName;
    this.weight = weight;
    this.radius = radius;
    this.radiusBonding = radiusBonding;
    this.hydrogenValency = hValency;
  };

  _defineProperty(Element$a, "Constants", {
    U1: 1,
    Lead: 2,
    U2: 3,
    Wing: 4,
    U18: 18
  });

  _defineProperty(Element$a, "Role", {
    N: Element$a.Constants.U1,
    CA: Element$a.Constants.Lead,
    C: Element$a.Constants.U2,
    O: Element$a.Constants.Wing,
    SG: Element$a.Constants.U18
  });

  _defineProperty(Element$a, "ByAtomicNumber", [null, new Element$a(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]), new Element$a(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]), new Element$a(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]), new Element$a(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]), new Element$a(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]), new Element$a(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]), new Element$a(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [3, 5]), new Element$a(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [2, 4]), new Element$a(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]), new Element$a(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]), new Element$a(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]), new Element$a(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]), new Element$a(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]), new Element$a(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]), new Element$a(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [3, 5]), new Element$a(16, 'S', 'Sulfur', 32.07, 2, 1.02, [2, 4, 6]), new Element$a(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [1, 3, 5, 7]), new Element$a(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]), new Element$a(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]), new Element$a(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]), new Element$a(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]), new Element$a(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]), new Element$a(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]), new Element$a(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]), new Element$a(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]), new Element$a(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]), new Element$a(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]), new Element$a(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]), new Element$a(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]), new Element$a(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]), new Element$a(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]), new Element$a(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]), new Element$a(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [3, 5]), new Element$a(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [2, 4, 6]), new Element$a(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [1, 3, 5, 7]), new Element$a(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]), new Element$a(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]), new Element$a(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]), new Element$a(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]), new Element$a(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]), new Element$a(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]), new Element$a(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]), new Element$a(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]), new Element$a(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]), new Element$a(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]), new Element$a(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]), new Element$a(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]), new Element$a(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]), new Element$a(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]), new Element$a(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [2, 4]), new Element$a(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [3, 5]), new Element$a(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [2, 4, 6]), new Element$a(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [1, 3, 5, 7]), new Element$a(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]), new Element$a(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]), new Element$a(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]), new Element$a(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]), new Element$a(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]), new Element$a(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]), new Element$a(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]), new Element$a(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]), new Element$a(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]), new Element$a(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]), new Element$a(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]), new Element$a(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]), new Element$a(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]), new Element$a(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]), new Element$a(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]), new Element$a(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]), new Element$a(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]), new Element$a(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]), new Element$a(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]), new Element$a(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]), new Element$a(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]), new Element$a(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]), new Element$a(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]), new Element$a(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]), new Element$a(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]), new Element$a(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]), new Element$a(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]), new Element$a(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [1, 3]), new Element$a(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [2, 4]), new Element$a(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [3, 5]), new Element$a(84, 'PO', 'Polonium', 210, 1.7, 1.68, [2, 4, 6]), new Element$a(85, 'AT', 'Astatine', 210, 1.7, 1.7, [1, 3, 5, 7]), new Element$a(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]), new Element$a(87, 'FR', 'Francium', 223, 1.7, 2, [1]), new Element$a(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]), new Element$a(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]), new Element$a(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]), new Element$a(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]), new Element$a(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]), new Element$a(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]), new Element$a(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]), new Element$a(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]), new Element$a(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]), new Element$a(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]), new Element$a(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]), new Element$a(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]), new Element$a(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]), new Element$a(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]), new Element$a(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]), new Element$a(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]), new Element$a(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]), new Element$a(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]), new Element$a(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]), new Element$a(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]), new Element$a(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]), new Element$a(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])]);

  _defineProperty(Element$a, "ByName", {
    D: new Element$a(1, 'D', 'Deuterium', 2.014, 1.2, 0.23, [1]),
    T: new Element$a(1, 'T', 'Tritium', 3.016, 1.2, 0.23, [1])
  });

  (function () {
    var byAtomicNumber = Element$a.ByAtomicNumber;
    var byName = Element$a.ByName;

    for (var i = 0, n = byAtomicNumber.length; i < n; ++i) {
      var element = byAtomicNumber[i];

      if (element) {
        byName[element.name] = element;
      }
    }
  })();

  Element$a.getByName = function (element) {
    var type = Element$a.ByName[element];

    if (!type) {
      type = Element$a.ByName[element] = new Element$a(0, element, 'Unknown', 0, 1.0, 0.01, [0]);
    }

    return type;
  };

  var cBondTypes = {
    UNKNOWN: 0,
    COVALENT: 1,
    AROMATIC: 2
  };

  function getAtomPos(atom) {
    return atom.position;
  }

  var Bond$5 = /*#__PURE__*/function () {
    function Bond(left, right, order, type, fixed) {
      _classCallCheck(this, Bond);

      this._left = left;
      this._right = right;
      this._fixed = fixed;
      this._index = -1;

      if (left > right) {
        throw new Error('In a bond atom indices must be in increasing order');
      }

      this._order = order;
      this._type = type;
    }

    _createClass(Bond, [{
      key: "getLeft",
      value: function getLeft() {
        return this._left;
      }
    }, {
      key: "getRight",
      value: function getRight() {
        return this._right;
      }
    }, {
      key: "getOrder",
      value: function getOrder() {
        return this._order;
      }
    }, {
      key: "calcLength",
      value: function calcLength() {
        return this._left.position.distanceTo(this._right.position);
      }
    }, {
      key: "_forEachNeighbour",
      value: function _forEachNeighbour(currAtom, process) {
        var bonds = currAtom.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right);
        }
      }
    }, {
      key: "forEachLevelOne",
      value: function forEachLevelOne(process) {
        var left = this._left;
        var right = this._right;

        this._forEachNeighbour(left, function (atom) {
          if (atom === right) {
            return;
          }

          process(atom);
        });

        this._forEachNeighbour(right, function (atom) {
          if (atom === left) {
            return;
          }

          process(atom);
        });
      }
    }, {
      key: "forEachLevelTwo",
      value: function forEachLevelTwo(process) {
        var left = this._left;
        var right = this._right;
        var self = this;

        self._forEachNeighbour(left, function (atom) {
          if (atom === right) {
            return;
          }

          self._forEachNeighbour(atom, function (l2Atom) {
            if (l2Atom === left) {
              return;
            }

            process(l2Atom);
          });
        });

        self._forEachNeighbour(right, function (atom) {
          if (atom === left) {
            return;
          }

          self._forEachNeighbour(atom, function (l2Atom) {
            if (l2Atom === right) {
              return;
            }

            process(l2Atom);
          });
        });
      }
    }, {
      key: "_fixDir",
      value: function _fixDir(refPoint, currDir, posGetter) {
        var rightCount = 0;
        var leftCount = 0;
        var tmpVec = refPoint.clone();

        function checkDir(atom) {
          tmpVec.copy(posGetter(atom));
          tmpVec.sub(refPoint);
          var dotProd = currDir.dot(tmpVec);

          if (dotProd > 0) {
            ++rightCount;
          } else {
            ++leftCount;
          }
        }

        function checkCarbon(atom) {
          if (atom.element.name === 'C') {
            checkDir(atom);
          }
        }

        var stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];

        for (var stageId = 0; stageId < stages.length; ++stageId) {
          stages[stageId][0].call(this, stages[stageId][1]);

          if (leftCount > rightCount) {
            return currDir.multiplyScalar(-1);
          }

          if (leftCount < rightCount) {
            return currDir;
          }
        }

        return currDir;
      }
    }, {
      key: "calcNormalDir",
      value: function calcNormalDir(posGetter) {
        var left = this._left;
        var right = this._right;
        var first = left;
        var second = right;
        posGetter = posGetter === undefined ? getAtomPos : posGetter;

        if (left.bonds.length > right.bonds.length) {
          first = right;
          second = left;
        }

        var third = first;
        var maxNeibs = 0;
        var _second = second,
            bonds = _second.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          var another = bonds[i]._left;

          if (bonds[i]._left === second) {
            another = bonds[i]._right;
          }

          if (another.bonds.length > maxNeibs && another !== first) {
            third = another;
            maxNeibs = another.bonds.length;
          }
        }

        var secondPos = posGetter(second);
        var firstV = posGetter(first).clone().sub(secondPos);
        var secondV = posGetter(third).clone().sub(secondPos);
        secondV.crossVectors(firstV, secondV);

        if (secondV.lengthSq() < 0.0001) {
          secondV.set(0, 1, 0);
        }

        firstV.normalize();
        secondV.normalize();
        firstV.crossVectors(secondV, firstV);

        if (firstV.lengthSq() < 0.0001) {
          firstV.set(0, 1, 0);
        }

        firstV.normalize();
        return this._fixDir(secondPos, firstV, posGetter);
      }
    }]);

    return Bond;
  }();

  _defineProperty(Bond$5, "BondType", cBondTypes);

  Bond$5.prototype.BondType = cBondTypes;

  var cNucleicControlNames = ["C3'", 'C3*', 'P', 'H5T', 'H3T'];
  var cNucleicWing1Names = ['OP1', 'O1P'];
  var cNucleicWing2Names = ['OP2', 'O2P'];
  var cCylinderSource = ["C3'", 'C3*', 'C1', "C1'", 'C1*', 'P'];
  var cCylinderTarget = [{
    types: ['A', 'DA', 'G', 'DG'],
    atoms: ['N1']
  }, {
    types: ['C', 'DC'],
    atoms: ['N3']
  }, {
    types: ['T', 'DT', 'U', 'DU'],
    atoms: ['O4']
  }];

  var Residue$1 = /*#__PURE__*/function () {
    function Residue(chain, type, sequence, icode) {
      _classCallCheck(this, Residue);

      this._chain = chain;
      this._component = null;
      this._type = type;
      this._sequence = sequence;
      this._icode = icode;
      this._mask = 1 | 0;
      this._index = -1;
      this._atoms = [];
      this._secondary = null;
      this._firstAtom = null;
      this._leadAtom = null;
      this._wingAtom = null;
      this._lastAtom = null;
      this._controlPoint = null;
      this._midPoint = null;
      this._wingVector = null;
      this._cylinders = null;
      this._isValid = true;
      this._het = false;
      this._molecule = null;
      this.temperature = null;
      this.occupancy = null;
    }

    _createClass(Residue, [{
      key: "getChain",
      value: function getChain() {
        return this._chain;
      }
    }, {
      key: "getMolecule",
      value: function getMolecule() {
        return this._molecule;
      }
    }, {
      key: "getType",
      value: function getType() {
        return this._type;
      }
    }, {
      key: "getSequence",
      value: function getSequence() {
        return this._sequence;
      }
    }, {
      key: "getSecondary",
      value: function getSecondary() {
        return this._secondary;
      }
    }, {
      key: "getICode",
      value: function getICode() {
        return this._icode;
      }
    }, {
      key: "addAtom",
      value: function addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
        var atom = new Atom$2(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);

        var complex = this._chain.getComplex();

        complex.addAtom(atom);

        this._atoms.push(atom);

        this._het = this._het || het;
        return atom;
      }
    }, {
      key: "getAtomCount",
      value: function getAtomCount() {
        return this._atoms.length;
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          if (process(atoms[i])) {
            break;
          }
        }
      }
    }, {
      key: "_findAtomByName",
      value: function _findAtomByName(name) {
        var res = null;
        this.forEachAtom(function (atom) {
          if (atom.name === name) {
            res = atom;
            return true;
          }

          return false;
        });
        return res;
      }
    }, {
      key: "_findFirstAtomInList",
      value: function _findFirstAtomInList(names) {
        var res = null;

        for (var i = 0; i < names.length; ++i) {
          res = this._findAtomByName(names[i]);

          if (res !== null) {
            return res;
          }
        }

        return res;
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          mask &= atoms[i].mask;
        }

        this._mask = mask;
      }
    }, {
      key: "getCylinderTargetList",
      value: function getCylinderTargetList() {
        var type = this._type._name;

        for (var i = 0, n = cCylinderTarget.length; i < n; ++i) {
          for (var j = 0, m = cCylinderTarget[i].types.length; j < m; ++j) {
            if (type === cCylinderTarget[i].types[j]) {
              return cCylinderTarget[i].atoms;
            }
          }
        }

        return null;
      }
    }, {
      key: "_detectLeadWing",
      value: function _detectLeadWing(dst, next, getAtomPosition) {
        var leadAtom = this._findFirstAtomInList(cNucleicControlNames);

        var wingStart = this._findFirstAtomInList(cNucleicWing1Names);

        var wingEnd = this._findFirstAtomInList(cNucleicWing2Names);

        if (wingStart === null && next !== null) {
          wingStart = next._findFirstAtomInList(cNucleicWing1Names);
        }

        if (wingEnd === null && next !== null) {
          wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
        }

        if (leadAtom === null || wingStart === null || wingEnd === null) {
          return;
        }

        dst._leadAtom = leadAtom;
        dst._controlPoint = getAtomPosition(leadAtom);
        dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
        dst._isValid = true;

        var cylSource = this._findFirstAtomInList(cCylinderSource);

        var targetList = this.getCylinderTargetList();
        var cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;

        if (cylSource === null || cylTarget === null) {
          return;
        }

        dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
      }
    }, {
      key: "calcWing",
      value: function calcWing(prevLeadPos, currLeadPos, prevWingPos, prevWing) {
        var vectorA = currLeadPos.clone().sub(prevLeadPos);
        var vectorB = prevLeadPos.clone().sub(prevWingPos);
        vectorB.crossVectors(vectorA, vectorB);
        vectorB.crossVectors(vectorA, vectorB).normalize();

        if (prevWing !== null && prevWing.length() > 0.0001) {
          var needToNegate = vectorB.length() > 0.0001 && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2;

          if (needToNegate) {
            vectorB.negate();
          }
        }

        return vectorB;
      }
    }, {
      key: "_innerFinalize",
      value: function _innerFinalize(prevRes, prev, nextRes, dst, chainAsNucleic, getAtomPosition) {
        var bFirstInChain = prev === null;
        var lp = getAtomPosition(this._leadAtom);
        var currLeadPos = new THREE__namespace.Vector3(lp.x, lp.y, lp.z);

        if (chainAsNucleic) {
          this._detectLeadWing(dst, nextRes, getAtomPosition);

          return;
        }

        if (bFirstInChain) {
          dst._midPoint = getAtomPosition(this._firstAtom).clone();
        } else {
          var prevLeadPos = prev._controlPoint;
          dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
          dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
        }

        dst._controlPoint = currLeadPos;
      }
    }, {
      key: "_finalize2",
      value: function _finalize2(prev, next, asNucleic) {
        this._innerFinalize(prev, prev, next, this, asNucleic, function (atom) {
          return atom.position;
        });
      }
    }, {
      key: "isConnected",
      value: function isConnected(anotherResidue) {
        if (this._chain !== anotherResidue._chain) {
          return false;
        }

        if (this === anotherResidue) {
          return true;
        }

        var res = false;
        this.forEachAtom(function (atom) {
          var bonds = atom.bonds;

          for (var i = 0, n = bonds.length; i < n; ++i) {
            var bond = bonds[i];

            if (bond._left.residue === anotherResidue || bond._right.residue === anotherResidue) {
              res = true;
              return true;
            }
          }

          return false;
        });
        return res;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var self = this;

        var _this$_atoms = _slicedToArray(this._atoms, 1);

        this._firstAtom = _this$_atoms[0];
        this._lastAtom = this._atoms[this._atoms.length - 1];
        this._leadAtom = null;
        this._wingAtom = null;
        var tempCount = 0;
        var temperature = 0;
        var occupCount = 0;
        var occupancy = 0;
        this.forEachAtom(function (a) {
          if (self._leadAtom === null) {
            if (a.role === Element$a.Constants.Lead) {
              self._leadAtom = a;
            }
          }

          if (self._wingAtom === null) {
            if (a.role === Element$a.Constants.Wing) {
              self._wingAtom = a;
            }
          }

          if (a.temperature) {
            temperature += a.temperature;
            tempCount++;
          }

          if (a.occupancy) {
            occupancy += a.occupancy;
            occupCount++;
          }

          return self._leadAtom !== null && self._wingAtom !== null;
        });

        if (tempCount > 0) {
          this.temperature = temperature / tempCount;
        }

        if (occupCount > 0) {
          this.occupancy = occupancy / occupCount;
        }

        if (this._leadAtom === null || this._wingAtom === null) {
          this._isValid = false;
        }

        if (this._leadAtom === null) {
          this._leadAtom = this._firstAtom;
        }

        if (this._wingAtom === null) {
          this._wingAtom = this._lastAtom;
        }
      }
    }]);

    return Residue;
  }();

  var ResidueType$1 = /*#__PURE__*/function () {
    function ResidueType(name, fullName, letterCode) {
      _classCallCheck(this, ResidueType);

      this._name = name;
      this._fullName = fullName;
      this.letterCode = letterCode;
      this.flags = 0x0000;
    }

    _createClass(ResidueType, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }]);

    return ResidueType;
  }();

  _defineProperty(ResidueType$1, "StandardTypes", {
    ALA: new ResidueType$1('ALA', 'Alanine', 'A'),
    ARG: new ResidueType$1('ARG', 'Arginine', 'R'),
    ASN: new ResidueType$1('ASN', 'Asparagine', 'N'),
    ASP: new ResidueType$1('ASP', 'Aspartic Acid', 'D'),
    CYS: new ResidueType$1('CYS', 'Cysteine', 'C'),
    GLN: new ResidueType$1('GLN', 'Glutamine', 'Q'),
    GLU: new ResidueType$1('GLU', 'Glutamic Acid', 'E'),
    GLY: new ResidueType$1('GLY', 'Glycine', 'G'),
    HIS: new ResidueType$1('HIS', 'Histidine', 'H'),
    ILE: new ResidueType$1('ILE', 'Isoleucine', 'I'),
    LEU: new ResidueType$1('LEU', 'Leucine', 'L'),
    LYS: new ResidueType$1('LYS', 'Lysine', 'K'),
    MET: new ResidueType$1('MET', 'Methionine', 'M'),
    PHE: new ResidueType$1('PHE', 'Phenylalanine', 'F'),
    PRO: new ResidueType$1('PRO', 'Proline', 'P'),
    PYL: new ResidueType$1('PYL', 'Pyrrolysine', 'O'),
    SEC: new ResidueType$1('SEC', 'Selenocysteine', 'U'),
    SER: new ResidueType$1('SER', 'Serine', 'S'),
    THR: new ResidueType$1('THR', 'Threonine', 'T'),
    TRP: new ResidueType$1('TRP', 'Tryptophan', 'W'),
    TYR: new ResidueType$1('TYR', 'Tyrosine', 'Y'),
    VAL: new ResidueType$1('VAL', 'Valine', 'V'),
    A: new ResidueType$1('A', 'Adenine', 'A'),
    C: new ResidueType$1('C', 'Cytosine', 'C'),
    G: new ResidueType$1('G', 'Guanine', 'G'),
    I: new ResidueType$1('I', 'Inosine', 'I'),
    T: new ResidueType$1('T', 'Thymine', 'T'),
    U: new ResidueType$1('U', 'Uracil', 'U'),
    DA: new ResidueType$1('DA', 'Adenine', 'A'),
    DC: new ResidueType$1('DC', 'Cytosine', 'C'),
    DG: new ResidueType$1('DG', 'Guanine', 'G'),
    DI: new ResidueType$1('DI', 'Inosine', 'I'),
    DT: new ResidueType$1('DT', 'Thymine', 'T'),
    DU: new ResidueType$1('DU', 'Uracil', 'U'),
    '+A': new ResidueType$1('+A', 'Adenine', 'A'),
    '+C': new ResidueType$1('+C', 'Cytosine', 'C'),
    '+G': new ResidueType$1('+G', 'Guanine', 'G'),
    '+I': new ResidueType$1('+I', 'Inosine', 'I'),
    '+T': new ResidueType$1('+T', 'Thymine', 'T'),
    '+U': new ResidueType$1('+U', 'Uracil', 'U'),
    WAT: new ResidueType$1('WAT', 'Water', ''),
    H2O: new ResidueType$1('H2O', 'Water', ''),
    HOH: new ResidueType$1('HOH', 'Water', ''),
    DOD: new ResidueType$1('DOD', 'Water', ''),
    UNK: new ResidueType$1('UNK', 'Unknown', ''),
    UNL: new ResidueType$1('UNL', 'Unknown Ligand', '')
  });

  _defineProperty(ResidueType$1, "Flags", {
    PROTEIN: 0x0001,
    BASIC: 0x0002,
    ACIDIC: 0x0004,
    POLAR: 0x0008,
    NONPOLAR: 0x0010,
    AROMATIC: 0x0020,
    NUCLEIC: 0x0100,
    PURINE: 0x0200,
    PYRIMIDINE: 0x0400,
    DNA: 0x0800,
    RNA: 0x1000,
    WATER: 0x10000
  });

  function _addFlag(flag, list) {
    for (var i = 0, n = list.length; i < n; ++i) {
      var res = ResidueType$1.StandardTypes[list[i]];

      if (res) {
        res.flags |= flag;
      }
    }
  }

  var Flags = ResidueType$1.Flags;

  _addFlag(Flags.WATER, ['WAT', 'H2O', 'HOH', 'DOD']);

  _addFlag(Flags.PROTEIN, ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLY', 'GLU', 'GLN', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'PYL', 'SEC', 'SER', 'THR', 'TRP', 'TYR', 'VAL']);

  _addFlag(Flags.BASIC, ['ARG', 'HIS', 'LYS']);

  _addFlag(Flags.ACIDIC, ['ASP', 'GLU']);

  _addFlag(Flags.POLAR, ['ASN', 'CYS', 'GLN', 'SER', 'THR', 'TYR']);

  _addFlag(Flags.NONPOLAR, ['ALA', 'ILE', 'LEU', 'MET', 'PHE', 'PRO', 'TRP', 'VAL', 'GLY']);

  _addFlag(Flags.AROMATIC, ['PHE', 'TRP', 'TYR']);

  _addFlag(Flags.NUCLEIC, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I', 'C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);

  _addFlag(Flags.PURINE, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I']);

  _addFlag(Flags.PYRIMIDINE, ['C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);

  _addFlag(Flags.DNA, ['DA', 'DG', 'DI', 'DC', 'DT', 'DU']);

  _addFlag(Flags.RNA, ['A', 'G', 'I', 'C', 'T', 'U']);

  var hydro = {
    ILE: 4.5,
    VAL: 4.2,
    LEU: 3.8,
    PHE: 2.8,
    CYS: 2.5,
    MET: 1.9,
    ALA: 1.8,
    GLY: -0.4,
    THR: -0.7,
    SER: -0.8,
    TRP: -0.9,
    TYR: -1.3,
    PRO: -1.6,
    HIS: -3.2,
    GLU: -3.5,
    GLN: -3.5,
    ASP: -3.5,
    ASN: -3.5,
    LYS: -3.9,
    ARG: -4.5
  };

  function _addParam(param, list) {
    var keys = Object.keys(list);

    for (var i = 0, n = keys.length; i < n; ++i) {
      var key = keys[i];
      var value = list[key];
      ResidueType$1.StandardTypes[key][param] = value;
    }
  }

  _addParam('hydrophobicity', hydro);

  var ChainType = {
    UNKNOWN: 0,
    PROTEIN: 1,
    NUCLEIC: 2
  };

  var Chain$2 = /*#__PURE__*/function () {
    function Chain(complex, name) {
      _classCallCheck(this, Chain);

      this._complex = complex;
      this._name = name;
      this._mask = 1 | 0;
      this._index = -1;
      this._residues = [];
      this.minSequence = Number.POSITIVE_INFINITY;
      this.maxSequence = Number.NEGATIVE_INFINITY;
    }

    _createClass(Chain, [{
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        return this._residues;
      }
    }, {
      key: "_determineType",
      value: function _determineType() {
        var residues = this._residues;
        var _ResidueType$Flags = ResidueType$1.Flags,
            PROTEIN = _ResidueType$Flags.PROTEIN,
            NUCLEIC = _ResidueType$Flags.NUCLEIC;
        this.type = ChainType.UNKNOWN;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var flags = residues[i]._type.flags;

          if ((flags & NUCLEIC) !== 0) {
            this.type = ChainType.NUCLEIC;
            break;
          } else if ((flags & PROTEIN) !== 0) {
            this.type = ChainType.PROTEIN;
            break;
          }
        }
      }
    }, {
      key: "findResidue",
      value: function findResidue(seqNum, iCode) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var res = residues[i];

          if (res._sequence === seqNum && res._icode === iCode) {
            return [res, i];
          }
        }

        return null;
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        this._determineType();

        var residues = this._residues;
        var prev = null;

        for (var i = 0, n = residues.length; i < n; ++i) {
          var next = i + 1 < n ? residues[i + 1] : null;
          var curr = residues[i];

          {
            curr._finalize2(prev, next, this.type === ChainType.NUCLEIC);

            prev = curr;
          }
        }

        if (residues.length > 1 && residues[1]._wingVector) {
          var p = residues[1]._wingVector;
          residues[0]._wingVector = new THREE__namespace.Vector3(p.x, p.y, p.z);
        } else if (residues.length > 0) {
          residues[0]._wingVector = new THREE__namespace.Vector3(1, 0, 0);
        }
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var residues = this._residues;
        var prev = null;
        var prevData = null;
        var frameRes = frameData._residues;
        var n = residues.length;

        function getAtomPos(atom) {
          return frameData.getAtomPos(atom.index);
        }

        for (var i = 0; i < n; ++i) {
          var curr = residues[i];
          var currData = frameRes[curr._index];
          var nextRes = i + 1 < n ? residues[i + 1] : null;

          curr._innerFinalize(prev, prevData, nextRes, currData, this.type === ChainType.NUCLEIC, getAtomPos);

          prev = curr;
          prevData = currData;
        }

        frameRes[residues[0]._index]._wingVector = n > 1 ? frameRes[residues[1]._index]._wingVector : new THREE__namespace.Vector3(1, 0, 0);
      }
    }, {
      key: "addResidue",
      value: function addResidue(name, sequence, iCode) {
        var type = this._complex.getResidueType(name);

        if (type === null) {
          type = this._complex.addResidueType(name);
        }

        var residue = new Residue$1(this, type, sequence, iCode);

        this._complex.addResidue(residue);

        this._residues.push(residue);

        if (type.flags & (ResidueType$1.Flags.NUCLEIC | ResidueType$1.Flags.PROTEIN)) {
          if (this.maxSequence < sequence) {
            this.maxSequence = sequence;
          }

          if (this.minSequence > sequence) {
            this.minSequence = sequence;
          }
        }

        return residue;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residues.length;
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          mask &= residues[i]._mask;
        }

        this._mask = mask;
      }
    }]);

    return Chain;
  }();

  var _StructuralElement$ge;

  var StructuralElement = /*#__PURE__*/function () {
    function StructuralElement(type, init, term) {
      _classCallCheck(this, StructuralElement);

      this.type = type;
      this.generic = StructuralElement.genericByType[this.type] || 'loop';
      this.init = init;
      this.term = term;
    }

    _createClass(StructuralElement, [{
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        if (this.init instanceof Residue$1 && this.term instanceof Residue$1) {
          return;
        }

        var start = complex.splitUnifiedSerial(this.init);
        var end = complex.splitUnifiedSerial(this.term);

        for (var chainId = start.chain; chainId <= end.chain; chainId++) {
          for (var serialId = start.serial; serialId <= end.serial; serialId++) {
            for (var iCode = start.iCode; iCode <= end.iCode; iCode++) {
              var hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);

              if (residueHash[hashCode]) {
                residueHash[hashCode]._secondary = this;
              }
            }
          }
        }

        this.init = residueHash[this.init];
        this.term = residueHash[this.term];
      }
    }]);

    return StructuralElement;
  }();

  StructuralElement.Type = {
    STRAND: 'E',
    BRIDGE: 'B',
    HELIX_310: 'G',
    HELIX_ALPHA: 'H',
    HELIX_PI: 'I',
    HELIX: 'X',
    TURN_310: '3',
    TURN_ALPHA: '4',
    TURN_PI: '5',
    TURN: 'T',
    BEND: 'S',
    COIL: 'C'
  };
  StructuralElement.Generic = {
    STRAND: 'strand',
    HELIX: 'helix',
    LOOP: 'loop'
  };
  var StructuralElementType$5 = StructuralElement.Type;
  var StructuralElementGeneric = StructuralElement.Generic;
  StructuralElement.genericByType = (_StructuralElement$ge = {}, _defineProperty(_StructuralElement$ge, StructuralElementType$5.STRAND, StructuralElementGeneric.STRAND), _defineProperty(_StructuralElement$ge, StructuralElementType$5.HELIX_310, StructuralElementGeneric.HELIX), _defineProperty(_StructuralElement$ge, StructuralElementType$5.HELIX_ALPHA, StructuralElementGeneric.HELIX), _defineProperty(_StructuralElement$ge, StructuralElementType$5.HELIX_PI, StructuralElementGeneric.HELIX), _defineProperty(_StructuralElement$ge, StructuralElementType$5.HELIX, StructuralElementGeneric.HELIX), _StructuralElement$ge);

  function _createSuper$1$(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1$(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1$() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var StructuralElementType$4 = StructuralElement.Type;
  var typeByPDBHelixClass = {
    1: StructuralElementType$4.HELIX_ALPHA,
    3: StructuralElementType$4.HELIX_PI,
    5: StructuralElementType$4.HELIX_310
  };

  var Helix$3 = /*#__PURE__*/function (_StructuralElement) {
    _inherits(Helix, _StructuralElement);

    var _super = _createSuper$1$(Helix);

    function Helix(helixClass, init, term, serial, name, comment, length) {
      var _this;

      _classCallCheck(this, Helix);

      _this = _super.call(this, typeByPDBHelixClass[helixClass] || StructuralElement.Type.HELIX, init, term);
      _this.serial = serial;
      _this.name = name;
      _this.comment = comment;
      _this.length = length;
      return _this;
    }

    return Helix;
  }(StructuralElement);

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _createSuper$1_(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1_(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1_() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Strand$3 = /*#__PURE__*/function (_StructuralElement) {
    _inherits(Strand, _StructuralElement);

    var _super = _createSuper$1_(Strand);

    function Strand(sheet, init, term, sense, atomCur, atomPrev) {
      var _this;

      _classCallCheck(this, Strand);

      _this = _super.call(this, StructuralElement.Type.STRAND, init, term);
      _this.sheet = sheet;
      _this.sense = sense;
      _this.atomCur = atomCur;
      _this.atomPrev = atomPrev;
      return _this;
    }

    _createClass(Strand, [{
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        _get(_getPrototypeOf(Strand.prototype), "_finalize", this).call(this, serialAtomMap, residueHash, complex);

        var as = this.atomCur;

        if (as !== null && !Number.isNaN(as)) {
          this.atomCur = serialAtomMap[as];
        }

        as = this.atomPrev;

        if (as !== null && !Number.isNaN(as)) {
          this.atomPrev = serialAtomMap[as];
        }
      }
    }]);

    return Strand;
  }(StructuralElement);

  var Sheet$3 = /*#__PURE__*/function () {
    function Sheet(name, width) {
      _classCallCheck(this, Sheet);

      this._name = name;
      this._width = width;
      this._strands = [];
    }

    _createClass(Sheet, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getWidth",
      value: function getWidth() {
        return this._width;
      }
    }, {
      key: "addStrand",
      value: function addStrand(strand) {
        this._strands.push(strand);

        this._width = this._strands.length;
      }
    }, {
      key: "addEmptyStrand",
      value: function addEmptyStrand() {
        this._strands.push(new Strand$3(null, null, null, null, null, null));
      }
    }, {
      key: "_finalize",
      value: function _finalize(serialAtomMap, residueHash, complex) {
        var s = this._strands;

        for (var i = 0, n = s.length; i < n; ++i) {
          s[i]._finalize(serialAtomMap, residueHash, complex);
        }

        if (!this._width) {
          this._width = s.length;
        }

        if (s.length !== this._width) {
          throw new Error("Sheet ".concat(this._name, " is inconsistent."));
        }
      }
    }]);

    return Sheet;
  }();

  var SGroup$1 = /*#__PURE__*/function () {
    function SGroup(id, name, position, atoms, saveNode) {
      _classCallCheck(this, SGroup);

      this._id = id;
      this._name = name;
      this._position = position || new THREE__namespace.Vector3();
      this._atoms = atoms || [];
      this._charge = 0;
      this._repeat = 1;
      this._center = null;
      this.xmlNodeRef = saveNode || null;
    }

    _createClass(SGroup, [{
      key: "getName",
      value: function getName() {
        return this._name;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return this._position;
      }
    }, {
      key: "getCentralPoint",
      value: function getCentralPoint() {
        return this._center;
      }
    }, {
      key: "_rebuildSGroupOnAtomChange",
      value: function _rebuildSGroupOnAtomChange() {
        var nLimon = 100000000;

        if (this._center === null) {
          return;
        }

        var bLow = new THREE__namespace.Vector3(nLimon, nLimon, nLimon);
        var bHight = new THREE__namespace.Vector3(-nLimon, -nLimon, -nLimon);

        for (var j = 0, n = this._atoms.length; j < n; j++) {
          var aPos = this._atoms[j].position;
          bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
          bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
        }

        this._center.addVectors(bLow, bHight);

        this._center.multiplyScalar(0.5);
      }
    }]);

    return SGroup;
  }();

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var parser$1 = function () {
    var o = function o(k, v, _o, l) {
      for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {
      }

      return _o;
    },
        $V0 = [1, 4],
        $V1 = [1, 5],
        $V2 = [1, 6],
        $V3 = [1, 7],
        $V4 = [1, 8],
        $V5 = [1, 9],
        $V6 = [1, 11],
        $V7 = [1, 12],
        $V8 = [5, 7, 8, 11],
        $V9 = [1, 17],
        $Va = [1, 22],
        $Vb = [1, 20],
        $Vc = [1, 21],
        $Vd = [5, 7, 8, 11, 19];

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        error: 2,
        Program: 3,
        Expression: 4,
        EOF: 5,
        Selector: 6,
        OR: 7,
        AND: 8,
        NOT: 9,
        '(': 10,
        ')': 11,
        SELECTOR: 12,
        NAMED_SELECTOR: 13,
        SELECTOR_RANGED: 14,
        RangeList: 15,
        SELECTOR_NAMED: 16,
        NameList: 17,
        Range: 18,
        ',': 19,
        NUMBER: 20,
        ':': 21,
        Name: 22,
        IDENTIFIER: 23,
        STRING: 24,
        $accept: 0,
        $end: 1
      },
      terminals_: {
        2: 'error',
        5: 'EOF',
        7: 'OR',
        8: 'AND',
        9: 'NOT',
        10: '(',
        11: ')',
        12: 'SELECTOR',
        13: 'NAMED_SELECTOR',
        14: 'SELECTOR_RANGED',
        16: 'SELECTOR_NAMED',
        19: ',',
        20: 'NUMBER',
        21: ':',
        23: 'IDENTIFIER',
        24: 'STRING'
      },
      productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
        var $0 = $$.length - 1;

        switch (yystate) {
          case 1:
            return $$[$0 - 1];

          case 3:
            this.$ = yy.keyword('or')($$[$0 - 2], $$[$0]);
            break;

          case 4:
            this.$ = yy.keyword('and')($$[$0 - 2], $$[$0]);
            break;

          case 5:
            this.$ = yy.keyword('not')($$[$0]);
            break;

          case 6:
            this.$ = $$[$0 - 1];
            break;

          case 7:
            this.$ = yy.keyword($$[$0])();
            break;

          case 8:
            this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
            break;

          case 9:
          case 10:
            this.$ = yy.keyword($$[$0 - 1])($$[$0]);
            break;

          case 11:
            this.$ = new yy.RangeList($$[$0]);
            break;

          case 12:
          case 16:
            this.$ = $$[$0 - 2].append($$[$0]);
            break;

          case 13:
            this.$ = new yy.Range(Number($$[$0]));
            break;

          case 14:
            this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
            break;

          case 15:
            this.$ = new yy.ValueList($$[$0]);
            break;
        }
      },
      table: [{
        3: 1,
        4: 2,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        1: [3]
      }, {
        5: [1, 10],
        7: $V6,
        8: $V7
      }, o($V8, [2, 2]), {
        4: 13,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        4: 14,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, o($V8, [2, 7]), o($V8, [2, 8]), {
        15: 15,
        18: 16,
        20: $V9
      }, {
        17: 18,
        20: $Va,
        22: 19,
        23: $Vb,
        24: $Vc
      }, {
        1: [2, 1]
      }, {
        4: 23,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, {
        4: 24,
        6: 3,
        9: $V0,
        10: $V1,
        12: $V2,
        13: $V3,
        14: $V4,
        16: $V5
      }, o($V8, [2, 5]), {
        7: $V6,
        8: $V7,
        11: [1, 25]
      }, o($V8, [2, 9], {
        19: [1, 26]
      }), o($Vd, [2, 11]), o($Vd, [2, 13], {
        21: [1, 27]
      }), o($V8, [2, 10], {
        19: [1, 28]
      }), o($Vd, [2, 15]), o($Vd, [2, 17]), o($Vd, [2, 18]), o($Vd, [2, 19]), o([5, 7, 11], [2, 3], {
        8: $V7
      }), o($V8, [2, 4]), o($V8, [2, 6]), {
        18: 29,
        20: $V9
      }, {
        20: [1, 30]
      }, {
        20: $Va,
        22: 31,
        23: $Vb,
        24: $Vc
      }, o($Vd, [2, 12]), o($Vd, [2, 14]), o($Vd, [2, 16])],
      defaultActions: {
        10: [2, 1]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error;
        }
      },
      parse: function parse(input) {
        var self = this,
            stack = [0],
            tstack = [],
            vstack = [null],
            lstack = [],
            table = this.table,
            yytext = '',
            yylineno = 0,
            yyleng = 0,
            TERROR = 2,
            EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = {
          yy: {}
        };

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }

        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }

        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }

        function lex() {
          var token;
          token = tstack.pop() || lexer.lex() || EOF;

          if (typeof token !== 'number') {
            if (token instanceof Array) {
              tstack = token;
              token = tstack.pop();
            }

            token = self.symbols_[token] || token;
          }

          return token;
        }

        var symbol,
            state,
            action,
            r,
            yyval = {},
            p,
            len,
            newState,
            expected;

        while (true) {
          state = stack[stack.length - 1];

          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }

            action = table[state] && table[state][symbol];
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }

            if (lexer.showPosition) {
              errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ", got '" + (this.terminals_[symbol] || symbol) + "'";
            } else {
              errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : "'" + (this.terminals_[symbol] || symbol) + "'");
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;

              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }

              break;

            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };

              if (ranges) {
                yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }

              r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));

              if (typeof r !== 'undefined') {
                return r;
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }

              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;

            case 3:
              return true;
          }
        }

        return true;
      }
    };

    var lexer = function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str);
          }
        },
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };

          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }

          this.offset = 0;
          return this;
        },
        input: function input() {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }

          this._input = this._input.slice(1);
          return ch;
        },
        unput: function unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }

          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          };

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }

          this.yyleng = this.yytext.length;
          return this;
        },
        more: function more() {
          this._more = true;
          return this;
        },
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
              text: '',
              token: null,
              line: this.yylineno
            });
          }

          return this;
        },
        less: function less(n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '');
        },
        upcomingInput: function upcomingInput() {
          var next = this.match;

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, '');
        },
        showPosition: function showPosition() {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join('-');
          return pre + this.upcomingInput() + '\n' + c + '^';
        },
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup;

          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g);

          if (lines) {
            this.yylineno += lines.length;
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
          }

          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);

          if (this.done && this._input) {
            this.done = false;
          }

          if (token) {
            return token;
          } else if (this._backtrack) {
            for (var k in backup) {
              this[k] = backup[k];
            }

            return false;
          }

          return false;
        },
        next: function next() {
          if (this.done) {
            return this.EOF;
          }

          if (!this._input) {
            this.done = true;
          }

          var token, match, tempMatch, index;

          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }

          var rules = this._currentRules();

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);

            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);

                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = false;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index]);

            if (token !== false) {
              return token;
            }

            return false;
          }

          if (this._input === '') {
            return this.EOF;
          } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
              text: '',
              token: null,
              line: this.yylineno
            });
          }
        },
        lex: function lex() {
          var r = this.next();

          if (r) {
            return r;
          } else {
            return this.lex();
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;

          if (n > 0) {
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        _currentRules: function _currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          } else {
            return this.conditions['INITIAL'].rules;
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);

          if (n >= 0) {
            return this.conditionStack[n];
          } else {
            return 'INITIAL';
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {
          'case-insensitive': true
        },
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

          switch ($avoiding_name_collisions) {
            case 0:
              break;

            case 1:
              return 20;

            case 2:
              return 7;

            case 3:
              return 8;

            case 4:
              return 9;

            case 5:
              return 12;

            case 6:
              return 16;

            case 7:
              return 14;

            case 8:
              return 10;

            case 9:
              return 11;

            case 10:
              return 19;

            case 11:
              return 21;

            case 12:
              return '<=';

            case 13:
              return '>=';

            case 14:
              return '<';

            case 15:
              return '>';

            case 16:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
              return 24;

            case 17:
              return 13;

            case 18:
              return 23;

            case 19:
              return 5;

            case 20:
              return 'INVALID';
          }
        },
        rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
        conditions: {
          INITIAL: {
            rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
            inclusive: true
          }
        }
      };
      return lexer;
    }();

    parser.lexer = lexer;

    function Parser() {
      this.yy = {};
    }

    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser();
  }();

  var SelectionParser = {
    parser: parser$1
  };

  function _createSuper$1Z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Z(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Range = /*#__PURE__*/function () {
    function Range(min, max) {
      _classCallCheck(this, Range);

      this.min = min;
      this.max = typeof max === 'undefined' ? min : max;
    }

    _createClass(Range, [{
      key: "includes",
      value: function includes(value) {
        return this.min <= value && value <= this.max;
      }
    }, {
      key: "toString",
      value: function toString() {
        var min = this.min,
            max = this.max;
        return min === max ? String(min) : [min, max].join(':');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.min, this.max];
      }
    }]);

    return Range;
  }();

  var List = /*#__PURE__*/function () {
    function List(arg) {
      _classCallCheck(this, List);

      if (arg instanceof this.constructor) {
        return arg;
      }

      if (arg instanceof Array) {
        this._values = arg.slice(0);
      } else if (arg) {
        this._values = [arg];
      } else {
        this._values = [];
      }
    }

    _createClass(List, [{
      key: "append",
      value: function append(value) {
        var values = this._values;
        values[values.length] = value;
        return this;
      }
    }, {
      key: "remove",
      value: function remove(value) {
        var values = this._values;
        var index = values.indexOf(value);

        if (index >= 0) {
          values.splice(index, 1);
        }

        return this;
      }
    }, {
      key: "toString",
      value: function toString() {
        return this._values.join(',');
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var values = this._values;
        var result = [];

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i];
          result[i] = value.toJSON ? value.toJSON() : value;
        }

        return result;
      }
    }]);

    return List;
  }();

  var RangeList = /*#__PURE__*/function (_List) {
    _inherits(RangeList, _List);

    var _super = _createSuper$1Z(RangeList);

    function RangeList() {
      _classCallCheck(this, RangeList);

      return _super.apply(this, arguments);
    }

    _createClass(RangeList, [{
      key: "includes",
      value: function includes(value) {
        var list = this._values;

        for (var i = 0, n = list.length; i < n; ++i) {
          if (list[i].includes(value)) {
            return true;
          }
        }

        return false;
      }
    }]);

    return RangeList;
  }(List);

  var valuesArray = [];

  var ValueList = /*#__PURE__*/function (_List2) {
    _inherits(ValueList, _List2);

    var _super2 = _createSuper$1Z(ValueList);

    function ValueList(arg, upperOnly) {
      var _this;

      _classCallCheck(this, ValueList);

      var list = _this = _super2.call(this, arg);

      if (upperOnly) {
        _this.upperOnly = true;
        var values = list._values;

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i];

          if (typeof value === 'string') {
            values[i] = value.toUpperCase();
          }
        }
      } else {
        _this.upperOnly = false;
      }

      return _possibleConstructorReturn(_this, list);
    }

    _createClass(ValueList, [{
      key: "includes",
      value: function includes(value) {
        return this._values.indexOf(value) !== -1;
      }
    }, {
      key: "toString",
      value: function toString() {
        var values = this._values;
        valuesArray.length = 0;

        for (var i = 0, n = values.length; i < n; ++i) {
          valuesArray[i] = utils.correctSelectorIdentifier(String(values[i]));
        }

        return valuesArray.join(',');
      }
    }, {
      key: "_validate",
      value: function _validate(value) {
        return this.upperOnly && typeof value === 'string' ? value.toUpperCase() : value;
      }
    }, {
      key: "append",
      value: function append(value) {
        _get(_getPrototypeOf(ValueList.prototype), "append", this).call(this, this._validate(value));

        return this;
      }
    }, {
      key: "remove",
      value: function remove(value) {
        _get(_getPrototypeOf(ValueList.prototype), "remove", this).call(this, this._validate(value));

        return this;
      }
    }]);

    return ValueList;
  }(List);

  function _createSuper$1Y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Y(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Selector = /*#__PURE__*/function () {
    function Selector() {
      _classCallCheck(this, Selector);
    }

    _createClass(Selector, [{
      key: "toString",
      value: function toString() {
        return this.keyword;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name];
      }
    }]);

    return Selector;
  }();

  Selector.prototype.name = 'Error';
  Selector.prototype.keyword = 'error';

  var ListSelector = /*#__PURE__*/function (_Selector) {
    _inherits(ListSelector, _Selector);

    var _super = _createSuper$1Y(ListSelector);

    function ListSelector(list) {
      var _this;

      _classCallCheck(this, ListSelector);

      _this = _super.call(this);
      _this.list = list;
      return _this;
    }

    _createClass(ListSelector, [{
      key: "toString",
      value: function toString() {
        return "".concat(this.keyword, " ").concat(this.list);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.list.toJSON()];
      }
    }]);

    return ListSelector;
  }(Selector);

  var RangeListSelector = /*#__PURE__*/function (_ListSelector) {
    _inherits(RangeListSelector, _ListSelector);

    var _super2 = _createSuper$1Y(RangeListSelector);

    function RangeListSelector(arg) {
      _classCallCheck(this, RangeListSelector);

      return _super2.call(this, new RangeList(arg));
    }

    return RangeListSelector;
  }(ListSelector);

  var ValueListSelector = /*#__PURE__*/function (_ListSelector2) {
    _inherits(ValueListSelector, _ListSelector2);

    var _super3 = _createSuper$1Y(ValueListSelector);

    function ValueListSelector(arg, caseSensitive) {
      _classCallCheck(this, ValueListSelector);

      return _super3.call(this, new ValueList(arg, !caseSensitive));
    }

    return ValueListSelector;
  }(ListSelector);

  var NoneSelector = /*#__PURE__*/function (_Selector2) {
    _inherits(NoneSelector, _Selector2);

    var _super4 = _createSuper$1Y(NoneSelector);

    function NoneSelector() {
      _classCallCheck(this, NoneSelector);

      return _super4.apply(this, arguments);
    }

    _createClass(NoneSelector, [{
      key: "includesAtom",
      value: function includesAtom(_atom) {
        return false;
      }
    }]);

    return NoneSelector;
  }(Selector);

  NoneSelector.prototype.name = 'None';
  NoneSelector.prototype.keyword = 'none';

  var AllSelector = /*#__PURE__*/function (_Selector3) {
    _inherits(AllSelector, _Selector3);

    var _super5 = _createSuper$1Y(AllSelector);

    function AllSelector() {
      _classCallCheck(this, AllSelector);

      return _super5.apply(this, arguments);
    }

    _createClass(AllSelector, [{
      key: "includesAtom",
      value: function includesAtom(_atom) {
        return true;
      }
    }]);

    return AllSelector;
  }(Selector);

  AllSelector.prototype.name = 'All';
  AllSelector.prototype.keyword = 'all';

  function _createSuper$1X(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1X(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1X() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var none = new NoneSelector();

  var PrefixOperator = /*#__PURE__*/function (_Selector) {
    _inherits(PrefixOperator, _Selector);

    var _super = _createSuper$1X(PrefixOperator);

    function PrefixOperator(rhs) {
      var _this;

      _classCallCheck(this, PrefixOperator);

      _this = _super.call(this);
      _this.rhs = rhs || none;
      return _this;
    }

    _createClass(PrefixOperator, [{
      key: "toString",
      value: function toString() {
        var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
        return "".concat(this.keyword, " ").concat(rhs);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.rhs.toJSON()];
      }
    }]);

    return PrefixOperator;
  }(Selector);

  PrefixOperator.prototype.priority = 1;

  var InfixOperator = /*#__PURE__*/function (_Selector2) {
    _inherits(InfixOperator, _Selector2);

    var _super2 = _createSuper$1X(InfixOperator);

    function InfixOperator(lhs, rhs) {
      var _this2;

      _classCallCheck(this, InfixOperator);

      _this2 = _super2.call(this);
      _this2.lhs = lhs || none;
      _this2.rhs = rhs || none;
      return _this2;
    }

    _createClass(InfixOperator, [{
      key: "toString",
      value: function toString() {
        var lhs = this.lhs.priority && this.lhs.priority > this.priority ? "(".concat(this.lhs, ")") : this.lhs;
        var rhs = this.rhs.priority && this.rhs.priority > this.priority ? "(".concat(this.rhs, ")") : this.rhs;
        return "".concat(lhs, " ").concat(this.keyword, " ").concat(rhs);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
      }
    }]);

    return InfixOperator;
  }(Selector);

  InfixOperator.prototype.priority = 1000;

  function _createSuper$1W(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1W(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1W() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var keywords = {};

  function defineSelector(name, SelectorClass) {
    var keyword = name.toLowerCase();
    SelectorClass.prototype.keyword = keyword;
    SelectorClass.prototype.name = name;

    var factory = function factory() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _construct(SelectorClass, args);
    };

    factory.SelectorClass = SelectorClass;
    keywords[keyword] = factory;
    return SelectorClass;
  }

  defineSelector('Serial', /*#__PURE__*/function (_RangeListSelector) {
    _inherits(SerialSelector, _RangeListSelector);

    var _super = _createSuper$1W(SerialSelector);

    function SerialSelector() {
      _classCallCheck(this, SerialSelector);

      return _super.apply(this, arguments);
    }

    _createClass(SerialSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.serial);
      }
    }]);

    return SerialSelector;
  }(RangeListSelector));
  defineSelector('Name', /*#__PURE__*/function (_ValueListSelector) {
    _inherits(NameSelector, _ValueListSelector);

    var _super2 = _createSuper$1W(NameSelector);

    function NameSelector() {
      _classCallCheck(this, NameSelector);

      return _super2.apply(this, arguments);
    }

    _createClass(NameSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.name);
      }
    }]);

    return NameSelector;
  }(ValueListSelector));
  defineSelector('AltLoc', /*#__PURE__*/function (_ValueListSelector2) {
    _inherits(AltLocSelector, _ValueListSelector2);

    var _super3 = _createSuper$1W(AltLocSelector);

    function AltLocSelector() {
      _classCallCheck(this, AltLocSelector);

      return _super3.apply(this, arguments);
    }

    _createClass(AltLocSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(String.fromCharCode(atom.location));
      }
    }]);

    return AltLocSelector;
  }(ValueListSelector));
  defineSelector('Elem', /*#__PURE__*/function (_ValueListSelector3) {
    _inherits(ElemSelector, _ValueListSelector3);

    var _super4 = _createSuper$1W(ElemSelector);

    function ElemSelector() {
      _classCallCheck(this, ElemSelector);

      return _super4.apply(this, arguments);
    }

    _createClass(ElemSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.element.name);
      }
    }]);

    return ElemSelector;
  }(ValueListSelector));
  defineSelector('Residue', /*#__PURE__*/function (_ValueListSelector4) {
    _inherits(ResidueSelector, _ValueListSelector4);

    var _super5 = _createSuper$1W(ResidueSelector);

    function ResidueSelector() {
      _classCallCheck(this, ResidueSelector);

      return _super5.apply(this, arguments);
    }

    _createClass(ResidueSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._type._name);
      }
    }]);

    return ResidueSelector;
  }(ValueListSelector));
  defineSelector('Sequence', /*#__PURE__*/function (_RangeListSelector2) {
    _inherits(SequenceSelector, _RangeListSelector2);

    var _super6 = _createSuper$1W(SequenceSelector);

    function SequenceSelector() {
      _classCallCheck(this, SequenceSelector);

      return _super6.apply(this, arguments);
    }

    _createClass(SequenceSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._sequence);
      }
    }]);

    return SequenceSelector;
  }(RangeListSelector));
  defineSelector('ICode', /*#__PURE__*/function (_ValueListSelector5) {
    _inherits(ICodeSelector, _ValueListSelector5);

    var _super7 = _createSuper$1W(ICodeSelector);

    function ICodeSelector(arg) {
      _classCallCheck(this, ICodeSelector);

      return _super7.call(this, arg, true);
    }

    _createClass(ICodeSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._icode);
      }
    }]);

    return ICodeSelector;
  }(ValueListSelector));
  defineSelector('ResIdx', /*#__PURE__*/function (_RangeListSelector3) {
    _inherits(ResIdxSelector, _RangeListSelector3);

    var _super8 = _createSuper$1W(ResIdxSelector);

    function ResIdxSelector() {
      _classCallCheck(this, ResIdxSelector);

      return _super8.apply(this, arguments);
    }

    _createClass(ResIdxSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._index);
      }
    }]);

    return ResIdxSelector;
  }(RangeListSelector));
  defineSelector('Chain', /*#__PURE__*/function (_ValueListSelector6) {
    _inherits(ChainSelector, _ValueListSelector6);

    var _super9 = _createSuper$1W(ChainSelector);

    function ChainSelector(arg) {
      _classCallCheck(this, ChainSelector);

      return _super9.call(this, arg, true);
    }

    _createClass(ChainSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.list.includes(atom.residue._chain._name);
      }
    }]);

    return ChainSelector;
  }(ValueListSelector));
  defineSelector('Hetatm', /*#__PURE__*/function (_Selector) {
    _inherits(HetatmSelector, _Selector);

    var _super10 = _createSuper$1W(HetatmSelector);

    function HetatmSelector() {
      _classCallCheck(this, HetatmSelector);

      return _super10.apply(this, arguments);
    }

    _createClass(HetatmSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return atom.het;
      }
    }]);

    return HetatmSelector;
  }(Selector));
  defineSelector('PolarH', /*#__PURE__*/function (_Selector2) {
    _inherits(PolarHSelector, _Selector2);

    var _super11 = _createSuper$1W(PolarHSelector);

    function PolarHSelector() {
      _classCallCheck(this, PolarHSelector);

      return _super11.apply(this, arguments);
    }

    _createClass(PolarHSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.flags & Atom$2.Flags.NONPOLARH) === Atom$2.Flags.HYDROGEN;
      }
    }]);

    return PolarHSelector;
  }(Selector));
  defineSelector('NonPolarH', /*#__PURE__*/function (_Selector3) {
    _inherits(NonPolarHSelector, _Selector3);

    var _super12 = _createSuper$1W(NonPolarHSelector);

    function NonPolarHSelector() {
      _classCallCheck(this, NonPolarHSelector);

      return _super12.apply(this, arguments);
    }

    _createClass(NonPolarHSelector, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return (atom.flags & Atom$2.Flags.NONPOLARH) === Atom$2.Flags.NONPOLARH;
      }
    }]);

    return NonPolarHSelector;
  }(Selector));
  defineSelector('All', AllSelector);
  defineSelector('None', NoneSelector);
  var NULL_SELECTOR = keywords.none();

  function defineOperator(name, priority, OperatorClass) {
    OperatorClass.prototype.priority = priority;
    return defineSelector(name, OperatorClass);
  }

  defineOperator('Not', 1, /*#__PURE__*/function (_PrefixOperator) {
    _inherits(NotOperator, _PrefixOperator);

    var _super13 = _createSuper$1W(NotOperator);

    function NotOperator() {
      _classCallCheck(this, NotOperator);

      return _super13.apply(this, arguments);
    }

    _createClass(NotOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return !this.rhs.includesAtom(atom);
      }
    }]);

    return NotOperator;
  }(PrefixOperator));
  defineOperator('And', 2, /*#__PURE__*/function (_InfixOperator) {
    _inherits(AndOperator, _InfixOperator);

    var _super14 = _createSuper$1W(AndOperator);

    function AndOperator() {
      _classCallCheck(this, AndOperator);

      return _super14.apply(this, arguments);
    }

    _createClass(AndOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
      }
    }]);

    return AndOperator;
  }(InfixOperator));
  defineOperator('Or', 3, /*#__PURE__*/function (_InfixOperator2) {
    _inherits(OrOperator, _InfixOperator2);

    var _super15 = _createSuper$1W(OrOperator);

    function OrOperator() {
      _classCallCheck(this, OrOperator);

      return _super15.apply(this, arguments);
    }

    _createClass(OrOperator, [{
      key: "includesAtom",
      value: function includesAtom(atom) {
        return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
      }
    }]);

    return OrOperator;
  }(InfixOperator));

  function byResidueTypeFlag(flag, name) {
    return defineSelector(name, /*#__PURE__*/function (_Selector4) {
      _inherits(_class, _Selector4);

      var _super16 = _createSuper$1W(_class);

      function _class() {
        _classCallCheck(this, _class);

        return _super16.apply(this, arguments);
      }

      _createClass(_class, [{
        key: "includesAtom",
        value: function includesAtom(atom) {
          return (atom.residue._type.flags & flag) !== 0;
        }
      }]);

      return _class;
    }(Selector));
  }

  byResidueTypeFlag(ResidueType$1.Flags.PROTEIN, 'Protein');
  byResidueTypeFlag(ResidueType$1.Flags.BASIC, 'Basic');
  byResidueTypeFlag(ResidueType$1.Flags.ACIDIC, 'Acidic');
  byResidueTypeFlag(ResidueType$1.Flags.BASIC | ResidueType$1.Flags.ACIDIC, 'Charged');
  byResidueTypeFlag(ResidueType$1.Flags.POLAR, 'Polar');
  byResidueTypeFlag(ResidueType$1.Flags.NONPOLAR, 'NonPolar');
  byResidueTypeFlag(ResidueType$1.Flags.AROMATIC, 'Aromatic');
  byResidueTypeFlag(ResidueType$1.Flags.NUCLEIC, 'Nucleic');
  byResidueTypeFlag(ResidueType$1.Flags.PURINE, 'Purine');
  byResidueTypeFlag(ResidueType$1.Flags.PYRIMIDINE, 'Pyrimidine');
  byResidueTypeFlag(ResidueType$1.Flags.WATER, 'Water');
  var selectors$5 = Object.create(keywords);
  selectors$5.Selector = Selector;
  selectors$5.RangeListSelector = RangeListSelector;
  selectors$5.ValueListSelector = ValueListSelector;
  selectors$5.Range = Range;
  selectors$5.RangeList = RangeList;
  selectors$5.ValueList = ValueList;
  selectors$5.PrefixOperator = PrefixOperator;
  selectors$5.InfixOperator = InfixOperator;
  selectors$5.Context = Object.create({});

  selectors$5.GetSelector = function (key) {
    if (!selectors$5.Context.hasOwnProperty(key)) {
      var exc = {
        message: "selector ".concat(key, " is not registered")
      };
      throw exc;
    }

    return selectors$5.Context[key] || NULL_SELECTOR;
  };

  selectors$5.ClearContext = function () {
    Object.keys(selectors$5.Context).forEach(function (k) {
      delete selectors$5.Context[k];
    });
  };

  selectors$5.keyword = function (key) {
    return keywords[key.toLowerCase()] || keywords.none;
  };

  selectors$5.parse = function (str) {
    var res = {};

    try {
      res.selector = SelectionParser.parser.parse(str);
    } catch (e) {
      res.selector = NULL_SELECTOR;
      res.error = e.message;
    }

    return res;
  };

  SelectionParser.parser.yy = selectors$5;
  SelectionParser.parser.yy.parseError = SelectionParser.parser.parseError;

  var BiologicalUnit = /*#__PURE__*/function () {
    function BiologicalUnit(complex) {
      _classCallCheck(this, BiologicalUnit);

      this._complex = complex;
      this._selector = selectors$5.keyword('All')();
      this._boundaries = {
        boundingBox: new THREE__namespace.Box3(),
        boundingSphere: new THREE__namespace.Sphere()
      };
    }

    _createClass(BiologicalUnit, [{
      key: "computeBoundaries",
      value: function computeBoundaries() {
        var atoms = this._complex._atoms;
        var n = atoms.length;
        var selector = this._selector;
        var boundingBox = this._boundaries.boundingBox;
        boundingBox.makeEmpty();

        if (n === 1) {
          boundingBox.expandByPoint(atoms[0].position);
          var bbc = new THREE__namespace.Vector3();
          boundingBox.getCenter(bbc);
          var s = 2 * atoms[0].element.radius;
          boundingBox.setFromCenterAndSize(bbc, new THREE__namespace.Vector3(s, s, s));
        } else {
          for (var i = 0; i < n; ++i) {
            if (selector.includesAtom(atoms[i])) {
              boundingBox.expandByPoint(atoms[i].position);
            }
          }
        }

        var radiusSquared = 0.0;
        var center = new THREE__namespace.Vector3();
        boundingBox.getCenter(center);

        if (n === 1) {
          this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
        } else {
          for (var _i = 0; _i < n; ++_i) {
            if (!selector.includesAtom(atoms[_i])) {
              continue;
            }

            var pos = atoms[_i].position;
            var lengthSquared = center.distanceToSquared(pos);

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared;
            }
          }

          this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
        }
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return [];
      }
    }, {
      key: "getSelector",
      value: function getSelector() {
        return this._selector;
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return this._boundaries;
      }
    }, {
      key: "finalize",
      value: function finalize() {}
    }]);

    return BiologicalUnit;
  }();

  function _createSuper$1V(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1V(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1V() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Assembly$3 = /*#__PURE__*/function (_BiologicalUnit) {
    _inherits(Assembly, _BiologicalUnit);

    var _super = _createSuper$1V(Assembly);

    function Assembly(complex) {
      var _this;

      _classCallCheck(this, Assembly);

      _this = _super.call(this, complex);
      _this.chains = [];
      _this.matrices = [];
      return _this;
    }

    _createClass(Assembly, [{
      key: "computeBoundaries",
      value: function computeBoundaries() {
        _get(_getPrototypeOf(Assembly.prototype), "computeBoundaries", this).call(this);

        var matrices = this.matrices;
        var oldCenter = this._boundaries.boundingSphere.center;
        var oldRad = this._boundaries.boundingSphere.radius;
        var boundingBox = this._boundaries.boundingBox = new THREE__namespace.Box3();
        boundingBox.makeEmpty();

        for (var i = 0, n = matrices.length; i < n; ++i) {
          boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i]));
        }

        var newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
        var center = new THREE__namespace.Vector3();
        boundingBox.getCenter(center);
        this._boundaries.boundingSphere = new THREE__namespace.Sphere().set(center, newRad);
        boundingBox.max.addScalar(oldRad);
        boundingBox.min.subScalar(oldRad);
      }
    }, {
      key: "addChain",
      value: function addChain(chain) {
        this.chains[this.chains.length] = chain;
      }
    }, {
      key: "addMatrix",
      value: function addMatrix(matrix) {
        this.matrices[this.matrices.length] = matrix;
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return this.matrices;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        if (this.chains.length > 0) {
          this._selector = selectors$5.keyword('Chain')(this.chains);
        } else {
          this._selector = selectors$5.keyword('None')();
        }
      }
    }]);

    return Assembly;
  }(BiologicalUnit);

  var Component = /*#__PURE__*/function () {
    function Component(complex) {
      _classCallCheck(this, Component);

      this._complex = complex;
      this._index = -1;
      this._residueIndices = [];
      this._cycles = [];
      this._subDivs = [];
      this._residueCount = 0;
    }

    _createClass(Component, [{
      key: "getResidues",
      value: function getResidues() {
        return this._complex._residues;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residueCount;
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._complex._residues;
        var resIdc = this._residueIndices;

        for (var idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
          for (var idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
            process(residues[idx]);
          }
        }
      }
    }, {
      key: "setSubDivs",
      value: function setSubDivs(subDivs) {
        this._subDivs = subDivs;
        var curr = 0;
        var resIdc = [];
        var resCnt = 0;

        for (var i = 0, n = subDivs.length; i < n; ++i) {
          if (i === n - 1 || subDivs[i].end + 1 !== subDivs[i + 1].start) {
            var start = subDivs[curr].start;
            var end = subDivs[i].end;
            resIdc[resIdc.length] = {
              start: start,
              end: end
            };
            resCnt += end - start + 1;
            curr = i + 1;
          }
        }

        this._residueIndices = resIdc;
        this._residueCount = resCnt;
      }
    }, {
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this._complex._bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          var bond = bonds[i];

          if (bond._left.residue._component === this) {
            process(bond);
          }
        }
      }
    }, {
      key: "update",
      value: function update() {
        this.forEachCycle(function (cycle) {
          cycle.update();
        });
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        this.forEachResidue(function (residue) {
          residue.forEachAtom(process);
        });
      }
    }, {
      key: "addCycle",
      value: function addCycle(cycle) {
        this._cycles.push(cycle);
      }
    }, {
      key: "forEachCycle",
      value: function forEachCycle(process) {
        var cycles = this._cycles;

        for (var i = 0, n = cycles.length; i < n; ++i) {
          process(cycles[i]);
        }
      }
    }, {
      key: "markResidues",
      value: function markResidues() {
        var self = this;
        self.forEachResidue(function (residue) {
          residue._component = self;
        });
      }
    }, {
      key: "_forEachSubChain",
      value: function _forEachSubChain(mask, process) {
        var residues = this._complex._residues;
        var subs = this._subDivs;

        for (var i = 0, n = subs.length; i < n; ++i) {
          for (var idx = subs[i].start, last = subs[i].end; idx <= last; ++idx) {
            var currRes = residues[idx];

            if (mask & currRes._mask && currRes._isValid) {
              var end = idx + 1;

              for (; end <= last; ++end) {
                var endRes = residues[end];

                if (!(mask & endRes._mask && endRes._isValid)) {
                  break;
                }
              }

              process(i, idx, end - 1);
              idx = end;
            }
          }
        }
      }
    }, {
      key: "getMaskedSequences",
      value: function getMaskedSequences(mask) {
        var subs = [];
        var idx = 0;

        this._forEachSubChain(mask, function (_subIdx, start, end) {
          subs[idx++] = {
            start: start,
            end: end
          };
        });

        return subs;
      }
    }, {
      key: "getMaskedSubdivSequences",
      value: function getMaskedSubdivSequences(mask) {
        var subs = [];
        var currIdx = -1;
        var lastSubIdx = -1;
        var subDivs = this._subDivs;

        this._forEachSubChain(mask, function (subIdx, start, end) {
          if (lastSubIdx !== subIdx) {
            ++currIdx;
            subs[currIdx] = {
              arr: [],
              boundaries: subDivs[subIdx]
            };
            lastSubIdx = subIdx;
          }

          subs[currIdx].arr[subs[currIdx].arr.length] = {
            start: start,
            end: end
          };
        });

        return subs;
      }
    }]);

    return Component;
  }();

  var cMaxPairsForHashCode = 32;
  var cHashTableSize = 1024 * 1024;
  var cNumbersPerPair = 4;
  var cMaxNeighbours = 14;
  var cInvalidVal = -1;
  var cBigPrime = 89237;

  var AtomPairs = /*#__PURE__*/function () {
    function AtomPairs(maxPairsEstimate) {
      _classCallCheck(this, AtomPairs);

      this.numPairs = 0;
      this.numMaxPairs = maxPairsEstimate;
      this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);

      for (var i = 0; i < maxPairsEstimate * cNumbersPerPair; i++) {
        this.intBuffer[i] = cInvalidVal;
      }

      this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);

      for (var _i = 0; _i < cHashTableSize * cMaxPairsForHashCode; _i++) {
        this.hashBuffer[_i] = cInvalidVal;
      }
    }

    _createClass(AtomPairs, [{
      key: "destroy",
      value: function destroy() {
        this.intBuffer = null;
        this.hashBuffer = null;
      }
    }, {
      key: "addPair",
      value: function addPair(indexA, indexB) {
        var ia = indexA < indexB ? indexA : indexB;
        var ib = indexA > indexB ? indexA : indexB;
        var codeToAdd = ia + (ib << cMaxNeighbours);
        var hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
        var j = hashCode * cMaxPairsForHashCode;
        var apI = 0;

        for (; apI < cMaxPairsForHashCode; apI++) {
          var code = this.hashBuffer[j + apI];

          if (code === cInvalidVal) {
            break;
          }

          if (code === codeToAdd) {
            return false;
          }
        }

        if (apI >= cMaxPairsForHashCode) {
          throw new Error('addPair: increase cMaxPairsForHashCode');
        }

        this.hashBuffer[j + apI] = codeToAdd;

        if (this.numPairs >= this.numMaxPairs) {
          throw new Error('addPair: increase num pairs');
        }

        j = this.numPairs * cNumbersPerPair;
        this.intBuffer[j] = ia;
        this.intBuffer[j + 1] = ib;
        this.intBuffer[j + 2] = codeToAdd;
        this.numPairs++;
        return true;
      }
    }]);

    return AtomPairs;
  }();

  var cEstBondsMultiplier = 4;
  var cSpaceCode = 32;
  var cBondTolerance = 0.45;
  var cEpsilon = 0.001;

  function _getBondingRadius(atom) {
    var element = atom.element;

    if (element) {
      return element.radiusBonding;
    }

    throw new Error('_getBondingRadius: Logic error.');
  }

  function _isAtomEligible(atom) {
    return !atom.isHet() || atom.bonds && atom.bonds.length === 0;
  }

  var AutoBond = /*#__PURE__*/function () {
    function AutoBond(complex) {
      _classCallCheck(this, AutoBond);

      this._complex = complex;
      this._maxRad = 1.8;

      var bBox = this._complex.getDefaultBoundaries().boundingBox;

      this._vBoxMin = bBox.min.clone();
      this._vBoxMax = bBox.max.clone();
      this._pairCollection = null;
    }

    _createClass(AutoBond, [{
      key: "_addExistingPairs",
      value: function _addExistingPairs() {
        var atoms = this._complex.getAtoms();

        var numAtoms = atoms.length;
        var aInd = 0;
        var collection = this._pairCollection;

        for (; aInd < numAtoms; aInd++) {
          var bonds = atoms[aInd].bonds;
          var numBondsForAtom = bonds.length;

          for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
            var bond = bonds[bInd];
            var indTo = bond._left.index;

            if (indTo === aInd) {
              collection.addPair(aInd, bond._right.index);
            }
          }
        }

        return 0;
      }
    }, {
      key: "_findPairs",
      value: function _findPairs() {
        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return;
        }

        var atoms = this._complex._atoms;
        var atomsNum = atoms.length;
        var self = this;
        var rA;
        var isHydrogenA;
        var posA;
        var locationA;
        var atomA;

        var processAtom = function processAtom(atomB) {
          if (isHydrogenA && atomB.isHydrogen()) {
            return;
          }

          var locationB = atomB.location;

          if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
            return;
          }

          var dist2 = posA.distanceToSquared(atomB.position);
          var rB = atomB.element.radiusBonding;
          var maxAcceptable = rA + rB + cBondTolerance ;

          if (dist2 > maxAcceptable * maxAcceptable) {
            return;
          }

          if (dist2 < cEpsilon) {
            return;
          }

          self._pairCollection.addPair(atomA.index, atomB.index);
        };

        for (var i = 0; i < atomsNum; ++i) {
          atomA = atoms[i];

          if (!_isAtomEligible(atomA)) {
            continue;
          }

          rA = atomA.element.radiusBonding;
          isHydrogenA = atomA.isHydrogen();
          posA = atomA.position;
          locationA = atomA.location;
          vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
        }
      }
    }, {
      key: "_addPairs",
      value: function _addPairs() {
        var atoms = this._complex._atoms;

        for (var i = 0, k = 0; i < this._pairCollection.numPairs; i++, k += 4) {
          var iA = this._pairCollection.intBuffer[k];
          var iB = this._pairCollection.intBuffer[k + 1];

          this._addPair(atoms[iA], atoms[iB]);
        }
      }
    }, {
      key: "_addPair",
      value: function _addPair(atomA, atomB) {
        var bondsA = atomA.bonds;
        var indexA = atomA.index;
        var indexB = atomB.index;

        for (var j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
          var bond = bondsA[j];

          if (bond._left.index === indexB || bond._right.index === indexB) {
            return;
          }
        }

        var left = indexA < indexB ? atomA : atomB;
        var right = indexA < indexB ? atomB : atomA;

        var newBond = this._complex.addBond(left, right, 0, Bond$5.BondType.UNKNOWN, false);

        bondsA.push(newBond);
        atomB.bonds.push(newBond);
      }
    }, {
      key: "build",
      value: function build() {

        this._buildInner();
      }
    }, {
      key: "_buildInner",
      value: function _buildInner() {
        var atoms = this._complex._atoms;

        if (atoms.length < 2) {
          return;
        }

        if (atoms[0].index < 0) {
          throw new Error('AutoBond: Atoms in complex were not indexed.');
        }

        this._calcBoundingBox();

        this._pairCollection = new AtomPairs(atoms.length * cEstBondsMultiplier);

        this._addExistingPairs();

        this._findPairs();

        this._addPairs();
      }
    }, {
      key: "_calcBoundingBox",
      value: function _calcBoundingBox() {
        var atoms = this._complex._atoms;
        var nAtoms = atoms.length;

        var maxRad = _getBondingRadius(atoms[0]);

        for (var i = 1; i < nAtoms; ++i) {
          maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]));
        }

        this._vBoxMax.addScalar(maxRad);

        this._vBoxMin.addScalar(-maxRad);

        this._maxRad = maxRad * 1.2;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._pairCollection) {
          this._pairCollection.destroy();
        }
      }
    }]);

    return AutoBond;
  }();

  var cCrossThresh = 0.1;
  var cAromaticType = Bond$5.BondType.AROMATIC;
  var cAromaticAtoms = [Element$a.ByName.C.number, Element$a.ByName.N.number];

  var _coDirVectors = function () {
    var v1Tmp = new THREE__namespace.Vector3();
    var v2Tmp = new THREE__namespace.Vector3();
    var cp = new THREE__namespace.Vector3();
    return function (v1, v2) {
      v1Tmp.copy(v1).normalize();
      v2Tmp.copy(v2).normalize();
      cp.crossVectors(v1Tmp, v2Tmp);

      if (cp.length() > cCrossThresh) {
        return false;
      }

      return v1Tmp.dot(v2Tmp) >= 0;
    };
  }();

  function _insertAscending(arr, val) {
    var idx = 0;

    while (idx < arr.length && arr[idx] < val) {
      ++idx;
    }

    arr.splice(idx, 0, val);
  }

  function _anotherAtom(bond, currAtom) {
    return bond._left === currAtom ? bond._right : bond._left;
  }

  function _cosBetween(v1, v2) {
    var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
    return THREE__namespace.MathUtils.clamp(theta, -1, 1);
  }

  function _markAromatic(bond) {
    bond._type = cAromaticType;
  }

  var Cycle = /*#__PURE__*/function () {
    function Cycle(atomsList) {
      _classCallCheck(this, Cycle);

      this.atoms = atomsList;
      this.update();
    }

    _createClass(Cycle, [{
      key: "update",
      value: function update() {
        var atoms = this.atoms;
        var center = new THREE__namespace.Vector3();
        var nA = atoms.length;

        for (var j = 0; j < nA; ++j) {
          center.add(atoms[j].position);
        }

        center.multiplyScalar(1.0 / nA);
        this.center = center;
        this.radius = center.distanceTo(atoms[0].position.clone().lerp(atoms[1].position, 0.5));
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var atoms = this.atoms;
        var nA = atoms.length;
        var currAtom = atoms[0];
        var nextAtom;

        function checkBond(bond) {
          if (bond._left === nextAtom || bond._right === nextAtom) {
            process(bond);
          }
        }

        for (var i = 0; i < nA; ++i) {
          nextAtom = atoms[(i + 1) % nA];
          currAtom.forEachBond(checkBond);
          currAtom = nextAtom;
        }
      }
    }]);

    return Cycle;
  }();

  function _isAromatic(bond) {
    return bond._type === cAromaticType;
  }

  function _isPossibleAromatic(bond) {
    if (bond.type === cAromaticType) {
      return true;
    }

    var rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
    var leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
    return rightIdx !== -1 && leftIdx !== -1;
  }

  function _checkCycleSimple(cycle) {
    return cycle.length > 3;
  }

  function _checkCycleComplex(cycle) {
    console.assert(cycle.length > 2);
    return true;
  }

  var AromaticLoopsMarker = /*#__PURE__*/function () {
    function AromaticLoopsMarker(complex) {
      _classCallCheck(this, AromaticLoopsMarker);

      this._complex = complex;
      var bondsData = new Array(complex._bonds.length);
      var bondMarks = new Array(complex._bonds.length);

      for (var i = 0, n = bondsData.length; i < n; ++i) {
        bondsData[i] = [];
        bondMarks[i] = false;
      }

      this._bondsData = bondsData;
      this._bondMarks = bondMarks;

      this._resetCycles();
    }

    _createClass(AromaticLoopsMarker, [{
      key: "_resetCycles",
      value: function _resetCycles() {
        this._cycles = [];
        this._currIdx = -1;
      }
    }, {
      key: "_haveSameCycle",
      value: function _haveSameCycle(bondsData, bond1, bond2) {
        var arr1 = bondsData[bond1._index];
        var arr2 = bondsData[bond2._index];
        var n1 = arr1.length;
        var n2 = arr2.length;
        var i1 = 0;
        var i2 = 0;

        while (i1 < n1 && i2 < n2) {
          if (arr1[i1] === arr2[i2]) {
            return true;
          }

          if (arr1[i1] > arr2[i2]) {
            ++i2;
          } else {
            ++i1;
          }
        }

        return false;
      }
    }, {
      key: "_tryBond",
      value: function _tryBond(prevBond, currRight, currDir) {
        var bondsOrder = [];
        var bondsData = this._bondsData;

        var currLeft = _anotherAtom(prevBond, currRight);

        var currVec = currRight.position.clone().sub(currLeft.position);
        var startAtomRef = this._currStart;
        var self = this;
        var bondMarks = this._bondMarks;
        var checkAromatic = this._checkBond;
        bondMarks[prevBond._index] = true;
        checkAromatic = checkAromatic === undefined ? _isAromatic : checkAromatic;
        currRight.forEachBond(function (newBond) {
          if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self._haveSameCycle(bondsData, prevBond, newBond)) {
            return;
          }

          var anotherAtom = _anotherAtom(newBond, currRight);

          var anotherVec = anotherAtom.position.clone().sub(currRight.position);
          var val = anotherAtom === startAtomRef ? -2.0 : 1 - _cosBetween(currVec, anotherVec);
          var newDir = anotherVec.cross(currVec);

          if (!_coDirVectors(newDir, currDir)) {
            return;
          }

          var idx = 0;

          while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
            ++idx;
          }

          bondsOrder.splice(idx, 0, {
            bond: newBond,
            val: val,
            dir: newDir
          });
        });

        for (var i = 0, n = bondsOrder.length; i < n; ++i) {
          var bond = bondsOrder[i].bond;
          var newRight = bond._left === currRight ? bond._right : bond._left;

          if (newRight === startAtomRef) {
            ++this._currIdx;

            this._cycles.push([currRight]);

            bondMarks[prevBond._index] = false;
            return true;
          }

          if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
            _insertAscending(bondsData[bond._index], this._currIdx);

            this._cycles[this._currIdx].push(currRight);

            bondMarks[prevBond._index] = false;
            return true;
          }
        }

        bondMarks[prevBond._index] = false;
        return false;
      }
    }, {
      key: "_startCycle",
      value: function _startCycle(bond) {
        this._currStart = bond._left;

        if (this._tryBond(bond, bond._right, new THREE__namespace.Vector3())) {
          _insertAscending(this._bondsData[bond._index], this._currIdx);

          this._cycles[this._currIdx].push(bond._left);
        }
      }
    }, {
      key: "_findLoops",
      value: function _findLoops(checkBond, checkCycle) {
        this._checkBond = checkBond;
        var complex = this._complex;
        var self = this;
        complex.forEachComponent(function (component) {
          self._resetCycles();

          component.forEachBond(function (bond) {
            if (checkBond(bond)) {
              self._startCycle(bond);
            }
          });
          var cycles = self._cycles;

          for (var i = 0, n = cycles.length; i < n; ++i) {
            var cycle = cycles[i];

            if (!checkCycle(cycle)) {
              continue;
            }

            var newCycle = new Cycle(cycle);
            newCycle.forEachBond(_markAromatic);
            component.addCycle(newCycle);
          }
        });
      }
    }, {
      key: "markCycles",
      value: function markCycles() {
        this._findLoops(_isAromatic, _checkCycleSimple);
      }
    }, {
      key: "detectCycles",
      value: function detectCycles() {
        this._findLoops(_isPossibleAromatic, _checkCycleComplex);
      }
    }]);

    return AromaticLoopsMarker;
  }();

  function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
    var dzMin = zMin - center.z;
    var dzMax = zMax - center.z;
    var rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0.0));
    var rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0.0));
    var rMin = Math.min(rzMin, rzMax);
    var rMax;

    if (zMin <= center.z && zMax >= center.z) {
      rMax = radius;
    } else {
      rMax = Math.max(rzMin, rzMax);
    }

    return [rMin, rMax];
  }

  function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
    var dyMin = yMin - center.y;
    var dyMax = yMax - center.y;
    var ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0.0));
    var ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0.0));
    var rMin = Math.min(ryMin, ryMax);
    var rMax;

    if (yMin <= center.y && yMax >= center.y) {
      rMax = radius;
    } else {
      rMax = Math.max(ryMin, ryMax);
    }

    return [rMin, rMax];
  }

  var VoxelWorld = /*#__PURE__*/function () {
    function VoxelWorld(box, vCellSizeHint) {
      _classCallCheck(this, VoxelWorld);

      this._box = box.clone();
      var size = new THREE__namespace.Vector3();
      box.getSize(size);
      this._count = size.clone().divide(vCellSizeHint).floor().max(new THREE__namespace.Vector3(1, 1, 1));
      this._last = this._count.clone().subScalar(1);
      this._cellSize = size.clone().divide(this._count);
      this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
      this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize));
      var numVoxels = this._count.x * this._count.y * this._count.z;
      this._voxels = utils.allocateTyped(Int32Array, numVoxels);

      for (var i = 0; i < numVoxels; ++i) {
        this._voxels[i] = -1;
      }

      this._atoms = [];
    }

    _createClass(VoxelWorld, [{
      key: "addAtoms",
      value: function addAtoms(complex) {
        var self = this;
        var idx = this._atoms.length;
        this._atoms.length += 2 * complex.getAtomCount();
        complex.forEachAtom(function (atom) {
          var voxelIdx = self._findVoxel(atom.position);

          self._atoms[idx] = atom;
          self._atoms[idx + 1] = self._voxels[voxelIdx];
          self._voxels[voxelIdx] = idx;
          idx += 2;
        });
      }
    }, {
      key: "_findVoxel",
      value: function _findVoxel(point) {
        var zero = VoxelWorld._zero;
        var voxel = VoxelWorld._voxel;
        voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
        return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
      }
    }, {
      key: "_forEachAtomInVoxel",
      value: function _forEachAtomInVoxel(voxel, process) {
        for (var i = this._voxels[voxel]; i >= 0; i = this._atoms[i + 1]) {
          process(this._atoms[i]);
        }
      }
    }, {
      key: "_forEachVoxelWithinRadius",
      value: function _forEachVoxelWithinRadius(center, radius, process) {
        var xRange = VoxelWorld._xRange;
        var yRange = VoxelWorld._yRange;
        var zRange = VoxelWorld._zRange;

        if (radius / this._cellInnerR < 10) {
          this._forEachVoxelWithinRadiusSimple(center, radius, process);

          return;
        }

        var rRangeXY;
        var rRangeX;
        var xVal;
        var yVal;
        var zVal;
        var isInsideX;
        var isInsideY;
        var isInsideZ;
        zRange.set(center.z - radius, center.z + radius);
        zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);

        for (var z = zRange.x; z <= zRange.y; ++z) {
          zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
          isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;
          rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);
          yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
          yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);

          for (var y = yRange.x; y <= yRange.y; ++y) {
            yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
            isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];
            rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);
            xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
            xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);

            for (var x = xRange.x; x <= xRange.y; ++x) {
              xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
              isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];
              process(x + this._count.x * (y + this._count.y * z), isInsideX && isInsideY && isInsideZ);
            }
          }
        }
      }
    }, {
      key: "_forEachVoxelWithinRadiusSimple",
      value: function _forEachVoxelWithinRadiusSimple(center, radius, process) {
        var xRange = VoxelWorld._xRange;
        var yRange = VoxelWorld._yRange;
        var zRange = VoxelWorld._zRange;
        var vCenter = VoxelWorld._vCenter;
        var distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
        var distInside2 = -1.0;

        if (radius > this._cellOuterR) {
          distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
        }

        xRange.set(center.x - radius, center.x + radius);
        xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
        xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
        xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);
        yRange.set(center.y - radius, center.y + radius);
        yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
        yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
        yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);
        zRange.set(center.z - radius, center.z + radius);
        zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
        zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
        zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);

        for (var z = zRange.x; z <= zRange.y; ++z) {
          var zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
          vCenter.z = 0.5 * (zVal[0] + zVal[1]);

          for (var y = yRange.x; y <= yRange.y; ++y) {
            var yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
            vCenter.y = 0.5 * (yVal[0] + yVal[1]);

            for (var x = xRange.x; x <= xRange.y; ++x) {
              var xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
              vCenter.x = 0.5 * (xVal[0] + xVal[1]);
              var d2 = center.distanceToSquared(vCenter);

              if (d2 <= distTouch2) {
                process(x + this._count.x * (y + this._count.y * z), d2 <= distInside2);
              }
            }
          }
        }
      }
    }, {
      key: "forEachAtomWithinRadius",
      value: function forEachAtomWithinRadius(center, radius, process) {
        var self = this;
        var r2 = radius * radius;

        self._forEachVoxelWithinRadius(center, radius, function (voxel, isInside) {
          if (isInside) {
            self._forEachAtomInVoxel(voxel, process);
          } else {
            self._forEachAtomInVoxel(voxel, function (atom) {
              if (center.distanceToSquared(atom.position) <= r2) {
                process(atom);
              }
            });
          }
        });
      }
    }, {
      key: "forEachAtomWithinDistFromMasked",
      value: function forEachAtomWithinDistFromMasked(complex, mask, dist, process) {
        this._forEachAtomWithinDistFromGroup(function (atomProc) {
          complex.forEachAtom(function (atom) {
            if ((atom.mask & mask) !== 0) {
              atomProc(atom);
            }
          });
        }, dist, process);
      }
    }, {
      key: "forEachAtomWithinDistFromSelected",
      value: function forEachAtomWithinDistFromSelected(complex, selector, dist, process) {
        this._forEachAtomWithinDistFromGroup(function (atomProc) {
          complex.forEachAtom(function (atom) {
            if (selector.includesAtom(atom)) {
              atomProc(atom);
            }
          });
        }, dist, process);
      }
    }, {
      key: "_forEachAtomWithinDistFromGroup",
      value: function _forEachAtomWithinDistFromGroup(forEachAtom, dist, process) {
        var self = this;
        var r2 = dist * dist;
        var voxels = [];
        var atoms = [];
        var idx = 0;
        forEachAtom(function (atom) {
          self._forEachVoxelWithinRadius(atom.position, dist, function (voxel, isInside) {
            if (isInside) {
              voxels[voxel] = -1;
            } else if (typeof voxels[voxel] === 'undefined') {
              atoms.push(atom);
              atoms.push(-1);
              voxels[voxel] = idx;
              idx += 2;
            } else if (voxels[voxel] !== -1) {
              atoms.push(atom);
              atoms.push(voxels[voxel]);
              voxels[voxel] = idx;
              idx += 2;
            }
          });
        });
        var voxel;

        var processIfWithin = function processIfWithin(atom) {
          if (typeof voxels[voxel] === 'undefined') {
            return;
          }

          idx = voxels[voxel];

          if (idx === -1) {
            process(atom);
            return;
          }

          for (; idx >= 0; idx = atoms[idx + 1]) {
            if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
              process(atom);
              break;
            }
          }
        };

        for (voxel in voxels) {
          if (voxels.hasOwnProperty(voxel)) {
            self._forEachAtomInVoxel(voxel, processIfWithin);
          }
        }
      }
    }]);

    return VoxelWorld;
  }();

  _defineProperty(VoxelWorld, "_zero", new THREE__namespace.Vector3(0, 0, 0));

  _defineProperty(VoxelWorld, "_voxel", new THREE__namespace.Vector3());

  _defineProperty(VoxelWorld, "_xRange", new THREE__namespace.Vector2());

  _defineProperty(VoxelWorld, "_yRange", new THREE__namespace.Vector2());

  _defineProperty(VoxelWorld, "_zRange", new THREE__namespace.Vector2());

  _defineProperty(VoxelWorld, "_vCenter", new THREE__namespace.Vector3());

  var MINIMAL_DISTANCE = 0.5;
  var MIN_HBOND_ENERGY = -9.9;
  var MAX_HBOND_ENERGY = -0.5;
  var COUPLING_CONSTANT = -27.888;
  var MAX_COUPLING_DISTANCE = 5.0;
  var MAX_RESIDUES_THRESHOLD = 1000;

  var HBondInfo = /*#__PURE__*/function () {
    function HBondInfo(complex) {
      _classCallCheck(this, HBondInfo);

      this._complex = complex;
      this._hbonds = [];

      if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
        this._buildVW();
      } else {
        this._build();
      }
    }

    _createClass(HBondInfo, [{
      key: "isBond",
      value: function isBond(from, to) {
        if (this._hbonds[from]) {
          var _this$_hbonds$from$ac = _slicedToArray(this._hbonds[from].acceptor, 2),
              acc0 = _this$_hbonds$from$ac[0],
              acc1 = _this$_hbonds$from$ac[1];

          if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
            return true;
          }

          if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "_build",
      value: function _build() {
        var self = this;

        for (var i = 0; i < this._complex._residues.length - 1; ++i) {
          var ri = this._complex._residues[i];

          if ((ri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
            continue;
          }

          var preri = null;

          if (i > 0 && this._complex._residues[i - 1].getType().flags & ResidueType$1.Flags.PROTEIN && ri._sequence === this._complex._residues[i - 1]._sequence + 1) {
            preri = this._complex._residues[i - 1];
          }

          for (var j = i + 1; j < this._complex._residues.length; ++j) {
            var rj = this._complex._residues[j];

            if ((rj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
              continue;
            }

            var prerj = null;

            if (this._complex._residues[j - 1].getType().flags & ResidueType$1.Flags.PROTEIN && rj._sequence === this._complex._residues[j - 1]._sequence + 1) {
              prerj = this._complex._residues[j - 1];
            }

            self._calcHBondEnergy(preri, ri, rj);

            if (j !== i + 1) {
              self._calcHBondEnergy(prerj, rj, ri);
            }
          }
        }
      }
    }, {
      key: "_buildVW",
      value: function _buildVW() {
        var self = this;
        var residues = this._complex._residues;
        var ri;
        var preri;

        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return;
        }

        var pairs = new AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);

        function processAtom(atom) {
          var rj = atom.residue;

          if (rj._index === ri._index) {
            return;
          }

          if ((rj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
            return;
          }

          if (!pairs.addPair(ri._index, rj._index)) {
            return;
          }

          var prerj = rj._index > 0 ? residues[rj._index - 1] : null;

          if (prerj && ((prerj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
            prerj = null;
          }

          self._calcHBondEnergy(preri, ri, rj);

          if (rj._index !== ri._index + 1) {
            self._calcHBondEnergy(prerj, rj, ri);
          }
        }

        for (var i = 0; i < residues.length - 1; ++i) {
          ri = residues[i];

          if ((ri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
            continue;
          }

          preri = i > 0 ? residues[i - 1] : null;

          if (preri && ((preri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
            preri = null;
          }

          vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
        }
      }
    }, {
      key: "_residueGetCAlpha",
      value: function _residueGetCAlpha(res) {
        for (var i = 0; i < res._atoms.length; ++i) {
          var name = res._atoms[i].name;

          if (name === 'CA' || name === 'C1') {
            return res._atoms[i].position;
          }
        }

        return null;
      }
    }, {
      key: "_residueGetCO",
      value: function _residueGetCO(res) {
        var c = null;
        var o = null;
        res.forEachAtom(function (a) {
          if (a.name === 'C') {
            c = a.position;
          } else if (a.name === 'O') {
            o = a.position;
          }
        });
        return [c, o];
      }
    }, {
      key: "_residueGetNH",
      value: function _residueGetNH(prev, res) {
        var _this$_residueGetCO = this._residueGetCO(prev),
            _this$_residueGetCO2 = _slicedToArray(_this$_residueGetCO, 2),
            c = _this$_residueGetCO2[0],
            o = _this$_residueGetCO2[1];

        var n;
        res.forEachAtom(function (a) {
          if (a.name === 'N') {
            n = a.position;
          }
        });

        if (c && o && n) {
          var h = c.clone();
          h.sub(o);
          h.multiplyScalar(1.0 / h.length());
          h.add(n);
          return [n, h];
        }

        return [null, null];
      }
    }, {
      key: "_calcHBondEnergy",
      value: function _calcHBondEnergy(predonor, donor, acceptor) {
        var result = 0;

        if (predonor === null) {
          return result;
        }

        if (donor.getType().getName() !== 'PRO') {
          var _this$_residueGetNH = this._residueGetNH(predonor, donor),
              _this$_residueGetNH2 = _slicedToArray(_this$_residueGetNH, 2),
              n = _this$_residueGetNH2[0],
              h = _this$_residueGetNH2[1];

          var _this$_residueGetCO3 = this._residueGetCO(acceptor),
              _this$_residueGetCO4 = _slicedToArray(_this$_residueGetCO3, 2),
              c = _this$_residueGetCO4[0],
              o = _this$_residueGetCO4[1];

          if (n === null || h === null || c === null || o === null) {
            return result;
          }

          var distanceHO = h.distanceTo(o);
          var distanceHC = h.distanceTo(c);
          var distanceNC = n.distanceTo(c);
          var distanceNO = n.distanceTo(o);

          if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
            result = MIN_HBOND_ENERGY;
          } else {
            result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
          }

          result = Math.round(result * 1000) / 1000;

          if (result < MIN_HBOND_ENERGY) {
            result = MIN_HBOND_ENERGY;
          }
        }

        if (typeof this._hbonds[donor._index] === 'undefined') {
          this._hbonds[donor._index] = {
            donor: [],
            acceptor: []
          };
        }

        var donorInfo = this._hbonds[donor._index];

        if (donorInfo.acceptor.length < 2) {
          donorInfo.acceptor.push({
            residue: acceptor._index,
            energy: result
          });
        }

        if (donorInfo.acceptor.length > 1) {
          if (result < donorInfo.acceptor[0].energy) {
            donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
            donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
            donorInfo.acceptor[0].residue = acceptor._index;
            donorInfo.acceptor[0].energy = result;
          } else if (result < donorInfo.acceptor[1].energy) {
            donorInfo.acceptor[1].residue = acceptor._index;
            donorInfo.acceptor[1].energy = result;
          }
        }

        if (typeof this._hbonds[acceptor._index] === 'undefined') {
          this._hbonds[acceptor._index] = {
            donor: [],
            acceptor: []
          };
        }

        var accInfo = this._hbonds[acceptor._index];

        if (accInfo.donor.length < 2) {
          accInfo.donor.push({
            residue: donor._index,
            energy: result
          });
        }

        if (accInfo.donor.length > 1) {
          if (result < accInfo.donor[0].energy) {
            accInfo.donor[1].residue = accInfo.donor[0].residue;
            accInfo.donor[1].energy = accInfo.donor[0].energy;
            accInfo.donor[0].residue = donor._index;
            accInfo.donor[0].energy = result;
          } else if (result < accInfo.donor[1].energy) {
            accInfo.donor[1].residue = donor._index;
            accInfo.donor[1].energy = result;
          }
        }

        return result;
      }
    }]);

    return HBondInfo;
  }();

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  var BridgeType = Object.freeze({
    NO_BRIDGE: 0,
    PARALLEL: 1,
    ANTI_PARALLEL: 2
  });
  var HelixFlag = Object.freeze({
    START: 1,
    MIDDLE: 2,
    END: 3,
    START_AND_END: 4
  });
  var StructureType$1 = Object.freeze({
    STRAND: 'E',
    BRIDGE: 'B',
    HELIX_310: 'G',
    HELIX_ALPHA: 'H',
    HELIX_PI: 'I',
    TURN: 'T',
    BEND: 'S',
    LOOP: ' '
  });

  var SecondaryStructureMap = /*#__PURE__*/function () {
    function SecondaryStructureMap(complex) {
      _classCallCheck(this, SecondaryStructureMap);

      this._complex = complex;

      this._build();
    }

    _createClass(SecondaryStructureMap, [{
      key: "_build",
      value: function _build() {
        var self = this;
        this._hbonds = new HBondInfo(this._complex);
        this._ss = [];
        this._sheet = [];
        this._betaPartners = [];
        this._bend = [];

        for (var i = 0; i < this._complex.getResidues().length; ++i) {
          this._betaPartners[i] = [];
        }

        this._helixFlags = [];
        this._helixFlags[3] = [];
        this._helixFlags[4] = [];
        this._helixFlags[5] = [];
        this._chainLengths = [];

        for (var _i = 0; _i < this._complex._chains.length; ++_i) {
          var chain = this._complex._chains[_i].getResidues();

          var len = 0;

          for (; len < chain.length; ++len) {
            if ((chain[len].getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
              break;
            }
          }

          this._chainLengths[_i] = len;
        }

        this._buildBetaSheets();

        for (var _i2 = 0; _i2 < this._complex._chains.length; ++_i2) {
          self._buildAlphaHelices(this._complex._chains[_i2].getResidues(), this._chainLengths[_i2], false);
        }
      }
    }, {
      key: "_buildAlphaHelices",
      value: function _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
        for (var stride = 3; stride <= 5; ++stride) {
          if (inResidues.length < stride) {
            break;
          }

          for (var i = 0; i + stride < chainLength; ++i) {
            if (this._hbonds.isBond(inResidues[i + stride]._index, inResidues[i]._index)) {
              this._helixFlags[stride][inResidues[i + stride]._index] = HelixFlag.END;

              for (var j = i + 1; j < i + stride; ++j) {
                if (typeof this._helixFlags[stride][inResidues[j]._index] === 'undefined') {
                  this._helixFlags[stride][inResidues[j]._index] = HelixFlag.MIDDLE;
                }
              }

              if (this._helixFlags[stride][inResidues[i]._index] === HelixFlag.END) {
                this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START_AND_END;
              } else {
                this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START;
              }
            }
          }
        }

        for (var _i3 = 2; _i3 < chainLength - 2; ++_i3) {
          var kappa = this._kappa(inResidues[_i3 - 2], inResidues[_i3], inResidues[_i3 + 2]);

          this._bend[inResidues[_i3]._index] = kappa !== 360 && kappa > 70;
        }

        for (var _i4 = 1; _i4 + 4 < chainLength; ++_i4) {
          if (this._isHelixStart(inResidues[_i4]._index, 4) && this._isHelixStart(inResidues[_i4 - 1]._index, 4)) {
            for (var _j = _i4; _j <= _i4 + 3; ++_j) {
              this._ss[inResidues[_j]._index] = StructureType$1.HELIX_ALPHA;
            }
          }
        }

        for (var _i5 = 1; _i5 + 3 < chainLength; ++_i5) {
          if (this._isHelixStart(inResidues[_i5]._index, 3) && this._isHelixStart(inResidues[_i5 - 1]._index, 3)) {
            var empty = true;

            for (var _j2 = _i5; empty && _j2 <= _i5 + 2; ++_j2) {
              empty = typeof this._ss[inResidues[_j2]._index] === 'undefined' || this._ss[inResidues[_j2]._index] === StructureType$1.HELIX_310;
            }

            if (empty) {
              for (var _j3 = _i5; _j3 <= _i5 + 2; ++_j3) {
                this._ss[inResidues[_j3]._index] = StructureType$1.HELIX_310;
              }
            }
          }
        }

        for (var _i6 = 1; _i6 + 5 < chainLength; ++_i6) {
          if (this._isHelixStart(inResidues[_i6]._index, 5) && this._isHelixStart(inResidues[_i6 - 1]._index, 5)) {
            var _empty = true;

            for (var _j4 = _i6; _empty && _j4 <= _i6 + 4; ++_j4) {
              _empty = typeof this._ss[inResidues[_j4]._index] === 'undefined' || this._ss[inResidues[_j4]._index] === StructureType$1.HELIX_PI || inPreferPiHelices && this._ss[inResidues[_j4]._index] === StructureType$1.HELIX_ALPHA;
            }

            if (_empty) {
              for (var _j5 = _i6; _j5 <= _i6 + 4; ++_j5) {
                this._ss[inResidues[_j5]._index] = StructureType$1.HELIX_PI;
              }
            }
          }
        }

        for (var _i7 = 1; _i7 + 1 < chainLength; ++_i7) {
          if (typeof this._ss[inResidues[_i7]._index] === 'undefined') {
            var isTurn = false;

            for (var _stride = 3; _stride <= 5 && !isTurn; ++_stride) {
              for (var k = 1; k < _stride && !isTurn; ++k) {
                isTurn = _i7 >= k && this._isHelixStart(inResidues[_i7 - k]._index, _stride);
              }
            }

            if (isTurn) {
              this._ss[inResidues[_i7]._index] = StructureType$1.TURN;
            } else if (this._bend[inResidues[_i7]._index]) {
              this._ss[inResidues[_i7]._index] = StructureType$1.BEND;
            }
          }
        }
      }
    }, {
      key: "_residueGetCAlpha",
      value: function _residueGetCAlpha(res) {
        for (var i = 0; i < res._atoms.length; ++i) {
          var name = res._atoms[i].name;

          if (name === 'CA' || name === 'C1') {
            return res._atoms[i].position;
          }
        }

        return null;
      }
    }, {
      key: "_cosinusAngle",
      value: function _cosinusAngle(p1, p2, p3, p4) {
        var v12 = p1.clone().sub(p2);
        var v34 = p3.clone().sub(p4);
        var result = 0;
        var x = v12.dot(v12) * v34.dot(v34);

        if (x > 0) {
          result = v12.dot(v34) / Math.sqrt(x);
        }

        return result;
      }
    }, {
      key: "_kappa",
      value: function _kappa(prevPrev, res, nextNext) {
        var curCA = this._residueGetCAlpha(res);

        var ppCA = this._residueGetCAlpha(prevPrev);

        var nnCA = this._residueGetCAlpha(nextNext);

        if (curCA === null || ppCA === null || nnCA === null) {
          return 180;
        }

        var ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);

        var skap = Math.sqrt(1 - ckap * ckap);
        return Math.atan2(skap, ckap) * 180 / Math.PI;
      }
    }, {
      key: "_isHelixStart",
      value: function _isHelixStart(res, stride) {
        return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
      }
    }, {
      key: "_buildBetaSheets",
      value: function _buildBetaSheets() {
        var bridges = [];

        for (var a = 0; a < this._complex._chains.length; ++a) {
          var lenA = this._chainLengths[a];

          if (lenA <= 4) {
            continue;
          }

          var chainA = this._complex._chains[a].getResidues();

          for (var b = a; b < this._complex._chains.length; ++b) {
            var lenB = this._chainLengths[b];

            if (lenB <= 4) {
              continue;
            }

            var chainB = this._complex._chains[b].getResidues();

            for (var i = 1; i + 1 < lenA; ++i) {
              var ri = chainA[i];
              var j = 1;

              if (b === a) {
                j = i + 3;
              }

              for (; j + 1 < lenB; ++j) {
                var rj = chainB[j];

                var type = this._testBridge(chainA, i, chainB, j);

                if (type === BridgeType.NO_BRIDGE) {
                  continue;
                }

                var found = false;

                var _iterator = _createForOfIteratorHelper(bridges),
                    _step;

                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var bridge = _step.value;

                    if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
                      continue;
                    }

                    if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
                      bridge.i.push(ri._index);
                      bridge.j.push(rj._index);
                      found = true;
                      break;
                    }

                    if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
                      bridge.i.push(ri._index);
                      bridge.j.unshift(rj._index);
                      found = true;
                      break;
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }

                if (!found) {
                  bridges.push({
                    type: type,
                    i: [ri._index],
                    chainI: ri.getChain()._index,
                    j: [rj._index],
                    chainJ: rj.getChain()._index
                  });
                }
              }
            }
          }
        }

        bridges.sort(function (a, b) {
          if (a.chainI < b.chainI || a.chainI === b.chainI && a.i[0] < b.i[0]) {
            return -1;
          }

          return 1;
        });

        for (var _i8 = 0; _i8 < bridges.length; ++_i8) {
          for (var _j6 = _i8 + 1; _j6 < bridges.length; ++_j6) {
            var ibi = bridges[_i8].i[0];
            var iei = bridges[_i8].i[bridges[_i8].i.length - 1];
            var jbi = bridges[_i8].j[0];
            var jei = bridges[_i8].j[bridges[_i8].j.length - 1];
            var ibj = bridges[_j6].i[0];
            var iej = bridges[_j6].i[bridges[_j6].i.length - 1];
            var jbj = bridges[_j6].j[0];
            var jej = bridges[_j6].j[bridges[_j6].j.length - 1];

            if (bridges[_i8].type !== bridges[_j6].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
              continue;
            }

            var bulge = false;

            if (bridges[_i8].type === BridgeType.PARALLEL) {
              bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
            } else {
              bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
            }

            if (bulge) {
              bridges[_i8].i = bridges[_i8].i.concat(bridges[_j6].i);

              if (bridges[_i8].type === BridgeType.PARALLEL) {
                bridges[_i8].j = bridges[_i8].j.concat(bridges[_j6].j);
              } else {
                bridges[_i8].j = bridges[_j6].j.concat(bridges[_i8].j);
              }

              bridges.splice(_j6--, 1);
            }
          }
        }

        var ladderset = new Set();

        for (var _i9 = 0; _i9 < bridges.length; ++_i9) {
          ladderset.add(bridges[_i9]);
        }

        var sheet = 1;
        var ladder = 0;

        while (ladderset.size > 0) {
          var _bridge = ladderset.values().next().value;
          ladderset.delete(_bridge);
          var sheetset = new Set();
          sheetset.add(_bridge);
          var toMove = void 0;

          do {
            toMove = new Set();

            var _iterator2 = _createForOfIteratorHelper(sheetset.values()),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _a = _step2.value;

                var _iterator4 = _createForOfIteratorHelper(ladderset.values()),
                    _step4;

                try {
                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var _b = _step4.value;

                    if (this._areBridgesLinked(_a, _b)) {
                      toMove.add(_b);
                    }
                  }
                } catch (err) {
                  _iterator4.e(err);
                } finally {
                  _iterator4.f();
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            var _iterator3 = _createForOfIteratorHelper(toMove.values()),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                _bridge = _step3.value;
                sheetset.add(_bridge);
                ladderset.delete(_bridge);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } while (toMove.size > 0);

          var _iterator5 = _createForOfIteratorHelper(sheetset.values()),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _bridge = _step5.value;
              _bridge.ladder = ladder;
              _bridge.sheet = sheet;
              _bridge.link = sheetset;
              ++ladder;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          ++sheet;
        }

        for (var _i10 = 0; _i10 < bridges.length; ++_i10) {
          var _bridge2 = bridges[_i10];
          var betai = 0;
          var betaj = 0;

          for (var l = 0; l < _bridge2.i.length; ++l) {
            if (this._betaPartners[_bridge2.i[l]][0]) {
              betai = 1;
              break;
            }
          }

          for (var _l = 0; _l < _bridge2.j.length; ++_l) {
            if (this._betaPartners[_bridge2.j[_l]][0]) {
              betaj = 1;
              break;
            }
          }

          var ss = StructureType$1.BRIDGE;

          if (_bridge2.i.length > 1) {
            ss = StructureType$1.STRAND;
          }

          if (_bridge2.type === BridgeType.PARALLEL) {
            var _j7 = 0;

            for (var k = 0; k < _bridge2.i.length; ++k) {
              this._betaPartners[_bridge2.i[k]][betai] = {
                residue: _bridge2.j[_j7++],
                ladder: _bridge2.ladder,
                parallel: true
              };
            }

            _j7 = 0;

            for (var _k = 0; _k < _bridge2.j.length; ++_k) {
              this._betaPartners[_bridge2.j[_k]][betaj] = {
                residue: _bridge2.i[_j7++],
                ladder: _bridge2.ladder,
                parallel: true
              };
            }
          } else {
            var _j8 = _bridge2.j.length - 1;

            for (var _k2 = 0; _k2 < _bridge2.i.length; ++_k2) {
              this._betaPartners[_bridge2.i[_k2]][betai] = {
                residue: _bridge2.j[_j8--],
                ladder: _bridge2.ladder,
                parallel: false
              };
            }

            _j8 = _bridge2.i.length - 1;

            for (var _k3 = 0; _k3 < _bridge2.j.length; ++_k3) {
              this._betaPartners[_bridge2.j[_k3]][betaj] = {
                residue: _bridge2.i[_j8--],
                ladder: _bridge2.ladder,
                parallel: false
              };
            }
          }

          for (var _k4 = _bridge2.i[0]; _k4 <= _bridge2.i[_bridge2.i.length - 1]; ++_k4) {
            if (this._ss[_k4] !== StructureType$1.STRAND) {
              this._ss[_k4] = ss;
              this._sheet[_k4] = _bridge2.sheet;
            }
          }

          for (var _k5 = _bridge2.j[0]; _k5 <= _bridge2.j[_bridge2.j.length - 1]; ++_k5) {
            if (this._ss[_k5] !== StructureType$1.STRAND) {
              this._ss[_k5] = ss;
              this._sheet[_k5] = _bridge2.sheet;
            }
          }
        }
      }
    }, {
      key: "_testBridge",
      value: function _testBridge(chainA, from, chainB, to) {
        var result = BridgeType.NO_BRIDGE;
        var a = chainA[from - 1]._index;
        var b = chainA[from]._index;
        var c = chainA[from + 1]._index;
        var d = chainB[to - 1]._index;
        var e = chainB[to]._index;
        var f = chainB[to + 1]._index;

        var isBond = this._hbonds.isBond.bind(this._hbonds);

        if (isBond(c, e) && isBond(e, a) || isBond(f, b) && isBond(b, d)) {
          result = BridgeType.PARALLEL;
        } else if (isBond(c, d) && isBond(f, a) || isBond(e, b) && isBond(b, e)) {
          result = BridgeType.ANTI_PARALLEL;
        }

        return result;
      }
    }, {
      key: "_areBridgesLinked",
      value: function _areBridgesLinked(a, b) {
        var ai = new Set(a.i);
        var aj = new Set(a.j);

        var _iterator6 = _createForOfIteratorHelper(b.i),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var i = _step6.value;

            if (ai.has(i) || aj.has(i)) {
              return true;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        var _iterator7 = _createForOfIteratorHelper(b.j),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var _i11 = _step7.value;

            if (ai.has(_i11) || aj.has(_i11)) {
              return true;
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return false;
      }
    }, {
      key: "_hasChainBreak",
      value: function _hasChainBreak(from, to) {
        for (var i = from + 1; i <= to; ++i) {
          if (this._complex._residues[i]._sequence !== this._complex._residues[i - 1]._sequence + 1) {
            return true;
          }
        }

        return false;
      }
    }]);

    return SecondaryStructureMap;
  }();
  SecondaryStructureMap.StructureType = StructureType$1;

  var _helixClassMap, _loopMap;
  var VOXEL_SIZE = 5.0;
  var StructureType = SecondaryStructureMap.StructureType;
  var StructuralElementType$3 = StructuralElement.Type;
  var helixClassMap = (_helixClassMap = {}, _defineProperty(_helixClassMap, StructureType.HELIX_ALPHA, 1), _defineProperty(_helixClassMap, StructureType.HELIX_PI, 3), _defineProperty(_helixClassMap, StructureType.HELIX_310, 5), _helixClassMap);
  var loopMap = (_loopMap = {}, _defineProperty(_loopMap, StructureType.BRIDGE, StructuralElementType$3.BRIDGE), _defineProperty(_loopMap, StructureType.TURN, StructuralElementType$3.TURN), _defineProperty(_loopMap, StructureType.BEND, StructuralElementType$3.BEND), _defineProperty(_loopMap, StructureType.LOOP, StructuralElementType$3.COIL), _loopMap);

  var Complex$9 = /*#__PURE__*/function () {
    function Complex() {
      _classCallCheck(this, Complex);

      this._chains = [];
      this._components = [];
      this._helices = [];
      this._sheets = [];
      this.structures = [];
      this._residueTypes = Object.create(ResidueType$1.StandardTypes);
      this._atoms = [];
      this._residues = [];
      this._bonds = [];
      this._sgroups = [];
      this._molecules = [];
      this._maskNeedsUpdate = false;
      this.metadata = {};
      this.symmetry = [];
      this.units = [new BiologicalUnit(this)];
      this._currentUnit = 0;
    }

    _createClass(Complex, [{
      key: "addAtom",
      value: function addAtom(atom) {
        var index = this._atoms.length;

        this._atoms.push(atom);

        return index;
      }
    }, {
      key: "addSheet",
      value: function addSheet(sheet) {
        var index = this._sheets.length;

        this._sheets.push(sheet);

        return index;
      }
    }, {
      key: "addHelix",
      value: function addHelix(helix) {
        var index = this._helices.length;

        this._helices.push(helix);

        return index;
      }
    }, {
      key: "getAtoms",
      value: function getAtoms() {
        return this._atoms;
      }
    }, {
      key: "getBonds",
      value: function getBonds() {
        return this._bonds;
      }
    }, {
      key: "getAtomCount",
      value: function getAtomCount() {
        return this._atoms.length;
      }
    }, {
      key: "addResidue",
      value: function addResidue(residue) {
        var index = this._residues.length;

        this._residues.push(residue);

        return index;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        this.forEachChain(function (chain) {
          chain.updateToFrame(frameData);
        });
      }
    }, {
      key: "addResidueType",
      value: function addResidueType(resName) {
        var rt = this._residueTypes[resName] = new ResidueType$1(resName, 'Unknown', '');
        return rt;
      }
    }, {
      key: "getResidueCount",
      value: function getResidueCount() {
        return this._residues.length;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        return this._residues;
      }
    }, {
      key: "getSGroupCount",
      value: function getSGroupCount() {
        return this._sgroups.length;
      }
    }, {
      key: "getSGroups",
      value: function getSGroups() {
        return this._sgroups;
      }
    }, {
      key: "getAtomByFullname",
      value: function getAtomByFullname(fullName) {
        var parts = fullName.split('.');

        if (parts.length !== 3) {
          return null;
        }

        var chainName = parts[0];
        var resId = parseInt(parts[1], 10);

        if (Number.isNaN(resId)) {
          return null;
        }

        var atomName = parts[2].toUpperCase();
        var currAtom = null;
        this.forEachChain(function (chain) {
          if (currAtom) {
            return;
          }

          if (chain._name.localeCompare(chainName) === 0) {
            chain.forEachResidue(function (residue) {
              if (currAtom) {
                return;
              }

              if (residue._sequence === resId) {
                residue.forEachAtom(function (atom) {
                  if (currAtom) {
                    return;
                  }

                  if (atomName.localeCompare(atom.name) === 0) {
                    currAtom = atom;
                  }
                });
              }
            });
          }
        });
        return currAtom;
      }
    }, {
      key: "addChain",
      value: function addChain(name) {
        var result = new Chain$2(this, name);

        this._chains.push(result);

        return result;
      }
    }, {
      key: "getChain",
      value: function getChain(name) {
        for (var i = 0, n = this._chains.length; i < n; ++i) {
          var chain = this._chains[i];

          if (chain.getName() === name) {
            return chain;
          }
        }

        return null;
      }
    }, {
      key: "getChainCount",
      value: function getChainCount() {
        return this._chains.length;
      }
    }, {
      key: "getMolecules",
      value: function getMolecules() {
        return this._molecules;
      }
    }, {
      key: "getMoleculeCount",
      value: function getMoleculeCount() {
        return this._molecules.length;
      }
    }, {
      key: "forEachAtom",
      value: function forEachAtom(process) {
        var atoms = this._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          process(atoms[i]);
        }
      }
    }, {
      key: "forEachBond",
      value: function forEachBond(process) {
        var bonds = this._bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          process(bonds[i]);
        }
      }
    }, {
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this._residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "forEachChain",
      value: function forEachChain(process) {
        var chains = this._chains;

        for (var i = 0, n = chains.length; i < n; ++i) {
          process(chains[i]);
        }
      }
    }, {
      key: "forEachMolecule",
      value: function forEachMolecule(process) {
        var molecules = this._molecules;
        var n = molecules.length;

        for (var i = 0; i < n; ++i) {
          process(molecules[i]);
        }
      }
    }, {
      key: "forEachSGroup",
      value: function forEachSGroup(process) {
        var groups = this._sgroups;

        for (var i = 0, n = groups.length; i < n; ++i) {
          process(groups[i]);
        }
      }
    }, {
      key: "forEachComponent",
      value: function forEachComponent(process) {
        var components = this._components;

        for (var i = 0, n = components.length; i < n; ++i) {
          process(components[i]);
        }
      }
    }, {
      key: "forEachVisibleComponent",
      value: function forEachVisibleComponent(process) {
        var components = this._components;

        for (var i = 0, n = components.length; i < n; ++i) {
          process(components[i]);
        }
      }
    }, {
      key: "addBond",
      value: function addBond(left, right, order, type, fixed) {
        var bond = new Bond$5(left, right, order, type, fixed);

        this._bonds.push(bond);

        return bond;
      }
    }, {
      key: "getBondCount",
      value: function getBondCount() {
        return this._bonds.length;
      }
    }, {
      key: "getResidueType",
      value: function getResidueType(name) {
        return this._residueTypes[name] || null;
      }
    }, {
      key: "getUnifiedSerial",
      value: function getUnifiedSerial(chain, serial, iCode) {
        var maxSerial = 65536;
        var chainShift = maxSerial * 256;
        return serial + iCode * maxSerial + chain * chainShift;
      }
    }, {
      key: "splitUnifiedSerial",
      value: function splitUnifiedSerial(uniSerial) {
        var maxSerial = 65536;
        var chainShift = maxSerial * 256;
        var chainId = Math.floor(uniSerial / chainShift);
        var remnant = uniSerial - chainId * chainShift;
        var insCode = Math.floor(remnant / maxSerial);
        var ser = remnant - insCode * maxSerial;
        return {
          chain: chainId,
          serial: ser,
          iCode: insCode
        };
      }
    }, {
      key: "_fillCmpEdit",
      value: function _fillCmpEdit() {
        var self = this;
        var components = this._components;

        function addComp() {
          var comp = new Component(self);
          comp._index = components.length;
          components[comp._index] = comp;
          return comp;
        }

        this.forEachChain(function (chain) {
          var residues = chain._residues;
          var resCount = residues.length;

          if (resCount < 1) {
            return;
          }

          var comp = addComp();
          var currStart = residues[0]._index;

          for (var i = 0; i < resCount; ++i) {
            var currRes = residues[i];
            currRes._component = comp;
            var nextRes = i === resCount - 1 ? null : residues[i + 1];

            if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
              comp.setSubDivs([{
                start: currStart,
                end: currRes._index
              }]);

              if (nextRes) {
                currStart = nextRes._index;
                comp = addComp();
              }
            }
          }
        });
      }
    }, {
      key: "_fillCmpNoedit",
      value: function _fillCmpNoedit() {
        var comp = new Component(this);
        comp._index = 0;
        var residues = this._residues;
        var resCount = residues.length;

        if (resCount === 0) {
          return;
        }

        var currSubDivs = [];
        var currStart = 0;

        for (var i = 0; i < resCount; ++i) {
          var currRes = residues[i];
          currRes._component = comp;
          var nextRes = i === resCount - 1 ? null : residues[i + 1];

          if (!nextRes || !currRes.isConnected(nextRes)) {
            currSubDivs[currSubDivs.length] = {
              start: currStart,
              end: i
            };

            if (nextRes) {
              currStart = i + 1;
            }
          }
        }

        comp.setSubDivs(currSubDivs);
        this._components[comp._index] = comp;
      }
    }, {
      key: "_fillComponents",
      value: function _fillComponents(enableEditing) {
        if (enableEditing) {
          this._fillCmpEdit();
        } else {
          this._fillCmpNoedit();
        }
      }
    }, {
      key: "getCurrentUnit",
      value: function getCurrentUnit() {
        return this._currentUnit;
      }
    }, {
      key: "getDefaultBoundaries",
      value: function getDefaultBoundaries() {
        return this.units[0].getBoundaries();
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return this.units[this._currentUnit].getBoundaries();
      }
    }, {
      key: "getTransforms",
      value: function getTransforms() {
        return this.units[this._currentUnit].getTransforms();
      }
    }, {
      key: "getSelector",
      value: function getSelector() {
        return this.units[this._currentUnit].getSelector();
      }
    }, {
      key: "resetCurrentUnit",
      value: function resetCurrentUnit() {
        this._currentUnit = 0;
        this.setCurrentUnit(1);
      }
    }, {
      key: "setCurrentUnit",
      value: function setCurrentUnit(newUnit) {
        if (newUnit !== null && newUnit !== undefined && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
          this._currentUnit = newUnit;
          return true;
        }

        return false;
      }
    }, {
      key: "_computeBounds",
      value: function _computeBounds() {
        var units = this.units;

        for (var i = 0, n = units.length; i < n; ++i) {
          units[i].computeBoundaries();
        }
      }
    }, {
      key: "onAtomPositionChanged",
      value: function onAtomPositionChanged() {
        this.forEachChain(function (a) {
          a._finalize();
        });
        this.forEachComponent(function (c) {
          c.update();
        });

        this._computeBounds();

        this._finalizeBonds();

        this.forEachSGroup(function (s) {
          s._rebuildSGroupOnAtomChange();
        });
      }
    }, {
      key: "update",
      value: function update() {
        if (this._maskNeedsUpdate) {
          this.updateStructuresMask();
          this._maskNeedsUpdate = false;
        }
      }
    }, {
      key: "_finalizeBonds",
      value: function _finalizeBonds() {
        var bonds = this.getBonds();
        var n = bonds.length;

        for (var i = 0; i < n; ++i) {
          bonds[i]._index = i;
        }
      }
    }, {
      key: "finalize",
      value: function finalize(opts) {
        opts = opts || {};
        var bonds = this._bonds;
        var i;
        var n;

        for (i = bonds.length - 1; i >= 0; i--) {
          var bond = bonds[i];

          if (bond._left === null || bond._right === null) {
            bonds.splice(i, 1);
          } else {
            bond._left.bonds.push(bond);

            bond._right.bonds.push(bond);
          }
        }

        var residues = this._residues;

        for (i = 0, n = residues.length; i < n; ++i) {
          residues[i]._finalize();
        }

        this.forEachChain(function (a) {
          a._finalize();
        });
        var units = this.units;

        for (i = 0, n = units.length; i < n; ++i) {
          units[i].finalize();
        }

        this.setCurrentUnit(1);
        var residueHash = {};

        for (i = 0, n = residues.length; i < n; ++i) {
          var res = residues[i];
          residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
        }

        var structures = this.structures;

        for (i = 0, n = structures.length; i < n; ++i) {
          structures[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        var helices = this._helices;

        for (i = 0, n = helices.length; i < n; ++i) {
          helices[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        var sheets = this._sheets;

        for (i = 0, n = sheets.length; i < n; ++i) {
          sheets[i]._finalize(opts.serialAtomMap, residueHash, this);
        }

        this._computeBounds();

        var atoms = this._atoms;

        for (i = 0, n = atoms.length; i < n; ++i) {
          var currAtom = atoms[i];
          currAtom.index = i;
        }

        if (opts.needAutoBonding) {
          var autoConnector = new AutoBond(this);
          autoConnector.build();
          autoConnector.destroy();
        }

        var chains = this._chains;

        for (i = 0, n = chains.length; i < n; ++i) {
          chains[i]._index = i;
        }

        for (i = 0, n = residues.length; i < n; ++i) {
          residues[i]._index = i;
        }

        for (i = 0, n = atoms.length; i < n; ++i) {
          var atom = atoms[i];

          if (atom.flags & Atom$2.Flags.HYDROGEN && atom.bonds.length === 1) {
            var _bond = atom.bonds[0];
            var other = _bond._left !== atom && _bond._left || _bond._right;

            if (other.flags & Atom$2.Flags.CARBON) {
              atom.flags |= Atom$2.Flags.NONPOLARH;
            }
          }
        }

        this._finalizeBonds();

        this._fillComponents(opts.enableEditing);

        var marker = new AromaticLoopsMarker(this);
        marker.markCycles();

        if (opts.detectAromaticLoops) {
          marker.detectCycles();
        }

        this._finalizeMolecules();
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        for (var i = 0; i < this._molecules.length; i++) {
          var molecule = this._molecules[i];
          var count = molecule.residues.length;

          for (var j = 0; j < count; j++) {
            var residue = molecule.residues[j];
            residue._molecule = molecule;
          }
        }
      }
    }, {
      key: "updateStructuresMask",
      value: function updateStructuresMask() {
        var updater = function updater(structure) {
          return structure.collectMask();
        };

        this.forEachResidue(updater);
        this.forEachChain(updater);
        this.forEachMolecule(updater);
      }
    }, {
      key: "countAtomsByMask",
      value: function countAtomsByMask(mask) {
        var count = 0;
        this.forEachAtom(function (atom) {
          if ((atom.mask & mask) !== 0) {
            count++;
          }
        });
        return count;
      }
    }, {
      key: "getNumAtomsBySelector",
      value: function getNumAtomsBySelector(selector) {
        var count = 0;
        this.forEachAtom(function (atom) {
          if (selector.includesAtom(atom)) {
            count++;
          }
        });
        return count;
      }
    }, {
      key: "resetAtomMask",
      value: function resetAtomMask(mask) {
        this.forEachAtom(function (atom) {
          atom.mask = mask;
        });
      }
    }, {
      key: "markAtoms",
      value: function markAtoms(selector, mask) {
        var setMask = mask;
        var clearMask = ~setMask;
        var count = 0;
        var totalSelector = selectors$5.keyword('And')(selector, this.getSelector());
        this.forEachAtom(function (atom) {
          if (totalSelector.includesAtom(atom)) {
            atom.mask |= setMask;
            count++;
          } else {
            atom.mask &= clearMask;
          }
        });
        this._maskNeedsUpdate = true;
        return count;
      }
    }, {
      key: "markAtomsAdditionally",
      value: function markAtomsAdditionally(selector, mask) {
        var setMask = mask;
        var count = 0;
        this.forEachAtom(function (atom) {
          if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
            atom.mask |= setMask;
            count++;
          }
        });
        return count;
      }
    }, {
      key: "clearAtomBits",
      value: function clearAtomBits(mask) {
        var clearMask = ~mask;
        this.forEachAtom(function (atom) {
          atom.mask &= clearMask;
        });

        var reseter = function reseter(a) {
          a._mask &= clearMask;
        };

        this.forEachAtom(reseter);
        this.forEachResidue(reseter);
        this.forEachChain(reseter);
        this.forEachMolecule(reseter);
      }
    }, {
      key: "getAtomNames",
      value: function getAtomNames() {
        if (this.hasOwnProperty('_atomNames')) {
          return this._atomNames;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[atom.name] = 1;
        });
        this._atomNames = Object.keys(dict);
        return this._atomNames;
      }
    }, {
      key: "getElements",
      value: function getElements() {
        if (this.hasOwnProperty('_elements')) {
          return this._elements;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[atom.element.name] = 1;
        });
        this._elements = Object.keys(dict);
        return this._elements;
      }
    }, {
      key: "getResidueNames",
      value: function getResidueNames() {
        if (this.hasOwnProperty('_residueNames')) {
          return this._residueNames;
        }

        var dict = {};
        this.forEachResidue(function (res) {
          dict[res._type._name] = 1;
        });
        this._residueNames = Object.keys(dict);
        return this._residueNames;
      }
    }, {
      key: "getChainNames",
      value: function getChainNames() {
        if (this.hasOwnProperty('_chainNames')) {
          return this._chainNames;
        }

        var dict = {};
        this.forEachChain(function (chain) {
          dict[chain._name] = 1;
        });
        this._chainNames = Object.keys(dict);
        return this._chainNames;
      }
    }, {
      key: "getAltLocNames",
      value: function getAltLocNames() {
        if (this.hasOwnProperty('_altlocNames')) {
          return this._altlocNames;
        }

        var dict = {};
        this.forEachAtom(function (atom) {
          dict[String.fromCharCode(atom.location)] = 1;
        });
        this._altlocNames = Object.keys(dict);
        return this._altlocNames;
      }
    }, {
      key: "getVoxelWorld",
      value: function getVoxelWorld() {
        if (!this.hasOwnProperty('_voxelWorld')) {
          try {
            this._voxelWorld = new VoxelWorld(this.getDefaultBoundaries().boundingBox, new THREE__namespace.Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));

            this._voxelWorld.addAtoms(this);
          } catch (e) {
            logger.warn('Unable to create voxel world');
            this._voxelWorld = null;
          }
        }

        return this._voxelWorld;
      }
    }, {
      key: "addElement",
      value: function addElement(srcArray, dstArray, param, functor) {
        var length = srcArray.length;

        for (var i = 0; i < length; ++i) {
          var elem = srcArray[i];
          functor(elem, param);
          dstArray.push(elem);
        }
      }
    }, {
      key: "joinComplexes",
      value: function joinComplexes(complexes) {
        this._chains = [];
        this._components = [];
        this._helices = [];
        this._sheets = [];
        this.structures = [];
        this._atoms = [];
        this._residues = [];
        this._bonds = [];
        this._sgroups = [];
        var self = this;
        var atomBias = 0;
        var bondBias = 0;
        var residueBias = 0;
        var chainBias = 0;
        var componentBias = 0;

        function processAtom(atom, bias) {
          atom.serial += bias;
          atom.index += bias;
        }

        function processBond(bond, bias) {
          bond._index += bias;
        }

        function processResidue(residue, bias) {
          residue._index += bias;
        }

        function processChain(chain, bias) {
          chain._complex = self;
          chain._index += bias;
        }

        function processComponent(component, bias) {
          component._complex = self;
          component._index += bias;
        }

        function doNothing() {}

        for (var i = 0; i < complexes.length; ++i) {
          var c = complexes[i];
          this.addElement(c._atoms, this._atoms, atomBias, processAtom);
          this.addElement(c._bonds, this._bonds, bondBias, processBond);
          this.addElement(c._residues, this._residues, residueBias, processResidue);
          this.addElement(c._chains, this._chains, chainBias, processChain);
          this.addElement(c._sheets, this._sheets, 0, doNothing);
          this.addElement(c._helices, this._helices, 0, doNothing);
          this.addElement(c._sgroups, this._sgroups, 0, doNothing);
          this.addElement(c._components, this._components, componentBias, processComponent);
          this.addElement(c.structures, this.structures, 0, doNothing);

          for (var rt in c._residueTypes) {
            if (c._residueTypes.hasOwnProperty(rt)) {
              this._residueTypes[rt] = c._residueTypes[rt];
            }
          }

          atomBias += c._atoms.length;
          bondBias += c._bonds.length;
          residueBias += c._residues.length;
          chainBias += c._chains.length;
          componentBias += c._components.length;
        }

        this._computeBounds();
      }
    }, {
      key: "dssp",
      value: function dssp() {
        var ssMap = new SecondaryStructureMap(this);
        var structures = this.structures = [];
        var helices = this._helices = [];
        var sheets = this._sheets = [];

        var getSheet = function getSheet(index) {
          var item = sheets[index];

          if (!item) {
            item = sheets[index] = new Sheet$3(String(index), 0);
          }

          return item;
        };

        var lastCode;
        var lastSheetIndex;
        var lastHelixIndex = 0;
        var curStructure = null;

        for (var i = 0, n = this._residues.length; i < n; ++i) {
          var curCode = ssMap._ss[i];
          var curResidue = this._residues[i];
          var curSheetIndex = ssMap._sheet[i];

          if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
            curResidue._secondary = curStructure;

            if (curStructure) {
              curStructure.term = curResidue;
            }

            if (curStructure instanceof Helix$3) {
              curStructure.length++;
            }

            continue;
          }

          var helixClass = helixClassMap[curCode];
          var loopType = loopMap[curCode];

          if (curCode === StructureType.STRAND) {
            var curSheet = getSheet(curSheetIndex);
            curStructure = new Strand$3(curSheet, curResidue, curResidue, 0, null, null);
            curSheet.addStrand(curStructure);
          } else if (helixClass !== undefined) {
            lastHelixIndex++;
            curStructure = new Helix$3(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), '', 1);
            helices.push(curStructure);
          } else if (loopType !== undefined) {
            curStructure = new StructuralElement(loopType, curResidue, curResidue);
          } else {
            curStructure = null;
          }

          if (curStructure) {
            structures.push(curStructure);
          }

          curResidue._secondary = curStructure;
          lastCode = curCode;
          lastSheetIndex = curSheetIndex;
        }

        this._sheets = sheets.filter(function (_sheet) {
          return true;
        });
      }
    }]);

    return Complex;
  }();

  Complex$9.prototype.id = 'Complex';
  Complex$9.prototype.name = '';

  function pow2ceil(v) {
    var p = 2;
    v = v - 1 >> 1;

    while (v) {
      p <<= 1;
      v >>= 1;
    }

    return p;
  }

  var Volume$2 = /*#__PURE__*/function () {
    function Volume(type, dimensions, box, vecSize, data, volumeInfo) {
      _classCallCheck(this, Volume);

      this._box = box.clone();
      this._dimVec = Math.max(Math.floor(vecSize || 1), 1);
      this._volumeInfo = volumeInfo;

      if (dimensions instanceof Array) {

        var _dimensions = _slicedToArray(dimensions, 3);

        this._dimX = _dimensions[0];
        this._dimY = _dimensions[1];
        this._dimZ = _dimensions[2];
      } else {
        this._dimX = dimensions.x;
        this._dimY = dimensions.y;
        this._dimZ = dimensions.z;
      }

      this._dimX = Math.max(Math.floor(this._dimX), 1);
      this._dimY = Math.max(Math.floor(this._dimY), 1);
      this._dimZ = Math.max(Math.floor(this._dimZ), 1);
      this._rowElements = this._dimVec * this._dimX;
      this._planeElements = this._rowElements * this._dimY;
      this._totalElements = this._planeElements * this._dimZ;
      this._data = data || utils.allocateTyped(type, this._totalElements);

      switch (this._dimVec) {
        case 1:
          break;

        case 2:
          this.getValue = function (x, y, z) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            return [this._data[idx], this._data[idx + 1]];
          };

          this.setValue = function (x, y, z, a, b) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] = a;
            this._data[idx + 1] = b;
          };

          this.addValue = function (x, y, z, a, b) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] += a;
            this._data[idx + 1] += b;
          };

          break;

        case 3:
          this.getValue = function (x, y, z) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
          };

          this.setValue = function (x, y, z, a, b, c) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] = a;
            this._data[idx + 1] = b;
            this._data[idx + 2] = c;
          };

          this.addValue = function (x, y, z, a, b, c) {
            var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
            this._data[idx] += a;
            this._data[idx + 1] += b;
            this._data[idx + 2] += c;
          };

          break;

        default:
          throw new Error('Volume: invalid vector dimension');
      }
    }

    _createClass(Volume, [{
      key: "getValue",
      value: function getValue(x, y, z) {
        return this._data[x + y * this._rowElements + z * this._planeElements];
      }
    }, {
      key: "setValue",
      value: function setValue(x, y, z, val) {
        this._data[x + y * this._rowElements + z * this._planeElements] = val;
      }
    }, {
      key: "addValue",
      value: function addValue(x, y, z, val) {
        this._data[x + y * this._rowElements + z * this._planeElements] += val;
      }
    }, {
      key: "getDimensions",
      value: function getDimensions() {
        return [this._dimX, this._dimY, this._dimZ];
      }
    }, {
      key: "getBox",
      value: function getBox() {
        return this._box;
      }
    }, {
      key: "getVolumeInfo",
      value: function getVolumeInfo() {
        return this._volumeInfo;
      }
    }, {
      key: "getCellSize",
      value: function getCellSize() {
        var boxSize = new THREE__namespace.Vector3();

        this._box.getSize(boxSize);

        var res = new THREE__namespace.Vector3();
        res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
        res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
        res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
        return res;
      }
    }, {
      key: "computeGradient",
      value: function computeGradient() {
        if (this._dimVec !== 1) {
          return null;
        }

        var gradient = new Volume(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3);
        var vl = this.getCellSize();
        var vs = new THREE__namespace.Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z);

        function clamp(val, min, max) {
          return Math.min(max, Math.max(min, val));
        }

        var xSize = this._dimX;
        var ySize = this._dimY;
        var zSize = this._dimZ;
        var volMap = this._data;

        function _voxelValue(x, y, z) {
          return volMap[z * xSize * ySize + y * xSize + x];
        }

        for (var zi = 0; zi < zSize; ++zi) {
          var zm = clamp(zi - 1, 0, zSize - 1);
          var zp = clamp(zi + 1, 0, zSize - 1);

          for (var yi = 0; yi < ySize; ++yi) {
            var ym = clamp(yi - 1, 0, ySize - 1);
            var yp = clamp(yi + 1, 0, ySize - 1);

            for (var xi = 0; xi < xSize; ++xi) {
              var xm = clamp(xi - 1, 0, xSize - 1);
              var xp = clamp(xi + 1, 0, xSize - 1);
              gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
            }
          }
        }

        return gradient;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        var data = this._data;
        var min = data[0];
        var max = data[0];

        for (var i = 1; i < data.length; ++i) {
          min = Math.min(min, data[i]);
          max = Math.max(max, data[i]);
        }

        var d = 1.0 / (max - min);

        if (d === 0) {
          return;
        }

        for (var _i = 0; _i < data.length; ++_i) {
          data[_i] = d * (data[_i] - min);
        }
      }
    }, {
      key: "getTiledTextureStride",
      value: function getTiledTextureStride() {
        return [this._dimX + 2, this._dimY + 2];
      }
    }, {
      key: "buildTiledTexture",
      value: function buildTiledTexture() {
        var tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));
        var width = tilesX * (this._dimX + 2) - 1;
        width = pow2ceil(width);
        tilesX = Math.floor(width / (this._dimX + 2));
        var tilesY = Math.ceil(this._dimZ / tilesX);
        var height = tilesY * (this._dimY + 2) - 1;
        height = pow2ceil(height);
        var data = new Uint8Array(width * height);
        var src;
        var dst;

        for (var tileRow = 0; tileRow < tilesY; ++tileRow) {
          for (var row = 0; row < this._dimY; ++row) {
            src = tileRow * tilesX * this._planeElements + row * this._rowElements;
            dst = width * (tileRow * (this._dimY + 2) + row);

            for (var t = 0; t < tilesX; ++t) {
              for (var x = 0; x < this._dimX; ++x) {
                data[dst++] = 255.0 * this._data[src++];
              }

              data[dst++] = 255.0 * this._data[src - 1];

              if (t < tilesX - 1) {
                src += this._planeElements - this._rowElements;
                data[dst++] = 255.0 * this._data[src];
              }
            }
          }
        }

        for (var _tileRow = 0; _tileRow < tilesY; ++_tileRow) {
          src = width * (_tileRow * (this._dimY + 2) + this._dimY - 1);
          dst = src + width;

          for (var _x = 0; _x < width; ++_x) {
            data[dst++] = data[src++];
          }

          if (_tileRow < tilesY - 1) {
            src = width * (_tileRow + 1) * (this._dimY + 2);
            dst = src - width;

            for (var _x2 = 0; _x2 < width; ++_x2) {
              data[dst++] = data[src++];
            }
          }
        }

        var texture = new THREE__namespace.DataTexture(data, width, height, THREE__namespace.LuminanceFormat, THREE__namespace.UnsignedByteType, THREE__namespace.UVMapping, THREE__namespace.ClampToEdgeWrapping, THREE__namespace.ClampToEdgeWrapping, THREE__namespace.LinearFilter, THREE__namespace.LinearFilter);
        texture.needsUpdate = true;
        return texture;
      }
    }, {
      key: "getData",
      value: function getData() {
        return this._data;
      }
    }, {
      key: "getDirectIdx",
      value: function getDirectIdx(x, y, z) {
        return x * this._dimVec + y * this._rowElements + z * this._planeElements;
      }
    }, {
      key: "getStrideX",
      value: function getStrideX() {
        return this._dimVec;
      }
    }, {
      key: "getStrideY",
      value: function getStrideY() {
        return this._rowElements;
      }
    }, {
      key: "getStrideZ",
      value: function getStrideZ() {
        return this._planeElements;
      }
    }]);

    return Volume;
  }();

  Volume$2.prototype.id = 'Volume';

  var Molecule$8 = /*#__PURE__*/function () {
    function Molecule(complex, name, index) {
      _classCallCheck(this, Molecule);

      this.complex = complex;
      this.name = name || '';
      this.residues = [];
      this.mask = 1 | 0;
      this.index = index || -1;
    }

    _createClass(Molecule, [{
      key: "forEachResidue",
      value: function forEachResidue(process) {
        var residues = this.residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          process(residues[i]);
        }
      }
    }, {
      key: "collectMask",
      value: function collectMask() {
        var mask = 0xffffffff;
        var residues = this.residues;

        for (var i = 0, n = residues.length; i < n; ++i) {
          mask &= residues[i]._mask;
        }

        this.mask = mask;
      }
    }]);

    return Molecule;
  }();

  var chem = {
    Atom: Atom$2,
    Element: Element$a,
    Bond: Bond$5,
    Residue: Residue$1,
    ResidueType: ResidueType$1,
    Chain: Chain$2,
    Helix: Helix$3,
    Strand: Strand$3,
    Sheet: Sheet$3,
    SGroup: SGroup$1,
    Assembly: Assembly$3,
    Complex: Complex$9,
    Volume: Volume$2,
    VoxelWorld: VoxelWorld,
    selectors: selectors$5,
    Molecule: Molecule$8
  };

  function _createSuper$1U(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1U(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1U() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var CSS2DObject = /*#__PURE__*/function (_THREE$Object3D) {
    _inherits(CSS2DObject, _THREE$Object3D);

    var _super = _createSuper$1U(CSS2DObject);

    function CSS2DObject(element) {
      var _this;

      _classCallCheck(this, CSS2DObject);

      _this = _super.call(this);

      var self = _assertThisInitialized(_this);

      _this._element = element;
      _this._element.style.position = 'absolute';

      _this.addEventListener('removed', function () {
        if (self._element.parentNode !== null) {
          self._element.parentNode.removeChild(self._element);
        }
      });

      return _this;
    }

    _createClass(CSS2DObject, [{
      key: "getElement",
      value: function getElement() {
        return this._element;
      }
    }, {
      key: "setTransparency",
      value: function setTransparency(transp) {
        var el = this.getElement();

        if (el === null) {
          return;
        }

        if (transp === 1.0) {
          el.style.display = 'none';
          return;
        }

        el.style.display = 'inline';
        var op = 1.0 - transp;
        var top = op.toString();
        var op100 = op * 100;
        el.style.opacity = top;
        el.style.filter = "alpha(opacity=".concat(op100, ")");
      }
    }, {
      key: "clone",
      value: function clone() {
        var obj = new CSS2DObject(this._element);
        obj.copy(this);
        return obj;
      }
    }]);

    return CSS2DObject;
  }(THREE__namespace.Object3D);

  function _createSuper$1T(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1T(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1T() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var RCGroup = /*#__PURE__*/function (_THREE$Group) {
    _inherits(RCGroup, _THREE$Group);

    var _super = _createSuper$1T(RCGroup);

    function RCGroup() {
      _classCallCheck(this, RCGroup);

      return _super.apply(this, arguments);
    }

    _createClass(RCGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (!this.visible) {
          return;
        }

        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          children[i].raycast(raycaster, intersects);
        }
      }
    }, {
      key: "enableSubset",
      value: function enableSubset(mask, innerOnly) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].enableSubset) {
            children[i].enableSubset(mask, innerOnly);
          }
        }
      }
    }, {
      key: "disableSubset",
      value: function disableSubset(mask, innerOnly) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].disableSubset) {
            children[i].disableSubset(mask, innerOnly);
          }
        }
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.children.length === 0;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].updateToFrame) {
            children[i].updateToFrame(frameData);
          }
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            Array.prototype.push.apply(totalSubset, children[i].getSubset(mask, innerOnly));
          }
        }

        return totalSubset;
      }
    }]);

    return RCGroup;
  }(THREE__namespace.Group);

  var vertexScreenQuadShader = "uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec2 uv;\r\nattribute vec3 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n";

  var fragmentScreenQuadFromTex = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color = texture2D(srcTex, vUv);\r\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\r\n}\r\n";

  var fragmentScreenQuadFromTexWithDistortion = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float coef;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  float r2 = dot(uv, uv);\r\n  vec2 tc = uv * (1.0 + coef * r2);\r\n  if (!all(lessThan(abs(tc), vec2(1.0))))\r\n    discard;\r\n  tc = 0.5 * (tc + 1.0);\r\n  gl_FragColor = texture2D(srcTex, tc);\r\n}\r\n";

  function _createSuper$1S(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1S(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1S() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var LAYERS = {
    DEFAULT: 0,
    VOLUME: 1,
    TRANSPARENT: 2,
    PREPASS_TRANSPARENT: 3,
    VOLUME_BFPLANE: 4,
    COLOR_FROM_POSITION: 5,
    SHADOWMAP: 6
  };
  var SELECTION_LAYERS = [LAYERS.DEFAULT, LAYERS.TRANSPARENT];

  THREE__namespace.Object3D.prototype.resetTransform = function () {
    this.position.set(0, 0, 0);
    this.quaternion.set(0, 0, 0, 1);
    this.scale.set(1, 1, 1);
  };

  THREE__namespace.Object3D.prototype.updateMatrixWorldRecursive = function () {
    if (this.parent != null) {
      this.parent.updateMatrixWorldRecursive();
    }

    this.updateMatrixWorld();
  };

  THREE__namespace.Object3D.prototype.addSavingWorldTransform = function () {
    var _worldMatrixInverse = new THREE__namespace.Matrix4();

    return function (object) {
      if (object instanceof THREE__namespace.Object3D) {
        _worldMatrixInverse.copy(this.matrixWorld).invert();

        _worldMatrixInverse.multiply(object.matrixWorld);

        object.matrix.copy(_worldMatrixInverse);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
        this.add(object);
      }
    };
  }();

  THREE__namespace.WebGLRenderer.prototype.renderDummyQuad = function () {
    var _material = new THREE__namespace.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
      depthWrite: false
    });

    var _scene = new THREE__namespace.Scene();

    var _quad = new THREE__namespace.Mesh(new THREE__namespace.PlaneBufferGeometry(0.01, 0.01), _material);

    _scene.add(_quad);

    var _camera = new THREE__namespace.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);

    _camera.position.z = 100;
    return function () {
      this.render(_scene, _camera);
    };
  }();

  THREE__namespace.WebGLRenderer.prototype.renderScreenQuad = function () {
    var _scene = new THREE__namespace.Scene();

    var _quad = new THREE__namespace.Mesh(new THREE__namespace.PlaneBufferGeometry(1.0, 1.0));

    _scene.add(_quad);

    var _camera = new THREE__namespace.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);

    _camera.position.z = 100;
    return function (material) {
      _quad.material = material;
      this.render(_scene, _camera);
    };
  }();

  THREE__namespace.Matrix4.prototype.isIdentity = function () {
    var identity = new THREE__namespace.Matrix4();
    return function () {
      return identity.equals(this);
    };
  }();

  THREE__namespace.Matrix4.prototype.applyToPointsArray = function (array, stride, w) {
    if (!array || !stride || stride < 3) {
      return array;
    }

    w = w || 0;
    var e = this.elements;

    for (var i = 0; i < array.length; i += stride) {
      var x = array[i];
      var y = array[i + 1];
      var z = array[i + 2];
      var persp = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      array[i] = (e[0] * x + e[4] * y + e[8] * z + e[12] * w) * persp;
      array[i + 1] = (e[1] * x + e[5] * y + e[9] * z + e[13] * w) * persp;
      array[i + 2] = (e[2] * x + e[6] * y + e[10] * z + e[14] * w) * persp;
    }

    return array;
  };

  var ScreenQuadMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(ScreenQuadMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1S(ScreenQuadMaterial);

    function ScreenQuadMaterial(params) {
      _classCallCheck(this, ScreenQuadMaterial);

      if (params.uniforms === undefined) {
        params.uniforms = {};
      }

      params.uniforms.srcTex = {
        type: 't',
        value: null
      };
      params.vertexShader = vertexScreenQuadShader;
      params.transparent = false;
      params.depthTest = false;
      params.depthWrite = false;
      return _super.call(this, params);
    }

    return ScreenQuadMaterial;
  }(THREE__namespace.RawShaderMaterial);

  THREE__namespace.WebGLRenderer.prototype.renderScreenQuadFromTex = function () {
    var _material = new ScreenQuadMaterial({
      uniforms: {
        opacity: {
          type: 'f',
          value: 1.0
        }
      },
      fragmentShader: fragmentScreenQuadFromTex,
      transparent: true
    });

    return function (srcTex, opacity) {
      _material.uniforms.srcTex.value = srcTex;
      _material.transparent = opacity < 1.0;
      _material.uniforms.opacity.value = opacity;
      this.renderScreenQuad(_material);
    };
  }();

  THREE__namespace.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function () {
    var _material = new ScreenQuadMaterial({
      uniforms: {
        coef: {
          type: 'f',
          value: 1.0
        }
      },
      fragmentShader: fragmentScreenQuadFromTexWithDistortion
    });

    return function (srcTex, coef) {
      _material.uniforms.srcTex.value = srcTex;
      _material.uniforms.coef.value = coef;
      this.renderScreenQuad(_material);
    };
  }();

  THREE__namespace.PerspectiveCamera.prototype.setMinimalFov = function (angle) {
    if (this.aspect >= 1.0) {
      this.fov = angle;
    } else {
      this.fov = THREE__namespace.MathUtils.radToDeg(2 * Math.atan(Math.tan(THREE__namespace.MathUtils.degToRad(angle) * 0.5) / this.aspect));
    }
  };

  THREE__namespace.StereoCamera.prototype.updateHalfSized = function (camera, angle) {
    var originalAspect = camera.aspect;
    var originalFov = camera.fov;
    camera.aspect = originalAspect / 2.0;
    camera.setMinimalFov(angle);
    camera.updateProjectionMatrix();
    this.update(camera);
    camera.aspect = originalAspect;
    camera.fov = originalFov;
    camera.updateProjectionMatrix();
  };

  THREE__namespace.PerspectiveCamera.prototype.setDistanceToFit = function (radius, angle) {
    this.position.z = radius / Math.sin(0.5 * THREE__namespace.MathUtils.degToRad(angle));
  };

  THREE__namespace.Raycaster.prototype.intersectVisibleObject = function (gfxObj, camera, clipPlane, fogFarPlane) {
    var intersects = this.intersectObject(gfxObj, false);

    if (intersects.length === 0) {
      return null;
    }

    var nearPlane = Math.min(camera.near, clipPlane);
    var i;
    var p = intersects[0];
    var v = new THREE__namespace.Vector3();

    for (i = 0; i < intersects.length; ++i) {
      p = intersects[i];
      v.copy(p.point);
      v.applyMatrix4(camera.matrixWorldInverse);

      if (v.z <= -nearPlane) {
        break;
      }
    }

    if (i === intersects.length) {
      return null;
    }

    var farPlane = Math.min(camera.far, fogFarPlane);
    v.copy(p.point);
    v.applyMatrix4(camera.matrixWorldInverse);

    if (v.z <= -farPlane) {
      return null;
    }

    return p;
  };

  THREE__namespace.Matrix4.prototype.extractScale = function () {
    var _v = new THREE__namespace.Vector3();

    return function (scale) {
      if (scale === undefined) {
        logger.debug('extractScale(): new is too expensive operation to do it on-the-fly');
        scale = _v.clone();
      }

      var te = this.elements;
      scale.x = _v.set(te[0], te[1], te[2]).length();
      scale.y = _v.set(te[4], te[5], te[6]).length();
      scale.z = _v.set(te[8], te[9], te[10]).length();
      var det = this.determinant();

      if (det < 0) {
        scale.x = -scale.x;
      }

      return scale;
    };
  }();

  function _calcCylinderMatrix(posBegin, posEnd, radius) {
    var posCenter = posBegin.clone().lerp(posEnd, 0.5);
    var matScale = new THREE__namespace.Matrix4();
    matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
    var matRotHalf = new THREE__namespace.Matrix4();
    matRotHalf.makeRotationX(Math.PI / 2);
    var matRotLook = new THREE__namespace.Matrix4();
    var vUp = new THREE__namespace.Vector3(0, 1, 0);
    matRotLook.lookAt(posCenter, posEnd, vUp);
    matRotLook.multiply(matRotHalf);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(posCenter);
    return matRotLook;
  }

  function _calcChunkMatrix(eye, target, up, rad) {
    var matScale = new THREE__namespace.Matrix4();
    matScale.makeScale(rad.x, rad.y, 0);
    var matRotLook = new THREE__namespace.Matrix4();
    matRotLook.lookAt(eye, target, up);
    matRotLook.multiply(matScale);
    matRotLook.setPosition(eye);
    return matRotLook;
  }

  function _groupHasGeometryToRender(group) {
    var hasGeoms = false;
    group.traverse(function (node) {
      if (node.hasOwnProperty('geometry') || node instanceof CSS2DObject) {
        hasGeoms = true;
      }
    });
    return hasGeoms;
  }

  function _buildDistorionMesh(widthSegments, heightSegements, coef) {
    function calcInverseBarrel(r2) {
      var epsilon = 1e-5;
      var prevR2 = 0.0;
      var curR2 = r2;
      var dr = 1.0;

      while (Math.abs(curR2 - prevR2) > epsilon) {
        dr = 1.0 + coef * curR2;
        prevR2 = curR2;
        curR2 = r2 / (dr * dr);
      }

      return 1.0 / dr;
    }

    var geo = new THREE__namespace.PlaneBufferGeometry(2.0, 2.0, widthSegments, heightSegements);
    var pos = geo.getAttribute('position');

    for (var i = 0; i < pos.count; ++i) {
      var x = pos.array[3 * i];
      var y = pos.array[3 * i + 1];
      var c = calcInverseBarrel(x * x + y * y);
      pos.setXY(i, c * x, c * y);
    }

    return geo;
  }

  THREE__namespace.BufferAttribute.prototype.copyAtList = function (attribute, indexList) {
    console.assert(this.itemSize === attribute.itemSize, 'false: BufferAttribute.copyAtList buffers have different item size.');
    var itemSize = this.itemSize;

    for (var i = 0, n = indexList.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        this.array[i * itemSize + j] = attribute.array[indexList[i] * itemSize + j];
      }
    }

    return this;
  };

  function fillArray(array, value, startIndex, endIndex) {
    startIndex = typeof startIndex !== 'undefined' ? startIndex : 0;
    endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length;

    for (var i = startIndex; i < endIndex; ++i) {
      array[i] = value;
    }
  }

  function removeChildren(object) {
    var children = object.children;

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];
      child.parent = null;
      child.dispatchEvent({
        type: 'removed'
      });
    }

    object.children = [];
  }

  function clearTree(object) {
    object.traverse(function (obj) {
      if (obj instanceof THREE__namespace.Mesh || obj instanceof THREE__namespace.LineSegments || obj instanceof THREE__namespace.Line) {
        obj.geometry.dispose();
      }
    });
    removeChildren(object);
  }

  function destroyObject(object) {
    clearTree(object);

    if (object.parent) {
      object.parent.remove(object);
    } else {
      object.dispatchEvent({
        type: 'removed'
      });
    }
  }

  function belongToSelectLayers(object) {
    for (var i = 0; i < SELECTION_LAYERS.length; i++) {
      if ((object.layers.mask >> SELECTION_LAYERS[i] & 1) === 1) {
        return true;
      }
    }

    return false;
  }

  function processObjRenderOrder(root, idMaterial) {
    var renderOrder = +(idMaterial !== 'BA');
    root.traverse(function (object) {
      if (object.isGroup) {
        object.renderOrder = renderOrder;
      }
    });
  }

  function applySelectionMaterial(geo) {
    geo.traverse(function (node) {
      if ('material' in node) {
        node.material = node.material.clone(true);
        node.material.setValues({
          depthFunc: THREE__namespace.LessEqualDepth,
          overrideColor: true,
          fog: false,
          lights: false,
          shadowmap: false
        });
        node.material.setUberOptions({
          fixedColor: new THREE__namespace.Color(0xffff00),
          zOffset: -1e-6
        });
      }
    });
  }

  function getMiddlePoint(point1, point2, optionalTarget) {
    var result = optionalTarget || new THREE__namespace.Vector3();
    result.set(0, 0, 0);
    result.addScaledVector(point1, 0.5);
    result.addScaledVector(point2, 0.5);
    return result;
  }

  var _oldInstancedBufferGeometryCopy = THREE__namespace.InstancedBufferGeometry.prototype.copy;

  THREE__namespace.InstancedBufferGeometry.prototype.copy = function (source) {
    _oldInstancedBufferGeometryCopy.call(this, source);

    if (this.instanceCount === undefined) {
      this.instanceCount = Infinity;
    }
  };

  var gfxutils = {
    calcCylinderMatrix: _calcCylinderMatrix,
    calcChunkMatrix: _calcChunkMatrix,
    groupHasGeometryToRender: _groupHasGeometryToRender,
    buildDistorionMesh: _buildDistorionMesh,
    RCGroup: RCGroup,
    fillArray: fillArray,
    clearTree: clearTree,
    destroyObject: destroyObject,
    belongToSelectLayers: belongToSelectLayers,
    processObjRenderOrder: processObjRenderOrder,
    applySelectionMaterial: applySelectionMaterial,
    getMiddlePoint: getMiddlePoint,
    LAYERS: LAYERS
  };

  function _createSuper$1R(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1R(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1R() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var _defaultBoundaries = {
    boundingBox: new THREE__namespace.Box3(new THREE__namespace.Vector3(-1, -1, -1), new THREE__namespace.Vector3(1, 1, 1)),
    boundingSphere: new THREE__namespace.Sphere(new THREE__namespace.Vector3(0, 0, 0), 1)
  };

  var Visual = /*#__PURE__*/function (_gfxutils$RCGroup) {
    _inherits(Visual, _gfxutils$RCGroup);

    var _super = _createSuper$1R(Visual);

    function Visual(name, dataSource) {
      var _this;

      _classCallCheck(this, Visual);

      _this = _super.call(this, name, dataSource);
      _this.name = name;
      _this._dataSource = dataSource;
      return _this;
    }

    _createClass(Visual, [{
      key: "release",
      value: function release() {
        if (this.parent) {
          this.parent.remove(this);
        }
      }
    }, {
      key: "getDataSource",
      value: function getDataSource() {
        return this._dataSource;
      }
    }, {
      key: "getBoundaries",
      value: function getBoundaries() {
        return _defaultBoundaries;
      }
    }]);

    return Visual;
  }(gfxutils.RCGroup);

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  function _ensureArray(x) {
    if (x === null || x === undefined || Array.isArray(x)) {
      return x;
    }

    return [x];
  }

  var EntityList = /*#__PURE__*/function () {
    function EntityList() {
      var _this = this;

      var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['id'];

      _classCallCheck(this, EntityList);

      this._list = [];
      this._dict = {};
      this._indices = _toConsumableArray(indices);

      this._indices.forEach(function (index) {
        _this._dict[index] = {};
      });

      entities.forEach(function (entity) {
        return _this.register(entity);
      });
    }

    _createClass(EntityList, [{
      key: "register",
      value: function register(entity) {
        var _this2 = this;

        EntityList.registerInList(this._list, entity);

        this._indices.forEach(function (index) {
          EntityList.registerInDict(_this2._dict[index], _ensureArray(entity[index]), entity);
        });
      }
    }, {
      key: "unregister",
      value: function unregister(entity) {
        var _this3 = this;

        EntityList.unregisterFromList(this._list, entity);

        this._indices.forEach(function (index) {
          EntityList.unregisterFromDict(_this3._dict[index], _ensureArray(entity[index]), entity);
        });
      }
    }, {
      key: "all",
      get: function get() {
        return _toConsumableArray(this._list);
      }
    }, {
      key: "first",
      get: function get() {
        return this._list[0];
      }
    }, {
      key: "keys",
      value: function keys(index) {
        return Object.keys(this._dict[index || this._indices[0]]);
      }
    }, {
      key: "get",
      value: function get(key, index) {
        var dict = this._dict[index || this._indices[0]];

        if (dict) {
          var values = dict[key && key.toLowerCase()];
          return values && values.length > 0 ? values[0] : undefined;
        }

        return undefined;
      }
    }], [{
      key: "registerInList",
      value: function registerInList(list, value) {
        if (!list.includes(value)) {
          list.push(value);
        }
      }
    }, {
      key: "unregisterFromList",
      value: function unregisterFromList(list, value) {
        var pos = list.indexOf(value);

        if (pos !== -1) {
          list.splice(pos, 1);
        }
      }
    }, {
      key: "registerInDict",
      value: function registerInDict(dict, keys, value) {
        keys.forEach(function (key) {
          key = key.toLowerCase();
          var list = dict[key] = dict[key] || [];

          if (!list.includes(value)) {
            list.push(value);
          }
        });
      }
    }, {
      key: "unregisterFromDict",
      value: function unregisterFromDict(dict, keys, value) {
        keys.forEach(function (key) {
          key = key.toLowerCase();
          var list = dict[key];

          if (list) {
            var pos = list.indexOf(value);

            if (pos !== -1) {
              list.splice(pos, 1);
            }

            if (list.length === 0) {
              delete dict[key];
            }
          }
        });
      }
    }]);

    return EntityList;
  }();

  function makeContextDependent(prototype) {
    Object.defineProperties(prototype, {
      logger: {
        get: function get() {
          return this.context && this.context.logger ? this.context.logger : logger;
        }
      },
      settings: {
        get: function get() {
          return this.context && this.context.settings ? this.context.settings : settings$1;
        }
      }
    });
  }

  function _createSuper$1Q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1Q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1Q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var CollisionSphere = /*#__PURE__*/function () {
    function CollisionSphere(position, radius) {
      _classCallCheck(this, CollisionSphere);

      this._position = position;
      this._radius = radius;
    }

    _createClass(CollisionSphere, [{
      key: "raycast",
      value: function raycast(raycaster) {
        var sphere = CollisionSphere._sphere;
        sphere.set(this._position, this._radius);
        var p = new THREE__namespace.Vector3();

        if (raycaster.ray.intersectSphere(sphere, p)) {
          return {
            distance: raycaster.ray.origin.distanceTo(p),
            point: p
          };
        }

        return null;
      }
    }]);

    return CollisionSphere;
  }();

  _defineProperty(CollisionSphere, "_sphere", new THREE__namespace.Sphere());

  var SphereCollisionGeo = function SphereCollisionGeo(base) {
    return /*#__PURE__*/function (_base) {
      _inherits(_class, _base);

      var _super = _createSuper$1Q(_class);

      function _class(count) {
        var _this;

        _classCallCheck(this, _class);

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(args));
        _this._objects = new Array(count);
        _this.boundingSphere = null;
        _this.boundingBox = null;
        return _this;
      }

      _createClass(_class, [{
        key: "setSphere",
        value: function setSphere(idx, position, radius) {
          this._objects[idx] = new CollisionSphere(position, radius);
        }
      }, {
        key: "raycast",
        value: function raycast(raycaster, intersects) {
          for (var i = 0, n = this._objects.length; i < n; ++i) {
            var inters = this._objects[i].raycast(raycaster);

            if (inters) {
              inters.chunkIdx = i;
              intersects.push(inters);
            }
          }
        }
      }, {
        key: "computeBoundingBox",
        value: function computeBoundingBox() {
          var objects = this._objects;
          var boundingBox = this.boundingBox;

          if (boundingBox === null) {
            this.boundingBox = boundingBox = new THREE__namespace.Box3();
          }

          boundingBox.makeEmpty();

          for (var i = 0, n = objects.length; i < n; ++i) {
            boundingBox.expandByPoint(objects[i]._position);
          }
        }
      }, {
        key: "computeBoundingSphere",
        value: function computeBoundingSphere() {
          this.computeBoundingBox();
          var objects = this._objects;
          var boundingBox = this.boundingBox;
          var radiusSquared = 0.0;
          var center = new THREE__namespace.Vector3();
          boundingBox.getCenter(center);

          for (var i = 0, n = objects.length; i < n; ++i) {
            var pos = objects[i]._position;
            var lengthSquared = center.distanceToSquared(pos);

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared;
            }
          }

          if (this.boundingSphere === null) {
            this.boundingSphere = new THREE__namespace.Sphere();
          }

          this.boundingSphere.set(center, Math.sqrt(radiusSquared));
        }
      }]);

      return _class;
    }(base);
  };

  function _createSuper$1P(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1P(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1P() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var tmpColor$4 = new THREE__namespace.Color();
  var OFFSET_SIZE$1 = 4;
  var COLOR_SIZE$3 = 3;
  var copySubArrays$1 = utils.copySubArrays;

  function setArrayXYZ$2(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW$2(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  var InstancedSpheresGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    _inherits(InstancedSpheresGeometry, _SphereCollisionGeo);

    var _super = _createSuper$1P(InstancedSpheresGeometry);

    function InstancedSpheresGeometry(spheresCount, sphereComplexity, useZSprites) {
      var _this;

      _classCallCheck(this, InstancedSpheresGeometry);

      _this = _super.call(this, spheresCount);
      _this._sphGeometry = useZSprites ? new THREE__namespace.PlaneBufferGeometry(2, 2, 1, 1) : new THREE__namespace.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);

      _this._init(spheresCount, _this._sphGeometry);

      return _this;
    }

    _createClass(InstancedSpheresGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        setArrayXYZW$2(this._offsets, itemIdx * OFFSET_SIZE$1, itemPos.x, itemPos.y, itemPos.z, itemRad);
        this.setSphere(itemIdx, itemPos, itemRad);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal) {
        tmpColor$4.set(colorVal);
        setArrayXYZ$2(this._colors, itemIdx * COLOR_SIZE$3, tmpColor$4.r, tmpColor$4.g, tmpColor$4.b);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('offset').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          alphaArr[chunkIndices[i]] = value;
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var geom = new THREE__namespace.InstancedBufferGeometry();

        this._init.call(geom, instanceCount, this._sphGeometry);

        copySubArrays$1(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE$1);
        copySubArrays$1(this._colors, geom._colors, chunkIndices, COLOR_SIZE$3);
        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "_init",
      value: function _init(spheresCount, sphereGeo) {
        this.copy(sphereGeo);
        this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE$1);
        this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$3);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);

        ___default["default"].fill(alpha, 1.0);

        this.setAttribute('offset', new THREE__namespace.InstancedBufferAttribute(this._offsets, OFFSET_SIZE$1, false, 1));
        this.setAttribute('color', new THREE__namespace.InstancedBufferAttribute(this._colors, COLOR_SIZE$3, false, 1));
        this.setAttribute('alphaColor', new THREE__namespace.InstancedBufferAttribute(alpha, 1, false, 1));
      }
    }]);

    return InstancedSpheresGeometry;
  }(SphereCollisionGeo(THREE__namespace.InstancedBufferGeometry));

  function _createSuper$1O(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1O(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1O() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_IDC_16BIT$1 = 65535;
  var VEC_SIZE$4 = 3;
  var tmpColor$3 = new THREE__namespace.Color();

  var ChunkedObjectsGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    _inherits(ChunkedObjectsGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$1O(ChunkedObjectsGeometry);

    function ChunkedObjectsGeometry(chunkGeo, chunksCount) {
      var _this;

      _classCallCheck(this, ChunkedObjectsGeometry);

      _this = _super.call(this);

      if (_this.constructor === ChunkedObjectsGeometry) {
        throw new Error('Can not instantiate abstract class!');
      }

      _this._chunkGeo = chunkGeo;

      _this._init(chunkGeo, chunksCount);

      return _this;
    }

    _createClass(ChunkedObjectsGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('position').needsUpdate = true;
        this.getAttribute('normal').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        tmpColor$3.set(colorVal);
        var colors = this._colors;
        var chunkSize = this._chunkSize;

        for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
          var idx = i * VEC_SIZE$4;
          colors[idx] = tmpColor$3.r;
          colors[idx + 1] = tmpColor$3.g;
          colors[idx + 2] = tmpColor$3.b;
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;
        var chunkSize = this._chunkSize;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var left = chunkIndices[i] * chunkSize;

          ___default["default"].fill(alphaArr, value, left, left + chunkSize);
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var inters = [];
        var mesh = new THREE__namespace.Mesh();
        mesh.geometry = this;
        mesh.raycast(raycaster, inters);
        var facesPerChunk = this._chunkGeo.index.count / 3;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('faceIndex')) {
            continue;
          }

          inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk);
          intersects.push(inters[i]);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var geom = new THREE__namespace.BufferGeometry();

        this._init.call(geom, this._chunkGeo, instanceCount);

        var srcPos = this._positions;
        var srcNorm = this._normals;
        var srcColor = this._colors;
        var dstPos = geom._positions;
        var dstNorm = geom._normals;
        var dstColor = geom._colors;
        var chunkSize = this._chunkSize * VEC_SIZE$4;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var dstPtOffset = i * chunkSize;
          var ptIdxBegin = chunkIndices[i] * chunkSize;
          var ptIdxEnd = ptIdxBegin + chunkSize;
          dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
          dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
          dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
        }

        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "_init",
      value: function _init(chunkGeo, chunksCount) {
        var chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
        var chunkIndex = chunkGeo.index.array;
        var chunkIndexSize = chunkIndex.length;
        var pointsCount = this._chunkSize * chunksCount;
        var use32bitIndex = pointsCount > MAX_IDC_16BIT$1;
        var indexSize = chunkIndexSize * chunksCount;
        var index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
        this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE$4);
        this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE$4);
        this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE$4);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);

        ___default["default"].fill(alpha, 1.0);

        for (var i = 0; i < chunksCount; ++i) {
          var offset = i * chunkIndexSize;
          var posOffset = i * chunkSize;
          index.set(chunkIndex, offset);

          for (var j = 0; j < chunkIndexSize; ++j) {
            index[offset + j] += posOffset;
          }
        }

        this.setIndex(new THREE__namespace.BufferAttribute(this._index, 1));
        this.setAttribute('position', new THREE__namespace.BufferAttribute(this._positions, VEC_SIZE$4));
        this.setAttribute('normal', new THREE__namespace.BufferAttribute(this._normals, VEC_SIZE$4));
        this.setAttribute('color', new THREE__namespace.BufferAttribute(this._colors, VEC_SIZE$4));
        this.setAttribute('alphaColor', new THREE__namespace.BufferAttribute(alpha, 1));
      }
    }]);

    return ChunkedObjectsGeometry;
  }(THREE__namespace.BufferGeometry);

  function _createSuper$1N(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1N(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1N() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$3 = 3;

  var SimpleSpheresGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    _inherits(SimpleSpheresGeometry, _SphereCollisionGeo);

    var _super = _createSuper$1N(SimpleSpheresGeometry);

    function SimpleSpheresGeometry(spheresCount, sphereComplexity) {
      var _this;

      _classCallCheck(this, SimpleSpheresGeometry);

      var sphGeometry = new THREE__namespace.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
      _this = _super.call(this, spheresCount, sphGeometry, spheresCount);
      var normals = _this._normals;
      var geoNormals = sphGeometry.attributes.normal.array;
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$3);

      for (var i = 0; i < spheresCount; ++i) {
        normals.set(geoNormals, chunkSize * VEC_SIZE$3 * i);
      }

      return _this;
    }

    _createClass(SimpleSpheresGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        var tmpPos = this._tmpPositions;
        var chunkSize = this._chunkSize;
        var geoPos = this._chunkPos;

        for (var i = 0; i < chunkSize; ++i) {
          var idx = i * 3;
          tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
          tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
          tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
        }

        this._positions.set(tmpPos, chunkSize * itemIdx * VEC_SIZE$3);

        this.setSphere(itemIdx, itemPos, itemRad);
      }
    }]);

    return SimpleSpheresGeometry;
  }(SphereCollisionGeo(ChunkedObjectsGeometry));

  function _createSuper$1M(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1M(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1M() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$2 = 3;
  var centerPos = new THREE__namespace.Vector3();
  var tmpVector$2 = new THREE__namespace.Vector3();
  var normMtx$1 = new THREE__namespace.Matrix3();

  var Simple2CCylindersGeometry = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    _inherits(Simple2CCylindersGeometry, _ChunkedObjectsGeomet);

    var _super = _createSuper$1M(Simple2CCylindersGeometry);

    function Simple2CCylindersGeometry(instanceCount, polyComplexity) {
      var _this;

      _classCallCheck(this, Simple2CCylindersGeometry);

      var cylGeometry = new THREE__namespace.CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
      _this = _super.call(this, cylGeometry, 2 * instanceCount);
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$2);
      return _this;
    }

    _createClass(Simple2CCylindersGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var chunkSize = this._chunkSize;
        var firstOffset = chunkSize * 2 * itemIdx * VEC_SIZE$2;
        var secondOffset = firstOffset + chunkSize * VEC_SIZE$2;
        var tmpArray = this._tmpVector;
        var geoPos = this._chunkPos;
        var geoNorm = this._chunkNorms;
        centerPos.lerpVectors(botPos, topPos, 0.5);
        var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
        normMtx$1.getNormalMatrix(mtx1);
        var idx;

        for (var i = 0; i < chunkSize; ++i) {
          idx = i * VEC_SIZE$2;
          tmpVector$2.fromArray(geoPos, idx);
          tmpVector$2.applyMatrix4(mtx1);
          tmpVector$2.toArray(tmpArray, idx);
        }

        this._positions.set(tmpArray, firstOffset);

        centerPos.sub(botPos);

        for (var _i = 0; _i < chunkSize; ++_i) {
          idx = _i * VEC_SIZE$2;
          tmpArray[idx] += centerPos.x;
          tmpArray[idx + 1] += centerPos.y;
          tmpArray[idx + 2] += centerPos.z;
        }

        this._positions.set(tmpArray, secondOffset);

        for (var _i2 = 0; _i2 < chunkSize; ++_i2) {
          idx = _i2 * VEC_SIZE$2;
          tmpVector$2.fromArray(geoNorm, idx);
          tmpVector$2.applyMatrix3(normMtx$1);
          tmpVector$2.toArray(tmpArray, idx);
        }

        this._normals.set(tmpArray, firstOffset);

        this._normals.set(tmpArray, secondOffset);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var first = 2 * itemIdx;

        _get(_getPrototypeOf(Simple2CCylindersGeometry.prototype), "setColor", this).call(this, first, colorVal1);

        var second = first + 1;

        _get(_getPrototypeOf(Simple2CCylindersGeometry.prototype), "setColor", this).call(this, second, colorVal2);
      }
    }]);

    return Simple2CCylindersGeometry;
  }(ChunkedObjectsGeometry);

  function _createSuper$1L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1L(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_POINTS_COUNT_16BIT = 65536;
  var PTS_PER_TRIANGLE = 3;

  var CylinderBufferGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    _inherits(CylinderBufferGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$1L(CylinderBufferGeometry);

    function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
      var _this;

      _classCallCheck(this, CylinderBufferGeometry);

      _this = _super.call(this);
      var thetaStart = 0;
      var thetaLength = 2 * Math.PI;
      _this.type = 'CylinderBufferGeometry';
      _this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded
      };
      var hasTop = openEnded === false && radiusTop > 0;
      var hasBottom = openEnded === false && radiusBottom > 0;
      var vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
      var facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
      var heightHalf = height / 2;
      var positions = new THREE__namespace.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
      var normals = new THREE__namespace.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
      var indices = new THREE__namespace.Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
      var uvs = new THREE__namespace.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
      console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, 'false: Cylinder Geometry has too many vertices (65536 max).');
      var currVtxIdx = 0;
      var currFaceIdx = 0;
      var tanTheta = -(radiusBottom - radiusTop) / height;

      for (var y = 0; y <= heightSegments; y++) {
        if (y !== heightSegments) {
          for (var i = 0; i < radialSegments; i++) {
            var v1 = currVtxIdx + i;
            var v2 = currVtxIdx + radialSegments + i;
            var v3 = currVtxIdx + radialSegments + (i + 1) % radialSegments;
            var v4 = currVtxIdx + (i + 1) % radialSegments;
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
            currFaceIdx++;
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
            currFaceIdx++;
          }
        }

        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;

        for (var x = 0; x < radialSegments; x++) {
          var u = x / radialSegments;
          var vx = radius * Math.sin(u * thetaLength + thetaStart);
          var vy = v * height - heightHalf;
          var vz = radius * Math.cos(u * thetaLength + thetaStart);
          var normal = new THREE__namespace.Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
          positions.setXYZ(currVtxIdx, vx, vy, vz);
          normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
          uvs.setXY(currVtxIdx, u, v);
          ++currVtxIdx;
        }
      }

      if (hasTop) {
        var startTIdx = currVtxIdx;
        var lastIdx = currVtxIdx + radialSegments;

        for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
          var currSrcIdx = currVtxIdx - radialSegments;
          positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
          normals.setXYZ(currVtxIdx, 0, 1, 0);
          uvs.setXY(currVtxIdx, 1, 1);
          var nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
          currFaceIdx++;
          currVtxIdx++;
        }

        positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        ++currVtxIdx;
      }

      if (hasBottom) {
        var startBIdx = currVtxIdx;
        var lastBIdx = currVtxIdx + radialSegments;

        for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
          var currSrcBIdx = fBIdx;
          positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
          normals.setXYZ(currVtxIdx, 0, -1, 0);
          uvs.setXY(currVtxIdx, 0, 0);
          var nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
          currFaceIdx++;
          currVtxIdx++;
        }

        positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
      }

      _this.setIndex(indices);

      _this.setAttribute('position', positions);

      _this.setAttribute('normal', normals);

      _this.setAttribute('uv', uvs);

      return _this;
    }

    _createClass(CylinderBufferGeometry, [{
      key: "clone",
      value: function clone() {
        var parameters = this.parameters;
        return new CylinderBufferGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
      }
    }]);

    return CylinderBufferGeometry;
  }(THREE__namespace.BufferGeometry);

  function _createSuper$1K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1K(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var tmpColor$2 = new THREE__namespace.Color();
  var invMatrix = new THREE__namespace.Matrix4();
  var OFFSET_SIZE = 4;
  var COLOR_SIZE$2 = 3;
  var copySubArrays = utils.copySubArrays;

  function setArrayXYZ$1(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW$1(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  function sortNumber(a, b) {
    return a - b;
  }

  function _prepareCylinderInfo(chunkIndices) {
    chunkIndices.sort(sortNumber);
    var chunksIdx = [];
    var cylinderInfo = [];

    for (var i = 0, n = chunkIndices.length; i < n; ++i) {
      var val = chunkIndices[i];
      var even = (val | 0) % 2 === 0;
      var newPar = {
        first: false,
        second: false
      };

      if (even) {
        newPar.first = true;
        newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1;

        if (newPar.second) {
          ++i;
        }
      } else {
        newPar.second = true;
      }

      chunksIdx.push(Math.floor(val / 2));
      cylinderInfo.push(newPar);
    }

    return {
      indices: chunksIdx,
      cylinderInfo: cylinderInfo
    };
  }

  function _assignOpacity(cylinderInfo, color1, color2) {
    for (var i = 0, n = cylinderInfo.length; i < n; ++i) {
      var info = cylinderInfo[i];

      if (!info.first) {
        color1[COLOR_SIZE$2 * i] = -0.5;
      }

      if (!info.second) {
        color2[COLOR_SIZE$2 * i] = -0.5;
      }
    }
  }

  var Instanced2CCylindersGeometry = /*#__PURE__*/function (_THREE$InstancedBuffe) {
    _inherits(Instanced2CCylindersGeometry, _THREE$InstancedBuffe);

    var _super = _createSuper$1K(Instanced2CCylindersGeometry);

    function Instanced2CCylindersGeometry(instanceCount, polyComplexity, useZSprites, openEnded) {
      var _this;

      _classCallCheck(this, Instanced2CCylindersGeometry);

      _this = _super.call(this);
      _this._useZSprites = useZSprites;
      _this._cylGeometry = useZSprites ? new THREE__namespace.PlaneBufferGeometry(2, 2, 1, 1) : new CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, openEnded);

      _this._init(instanceCount, _this._cylGeometry, _this._useZSprites);

      _this._collisionGeo = new Simple2CCylindersGeometry(instanceCount, 3);
      return _this;
    }

    _createClass(Instanced2CCylindersGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
        var me = matrix.elements;
        var mtxOffset = itemIdx * OFFSET_SIZE;

        this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);

        setArrayXYZW$1(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
        setArrayXYZW$1(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
        setArrayXYZW$1(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);

        if (this._useZSprites) {
          invMatrix.copy(matrix).invert();
          me = invMatrix.elements;
          setArrayXYZW$1(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
          setArrayXYZW$1(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
          setArrayXYZW$1(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
        }
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var colorIdx = itemIdx * COLOR_SIZE$2;
        tmpColor$2.set(colorVal1);
        setArrayXYZ$1(this._color1, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
        tmpColor$2.set(colorVal2);
        setArrayXYZ$1(this._color2, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        this._collisionGeo.computeBoundingSphere();

        this.boundingSphere = this._collisionGeo.boundingSphere;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        this._collisionGeo.computeBoundingBox();

        this.boundingBox = this._collisionGeo.boundingBox;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        this._collisionGeo.raycast(raycaster, intersects);
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('matVector1').needsUpdate = true;
        this.getAttribute('matVector2').needsUpdate = true;
        this.getAttribute('matVector3').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
        this.getAttribute('color2').needsUpdate = true;
        this.getAttribute('alphaColor').needsUpdate = true;

        if (this._useZSprites) {
          this.getAttribute('invmatVector1').needsUpdate = true;
          this.getAttribute('invmatVector2').needsUpdate = true;
          this.getAttribute('invmatVector3').needsUpdate = true;
        }

        this._collisionGeo.finishUpdate();
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var alphaArr = this._alpha;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          alphaArr[Math.floor(chunkIndices[i] / 2)] = value;
        }

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var info = _prepareCylinderInfo(chunkIndices);

        var cylinderIndices = info.indices;
        var instanceCount = cylinderIndices.length;
        var geom = new THREE__namespace.InstancedBufferGeometry();

        this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);

        copySubArrays(this._matVector1, geom._matVector1, cylinderIndices, OFFSET_SIZE);
        copySubArrays(this._matVector2, geom._matVector2, cylinderIndices, OFFSET_SIZE);
        copySubArrays(this._matVector3, geom._matVector3, cylinderIndices, OFFSET_SIZE);

        if (this._useZSprites) {
          copySubArrays(this._invmatVector1, geom._invmatVector1, cylinderIndices, OFFSET_SIZE);
          copySubArrays(this._invmatVector2, geom._invmatVector2, cylinderIndices, OFFSET_SIZE);
          copySubArrays(this._invmatVector3, geom._invmatVector3, cylinderIndices, OFFSET_SIZE);
        }

        copySubArrays(this._color1, geom._color1, cylinderIndices, COLOR_SIZE$2);
        copySubArrays(this._color2, geom._color2, cylinderIndices, COLOR_SIZE$2);

        _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);

        geom.boundingSphere = this.boundingSphere;
        geom.boundingBox = this.boundingBox;
        return [geom];
      }
    }, {
      key: "getGeoParams",
      value: function getGeoParams() {
        return this._cylGeometry.parameters;
      }
    }, {
      key: "_init",
      value: function _init(instanceCount, cylinderGeo, useZSprites) {
        this.copy(cylinderGeo);
        this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
        this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
        this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
        this._color1 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$2);
        this._color2 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$2);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);

        ___default["default"].fill(alpha, 1.0);

        this.setAttribute('matVector1', new THREE__namespace.InstancedBufferAttribute(this._matVector1, OFFSET_SIZE, false, 1));
        this.setAttribute('matVector2', new THREE__namespace.InstancedBufferAttribute(this._matVector2, OFFSET_SIZE, false, 1));
        this.setAttribute('matVector3', new THREE__namespace.InstancedBufferAttribute(this._matVector3, OFFSET_SIZE, false, 1));
        this.setAttribute('color', new THREE__namespace.InstancedBufferAttribute(this._color1, COLOR_SIZE$2, false, 1));
        this.setAttribute('color2', new THREE__namespace.InstancedBufferAttribute(this._color2, COLOR_SIZE$2, false, 1));
        this.setAttribute('alphaColor', new THREE__namespace.InstancedBufferAttribute(this._alpha, 1, false, 1));

        if (useZSprites) {
          this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
          this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
          this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE);
          this.setAttribute('invmatVector1', new THREE__namespace.InstancedBufferAttribute(this._invmatVector1, OFFSET_SIZE, false, 1));
          this.setAttribute('invmatVector2', new THREE__namespace.InstancedBufferAttribute(this._invmatVector2, OFFSET_SIZE, false, 1));
          this.setAttribute('invmatVector3', new THREE__namespace.InstancedBufferAttribute(this._invmatVector3, OFFSET_SIZE, false, 1));
        }
      }
    }]);

    return Instanced2CCylindersGeometry;
  }(THREE__namespace.InstancedBufferGeometry);

  function _createSuper$1J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1J(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE$1 = 3;
  var TRI_SIZE = 3;
  var tmpPrev = new THREE__namespace.Vector3();
  var tmpNext = new THREE__namespace.Vector3();
  var tmpRes = new THREE__namespace.Vector3();
  var simpleNormal = new THREE__namespace.Vector3(1.0, 0.0, 0.0);
  var normalOnCut = new THREE__namespace.Vector3();
  var nearRingPt = new THREE__namespace.Vector3();

  function _createExtrudedChunkGeometry(shape, ringsCount) {
    var geo = new THREE__namespace.BufferGeometry();
    var ptsCount = shape.length;
    var totalPts = ptsCount * ringsCount;
    var type = totalPts <= 65536 ? Uint16Array : Uint32Array;
    var facesPerChunk = (ringsCount - 1) * ptsCount * 2;
    var indices = new THREE__namespace.BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);
    var currVtxIdx = 0;
    var currFaceIdx = 0;

    for (var y = 0; y < ringsCount; y++) {
      if (y !== ringsCount - 1) {
        for (var i = 0; i < ptsCount; i++) {
          var v1 = currVtxIdx + i;
          var v2 = currVtxIdx + ptsCount + i;
          var v3 = currVtxIdx + ptsCount + (i + 1) % ptsCount;
          var v4 = currVtxIdx + (i + 1) % ptsCount;
          indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
          currFaceIdx++;
        }
      }

      currVtxIdx += ptsCount;
    }

    geo.setIndex(indices);
    var pos = utils.allocateTyped(Float32Array, totalPts * VEC_SIZE$1);
    geo.setAttribute('position', new THREE__namespace.BufferAttribute(pos, VEC_SIZE$1));
    geo._positions = shape;
    return geo;
  }

  var ExtrudedObjectsGeometry = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    _inherits(ExtrudedObjectsGeometry, _ChunkedObjectsGeomet);

    var _super = _createSuper$1J(ExtrudedObjectsGeometry);

    function ExtrudedObjectsGeometry(shape, ringsCount, chunksCount) {
      var _this;

      _classCallCheck(this, ExtrudedObjectsGeometry);

      var chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);

      _this = _super.call(this, chunkGeo, chunksCount);
      _this._ringsCount = ringsCount;
      var tmpShape = _this._tmpShape = [];

      for (var i = 0; i < shape.length; ++i) {
        tmpShape[i] = new THREE__namespace.Vector3();
      }

      return _this;
    }

    _createClass(ExtrudedObjectsGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, matrices) {
        var hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var ptsCount = this._chunkGeo._positions.length;
        var ringsCount = this._ringsCount;
        var chunkStartIdx = ptsCount * this._ringsCount * itemIdx * VEC_SIZE$1;

        this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx);

        if (hasSlope) {
          this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx);
        } else {
          this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx);
        }

        if (hasCut) {
          this._addCut(ptsCount, ringsCount, chunkStartIdx);
        }
      }
    }, {
      key: "_setPoints",
      value: function _setPoints(matrices, ptsCount, ringsCount, chunkStartIdx) {
        var tmpShape = this._tmpShape;
        var positions = this._positions;
        var shape = this._chunkGeo._positions;

        for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i) {
          var mtx = matrices[i];

          for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$1) {
            tmpShape[j].copy(shape[j]).applyMatrix4(mtx).toArray(positions, vtxIdx);
          }
        }
      }
    }, {
      key: "_setBaseNormals",
      value: function _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
        var nPtsInRing = ptsCount * VEC_SIZE$1;

        for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
          this._countNormalsInRing(ptsCount, vtxIdx, false);
        }
      }
    }, {
      key: "_setSlopeNormals",
      value: function _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
        var normals = this._normals;
        var nPtsInRing = ptsCount * VEC_SIZE$1;
        var vtxIdx = chunkStartIdx;

        for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$1) {
          simpleNormal.toArray(normals, vtxIdx);
        }

        if (vtxIdx - 2 * nPtsInRing > 0) {
          for (var _j = 0; _j < ptsCount; ++_j, vtxIdx += VEC_SIZE$1) {
            tmpRes.fromArray(normals, vtxIdx - 2 * nPtsInRing).toArray(normals, vtxIdx);
          }
        } else {
          this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing);

          vtxIdx += nPtsInRing;
        }

        for (var i = 2; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
          this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing);
        }
      }
    }, {
      key: "_countNormalsInRing",
      value: function _countNormalsInRing(ptsCount, vtxIdx, isSlope, shiftToExtraPt) {
        var tmpShape = this._tmpShape;
        var normals = this._normals;
        tmpShape[0].fromArray(this._positions, vtxIdx);
        tmpShape[ptsCount - 1].fromArray(this._positions, vtxIdx + (ptsCount - 1) * VEC_SIZE$1);

        for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$1) {
          if (j < ptsCount - 1) {
            tmpShape[j + 1].fromArray(this._positions, vtxIdx + VEC_SIZE$1);
          }

          if (isSlope) {
            nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt);
            tmpPrev.subVectors(tmpShape[(j + ptsCount - 1) % ptsCount], tmpShape[(j + 1) % ptsCount]).normalize();
            tmpNext.subVectors(tmpShape[j], nearRingPt).normalize();
            tmpRes.crossVectors(tmpNext, tmpPrev).normalize().toArray(normals, vtxIdx);
          } else {
            tmpPrev.subVectors(tmpShape[j], tmpShape[(j + ptsCount - 1) % ptsCount]).normalize();
            tmpNext.subVectors(tmpShape[j], tmpShape[(j + 1) % ptsCount]).normalize();
            tmpRes.addVectors(tmpPrev, tmpNext).normalize().toArray(normals, vtxIdx);
          }
        }
      }
    }, {
      key: "_addCut",
      value: function _addCut(ptsCount, ringsCount, chunkStartIdx) {
        if (ptsCount < 3 || ringsCount < 2) {
          return;
        }

        var positions = this._positions;
        var normals = this._normals;
        var tmpShape = this._tmpShape;
        var nPtsInRing = ptsCount * VEC_SIZE$1;
        tmpShape[0].fromArray(positions, chunkStartIdx);
        tmpShape[1].fromArray(positions, chunkStartIdx + VEC_SIZE$1);
        tmpShape[2].fromArray(positions, chunkStartIdx + 2 * VEC_SIZE$1);
        tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize();
        tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize();
        normalOnCut.crossVectors(tmpPrev, tmpNext).normalize();
        var vtxIdx = chunkStartIdx;

        for (var j = 0; j < ptsCount * 2; ++j, vtxIdx += VEC_SIZE$1) {
          normalOnCut.toArray(normals, vtxIdx);
        }

        if (ringsCount > 2) {
          for (var _j2 = 0; _j2 < ptsCount; ++_j2, vtxIdx += VEC_SIZE$1) {
            tmpRes.fromArray(positions, vtxIdx - nPtsInRing).toArray(positions, vtxIdx);
          }
        }
      }
    }]);

    return ExtrudedObjectsGeometry;
  }(ChunkedObjectsGeometry);

  function _createSuper$1I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1I(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var MAX_IDC_16BIT = 65535;
  var VERTEX_PER_SEGMENT = 4;
  var POS_SIZE = 4;
  var DIR_SIZE = 3;
  var COL_SIZE = 3;
  var tmpColor$1 = new THREE__namespace.Color();
  var direction = new THREE__namespace.Vector3();

  function setArrayXYZ(arr, idx, x, y, z) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
  }

  function setArrayXYZW(arr, idx, x, y, z, w) {
    arr[idx] = x;
    arr[idx + 1] = y;
    arr[idx + 2] = z;
    arr[idx + 3] = w;
  }

  function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
    var start = startSegmentIdx * VERTEX_PER_SEGMENT;
    var end = start + segmentsCount * VERTEX_PER_SEGMENT;
    return arr.subarray(start * elemSize, end * elemSize);
  }

  var ThickLinesGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    _inherits(ThickLinesGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$1I(ThickLinesGeometry);

    function ThickLinesGeometry(segmentsCount) {
      var _this;

      _classCallCheck(this, ThickLinesGeometry);

      _this = _super.call(this);

      _this._initVertices(segmentsCount);

      return _this;
    }

    _createClass(ThickLinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.getAttribute('position').needsUpdate = true;
        this.getAttribute('color').needsUpdate = true;
        this.getAttribute('alphaColor').needsUpdate = true;
        this.getAttribute('direction').needsUpdate = true;
      }
    }, {
      key: "setColor",
      value: function setColor(segmentIdx, colorVal) {
        tmpColor$1.set(colorVal);
        var idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
        setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
        idx += COL_SIZE;
        setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
        idx += COL_SIZE;
        setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
        idx += COL_SIZE;
        setArrayXYZ(this._colors, idx, tmpColor$1.r, tmpColor$1.g, tmpColor$1.b);
      }
    }, {
      key: "setSegment",
      value: function setSegment(segmentIdx, pos1, pos2) {
        direction.subVectors(pos1, pos2);
        direction.normalize();
        var positions = this._positions;
        var directions = this._directions;
        var idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
        var dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
        setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
        setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
        setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
        setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
        idx += POS_SIZE;
        dirIdx += DIR_SIZE;
        setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
        setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(startSegIdx, endSegIdx, value) {
        var start = startSegIdx * VERTEX_PER_SEGMENT;
        var end = endSegIdx * VERTEX_PER_SEGMENT;

        ___default["default"].fill(this.alpha, value, end, start);

        this.getAttribute('alphaColor').needsUpdate = true;
      }
    }, {
      key: "getSubsetSegments",
      value: function getSubsetSegments(startSegmentIdx, segmentsCount) {
        return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
      }
    }, {
      key: "getSubsetColors",
      value: function getSubsetColors(startSegmentIdx, segmentsCount) {
        return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
      }
    }, {
      key: "getSubsetOpacities",
      value: function getSubsetOpacities(startSegmentIdx, segmentsCount) {
        return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
      }
    }, {
      key: "getNumVertexPerSegment",
      value: function getNumVertexPerSegment() {
        return VERTEX_PER_SEGMENT;
      }
    }, {
      key: "getPositionSize",
      value: function getPositionSize() {
        return POS_SIZE;
      }
    }, {
      key: "setSegments",
      value: function setSegments(startSegmentIdx, positions) {
        var startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;

        if (positions instanceof Array && positions.length === 2) {
          this._positions.set(positions[0], startPos);

          var startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;

          this._directions.set(positions[1], startDir);
        } else {
          this._positions.set(positions, startPos);
        }
      }
    }, {
      key: "setColors",
      value: function setColors(startSegmentIdx, colors) {
        var start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;

        this._colors.set(colors, start);
      }
    }, {
      key: "_initVertices",
      value: function _initVertices(segmentsCount) {
        this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
        var pointsCount = this._buffersSize;
        var use32bitIndex = pointsCount > MAX_IDC_16BIT;
        this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
        this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
        this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
        this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
        var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);

        ___default["default"].fill(alpha, 1.0);

        var index = this._index;
        var indexOffset = 0;
        var pointOffset = 0;

        for (var j = 0; j < segmentsCount; j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
          index[indexOffset] = pointOffset;
          index[indexOffset + 1] = pointOffset + 1;
          index[indexOffset + 2] = pointOffset + 3;
          index[indexOffset + 3] = pointOffset;
          index[indexOffset + 4] = pointOffset + 2;
          index[indexOffset + 5] = pointOffset + 3;
        }

        this.setIndex(new THREE__namespace.BufferAttribute(this._index, 1));
        this.setAttribute('position', new THREE__namespace.BufferAttribute(this._positions, POS_SIZE));
        this.setAttribute('color', new THREE__namespace.BufferAttribute(this._colors, COL_SIZE));
        this.setAttribute('alphaColor', new THREE__namespace.BufferAttribute(alpha, 1));
        this.setAttribute('direction', new THREE__namespace.BufferAttribute(this._directions, DIR_SIZE));
      }
    }]);

    return ThickLinesGeometry;
  }(THREE__namespace.BufferGeometry);

  function _createSuper$1H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1H(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var LinesGeometry = /*#__PURE__*/function (_BaseLinesGeometry) {
    _inherits(LinesGeometry, _BaseLinesGeometry);

    var _super = _createSuper$1H(LinesGeometry);

    function LinesGeometry() {
      _classCallCheck(this, LinesGeometry);

      return _super.apply(this, arguments);
    }

    _createClass(LinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var boundingBox = this.boundingBox;
        var radiusSquared = 0.0;
        var center = new THREE__namespace.Vector3();

        if (boundingBox) {
          boundingBox.getCenter(center);
        }

        var positions = this._positions;
        var sphere = this.boundingSphere || new THREE__namespace.Sphere();
        var size = this._positions.length;
        var pos = new THREE__namespace.Vector3();
        var posSize = this.getPositionSize();

        for (var i = 0; i < size; i += posSize) {
          pos.set(positions[i], positions[i + 1], positions[i + 2]);
          var lengthSquared = center.distanceToSquared(pos);

          if (radiusSquared < lengthSquared) {
            radiusSquared = lengthSquared;
          }
        }

        sphere.set(center, Math.sqrt(radiusSquared));
        this.boundingSphere = sphere;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var positions = this._positions;
        var box = new THREE__namespace.Box3();
        var size = this._positions.length;
        var tmpVec = new THREE__namespace.Vector3();
        var posSize = this.getPositionSize();

        for (var i = 0; i < size; i += posSize) {
          tmpVec.set(positions[i], positions[i + 1], positions[i + 2]);
          box.expandByPoint(tmpVec);
        }

        this.boundingBox = box;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }]);

    return LinesGeometry;
  }(ThickLinesGeometry);

  function _createSuper$1G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1G(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var VEC_SIZE = 3;
  var tmpVector$1 = new THREE__namespace.Vector3();
  var normMtx = new THREE__namespace.Matrix3();

  var CylinderCollisionGeo = /*#__PURE__*/function (_ChunkedObjectsGeomet) {
    _inherits(CylinderCollisionGeo, _ChunkedObjectsGeomet);

    var _super = _createSuper$1G(CylinderCollisionGeo);

    function CylinderCollisionGeo(instanceCount, polyComplexity) {
      var _this;

      _classCallCheck(this, CylinderCollisionGeo);

      var cylGeometry = new THREE__namespace.CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
      _this = _super.call(this, cylGeometry, instanceCount);
      var chunkSize = _this._chunkSize;
      _this._chunkPos = _this._chunkGeo.attributes.position.array;
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE);
      return _this;
    }

    _createClass(CylinderCollisionGeo, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos, itemRad) {
        var chunkSize = this._chunkSize;
        var itemOffset = chunkSize * itemIdx * VEC_SIZE;
        var tmpArray = this._tmpVector;
        var geoPos = this._chunkPos;
        var geoNorm = this._chunkNorms;
        var mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
        normMtx.getNormalMatrix(mtx1);
        var idx;

        for (var i = 0; i < chunkSize; ++i) {
          idx = i * VEC_SIZE;
          tmpVector$1.fromArray(geoPos, idx);
          tmpVector$1.applyMatrix4(mtx1);
          tmpVector$1.toArray(tmpArray, idx);
        }

        this._positions.set(tmpArray, itemOffset);

        for (var _i = 0; _i < chunkSize; ++_i) {
          idx = _i * VEC_SIZE;
          tmpVector$1.fromArray(geoNorm, idx);
          tmpVector$1.applyMatrix3(normMtx);
          tmpVector$1.toArray(tmpArray, idx);
        }

        this._normals.set(tmpArray, itemOffset);
      }
    }]);

    return CylinderCollisionGeo;
  }(ChunkedObjectsGeometry);

  function _createSuper$1F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1F(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var COLLISION_RAD$1 = 0.1;

  var ChunkedLinesGeometry = /*#__PURE__*/function (_LinesGeometry) {
    _inherits(ChunkedLinesGeometry, _LinesGeometry);

    var _super = _createSuper$1F(ChunkedLinesGeometry);

    function ChunkedLinesGeometry(chunksCount, segmentsCount, enableCollision) {
      var _this;

      _classCallCheck(this, ChunkedLinesGeometry);

      _this = _super.call(this, chunksCount * segmentsCount);

      _this._init(segmentsCount);

      _this._collisionGeo = enableCollision ? new CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
      return _this;
    }

    _createClass(ChunkedLinesGeometry, [{
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var collisionGeo = this._collisionGeo;

        if (collisionGeo) {
          collisionGeo.computeBoundingSphere();
          this.boundingSphere = collisionGeo.boundingSphere;
          return;
        }

        _get(_getPrototypeOf(ChunkedLinesGeometry.prototype), "computeBoundingSphere", this).call(this);
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var collisionGeo = this._collisionGeo;

        if (collisionGeo) {
          collisionGeo.computeBoundingBox();
          this.boundingBox = collisionGeo.boundingBox;
          return;
        }

        _get(_getPrototypeOf(ChunkedLinesGeometry.prototype), "computeBoundingBox", this).call(this);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var collisionGeo = this._collisionGeo;

        if (!collisionGeo) {
          return;
        }

        var segCount = this._chunkSize;

        this._collisionGeo.raycast(raycaster, intersects);

        for (var i = 0, n = intersects.length; i < n; ++i) {
          var chunkIdx = intersects[i].chunkIdx;

          if (chunkIdx === undefined) {
            continue;
          }

          chunkIdx = chunkIdx / segCount | 0;
          intersects[i].chunkIdx = chunkIdx;
        }
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        var chunkSize = this._chunkSize;

        for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
          _get(_getPrototypeOf(ChunkedLinesGeometry.prototype), "setColor", this).call(this, i, colorVal);
        }
      }
    }, {
      key: "setSegment",
      value: function setSegment(chunkIdx, segIdx, pos1, pos2) {
        var chunkSize = this._chunkSize;
        var idx = chunkIdx * chunkSize + segIdx;

        _get(_getPrototypeOf(ChunkedLinesGeometry.prototype), "setSegment", this).call(this, idx, pos1, pos2);

        if (this._collisionGeo) {
          this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD$1);
        }
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity(chunkIndices, value) {
        var chunkSize = this._chunkSize;

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var left = chunkIndices[i] * chunkSize;

          _get(_getPrototypeOf(ChunkedLinesGeometry.prototype), "setOpacity", this).call(this, left, left + chunkSize - 1, value);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var instanceCount = chunkIndices.length;
        var chunkSize = this._chunkSize;
        var subset = new ChunkedLinesGeometry(instanceCount, chunkSize, false);

        for (var i = 0, n = chunkIndices.length; i < n; ++i) {
          var dstPtOffset = i * chunkSize;
          var startSegIdx = chunkIndices[i] * chunkSize;
          subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
          subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
        }

        subset.boundingSphere = this.boundingSphere;
        subset.boundingBox = this.boundingBox;
        return [subset];
      }
    }, {
      key: "_init",
      value: function _init(chunkSize) {
        this._chunkSize = chunkSize;
      }
    }]);

    return ChunkedLinesGeometry;
  }(LinesGeometry);

  function _createSuper$1E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1E(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var COLLISION_RAD = 0.3;
  var tmpVector = new THREE__namespace.Vector3();

  var TwoColorLinesGeometry = /*#__PURE__*/function (_LinesGeometry) {
    _inherits(TwoColorLinesGeometry, _LinesGeometry);

    var _super = _createSuper$1E(TwoColorLinesGeometry);

    function TwoColorLinesGeometry(segmentsCount) {
      var _this;

      _classCallCheck(this, TwoColorLinesGeometry);

      _this = _super.call(this, segmentsCount * 2);

      _this._init(segmentsCount);

      _this._collisionGeo = new Simple2CCylindersGeometry(segmentsCount, 3);
      return _this;
    }

    _createClass(TwoColorLinesGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, botPos, topPos) {
        this._collisionGeo.setItem(itemIdx, botPos, topPos, COLLISION_RAD);

        var offset = 2 * itemIdx;
        tmpVector.lerpVectors(botPos, topPos, 0.5);

        _get(_getPrototypeOf(TwoColorLinesGeometry.prototype), "setSegment", this).call(this, offset, botPos, tmpVector);

        _get(_getPrototypeOf(TwoColorLinesGeometry.prototype), "setSegment", this).call(this, offset + 1, tmpVector, topPos);
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, colorVal1, colorVal2) {
        var offset = 2 * itemIdx;

        _get(_getPrototypeOf(TwoColorLinesGeometry.prototype), "setColor", this).call(this, offset, colorVal1);

        _get(_getPrototypeOf(TwoColorLinesGeometry.prototype), "setColor", this).call(this, offset + 1, colorVal2);
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (this._collisionGeo) {
          this._collisionGeo.raycast(raycaster, intersects);
        }
      }
    }, {
      key: "getSubset",
      value: function getSubset(segmentIndices) {
        var instanceCount = segmentIndices.length;
        var subset = new TwoColorLinesGeometry(instanceCount, false);

        for (var i = 0, n = instanceCount; i < n; ++i) {
          var startSegIdx = segmentIndices[i];
          subset.setSegments(i, this.getSubsetSegments(startSegIdx, 1));
          subset.setColors(i, this.getSubsetColors(startSegIdx, 1));
        }

        subset.boundingSphere = this.boundingSphere;
        subset.boundingBox = this.boundingBox;
        return [subset];
      }
    }, {
      key: "_init",
      value: function _init(segmentsCount) {
        this._segCounts = segmentsCount * 2;
      }
    }]);

    return TwoColorLinesGeometry;
  }(LinesGeometry);

  function _createSuper$1D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1D(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var vectors = [new THREE__namespace.Vector3(1, 0, 0), new THREE__namespace.Vector3(-1, 0, 0), new THREE__namespace.Vector3(0, 1, 0), new THREE__namespace.Vector3(0, -1, 0), new THREE__namespace.Vector3(0, 0, 1), new THREE__namespace.Vector3(0, 0, -1)];
  var vecCount = vectors.length;
  var tempPos1 = new THREE__namespace.Vector3();
  var tempPos2 = new THREE__namespace.Vector3();

  var CrossGeometry = /*#__PURE__*/function (_SphereCollisionGeo) {
    _inherits(CrossGeometry, _SphereCollisionGeo);

    var _super = _createSuper$1D(CrossGeometry);

    function CrossGeometry(chunksCount) {
      _classCallCheck(this, CrossGeometry);

      return _super.call(this, chunksCount, chunksCount, vecCount / 2 | 0, false);
    }

    _createClass(CrossGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, itemRad) {
        this.setSphere(itemIdx, itemPos, itemRad);

        for (var i = 0; i < vecCount / 2; ++i) {
          var first = i * 2;
          tempPos1.x = itemPos.x + vectors[first].x * itemRad;
          tempPos1.y = itemPos.y + vectors[first].y * itemRad;
          tempPos1.z = itemPos.z + vectors[first].z * itemRad;
          var second = first + 1;
          tempPos2.x = itemPos.x + vectors[second].x * itemRad;
          tempPos2.y = itemPos.y + vectors[second].y * itemRad;
          tempPos2.z = itemPos.z + vectors[second].z * itemRad;
          this.setSegment(itemIdx, i, tempPos1, tempPos2);
        }
      }
    }]);

    return CrossGeometry;
  }(SphereCollisionGeo(ChunkedLinesGeometry));

  function _createSuper$1C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1C(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var POS_RAD_SIZE = 4;
  var COLOR_SIZE$1 = 3;
  var tmpColor = new THREE__namespace.Color();

  var IsoSurfaceGeometry = /*#__PURE__*/function (_THREE$BufferGeometry) {
    _inherits(IsoSurfaceGeometry, _THREE$BufferGeometry);

    var _super = _createSuper$1C(IsoSurfaceGeometry);

    function IsoSurfaceGeometry(spheresCount, opts) {
      var _this;

      _classCallCheck(this, IsoSurfaceGeometry);

      _this = _super.call(this);
      _this._opts = opts;
      _this.zClip = _this._opts.zClip;
      _this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
      _this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$1);
      return _this;
    }

    _createClass(IsoSurfaceGeometry, [{
      key: "setItem",
      value: function setItem(chunkIdx, pos, radius) {
        var posRad = this._posRad;
        var idx = POS_RAD_SIZE * chunkIdx;
        posRad[idx++] = pos.x;
        posRad[idx++] = pos.y;
        posRad[idx++] = pos.z;
        posRad[idx] = radius;
      }
    }, {
      key: "setColor",
      value: function setColor(chunkIdx, colorVal) {
        tmpColor.set(colorVal);
        var colors = this._colors;
        var idx = COLOR_SIZE$1 * chunkIdx;
        colors[idx++] = tmpColor.r;
        colors[idx++] = tmpColor.g;
        colors[idx] = tmpColor.b;
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
        this.computeBoundingSphere();
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this._build();
      }
    }, {
      key: "setOpacity",
      value: function setOpacity() {}
    }, {
      key: "raycast",
      value: function raycast() {}
    }, {
      key: "getSubset",
      value: function getSubset() {
        return [];
      }
    }]);

    return IsoSurfaceGeometry;
  }(THREE__namespace.BufferGeometry);

  var IsoSurfaceMarchCube = /*#__PURE__*/function () {
    function IsoSurfaceMarchCube() {
      _classCallCheck(this, IsoSurfaceMarchCube);

      this.pointsValuesLinear = null;
      this.hasIntersection = null;
      this.bitsInside = null;
    }

    _createClass(IsoSurfaceMarchCube, [{
      key: "create",
      value: function create(numCellsPerSide) {
        var vx7000000 = 0x7000000;
        var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;

        if (n3 > vx7000000) {
          throw new Error('Too large cube dimension: lead to memory huge uasge');
        }

        this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
        this.hasIntersection = utils.allocateTyped(Int32Array, n3);
        this.bitsInside = utils.allocateTyped(Int32Array, n3);
        return 0;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.bitsInside = null;
        this.hasIntersection = null;
        this.pointsValuesLinear = null;
      }
    }]);

    return IsoSurfaceMarchCube;
  }();

  IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];

  var edgeTable = [0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0];

  function _voxelGradientFast(v, point, grad) {
    var g = v.getValue(point.x, point.y, point.z);
    grad.set(g[0], g[1], g[2]);
  }

  var GridCell = function GridCell() {
    _classCallCheck(this, GridCell);

    this._arrSize = 8;
    this.p = new Array(this._arrSize);
    this.g = new Array(this._arrSize);
    this.val = new Array(this._arrSize);

    for (var i = 0; i < this._arrSize; ++i) {
      this.p[i] = new THREE__namespace.Vector3();
      this.g[i] = new THREE__namespace.Vector3();
    }

    this.cubeIndex = 0;
  };

  var Triangle = function Triangle() {
    _classCallCheck(this, Triangle);

    this.a = {
      p: new THREE__namespace.Vector3(),
      n: new THREE__namespace.Vector3()
    };
    this.b = {
      p: new THREE__namespace.Vector3(),
      n: new THREE__namespace.Vector3()
    };
    this.c = {
      p: new THREE__namespace.Vector3(),
      n: new THREE__namespace.Vector3()
    };
  };

  function createArray(arrSize) {
    var arr = new Array(arrSize);

    for (var i = 0; i < arrSize; ++i) {
      arr[i] = new THREE__namespace.Vector3();
    }

    return arr;
  }

  var IsoSurface = /*#__PURE__*/function () {
    function IsoSurface() {
      _classCallCheck(this, IsoSurface);

      this._numTriangles = 0;
      this._numVertices = 0;
      this._position = [];
      this._normals = [];
      this._colors = null;
      this._indices = [];
      this._volumetricData = null;
      this._xAxis = new THREE__namespace.Vector3();
      this._yAxis = new THREE__namespace.Vector3();
      this._zAxis = new THREE__namespace.Vector3();
      this._xDir = new THREE__namespace.Vector3();
      this._yDir = new THREE__namespace.Vector3();
      this._zDir = new THREE__namespace.Vector3();
    }

    _createClass(IsoSurface, [{
      key: "_prepareAxesAndDirs",
      value: function _prepareAxesAndDirs() {
        var volData = this._volumetricData;
        var cellSize = volData.getCellSize();
        var xAxis = this._xAxis;
        var yAxis = this._yAxis;
        var zAxis = this._zAxis;
        var xDir = this._xDir;
        var yDir = this._yDir;
        var zDir = this._zDir;
        xAxis.set(cellSize.x, 0, 0);
        yAxis.set(0, cellSize.y, 0);
        zAxis.set(0, 0, cellSize.z);
        xDir.set(1, 0, 0);
        yDir.set(0, 1, 0);
        zDir.set(0, 0, 1);
        var tmp = new THREE__namespace.Vector3();
        tmp.crossVectors(xDir, yDir);

        if (tmp.dot(zDir) < 0) {
          xDir.negate();
          yDir.negate();
          zDir.negate();
        }

        if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
          return false;
        }

        var notZero = function notZero(axe) {
          return Math.abs(axe) > Number.EPSILON;
        };

        return !(notZero(xAxis.y) || notZero(xAxis.z) || notZero(yAxis.x) || notZero(yAxis.z) || notZero(zAxis.x) || notZero(zAxis.y));
      }
    }, {
      key: "_vertexInterp",
      value: function _vertexInterp(isoLevel, grid, ind1, ind2, vertex, normal) {
        var p1 = grid.p[ind1];
        var p2 = grid.p[ind2];
        var n1 = grid.g[ind1];
        var n2 = grid.g[ind2];
        var valP1 = grid.val[ind1];
        var valP2 = grid.val[ind2];
        var isoDiffP1 = isoLevel - valP1;
        var diffValP2P1 = valP2 - valP1;
        var mu = 0.0;

        if (Math.abs(diffValP2P1) > 0.0) {
          mu = isoDiffP1 / diffValP2P1;
        }

        mu = mu > 1.0 ? 1.0 : mu;
        vertex.lerpVectors(p1, p2, mu);
        normal.lerpVectors(n1, n2, mu);
      }
    }, {
      key: "_polygonize",
      value: function _polygonize(grid, isoLevel, triangles) {
        var cubeIndex = grid.cubeIndex;
        var i = 0;
        var arrSize = IsoSurface._arrSize;
        var firstIndices = IsoSurface._firstIndices;
        var secondIndices = IsoSurface._secondIndices;
        var vertexList = IsoSurface._vertexList;
        var normalList = IsoSurface._normalList;

        for (; i < arrSize; ++i) {
          if (edgeTable[cubeIndex] & 1 << i) {
            this._vertexInterp(isoLevel, grid, firstIndices[i], secondIndices[i], vertexList[i], normalList[i]);
          }
        }

        var triCount = 0;
        var triTblIdx = cubeIndex * 16;
        var triTable = IsoSurface._triTable;

        for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
          triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]]);
          triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]]);
          triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i + 1]]);
          triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i + 1]]);
          triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i + 2]]);
          triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i + 2]]);
          ++triCount;
        }

        return triCount;
      }
    }, {
      key: "_doGridPosNorms",
      value: function _doGridPosNorms(isoValue, step, appendSimple) {
        var vol = this._volumetricData;

        var volData = this._volumetricData.getData();

        var dim = vol.getDimensions();
        var xSize = dim[0];
        var ySize = dim[1];
        var zSize = dim[2];
        var stepX = step * vol.getStrideX();
        var stepY = step * vol.getStrideY();
        var stepZ = step * vol.getStrideZ();
        var gc = new GridCell();
        var gcVal = gc.val;
        var gcValSize = gc.val.length;
        var additions = [new THREE__namespace.Vector3(0, 0, 0), new THREE__namespace.Vector3(step, 0, 0), new THREE__namespace.Vector3(step, step, 0), new THREE__namespace.Vector3(0, step, 0), new THREE__namespace.Vector3(0, 0, step), new THREE__namespace.Vector3(step, 0, step), new THREE__namespace.Vector3(step, step, step), new THREE__namespace.Vector3(0, step, step)];
        var tmpTriCount = 5;
        var triangles = new Array(tmpTriCount);

        for (var j = 0; j < tmpTriCount; ++j) {
          triangles[j] = new Triangle();
        }

        var appendVertex;
        var self = this;
        var positions = this._position;
        var normals = this._normals;

        if (appendSimple) {
          appendVertex = function () {
            var axis = new THREE__namespace.Vector3(self._xAxis.x, self._yAxis.y, self._zAxis.z);
            return function (triVertex) {
              var vertex = triVertex.p.clone();
              vertex.multiply(axis);
              positions.push(vertex.add(self._origin));
              normals.push(triVertex.n.clone());
            };
          }();
        } else {
          appendVertex = function () {
            var posMtx = new THREE__namespace.Matrix3();
            posMtx.set(self._xAxis.x, self._yAxis.x, self._zAxis.x, self._xAxis.y, self._yAxis.y, self._zAxis.y, self._xAxis.z, self._yAxis.z, self._zAxis.z);
            var normMtx = new THREE__namespace.Matrix3();
            normMtx.set(self._xDir.x, self._yDir.x, self._zDir.x, self._xDir.y, self._yDir.y, self._zDir.y, self._xDir.z, self._yDir.z, self._zDir.z);
            return function (triVertex) {
              positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self._origin));
              normals.push(triVertex.n.clone().applyMatrix3(normMtx));
            };
          }();
        }

        var indices = this._indices;
        var globTriCount = 0;

        for (var z = 0; z < zSize - step; z += step) {
          for (var y = 0; y < ySize - step; y += step) {
            var idx = vol.getDirectIdx(0, y, z);

            for (var x = 0; x < xSize - step; x += step, idx += stepX) {
              gcVal[0] = volData[idx];
              gcVal[1] = volData[idx + stepX];
              gcVal[3] = volData[idx + stepY];
              gcVal[2] = volData[idx + stepX + stepY];
              gcVal[4] = volData[idx + stepZ];
              gcVal[5] = volData[idx + stepX + stepZ];
              gcVal[7] = volData[idx + stepY + stepZ];
              gcVal[6] = volData[idx + stepX + stepY + stepZ];
              var cubeIndex = 0;
              var i = 0;

              for (; i < gcValSize; ++i) {
                if (gcVal[i] < isoValue) {
                  cubeIndex |= 1 << i;
                }
              }

              if (edgeTable[cubeIndex] === 0) {
                continue;
              }

              gc.cubeIndex = cubeIndex;

              for (i = 0; i < gcValSize; ++i) {
                gc.p[i].set(x + additions[i].x, y + additions[i].y, z + additions[i].z);

                _voxelGradientFast(this._gradient, gc.p[i], gc.g[i]);
              }

              var triCount = this._polygonize(gc, isoValue, triangles);

              globTriCount += triCount;

              for (i = 0; i < triCount; ++i) {
                indices.push(this._numTriangles * 3);
                indices.push(this._numTriangles * 3 + 1);
                indices.push(this._numTriangles * 3 + 2);
                ++this._numTriangles;
                appendVertex(triangles[i].a);
                appendVertex(triangles[i].b);
                appendVertex(triangles[i].c);
              }
            }
          }
        }

        return globTriCount;
      }
    }, {
      key: "compute",
      value: function compute(volData, origin, isoValue, step) {
        this._volumetricData = volData;
        this._origin = origin;
        this._gradient = volData.computeGradient();

        this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
      }
    }, {
      key: "_remapIndices",
      value: function _remapIndices(vertexMap, idcCount) {
        var indices = this._indices;
        var newIndices = utils.allocateTyped(Uint32Array, idcCount);

        for (var i = 0; i < idcCount; ++i) {
          indices[i] = vertexMap[indices[i]];
          newIndices[i] = indices[i];
        }

        this._indices = newIndices;
      }
    }, {
      key: "_remapVertices",
      value: function _remapVertices(vertices, normals, count) {
        var newPositions = utils.allocateTyped(Float32Array, count * 3);
        var newNormals = utils.allocateTyped(Float32Array, count * 3);

        for (var i = 0; i < count; ++i) {
          var pos = vertices[i];
          newPositions[i * 3] = pos.x;
          newPositions[i * 3 + 1] = pos.y;
          newPositions[i * 3 + 2] = pos.z;
          var norm = normals[i].normalize();
          newNormals[i * 3] = norm.x;
          newNormals[i * 3 + 1] = norm.y;
          newNormals[i * 3 + 2] = norm.z;
        }

        this._position = newPositions;
        this._normals = newNormals;
      }
    }, {
      key: "vertexFusion",
      value: function vertexFusion(offset, len) {
        var faceVer = this._indices.length;
        var vertices = this._position;
        var normals = this._normals;
        var oldVerCount = vertices.length | 0;

        if (faceVer === 0 || oldVerCount === 0) {
          return;
        }

        var vMap = utils.allocateTyped(Uint32Array, oldVerCount);
        vMap[0] = 0;
        var newVer = 1;
        var i = 1;

        for (; i < oldVerCount; ++i) {
          var start = newVer - offset < 0 ? 0 : newVer - offset;
          var end = start + len > newVer ? newVer : start + len;
          var matchedIndex = -1;

          for (var j = start; j < end; ++j) {
            if (Math.abs(vertices[i] - vertices[j]) < Number.EPSILON) {
              matchedIndex = j;
              break;
            }
          }

          if (matchedIndex !== -1) {
            vMap[i] = matchedIndex;
          } else {
            vertices[newVer].copy(vertices[i]);
            normals[newVer].copy(normals[i]);
            vMap[i] = newVer;
            ++newVer;
          }
        }

        this._remapIndices(vMap, faceVer);

        this._remapVertices(vertices, normals, newVer);
      }
    }, {
      key: "setColorVolTex",
      value: function setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
        var i;
        var idx;
        var numVerts = this._position.length / 3;
        var vertices = this._position;
        var origin = this._origin;

        var dim = this._volumetricData.getDimensions();

        var xs = dim[0] - 1;
        var ys = dim[1] - 1;
        var zs = dim[2] - 1;
        var colorData = colorMap.getData();
        var strideX = colorMap.getStrideX();
        var strideY = colorMap.getStrideY();
        var strideZ = colorMap.getStrideZ();
        var atomWeightData;
        var atomStrideX;
        var atomStrideY;
        var atomStrideZ;

        if (visibilitySelector !== null) {
          atomWeightData = atomWeightMap.getData();
          atomStrideX = atomWeightMap.getStrideX();
          atomStrideY = atomWeightMap.getStrideY();
          atomStrideZ = atomWeightMap.getStrideZ();
        }

        var xInv = 1.0 / this._xAxis.x;
        var yInv = 1.0 / this._yAxis.y;
        var zInv = 1.0 / this._zAxis.z;
        var atomLookup = [];
        var atomWeights = [];
        var colors = utils.allocateTyped(Float32Array, numVerts * 3);

        function interp(mu, idx1, idx2, c) {
          c[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
          c[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
          c[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
        }

        function collectWeight(ai, coefX, coefY, coefZ) {
          var a = atomMap[ai];

          if (a != null) {
            atomLookup[a.index] = a;
            var w = coefX * coefY * coefZ * atomWeightData[ai];

            if (typeof atomWeights[a.index] === 'undefined') {
              atomWeights[a.index] = w;
            } else {
              atomWeights[a.index] += w;
            }
          }
        }

        var vMap = utils.allocateTyped(Int32Array, numVerts);
        var newVerCount = 0;

        for (i = 0; i < numVerts; i++) {
          var ind = i * 3;
          var vx = (vertices[ind] - origin.x) * xInv;
          var vy = (vertices[ind + 1] - origin.y) * yInv;
          var vz = (vertices[ind + 2] - origin.z) * zInv;
          var x = Math.min(Math.max(vx, 0), xs) | 0;
          var y = Math.min(Math.max(vy, 0), ys) | 0;
          var z = Math.min(Math.max(vz, 0), zs) | 0;
          var mux = vx - x;
          var muy = vy - y;
          var muz = vz - z;

          if (visibilitySelector != null) {
            atomLookup = [];
            atomWeights = [];
            idx = atomWeightMap.getDirectIdx(x, y, z);
            collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
            collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
            collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
            collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
            collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
            collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
            collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
            collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz);
            var maxWeight = 0.0;
            var dominantIdx = -1;

            for (var atomIdx in atomWeights) {
              if (atomWeights[atomIdx] > maxWeight) {
                dominantIdx = atomIdx;
                maxWeight = atomWeights[atomIdx];
              }
            }

            if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
              vMap[i] = -1;
              continue;
            }
          }

          vMap[i] = newVerCount++;
          var dx = x < xs ? strideX : 0;
          var dy = y < ys ? strideY : 0;
          var dz = z < zs ? strideZ : 0;
          var c0 = [0, 0, 0];
          var c1 = [0, 0, 0];
          var c2 = [0, 0, 0];
          var c3 = [0, 0, 0];
          idx = colorMap.getDirectIdx(x, y, z);
          interp(mux, idx, idx + dx, c0);
          interp(mux, idx + dy, idx + dx + dy, c1);
          interp(mux, idx + dz, idx + dx + dz, c2);
          interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);
          var cz0 = [0, 0, 0];
          cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
          cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
          cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
          var cz1 = [0, 0, 0];
          cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
          cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
          cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
          colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
          colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
          colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
        }

        this._colors = colors;

        if (visibilitySelector != null) {
          for (i = 0; i < numVerts; ++i) {
            var j = vMap[i];

            if (j < 0) {
              continue;
            }

            this._position[j * 3] = this._position[i * 3];
            this._position[j * 3 + 1] = this._position[i * 3 + 1];
            this._position[j * 3 + 2] = this._position[i * 3 + 2];
            this._normals[j * 3] = this._normals[i * 3];
            this._normals[j * 3 + 1] = this._normals[i * 3 + 1];
            this._normals[j * 3 + 2] = this._normals[i * 3 + 2];
            this._colors[j * 3] = this._colors[i * 3];
            this._colors[j * 3 + 1] = this._colors[i * 3 + 1];
            this._colors[j * 3 + 2] = this._colors[i * 3 + 2];
          }

          var numTriangles = this._indices.length / 3;
          var newTriCount = 0;

          for (i = 0; i < numTriangles; ++i) {
            var i0 = vMap[this._indices[3 * i]];
            var i1 = vMap[this._indices[3 * i + 1]];
            var i2 = vMap[this._indices[3 * i + 2]];

            if (i0 >= 0 && i1 >= 0 && i2 >= 0) {
              this._indices[3 * newTriCount] = i0;
              this._indices[3 * newTriCount + 1] = i1;
              this._indices[3 * newTriCount + 2] = i2;
              ++newTriCount;
            }
          }

          this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
          this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
          this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
          this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
        }
      }
    }, {
      key: "toMesh",
      value: function toMesh() {
        var geo = new THREE__namespace.BufferGeometry();
        geo.setIndex(new THREE__namespace.BufferAttribute(this._indices, 1));
        geo.setAttribute('position', new THREE__namespace.BufferAttribute(this._position, 3));
        geo.setAttribute('normal', new THREE__namespace.BufferAttribute(this._normals, 3));
        geo.setAttribute('color', new THREE__namespace.BufferAttribute(this._colors, 3));
        geo.computeBoundingSphere();
        return geo;
      }
    }]);

    return IsoSurface;
  }();

  _defineProperty(IsoSurface, "_triTable", IsoSurfaceMarchCube.prototype.striIndicesMarchCube);

  _defineProperty(IsoSurface, "_arrSize", 12);

  _defineProperty(IsoSurface, "_firstIndices", [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]);

  _defineProperty(IsoSurface, "_secondIndices", [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7]);

  _defineProperty(IsoSurface, "_vertexList", createArray(IsoSurface._arrSize));

  _defineProperty(IsoSurface, "_normalList", createArray(IsoSurface._arrSize));

  function _createSuper$1B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1B(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeSurfaceGeometry = /*#__PURE__*/function (_IsoSurfaceGeometry) {
    _inherits(VolumeSurfaceGeometry, _IsoSurfaceGeometry);

    var _super = _createSuper$1B(VolumeSurfaceGeometry);

    function VolumeSurfaceGeometry() {
      _classCallCheck(this, VolumeSurfaceGeometry);

      return _super.apply(this, arguments);
    }

    _createClass(VolumeSurfaceGeometry, [{
      key: "_build",
      value: function _build() {
        var params = this._opts;
        this.numVoxels = [128, 128, 128];
        this.xAxis = new THREE__namespace.Vector3(1.0, 0.0, 0.0);
        this.yAxis = new THREE__namespace.Vector3(0.0, 1.0, 0.0);
        this.zAxis = new THREE__namespace.Vector3(0.0, 0.0, 1.0);
        this.origin = new THREE__namespace.Vector3(0.0, 0.0, 0.0);
        this._visibilitySelector = params.visibilitySelector;

        this._calcSurface(params);
      }
    }, {
      key: "_findMinMax",
      value: function _findMinMax(posRadArray) {
        var itemSize = 4;
        var itemsCount = posRadArray.length / itemSize;
        var maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
        var minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];

        for (var i = 1; i < itemsCount; ++i) {
          var ind = i * itemSize;

          for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
            var tmpVal = posRadArray[ind + itemIdx];
            maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
            minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
          }
        }

        return {
          maxPosRad: maxPosRad,
          minPosRad: minPosRad
        };
      }
    }, {
      key: "_findNumVoxels",
      value: function _findNumVoxels(posRadArray, params) {
        var numVoxels = this.numVoxels;

        var minMaxValues = this._findMinMax(posRadArray);

        var minCoordRad = minMaxValues.minPosRad;
        var maxCoordRad = minMaxValues.maxPosRad;

        if (minCoordRad[3] > 4.0) {
          params.gridSpacing *= minCoordRad[3];
        }

        var gridPadding = params.radScale * maxCoordRad[3] * 1.7;
        var padRad = gridPadding;
        padRad = 0.65 * Math.sqrt(4.0 / 3.0 * Math.PI * padRad * padRad * padRad);
        gridPadding = Math.max(gridPadding, padRad);
        var i = 0;

        for (; i < 3; ++i) {
          minCoordRad[i] -= gridPadding;
          maxCoordRad[i] += gridPadding;
        }

        for (i = 0; i < 3; ++i) {
          numVoxels[i] = Math.ceil((maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing);
        }

        this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
        this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
        this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;

        var _minCoordRad = _slicedToArray(minCoordRad, 3);

        this.origin.x = _minCoordRad[0];
        this.origin.y = _minCoordRad[1];
        this.origin.z = _minCoordRad[2];
        return {
          bbox: minMaxValues,
          dim: numVoxels
        };
      }
    }, {
      key: "_makeSurface",
      value: function _makeSurface(surface, params) {
        var isoSurf = new IsoSurface();
        isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
        isoSurf.vertexFusion(9, 9);

        if (isoSurf._numTriangles > 0) {
          isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
          this.setIndex(new THREE__namespace.BufferAttribute(isoSurf._indices, 1));
          this.setAttribute('position', new THREE__namespace.BufferAttribute(isoSurf._position, 3));
          this.setAttribute('normal', new THREE__namespace.BufferAttribute(isoSurf._normals, 3));
          this.setAttribute('color', new THREE__namespace.BufferAttribute(isoSurf._colors, 3));
        } else {
          this.setAttribute('position', new THREE__namespace.BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
        }
      }
    }, {
      key: "_calcSurface",
      value: function _calcSurface(params) {
        var packedArrays = {
          posRad: this._posRad,
          colors: this._colors,
          atoms: this._opts.atoms
        };

        if (packedArrays.posRad.length === 0) {
          return;
        }

        var boundaries = this._findNumVoxels(packedArrays.posRad, params);

        var box = new THREE__namespace.Box3(this.origin, new THREE__namespace.Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));

        var surface = this._computeSurface(packedArrays, box, boundaries, params);

        this._makeSurface(surface, params);
      }
    }]);

    return VolumeSurfaceGeometry;
  }(IsoSurfaceGeometry);

  function _createSuper$1A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1A(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Volume$1 = chem.Volume;

  var QuickSurfGeometry = /*#__PURE__*/function (_VolumeSurfaceGeometr) {
    _inherits(QuickSurfGeometry, _VolumeSurfaceGeometr);

    var _super = _createSuper$1A(QuickSurfGeometry);

    function QuickSurfGeometry() {
      _classCallCheck(this, QuickSurfGeometry);

      return _super.apply(this, arguments);
    }

    _createClass(QuickSurfGeometry, [{
      key: "_computeSurface",
      value: function _computeSurface(packedArrays, box, boundaries, params) {
        this._shiftByOrigin(packedArrays.posRad);

        var surface = {
          volMap: new Volume$1(Float32Array, this.numVoxels, box),
          volTexMap: new Volume$1(Float32Array, this.numVoxels, box, 3)
        };

        if (this._visibilitySelector != null) {
          surface.atomMap = [];
          surface.atomWeightMap = new Volume$1(Float32Array, this.numVoxels, box);
        }

        this.gaussdensity(surface, packedArrays, null, params);
        return surface;
      }
    }, {
      key: "gaussdensity",
      value: function gaussdensity(surface, packedArrays, atomicNum, params) {
        var numAtoms = packedArrays.posRad.length / 4;
        var posRad = packedArrays.posRad,
            colors = packedArrays.colors;
        var numVoxels = this.numVoxels;
        var radScale = params.radScale,
            gaussLim = params.gaussLim,
            gridSpacing = params.gridSpacing;
        var invIsoValue = 1.0 / params.isoValue;
        var invGridSpacing = 1.0 / gridSpacing;
        var maxVoxelX = numVoxels[0] - 1;
        var maxVoxelY = numVoxels[1] - 1;
        var maxVoxelZ = numVoxels[2] - 1;
        var volMap = surface.volMap,
            volTexMap = surface.volTexMap;
        var volData = volMap.getData();
        var strideX = volMap.getStrideX();
        var volTexData = volTexMap.getData();
        var texStrideX = volTexMap.getStrideX();
        var atomWeightData;

        if (this._visibilitySelector != null) {
          atomWeightData = surface.atomWeightMap.getData();
        }

        var atomMap = surface.atomMap;

        for (var i = 0; i < numAtoms; ++i) {
          var ind = i * 4;
          var scaledRad = posRad[ind + 3] * radScale;
          var atomicNumFactor = atomicNum === null ? 1.0 : atomicNum[i];
          var radInv = 1 / (2 * scaledRad * scaledRad);
          var radLim = gaussLim * scaledRad;
          var radLim2 = radLim * radLim;
          radLim *= invGridSpacing;
          var tmp = posRad[ind] * invGridSpacing;
          var xMin = Math.max(tmp - radLim | 0, 0);
          var xMax = Math.min(tmp + radLim | 0, maxVoxelX);
          tmp = posRad[ind + 1] * invGridSpacing;
          var yMin = Math.max(tmp - radLim | 0, 0);
          var yMax = Math.min(tmp + radLim | 0, maxVoxelY);
          tmp = posRad[ind + 2] * invGridSpacing;
          var zMin = Math.max(tmp - radLim | 0, 0);
          var zMax = Math.min(tmp + radLim | 0, maxVoxelZ);
          var dz = zMin * gridSpacing - posRad[ind + 2];

          for (var z = zMin; z <= zMax; ++z, dz += gridSpacing) {
            var dy = yMin * gridSpacing - posRad[ind + 1];

            for (var y = yMin; y <= yMax; ++y, dy += gridSpacing) {
              var dy2dz2 = dy * dy + dz * dz;

              if (dy2dz2 >= radLim2) {
                continue;
              }

              var addr = volMap.getDirectIdx(xMin, y, z);
              var texAddr = volTexMap.getDirectIdx(xMin, y, z);
              var dx = xMin * gridSpacing - posRad[ind];

              for (var x = xMin; x <= xMax; ++x, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
                var r2 = dx * dx + dy2dz2;
                var expVal = -r2 * radInv;
                var density = Math.exp(expVal) * atomicNumFactor;

                if (this._visibilitySelector != null && density > atomWeightData[addr]) {
                  atomWeightData[addr] = density;
                  atomMap[addr] = packedArrays.atoms[i];
                }

                volData[addr] += density;
                density *= invIsoValue;
                var colInd = i * 3;
                volTexData[texAddr] += density * colors[colInd];
                volTexData[texAddr + 1] += density * colors[colInd + 1];
                volTexData[texAddr + 2] += density * colors[colInd + 2];
              }
            }
          }
        }
      }
    }, {
      key: "_shiftByOrigin",
      value: function _shiftByOrigin(posRadArray) {
        var originX = this.origin.x;
        var originY = this.origin.y;
        var originZ = this.origin.z;
        var itemSize = 4;
        var itemsCount = posRadArray.length / itemSize;

        for (var i = 0; i < itemsCount; ++i) {
          var ind = i * itemSize;
          posRadArray[ind] -= originX;
          posRadArray[ind + 1] -= originY;
          posRadArray[ind + 2] -= originZ;
        }
      }
    }]);

    return QuickSurfGeometry;
  }(VolumeSurfaceGeometry);

  function AVHash(posRad, min, max, maxDistance) {
    var itemSize = 4;
    var nAtoms = posRad.length / itemSize;
    var minX = min[0];
    var minY = min[1];
    var minZ = min[2];
    var maxX = max[0];
    var maxY = max[1];
    var maxZ = max[2];

    function hashFunc(w, minW) {
      return Math.floor((w - minW) / maxDistance);
    }

    var iDim = hashFunc(maxX, minX) + 1;
    var jDim = hashFunc(maxY, minY) + 1;
    var kDim = hashFunc(maxZ, minZ) + 1;
    var nCells = iDim * jDim * kDim;
    var jkDim = jDim * kDim;

    var cellID = function cellID(x, y, z) {
      return (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim + hashFunc(z, minZ);
    };

    var preHash = [];
    var i;
    var cid;

    for (i = 0; i < nAtoms; i++) {
      var iIdx = itemSize * i;
      cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);

      if (preHash[cid] === undefined) {
        preHash[cid] = [i];
      } else {
        preHash[cid].push(i);
      }
    }

    var cellOffsets = utils.allocateTyped(Uint32Array, nCells);
    var cellLengths = utils.allocateTyped(Uint16Array, nCells);
    var data = utils.allocateTyped(Uint32Array, nAtoms);
    var offset = 0;
    var maxCellLength = 0;
    var j;

    for (i = 0; i < nCells; i++) {
      var start = cellOffsets[i] = offset;
      var subArray = preHash[i];

      if (subArray !== undefined) {
        for (j = 0; j < subArray.length; j++) {
          data[offset] = subArray[j];
          offset++;
        }
      }

      var cellLength = offset - start;
      cellLengths[i] = cellLength;

      if (cellLength > maxCellLength) {
        maxCellLength = cellLength;
      }
    }

    this.neighbourListLength = 27 * maxCellLength + 1;

    this.withinRadii = function (x, y, z, rExtra, out) {
      var outIdx = 0;
      var nearI = hashFunc(x, minX);
      var nearJ = hashFunc(y, minY);
      var nearK = hashFunc(z, minZ);
      var loI = Math.max(0, nearI - 1);
      var loJ = Math.max(0, nearJ - 1);
      var loK = Math.max(0, nearK - 1);
      var hiI = Math.min(iDim - 1, nearI + 1);
      var hiJ = Math.min(jDim - 1, nearJ + 1);
      var hiK = Math.min(kDim - 1, nearK + 1);

      for (i = loI; i <= hiI; ++i) {
        var iOffset = i * jkDim;

        for (j = loJ; j <= hiJ; ++j) {
          var jOffset = j * kDim;

          for (var k = loK; k <= hiK; ++k) {
            cid = iOffset + jOffset + k;
            var cellStart = cellOffsets[cid];
            var cellEnd = cellStart + cellLengths[cid];

            for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
              var atomIndex = data[dataIndex];
              var baseIndex = itemSize * atomIndex;
              var dx = posRad[baseIndex] - x;
              var dy = posRad[baseIndex + 1] - y;
              var dz = posRad[baseIndex + 2] - z;
              var rSum = posRad[baseIndex + 3] + rExtra;

              if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
                out[outIdx++] = data[dataIndex];
              }
            }
          }
        }
      }

      out[outIdx] = -1;
    };
  }

  function ContactSurface(packedArrays, boundaries, params, _indexList) {
    var itemSize = 4;
    var posRad = packedArrays.posRad,
        colors = packedArrays.colors,
        atoms = packedArrays.atoms;
    var nAtoms = posRad.length / itemSize;
    var bbox = boundaries.bbox;
    var min = bbox.minPosRad;
    var max = bbox.maxPosRad;
    var r2;
    var maxRadius;
    var probeRadius;
    var scaleFactor;
    var probePositions;
    var lastClip = -1;
    var dim;
    var grid;
    var volTex;
    var weights;
    var weightsMap = null;
    var atomMap = null;
    var visibilitySelector = null;
    var gridx;
    var gridy;
    var gridz;
    var sinTable;
    var cosTable;
    var hash;
    var neighbours;
    var mid = new THREE__namespace.Vector3(0.0, 0.0, 0.0);
    var n1 = new THREE__namespace.Vector3(0.0, 0.0, 0.0);
    var n2 = new THREE__namespace.Vector3(0.0, 0.0, 0.0);
    var ngTorus;

    function uniformArray(TypeName, n, a) {
      var array = utils.allocateTyped(TypeName, n);

      for (var innI = 0; innI < n; ++innI) {
        array[innI] = a;
      }

      return array;
    }

    function fillGridDim(a, start, step) {
      for (var innI = 0; innI < a.length; innI++) {
        a[innI] = start + step * innI;
      }
    }

    function initializeGrid() {
      scaleFactor = params.scaleFactor;
      dim = boundaries.dim;
      ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
      var gridSize = dim[0] * dim[1] * dim[2];
      grid = uniformArray(Float32Array, gridSize, -1001.0);
      volTex = utils.allocateTyped(Float32Array, gridSize * 3);
      weights = utils.allocateTyped(Float32Array, gridSize);

      if (visibilitySelector) {
        weightsMap = utils.allocateTyped(Float32Array, gridSize);
        atomMap = [];
      }

      gridx = utils.allocateTyped(Float32Array, dim[0]);
      gridy = utils.allocateTyped(Float32Array, dim[1]);
      gridz = utils.allocateTyped(Float32Array, dim[2]);
      fillGridDim(gridx, min[0], 1 / scaleFactor);
      fillGridDim(gridy, min[1], 1 / scaleFactor);
      fillGridDim(gridz, min[2], 1 / scaleFactor);
    }

    function initializeAngleTables() {
      var theta = 0.0;
      var step = 2 * Math.PI / probePositions;
      cosTable = utils.allocateTyped(Float32Array, probePositions);
      sinTable = utils.allocateTyped(Float32Array, probePositions);

      for (var innI = 0; innI < probePositions; innI++) {
        cosTable[innI] = Math.cos(theta);
        sinTable[innI] = Math.sin(theta);
        theta += step;
      }
    }

    function initializeHash() {
      hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
      neighbours = new Int32Array(hash.neighbourListLength);
    }

    function init() {
      probeRadius = params.probeRadius;
      scaleFactor = params.scaleFactor;
      probePositions = params.probePositions;
      visibilitySelector = params.visibilitySelector;
      r2 = utils.allocateTyped(Float32Array, nAtoms);
      maxRadius = 0;

      for (var innI = 0; innI < nAtoms; ++innI) {
        var rExt = posRad[innI * itemSize + 3] += probeRadius;

        if (rExt > maxRadius) {
          maxRadius = rExt;
        }

        r2[innI] = rExt * rExt;
      }

      initializeGrid();
      initializeAngleTables();
      initializeHash();
      lastClip = -1;
    }

    function singleAtomObscures(ai, innX, innY, innZ) {
      var innCI = itemSize * ai;
      var ra2 = r2[ai];
      var dx = posRad[innCI] - innX;
      var dy = posRad[innCI + 1] - innY;
      var dz = posRad[innCI + 2] - innZ;
      var d2 = dx * dx + dy * dy + dz * dz;
      return d2 < ra2;
    }

    function obscured(innX, innY, innZ, a, b) {
      var ai;

      if (lastClip !== -1) {
        ai = lastClip;

        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          return ai;
        }

        lastClip = -1;
      }

      var ni = 0;
      ai = neighbours[ni];

      while (ai >= 0) {
        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          lastClip = ai;
          return ai;
        }

        ai = neighbours[++ni];
      }

      lastClip = -1;
      return -1;
    }

    function projectPoints() {
      var maxRad = 4.0;
      var sigma = maxRad / 3;
      var sigma2Inv = 1 / (2 * sigma * sigma);

      for (var innI = 0; innI < nAtoms; innI++) {
        var innCI = itemSize * innI;
        var ax = posRad[innCI];
        var ay = posRad[innCI + 1];
        var az = posRad[innCI + 2];
        var ar = posRad[innCI + 3];
        var ar2 = r2[innI];
        hash.withinRadii(ax, ay, az, ar, neighbours);
        var ng = Math.ceil(ar * scaleFactor);
        var iax = Math.floor(scaleFactor * (ax - min[0]));
        var iay = Math.floor(scaleFactor * (ay - min[1]));
        var iaz = Math.floor(scaleFactor * (az - min[2]));
        var minx = Math.max(0, iax - ng);
        var miny = Math.max(0, iay - ng);
        var minz = Math.max(0, iaz - ng);
        var maxx = Math.min(dim[0], iax + ng + 2);
        var maxy = Math.min(dim[1], iay + ng + 2);
        var maxz = Math.min(dim[2], iaz + ng + 2);
        var colIdx = innI * 3;
        var cr = colors[colIdx];
        var cg = colors[colIdx + 1];
        var cb = colors[colIdx + 2];

        for (var iz = minz; iz < maxz; iz++) {
          var dz = gridz[iz] - az;
          var zOffset = dim[1] * dim[0] * iz;

          for (var iy = miny; iy < maxy; iy++) {
            var dy = gridy[iy] - ay;
            var dzy2 = dz * dz + dy * dy;
            var zyOffset = zOffset + dim[0] * iy;

            for (var ix = minx; ix < maxx; ix++) {
              var idx = ix + zyOffset;
              var dx = gridx[ix] - ax;
              var d2 = dzy2 + dx * dx;

              if (d2 < ar2) {
                var w = Math.exp(-d2 * sigma2Inv);
                var cIdx = idx * 3;
                volTex[cIdx] += cr * w;
                volTex[cIdx + 1] += cg * w;
                volTex[cIdx + 2] += cb * w;
                weights[idx] += w;

                if (visibilitySelector !== null && w > weightsMap[idx]) {
                  weightsMap[idx] = w;
                  atomMap[idx] = atoms[innI];
                }

                if (grid[idx] < 0.0) {
                  grid[idx] = -grid[idx];
                }

                var d = Math.sqrt(d2);
                var ap = ar / d;
                var spx = dx * ap;
                var spy = dy * ap;
                var spz = dz * ap;
                spx += ax;
                spy += ay;
                spz += az;

                if (obscured(spx, spy, spz, innI, -1) === -1) {
                  var dd = ar - d;

                  if (dd < grid[idx]) {
                    grid[idx] = dd;
                  }
                }
              }
            }
          }
        }
      }
    }

    function normalToLine(out, p) {
      out.x = out.y = out.z = 1.0;

      if (p.x !== 0) {
        out.x = (p.y + p.z) / -p.x;
      } else if (p.y !== 0) {
        out.y = (p.x + p.z) / -p.y;
      } else if (p.z !== 0) {
        out.z = (p.x + p.y) / -p.z;
      }

      return out;
    }

    function projectTorus(a, b) {
      var aIdx = itemSize * a;
      var bIdx = itemSize * b;
      var xa = posRad[aIdx];
      var ya = posRad[aIdx + 1];
      var za = posRad[aIdx + 2];
      var r1 = posRad[aIdx + 3];
      var dx = mid.x = posRad[bIdx] - xa;
      var dy = mid.y = posRad[bIdx + 1] - ya;
      var dz = mid.z = posRad[bIdx + 2] - za;
      var innR2 = posRad[bIdx + 3];
      var d2 = dx * dx + dy * dy + dz * dz;
      var d = Math.sqrt(d2);
      var cosA = (r1 * r1 + d * d - innR2 * innR2) / (2.0 * r1 * d);
      var dmp = r1 * cosA;
      mid.normalize();
      normalToLine(n1, mid);
      n1.normalize();
      n2.crossVectors(mid, n1);
      n2.normalize();
      var rInt = Math.sqrt(r1 * r1 - dmp * dmp);
      n1.multiplyScalar(rInt);
      n2.multiplyScalar(rInt);
      mid.multiplyScalar(dmp);
      mid.x += xa;
      mid.y += ya;
      mid.z += za;
      lastClip = -1;
      var ng = ngTorus;

      for (var innI = 0; innI < probePositions; innI++) {
        var cost = cosTable[innI];
        var sint = sinTable[innI];
        var px = mid.x + cost * n1.x + sint * n2.x;
        var py = mid.y + cost * n1.y + sint * n2.y;
        var pz = mid.z + cost * n1.z + sint * n2.z;

        if (obscured(px, py, pz, a, b) === -1) {
          var iax = Math.floor(scaleFactor * (px - min[0]));
          var iay = Math.floor(scaleFactor * (py - min[1]));
          var iaz = Math.floor(scaleFactor * (pz - min[2]));
          var minx = Math.max(0, iax - ng);
          var miny = Math.max(0, iay - ng);
          var minz = Math.max(0, iaz - ng);
          var maxx = Math.min(dim[0], iax + ng + 2);
          var maxy = Math.min(dim[1], iay + ng + 2);
          var maxz = Math.min(dim[2], iaz + ng + 2);

          for (var iz = minz; iz < maxz; iz++) {
            dz = pz - gridz[iz];
            var zOffset = dim[1] * dim[0] * iz;

            for (var iy = miny; iy < maxy; iy++) {
              dy = py - gridy[iy];
              var dzy2 = dz * dz + dy * dy;
              var zyOffset = zOffset + dim[0] * iy;

              for (var ix = minx; ix < maxx; ix++) {
                dx = px - gridx[ix];
                d2 = dzy2 + dx * dx;
                var idx = ix + zyOffset;
                var current = grid[idx];

                if (current > 0.0 && d2 < current * current) {
                  grid[idx] = Math.sqrt(d2);
                }
              }
            }
          }
        }
      }
    }

    function projectTorii() {
      for (var innI = 0; innI < nAtoms; innI++) {
        var innIdx = itemSize * innI;
        hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
        var ia = 0;
        var ni = neighbours[ia];

        while (ni >= 0) {
          if (innI < ni) {
            projectTorus(innI, ni);
          }

          ni = neighbours[++ia];
        }
      }
    }

    function fixNegatives() {
      for (var innI = 0, n = grid.length; innI < n; innI++) {
        if (grid[innI] < 0) grid[innI] = 0;
        var w = weights[innI];

        if (w > 0) {
          w = 1 / w;
          var innInnI = innI * 3;
          volTex[innInnI] *= w;
          volTex[innInnI + 1] *= w;
          volTex[innInnI + 2] *= w;
        }
      }
    }

    function getVolume() {
      console.time('ContactSurface.getVolume');
      console.time('ContactSurface.init');
      init();
      console.timeEnd('ContactSurface.init');
      console.time('ContactSurface.projectPoints');
      projectPoints();
      console.timeEnd('ContactSurface.projectPoints');
      console.time('ContactSurface.projectTorii');
      projectTorii();
      console.timeEnd('ContactSurface.projectTorii');
      fixNegatives();
      console.timeEnd('ContactSurface.getVolume');
    }

    this.build = function () {
      getVolume();
      this.volTexMap = volTex;
      this.weightsMap = weightsMap;
      this.atomMap = atomMap;
      this.volMap = grid;
    };
  }

  function _createSuper$1z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1z(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Volume = chem.Volume;

  var ContactSurfaceGeometry = /*#__PURE__*/function (_VolumeSurfaceGeometr) {
    _inherits(ContactSurfaceGeometry, _VolumeSurfaceGeometr);

    var _super = _createSuper$1z(ContactSurfaceGeometry);

    function ContactSurfaceGeometry() {
      _classCallCheck(this, ContactSurfaceGeometry);

      return _super.apply(this, arguments);
    }

    _createClass(ContactSurfaceGeometry, [{
      key: "_computeSurface",
      value: function _computeSurface(packedArrays, box, boundaries, params) {
        var contactSurface = new ContactSurface(packedArrays, boundaries, params);
        contactSurface.build();
        var surface = {
          volMap: new Volume(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
          volTexMap: new Volume(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
          atomMap: contactSurface.atomMap,
          atomWeightMap: new Volume(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
        };
        return surface;
      }
    }]);

    return ContactSurfaceGeometry;
  }(VolumeSurfaceGeometry);

  var IsoSurfaceAtomColored = function IsoSurfaceAtomColored(vCenter, radiusAt) {
    _classCallCheck(this, IsoSurfaceAtomColored);

    this.coord = new THREE__namespace.Vector3();
    this.coord.copy(vCenter);
    this.radius = radiusAt;
    this.colorX = 0.99999;
    this.colorY = 0.0;
    this.colorZ = 0.0;
    this.atomType = 0;
    this.srcAtom = null;
  };

  var IsosurfaceBuildNormals = /*#__PURE__*/function () {
    function IsosurfaceBuildNormals(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
      _classCallCheck(this, IsosurfaceBuildNormals);

      this._numAtoms = numAtoms;
      this._atoms = atoms;
      this._vBoxMin = new THREE__namespace.Vector3();
      this._vBoxMax = new THREE__namespace.Vector3();

      this._vBoxMin.copy(vBoxMin);

      this._vBoxMax.copy(vBoxMax);

      this._probeRadius = probeRadius;
      this._atomsList = null;
      this._voxelList = null;
    }

    _createClass(IsosurfaceBuildNormals, [{
      key: "createVoxels",
      value: function createVoxels() {
        var numAtomsRefs;
        var rad;
        var ATOM_VOXEL_REF_SCALE = 4.5;
        var numAtoms = this._numAtoms | 0;
        var atoms = this._atoms;
        var dx = this._vBoxMax.x - this._vBoxMin.x;
        var dy = this._vBoxMax.y - this._vBoxMin.y;
        var dz = this._vBoxMax.z - this._vBoxMin.z;
        var w = dx < dy ? dx : dy;
        w = dz < w ? dz : w;
        var maxRad = 0.0;
        var aveRad = 0.0;
        var i;

        for (i = 0; i < numAtoms; i++) {
          rad = (atoms[i].radius + this._probeRadius) * 2.0;
          maxRad = rad > maxRad ? rad : maxRad;
          aveRad += rad;
        }

        var numCells = Math.floor(w / maxRad);

        if (numCells < 2) {
          numCells = 2;
        }

        aveRad /= numAtoms;
        this._numCells = numCells;
        this._aveRad = aveRad;
        this._maxRad = maxRad;
        var side = numCells;
        var side2 = numCells * numCells;
        var side3 = numCells * numCells * numCells;
        var xScale = this._xScale = 1.0 / (this._vBoxMax.x - this._vBoxMin.x);
        var yScale = this._yScale = 1.0 / (this._vBoxMax.y - this._vBoxMin.y);
        var zScale = this._zScale = 1.0 / (this._vBoxMax.z - this._vBoxMin.z);
        var maxAtomsRefs = 0;
        var xNumVoxMult = xScale * numCells;
        var yNumVoxMult = yScale * numCells;
        var zNumVoxMult = zScale * numCells;

        for (i = 0; i < numAtoms; i++) {
          var radAffect = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
          var diaAffect = radAffect * 2.0;
          var numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
          var numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
          var numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8);
          numVoxX++;
          numVoxY++;
          numVoxZ++;
          maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
        }

        this._voxelList = utils.allocateTyped(Int32Array, side3);
        var atomsList = [];
        atomsList.length = maxAtomsRefs;

        if (this._voxelList === null || atomsList === null) {
          return 0 - 1;
        }

        for (i = 0; i < side3; i++) {
          this._voxelList[i] = -1;
        }

        numAtomsRefs = 0;

        for (i = 0; i < numAtoms; i++) {
          rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
          var xIndMin = Math.floor((atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
          var yIndMin = Math.floor((atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
          var zIndMin = Math.floor((atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
          var xIndMax = Math.floor((atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
          var yIndMax = Math.floor((atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
          var zIndMax = Math.floor((atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
          xIndMin = xIndMin >= 0 ? xIndMin : 0;
          yIndMin = yIndMin >= 0 ? yIndMin : 0;
          zIndMin = zIndMin >= 0 ? zIndMin : 0;
          xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
          yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
          zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;

          for (var z = zIndMin; z <= zIndMax; z++) {
            for (var y = yIndMin; y <= yIndMax; y++) {
              for (var x = xIndMin; x <= xIndMax; x++) {
                var indVoxel = x + y * side + z * side2;

                if (this._voxelList[indVoxel] < 0) {
                  atomsList[numAtomsRefs * 2 + 0] = i;
                  atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
                  this._voxelList[indVoxel] = numAtomsRefs;
                  numAtomsRefs++;
                  continue;
                }

                var indexNext = this._voxelList[indVoxel];
                this._voxelList[indVoxel] = numAtomsRefs;
                atomsList[numAtomsRefs * 2 + 0] = i;
                atomsList[numAtomsRefs * 2 + 1] = indexNext;
                numAtomsRefs++;
              }
            }
          }
        }

        this._atomsList = Int32Array.from(atomsList);
        return 0;
      }
    }, {
      key: "destroyVoxels",
      value: function destroyVoxels() {
        this._atomsList = null;
        this._voxelList = null;
        this._atoms = null;
        this._vertices = null;
        this._vBoxMin = null;
        this._vBoxMax = null;
      }
    }, {
      key: "forEachRelatedAtom",
      value: function forEachRelatedAtom(point, process) {
        var xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
        var yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
        var zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
        var indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells;
        var atoms = this._atoms;

        for (var ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
          var indexAtom = this._atomsList[ref * 2];
          process(atoms[indexAtom]);
        }
      }
    }, {
      key: "getClosestAtom",
      value: function getClosestAtom(point) {
        var closest = null;
        var minDist2 = Number.MAX_VALUE;
        this.forEachRelatedAtom(point, function (atom) {
          var dist2 = point.distanceToSquared(atom.coord);

          if (dist2 < minDist2) {
            minDist2 = dist2;
            closest = atom;
          }
        });
        return closest;
      }
    }, {
      key: "buildNormals",
      value: function buildNormals(numVertices, vertices, normals) {
        var self = this;
        var numCloseAtoms = 0;
        var vx = 0;
        var vy = 0;
        var vz = 0;
        var dist2;
        var vNormalX = 0;
        var vNormalY = 0;
        var vNormalZ = 0;
        var koef = 0;
        var w = 0;
        var r25 = 2.5;
        var r01 = 0.1;
        var maxRadAffect = this._aveRad * r25;
        var maxRadAffect2 = maxRadAffect * maxRadAffect;
        var expScale = -this._aveRad * r01;

        var gatherNormals = function gatherNormals(atom) {
          var dx = vx - atom.coord.x;
          var dy = vy - atom.coord.y;
          var dz = vz - atom.coord.z;
          dist2 = dx * dx + dy * dy + dz * dz;

          if (dist2 > maxRadAffect2) {
            return;
          }

          var rad = atom.radius + self._probeRadius;
          koef = dist2 - rad * rad;

          if (koef < 0.0) {
            koef = -koef;
          }

          w = Math.exp(expScale * koef);
          vNormalX += dx * w;
          vNormalY += dy * w;
          vNormalZ += dz * w;
          numCloseAtoms++;
        };

        for (var i = 0; i < numVertices; i++) {
          vx = vertices[i].x;
          vy = vertices[i].y;
          vz = vertices[i].z;
          numCloseAtoms = 0;
          vNormalX = vNormalY = vNormalZ = 0.0;
          this.forEachRelatedAtom(vertices[i], gatherNormals);
          dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;

          if (numCloseAtoms > 0) {
            koef = 1.0 / Math.sqrt(dist2);
            vNormalX *= koef;
            vNormalY *= koef;
            vNormalZ *= koef;
          }

          normals[i].x = vNormalX;
          normals[i].y = vNormalY;
          normals[i].z = vNormalZ;
        }

        return 0;
      }
    }, {
      key: "buildColors",
      value: function buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
        var self = this;
        var vx = 0.0;
        var vy = 0.0;
        var vz = 0.0;
        var koef = 0.0;
        var w = 0.0;
        var KOEF_ADD = 0.8;
        var maxRadAffect = radiusColorSmoothness;
        var maxRadAffect2 = maxRadAffect * maxRadAffect;
        var colorsClose = [];
        var weights = [];
        var weightsSum = 0;

        var gatherColors = function gatherColors(atom) {
          var dx = vx - atom.coord.x;
          var dy = vy - atom.coord.y;
          var dz = vz - atom.coord.z;
          var dist2 = dx * dx + dy * dy + dz * dz;

          if (dist2 > maxRadAffect2) {
            return;
          }

          var rad = atom.radius + self._probeRadius;
          koef = dist2 - rad * rad;

          if (koef < 0.0) {
            koef = -koef;
          }

          w = 1.0 / (KOEF_ADD + koef);
          colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
          weights.push(w);
          weightsSum += w;
        };

        for (var i = 0; i < numVertices; i++) {
          vx = vertices[i].x;
          vy = vertices[i].y;
          vz = vertices[i].z;
          colorsClose = [];
          weights = [];
          weightsSum = 0;
          this.forEachRelatedAtom(vertices[i], gatherColors);

          for (var j = 0; j < colorsClose.length; ++j) {
            var weightNormalized = weights[j] / weightsSum;
            colors[i].x += colorsClose[j][0] * weightNormalized;
            colors[i].y += colorsClose[j][1] * weightNormalized;
            colors[i].z += colorsClose[j][2] * weightNormalized;
          }
        }

        return 0;
      }
    }]);

    return IsosurfaceBuildNormals;
  }();

  var IsoSurfaceGeo = /*#__PURE__*/function () {
    function IsoSurfaceGeo(maxNumVertices, maxNumTriangles, needVertexColors) {
      _classCallCheck(this, IsoSurfaceGeo);

      this._maxNumVertices = maxNumVertices;
      this._maxNumTriangles = maxNumTriangles;
      this._vertices = new Array(maxNumVertices);
      this._normals = new Array(maxNumVertices);
      this._colors = null;

      if (needVertexColors) {
        this._colors = new Array(maxNumVertices);
      }

      this._indices = new Array(maxNumTriangles * (1 + 2));
      this._numVertices = 0;
      this._numTriangles = 0;
      var i;

      for (i = 0; i < maxNumVertices; i++) {
        this._vertices[i] = new THREE__namespace.Vector3();
        this._normals[i] = new THREE__namespace.Vector3();
      }

      for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
        this._indices[i] = -1;
      }

      if (needVertexColors) {
        for (i = 0; i < maxNumVertices; i++) {
          this._colors[i] = new THREE__namespace.Vector3();
        }
      }
    }

    _createClass(IsoSurfaceGeo, [{
      key: "destroy",
      value: function destroy() {
        this._vertices = null;
        this._normals = null;
        this._indices = null;
      }
    }]);

    return IsoSurfaceGeo;
  }();

  function _createSuper$1y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1y(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var COLOR_SIZE = 3;
  var HASH_SIZE = 32768;
  var Element$9 = chem.Element;

  var SSIsosurfaceGeometry = /*#__PURE__*/function (_IsoSurfaceGeometry) {
    _inherits(SSIsosurfaceGeometry, _IsoSurfaceGeometry);

    var _super = _createSuper$1y(SSIsosurfaceGeometry);

    function SSIsosurfaceGeometry() {
      _classCallCheck(this, SSIsosurfaceGeometry);

      return _super.apply(this, arguments);
    }

    _createClass(SSIsosurfaceGeometry, [{
      key: "_build",
      value: function _build() {
        this._innerBuild();

        var geoOut = this.getGeo();
        this.destroy();

        this._fromGeo(geoOut);
      }
    }, {
      key: "_fromGeo",
      value: function _fromGeo(geoOut) {
        var colors = null;
        var positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
        var normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);

        if (geoOut._colors !== null) {
          colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
        }

        var indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);

        for (var i = 0, j = 0; i < geoOut._numVertices; i++) {
          positions[j + 0] = geoOut._vertices[i].x;
          positions[j + 1] = geoOut._vertices[i].y;
          positions[j + 2] = geoOut._vertices[i].z;
          normals[j + 0] = geoOut._normals[i].x;
          normals[j + 1] = geoOut._normals[i].y;
          normals[j + 2] = geoOut._normals[i].z;
          j += 3;
        }

        if (colors !== null) {
          for (var _i = 0, _j = 0; _i < geoOut._numVertices; _i++, _j += 3) {
            colors[_j + 0] = geoOut._colors[_i].x;
            colors[_j + 1] = geoOut._colors[_i].y;
            colors[_j + 2] = geoOut._colors[_i].z;
          }
        }

        var numTri3 = geoOut._numTriangles * (1 + 2);

        for (var _i2 = 0; _i2 < numTri3; _i2++) {
          indices[_i2] = geoOut._indices[_i2];
        }

        this.setIndex(new THREE__namespace.BufferAttribute(indices, 1));
        this.setAttribute('position', new THREE__namespace.BufferAttribute(positions, 3));
        this.setAttribute('normal', new THREE__namespace.BufferAttribute(normals, 3));
        this.setAttribute('color', new THREE__namespace.BufferAttribute(colors, 3));
        this.computeBoundingBox();
        this.computeBoundingSphere();
        geoOut.destroy();
      }
    }, {
      key: "convertToAtomsColored",
      value: function convertToAtomsColored(packedArrays, atomsColored) {
        var atoms = packedArrays.atoms,
            colors = packedArrays.colors;

        for (var i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
          var vCenter = atoms[i].position;
          var radius = atoms[i].element.radius;
          atomsColored[i] = new IsoSurfaceAtomColored(vCenter, radius);
          var nm = atoms[i].element.number;
          atomsColored[i].atomType = this.getType(nm);
          var cIdx = COLOR_SIZE * i;
          atomsColored[i].colorX = colors[cIdx++];
          atomsColored[i].colorY = colors[cIdx++];
          atomsColored[i].colorZ = colors[cIdx];
          atomsColored[i].srcAtom = atoms[i];
        }
      }
    }, {
      key: "getGeo",
      value: function getGeo() {
        return this.geoOut;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.atoms = null;
        this.hashLines = null;
        this.hashEntries = null;
      }
    }, {
      key: "getBoundingBox",
      value: function getBoundingBox(atoms, vBoxMin, vBoxMax) {
        var bigNum = 10000000.0;
        vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
        vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
        var probeRadius2 = this.probeRadius * this.atomRadiusScale;
        var radMax = 0.0;

        for (var i = 0, num = atoms.length; i < num; i++) {
          var vCenter = atoms[i].coord;
          var rad = atoms[i].radius + probeRadius2;
          radMax = rad > radMax ? rad : radMax;

          if (vCenter.x - rad < vBoxMin.x) {
            vBoxMin.x = vCenter.x - rad;
          }

          if (vCenter.y - rad < vBoxMin.y) {
            vBoxMin.y = vCenter.y - rad;
          }

          if (vCenter.z - rad < vBoxMin.z) {
            vBoxMin.z = vCenter.z - rad;
          }

          if (vCenter.x + rad > vBoxMax.x) {
            vBoxMax.x = vCenter.x + rad;
          }

          if (vCenter.y + rad > vBoxMax.y) {
            vBoxMax.y = vCenter.y + rad;
          }

          if (vCenter.z + rad > vBoxMax.z) {
            vBoxMax.z = vCenter.z + rad;
          }
        }

        vBoxMin.x -= radMax;
        vBoxMin.y -= radMax;
        vBoxMin.z -= radMax;
        vBoxMax.x += radMax;
        vBoxMax.y += radMax;
        vBoxMax.z += radMax;
      }
    }, {
      key: "getCornerCoord",
      value: function getCornerCoord(vBoxMin, vBoxMax, x, y, z, numPoints, vOut) {
        var invNP = 1.0 / (numPoints - 1.0);
        var tx = x * invNP;
        var ty = y * invNP;
        var tz = z * invNP;
        vOut.x = vBoxMin.x * (1.0 - tx) + vBoxMax.x * tx;
        vOut.y = vBoxMin.y * (1.0 - ty) + vBoxMax.y * ty;
        vOut.z = vBoxMin.z * (1.0 - tz) + vBoxMax.z * tz;
      }
    }, {
      key: "buildEdgePoint",
      value: function buildEdgePoint(indexA, indexB, sign, cube, indexPointValue, vOut) {
        if (sign[indexA] ^ sign[indexB]) {
          var cTwentyFour = 24;
          var t = (0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]) / (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]);
          var xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
          var ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
          var za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
          var xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
          var yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
          var zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
          vOut.x = xa * (1.0 - t) + xb * t;
          vOut.y = ya * (1.0 - t) + yb * t;
          vOut.z = za * (1.0 - t) + zb * t;
        }
      }
    }, {
      key: "isTriangleVisible",
      value: function isTriangleVisible(v0, v1, v2) {
        var a0 = this.voxelWorld.getClosestAtom(v0);
        var a1 = this.voxelWorld.getClosestAtom(v1);
        var a2 = this.voxelWorld.getClosestAtom(v2);

        if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
          return false;
        }

        return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
      }
    }, {
      key: "addTriangle",
      value: function addTriangle(v0, v1, v2) {
        if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
          return true;
        }

        var geo = this.geoOut;

        if (geo._numTriangles >= this.maxNumTriangles) {
          return false;
        }

        var indInGeo0 = this.addVertexToGeo(geo, v0);
        var indInGeo1 = this.addVertexToGeo(geo, v1);
        var indInGeo2 = this.addVertexToGeo(geo, v2);

        if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
          return false;
        }

        var itr = 3 * geo._numTriangles;
        geo._indices[itr + 0] = indInGeo0;
        geo._indices[itr + 1] = indInGeo1;
        geo._indices[itr + 2] = indInGeo2;
        geo._numTriangles++;
        return true;
      }
    }, {
      key: "buildGeoFromCorners",
      value: function buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
        var arrSize = 12;
        var cNumVerts = 8;
        var numCells = meshRes - 1;
        var side = meshRes;
        var side2 = meshRes * meshRes;
        var vaEdges = new Array(arrSize);

        for (var i = 0; i < arrSize; i++) {
          vaEdges[i] = new THREE__namespace.Vector3();
        }

        var sign = [];

        for (var _i3 = 0; _i3 < cNumVerts; _i3++) {
          sign[_i3] = 1.0;
        }

        var vCorner = new THREE__namespace.Vector3();
        var indCell = 0;
        var indY = 0;

        for (var y = 0; y < numCells; y++, indY += side2) {
          var indZ = 0;

          for (var z = 0; z < numCells; z++, indZ += side) {
            for (var x = 0; x < numCells; x++) {
              if (!cube.hasIntersection[indCell]) {
                indCell++;
                continue;
              }

              var bitsInside = cube.bitsInside[indCell];
              this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner);
              var indPointValues = indCell * (2 << 2 + 2);

              for (var _i4 = 0, j = 0; _i4 < cNumVerts; _i4++) {
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.x;
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.y;
                cube.pointsValuesLinear[indPointValues + j++] = vCorner.z;
              }

              cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;
              cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;
              cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
              cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y;
              var indValues = indPointValues + 24;

              for (var _i5 = 0; _i5 < cNumVerts; ++_i5) {
                sign[_i5] = cube.pointsValuesLinear[indValues + _i5] < 0.0 ? 1 : 0;
              }

              this.buildEdgePoint(0, 1, sign, cube, indPointValues, vaEdges[0]);
              this.buildEdgePoint(1, 2, sign, cube, indPointValues, vaEdges[1]);
              this.buildEdgePoint(2, 3, sign, cube, indPointValues, vaEdges[2]);
              this.buildEdgePoint(3, 0, sign, cube, indPointValues, vaEdges[3]);
              this.buildEdgePoint(4, 5, sign, cube, indPointValues, vaEdges[4]);
              this.buildEdgePoint(5, 6, sign, cube, indPointValues, vaEdges[5]);
              this.buildEdgePoint(6, 7, sign, cube, indPointValues, vaEdges[6]);
              this.buildEdgePoint(7, 4, sign, cube, indPointValues, vaEdges[7]);
              this.buildEdgePoint(0, 4, sign, cube, indPointValues, vaEdges[8]);
              this.buildEdgePoint(1, 5, sign, cube, indPointValues, vaEdges[9]);
              this.buildEdgePoint(2, 6, sign, cube, indPointValues, vaEdges[10]);
              this.buildEdgePoint(3, 7, sign, cube, indPointValues, vaEdges[11]);
              var offs = bitsInside * (2 << 1 + 2);

              for (var numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
                var i0 = cube.striIndicesMarchCube[offs + indTri];

                if (i0 < 0) {
                  break;
                }

                var i1 = cube.striIndicesMarchCube[offs + indTri + 1];
                var i2 = cube.striIndicesMarchCube[offs + indTri + 2];

                if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])) {
                  return 0 - 2;
                }
              }

              indCell++;
            }
          }
        }

        return 0;
      }
    }, {
      key: "getNumIntersectedCells",
      value: function getNumIntersectedCells(side, numCells, corners, cube) {
        var side2 = side * side;
        var cNumVerts = 8;
        var numIntersectedCells = 0;
        var indCell = 0;
        var indY = 0;

        for (var y = 0; y < numCells; y++, indY += side2) {
          var indZ = 0;

          for (var z = 0; z < numCells; z++, indZ += side) {
            for (var x = 0; x < numCells; x++) {
              var cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
              var indCorner = x + indZ + indY;
              cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
              cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
              cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
              cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
              cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side];
              var bitsInside = 0;

              for (var i = 0; i < cNumVerts; ++i) {
                if (cube.pointsValuesLinear[cubeValuesIndex + i] < 0.0) {
                  bitsInside |= 1 << i;
                }
              }

              if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
                cube.hasIntersection[indCell] = false;
              } else {
                cube.hasIntersection[indCell] = true;
                numIntersectedCells++;
              }

              cube.bitsInside[indCell] = bitsInside;
              indCell++;
            }
          }
        }

        return numIntersectedCells;
      }
    }, {
      key: "getType",
      value: function getType(letter) {
        var atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];

        if (letter < 1 || letter > atomT.length / 2 || Object.keys(Element$9.ByAtomicNumber).length * 2 !== atomT.length) {
          throw new Error('atomT.length  should be equal Element.ByAtomicNumber.length * 2');
        }

        return atomT[letter * 2];
      }
    }, {
      key: "calculateGridCorners",
      value: function calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
        var side2 = side * side;
        var side3 = side2 * side;
        var vCorner = new THREE__namespace.Vector3();
        var vDif = new THREE__namespace.Vector3();
        var aLot = +1.0e12;

        for (var i = 0; i < side3; i++) {
          corners[i] = aLot;
        }

        var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
        var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
        var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);

        for (var s = 0, numAtoms = atoms.length; s < numAtoms; s++) {
          var atom = atoms[s];
          var radius = atom.radius + probeRad;
          var fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
          var fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
          var fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
          var indXMin = Math.floor(fx);
          var indYMin = Math.floor(fy);
          var indZMin = Math.floor(fz);
          var indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
          var indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
          var indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
          indXMax++;
          indYMax++;
          indZMax++;
          indXMax = indXMax <= side - 1 ? indXMax : side - 1;
          indYMax = indYMax <= side - 1 ? indYMax : side - 1;
          indZMax = indZMax <= side - 1 ? indZMax : side - 1;

          for (var y = indYMin; y <= indYMax; y++) {
            var indY = y * side2;

            for (var z = indZMin; z <= indZMax; z++) {
              var indZ = z * side;

              for (var x = indXMin; x <= indXMax; x++) {
                var ind = indY + indZ + x;
                this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner);
                vDif.x = vCorner.x - atom.coord.x;
                vDif.y = vCorner.y - atom.coord.y;
                vDif.z = vCorner.z - atom.coord.z;
                var distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z);
                var val = distToSphere - radius;

                if (val < corners[ind]) {
                  corners[ind] = val;
                }
              }
            }
          }
        }
      }
    }, {
      key: "createVertexHash",
      value: function createVertexHash(maxNumVertices, maxNumTriangles) {
        this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);

        if (this.hashLines === null) {
          return 0 - 1;
        }

        for (var i = 0, j = 0; i < HASH_SIZE; i++) {
          this.hashLines[j++] = 0;
          this.hashLines[j++] = 0 - 1;
        }

        this.maxNumVertices = maxNumVertices;
        this.maxNumTriangles = maxNumTriangles;
        this.numHashEtriesAllocated = maxNumVertices;
        this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);

        if (this.hashEntries === null) {
          return 0 - 1;
        }

        for (var _i6 = 0, _j2 = 0; _i6 < this.numHashEtriesAllocated; _i6++) {
          this.hashEntries[_j2++] = 0 - 1;
          this.hashEntries[_j2++] = 0 - 1;
        }

        this.numHashEntryIndex = 0;
        return 0;
      }
    }, {
      key: "getNewHashEntry",
      value: function getNewHashEntry() {
        if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
          var i = this.numHashEntryIndex;
          this.numHashEntryIndex++;
          return i;
        }

        return 0 - 1;
      }
    }, {
      key: "addVertexToGeo",
      value: function addVertexToGeo(geoOut, vAdd) {
        var entry;
        var oneHynberes = 0.01;
        var n815851 = 815851;
        var n37633 = 37633;
        var n2453543 = 2453543;
        var r106 = 1.0e-6;
        var hashResolution = this.marCubeResoultion << 2;
        var v = new THREE__namespace.Vector3();
        var ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
        var iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
        var iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
        var iHash = ix * n815851 + iz * n37633 + iy * n2453543;
        iHash &= HASH_SIZE - 1;
        var hLineIndex = iHash + iHash;

        if (this.vBoxMin !== null && this.vBoxMax !== null) {
          for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
            var ind = this.hashEntries[entry * 2 + 0];
            v.copy(geoOut._vertices[ind]);
            v.x -= vAdd.x;
            v.y -= vAdd.y;
            v.z -= vAdd.z;
            var dot2 = v.x * v.x + v.y * v.y + v.z * v.z;

            if (dot2 < r106) {
              return ind;
            }
          }
        }

        if (geoOut._numVertices >= this.maxNumVertices) {
          return 0 - 1;
        }

        var iVertAdd = geoOut._numVertices;

        geoOut._vertices[iVertAdd].copy(vAdd);

        if (this.vBoxMin !== null && this.vBoxMax !== null) {
          entry = this.getNewHashEntry();

          if (entry < 0) {
            return 0 - 1;
          }

          var entryFirst = this.hashLines[hLineIndex + 1];
          this.hashLines[hLineIndex + 1] = entry;
          this.hashEntries[entry * 2 + 0] = iVertAdd;
          this.hashEntries[entry * 2 + 1] = entryFirst;
          this.hashLines[hLineIndex + 0]++;
        }

        geoOut._numVertices++;
        return iVertAdd;
      }
    }, {
      key: "modifyExcludedFromGeo",
      value: function modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
        var ind;
        var distToSphere;
        var distToBorder;
        var r11 = 1.1;

        function innerBlockWorkAround() {
          if (distToBorder > 0.0) {
            if (corners[ind] < 0.0) {
              corners[ind] = distToBorder;
            }

            if (distToBorder > corners[ind]) {
              corners[ind] = distToBorder;
            }
          } else if (distToBorder > corners[ind]) {
            corners[ind] = distToBorder;
          }
        }

        var side2 = side * side;
        var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
        var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
        var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
        var probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
        var sideInv = 1.0 / (side - 1);

        for (var i = 0; i < geoOut._numVertices; i++) {
          var vCenter = geoOut._vertices[i];
          var radEst = probeSphereRadius * r11;
          var indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
          var indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
          var indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
          var indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
          var indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
          var indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
          indXMin = indXMin >= 0 ? indXMin : 0;
          indYMin = indYMin >= 0 ? indYMin : 0;
          indZMin = indZMin >= 0 ? indZMin : 0;
          indXMax = indXMax <= side - 1 ? indXMax : side - 1;
          indYMax = indYMax <= side - 1 ? indYMax : side - 1;
          indZMax = indZMax <= side - 1 ? indZMax : side - 1;

          for (var iy = indYMin; iy <= indYMax; iy++) {
            var indY = iy * side2;

            for (var iz = indZMin; iz <= indZMax; iz++) {
              var indZ = iz * side;

              for (var ix = indXMin; ix <= indXMax; ix++) {
                ind = indY + indZ + ix;
                var t = ix * sideInv;
                var xCorner = vBoxMin.x * (1.0 - t) + vBoxMax.x * t;
                t = iy * sideInv;
                var yCorner = vBoxMin.y * (1.0 - t) + vBoxMax.y * t;
                t = iz * sideInv;
                var zCorner = vBoxMin.z * (1.0 - t) + vBoxMax.z * t;
                var dx = xCorner - vCenter.x;
                var dy = yCorner - vCenter.y;
                var dz = zCorner - vCenter.z;
                var dist2 = dx * dx + dy * dy + dz * dz;

                if (dist2 < probeSpRad2) {
                  distToSphere = Math.sqrt(dist2);
                  distToBorder = -(distToSphere - probeSphereRadius);
                  innerBlockWorkAround();
                }
              }
            }
          }
        }

        return 0;
      }
    }, {
      key: "_innerBuild",
      value: function _innerBuild() {
        var ok;
        var expandFactor = 1.2;
        var packedArrays = {
          posRad: this._posRad,
          colors: this._colors,
          atoms: this._opts.atoms
        };
        this.complex = this._opts.parent;
        this.atoms = packedArrays.atoms;
        this.meshResolution = this._opts.gridSpacing;
        this.atomRadiusScale = this._opts.radScale;
        this.colorMode = this._opts.colorMode;
        this.probeRadius = this._opts.probeRadius;
        this.useVertexColors = true;
        this.excludeProbe = this._opts.excludeProbe;
        this.visibilitySelector = this._opts.visibilitySelector;
        this.geoOut = null;
        this.hashLines = null;
        this.hashEntries = null;
        this.numHashEtriesAllocated = 0;
        this.numHashEntryIndex = 0;
        this.maxNumVertices = 0;
        this.maxNumTriangles = 0;
        var atomsColored = new Array(this.atoms.length);
        this.convertToAtomsColored(packedArrays, atomsColored);
        var vBoxMin = this.vBoxMin = new THREE__namespace.Vector3();
        var vBoxMax = this.vBoxMax = new THREE__namespace.Vector3();
        this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
        var marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2);
        var side = marCubeResoultion;
        var side2 = side * side;
        var side3 = side2 * side;
        var corners = utils.allocateTyped(Float32Array, side3);
        var rProbeRadius = this.probeRadius * this.atomRadiusScale;
        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
        var numCells = marCubeResoultion - 1;
        var cube = new IsoSurfaceMarchCube();
        ok = cube.create(numCells);

        if (ok < 0) {
          return ok;
        }

        var vCellStep = new THREE__namespace.Vector3();
        vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
        vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
        vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
        var numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
        var maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
        var maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
        this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
        ok = this.createVertexHash(maxNumVertices, maxNumTriangles);

        if (ok < 0) {
          return ok;
        }

        var probeRadForNormalsColors = rProbeRadius;

        if (this.excludeProbe) {
          probeRadForNormalsColors = 0.01;
        }

        this.voxelWorld = new IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
        this.voxelWorld.createVoxels();
        ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);

        if (this.excludeProbe) {
          this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners);
          this.geoOut._vertices = null;
          this.geoOut._colors = null;
          this.geoOut._indices = null;
          this.geoOut._normals = null;
          this.geoOut._numVertices = 0;
          this.geoOut._numTriangles = 0;
          this.geoOut = null;
          numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
          maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
          maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
          this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
          ok = this.createVertexHash(maxNumVertices, maxNumTriangles);

          if (ok < 0) {
            return ok;
          }

          ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
        }

        this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals);
        var radiusColorSmoothness = 6.5;

        if (this.excludeProbe) {
          radiusColorSmoothness -= 1.5;
        }

        if (this.useVertexColors) {
          this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
        }

        this.voxelWorld.destroyVoxels();
        this.voxelWorld = null;
        cube.destroy();
        return ok;
      }
    }]);

    return SSIsosurfaceGeometry;
  }(IsoSurfaceGeometry);

  function _createSuper$1x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1x(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function createLabel(fieldTxt, className) {
    var text = document.createElement('div');
    text.className = className;

    if (typeof fieldTxt === 'string') {
      var spanText = document.createElement('span');
      spanText.style.fontSize = '150%';
      var strings = fieldTxt.split('\n');

      for (var i = 0, n = strings.length; i < n; ++i) {
        var spanNodeP = document.createElement('span');
        var spanNodeText = document.createTextNode(strings[i]);
        spanNodeP.appendChild(spanNodeText);
        spanText.appendChild(spanNodeP);

        if (i < n - 1) {
          spanText.appendChild(document.createElement('br'));
        }
      }

      text.appendChild(spanText);
    } else {
      text.appendChild(fieldTxt);
    }

    text.worldPos = new THREE__namespace.Vector3();
    return text;
  }

  var LabelsGeometry = /*#__PURE__*/function (_EventDispatcher) {
    _inherits(LabelsGeometry, _EventDispatcher);

    var _super = _createSuper$1x(LabelsGeometry);

    function LabelsGeometry(instanceCount, opts) {
      var _this;

      _classCallCheck(this, LabelsGeometry);

      _this = _super.call(this);
      _this._opts = opts;
      _this.items = [];
      _this.needsUpdate = false;
      var xTranslation = -50;
      var yTranslation = -50;

      switch (opts.horizontalAlign) {
        case 'left':
          xTranslation = 0;
          break;

        case 'right':
          xTranslation = -100;
          break;
      }

      switch (opts.verticalAlign) {
        case 'top':
          yTranslation = -100;
          break;

        case 'bottom':
          yTranslation = 0;
          break;
      }

      var deltaPos = new THREE__namespace.Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
      _this.userData = {
        translation: "translate(".concat(xTranslation, "%, ").concat(yTranslation, "%)"),
        offset: deltaPos
      };
      return _this;
    }

    _createClass(LabelsGeometry, [{
      key: "setItem",
      value: function setItem(itemIdx, itemPos, fieldTxt) {
        var opts = this._opts;
        var text = this.items[itemIdx] || createLabel(fieldTxt, 'label');
        text.worldPos.copy(itemPos);
        text.style.textAlign = opts.horizontalAlign;
        text.style.verticalAlign = opts.verticalAlign;
        this.items[itemIdx] = text;
      }
    }, {
      key: "setColor",
      value: function setColor(itemIdx, fColor, bColor) {
        var text = this.items[itemIdx];
        text.opts = {
          color: fColor,
          background: bColor
        };
      }
    }, {
      key: "startUpdate",
      value: function startUpdate() {
        return true;
      }
    }, {
      key: "finishUpdate",
      value: function finishUpdate() {
        this.needsUpdate = true;
        this.dispatchEvent({
          type: 'update'
        });
      }
    }, {
      key: "finalize",
      value: function finalize() {
        this.finishUpdate();
      }
    }, {
      key: "raycast",
      value: function raycast() {}
    }, {
      key: "setOpacity",
      value: function setOpacity() {}
    }, {
      key: "getSubset",
      value: function getSubset() {
        return [];
      }
    }]);

    return LabelsGeometry;
  }(EventDispatcher);

  var geometries = {
    InstancedSpheresGeometry: InstancedSpheresGeometry,
    SimpleSpheresGeometry: SimpleSpheresGeometry,
    Simple2CCylindersGeometry: Simple2CCylindersGeometry,
    Instanced2CCylindersGeometry: Instanced2CCylindersGeometry,
    ExtrudedObjectsGeometry: ExtrudedObjectsGeometry,
    ChunkedLinesGeometry: ChunkedLinesGeometry,
    TwoColorLinesGeometry: TwoColorLinesGeometry,
    CrossGeometry: CrossGeometry,
    QuickSurfGeometry: QuickSurfGeometry,
    ContactSurfaceGeometry: ContactSurfaceGeometry,
    SSIsosurfaceGeometry: SSIsosurfaceGeometry,
    LabelsGeometry: LabelsGeometry
  };

  var vertexShader = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n    varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform mat4 projMatrixInv;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 objectNormal = vec3(\r\n    dot(normal, matVector1.xyz),\r\n    dot(normal, matVector2.xyz),\r\n    dot(normal, matVector3.xyz));\r\n#else\r\n  vec3 objectNormal = vec3( normal );\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n    spritePosEye = posEye;\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n    vec2 spriteSize;\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // In ortho projection we skip z coordinate\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r\n\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r\n    #else\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n      // full sprite size in eye coords\r\n      float minZ = min(abs(p1.z), abs(p2.z));\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r\n    #endif\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t  vec4 worldPosition;\r\n\t  // see THREE.WebGLProgram.unrollLoops\r\n\t  #pragma unroll_loop_start\r\n\t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r\n\t  }\r\n\t  #pragma unroll_loop_end\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n";

  var fragmentShader$6 = "#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r\n\r\n    #ifdef SHADOWMAP_PCF_RAND\r\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r\n      // unroll_loop and unroll_loop has pattern:\r\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n      uniform sampler2D noiseTex;\r\n      uniform vec2 noiseTexelSize;\r\n      uniform vec2 srcTexelSize;\r\n      uniform mat4 projectionMatrix;\r\n    #endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n  uniform float nearPlaneValue;\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n\r\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r\n    uniform mat4 projectionMatrix;\r\n  #endif\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n\r\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point inside frustum\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r\n      // t1 is always smaller than t2 (from calculations)\r\n      point = p1;\r\n      frontFaced = 1.0;\r\n      return true;\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into sphere local coords\r\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\r\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r\n\r\n      // transform camera orientation vector into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into sphere local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n      // transform vector from camera pos to curPixel into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  varying vec4 spritePosEye;\r\n\r\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    float halfHeight = 0.5;\r\n\r\n    // choose nearest point\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\r\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n    vec4 v;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform camera orientation vector into cylinder local coords\r\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into cylinder local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform vector from camera pos to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n  vec4 r = vec4( fract( v * PackFactors ), v );\r\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n  return r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n  return dot( v, UnpackFactors );\r\n}\r\n\r\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n  struct DirectionalLightShadow {\r\n     vec2 shadowMapSize;\r\n     float shadowBias;\r\n     float shadowRadius;\r\n   };\r\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r\n\r\n  uniform vec3 ambientLightColor;\r\n\r\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r\n\r\n  #if defined(SHADOWMAP)\r\n  \tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n  \t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n  \t}\r\n\r\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r\n   \t  float shadow = 0.0;\r\n\r\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r\n      shadowCoord.xyz /= shadowCoord.w;\r\n\r\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n      bool inFrustum = all( inFrustumVec );\r\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n      bool frustumTest = all( frustumTestVec );\r\n\r\n      if ( frustumTest ) {\r\n        #ifdef SHADOWMAP_BASIC\r\n      \t  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n      \t#endif\r\n\r\n      \t#ifdef SHADOWMAP_PCF_SHARP\r\n      \t  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\r\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\r\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\r\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\r\n\r\n            shadow = (\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n            ) * ( 1.0 / 9.0 );\r\n        #endif\r\n\r\n        #ifdef SHADOWMAP_PCF_RAND\r\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r\n\r\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r\n\r\n          vec2 offset;\r\n          #pragma unroll_loop_start\r\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r\n          }\r\n          #pragma unroll_loop_end\r\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n        #endif\r\n      }\r\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r\n   }\r\n  #endif\r\n\r\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color * PI;\r\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor * PI;\r\n\r\n    float shadowMask = 1.0;\r\n    // see THREE.WebGLProgram.unrollLoops\r\n  \t#pragma unroll_loop_start\r\n  \t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n  \t    #ifdef SHADOWMAP\r\n  \t      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r\n        #endif\r\n\r\n  \t\t  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r\n  \t\t}\r\n  \t\t#pragma unroll_loop_end\r\n\r\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n  #if NUM_DIR_LIGHTS > 0\r\n    // see THREE.WebGLProgram.unrollLoops\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n  #ifdef ATTR_COLOR\r\n    vec3 vertexColor = vColor;\r\n  #else\r\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n  #endif\r\n\r\n  #ifdef ATTR_COLOR2\r\n    #ifdef CYLINDER_SPRITE\r\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n    #else\r\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n    #endif\r\n      // choose either color or color2\r\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n  #endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n  #ifdef DASHED_LINE\r\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n  #endif\r\n\r\n  // transparency prepass writes only z, so we don't need to calc the color\r\n  #ifdef PREPASS_TRANSP\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n    float totalOpacity = opacity;\r\n\r\n  #ifdef ATTR_ALPHA_COLOR\r\n    totalOpacity *= alphaCol;\r\n  #endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n  #ifdef FAKE_OPACITY\r\n    // discard pixels in checker pattern\r\n    vec2 dm_coord = floor(gl_FragCoord.xy);\r\n    dm_coord = fract(dm_coord * 0.5);\r\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n    vec4 diffuseColor = vec4(diffuse, 1.0);\r\n  #else\r\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n  #endif\r\n\r\n  float flipNormal;\r\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n    flipNormal = 1.0;\r\n    #ifdef DOUBLE_SIDED\r\n      flipNormal = float( gl_FrontFacing );\r\n    #endif\r\n    vec3 normal = normalize( vNormal ) * flipNormal;\r\n  #endif\r\n\r\n    diffuseColor.rgb *= vertexColor;\r\n\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n\r\n  #ifdef NORMALS_TO_G_BUFFER\r\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n      vec3 viewNormaInColor = viewNormalSprites;\r\n    #else\r\n      vec3 viewNormaInColor = viewNormal;\r\n      float frontFaced = float( gl_FrontFacing );\r\n    #endif\r\n    // [-1, 1] -> [0, 1]\r\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r\n  #endif\r\n\r\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n    vec3 viewDir;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDir = -pixelPosEye.xyz;\r\n    #else\r\n      viewDir = vViewPosition;\r\n    #endif\r\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r\n  #else\r\n    vec3 outgoingLight = diffuseColor.rgb;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_DEPTH\r\n    float depth = 0.0;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n      depth = gl_FragDepthEXT;\r\n    #else\r\n      depth = gl_FragCoord.z;\r\n    #endif\r\n    fragColor = packDepthToRGBA(depth);\r\n    return;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_POS\r\n    fragColor = world2colorMatrix * pixelPosWorld;\r\n  #else\r\n    #ifdef OVERRIDE_COLOR\r\n      fragColor = vec4(fixedColor, diffuseColor.a);\r\n    #else\r\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n    #endif\r\n\r\n    #ifdef USE_FOG\r\n      float viewDistance;\r\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n        viewDistance = abs(pixelPosEye.z);\r\n      #else\r\n        viewDistance = vViewPosition.z;\r\n      #endif\r\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n      #ifdef FOG_TRANSPARENT\r\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n      #else\r\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n      #endif\r\n    #endif\r\n\r\n  #endif\r\n}\r\n";

  var capabilities = {
    precision: 'mediump',
    init: function init(renderer) {
      this.precision = renderer.capabilities.getMaxPrecision('highp');
    }
  };

  var noiseWidth = 4;
  var noiseHeight = 4;

  var _noiseData = new Uint8Array([24, 52, 0, 254, 145, 0, 122, 0, 0, 7, 170, 0, 34, 214, 0, 173, 8, 0, 86, 249, 0, 160, 4, 0, 226, 46, 0, 224, 211, 0, 3, 157, 0, 174, 247, 0, 12, 182, 0, 220, 216, 0, 1, 109, 0, 253, 154, 0]);

  var _noiseWrapS = THREE__namespace.RepeatWrapping;
  var _noiseWrapT = THREE__namespace.RepeatWrapping;
  var _noiseMinFilter = THREE__namespace.NearestFilter;
  var _noiseMagFilter = THREE__namespace.NearestFilter;
  var _noiseMapping = THREE__namespace.UVMapping;
  var noiseTexture = new THREE__namespace.DataTexture(_noiseData, noiseWidth, noiseHeight, THREE__namespace.RGBFormat, THREE__namespace.UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
  noiseTexture.needsUpdate = true;
  var noise = {
    noiseWidth: noiseWidth,
    noiseHeight: noiseHeight,
    noiseTexture: noiseTexture
  };

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper$1w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1w(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var _samplesKernel$1 = [new THREE__namespace.Vector2(-0.541978, 0.840393), new THREE__namespace.Vector2(0.125533, -0.992089), new THREE__namespace.Vector2(0.374329, 0.927296), new THREE__namespace.Vector2(-0.105475, 0.994422)];
  var defaultUniforms = THREE__namespace.UniformsUtils.merge([THREE__namespace.UniformsLib.fog, THREE__namespace.UniformsLib.lights, {
    diffuse: {
      value: new THREE__namespace.Color(0xeeeeee)
    },
    opacity: {
      value: 1.0
    },
    specular: {
      type: 'c',
      value: new THREE__namespace.Color(0x111111)
    },
    shininess: {
      type: 'f',
      value: 30
    },
    fixedColor: {
      type: 'c',
      value: new THREE__namespace.Color(0xffffff)
    },
    zOffset: {
      type: 'f',
      value: 0.0
    },
    zClipValue: {
      type: 'f',
      value: 0.0
    },
    clipPlaneValue: {
      type: 'f',
      value: 0.0
    },
    nearPlaneValue: {
      type: 'f',
      value: -0.5
    },
    invModelViewMatrix: {
      type: '4fv',
      value: new THREE__namespace.Matrix4()
    },
    world2colorMatrix: {
      type: '4fv',
      value: new THREE__namespace.Matrix4()
    },
    dashedLineSize: {
      type: 'f',
      value: 0.1
    },
    dashedLinePeriod: {
      type: 'f',
      value: 0.2
    },
    projMatrixInv: {
      type: '4fv',
      value: new THREE__namespace.Matrix4()
    },
    viewport: {
      type: 'v2',
      value: new THREE__namespace.Vector2()
    },
    lineWidth: {
      type: 'f',
      value: 2.0
    },
    fogAlpha: {
      type: 'f',
      value: 1.0
    },
    samplesKernel: {
      type: 'v2v',
      value: null
    },
    noiseTex: {
      type: 't',
      value: null
    },
    noiseTexelSize: {
      type: 'v2',
      value: null
    },
    srcTexelSize: {
      type: 'v2',
      value: null
    }
  }]);
  var uberOptionNames = ['shininess', 'opacity', 'zOffset', 'diffuse', 'specular', 'fixedColor', 'zClipCoef', 'zClipValue', 'clipPlaneValue', 'world2colorMatrix', 'dashedLineSize', 'dashedLinePeriod', 'projMatrixInv', 'viewport', 'lineWidth', 'fogAlpha', 'samplesKernel', 'noiseTex', 'noiseTexelSize', 'srcTexelSize'];
  var uberOptions = {
    diffuse: new THREE__namespace.Color(0xffffff),
    specular: new THREE__namespace.Color(0x111111),
    shininess: 30,
    opacity: 1,
    fixedColor: new THREE__namespace.Color(0xffffff),
    zOffset: 0.0,
    zClipCoef: 2.0,
    zClipValue: 0.0,
    clipPlaneValue: 0.0,
    world2colorMatrix: new THREE__namespace.Matrix4(),
    dashedLineSize: 0.1,
    dashedLinePeriod: 0.3,
    projMatrixInv: new THREE__namespace.Matrix4(),
    viewport: new THREE__namespace.Vector2(800, 600),
    lineWidth: 2.0,
    fogAlpha: 1.0,
    samplesKernel: _samplesKernel$1,
    noiseTex: noise.noiseTexture,
    noiseTexelSize: new THREE__namespace.Vector2(1.0 / noise.noiseWidth, 1.0 / noise.noiseHeight),
    srcTexelSize: new THREE__namespace.Vector2(1.0 / 800.0, 1.0 / 600.0),
    copy: function copy(source) {
      this.diffuse.copy(source.diffuse);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.opacity = source.opacity;
      this.fixedColor.copy(source.fixedColor);
      this.zOffset = source.zOffset;
      this.zClipCoef = source.zClipCoef;
      this.zClipValue = source.zClipValue;
      this.clipPlaneValue = source.clipPlaneValue;
      this.world2colorMatrix.copy(source.world2colorMatrix);
      this.dashedLineSize = source.dashedLineSize;
      this.dashedLinePeriod = source.dashedLinePeriod;
      this.projMatrixInv = source.projMatrixInv;
      this.viewport = source.viewport;
      this.lineWidth = source.lineWidth;
      this.toonShading = source.toonShading;
      this.fogAlpha = source.fogAlpha;
      this.samplesKernel = source.samplesKernel;
      this.noiseTex = source.noiseTex;
      this.noiseTexelSize = source.noiseTexelSize;
      this.srcTexelSize = source.srcTexelSize;
    }
  };

  var UberMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(UberMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1w(UberMaterial);

    function UberMaterial(params) {
      var _this;

      _classCallCheck(this, UberMaterial);

      _this = _super.call(this, params);
      _this.fog = true;
      _this.instancedPos = false;
      _this.instancedMatrix = false;
      _this.attrColor = false;
      _this.attrColor2 = false;
      _this.attrAlphaColor = false;
      _this.overrideColor = false;
      _this.sphereSprite = false;
      _this.cylinderSprite = false;
      _this.zClip = false;
      _this.clipPlane = false;
      _this.fakeOpacity = false;
      _this.prepassTransparancy = false;
      _this.colorFromPos = false;
      _this.shadowmap = false;
      _this.shadowmapType = 'random';
      _this.colorFromDepth = false;
      _this.orthoCam = false;
      _this.dashedLine = false;
      _this.transparent = true;
      _this.thickLine = false;
      _this.fogTransparent = false;
      _this.normalsToGBuffer = false;
      _this.toonShading = false;
      _this.uberOptions = uberOptions;

      _this.setValues(_objectSpread({
        uniforms: THREE__namespace.UniformsUtils.clone(defaultUniforms),
        vertexShader: _this.precisionString() + vertexShader,
        fragmentShader: _this.precisionString() + fragmentShader$6,
        lights: true,
        fog: true,
        side: THREE__namespace.DoubleSide
      }, params));

      return _this;
    }

    _createClass(UberMaterial, [{
      key: "precisionString",
      value: function precisionString() {
        var precision = capabilities.precision;
        var str = "precision ".concat(precision, " float;\n") + "precision ".concat(precision, " int;\n\n");
        return str;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _get(_getPrototypeOf(UberMaterial.prototype), "copy", this).call(this, source);

        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = THREE__namespace.UniformsUtils.clone(source.uniforms);
        this.defines = _objectSpread({}, source.defines);
        this.extensions = source.extensions;
        this.fog = source.fog;
        this.instancedPos = source.instancedPos;
        this.instancedMatrix = source.instancedMatrix;
        this.attrColor = source.attrColor;
        this.attrColor2 = source.attrColor2;
        this.attrAlphaColor = source.attrAlphaColor;
        this.overrideColor = source.overrideColor;
        this.sphereSprite = source.sphereSprite;
        this.cylinderSprite = source.cylinderSprite;
        this.zClip = source.zClip;
        this.clipPlane = source.clipPlane;
        this.fakeOpacity = source.fakeOpacity;
        this.colorFromPos = source.colorFromPos;
        this.shadowmap = source.shadowmap;
        this.shadowmapType = source.shadowmapType;
        this.colorFromDepth = source.colorFromDepth;
        this.orthoCam = source.orthoCam;
        this.prepassTransparancy = source.prepassTransparancy;
        this.dashedLine = source.dashedLine;
        this.thickLine = source.thickLine;
        this.fogTransparent = source.fogTransparent;
        this.normalsToGBuffer = source.normalsToGBuffer;
        this.toonShading = source.toonShading;
        this.uberOptions.copy(source.uberOptions);
        return this;
      }
    }, {
      key: "createInstance",
      value: function createInstance() {
        var inst = new UberMaterial();
        inst.copy(this);
        inst.uberOptions = Object.create(this.uberOptions);
        return inst;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        }

        _get(_getPrototypeOf(UberMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};
        var extensions = {};

        if (this.fog) {
          defines.USE_FOG = 1;
        }

        if (this.instancedPos) {
          defines.INSTANCED_POS = 1;
        }

        if (this.instancedMatrix) {
          defines.INSTANCED_MATRIX = 1;
        }

        if (this.attrColor) {
          defines.ATTR_COLOR = 1;
        }

        if (this.attrColor2) {
          defines.ATTR_COLOR2 = 1;
        }

        if (this.attrAlphaColor) {
          defines.ATTR_ALPHA_COLOR = 1;
        }

        if (this.overrideColor) {
          defines.OVERRIDE_COLOR = 1;
        }

        if (this.sphereSprite) {
          defines.SPHERE_SPRITE = 1;
          extensions.fragDepth = 1;
        }

        if (this.cylinderSprite) {
          defines.CYLINDER_SPRITE = 1;
          extensions.fragDepth = 1;
        }

        if (this.zClip) {
          defines.ZCLIP = 1;
        }

        if (this.clipPlane) {
          defines.CLIP_PLANE = 1;
        }

        if (this.fakeOpacity) {
          defines.FAKE_OPACITY = 1;
        }

        if (this.lights) {
          defines.USE_LIGHTS = 1;
        }

        if (this.colorFromPos) {
          defines.COLOR_FROM_POS = 1;
        }

        if (this.shadowmap) {
          defines.SHADOWMAP = 1;

          if (this.shadowmapType === 'pcf') {
            defines.SHADOWMAP_PCF_SHARP = 1;
          } else if (this.shadowmapType === 'random') {
            defines.SHADOWMAP_PCF_RAND = 1;
          } else {
            defines.SHADOWMAP_BASIC = 1;
          }
        }

        if (this.colorFromDepth) {
          defines.COLOR_FROM_DEPTH = 1;
        }

        if (this.orthoCam) {
          defines.ORTHOGRAPHIC_CAMERA = 1;
        }

        if (this.prepassTransparancy) {
          defines.PREPASS_TRANSP = 1;
        }

        if (this.dashedLine) {
          defines.DASHED_LINE = 1;
        }

        if (this.thickLine) {
          defines.THICK_LINE = 1;
        }

        if (this.fogTransparent) {
          defines.FOG_TRANSPARENT = 1;
        }

        if (this.normalsToGBuffer) {
          extensions.drawBuffers = 1;
          defines.NORMALS_TO_G_BUFFER = 1;
        }

        if (this.toonShading) {
          defines.TOON_SHADING = 1;
        }

        this.defines = defines;
        this.extensions = extensions;
      }
    }, {
      key: "setUberOptions",
      value: function setUberOptions(values) {
        if (typeof values === 'undefined') {
          return;
        }

        for (var key in values) {
          if (!values.hasOwnProperty(key)) {
            continue;
          }

          if (this.uberOptions[key] instanceof THREE__namespace.Color) {
            this.uberOptions[key] = values[key].clone();
          } else {
            this.uberOptions[key] = values[key];
          }
        }
      }
    }, {
      key: "clone",
      value: function clone(shallow) {
        if (!shallow) {
          return THREE__namespace.Material.prototype.clone.call(this);
        }

        return this.createInstance();
      }
    }, {
      key: "updateUniforms",
      value: function updateUniforms() {
        var self = this;
        uberOptionNames.forEach(function (p) {
          if (self.uniforms.hasOwnProperty(p)) {
            if (self.uberOptions[p] instanceof THREE__namespace.Color || self.uberOptions[p] instanceof THREE__namespace.Matrix4) {
              self.uniforms[p].value = self.uberOptions[p].clone();
            } else {
              self.uniforms[p].value = self.uberOptions[p];
            }
          }
        });
      }
    }]);

    return UberMaterial;
  }(THREE__namespace.RawShaderMaterial);

  function _createSuper$1v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1v(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  function UberObject (SuperClass) {
    var NewObjectType = /*#__PURE__*/function (_SuperClass) {
      _inherits(NewObjectType, _SuperClass);

      var _super = _createSuper$1v(NewObjectType);

      function NewObjectType() {
        var _this;

        _classCallCheck(this, NewObjectType);

        for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
          rest[_key] = arguments[_key];
        }

        _this = _super.call.apply(_super, [this].concat(rest));
        _this.onBeforeRender = NewObjectType.prototype.onBeforeRender;
        return _this;
      }

      _createClass(NewObjectType, [{
        key: "onBeforeRender",
        value: function onBeforeRender(renderer, scene, camera, geometry, material, group) {
          this._onBeforeRender(renderer, scene, camera, geometry, material, group);

          this._update();
        }
      }, {
        key: "_onBeforeRender",
        value: function _onBeforeRender() {}
      }, {
        key: "_update",
        value: function _update() {
          var material = this.material;

          if (!material) {
            return;
          }

          if (material instanceof UberMaterial) {
            material.updateUniforms();
          }
        }
      }]);

      return NewObjectType;
    }(SuperClass);

    return NewObjectType;
  }

  function _createSuper$1u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1u(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$4 = UberObject(THREE__namespace.Mesh);

  var ZSpriteMesh = /*#__PURE__*/function (_Mesh) {
    _inherits(ZSpriteMesh, _Mesh);

    var _super = _createSuper$1u(ZSpriteMesh);

    function ZSpriteMesh() {
      var _this;

      _classCallCheck(this, ZSpriteMesh);

      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(rest));
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    _createClass(ZSpriteMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
        Mesh$4.prototype._onBeforeRender.call(this, renderer, scene, camera);

        var material = this.material;

        if (!material) {
          return;
        }

        if (material.uniforms.invModelViewMatrix) {
          this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
          material.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert();
          material.uniforms.nearPlaneValue.value = camera.near;
          material.uniformsNeedUpdate = true;
        }
      }
    }]);

    return ZSpriteMesh;
  }(Mesh$4);

  function _createSuper$1t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1t(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$3 = UberObject(THREE__namespace.Mesh);

  var ZClippedMesh = /*#__PURE__*/function (_Mesh) {
    _inherits(ZClippedMesh, _Mesh);

    var _super = _createSuper$1t(ZClippedMesh);

    function ZClippedMesh(geometry, material) {
      var _this;

      _classCallCheck(this, ZClippedMesh);

      _this = _super.call(this, geometry, material);
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    _createClass(ZClippedMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera) {
        Mesh$3.prototype._onBeforeRender.call(this, renderer, scene, camera);

        var geo = this.geometry;
        var material = this.material;

        if (!geo.zClip || !material.uberOptions) {
          return;
        }

        var zClipCoef = 0.5;
        var modelView = ZClippedMesh._modelView;
        var mvLength = ZClippedMesh._mvLength;
        var center = ZClippedMesh._center;
        modelView.multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
        var s = mvLength.setFromMatrixColumn(modelView, 0).length();
        center.copy(geo.boundingSphere.center);
        this.localToWorld(center);
        material.uberOptions.zClipValue = camera.position.z - center.z - s * (zClipCoef * geo.boundingSphere.radius);
      }
    }]);

    return ZClippedMesh;
  }(Mesh$3);

  _defineProperty(ZClippedMesh, "_mvLength", new THREE__namespace.Vector3());

  _defineProperty(ZClippedMesh, "_center", new THREE__namespace.Vector3());

  _defineProperty(ZClippedMesh, "_modelView", new THREE__namespace.Matrix4());

  function _createSuper$1s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TextMesh = /*#__PURE__*/function (_THREE$Group) {
    _inherits(TextMesh, _THREE$Group);

    var _super = _createSuper$1s(TextMesh);

    function TextMesh(geometry, _material) {
      var _this;

      _classCallCheck(this, TextMesh);

      _this = _super.call(this);
      _this.geometry = geometry;

      var self = _assertThisInitialized(_this);

      self.initialized = false;

      _this.geometry.addEventListener('update', function () {
        self.update();
      });

      return _this;
    }

    _createClass(TextMesh, [{
      key: "init",
      value: function init() {
        var children = this.children;

        for (var i = children.length - 1; i >= 0; --i) {
          this.remove(children[i]);
        }

        var _this$geometry = this.geometry,
            items = _this$geometry.items,
            userData = _this$geometry.userData;

        for (var _i = 0, n = items.length; _i < n; ++_i) {
          var srcItem = items[_i];

          if (!srcItem) {
            continue;
          }

          var item = utils.shallowCloneNode(srcItem);
          var label = new CSS2DObject(item);
          label.userData = ___default["default"].clone(userData);
          var el = label.getElement();
          el.style.visibility = 'visible';
          label.source = srcItem;
          this.add(label);
        }

        this.initialized = true;
      }
    }, {
      key: "update",
      value: function update() {
        var geo = this.geometry;

        if (!geo.needsUpdate) {
          return;
        }

        var children = this.children;

        if (!this.initialized) {
          this.init();
        }

        for (var i = 0, n = children.length; i < n; ++i) {
          var child = children[i];
          var item = child.source;
          child.position.copy(item.worldPos);
          child.userData.color = item.opts.color;
          child.userData.background = item.opts.background;
        }
      }
    }]);

    return TextMesh;
  }(THREE__namespace.Group);

  function _createSuper$1r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$2 = UberObject(THREE__namespace.Mesh);

  var SimpleMesh = /*#__PURE__*/function (_Mesh) {
    _inherits(SimpleMesh, _Mesh);

    var _super = _createSuper$1r(SimpleMesh);

    function SimpleMesh(geometry, material) {
      var _this;

      _classCallCheck(this, SimpleMesh);

      _this = _super.call(this, geometry, material);
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    return SimpleMesh;
  }(Mesh$2);

  function _createSuper$1q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh$1 = UberObject(THREE__namespace.Mesh);

  var _viewport = new THREE__namespace.Vector2();

  var ThickLineMesh = /*#__PURE__*/function (_Mesh) {
    _inherits(ThickLineMesh, _Mesh);

    var _super = _createSuper$1q(ThickLineMesh);

    function ThickLineMesh() {
      _classCallCheck(this, ThickLineMesh);

      return _super.apply(this, arguments);
    }

    _createClass(ThickLineMesh, [{
      key: "_onBeforeRender",
      value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
        var material = this.material;

        if (!material.uberOptions) {
          return;
        }

        material.uberOptions.projMatrixInv.copy(camera.projectionMatrix).invert();
        renderer.getSize(_viewport);
        material.uberOptions.viewport.set(_viewport.width, _viewport.height);
      }
    }]);

    return ThickLineMesh;
  }(Mesh$1);

  function _createSuper$1p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Mesh = UberObject(THREE__namespace.Mesh);

  var InstancedMesh = /*#__PURE__*/function (_Mesh) {
    _inherits(InstancedMesh, _Mesh);

    var _super = _createSuper$1p(InstancedMesh);

    function InstancedMesh() {
      var _this;

      _classCallCheck(this, InstancedMesh);

      for (var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++) {
        rest[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(rest));
      _this.castShadow = true;
      _this.receiveShadow = true;
      return _this;
    }

    return InstancedMesh;
  }(Mesh);

  var meshes = {
    ZClipped: ZClippedMesh,
    ZSprite: ZSpriteMesh,
    Text: TextMesh,
    Line: UberObject(THREE__namespace.Line),
    LineSegments: UberObject(THREE__namespace.LineSegments),
    Mesh: SimpleMesh,
    ThickLineMesh: ThickLineMesh,
    Instanced: InstancedMesh
  };

  function setMatParams(params, uniforms) {
    return function (material) {
      material.setValues(params);
      material.setUberOptions(uniforms);
    };
  }

  function _createInstancedCylinders(useZSprites, openEnded) {
    return {
      Geometry: function Geometry(a, b) {
        return new geometries.Instanced2CCylindersGeometry(a, b, useZSprites, openEnded);
      },
      Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
      initMaterial: setMatParams({
        instancedMatrix: true,
        attrColor: true,
        attrColor2: true,
        attrAlphaColor: true,
        cylinderSprite: useZSprites
      })
    };
  }

  function _createLineSegmentsGeoTriplet(geo, renderParams) {
    var thickLines = geo.prototype instanceof ThickLinesGeometry;
    var lineWidth = renderParams.lineWidth || 0;
    return {
      Geometry: geo,
      Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
      initMaterial: setMatParams({
        lights: false,
        attrColor: true,
        attrAlphaColor: true,
        thickLine: thickLines
      }, {
        lineWidth: lineWidth
      })
    };
  }

  function _createSimpleGeoTriplet(geoClass) {
    return {
      Geometry: geoClass,
      Object: meshes.Mesh,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: true
      })
    };
  }

  function _createIsoSurfaceGeoTriplet(geoClass, caps, settings, renderParams) {
    var surfaceOpts = {
      wireframe: !!renderParams.wireframe,
      fakeOpacity: settings.now.isoSurfaceFakeOpacity,
      zClip: renderParams.zClip
    };
    return {
      Geometry: geoClass,
      Object: meshes.ZClipped,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: false,
        wireframe: surfaceOpts.wireframe,
        fakeOpacity: surfaceOpts.fakeOpacity,
        zClip: surfaceOpts.zClip
      })
    };
  }

  var MeshCreator = /*#__PURE__*/function () {
    function MeshCreator() {
      _classCallCheck(this, MeshCreator);
    }

    _createClass(MeshCreator, null, [{
      key: "createSpheres",
      value: function createSpheres(caps, settings) {
        var useZSprites = settings.now.zSprites;
        return {
          Geometry: function Geometry(a, b) {
            return new geometries.InstancedSpheresGeometry(a, b, useZSprites);
          },
          Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
          initMaterial: setMatParams({
            instancedPos: true,
            attrColor: true,
            attrAlphaColor: true,
            sphereSprite: useZSprites
          })
        };
      }
    }, {
      key: "create2CClosedCylinders",
      value: function create2CClosedCylinders(_caps, _settings) {
        return _createInstancedCylinders(false, false);
      }
    }, {
      key: "create2CCylinders",
      value: function create2CCylinders(caps, settings) {
        return _createInstancedCylinders(settings.now.zSprites, true);
      }
    }, {
      key: "create2CLines",
      value: function create2CLines(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
      }
    }, {
      key: "createCrosses",
      value: function createCrosses(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
      }
    }, {
      key: "createExtrudedChains",
      value: function createExtrudedChains(_caps, _settings) {
        return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
      }
    }, {
      key: "createChunkedLines",
      value: function createChunkedLines(_caps, _settings, renderParams) {
        return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
      }
    }, {
      key: "createQuickSurface",
      value: function createQuickSurface(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createContactSurface",
      value: function createContactSurface(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createSASSES",
      value: function createSASSES(caps, settings, renderParams) {
        return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings, renderParams);
      }
    }, {
      key: "createLabels",
      value: function createLabels(_caps, _settings) {
        return {
          Geometry: geometries.LabelsGeometry,
          Object: meshes.Text,
          initMaterial: function initMaterial() {}
        };
      }
    }]);

    return MeshCreator;
  }();

  function _createSuper$1o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TransformGroup = /*#__PURE__*/function (_THREE$Object3D) {
    _inherits(TransformGroup, _THREE$Object3D);

    var _super = _createSuper$1o(TransformGroup);

    function TransformGroup(geometry, geoParams, material, transforms) {
      var _this;

      _classCallCheck(this, TransformGroup);

      _this = _super.call(this);
      _this._geometry = geometry;
      _this._geoParams = geoParams;
      var mat = material.createInstance();
      geoParams.initMaterial(mat);
      _this._material = mat;
      _this._transforms = transforms.length > 0 ? transforms : [new THREE__namespace.Matrix4()];

      var meshes = _this._createMeshes(geometry);

      for (var i = 0, n = meshes.length; i < n; ++i) {
        _this.add(meshes[i]);
      }

      return _this;
    }

    _createClass(TransformGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var ray = TransformGroup._ray;
        var inverseMatrix = TransformGroup._inverseMatrix;
        var children = this.children;
        ray.copy(raycaster.ray);

        for (var i = 0, n = children.length; i < n; ++i) {
          var child = children[i];

          if (!gfxutils.belongToSelectLayers(child)) {
            continue;
          }

          child.updateMatrixWorld();
          var mtx = child.matrixWorld;
          inverseMatrix.copy(mtx).invert();
          raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
          var childIntersects = [];

          this._geometry.raycast(raycaster, childIntersects);

          for (var j = 0, ciCount = childIntersects.length; j < ciCount; ++j) {
            var inters = childIntersects[j];

            if (inters.point) {
              inters.point.applyMatrix4(mtx);
              inters.distance = ray.origin.distanceTo(inters.point);
            }

            inters.object = child;
            intersects[intersects.length] = inters;
          }
        }

        raycaster.ray.copy(ray);
      }
    }, {
      key: "getSubset",
      value: function getSubset(chunkIndices) {
        var geos = this._geometry.getSubset(chunkIndices);

        var subset = [];
        var subIdx = 0;

        for (var i = 0, n = geos.length; i < n; ++i) {
          var meshes = this._createMeshes(geos[i]);

          for (var j = 0, meshCnt = meshes.length; j < meshCnt; ++j) {
            subset[subIdx++] = meshes[j];
          }
        }

        return subset;
      }
    }, {
      key: "_createMeshes",
      value: function _createMeshes(geometry) {
        var transforms = this._transforms;
        var Mesh = this._geoParams.Object;
        var material = this._material;
        var meshes = [];

        for (var i = 0, n = transforms.length; i < n; ++i) {
          var mesh = new Mesh(geometry, material);
          mesh.applyMatrix4(transforms[i]);
          meshes[i] = mesh;
        }

        return meshes;
      }
    }]);

    return TransformGroup;
  }(THREE__namespace.Object3D);

  _defineProperty(TransformGroup, "_inverseMatrix", new THREE__namespace.Matrix4());

  _defineProperty(TransformGroup, "_ray", new THREE__namespace.Ray());

  function _createSuper$1n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function wrapper(Name, args) {
    var params = [Name].concat(args);
    return Name.bind.apply(Name, _toConsumableArray(params));
  }

  var ChemGroup = /*#__PURE__*/function (_RCGroup) {
    _inherits(ChemGroup, _RCGroup);

    var _super = _createSuper$1n(ChemGroup);

    function ChemGroup(geoParams, selection, colorer, mode, transforms, polyComplexity, material) {
      var _this;

      _classCallCheck(this, ChemGroup);

      _this = _super.call(this);

      if (_this.constructor === ChemGroup) {
        throw new Error('Can not instantiate abstract class!');
      }

      _this._selection = selection;
      _this._mode = mode;
      _this._colorer = colorer;
      _this._chunksIdc = selection.chunks;
      _this._polyComplexity = polyComplexity;
      _this._geo = new (wrapper(geoParams.Geometry, _this._makeGeoArgs()))();
      _this._mesh = new TransformGroup(_this._geo, geoParams, material, transforms);

      _this.add(_this._mesh);

      _this._build();

      return _this;
    }

    _createClass(ChemGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        throw new Error('ChemGroup subclass must override _makeGeoArgs() method');
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : false;

        var chunksList = this._calcChunksList(mask, innerOnly);

        if (chunksList.length === 0) {
          return [];
        }

        return this._mesh.getSubset(chunksList);
      }
    }, {
      key: "_changeSubsetOpacity",
      value: function _changeSubsetOpacity(mask, value, innerOnly) {
        var chunksList = this._calcChunksList(mask, innerOnly);

        if (chunksList.length === 0) {
          return;
        }

        this._geo.setOpacity(chunksList, value);
      }
    }, {
      key: "enableSubset",
      value: function enableSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : true;

        this._changeSubsetOpacity(mask, 1.0, innerOnly);
      }
    }, {
      key: "disableSubset",
      value: function disableSubset(mask, innerOnly) {
        innerOnly = innerOnly !== undefined ? innerOnly : true;

        this._changeSubsetOpacity(mask, 0.0, innerOnly);
      }
    }]);

    return ChemGroup;
  }(RCGroup);

  function _createSuper$1m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsGroup = /*#__PURE__*/function (_ChemGroup) {
    _inherits(AtomsGroup, _ChemGroup);

    var _super = _createSuper$1m(AtomsGroup);

    function AtomsGroup() {
      _classCallCheck(this, AtomsGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AtomsGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var atoms = this._selection.atoms;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var atomsIdc = this._chunksIdc;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var atomIdx = atomsIdc[inters[i].chunkIdx];

          if (atomIdx < atoms.length) {
            inters[i].atom = atoms[atomIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var atoms = this._selection.atoms;
        var atomsIdc = this._chunksIdc;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];

          if ((atom.mask & mask) !== 0) {
            chunksList.push(i);
          }
        }

        return chunksList;
      }
    }]);

    return AtomsGroup;
  }(ChemGroup);

  function _createSuper$1l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSphereGroup = /*#__PURE__*/function (_AtomsGroup) {
    _inherits(AtomsSphereGroup, _AtomsGroup);

    var _super = _createSuper$1l(AtomsSphereGroup);

    function AtomsSphereGroup() {
      _classCallCheck(this, AtomsSphereGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AtomsSphereGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length, this._polyComplexity];
      }
    }, {
      key: "_build",
      value: function _build() {
        var atomsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          geo.setItem(i, atom.position, mode.calcAtomRadius(atom));
          geo.setColor(i, colorer.getAtomColor(atom, parent));
        }

        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var atomsIdc = this._selection.chunks;
        var atoms = this._selection.atoms;
        var mode = this._mode;
        var colorer = this._colorer;
        var updateColor = frameData.needsColorUpdate(colorer);
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), mode.calcAtomRadius(atom));

          if (updateColor) {
            geo.setColor(i, frameData.getAtomColor(colorer, atom));
          }
        }

        geo.finalize();
      }
    }]);

    return AtomsSphereGroup;
  }(AtomsGroup);

  function _createSuper$1k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSurfaceGroup = /*#__PURE__*/function (_AtomsSphereGroup) {
    _inherits(AtomsSurfaceGroup, _AtomsSphereGroup);

    var _super = _createSuper$1k(AtomsSurfaceGroup);

    function AtomsSurfaceGroup() {
      _classCallCheck(this, AtomsSurfaceGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AtomsSurfaceGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var selectedAtoms = [];
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks;
        var n = chunks.length;

        for (var i = 0; i < n; ++i) {
          selectedAtoms[i] = atoms[chunks[i]];
        }

        var opts = this._mode.getSurfaceOpts();

        opts.atoms = selectedAtoms;
        return [n, opts];
      }
    }]);

    return AtomsSurfaceGroup;
  }(AtomsSphereGroup);

  function _createSuper$1j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsSASSESGroupStub = /*#__PURE__*/function (_AtomsSphereGroup) {
    _inherits(AtomsSASSESGroupStub, _AtomsSphereGroup);

    var _super = _createSuper$1j(AtomsSASSESGroupStub);

    function AtomsSASSESGroupStub() {
      _classCallCheck(this, AtomsSASSESGroupStub);

      return _super.apply(this, arguments);
    }

    _createClass(AtomsSASSESGroupStub, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var selectedAtoms = [];
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks;
        var n = chunks.length;

        for (var i = 0; i < n; ++i) {
          selectedAtoms[i] = atoms[chunks[i]];
        }

        var opts = this._mode.getSurfaceOpts();

        opts.atoms = selectedAtoms;
        opts.selection = this._selection;
        opts.colorMode = this._colorer;
        return [n, opts];
      }
    }]);

    return AtomsSASSESGroupStub;
  }(AtomsSphereGroup);

  function _createSuper$1i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function adjustColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;

    if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
      r = r * 3 / 10;
      g = g * 3 / 10;
      b = b * 3 / 10;
    } else {
      r = 255 - (255 - r) * 3 / 10;
      g = 255 - (255 - g) * 3 / 10;
      b = 255 - (255 - b) * 3 / 10;
    }

    return r << 16 | g << 8 | b;
  }

  function inverseColor(color) {
    var r = color >> 16 & 255;
    var g = color >> 8 & 255;
    var b = color & 255;
    return 255 - r << 16 | 255 - g << 8 | 255 - b;
  }

  function getAtomText(atom) {
    if (atom.name.getNode() !== null) {
      return atom.name.getNode();
    }

    return atom.getVisualName();
  }

  var colorMappings = {
    none: function none(c) {
      return c;
    },
    adjust: adjustColor,
    inverse: inverseColor
  };

  function propagateColor(color, rule) {
    var result;

    if (colorMappings.hasOwnProperty(rule)) {
      result = utils.hexColor(colorMappings[rule](color));
    } else {
      var val = parseInt(rule, 16);

      if (!Number.isNaN(val) && rule.toLowerCase().startsWith('0x')) {
        result = utils.hexColor(val);
      } else {
        result = '#000000';
      }
    }

    return result;
  }

  var templateMappings = {
    serial: function serial(a) {
      return a.serial;
    },
    name: function name(a) {
      return a.getVisualName();
    },
    elem: function elem(a) {
      return a.element.name;
    },
    residue: function residue(a) {
      return a.residue.getType().getName();
    },
    sequence: function sequence(a) {
      return a.residue.getSequence();
    },
    chain: function chain(a) {
      return a.residue.getChain().getName();
    },
    hetatm: function hetatm(a) {
      return a.isHet();
    },
    water: function water(a) {
      return a.residue.getType().getName() === 'HOH' || a.residue.getType().getName() === 'WAT';
    }
  };

  var parseTemplate = function parseTemplate(atom, str) {
    return str.replace(/\{\{(\s*\w+\s*)\}\}/g, function (m) {
      var key = m.replace(/\s+/g, '');
      key = key.substring(2, key.length - 2).toLowerCase();

      if (templateMappings.hasOwnProperty(key)) {
        return templateMappings[key](atom);
      }

      return 'null';
    });
  };

  var AtomsTextGroup = /*#__PURE__*/function (_AtomsGroup) {
    _inherits(AtomsTextGroup, _AtomsGroup);

    var _super = _createSuper$1i(AtomsTextGroup);

    function AtomsTextGroup() {
      _classCallCheck(this, AtomsTextGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AtomsTextGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var opts = this._mode.getLabelOpts();

        return [this._selection.chunks.length, opts];
      }
    }, {
      key: "_build",
      value: function _build() {
        var opts = this._mode.getLabelOpts();

        var atomsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);

          if (!text) {
            continue;
          }

          var color = colorer.getAtomColor(atom, parent);
          var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
          var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
          geo.setItem(i, atom.position, text);
          geo.setColor(i, fgColor, bgColor);
        }

        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var opts = this._mode.getLabelOpts();

        var atomsIdc = this._selection.chunks;
        var atoms = this._selection.atoms;
        var colorer = this._colorer;
        var geo = this._geo;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = atomsIdc.length; i < n; ++i) {
          var atom = atoms[atomsIdc[i]];
          var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);

          if (!text) {
            continue;
          }

          var color = frameData.getAtomColor(colorer, atom);
          var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
          var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
          geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), text);

          if (updateColor) {
            geo.setColor(i, fgColor, bgColor);
          }
        }

        geo.finalize();
      }
    }]);

    return AtomsTextGroup;
  }(AtomsGroup);

  function _createSuper$1h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _slerp(omega, v1, v2, t) {
    var oSin = Math.sin(omega);
    return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
  }

  var AromaticGroup = /*#__PURE__*/function (_AtomsGroup) {
    _inherits(AromaticGroup, _AtomsGroup);

    var _super = _createSuper$1h(AromaticGroup);

    function AromaticGroup() {
      _classCallCheck(this, AromaticGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AromaticGroup, [{
      key: "_buildInner",
      value: function _buildInner(radOffset, addChunk) {
        var chunksToIdx = this._selection.chunks;
        var prevVector = new THREE__namespace.Vector3();
        var currVector = new THREE__namespace.Vector3();
        var segmentsHeight = this._segmentsHeight;
        var leprStep = 1.0 / segmentsHeight;
        var colorer = this._colorer;
        var _this$_selection = this._selection,
            cycles = _this$_selection.cycles,
            parent = _this$_selection.parent;
        var chunkIdx = 0;
        var currAtomIdx = chunksToIdx[chunkIdx];

        for (var cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
          var cycle = cycles[cIdx];
          var cycAtoms = cycle.atoms;
          var chunkPoints = [];
          var tmpDir = [];
          var center = cycle.center;
          var cycleRad = cycle.radius - radOffset;
          var n = cycAtoms.length;
          var i = 0;
          var prevPos = cycAtoms[n - 1].position;
          var currPos = cycAtoms[i].position;
          prevVector.subVectors(prevPos, center);
          currVector.subVectors(currPos, center);
          var upDir = currVector.clone().cross(prevVector).normalize();

          for (; i < n; ++i) {
            var omega = prevVector.angleTo(currVector);
            tmpDir[i] = _slerp(omega, prevVector, currVector, 0.5).normalize();
            currPos = cycAtoms[(i + 1) % n].position;
            prevVector.copy(currVector);
            currVector.subVectors(currPos, center);
          }

          for (i = 0; i < n; ++i) {
            if (cycAtoms[i].index !== currAtomIdx) {
              continue;
            }

            var start = tmpDir[i];
            var end = tmpDir[(i + 1) % n];
            var color = colorer.getAtomColor(cycAtoms[i], parent);
            var currAngle = start.angleTo(end);

            for (var j = 0; j <= segmentsHeight; ++j) {
              chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
            }

            addChunk(chunkIdx++, color, chunkPoints, center, upDir);
            currAtomIdx = chunksToIdx[chunkIdx];
          }
        }
      }
    }]);

    return AromaticGroup;
  }(AtomsGroup);

  function _createSuper$1g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _createShape$1(rad, parts) {
    var pts = [];

    for (var i = 0; i < parts; ++i) {
      var a = -2 * i / parts * Math.PI;
      pts.push(new THREE__namespace.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }

    return pts;
  }

  var calcChunkMatrix = gfxutils.calcChunkMatrix;

  var AromaticTorusGroup = /*#__PURE__*/function (_AromaticGroup) {
    _inherits(AromaticTorusGroup, _AromaticGroup);

    var _super = _createSuper$1g(AromaticTorusGroup);

    function AromaticTorusGroup() {
      _classCallCheck(this, AromaticTorusGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AromaticTorusGroup, [{
      key: "_build",
      value: function _build() {
        var segmentsHeight = this._segmentsHeight;

        var torusRad = this._mode.getAromRadius();

        var radiusV = new THREE__namespace.Vector2(torusRad, torusRad);
        var radOffset = this._mode.calcStickRadius() + 2 * torusRad;
        var lookAtVector = new THREE__namespace.Vector3();
        var mtc = [];
        var geo = this._geo;

        this._buildInner(radOffset, function (chunkIdx, color, points, center, upDir) {
          for (var j = 0; j <= segmentsHeight; ++j) {
            var currPoint = points[j];
            var currDir = currPoint.clone().sub(center).cross(upDir);
            lookAtVector.addVectors(currPoint, currDir);
            mtc[j] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
          }

          geo.setItem(chunkIdx, mtc);
          geo.setColor(chunkIdx, color);
        });

        geo.finalize();
      }
    }, {
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        this._segmentsHeight = this._polyComplexity;
        return [_createShape$1(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
      }
    }]);

    return AromaticTorusGroup;
  }(AromaticGroup);

  function _createSuper$1f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AromaticLinesGroup = /*#__PURE__*/function (_AromaticGroup) {
    _inherits(AromaticLinesGroup, _AromaticGroup);

    var _super = _createSuper$1f(AromaticLinesGroup);

    function AromaticLinesGroup() {
      _classCallCheck(this, AromaticLinesGroup);

      return _super.apply(this, arguments);
    }

    _createClass(AromaticLinesGroup, [{
      key: "_build",
      value: function _build() {
        var _this = this;

        var geo = this._geo;

        var radOffset = this._mode.getAromaticOffset();

        this._buildInner(radOffset, function (chunkIdx, color, points) {
          var prevPt = points[0];

          for (var j = 1; j <= _this._segmentsHeight; ++j) {
            var currPoint = points[j];
            geo.setSegment(chunkIdx, j - 1, prevPt, currPoint);
            prevPt = currPoint;
          }

          geo.setColor(chunkIdx, color);
        });

        geo.finalize();
      }
    }, {
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        this._segmentsHeight = this._mode.getAromaticArcChunks();
        return [this._selection.chunks.length, this._segmentsHeight, true];
      }
    }]);

    return AromaticLinesGroup;
  }(AromaticGroup);

  function _createSuper$1e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesGroup = /*#__PURE__*/function (_ChemGroup) {
    _inherits(ResiduesGroup, _ChemGroup);

    var _super = _createSuper$1e(ResiduesGroup);

    function ResiduesGroup() {
      _classCallCheck(this, ResiduesGroup);

      return _super.apply(this, arguments);
    }

    _createClass(ResiduesGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var residues = this._selection.residues;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var chunksIdc = this._chunksIdc;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var resIdx = chunksIdc[inters[i].chunkIdx];

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var residues = this._selection.residues;
        var resIdc = this._chunksIdc;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];

          if ((res._mask & mask) !== 0) {
            chunksList.push(i);
          }
        }

        return chunksList;
      }
    }]);

    return ResiduesGroup;
  }(ChemGroup);

  function _createSuper$1d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicItemGroup = /*#__PURE__*/function (_ResiduesGroup) {
    _inherits(NucleicItemGroup, _ResiduesGroup);

    var _super = _createSuper$1d(NucleicItemGroup);

    function NucleicItemGroup() {
      _classCallCheck(this, NucleicItemGroup);

      return _super.apply(this, arguments);
    }

    _createClass(NucleicItemGroup, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var residues = this._selection.residues;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var chunksIdc = this._chunksIdc;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var resIdx = chunksIdc[Math.floor(inters[i].chunkIdx / 2)];

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        var stickRad = this._mode.calcStickRadius();

        var chunkIdx = 0;
        var resIdc = this._selection.chunks;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];
          var color = colorer.getResidueColor(res, parent);

          this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
        }

        geo.finalize();
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var chunkIdx = 0;
        var residues = this._selection.residues;
        var resIdc = this._chunksIdc;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];

          if ((res._mask & mask) !== 0) {
            chunksList[chunkIdx++] = 2 * i;
            chunksList[chunkIdx++] = 2 * i + 1;
          }
        }

        return chunksList;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var residues = frameData.getResidues();
        var parent = this._selection.parent;
        var colorer = this._colorer;
        var geo = this._geo;

        var stickRad = this._mode.calcStickRadius();

        var chunkIdx = 0;
        var resIdc = this._selection.chunks;

        for (var i = 0, n = resIdc.length; i < n; ++i) {
          var res = residues[resIdc[i]];
          var color = colorer.getResidueColor(res, parent);

          this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
        }

        geo.finishUpdate();
      }
    }]);

    return NucleicItemGroup;
  }(ResiduesGroup);

  function _createSuper$1c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicCylindersGroup = /*#__PURE__*/function (_NucleicItemGroup) {
    _inherits(NucleicCylindersGroup, _NucleicItemGroup);

    var _super = _createSuper$1c(NucleicCylindersGroup);

    function NucleicCylindersGroup() {
      _classCallCheck(this, NucleicCylindersGroup);

      return _super.apply(this, arguments);
    }

    _createClass(NucleicCylindersGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length, this._polyComplexity];
      }
    }, {
      key: "_processItem",
      value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
        var geo = this._geo;
        geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
        geo.setColor(chunkIdx, color, color);
      }
    }]);

    return NucleicCylindersGroup;
  }(NucleicItemGroup);

  function _createSuper$1b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicSpheresGroup = /*#__PURE__*/function (_NucleicItemGroup) {
    _inherits(NucleicSpheresGroup, _NucleicItemGroup);

    var _super = _createSuper$1b(NucleicSpheresGroup);

    function NucleicSpheresGroup() {
      _classCallCheck(this, NucleicSpheresGroup);

      return _super.apply(this, arguments);
    }

    _createClass(NucleicSpheresGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        return [this._selection.chunks.length * 2, this._polyComplexity];
      }
    }, {
      key: "_processItem",
      value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
        var geo = this._geo;
        var idx = chunkIdx * 2;
        geo.setItem(idx, cyl1, stickRad);
        geo.setColor(idx, color);
        idx++;
        geo.setItem(idx, cyl2, stickRad);
        geo.setColor(idx, color);
      }
    }]);

    return NucleicSpheresGroup;
  }(NucleicItemGroup);

  var Smooth = {};

  (function (exports) {
  /*
  Smooth.js version 0.1.7

  Turn arrays into smooth functions.

  Copyright 2012 Spencer Cohen
  Licensed under MIT license (see "Smooth.js MIT license.txt")
  */

  /*Constants (these are accessible by Smooth.WHATEVER in user space)
  */

  (function() {
    var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, Smooth, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v, validateNumber, validateVector,
      __hasProp = Object.prototype.hasOwnProperty,
      __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

    Enum = {
      /*Interpolation methods
      */
      METHOD_NEAREST: 'nearest',
      METHOD_LINEAR: 'linear',
      METHOD_CUBIC: 'cubic',
      METHOD_LANCZOS: 'lanczos',
      METHOD_SINC: 'sinc',
      /*Input clipping modes
      */
      CLIP_CLAMP: 'clamp',
      CLIP_ZERO: 'zero',
      CLIP_PERIODIC: 'periodic',
      CLIP_MIRROR: 'mirror',
      /* Constants for control over the cubic interpolation tension
      */
      CUBIC_TENSION_DEFAULT: 0,
      CUBIC_TENSION_CATMULL_ROM: 0
    };

    defaultConfig = {
      method: Enum.METHOD_CUBIC,
      cubicTension: Enum.CUBIC_TENSION_DEFAULT,
      clip: Enum.CLIP_CLAMP,
      scaleTo: 0,
      sincFilterSize: 2,
      sincWindow: void 0
    };

    /*Index clipping functions
    */

    clipClamp = function(i, n) {
      return Math.max(0, Math.min(i, n - 1));
    };

    clipPeriodic = function(i, n) {
      i = i % n;
      if (i < 0) i += n;
      return i;
    };

    clipMirror = function(i, n) {
      var period;
      period = 2 * (n - 1);
      i = clipPeriodic(i, period);
      if (i > n - 1) i = period - i;
      return i;
    };

    /*
    Abstract scalar interpolation class which provides common functionality for all interpolators
    
    Subclasses must override interpolate().
    */

    AbstractInterpolator = (function() {

      function AbstractInterpolator(array, config) {
        this.array = array.slice(0);
        this.length = this.array.length;
        if (!(this.clipHelper = {
          clamp: this.clipHelperClamp,
          zero: this.clipHelperZero,
          periodic: this.clipHelperPeriodic,
          mirror: this.clipHelperMirror
        }[config.clip])) {
          throw "Invalid clip: " + config.clip;
        }
      }

      AbstractInterpolator.prototype.getClippedInput = function(i) {
        if ((0 <= i && i < this.length)) {
          return this.array[i];
        } else {
          return this.clipHelper(i);
        }
      };

      AbstractInterpolator.prototype.clipHelperClamp = function(i) {
        return this.array[clipClamp(i, this.length)];
      };

      AbstractInterpolator.prototype.clipHelperZero = function(i) {
        return 0;
      };

      AbstractInterpolator.prototype.clipHelperPeriodic = function(i) {
        return this.array[clipPeriodic(i, this.length)];
      };

      AbstractInterpolator.prototype.clipHelperMirror = function(i) {
        return this.array[clipMirror(i, this.length)];
      };

      AbstractInterpolator.prototype.interpolate = function(t) {
        throw 'Subclasses of AbstractInterpolator must override the interpolate() method.';
      };

      return AbstractInterpolator;

    })();

    NearestInterpolator = (function(_super) {

      __extends(NearestInterpolator, _super);

      function NearestInterpolator() {
        NearestInterpolator.__super__.constructor.apply(this, arguments);
      }

      NearestInterpolator.prototype.interpolate = function(t) {
        return this.getClippedInput(Math.round(t));
      };

      return NearestInterpolator;

    })(AbstractInterpolator);

    LinearInterpolator = (function(_super) {

      __extends(LinearInterpolator, _super);

      function LinearInterpolator() {
        LinearInterpolator.__super__.constructor.apply(this, arguments);
      }

      LinearInterpolator.prototype.interpolate = function(t) {
        var k;
        k = Math.floor(t);
        t -= k;
        return (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1);
      };

      return LinearInterpolator;

    })(AbstractInterpolator);

    CubicInterpolator = (function(_super) {

      __extends(CubicInterpolator, _super);

      function CubicInterpolator(array, config) {
        this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
        CubicInterpolator.__super__.constructor.apply(this, arguments);
      }

      CubicInterpolator.prototype.getTangent = function(k) {
        return this.tangentFactor * (this.getClippedInput(k + 1) - this.getClippedInput(k - 1)) / 2;
      };

      CubicInterpolator.prototype.interpolate = function(t) {
        var k, m, p, t2, t3;
        k = Math.floor(t);
        m = [this.getTangent(k), this.getTangent(k + 1)];
        p = [this.getClippedInput(k), this.getClippedInput(k + 1)];
        t -= k;
        t2 = t * t;
        t3 = t * t2;
        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
      };

      return CubicInterpolator;

    })(AbstractInterpolator);

    sin = Math.sin, PI = Math.PI;

    sinc = function(x) {
      if (x === 0) {
        return 1;
      } else {
        return sin(PI * x) / (PI * x);
      }
    };

    makeLanczosWindow = function(a) {
      return function(x) {
        return sinc(x / a);
      };
    };

    makeSincKernel = function(window) {
      return function(x) {
        return sinc(x) * window(x);
      };
    };

    SincFilterInterpolator = (function(_super) {

      __extends(SincFilterInterpolator, _super);

      function SincFilterInterpolator(array, config) {
        SincFilterInterpolator.__super__.constructor.apply(this, arguments);
        this.a = config.sincFilterSize;
        if (!config.sincWindow) throw 'No sincWindow provided';
        this.kernel = makeSincKernel(config.sincWindow);
      }

      SincFilterInterpolator.prototype.interpolate = function(t) {
        var k, n, sum, _ref, _ref2;
        k = Math.floor(t);
        sum = 0;
        for (n = _ref = k - this.a + 1, _ref2 = k + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
          sum += this.kernel(t - n) * this.getClippedInput(n);
        }
        return sum;
      };

      return SincFilterInterpolator;

    })(AbstractInterpolator);

    getColumn = function(arr, i) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arr.length; _i < _len; _i++) {
        row = arr[_i];
        _results.push(row[i]);
      }
      return _results;
    };

    makeScaledFunction = function(f, baseScale, scaleRange) {
      var scaleFactor, translation;
      if (scaleRange.join === '0,1') {
        return f;
      } else {
        scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
        translation = scaleRange[0];
        return function(t) {
          return f(scaleFactor * (t - translation));
        };
      }
    };

    getType = function(x) {
      return Object.prototype.toString.call(x).slice('[object '.length, -1);
    };

    validateNumber = function(n) {
      if (isNaN(n)) throw 'NaN in Smooth() input';
      if (getType(n) !== 'Number') throw 'Non-number in Smooth() input';
      if (!isFinite(n)) throw 'Infinity in Smooth() input';
    };

    validateVector = function(v, dimension) {
      var n, _i, _len;
      if (getType(v) !== 'Array') throw 'Non-vector in Smooth() input';
      if (v.length !== dimension) throw 'Inconsistent dimension in Smooth() input';
      for (_i = 0, _len = v.length; _i < _len; _i++) {
        n = v[_i];
        validateNumber(n);
      }
    };

    isValidNumber = function(n) {
      return (getType(n) === 'Number') && isFinite(n) && !isNaN(n);
    };

    normalizeScaleTo = function(s) {
      var invalidErr;
      invalidErr = "scaleTo param must be number or array of two numbers";
      switch (getType(s)) {
        case 'Number':
          if (!isValidNumber(s)) throw invalidErr;
          s = [0, s];
          break;
        case 'Array':
          if (s.length !== 2) throw invalidErr;
          if (!(isValidNumber(s[0]) && isValidNumber(s[1]))) throw invalidErr;
          break;
        default:
          throw invalidErr;
      }
      return s;
    };

    shallowCopy = function(obj) {
      var copy, k, v;
      copy = {};
      for (k in obj) {
        if (!__hasProp.call(obj, k)) continue;
        v = obj[k];
        copy[k] = v;
      }
      return copy;
    };

    Smooth = function(arr, config) {
      var baseDomainEnd, dimension, i, interpolator, interpolatorClass, interpolators, k, n, properties, smoothFunc, v;
      if (config == null) config = {};
      properties = {};
      config = shallowCopy(config);
      properties.config = shallowCopy(config);
      if (config.scaleTo == null) config.scaleTo = config.period;
      if (config.sincFilterSize == null) {
        config.sincFilterSize = config.lanczosFilterSize;
      }
      for (k in defaultConfig) {
        if (!__hasProp.call(defaultConfig, k)) continue;
        v = defaultConfig[k];
        if (config[k] == null) config[k] = v;
      }
      if (!(interpolatorClass = {
        nearest: NearestInterpolator,
        linear: LinearInterpolator,
        cubic: CubicInterpolator,
        lanczos: SincFilterInterpolator,
        sinc: SincFilterInterpolator
      }[config.method])) {
        throw "Invalid method: " + config.method;
      }
      if (config.method === 'lanczos') {
        config.sincWindow = makeLanczosWindow(config.sincFilterSize);
      }
      if (arr.length < 2) throw 'Array must have at least two elements';
      properties.count = arr.length;
      smoothFunc = (function() {
        var _i, _j, _len, _len2;
        switch (getType(arr[0])) {
          case 'Number':
            properties.dimension = 'scalar';
            if (Smooth.deepValidation) {
              for (_i = 0, _len = arr.length; _i < _len; _i++) {
                n = arr[_i];
                validateNumber(n);
              }
            }
            interpolator = new interpolatorClass(arr, config);
            return function(t) {
              return interpolator.interpolate(t);
            };
          case 'Array':
            properties.dimension = dimension = arr[0].length;
            if (!dimension) throw 'Vectors must be non-empty';
            if (Smooth.deepValidation) {
              for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
                v = arr[_j];
                validateVector(v, dimension);
              }
            }
            interpolators = (function() {
              var _results;
              _results = [];
              for (i = 0; 0 <= dimension ? i < dimension : i > dimension; 0 <= dimension ? i++ : i--) {
                _results.push(new interpolatorClass(getColumn(arr, i), config));
              }
              return _results;
            })();
            return function(t) {
              var interpolator, _k, _len3, _results;
              _results = [];
              for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
                interpolator = interpolators[_k];
                _results.push(interpolator.interpolate(t));
              }
              return _results;
            };
          default:
            throw "Invalid element type: " + (getType(arr[0]));
        }
      })();
      if (config.clip === 'periodic') {
        baseDomainEnd = arr.length;
      } else {
        baseDomainEnd = arr.length - 1;
      }
      config.scaleTo || (config.scaleTo = baseDomainEnd);
      properties.domain = normalizeScaleTo(config.scaleTo);
      smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
      properties.domain.sort();
      /*copy properties
      */
      for (k in properties) {
        if (!__hasProp.call(properties, k)) continue;
        v = properties[k];
        smoothFunc[k] = v;
      }
      return smoothFunc;
    };

    for (k in Enum) {
      if (!__hasProp.call(Enum, k)) continue;
      v = Enum[k];
      Smooth[k] = v;
    }

    Smooth.deepValidation = true;

    (exports !== null ? exports : window).Smooth = Smooth;

  }).call(commonjsGlobal);
  }(Smooth));

  var ResidueType = chem.ResidueType;
  var calcMatrix = gfxutils.calcChunkMatrix;

  function _buildStructureInterpolator(points, tension) {
    var path = Smooth.Smooth(points, {
      method: Smooth.Smooth.METHOD_CUBIC,
      clip: Smooth.Smooth.CLIP_CLAMP,
      cubicTension: tension,
      scaleTo: 1
    });
    return function (t, argTrans) {
      var transformT = argTrans;

      if (transformT === null) {
        transformT = function transformT(tt) {
          return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
        };
      }

      var newt = transformT(t);
      var ans = path(newt);
      return new THREE__namespace.Vector3(ans[0], ans[1], ans[2]);
    };
  }

  function _addPoints(centerPoints, topPoints, idx, residue) {
    if (!residue._isValid) {
      centerPoints[idx] = centerPoints[idx - 1];
      topPoints[idx] = topPoints[idx - 1];
      return;
    }

    var cp = residue._controlPoint;
    centerPoints[idx] = [cp.x, cp.y, cp.z];
    var tp = cp.clone().add(residue._wingVector);
    topPoints[idx] = [tp.x, tp.y, tp.z];
  }

  function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
    var nucleic = (residue._type.flags & ResidueType.Flags.NUCLEIC) !== 0;
    var nameFrom = nucleic ? "C5'" : 'N';
    var nameTo = nucleic ? "C3'" : 'C';
    var posFrom;
    var posTo;
    residue.forEachAtom(function (atom) {
      var name = atom.getVisualName();

      if (!posFrom && name === nameFrom) {
        posFrom = atom.position;
      } else if (!posTo && name === nameTo) {
        posTo = atom.position;
      }
    });

    if (!(posFrom && posTo)) {
      posFrom = residue._firstAtom.position;
      posTo = residue._lastAtom.position;
    }

    if (posFrom && posTo) {
      var shift = posTo.clone().sub(posFrom);
      var wing = residue._wingVector;
      var cp = residue._controlPoint;
      var tp = cp.clone().add(wing);
      var cpPrev = cp.clone().sub(shift);
      var tpPrev = cpPrev.clone().add(wing);
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
      ++idx;
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
      ++idx;
      centerPoints[idx] = [cp.x, cp.y, cp.z];
      topPoints[idx] = [tp.x, tp.y, tp.z];
      ++idx;
      var cpNext = cp.clone().add(shift);
      var tpNext = cpNext.clone().add(wing);
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
      ++idx;
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
    }
  }

  function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
    var left = boundaries.start;
    var right = boundaries.end;

    function _prevIdx(idx) {
      return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx;
    }

    function _nextIdx(idx) {
      return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx;
    }

    var topPoints = [];
    var centerPoints = [];
    var arrIdx = 0;

    function _extrapolate2(currIdx, otherIdx) {
      var cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);

      var tp = cp.clone().add(residues[currIdx]._wingVector);
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
    }

    var prevIdx = _prevIdx(firstIdx);

    var nextIdx = _nextIdx(lastIdx);

    if (prevIdx === nextIdx) {
      _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);

      return {
        centerPoints: centerPoints,
        topPoints: topPoints
      };
    }

    if (firstIdx === prevIdx) {
      _extrapolate2(firstIdx, _nextIdx(firstIdx));
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);

      _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
    }

    for (var idx = firstIdx; idx <= lastIdx; ++idx) {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
    }

    if (nextIdx === _nextIdx(nextIdx)) {
      _extrapolate2(lastIdx, _prevIdx(lastIdx));
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);

      _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
    }

    return {
      centerPoints: centerPoints,
      topPoints: topPoints
    };
  }

  var CartoonHelper = /*#__PURE__*/function () {
    function CartoonHelper(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
      _classCallCheck(this, CartoonHelper);

      var pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);

      this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
      this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
      this._shift = 0.5 / (endIdx - startIdx + 2);
      this._valueStep = (1.0 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
      this._segmentsCount = segmentsCount;
    }

    _createClass(CartoonHelper, [{
      key: "prepareMatrices",
      value: function prepareMatrices(idx, firstRad, secondRad) {
        var mtcCount = this._segmentsCount;
        var outMtc = new Array(mtcCount);
        var currRad = new THREE__namespace.Vector2(0, 0);
        var topInterp = this._topInterp;
        var cenInterp = this._centerInterp;
        var currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;

        for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
          var lerpVal = Math.min(1.0, mtxIdx / (mtcCount - 1));
          currRad.lerpVectors(firstRad, secondRad, lerpVal);
          var currTop = topInterp(currentValue, null);
          var currCenter = cenInterp(currentValue, null);
          currentValue += this._valueStep;
          var nextCenter = cenInterp(currentValue, null);
          outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
        }

        return outMtc;
      }
    }]);

    return CartoonHelper;
  }();

  function _createSuper$1a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _createShape(rad, parts) {
    var pts = [];

    for (var i = 0; i < parts; ++i) {
      var a = Math.PI / 2.0 - 2 * Math.PI * i / parts;
      pts.push(new THREE__namespace.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
    }

    return pts;
  }

  function _loopThrough(subDiv, residues, segmentsHeight, tension, mode, callback) {
    for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      var subs = subDiv[subDivI].arr;
      var boundaries = subDiv[subDivI].boundaries;

      for (var i = 0, n = subs.length; i < n; ++i) {
        var idc = [subs[i].start, subs[i].end];
        var matrixHelper = new CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
        var prevLast = null;
        var startIdx = subs[i].start * 2;
        var endIdx = subs[i].end * 2 + 1;
        var prevSecondRad = mode.getResidueRadius(residues[0], 0);

        for (var idx = startIdx; idx <= endIdx; ++idx) {
          var resIdx = idx / 2 | 0;
          var currRes = residues[resIdx];
          var firstRad = mode.getResidueRadius(currRes, idx % 2);
          var secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);
          var mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
          mtc.unshift(prevLast === null ? mtc[0] : prevLast);
          var hasSlope = firstRad.x !== secondRad.x || firstRad.y !== secondRad.y;
          var hasCut = firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y;
          callback(currRes, mtc, hasSlope, hasCut);
          prevLast = mtc[segmentsHeight];
          prevSecondRad = secondRad;
        }
      }
    }
  }

  var ResiduesSubseqGroup = /*#__PURE__*/function (_ResiduesGroup) {
    _inherits(ResiduesSubseqGroup, _ResiduesGroup);

    var _super = _createSuper$1a(ResiduesSubseqGroup);

    function ResiduesSubseqGroup() {
      _classCallCheck(this, ResiduesSubseqGroup);

      return _super.apply(this, arguments);
    }

    _createClass(ResiduesSubseqGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var cmpMultiplier = this._mode.getHeightSegmentsRatio();

        this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
        return [_createShape(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var tension = mode.getTension();
        var geo = this._geo;
        var chunkIdx = 0;
        var chunkIdc = [];

        _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode, function (currRes, mtc) {
          var hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          var color = colorer.getResidueColor(currRes, parent);
          chunkIdc[chunkIdx] = currRes._index;
          geo.setItem(chunkIdx, mtc, hasSlope, hasCut);
          geo.setColor(chunkIdx++, color);
        });

        this._chunksIdc = chunkIdc;
        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var parent = this._selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var tension = mode.getTension();
        var geo = this._geo;
        var frameRes = frameData.getResidues();
        var chunkIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode, function (currRes, mtc) {
          geo.setItem(chunkIdx, mtc);

          if (updateColor) {
            geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
          }

          chunkIdx++;
        });

        geo.finalize();
      }
    }]);

    return ResiduesSubseqGroup;
  }(ResiduesGroup);

  function _createSuper$19(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$19(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$19() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesTraceGroup = /*#__PURE__*/function (_ChemGroup) {
    _inherits(ResiduesTraceGroup, _ChemGroup);

    var _super = _createSuper$19(ResiduesTraceGroup);

    function ResiduesTraceGroup() {
      _classCallCheck(this, ResiduesTraceGroup);

      return _super.apply(this, arguments);
    }

    _createClass(ResiduesTraceGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var subDiv = this._selection.subdivs;
        var chunksCount = 0;

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            chunksCount += subs[i].end - subs[i].start;
          }
        }

        return [chunksCount, this._polyComplexity];
      }
    }, {
      key: "_build",
      value: function _build() {
        var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var chunkIdx = 0;
        var chunkIdc = [];
        var subDiv = this._selection.subdivs;
        var stickRad = mode.calcStickRadius();

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            var startIdx = subs[i].start;
            var endIdx = subs[i].end;
            var prevRes = residues[startIdx];

            for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
              var currRes = residues[idx];
              chunkIdc[chunkIdx] = {
                first: prevRes._index,
                second: currRes._index
              };
              geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
              geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
              chunkIdx++;
              prevRes = currRes;
            }
          }
        }

        this._chunksIdc = chunkIdc;
        geo.finalize();
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var residues = frameData.getResidues();
        var parent = this._selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var chunkIdx = 0;
        var subDiv = this._selection.subdivs;
        var stickRad = mode.calcStickRadius();
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
          var subs = subDiv[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            var startIdx = subs[i].start;
            var endIdx = subs[i].end;
            var prevRes = residues[startIdx];

            for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
              var currRes = residues[idx];
              geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);

              if (updateColor) {
                geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
              }

              chunkIdx++;
              prevRes = currRes;
            }
          }
        }

        geo.finalize();
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var inters = [];
        var residues = this._selection.residues;

        this._mesh.raycast(raycaster, inters);

        var chunksToIdx = this._chunksIdc;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var chunkIdx = inters[i].chunkIdx;
          var chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
          var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;

          if (resIdx < residues.length) {
            inters[i].residue = residues[resIdx];
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask) {
        var chunksList = [];
        var chunksToIdx = this._chunksIdc;
        var residues = this._selection.residues;

        for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
          var chunk = chunksToIdx[i];

          if (residues[chunk.first]._mask & mask) {
            chunksList.push(i * 2);
          }

          if (residues[chunk.second]._mask & mask) {
            chunksList.push(i * 2 + 1);
          }
        }

        return chunksList;
      }
    }]);

    return ResiduesTraceGroup;
  }(ChemGroup);

  function _createSuper$18(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$18(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$18() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder;
  }

  var BondsGroup = /*#__PURE__*/function (_ChemGroup) {
    _inherits(BondsGroup, _ChemGroup);

    var _super = _createSuper$18(BondsGroup);

    function BondsGroup() {
      _classCallCheck(this, BondsGroup);

      return _super.apply(this, arguments);
    }

    _createClass(BondsGroup, [{
      key: "_makeGeoArgs",
      value: function _makeGeoArgs() {
        var drawMultiple = this._mode.drawMultiorderBonds();

        var showAromatic = this._mode.showAromaticLoops();

        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var bondsCount = 0;

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          bondsCount += this.getBondOrder(bonds[bondsIdc[i]], drawMultiple, showAromatic);
        }

        return [bondsCount, this._polyComplexity];
      }
    }, {
      key: "getBondOrder",
      value: function getBondOrder(bond, drawMultiple, showAromatic) {
        var bondOrder = 1;

        if (drawMultiple && (!showAromatic || bond._type !== Bond$5.BondType.AROMATIC)) {
          bondOrder = getCylinderCount(bond._order);
        }

        return bondOrder;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var bonds = this._selection.bonds;
        var inters = [];

        this._mesh.raycast(raycaster, inters);

        var bondsIdc = this._chunksIdc;

        for (var i = 0, n = inters.length; i < n; ++i) {
          if (!inters[i].hasOwnProperty('chunkIdx')) {
            continue;
          }

          var chunkIdx = inters[i].chunkIdx;
          var bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];

          if (bondIdx < bonds.length) {
            var bond = bonds[bondIdx];
            inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
            intersects.push(inters[i]);
          }
        }
      }
    }, {
      key: "_calcChunksList",
      value: function _calcChunksList(mask, innerOnly) {
        var chunksList = [];
        var bonds = this._selection.bonds;
        var chunksToIdx = this._chunksIdc;

        for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
          var bond = bonds[chunksToIdx[i]];

          if (bond._left.mask & mask && (!innerOnly || bond._right.mask & mask)) {
            chunksList.push(2 * i);
          }

          if (bond._right.mask & mask && (!innerOnly || bond._left.mask & mask)) {
            chunksList.push(2 * i + 1);
          }
        }

        return chunksList;
      }
    }]);

    return BondsGroup;
  }(ChemGroup);

  function _createSuper$17(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$17(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$17() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var BondsCylinderGroup = /*#__PURE__*/function (_BondsGroup) {
    _inherits(BondsCylinderGroup, _BondsGroup);

    var _super = _createSuper$17(BondsCylinderGroup);

    function BondsCylinderGroup() {
      _classCallCheck(this, BondsCylinderGroup);

      return _super.apply(this, arguments);
    }

    _createClass(BondsCylinderGroup, [{
      key: "_build",
      value: function _build() {
        var bondsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var stickRad = mode.calcStickRadius();
        var emptyOffset = mode.calcSpaceFraction();
        var normDir;
        var leftPos = new THREE__namespace.Vector3();
        var rightPos = new THREE__namespace.Vector3();
        var currBondIdx = 0;
        var chunksToIdx = [];

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = atom1.position;
          var a2Pos = atom2.position;
          normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);
          var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
          var dist = 2 * minRad / order;
          var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

          for (var j = 0; j < order; ++j) {
            var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
            chunksToIdx[currBondIdx] = bond._index;
            leftPos.copy(a1Pos);
            leftPos.addScaledVector(normDir, scale);
            rightPos.copy(a2Pos);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
            geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
          }
        }

        geo.finalize();
        this._chunksIdc = chunksToIdx;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var stickRad = mode.calcStickRadius();
        var emptyOffset = mode.calcSpaceFraction();
        var normDir;
        var leftPos = new THREE__namespace.Vector3();
        var rightPos = new THREE__namespace.Vector3();
        var currBondIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = frameData.getAtomPos(atom1.index).clone();
          var a2Pos = frameData.getAtomPos(atom2.index);
          normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);
          var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
          var dist = 2 * minRad / order;
          var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

          for (var j = 0; j < order; ++j) {
            var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
            leftPos.copy(a1Pos);
            leftPos.addScaledVector(normDir, scale);
            rightPos.copy(a2Pos);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);

            if (updateColor) {
              geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
            }

            currBondIdx++;
          }
        }

        geo.finalize();
      }
    }]);

    return BondsCylinderGroup;
  }(BondsGroup);

  function _createSuper$16(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$16(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$16() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var STEP_SIZE = 0.15;

  var BondsLinesGroup = /*#__PURE__*/function (_BondsGroup) {
    _inherits(BondsLinesGroup, _BondsGroup);

    var _super = _createSuper$16(BondsLinesGroup);

    function BondsLinesGroup() {
      _classCallCheck(this, BondsLinesGroup);

      return _super.apply(this, arguments);
    }

    _createClass(BondsLinesGroup, [{
      key: "_build",
      value: function _build() {
        var bondsIdc = this._selection.chunks;
        var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var bondDir = new THREE__namespace.Vector3();
        var leftPos = new THREE__namespace.Vector3();
        var rightPos = new THREE__namespace.Vector3();
        var currBondIdx = 0;
        var chunksToIdx = [];

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = atom1.position;
          var a2Pos = atom2.position;
          var a1Hangs = atom1.bonds.length === 1;
          var a2Hangs = atom2.bonds.length === 1;
          bondDir.subVectors(a2Pos, a1Pos);
          var len = bondDir.length();
          var normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);

          for (var j = 0; j < order; ++j) {
            leftPos.copy(a1Pos);
            rightPos.copy(a2Pos);
            var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
            chunksToIdx[currBondIdx] = bond._index;

            if (order === 2 && !a1Hangs && !a2Hangs) {
              scale -= 0.5;
              scale *= -1;
            }

            if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
              leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
              rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
            }

            scale *= STEP_SIZE;
            leftPos.addScaledVector(normDir, scale);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos);
            geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
          }
        }

        geo.finalize();
        this._chunksIdc = chunksToIdx;
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        var bondsIdc = this._selection.chunks;
        var bonds = this._selection.bonds;
        var mode = this._mode;
        var colorer = this._colorer;
        var geo = this._geo;
        var drawMultiple = mode.drawMultiorderBonds();
        var showAromatic = mode.showAromaticLoops();
        var bondDir = new THREE__namespace.Vector3();
        var leftPos = new THREE__namespace.Vector3();
        var rightPos = new THREE__namespace.Vector3();
        var currBondIdx = 0;
        var updateColor = frameData.needsColorUpdate(colorer);

        for (var i = 0, n = bondsIdc.length; i < n; ++i) {
          var bond = bonds[bondsIdc[i]];
          var atom1 = bond._left;
          var atom2 = bond._right;
          var a1Pos = frameData.getAtomPos(atom1.index).clone();
          var a2Pos = frameData.getAtomPos(atom2.index);
          var a1Hangs = atom1.bonds.length === 1;
          var a2Hangs = atom2.bonds.length === 1;
          bondDir.subVectors(a2Pos, a1Pos);
          var len = bondDir.length();
          var normDir = bond.calcNormalDir();
          var order = this.getBondOrder(bond, drawMultiple, showAromatic);

          for (var j = 0; j < order; ++j) {
            leftPos.copy(a1Pos);
            rightPos.copy(a2Pos);
            var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));

            if (order === 2 && !a1Hangs && !a2Hangs) {
              scale -= 0.5;
              scale *= -1;
            }

            if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
              leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
              rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
            }

            scale *= STEP_SIZE;
            leftPos.addScaledVector(normDir, scale);
            rightPos.addScaledVector(normDir, scale);
            geo.setItem(currBondIdx, leftPos, rightPos);

            if (updateColor) {
              geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
            }

            currBondIdx++;
          }
        }

        geo.finalize();
      }
    }]);

    return BondsLinesGroup;
  }(BondsGroup);

  var groups = {
    AtomsSphereGroup: AtomsSphereGroup,
    AtomsSurfaceGroup: AtomsSurfaceGroup,
    AtomsSASSESGroupStub: AtomsSASSESGroupStub,
    AtomsTextGroup: AtomsTextGroup,
    AromaticTorusGroup: AromaticTorusGroup,
    AromaticLinesGroup: AromaticLinesGroup,
    NucleicCylindersGroup: NucleicCylindersGroup,
    NucleicSpheresGroup: NucleicSpheresGroup,
    ResiduesSubseqGroup: ResiduesSubseqGroup,
    ResiduesTraceGroup: ResiduesTraceGroup,
    BondsCylinderGroup: BondsCylinderGroup,
    BondsLinesGroup: BondsLinesGroup
  };

  function _createSuper$15(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$15(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$15() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AtomsProcessor = /*#__PURE__*/function (_RCGroup) {
    _inherits(AtomsProcessor, _RCGroup);

    var _super = _createSuper$15(AtomsProcessor);

    function AtomsProcessor(AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      _classCallCheck(this, AtomsProcessor);

      _this = _super.call(this);

      var self = _assertThisInitialized(_this);

      _this._complex = complex;
      _this._mode = mode;
      var atoms = complex.getAtoms();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var atomsIdc = [];
        var atomCount = 0;
        component.forEachAtom(function (atom) {
          if (!self._checkAtom(atom, mask)) {
            return;
          }

          atomsIdc[atomCount++] = atom.index;
        });

        if (atomCount === 0) {
          return;
        }

        var atomsGroup = new AtomsGroup(geoParams, {
          atoms: atoms,
          chunks: atomsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        atomsGroup._component = component;
        self.add(atomsGroup);
      });
      return _this;
    }

    _createClass(AtomsProcessor, [{
      key: "_checkAtom",
      value: function _checkAtom(atom, mask) {
        return atom.mask & mask;
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return AtomsProcessor;
  }(RCGroup);

  function _createSuper$14(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$14(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$14() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var OrphanAtomsProcessor = /*#__PURE__*/function (_AtomsProcessor) {
    _inherits(OrphanAtomsProcessor, _AtomsProcessor);

    var _super = _createSuper$14(OrphanAtomsProcessor);

    function OrphanAtomsProcessor() {
      _classCallCheck(this, OrphanAtomsProcessor);

      return _super.apply(this, arguments);
    }

    _createClass(OrphanAtomsProcessor, [{
      key: "_checkAtom",
      value: function _checkAtom(atom, mask) {
        if (!(atom.mask & mask)) {
          return false;
        }

        var bonds = atom.bonds;

        for (var i = 0, n = bonds.length; i < n; ++i) {
          if (bonds[i]._left.mask & mask && bonds[i]._right.mask & mask) {
            return false;
          }
        }

        return true;
      }
    }]);

    return OrphanAtomsProcessor;
  }(AtomsProcessor);

  function _createSuper$13(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$13(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$13() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ResiduesProcessor = /*#__PURE__*/function (_RCGroup) {
    _inherits(ResiduesProcessor, _RCGroup);

    var _super = _createSuper$13(ResiduesProcessor);

    function ResiduesProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      _classCallCheck(this, ResiduesProcessor);

      _this = _super.call(this);

      var self = _assertThisInitialized(_this);

      _this._complex = complex;
      var residues = complex.getResidues();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var chunksCount = 0;
        var resIdc = [];
        component.forEachResidue(function (residue) {
          if (self._checkResidue(residue, mask)) {
            resIdc[chunksCount++] = residue._index;
          }
        });

        if (chunksCount === 0) {
          return;
        }

        var residuesGroup = new ResidueGroup(geoParams, {
          residues: residues,
          chunks: resIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        residuesGroup._component = component;
        self.add(residuesGroup);
      });
      return _this;
    }

    _createClass(ResiduesProcessor, [{
      key: "checkResidue",
      value: function checkResidue(residue, mask) {
        return residue._mask & mask;
      }
    }, {
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return ResiduesProcessor;
  }(RCGroup);

  function _createSuper$12(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$12(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$12() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var NucleicProcessor = /*#__PURE__*/function (_ResidueProcessor) {
    _inherits(NucleicProcessor, _ResidueProcessor);

    var _super = _createSuper$12(NucleicProcessor);

    function NucleicProcessor() {
      _classCallCheck(this, NucleicProcessor);

      return _super.apply(this, arguments);
    }

    _createClass(NucleicProcessor, [{
      key: "_checkResidue",
      value: function _checkResidue(residue, mask) {
        return mask & residue._mask && residue._cylinders !== null;
      }
    }]);

    return NucleicProcessor;
  }(ResiduesProcessor);

  function _createSuper$11(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$11(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$11() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SubseqsProcessor = /*#__PURE__*/function (_RCGroup) {
    _inherits(SubseqsProcessor, _RCGroup);

    var _super = _createSuper$11(SubseqsProcessor);

    function SubseqsProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      _classCallCheck(this, SubseqsProcessor);

      _this = _super.call(this);

      var self = _assertThisInitialized(_this);

      _this._complex = complex;
      var residues = complex.getResidues();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var subDivs = component.getMaskedSubdivSequences(mask);
        var chunksCount = 0;
        var resIdc = [];

        for (var subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
          var subs = subDivs[subDivI].arr;

          for (var i = 0, n = subs.length; i < n; ++i) {
            for (var j = subs[i].start, jEnd = subs[i].end; j <= jEnd; ++j) {
              resIdc[chunksCount++] = residues[j]._index;
            }
          }
        }

        if (chunksCount === 0) {
          return;
        }

        var residuesGroup = new ResidueGroup(geoParams, {
          residues: residues,
          chunks: resIdc,
          subdivs: subDivs,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        residuesGroup._component = component;
        self.add(residuesGroup);
      });
      return _this;
    }

    _createClass(SubseqsProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return SubseqsProcessor;
  }(RCGroup);

  function _createSuper$10(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$10(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$10() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var BondsProcessor = /*#__PURE__*/function (_RCGroup) {
    _inherits(BondsProcessor, _RCGroup);

    var _super = _createSuper$10(BondsProcessor);

    function BondsProcessor(BondsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      _classCallCheck(this, BondsProcessor);

      _this = _super.call(this);

      var self = _assertThisInitialized(_this);

      _this._complex = complex;
      var bonds = complex.getBonds();
      var transforms = complex.getTransforms();
      complex.forEachComponent(function (component) {
        var bondsIdc = [];
        var bondsCount = 0;
        component.forEachBond(function (bond) {
          var atom1 = bond._left;
          var atom2 = bond._right;

          if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
            return;
          }

          bondsIdc[bondsCount++] = bond._index;
        });

        if (bondsCount === 0) {
          return;
        }

        var bondsGroup = new BondsGroup(geoParams, {
          bonds: bonds,
          chunks: bondsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        bondsGroup._component = component;
        self.add(bondsGroup);
      });
      return _this;
    }

    _createClass(BondsProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return BondsProcessor;
  }(RCGroup);

  function _createSuper$$(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$$(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$$() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AromaticProcessor = /*#__PURE__*/function (_RCGroup) {
    _inherits(AromaticProcessor, _RCGroup);

    var _super = _createSuper$$(AromaticProcessor);

    function AromaticProcessor(AromaticGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
      var _this;

      _classCallCheck(this, AromaticProcessor);

      _this = _super.call(this);

      var self = _assertThisInitialized(_this);

      _this._complex = complex;
      var atoms = complex.getAtoms();
      var transforms = complex.getTransforms();

      if (!mode.showAromaticLoops()) {
        return _possibleConstructorReturn(_this);
      }

      complex.forEachComponent(function (component) {
        var atomsIdc = [];
        var chunksCount = 0;
        var cycles = [];
        var cycleIdx = 0;
        component.forEachCycle(function (cycle) {
          var cycAtoms = cycle.atoms;
          var perCycle = 0;

          for (var i = 0, n = cycAtoms.length; i < n; ++i) {
            if ((cycAtoms[i].mask & mask) !== 0) {
              ++perCycle;
              atomsIdc[chunksCount++] = cycAtoms[i].index;
            }
          }

          if (perCycle > 0) {
            cycles[cycleIdx++] = cycle;
          }
        });
        var atomsGroup = new AromaticGroup(geoParams, {
          cycles: cycles,
          atoms: atoms,
          chunks: atomsIdc,
          parent: complex
        }, colorer, mode, transforms, polyComplexity, material);
        atomsGroup._component = component;
        self.add(atomsGroup);
      });
      return _this;
    }

    _createClass(AromaticProcessor, [{
      key: "getSubset",
      value: function getSubset(mask, innerOnly) {
        var totalSubset = [];
        var children = this.children;
        var meshIdx = 0;

        for (var i = 0, n = children.length; i < n; ++i) {
          if (children[i].getSubset) {
            var chSubset = children[i].getSubset(mask, innerOnly);

            for (var j = 0, m = chSubset.length; j < m; ++j) {
              var subsetEl = chSubset[j];
              subsetEl._component = children[i]._component;
              totalSubset[meshIdx++] = subsetEl;
            }
          }
        }

        return totalSubset;
      }
    }]);

    return AromaticProcessor;
  }(RCGroup);

  var processors = {
    Atoms: AtomsProcessor,
    OrphanAtoms: OrphanAtomsProcessor,
    Residues: ResiduesProcessor,
    Nucleic: NucleicProcessor,
    Subseqs: SubseqsProcessor,
    Bonds: BondsProcessor,
    Aromatic: AromaticProcessor
  };

  function _bakeGroup(triplet, Processor, Group) {
    return function (complex, colorer, mode, polyComplexity, mask, material) {
      return new Processor(Group, triplet, complex, colorer, mode, polyComplexity, mask, material);
    };
  }

  var GroupsFactory = /*#__PURE__*/function () {
    function GroupsFactory() {
      _classCallCheck(this, GroupsFactory);
    }

    _createClass(GroupsFactory, null, [{
      key: "AtomsSpheres",
      value: function AtomsSpheres(caps, settings) {
        var gfxTriplet = MeshCreator.createSpheres(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
      }
    }, {
      key: "OrphanedAtomsCrosses",
      value: function OrphanedAtomsCrosses(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createCrosses(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
      }
    }, {
      key: "BondsCylinders",
      value: function BondsCylinders(caps, settings) {
        var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
      }
    }, {
      key: "BondsLines",
      value: function BondsLines(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.create2CLines(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
      }
    }, {
      key: "CartoonChains",
      value: function CartoonChains(caps, settings) {
        var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
      }
    }, {
      key: "TraceChains",
      value: function TraceChains(caps, settings) {
        var gfxTriplet = MeshCreator.create2CClosedCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
      }
    }, {
      key: "NucleicSpheres",
      value: function NucleicSpheres(caps, settings) {
        var gfxTriplet = MeshCreator.createSpheres(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
      }
    }, {
      key: "NucleicCylinders",
      value: function NucleicCylinders(caps, settings) {
        var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
      }
    }, {
      key: "ALoopsTorus",
      value: function ALoopsTorus(caps, settings) {
        var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
      }
    }, {
      key: "ALoopsLines",
      value: function ALoopsLines(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createChunkedLines(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
      }
    }, {
      key: "QuickSurfGeo",
      value: function QuickSurfGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createQuickSurface(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
      }
    }, {
      key: "ContactSurfaceGeo",
      value: function ContactSurfaceGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createContactSurface(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
      }
    }, {
      key: "SASSESSurfaceGeo",
      value: function SASSESSurfaceGeo(caps, settings, renderParams) {
        var gfxTriplet = MeshCreator.createSASSES(caps, settings, renderParams);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
      }
    }, {
      key: "TextLabelsGeo",
      value: function TextLabelsGeo(caps, settings) {
        var gfxTriplet = MeshCreator.createLabels(caps, settings);
        return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
      }
    }]);

    return GroupsFactory;
  }();

  var Mode = /*#__PURE__*/function () {
    function Mode(opts) {
      _classCallCheck(this, Mode);

      if (this.constructor === Mode) {
        throw new Error('Can not instantiate abstract class!');
      }

      this.opts = ___default["default"].merge(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
    }

    _createClass(Mode, [{
      key: "identify",
      value: function identify() {
        var diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);

        if (!___default["default"].isEmpty(diff)) {
          return [this.id, diff];
        }

        return this.id;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
        var groupList = this.depGroups;
        var groupCount = groupList.length;
        var group = new gfxutils.RCGroup();
        var self = this;

        for (var i = 0; i < groupCount; ++i) {
          var currGroup = groupList[i];
          var renderParams = {};

          if (___default["default"].isArray(currGroup)) {
            renderParams = currGroup[1].call(this);
            var _currGroup = currGroup;

            var _currGroup2 = _slicedToArray(_currGroup, 1);

            currGroup = _currGroup2[0];
          }

          var Group = GroupsFactory[currGroup](null, this.settings, renderParams);
          var newGroup = new Group(complex, colorer, self, polyComplexity, mask, material);

          if (newGroup.children.length > 0) {
            group.add(newGroup);
          }
        }

        return group;
      }
    }]);

    return Mode;
  }();

  makeContextDependent(Mode.prototype);
  Mode.prototype.id = '__';
  Mode.prototype.depGroups = [];

  function _createSuper$_(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$_(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$_() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function getRenderParams$1() {
    return {
      lineWidth: this.opts.lineWidth
    };
  }

  var LinesMode = /*#__PURE__*/function (_Mode) {
    _inherits(LinesMode, _Mode);

    var _super = _createSuper$_(LinesMode);

    function LinesMode(opts) {
      var _this;

      _classCallCheck(this, LinesMode);

      _this = _super.call(this, opts);
      _this.depGroups = _this.depGroups.slice(0);
      var groups = _this.depGroups;

      for (var i = 0, n = groups.length; i < n; ++i) {
        groups[i] = [groups[i], getRenderParams$1];
      }

      return _this;
    }

    _createClass(LinesMode, [{
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }, {
      key: "calcAtomRadius",
      value: function calcAtomRadius() {
        return this.opts.atom;
      }
    }, {
      key: "getAromaticOffset",
      value: function getAromaticOffset() {
        return this.opts.offsarom;
      }
    }, {
      key: "getAromaticArcChunks",
      value: function getAromaticArcChunks() {
        return this.opts.chunkarom;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }]);

    return LinesMode;
  }(Mode);

  _defineProperty(LinesMode, "id", 'LN');

  LinesMode.prototype.id = 'LN';
  LinesMode.prototype.name = 'Lines';
  LinesMode.prototype.shortName = 'Lines';
  LinesMode.prototype.depGroups = ['ALoopsLines', 'BondsLines', 'OrphanedAtomsCrosses'];

  function _createSuper$Z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Z(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var LicoriceMode = /*#__PURE__*/function (_Mode) {
    _inherits(LicoriceMode, _Mode);

    var _super = _createSuper$Z(LicoriceMode);

    function LicoriceMode() {
      _classCallCheck(this, LicoriceMode);

      return _super.apply(this, arguments);
    }

    _createClass(LicoriceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(_atom) {
        return this.opts.bond;
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.bond;
      }
    }, {
      key: "calcSpaceFraction",
      value: function calcSpaceFraction() {
        return this.opts.space;
      }
    }, {
      key: "getAromRadius",
      value: function getAromRadius() {
        return this.opts.aromrad;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }, {
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }]);

    return LicoriceMode;
  }(Mode);

  _defineProperty(LicoriceMode, "id", 'LC');

  LicoriceMode.prototype.id = 'LC';
  LicoriceMode.prototype.name = 'Licorice';
  LicoriceMode.prototype.shortName = 'Licorice';
  LicoriceMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

  function _createSuper$Y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Y(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var BallsAndSticksMode = /*#__PURE__*/function (_Mode) {
    _inherits(BallsAndSticksMode, _Mode);

    var _super = _createSuper$Y(BallsAndSticksMode);

    function BallsAndSticksMode() {
      _classCallCheck(this, BallsAndSticksMode);

      return _super.apply(this, arguments);
    }

    _createClass(BallsAndSticksMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius * this.opts.atom;
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.bond;
      }
    }, {
      key: "getAromRadius",
      value: function getAromRadius() {
        return this.opts.aromrad;
      }
    }, {
      key: "showAromaticLoops",
      value: function showAromaticLoops() {
        return this.opts.showarom;
      }
    }, {
      key: "calcSpaceFraction",
      value: function calcSpaceFraction() {
        return this.opts.space;
      }
    }, {
      key: "drawMultiorderBonds",
      value: function drawMultiorderBonds() {
        return this.opts.multibond;
      }
    }]);

    return BallsAndSticksMode;
  }(Mode);

  _defineProperty(BallsAndSticksMode, "id", 'BS');

  BallsAndSticksMode.prototype.id = 'BS';
  BallsAndSticksMode.prototype.name = 'Balls and Sticks';
  BallsAndSticksMode.prototype.shortName = 'Balls';
  BallsAndSticksMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

  function _createSuper$X(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$X(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$X() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var VanDerWaalsMode = /*#__PURE__*/function (_Mode) {
    _inherits(VanDerWaalsMode, _Mode);

    var _super = _createSuper$X(VanDerWaalsMode);

    function VanDerWaalsMode() {
      _classCallCheck(this, VanDerWaalsMode);

      return _super.apply(this, arguments);
    }

    _createClass(VanDerWaalsMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }]);

    return VanDerWaalsMode;
  }(Mode);

  _defineProperty(VanDerWaalsMode, "id", 'VW');

  VanDerWaalsMode.prototype.id = 'VW';
  VanDerWaalsMode.prototype.name = 'Van der Waals';
  VanDerWaalsMode.prototype.shortName = 'VDW';
  VanDerWaalsMode.prototype.depGroups = ['AtomsSpheres'];

  function _createSuper$W(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$W(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$W() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TraceMode = /*#__PURE__*/function (_Mode) {
    _inherits(TraceMode, _Mode);

    var _super = _createSuper$W(TraceMode);

    function TraceMode() {
      _classCallCheck(this, TraceMode);

      return _super.apply(this, arguments);
    }

    _createClass(TraceMode, [{
      key: "calcStickRadius",
      value: function calcStickRadius() {
        return this.opts.radius;
      }
    }]);

    return TraceMode;
  }(Mode);

  _defineProperty(TraceMode, "id", 'TR');

  TraceMode.prototype.id = 'TR';
  TraceMode.prototype.name = 'Trace';
  TraceMode.prototype.shortName = 'Trace';
  TraceMode.prototype.depGroups = ['TraceChains'];

  function _createSuper$V(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$V(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$V() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TubeMode = /*#__PURE__*/function (_Mode) {
    _inherits(TubeMode, _Mode);

    var _super = _createSuper$V(TubeMode);

    function TubeMode() {
      _classCallCheck(this, TubeMode);

      return _super.apply(this, arguments);
    }

    _createClass(TubeMode, [{
      key: "getResidueRadius",
      value: function getResidueRadius(_residue) {
        return this.TUBE_RADIUS;
      }
    }, {
      key: "getHeightSegmentsRatio",
      value: function getHeightSegmentsRatio() {
        return this.opts.heightSegmentsRatio;
      }
    }, {
      key: "getTension",
      value: function getTension() {
        return this.opts.tension;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var rad = this.opts.radius;
        this.TUBE_RADIUS = new THREE__namespace.Vector2(rad, rad);
        return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
      }
    }]);

    return TubeMode;
  }(Mode);

  _defineProperty(TubeMode, "id", 'TU');

  TubeMode.prototype.id = 'TU';
  TubeMode.prototype.name = 'Tube';
  TubeMode.prototype.shortName = 'Tube';
  TubeMode.prototype.depGroups = ['CartoonChains'];

  function _createSuper$U(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$U(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$U() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var CartoonMode = /*#__PURE__*/function (_Mode) {
    _inherits(CartoonMode, _Mode);

    var _super = _createSuper$U(CartoonMode);

    function CartoonMode(opts) {
      var _this;

      _classCallCheck(this, CartoonMode);

      _this = _super.call(this, opts);
      _this.secCache = {};
      return _this;
    }

    _createClass(CartoonMode, [{
      key: "getResidueStartRadius",
      value: function getResidueStartRadius(residue) {
        var second = residue.getSecondary();

        if (!second || !second.generic) {
          return this.TUBE_RADIUS;
        }

        var secOpts = this.secCache[second.generic];

        if (!secOpts) {
          return this.TUBE_RADIUS;
        }

        if (second.term === residue) {
          return secOpts.start;
        }

        return secOpts.center;
      }
    }, {
      key: "getResidueEndRadius",
      value: function getResidueEndRadius(residue) {
        var second = residue.getSecondary();

        if (second === null || !second.generic) {
          return this.TUBE_RADIUS;
        }

        var secOpts = this.secCache[second.generic];

        if (!secOpts) {
          return this.TUBE_RADIUS;
        }

        if (second.term === residue) {
          return this.ARROW_END;
        }

        return secOpts.center;
      }
    }, {
      key: "getResidueRadius",
      value: function getResidueRadius(residue, val) {
        var startRad = this.getResidueStartRadius(residue);

        if (val === 0) {
          return startRad;
        }

        var endRad = this.getResidueEndRadius(residue);

        if (val === 2) {
          return endRad;
        }

        return startRad.clone().lerp(endRad, val / 2.0);
      }
    }, {
      key: "calcStickRadius",
      value: function calcStickRadius(_res) {
        return this.opts.radius;
      }
    }, {
      key: "getHeightSegmentsRatio",
      value: function getHeightSegmentsRatio() {
        return this.opts.heightSegmentsRatio;
      }
    }, {
      key: "getTension",
      value: function getTension() {
        return this.opts.tension;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex, colorer, mask, material) {
        var tubeRad = this.opts.radius;
        var secHeight = this.opts.depth;
        this.TUBE_RADIUS = new THREE__namespace.Vector2(tubeRad, tubeRad);
        this.ARROW_END = new THREE__namespace.Vector2(secHeight, tubeRad);
        var secCache = {};
        var secData = this.opts.ss;

        for (var prop in secData) {
          secCache[prop] = {
            center: new THREE__namespace.Vector2(secHeight, secData[prop].width),
            start: new THREE__namespace.Vector2(secHeight, secData[prop].arrow)
          };
        }

        this.secCache = secCache;
        return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
      }
    }]);

    return CartoonMode;
  }(Mode);

  _defineProperty(CartoonMode, "id", 'CA');

  CartoonMode.prototype.id = 'CA';
  CartoonMode.prototype.name = 'Cartoon';
  CartoonMode.prototype.shortName = 'Cartoon';
  CartoonMode.prototype.depGroups = ['CartoonChains', 'NucleicSpheres', 'NucleicCylinders'];

  function _createSuper$T(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$T(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$T() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var selectors$4 = chem.selectors;

  function getRenderParams() {
    return {
      wireframe: this.opts.wireframe,
      zClip: this.opts.zClip
    };
  }

  var SurfaceMode = /*#__PURE__*/function (_Mode) {
    _inherits(SurfaceMode, _Mode);

    var _super = _createSuper$T(SurfaceMode);

    function SurfaceMode(opts) {
      var _this;

      _classCallCheck(this, SurfaceMode);

      _this = _super.call(this, opts);
      _this.depGroups = _this.depGroups.slice(0);
      var surfaces = _this.surfaceNames;
      var groups = _this.depGroups;

      for (var i = 0, n = surfaces.length; i < n; ++i) {
        groups[groups.length] = [surfaces[i], getRenderParams];
      }

      return _this;
    }

    _createClass(SurfaceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }, {
      key: "getVisibilitySelector",
      value: function getVisibilitySelector() {
        var visibilitySelector = null;

        if (this.opts.subset !== '') {
          var res = selectors$4.parse(this.opts.subset);

          if (!res.error) {
            visibilitySelector = res.selector;
          }
        }

        return visibilitySelector;
      }
    }]);

    return SurfaceMode;
  }(Mode);

  SurfaceMode.prototype.isSurface = true;
  SurfaceMode.prototype.surfaceNames = [];

  function _createSuper$S(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$S(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$S() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var QuickSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    _inherits(QuickSurfaceMode, _SurfaceMode);

    var _super = _createSuper$S(QuickSurfaceMode);

    function QuickSurfaceMode() {
      _classCallCheck(this, QuickSurfaceMode);

      return _super.apply(this, arguments);
    }

    _createClass(QuickSurfaceMode, [{
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          useBeads: false,
          isoValue: this.opts.isoValue,
          gaussLim: this.opts.gaussLim[this.settings.now.resolution],
          radScale: this.opts.scale,
          gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector()
        };
      }
    }]);

    return QuickSurfaceMode;
  }(SurfaceMode);

  _defineProperty(QuickSurfaceMode, "id", 'QS');

  QuickSurfaceMode.prototype.id = 'QS';
  QuickSurfaceMode.prototype.name = 'Quick Surface';
  QuickSurfaceMode.prototype.shortName = 'Quick Surf';
  QuickSurfaceMode.prototype.surfaceNames = ['QuickSurfGeo'];

  function _createSuper$R(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$R(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$R() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    _inherits(IsoSurfaceMode, _SurfaceMode);

    var _super = _createSuper$R(IsoSurfaceMode);

    function IsoSurfaceMode(excludeProbe, opts) {
      var _this;

      _classCallCheck(this, IsoSurfaceMode);

      _this = _super.call(this, opts);
      _this._excludeProbe = excludeProbe;
      return _this;
    }

    _createClass(IsoSurfaceMode, [{
      key: "calcAtomRadius",
      value: function calcAtomRadius(atom) {
        return atom.element.radius;
      }
    }, {
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
          radScale: this._radScale,
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector(),
          probeRadius: this.opts.probeRadius,
          excludeProbe: this._excludeProbe
        };
      }
    }]);

    return IsoSurfaceMode;
  }(SurfaceMode);

  IsoSurfaceMode.prototype.id = 'SU';
  IsoSurfaceMode.prototype.name = 'Surface';
  IsoSurfaceMode.prototype.shortName = 'Surface';
  IsoSurfaceMode.prototype.surfaceNames = ['SASSESSurfaceGeo'];
  IsoSurfaceMode.prototype._radScale = 1;
  IsoSurfaceMode.prototype._excludeProbe = false;

  function _createSuper$Q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$Q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$Q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceSASMode = /*#__PURE__*/function (_IsoSurfaceMode) {
    _inherits(IsoSurfaceSASMode, _IsoSurfaceMode);

    var _super = _createSuper$Q(IsoSurfaceSASMode);

    function IsoSurfaceSASMode(opts) {
      _classCallCheck(this, IsoSurfaceSASMode);

      return _super.call(this, false, opts);
    }

    return IsoSurfaceSASMode;
  }(IsoSurfaceMode);

  _defineProperty(IsoSurfaceSASMode, "id", 'SA');

  IsoSurfaceSASMode.prototype.id = 'SA';
  IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface';
  IsoSurfaceSASMode.prototype.shortName = 'SAS';

  function _createSuper$P(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$P(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$P() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var IsoSurfaceSESMode = /*#__PURE__*/function (_IsoSurfaceMode) {
    _inherits(IsoSurfaceSESMode, _IsoSurfaceMode);

    var _super = _createSuper$P(IsoSurfaceSESMode);

    function IsoSurfaceSESMode(opts) {
      _classCallCheck(this, IsoSurfaceSESMode);

      return _super.call(this, true, opts);
    }

    return IsoSurfaceSESMode;
  }(IsoSurfaceMode);

  _defineProperty(IsoSurfaceSESMode, "id", 'SE');

  IsoSurfaceSESMode.prototype.id = 'SE';
  IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface';
  IsoSurfaceSESMode.prototype.shortName = 'SES';

  function _createSuper$O(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$O(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$O() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ContactSurfaceMode = /*#__PURE__*/function (_SurfaceMode) {
    _inherits(ContactSurfaceMode, _SurfaceMode);

    var _super = _createSuper$O(ContactSurfaceMode);

    function ContactSurfaceMode() {
      _classCallCheck(this, ContactSurfaceMode);

      return _super.apply(this, arguments);
    }

    _createClass(ContactSurfaceMode, [{
      key: "getSurfaceOpts",
      value: function getSurfaceOpts() {
        return {
          probeRadius: this.opts.probeRadius,
          radScale: this.opts.polyComplexity[this.settings.now.resolution],
          scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
          gridSpacing: 1.0 / this.opts.polyComplexity[this.settings.now.resolution],
          isoValue: this.opts.isoValue,
          probePositions: this.opts.probePositions,
          zClip: this.opts.zClip,
          visibilitySelector: this.getVisibilitySelector()
        };
      }
    }]);

    return ContactSurfaceMode;
  }(SurfaceMode);

  _defineProperty(ContactSurfaceMode, "id", 'CS');

  ContactSurfaceMode.prototype.id = 'CS';
  ContactSurfaceMode.prototype.name = 'Contact Surface';
  ContactSurfaceMode.prototype.shortName = 'Contact Surf';
  ContactSurfaceMode.prototype.isSurface = true;
  ContactSurfaceMode.prototype.surfaceNames = ['ContactSurfaceGeo'];

  function _createSuper$N(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$N(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$N() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TextMode = /*#__PURE__*/function (_Mode) {
    _inherits(TextMode, _Mode);

    var _super = _createSuper$N(TextMode);

    function TextMode() {
      _classCallCheck(this, TextMode);

      return _super.apply(this, arguments);
    }

    _createClass(TextMode, [{
      key: "getTemplateOptions",
      value: function getTemplateOptions() {
        return this.opts.template;
      }
    }, {
      key: "getLabelOpts",
      value: function getLabelOpts() {
        return ___default["default"].merge(this.opts, {
          colors: true,
          adjustColor: true,
          transparent: true
        });
      }
    }]);

    return TextMode;
  }(Mode);

  _defineProperty(TextMode, "id", 'TX');

  TextMode.prototype.id = 'TX';
  TextMode.prototype.name = 'Text mode';
  TextMode.prototype.shortName = 'Text';
  TextMode.prototype.depGroups = ['TextLabelsGeo'];

  var modes$1 = new EntityList([LinesMode, LicoriceMode, BallsAndSticksMode, VanDerWaalsMode, TraceMode, TubeMode, CartoonMode, QuickSurfaceMode, IsoSurfaceSASMode, IsoSurfaceSESMode, ContactSurfaceMode, TextMode]);

  function clamp(x, a, b) {
    return x <= b ? x < 0 ? 0 : x : b;
  }

  function lerpColor(c1, c2, alpha) {
    var beta = 1 - alpha;
    var r1 = c1 >> 16 & 0xff;
    var g1 = c1 >> 8 & 0xff;
    var b1 = c1 & 0xff;
    var r2 = c2 >> 16 & 0xff;
    var g2 = c2 >> 8 & 0xff;
    var b2 = c2 & 0xff;
    var r = beta * r1 + alpha * r2;
    var g = beta * g1 + alpha * g2;
    var b = beta * b1 + alpha * b2;
    return r << 16 | g << 8 | b;
  }

  var Palette = /*#__PURE__*/function () {
    function Palette(name, id) {
      _classCallCheck(this, Palette);

      this.name = name || 'Custom';
      this.id = id || 'CP';
    }

    _createClass(Palette, [{
      key: "getElementColor",
      value: function getElementColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.elementColors[name];
        return color === undefined && !asIs ? this.defaultElementColor : color;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.residueColors[name];
        return color === undefined && !asIs ? this.defaultResidueColor : color;
      }
    }, {
      key: "getChainColor",
      value: function getChainColor(name) {
        var chain = name.charCodeAt(0);
        chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 0x1f) % this.chainColors.length;
        return this.chainColors[chain];
      }
    }, {
      key: "getSecondaryColor",
      value: function getSecondaryColor(type) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.secondaryColors[type];
        return color === undefined && !asIs ? this.defaultSecondaryColor : color;
      }
    }, {
      key: "getSequentialColor",
      value: function getSequentialColor(index) {
        var colors = this.colors;
        var len = colors.length;
        return index < 0 ? colors[index % len + len] : colors[index % len];
      }
    }, {
      key: "getGradientColor",
      value: function getGradientColor(value, gradientName) {
        var gradient = this.gradients[gradientName];

        if (!gradient) {
          return this.defaultNamedColor;
        }

        var count = gradient.length;
        var index = value * (count - 1);
        var left = Math.floor(index);
        var right = clamp(left + 1, 0, count - 1);
        left = clamp(left, 0, count - 1);
        return lerpColor(gradient[left], gradient[right], index - left);
      }
    }, {
      key: "getNamedColor",
      value: function getNamedColor(name) {
        var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var color = this.namedColors[name];
        return color === undefined && !asIs ? this.defaultNamedColor : color;
      }
    }]);

    return Palette;
  }();

  ___default["default"].assign(Palette.prototype, {
    colors: [0xffffff, 0xff0000, 0x00ff00, 0x0000ff, 0x808080],
    minRangeColor: 0x000000,
    midRangeColor: 0x7f7f7f,
    maxRangeColor: 0xffffff,
    defaultElementColor: 0xffffff,
    elementColors: {},
    defaultResidueColor: 0xffffff,
    residueColors: {},
    chainColors: [0xffffff],
    defaultSecondaryColor: 0xffffff,
    secondaryColors: {},
    defaultGradientColor: 0x000000,
    defaultNamedColor: 0xffffff,
    namedColorsArray: [['indianred', 0xcd5c5c], ['lightcoral', 0xf08080], ['salmon', 0xfa8072], ['darksalmon', 0xe9967a], ['lightsalmon', 0xffa07a], ['crimson', 0xdc143c], ['red', 0xff0000], ['firebrick', 0xb22222], ['darkred', 0x8b0000], ['pink', 0xffc0cb], ['lightpink', 0xffb6c1], ['hotpink', 0xff69b4], ['deeppink', 0xff1493], ['mediumvioletred', 0xc71585], ['palevioletred', 0xdb7093], ['coral', 0xff7f50], ['tomato', 0xff6347], ['orangered', 0xff4500], ['darkorange', 0xff8c00], ['orange', 0xffa500], ['gold', 0xffd700], ['yellow', 0xffff00], ['lightyellow', 0xffffe0], ['lemonchiffon', 0xfffacd], ['lightgoldenrodyellow', 0xfafad2], ['papayawhip', 0xffefd5], ['moccasin', 0xffe4b5], ['peachpuff', 0xffdab9], ['palegoldenrod', 0xeee8aa], ['khaki', 0xf0e68c], ['darkkhaki', 0xbdb76b], ['lavender', 0xe6e6fa], ['thistle', 0xd8bfd8], ['plum', 0xdda0dd], ['violet', 0xee82ee], ['orchid', 0xda70d6], ['fuchsia', 0xff00ff], ['magenta', 0xff00ff], ['mediumorchid', 0xba55d3], ['mediumpurple', 0x9370db], ['rebeccapurple', 0x663399], ['blueviolet', 0x8a2be2], ['darkviolet', 0x9400d3], ['darkorchid', 0x9932cc], ['darkmagenta', 0x8b008b], ['purple', 0x800080], ['indigo', 0x4b0082], ['slateblue', 0x6a5acd], ['mediumslateblue', 0x7b68ee], ['darkslateblue', 0x483d8b], ['greenyellow', 0xadff2f], ['chartreuse', 0x7fff00], ['lawngreen', 0x7cfc00], ['lime', 0x00ff00], ['limegreen', 0x32cd32], ['palegreen', 0x98fb98], ['lightgreen', 0x90ee90], ['mediumspringgreen', 0x00fa9a], ['springgreen', 0x00ff7f], ['mediumseagreen', 0x3cb371], ['seagreen', 0x2e8b57], ['forestgreen', 0x228b22], ['green', 0x008000], ['darkgreen', 0x006400], ['yellowgreen', 0x9acd32], ['olivedrab', 0x6b8e23], ['olive', 0x808000], ['darkolivegreen', 0x556b2f], ['mediumaquamarine', 0x66cdaa], ['darkseagreen', 0x8fbc8f], ['lightseagreen', 0x20b2aa], ['darkcyan', 0x008b8b], ['teal', 0x008080], ['aqua', 0x00ffff], ['cyan', 0x00ffff], ['lightcyan', 0xe0ffff], ['paleturquoise', 0xafeeee], ['aquamarine', 0x7fffd4], ['turquoise', 0x40e0d0], ['mediumturquoise', 0x48d1cc], ['darkturquoise', 0x00ced1], ['cadetblue', 0x5f9ea0], ['steelblue', 0x4682b4], ['lightsteelblue', 0xb0c4de], ['powderblue', 0xb0e0e6], ['lightblue', 0xadd8e6], ['skyblue', 0x87ceeb], ['lightskyblue', 0x87cefa], ['deepskyblue', 0x00bfff], ['dodgerblue', 0x1e90ff], ['cornflowerblue', 0x6495ed], ['royalblue', 0x4169e1], ['blue', 0x0000ff], ['mediumblue', 0x0000cd], ['darkblue', 0x00008b], ['navy', 0x000080], ['midnightblue', 0x191970], ['cornsilk', 0xfff8dc], ['blanchedalmond', 0xffebcd], ['bisque', 0xffe4c4], ['navajowhite', 0xffdead], ['wheat', 0xf5deb3], ['burlywood', 0xdeb887], ['tan', 0xd2b48c], ['rosybrown', 0xbc8f8f], ['sandybrown', 0xf4a460], ['goldenrod', 0xdaa520], ['darkgoldenrod', 0xb8860b], ['peru', 0xcd853f], ['chocolate', 0xd2691e], ['saddlebrown', 0x8b4513], ['sienna', 0xa0522d], ['brown', 0xa52a2a], ['maroon', 0x800000], ['white', 0xffffff], ['snow', 0xfffafa], ['honeydew', 0xf0fff0], ['mintcream', 0xf5fffa], ['azure', 0xf0ffff], ['aliceblue', 0xf0f8ff], ['ghostwhite', 0xf8f8ff], ['whitesmoke', 0xf5f5f5], ['seashell', 0xfff5ee], ['beige', 0xf5f5dc], ['oldlace', 0xfdf5e6], ['floralwhite', 0xfffaf0], ['ivory', 0xfffff0], ['antiquewhite', 0xfaebd7], ['linen', 0xfaf0e6], ['lavenderblush', 0xfff0f5], ['mistyrose', 0xffe4e1], ['gainsboro', 0xdcdcdc], ['lightgray', 0xd3d3d3], ['silver', 0xc0c0c0], ['darkgray', 0xa9a9a9], ['gray', 0x808080], ['dimgray', 0x696969], ['lightslategray', 0x778899], ['slategray', 0x708090], ['darkslategray', 0x2f4f4f], ['black', 0x000000]],
    namedColors: {},
    gradients: {
      rainbow: [0x0000ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff0000],
      temp: [0x0000ff, 0x007fff, 0xffffff, 0xff7f00, 0xff0000],
      hot: [0xffffff, 0xff7f00, 0xff0000],
      cold: [0xffffff, 0x007fff, 0x0000ff],
      'blue-red': [0x0000ff, 0xffffff, 0xff0000],
      reds: [0xffffff, 0xff0000],
      blues: [0xffffff, 0x0000ff]
    }
  });

  var _Palette$prototype = Palette.prototype,
      namedColorsArray = _Palette$prototype.namedColorsArray,
      namedColors = _Palette$prototype.namedColors;

  for (var i = 0, length = namedColorsArray.length; i < length; ++i) {
    var _namedColorsArray$i = _slicedToArray(namedColorsArray[i], 2),
        name = _namedColorsArray$i[0],
        value = _namedColorsArray$i[1];

    namedColors[name] = value;
  }

  var palette$2 = new Palette('CPK', 'CP');
  palette$2.elementColors = {
    H: 0xffffff,
    C: 0x202020,
    N: 0x2060ff,
    O: 0xee2010,
    F: 0x00ff00,
    P: 0x8020ff,
    S: 0xffff00,
    CL: 0x00bb00,
    FE: 0xd0d0d0,
    CO: 0xd0d0d0,
    NI: 0xd0d0d0,
    CU: 0xd0d0d0,
    BR: 0x008800,
    I: 0x005500
  };

  var _palette$secondaryCol$1;
  var palette$1 = new Palette('Jmol', 'JM');
  palette$1.colors = [0x0000ff, 0x0055ff, 0x00abff, 0x00ffff, 0x00ffab, 0x00ff55, 0x00ff00, 0x55ff00, 0xabff00, 0xffff00, 0xffab00, 0xff5500, 0xff0000, 0xff0055, 0xff00ab, 0xff00ff, 0xab00ff, 0x5500ff];
  palette$1.elementColors = {
    H: 0xffffff,
    D: 0xffffc0,
    T: 0xffffa0,
    HE: 0xd9ffff,
    LI: 0xcc80ff,
    BE: 0xc2ff00,
    B: 0xffb5b5,
    C: 0x909090,
    N: 0x3050f8,
    O: 0xff0d0d,
    F: 0x90e050,
    NE: 0xb3e3f5,
    NA: 0xab5cf2,
    MG: 0x8aff00,
    AL: 0xbfa6a6,
    SI: 0xf0c8a0,
    P: 0xff8000,
    S: 0xffff30,
    CL: 0x1ff01f,
    AR: 0x80d1e3,
    K: 0x8f40d4,
    CA: 0x3dff00,
    SC: 0xe6e6e6,
    TI: 0xbfc2c7,
    V: 0xa6a6ab,
    CR: 0x8a99c7,
    MN: 0x9c7ac7,
    FE: 0xe06633,
    CO: 0xf090a0,
    NI: 0x50d050,
    CU: 0xc88033,
    ZN: 0x7d80b0,
    GA: 0xc28f8f,
    GE: 0x668f8f,
    AS: 0xbd80e3,
    SE: 0xffa100,
    BR: 0xa62929,
    KR: 0x5cb8d1,
    RB: 0x702eb0,
    SR: 0x00ff00,
    Y: 0x94ffff,
    ZR: 0x94e0e0,
    NB: 0x73c2c9,
    MO: 0x54b5b5,
    TC: 0x3b9e9e,
    RU: 0x248f8f,
    RH: 0x0a7d8c,
    PD: 0x006985,
    AG: 0xc0c0c0,
    CD: 0xffd98f,
    IN: 0xa67573,
    SN: 0x668080,
    SB: 0x9e63b5,
    TE: 0xd47a00,
    I: 0x940094,
    XE: 0x429eb0,
    CS: 0x57178f,
    BA: 0x00c900,
    LA: 0x70d4ff,
    CE: 0xffffc7,
    PR: 0xd9ffc7,
    ND: 0xc7ffc7,
    PM: 0xa3ffc7,
    SM: 0x8fffc7,
    EU: 0x61ffc7,
    GD: 0x45ffc7,
    TB: 0x30ffc7,
    DY: 0x1fffc7,
    HO: 0x00ff9c,
    ER: 0x00e675,
    TM: 0x00d452,
    YB: 0x00bf38,
    LU: 0x00ab24,
    HF: 0x4dc2ff,
    TA: 0x4da6ff,
    W: 0x2194d6,
    RE: 0x267dab,
    OS: 0x266696,
    IR: 0x175487,
    PT: 0xd0d0e0,
    AU: 0xffd123,
    HG: 0xb8b8d0,
    TL: 0xa6544d,
    PB: 0x575961,
    BI: 0x9e4fb5,
    PO: 0xab5c00,
    AT: 0x754f45,
    RN: 0x428296,
    FR: 0x420066,
    RA: 0x007d00,
    AC: 0x70abfa,
    TH: 0x00baff,
    PA: 0x00a1ff,
    U: 0x008fff,
    NP: 0x0080ff,
    PU: 0x006bff,
    AM: 0x545cf2,
    CM: 0x785ce3,
    BK: 0x8a4fe3,
    CF: 0xa136d4,
    ES: 0xb31fd4,
    FM: 0xb31fba,
    MD: 0xb30da6,
    NO: 0xbd0d87,
    LR: 0xc70066,
    RF: 0xcc0059,
    DB: 0xd1004f,
    SG: 0xd90045,
    BH: 0xe00038,
    HS: 0xe6002e,
    MT: 0xeb0026
  };
  palette$1.defaultResidueColor = 0xbea06e;
  palette$1.residueColors = {
    ALA: 0xc8c8c8,
    ARG: 0x145aff,
    ASN: 0x00dcdc,
    ASP: 0xe60a0a,
    CYS: 0xe6e600,
    GLN: 0x00dcdc,
    GLU: 0xe60a0a,
    GLY: 0xebebeb,
    HIS: 0x8282d2,
    ILE: 0x0f820f,
    LEU: 0x0f820f,
    LYS: 0x145aff,
    MET: 0xe6e600,
    PHE: 0x3232aa,
    PRO: 0xdc9682,
    SER: 0xfa9600,
    THR: 0xfa9600,
    TRP: 0xb45ab4,
    TYR: 0x3232aa,
    VAL: 0x0f820f,
    A: 0xa0a0ff,
    C: 0xff8c4b,
    G: 0xff7070,
    I: 0x80ffff,
    T: 0xa0ffa0,
    U: 0xff8080,
    DA: 0xa0a0ff,
    DC: 0xff8c4b,
    DG: 0xff7070,
    DI: 0x80ffff,
    DT: 0xa0ffa0,
    DU: 0xff8080,
    '+A': 0xa0a0ff,
    '+C': 0xff8c4b,
    '+G': 0xff7070,
    '+I': 0x80ffff,
    '+T': 0xa0ffa0,
    '+U': 0xff8080
  };
  palette$1.chainColors = [0xffffffff, 0xffc0d0ff, 0xffb0ffb0, 0xffffc0c8, 0xffffff80, 0xffffc0ff, 0xffb0f0f0, 0xffffd070, 0xfff08080, 0xfff5deb3, 0xff00bfff, 0xffcd5c5c, 0xff66cdaa, 0xff9acd32, 0xffee82ee, 0xff00ced1, 0xff00ff7f, 0xff3cb371, 0xff00008b, 0xffbdb76b, 0xff006400, 0xff800000, 0xff808000, 0xff800080, 0xff008080, 0xffb8860b, 0xffb22222];
  var StructuralElementType$2 = StructuralElement.Type;
  palette$1.secondaryColors = (_palette$secondaryCol$1 = {}, _defineProperty(_palette$secondaryCol$1, StructuralElementType$2.HELIX_ALPHA, 0xff0080), _defineProperty(_palette$secondaryCol$1, StructuralElementType$2.HELIX_PI, 0x600080), _defineProperty(_palette$secondaryCol$1, StructuralElementType$2.HELIX_310, 0xa00080), _defineProperty(_palette$secondaryCol$1, StructuralElementType$2.STRAND, 0xffc800), _defineProperty(_palette$secondaryCol$1, StructuralElementType$2.TURN, 0x6080ff), _defineProperty(_palette$secondaryCol$1, "dna", 0xae00fe), _defineProperty(_palette$secondaryCol$1, "rna", 0xfd0162), _palette$secondaryCol$1);

  var _palette$secondaryCol;
  var palette = new Palette('VMD', 'VM');
  palette.colors = [0x0000ff, 0xff0000, 0x606060, 0xff8000, 0xffff00, 0x808033, 0x999999, 0x00ff00, 0xffffff, 0xff9999, 0x40c0c0, 0xa600a6, 0x80e666, 0xe666b3, 0x804d00, 0x8080c0];
  palette.defaultElementColor = 0x804d00;
  palette.elementColors = {
    H: 0xffffff,
    C: 0x40bfbf,
    N: 0x0000ff,
    O: 0xff0000,
    P: 0x808033,
    S: 0xffff00
  };
  palette.defaultResidueColor = 0x40c0c0;
  palette.residueColors = {
    ALA: 0x0000ff,
    ARG: 0xffffff,
    ASN: 0x808033,
    ASP: 0xff0000,
    CYS: 0xffff00,
    GLN: 0xff8000,
    GLU: 0xff9999,
    GLY: 0xffffff,
    HIS: 0x40c0c0,
    ILE: 0x00ff00,
    LEU: 0xff9999,
    LYS: 0x40c0c0,
    MET: 0xffff00,
    PHE: 0xa600a6,
    PRO: 0x804c00,
    SER: 0xffff00,
    THR: 0xe666b3,
    TRP: 0x999999,
    TYR: 0x00ff00,
    VAL: 0x808033,
    A: 0x0000ff,
    C: 0xff8000,
    G: 0xffff00,
    T: 0xa600a6,
    U: 0x00ff00,
    DA: 0x0000ff,
    DC: 0xff8000,
    DG: 0xffff00,
    DT: 0xa600a6,
    DU: 0x00ff00,
    '+A': 0x0000ff,
    '+C': 0xff8000,
    '+G': 0xffff00,
    '+T': 0xa600a6,
    '+U': 0x00ff00,
    WAT: 0x40c0c0,
    H2O: 0x40c0c0,
    HOH: 0x40c0c0
  };
  palette.chainColors = [0xffffff].concat(palette.colors);
  var StructuralElementType$1 = StructuralElement.Type;
  palette.secondaryColors = (_palette$secondaryCol = {}, _defineProperty(_palette$secondaryCol, StructuralElementType$1.HELIX_ALPHA, 0xa600a6), _defineProperty(_palette$secondaryCol, StructuralElementType$1.HELIX_310, 0x0000ff), _defineProperty(_palette$secondaryCol, StructuralElementType$1.HELIX_PI, 0xff0000), _defineProperty(_palette$secondaryCol, StructuralElementType$1.STRAND, 0xffff00), _defineProperty(_palette$secondaryCol, StructuralElementType$1.BRIDGE, 0x808033), _defineProperty(_palette$secondaryCol, StructuralElementType$1.TURN, 0x40c0c0), _palette$secondaryCol);

  var palettes$1 = new EntityList([palette$2, palette$1, palette]);

  var Colorer = /*#__PURE__*/function () {
    function Colorer(opts) {
      _classCallCheck(this, Colorer);

      if (this.constructor === Colorer) {
        throw new Error('Can not instantiate abstract class!');
      }

      this.opts = ___default["default"].merge(utils.deriveDeep(settings$1.now.colorers[this.id], true), opts);
      this.palette = palettes$1.first;
    }

    _createClass(Colorer, [{
      key: "identify",
      value: function identify() {
        var diff = utils.objectsDiff(this.opts, settings$1.now.colorers[this.id]);

        if (!___default["default"].isEmpty(diff)) {
          return [this.id, diff];
        }

        return this.id;
      }
    }]);

    return Colorer;
  }();

  Colorer.prototype.id = '__';

  function _createSuper$M(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$M(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$M() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ElementColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(ElementColorer, _Colorer);

    var _super = _createSuper$M(ElementColorer);

    function ElementColorer() {
      _classCallCheck(this, ElementColorer);

      return _super.apply(this, arguments);
    }

    _createClass(ElementColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var type = atom.element.name;

        if (type === 'C' && this.opts.carbon >= 0) {
          return this.opts.carbon;
        }

        return this.palette.getElementColor(type);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.palette.defaultResidueColor;
      }
    }]);

    return ElementColorer;
  }(Colorer);

  _defineProperty(ElementColorer, "id", 'EL');

  ElementColorer.prototype.id = 'EL';
  ElementColorer.prototype.name = 'Element';
  ElementColorer.prototype.shortName = 'Element';

  function _createSuper$L(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$L(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$L() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ResidueTypeColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(ResidueTypeColorer, _Colorer);

    var _super = _createSuper$L(ResidueTypeColorer);

    function ResidueTypeColorer() {
      _classCallCheck(this, ResidueTypeColorer);

      return _super.apply(this, arguments);
    }

    _createClass(ResidueTypeColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        return this.palette.getResidueColor(residue._type._name);
      }
    }]);

    return ResidueTypeColorer;
  }(Colorer);

  _defineProperty(ResidueTypeColorer, "id", 'RT');

  ResidueTypeColorer.prototype.id = 'RT';
  ResidueTypeColorer.prototype.name = 'Residue Type';
  ResidueTypeColorer.prototype.shortName = 'Residue';

  function _createSuper$K(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$K(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$K() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SequenceColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(SequenceColorer, _Colorer);

    var _super = _createSuper$K(SequenceColorer);

    function SequenceColorer() {
      _classCallCheck(this, SequenceColorer);

      return _super.apply(this, arguments);
    }

    _createClass(SequenceColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var chain = residue._chain;

        if (chain.minSequence === Number.POSITIVE_INFINITY && chain.maxSequence === Number.NEGATIVE_INFINITY) {
          return this.palette.defaultNamedColor;
        }

        var min = chain.minSequence;
        var max = chain.maxSequence > min ? chain.maxSequence : min + 1;
        return this.palette.getGradientColor((residue._sequence - min) / (max - min), this.opts.gradient);
      }
    }]);

    return SequenceColorer;
  }(Colorer);

  _defineProperty(SequenceColorer, "id", 'SQ');

  SequenceColorer.prototype.id = 'SQ';
  SequenceColorer.prototype.name = 'Sequence';
  SequenceColorer.prototype.shortName = 'Sequence';

  function _createSuper$J(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$J(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$J() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ChainColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(ChainColorer, _Colorer);

    var _super = _createSuper$J(ChainColorer);

    function ChainColorer() {
      _classCallCheck(this, ChainColorer);

      return _super.apply(this, arguments);
    }

    _createClass(ChainColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        return this.palette.getChainColor(residue.getChain()._name);
      }
    }]);

    return ChainColorer;
  }(Colorer);

  _defineProperty(ChainColorer, "id", 'CH');

  ChainColorer.prototype.id = 'CH';
  ChainColorer.prototype.name = 'Chain';
  ChainColorer.prototype.shortName = 'Chain';

  function _createSuper$I(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$I(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$I() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var SecondaryStructureColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(SecondaryStructureColorer, _Colorer);

    var _super = _createSuper$I(SecondaryStructureColorer);

    function SecondaryStructureColorer() {
      _classCallCheck(this, SecondaryStructureColorer);

      return _super.apply(this, arguments);
    }

    _createClass(SecondaryStructureColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        if (residue._type.flags & ResidueType$1.Flags.DNA) {
          return this.palette.getSecondaryColor('dna');
        }

        if (residue._type.flags & ResidueType$1.Flags.RNA) {
          return this.palette.getSecondaryColor('rna');
        }

        var secondary = residue.getSecondary();

        if (secondary) {
          var color = this.palette.getSecondaryColor(secondary.type, true);

          if (color === undefined) {
            color = this.palette.getSecondaryColor(secondary.generic);
          }

          return color;
        }

        return this.palette.defaultSecondaryColor;
      }
    }]);

    return SecondaryStructureColorer;
  }(Colorer);

  _defineProperty(SecondaryStructureColorer, "id", 'SS');

  SecondaryStructureColorer.prototype.id = 'SS';
  SecondaryStructureColorer.prototype.name = 'Secondary Structure';
  SecondaryStructureColorer.prototype.shortName = 'Structure';

  function _createSuper$H(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$H(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$H() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var UniformColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(UniformColorer, _Colorer);

    var _super = _createSuper$H(UniformColorer);

    function UniformColorer() {
      _classCallCheck(this, UniformColorer);

      return _super.apply(this, arguments);
    }

    _createClass(UniformColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(_atom, _complex) {
        return this.opts.color;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.opts.color;
      }
    }]);

    return UniformColorer;
  }(Colorer);

  _defineProperty(UniformColorer, "id", 'UN');

  UniformColorer.prototype.id = 'UN';
  UniformColorer.prototype.name = 'Uniform';
  UniformColorer.prototype.shortName = 'Uniform';

  function _createSuper$G(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$G(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$G() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ConditionalColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(ConditionalColorer, _Colorer);

    var _super = _createSuper$G(ConditionalColorer);

    function ConditionalColorer(opts) {
      var _this;

      _classCallCheck(this, ConditionalColorer);

      _this = _super.call(this, opts);
      var parsed = selectors$5.parse(_this.opts.subset);
      _this._subsetCached = parsed.error ? selectors$5.none() : parsed.selector;
      return _this;
    }

    _createClass(ConditionalColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var subset = this._subsetCached;
        var atoms = residue._atoms;

        for (var i = 0, n = atoms.length; i < n; ++i) {
          if (!subset.includesAtom(atoms[i])) {
            return this.opts.baseColor;
          }
        }

        return this.opts.color;
      }
    }]);

    return ConditionalColorer;
  }(Colorer);

  _defineProperty(ConditionalColorer, "id", 'CO');

  ConditionalColorer.prototype.id = 'CO';
  ConditionalColorer.prototype.name = 'Conditional';
  ConditionalColorer.prototype.shortName = 'Conditional';

  function _createSuper$F(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$F(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$F() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ConformationColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(ConformationColorer, _Colorer);

    var _super = _createSuper$F(ConformationColorer);

    function ConformationColorer() {
      _classCallCheck(this, ConformationColorer);

      return _super.apply(this, arguments);
    }

    _createClass(ConformationColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        return this.palette.getChainColor(String.fromCharCode(atom.location));
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.palette.defaultResidueColor;
      }
    }]);

    return ConformationColorer;
  }(Colorer);

  _defineProperty(ConformationColorer, "id", 'CF');

  ConformationColorer.prototype.id = 'CF';
  ConformationColorer.prototype.name = 'Conformation';
  ConformationColorer.prototype.shortName = 'Conformation';

  function _createSuper$E(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$E(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$E() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var TemperatureColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(TemperatureColorer, _Colorer);

    var _super = _createSuper$E(TemperatureColorer);

    function TemperatureColorer() {
      _classCallCheck(this, TemperatureColorer);

      return _super.apply(this, arguments);
    }

    _createClass(TemperatureColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var opts = this.opts;
        var factor = 1;

        if (atom.temperature && opts) {
          if (opts.min === opts.max) {
            factor = atom.temperature > opts.max ? 1 : 0;
          } else {
            factor = (atom.temperature - opts.min) / (opts.max - opts.min);
          }

          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var opts = this.opts;

        if (!opts) {
          return this.palette.defaultGradientColor;
        }

        if (residue.temperature) {
          var factor = 0;

          if (opts.min === opts.max) {
            factor = residue.temperature > opts.max ? 1 : 0;
          } else {
            factor = (residue.temperature - opts.min) / (opts.max - opts.min);
          }

          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }]);

    return TemperatureColorer;
  }(Colorer);

  _defineProperty(TemperatureColorer, "id", 'TM');

  TemperatureColorer.prototype.id = 'TM';
  TemperatureColorer.prototype.name = 'Temperature';
  TemperatureColorer.prototype.shortName = 'Temperature';

  function _createSuper$D(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$D(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$D() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var OccupancyColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(OccupancyColorer, _Colorer);

    var _super = _createSuper$D(OccupancyColorer);

    function OccupancyColorer() {
      _classCallCheck(this, OccupancyColorer);

      return _super.apply(this, arguments);
    }

    _createClass(OccupancyColorer, [{
      key: "_getColorByOccupancy",
      value: function _getColorByOccupancy(occupancy, opts) {
        if (occupancy !== undefined) {
          var factor = 1 - occupancy;
          return this.palette.getGradientColor(factor, opts.gradient);
        }

        return this.palette.defaultGradientColor;
      }
    }, {
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var opts = this.opts;
        return this._getColorByOccupancy(atom.occupancy, opts);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var opts = this.opts;
        return this._getColorByOccupancy(residue.occupancy, opts);
      }
    }]);

    return OccupancyColorer;
  }(Colorer);

  _defineProperty(OccupancyColorer, "id", 'OC');

  OccupancyColorer.prototype.id = 'OC';
  OccupancyColorer.prototype.name = 'Occupancy';
  OccupancyColorer.prototype.shortName = 'Occupancy';

  function _createSuper$C(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$C(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$C() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var HydrophobicityColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(HydrophobicityColorer, _Colorer);

    var _super = _createSuper$C(HydrophobicityColorer);

    function HydrophobicityColorer() {
      _classCallCheck(this, HydrophobicityColorer);

      return _super.apply(this, arguments);
    }

    _createClass(HydrophobicityColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var color = this.palette.defaultResidueColor;

        if (residue._type.hydrophobicity !== undefined) {
          var min = -4.5;
          var max = 4.5;
          color = this.palette.getGradientColor((residue._type.hydrophobicity - min) / (max - min), this.opts.gradient);
        }

        return color;
      }
    }]);

    return HydrophobicityColorer;
  }(Colorer);

  _defineProperty(HydrophobicityColorer, "id", 'HY');

  HydrophobicityColorer.prototype.id = 'HY';
  HydrophobicityColorer.prototype.name = 'Hydrophobicity';
  HydrophobicityColorer.prototype.shortName = 'Hydrophobicity';

  function _createSuper$B(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$B(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$B() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var MoleculeColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(MoleculeColorer, _Colorer);

    var _super = _createSuper$B(MoleculeColorer);

    function MoleculeColorer() {
      _classCallCheck(this, MoleculeColorer);

      return _super.apply(this, arguments);
    }

    _createClass(MoleculeColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, complex) {
        return this.getResidueColor(atom.residue, complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(residue, _complex) {
        var molecule = residue._molecule;

        var count = _complex.getMoleculeCount();

        if (count > 1) {
          return this.palette.getGradientColor((molecule.index - 1) / (count - 1), this.opts.gradient);
        }

        return this.palette.getGradientColor(0, this.opts.gradient);
      }
    }]);

    return MoleculeColorer;
  }(Colorer);

  _defineProperty(MoleculeColorer, "id", 'MO');

  MoleculeColorer.prototype.id = 'MO';
  MoleculeColorer.prototype.name = 'Molecule';
  MoleculeColorer.prototype.shortName = 'Molecule';

  function _createSuper$A(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$A(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$A() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function scaleColor(c, factor) {
    var r1 = c >> 16 & 0xff;
    var g1 = c >> 8 & 0xff;
    var b1 = c & 0xff;
    var r = factor * r1;
    var g = factor * g1;
    var b = factor * b1;
    return r << 16 | g << 8 | b;
  }

  var CarbonColorer = /*#__PURE__*/function (_Colorer) {
    _inherits(CarbonColorer, _Colorer);

    var _super = _createSuper$A(CarbonColorer);

    function CarbonColorer() {
      _classCallCheck(this, CarbonColorer);

      return _super.apply(this, arguments);
    }

    _createClass(CarbonColorer, [{
      key: "getAtomColor",
      value: function getAtomColor(atom, _complex) {
        var colorCarbon = this.opts.color;
        var colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
        return atom.flags & Atom$2.Flags.CARBON ? colorCarbon : colorNotCarbon;
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(_residue, _complex) {
        return this.opts.color;
      }
    }]);

    return CarbonColorer;
  }(Colorer);

  _defineProperty(CarbonColorer, "id", 'CB');

  CarbonColorer.prototype.id = 'CB';
  CarbonColorer.prototype.name = 'Carbon';
  CarbonColorer.prototype.shortName = 'Carbon';

  var colorers$1 = new EntityList([ElementColorer, ResidueTypeColorer, SequenceColorer, ChainColorer, SecondaryStructureColorer, UniformColorer, ConditionalColorer, ConformationColorer, TemperatureColorer, OccupancyColorer, HydrophobicityColorer, MoleculeColorer, CarbonColorer]);

  function neutralColor(intensity) {
    return new THREE__namespace.Color(intensity, intensity, intensity);
  }

  var materialList = [{
    id: 'DF',
    name: 'Diffuse',
    shortName: 'Diffuse',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'SF',
    name: 'Soft Plastic',
    shortName: 'Soft',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.1),
      shininess: 30,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'PL',
    name: 'Glossy Plastic',
    shortName: 'Glossy',
    uberOptions: {
      diffuse: neutralColor(0.56),
      specular: neutralColor(0.28),
      shininess: 100,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'ME',
    name: 'Metal',
    shortName: 'Metal',
    uberOptions: {
      diffuse: neutralColor(0.56),
      specular: neutralColor(0.55),
      shininess: 30,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'TR',
    name: 'Transparent',
    shortName: 'Transparent',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 0.5
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: true,
      toonShading: false
    }
  }, {
    id: 'GL',
    name: 'Glass',
    shortName: 'Glass',
    uberOptions: {
      diffuse: neutralColor(0.5),
      specular: neutralColor(0.65),
      shininess: 100,
      opacity: 0.5
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: true,
      toonShading: false
    }
  }, {
    id: 'BA',
    name: 'Backdrop',
    shortName: 'Backdrop',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: false,
      fog: false,
      depthWrite: false,
      transparent: false,
      toonShading: false
    }
  }, {
    id: 'TN',
    name: 'Toon',
    shortName: 'Toon',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 1,
      opacity: 1.0
    },
    values: {
      lights: true,
      fog: true,
      depthWrite: true,
      transparent: false,
      toonShading: true
    }
  }, {
    id: 'FL',
    name: 'Flat',
    shortName: 'Flat',
    uberOptions: {
      diffuse: neutralColor(1.0),
      specular: neutralColor(0.0),
      shininess: 0,
      opacity: 1.0
    },
    values: {
      lights: false,
      fog: true,
      depthWrite: true,
      transparent: false
    }
  }];
  var materials$1 = new EntityList(materialList);

  function _gatherObjects(root, meshTypes) {
    var meshes = [];
    root.traverse(function (object) {
      for (var i = 0; i < meshTypes.length; i++) {
        if (object instanceof meshTypes[i]) {
          meshes[meshes.length] = object;
          break;
        }
      }
    });
    return meshes;
  }

  function createDerivativeMesh(mesh, values, layer) {
    var material = mesh.material.createInstance();
    material.setValues(values);
    var newMesh = new mesh.constructor(mesh.geometry, material);
    newMesh.material.needsUpdate = true;
    newMesh.applyMatrix4(mesh.matrix);
    newMesh.layers.set(layer);
    return newMesh;
  }

  function traverseMeshes(root, meshTypes, func) {
    var meshes = _gatherObjects(root, meshTypes);

    for (var i = 0, n = meshes.length; i < n; ++i) {
      var mesh = meshes[i];

      if (!mesh.parent) {
        continue;
      }

      func(mesh);
    }
  }

  function applyTransformsToMeshes(root, mtc) {
    var mtcCount = mtc.length;

    if (mtcCount < 1) {
      return;
    }

    var meshTypes = [THREE__namespace.Mesh, THREE__namespace.LineSegments, THREE__namespace.Line];
    traverseMeshes(root, meshTypes, function (mesh) {
      mesh.applyMatrix4(mtc[0]);

      for (var j = 1; j < mtcCount; ++j) {
        var newMesh = new mesh.constructor(mesh.geometry, mesh.material);
        mesh.parent.add(newMesh);
        newMesh.applyMatrix4(mtc[j]);
      }
    });
  }

  var processTransparentMaterial = function () {
    var matValues = {
      prepassTransparancy: true,
      fakeOpacity: false,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE__namespace.Mesh, THREE__namespace.LineSegments], function (mesh) {
        mesh.material.setValues({
          prepassTransparancy: false,
          fakeOpacity: false
        });
        mesh.material.needsUpdate = true;
        mesh.layers.set(gfxutils.LAYERS.TRANSPARENT);
        var prepassTranspMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.PREPASS_TRANSPARENT);
        mesh.parent.add(prepassTranspMesh);
      });
    };
  }();

  var processColFromPosMaterial = function () {
    var matValues = {
      colorFromPos: true,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false,
      overrideColor: false,
      fogTransparent: false,
      attrColor: false,
      attrColor2: false,
      attrAlphaColor: false,
      fakeOpacity: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE__namespace.Mesh, THREE__namespace.LineSegments], function (mesh) {
        var colFromPosMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.COLOR_FROM_POSITION);
        mesh.parent.add(colFromPosMesh);
      });
    };
  }();

  var createShadowmapMaterial = function () {
    var matValues = {
      colorFromDepth: true,
      orthoCam: true,
      lights: false,
      shadowmap: false,
      fog: false
    };
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return;
      }

      traverseMeshes(root, [THREE__namespace.Mesh, THREE__namespace.LineSegments], function (mesh) {
        if (!mesh.receiveShadow && mesh.material.shadowmap) {
          mesh.material.setValues({
            shadowmap: false
          });
        }

        if (!mesh.material.lights) {
          return;
        }

        if (!mesh.castShadow) {
          return;
        }

        if (!gfxutils.belongToSelectLayers(mesh)) {
          return;
        }

        var shadowmapMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.SHADOWMAP);
        shadowmapMesh.isShadowmapMesh = true;
        mesh.parent.add(shadowmapMesh);
      });
    };
  }();

  function removeShadowmapMaterial(root, material) {
    if (!(material instanceof UberMaterial)) {
      return;
    }

    traverseMeshes(root, [THREE__namespace.Mesh, THREE__namespace.LineSegments], function (mesh) {
      if (mesh.isShadowmapMesh) {
        mesh.parent.remove(mesh);
      }
    });
  }

  function forEachMeshInGroup(group, process) {
    function processObj(object) {
      if (object instanceof THREE__namespace.Mesh) {
        process(object);
      }

      for (var i = 0, l = object.children.length; i < l; i++) {
        processObj(object.children[i]);
      }
    }

    processObj(group);
  }

  function _countMeshTriangles(mesh) {
    var geom = mesh.geometry;

    if (geom instanceof THREE__namespace.InstancedBufferGeometry) {
      var attribs = geom.attributes;

      for (var property in attribs) {
        if (attribs.hasOwnProperty(property) && attribs[property] instanceof THREE__namespace.InstancedBufferAttribute) {
          var currAttr = attribs[property];
          var indexSize = geom.index ? geom.index.array.length / 3 : 0;
          return indexSize * currAttr.array.length / currAttr.itemSize;
        }
      }

      return 0;
    }

    if (geom instanceof THREE__namespace.BufferGeometry) {
      return geom.index ? geom.index.array.length / 3 : 0;
    }

    return geom.faces ? geom.faces.length : 0;
  }

  function countTriangles(group) {
    var totalCount = 0;
    forEachMeshInGroup(group, function (mesh) {
      totalCount += _countMeshTriangles(mesh);
    });
    return totalCount;
  }

  var meshutils = {
    applyTransformsToMeshes: applyTransformsToMeshes,
    processTransparentMaterial: processTransparentMaterial,
    processColFromPosMaterial: processColFromPosMaterial,
    createShadowmapMaterial: createShadowmapMaterial,
    removeShadowmapMaterial: removeShadowmapMaterial,
    forEachMeshInGroup: forEachMeshInGroup,
    countTriangles: countTriangles
  };

  var selectors$3 = chem.selectors;

  var Representation = /*#__PURE__*/function () {
    function Representation(index, mode, colorer, selector) {
      _classCallCheck(this, Representation);

      var startMaterialValues = {
        clipPlane: settings$1.now.draft.clipPlane,
        fogTransparent: settings$1.now.bg.transparent,
        shadowmap: settings$1.now.shadow.on,
        shadowmapType: settings$1.now.shadow.type
      };
      this.index = index;
      this.mode = mode;
      this.colorer = colorer;
      this.selector = selector;
      this.selectorString = '';
      this.count = 0;
      this.material = new UberMaterial();
      this.material.setValues(startMaterialValues);
      this.material.setUberOptions({
        fogAlpha: settings$1.now.fogAlpha
      });
      this.materialPreset = materials$1.first;
      this.needsRebuild = true;
      this.visible = true;
      this.setMode(mode);
    }

    _createClass(Representation, [{
      key: "markAtoms",
      value: function markAtoms(complex) {
        this.count = complex.markAtoms(this.selector, 1 << this.index);
        this.needsRebuild = true;
        return this.count;
      }
    }, {
      key: "unmarkAtoms",
      value: function unmarkAtoms(complex) {
        complex.clearAtomBits(1 << this.index);
        this.count = 0;
      }
    }, {
      key: "setMode",
      value: function setMode(mode) {
        this.mode = mode;
      }
    }, {
      key: "setMaterialPreset",
      value: function setMaterialPreset(preset) {
        this.materialPreset = preset;
        this.material.setUberOptions(preset.uberOptions);
        this.material.setValues(preset.values);
      }
    }, {
      key: "reset",
      value: function reset() {
        this.geo = null;
        this.selectionGeo = null;
      }
    }, {
      key: "buildGeometry",
      value: function buildGeometry(complex) {
        this.reset();
        this.needsRebuild = false;

        if (settings$1.now.ao) {
          this.material.setValues({
            normalsToGBuffer: settings$1.now.ao
          });
        }

        this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);

        if (this.material.uberOptions.opacity < 0.99 && settings$1.now.transparency === 'prepass') {
          meshutils.processTransparentMaterial(this.geo, this.material);
        }

        this.geo.visible = this.visible;
        gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id);
        meshutils.processColFromPosMaterial(this.geo, this.material);

        if (settings$1.now.shadow.on) {
          meshutils.createShadowmapMaterial(this.geo, this.material);
        }

        return this.geo;
      }
    }, {
      key: "buildSelectionGeometry",
      value: function buildSelectionGeometry(mask) {
        var sg = null;

        if (this.geo && 'getSubset' in this.geo) {
          var meshes = this.geo.getSubset(mask);

          if (meshes && meshes.length > 0) {
            sg = new THREE__namespace.Group();
            sg.matrixAutoUpdate = false;
            sg.matrix = this.geo.matrix;

            for (var j = 0; j < meshes.length; j++) {
              var m = meshes[j];
              sg.add(m);
            }
          }
        }

        if (sg) {
          sg.visible = this.visible;
        }

        this.selectionGeo = sg;
        return this.selectionGeo;
      }
    }, {
      key: "compare",
      value: function compare(repSettings) {
        var diff = {};
        var selStr = String(this.selector);

        if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
          diff.selector = selStr;
        }

        var modeDiff = this.mode.identify();

        if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
          diff.mode = modeDiff;
        }

        var colorerDiff = this.colorer.identify();

        if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
          diff.colorer = colorerDiff;
        }

        if (!repSettings || this.materialPreset.id !== repSettings.material) {
          diff.material = this.materialPreset.id;
        }

        return diff;
      }
    }, {
      key: "change",
      value: function change(repSettings, complex, mode, color) {
        var diff = {};

        if (repSettings.selector) {
          var newSelectorObject = selectors$3.parse(repSettings.selector).selector;
          var newSelector = String(newSelectorObject);

          if (this.selectorString !== newSelector) {
            diff.selector = newSelector;
            this.selectorString = newSelector;
            this.selector = newSelectorObject;
            this.markAtoms(complex);
          }
        }

        if (repSettings.mode) {
          var newMode = repSettings.mode;

          if (!___default["default"].isEqual(this.mode.identify(), newMode)) {
            diff.mode = newMode;
            this.setMode(mode);
          }
        }

        if (repSettings.colorer) {
          var newColorer = repSettings.colorer;

          if (!___default["default"].isEqual(this.colorer.identify(), newColorer)) {
            diff.colorer = newColorer;
            this.colorer = color;
          }
        }

        if (repSettings.material) {
          var newMaterial = repSettings.material;

          if (!___default["default"].isEqual(this.materialPreset.id, newMaterial)) {
            diff.material = newMaterial;
            this.setMaterialPreset(materials$1.get(repSettings.material));
          }
        }

        return diff;
      }
    }, {
      key: "show",
      value: function show(visible) {
        this.visible = visible;

        if (this.geo) {
          this.geo.visible = visible;
        }

        if (this.selectionGeo) {
          this.selectionGeo.visible = visible;
        }
      }
    }]);

    return Representation;
  }();

  function _createSuper$z(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$z(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$z() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _traverseComponentGroups(root, component, callback) {
    var children = root.children;

    if (!children) {
      return;
    }

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i];

      if (child._component === component) {
        callback(child);
      }

      if (child instanceof gfxutils.RCGroup) {
        _traverseComponentGroups(child, component, callback);
      }
    }
  }

  function ComplexEditor() {}

  var ComplexComponentEditor = /*#__PURE__*/function (_ComplexEditor) {
    _inherits(ComplexComponentEditor, _ComplexEditor);

    var _super = _createSuper$z(ComplexComponentEditor);

    function ComplexComponentEditor(complexVisual) {
      var _this;

      _classCallCheck(this, ComplexComponentEditor);

      _this = _super.call(this);
      _this._complexVisual = complexVisual;
      _this._inProgress = false;
      return _this;
    }

    _createClass(ComplexComponentEditor, [{
      key: "begin",
      value: function begin() {
        var complex = this._complexVisual.getComplex();

        this._componentTransforms = [];

        for (var i = 0; i < complex._components.length; ++i) {
          var component = complex._components[i];
          this._componentTransforms[component._index] = new THREE__namespace.Object3D();
        }

        this._inProgress = true;
        return true;
      }
    }, {
      key: "apply",
      value: function apply() {
        if (!this._inProgress) {
          return;
        }

        var complex = this._complexVisual.getComplex();

        for (var i = 0; i < complex._components.length; ++i) {
          this._bakeComponentTransform(complex._components[i]);
        }

        complex.onAtomPositionChanged();

        this._resetComponentTransform();

        this._complexVisual.finalizeEdit();
      }
    }, {
      key: "discard",
      value: function discard() {
        if (!this._inProgress) {
          return;
        }

        this._resetComponentTransform();

        this._complexVisual.finalizeEdit();
      }
    }, {
      key: "getAltObj",
      value: function getAltObj() {
        var res = {
          objects: [],
          pivot: new THREE__namespace.Vector3(0, 0, 0)
        };
        var visual = this._complexVisual;
        var component = visual.getSelectedComponent();

        if (component === null) {
          return res;
        }

        var selection = this._complexVisual.getSelectionGeo();

        var selectionMask = 1 << visual.getSelectionBit();
        var i;
        var j;
        var reprNode;
        var geo;

        _traverseComponentGroups(visual, component, function (child) {
          res.objects.push(child);
        });

        for (i = 0; i < selection.children.length; ++i) {
          reprNode = selection.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component') && geo._component === component) {
              res.objects.push(geo);
            }
          }
        }

        res.objects.push(this._componentTransforms[component._index]);
        var bbmin = new THREE__namespace.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        var bbmax = new THREE__namespace.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        component.forEachResidue(function (residue) {
          var atoms = residue._atoms;

          for (j = 0; j < atoms.length; ++j) {
            if (atoms[j].mask & selectionMask) {
              bbmin.min(atoms[j].position);
              bbmax.max(atoms[j].position);
            }
          }
        });
        res.pivot.lerpVectors(bbmin, bbmax, 0.5);
        return res;
      }
    }, {
      key: "_bakeComponentTransform",
      value: function _bakeComponentTransform(component) {
        var t = this._componentTransforms[component._index];

        if (t && (!(t.position.x === 0 && t.position.y === 0 && t.position.z === 0) || !(t.quaternion.x === 0 && t.quaternion.y === 0 && t.quaternion.z === 0 && t.quaternion.w === 1))) {
          t.updateMatrix();
          component.forEachResidue(function (residue) {
            var atoms = residue._atoms;

            for (var j = 0; j < atoms.length; ++j) {
              atoms[j].position.applyMatrix4(t.matrix);
            }
          });
        }
      }
    }, {
      key: "_resetComponentTransform",
      value: function _resetComponentTransform() {
        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        var i;
        var j;
        var reprNode;
        var geo;

        for (i = 0; i < this._componentTransforms.length; ++i) {
          geo = this._componentTransforms[i];
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }

        for (i = 0; i < visual.children.length; ++i) {
          reprNode = visual.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component')) {
              geo.position.set(0, 0, 0);
              geo.quaternion.set(0, 0, 0, 1);
            }
          }
        }

        for (i = 0; i < selection.children.length; ++i) {
          reprNode = selection.children[i];

          for (j = 0; j < reprNode.children.length; ++j) {
            geo = reprNode.children[j];

            if (geo.hasOwnProperty('_component')) {
              geo.position.set(0, 0, 0);
              geo.quaternion.set(0, 0, 0, 1);
            }
          }
        }
      }
    }]);

    return ComplexComponentEditor;
  }(ComplexEditor);

  var ComplexFragmentEditor = /*#__PURE__*/function (_ComplexEditor2) {
    _inherits(ComplexFragmentEditor, _ComplexEditor2);

    var _super2 = _createSuper$z(ComplexFragmentEditor);

    function ComplexFragmentEditor(complexVisual) {
      var _this2;

      _classCallCheck(this, ComplexFragmentEditor);

      _this2 = _super2.call(this);
      _this2._complexVisual = complexVisual;
      _this2._inProgress = false;
      return _this2;
    }

    _createClass(ComplexFragmentEditor, [{
      key: "begin",
      value: function begin() {
        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        var atoms = this._getSelectionBorderAtoms();

        if (atoms.length < 1 || atoms.length > 2) {
          logger.error('Can only edit fragments with one or two bound atoms.');
          return false;
        }

        this._fragmentBoundAtoms = atoms;
        var selectionMask = 1 << visual.getSelectionBit();
        visual.disableSubset(selectionMask, true);

        for (var k = 0; k < selection.children.length; ++k) {
          selection.children[k].visible = false;
        }

        var pivotPos = atoms[0].position.clone();

        if (atoms.length === 2) {
          pivotPos.lerp(atoms[1].position, 0.5);
        }

        this._fragmentGeo = new THREE__namespace.Group();
        visual.add(this._fragmentGeo);

        this._fragmentGeo.position.copy(pivotPos);

        this._fragmentSelectionGeo = new THREE__namespace.Group();
        selection.add(this._fragmentSelectionGeo);

        this._fragmentSelectionGeo.position.copy(pivotPos);

        var offset = pivotPos.clone();
        offset.negate();

        for (var i = 0; i < visual.children.length; ++i) {
          var g = visual.children[i];

          if (!('getSubset' in g)) {
            continue;
          }

          var vg = new THREE__namespace.Group();

          this._fragmentGeo.add(vg);

          var sg = new THREE__namespace.Group();

          this._fragmentSelectionGeo.add(sg);

          var meshes = g.getSubset(selectionMask, true);

          for (var j = 0; j < meshes.length; j++) {
            var m = meshes[j];
            vg.add(m);
            m.position.copy(offset);
          }

          var smeshes = g.getSubset(selectionMask, true);

          for (var h = 0; h < smeshes.length; h++) {
            var sm = smeshes[h];
            sg.add(sm);
            sm.position.copy(offset);
          }
        }

        gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);
        this._inProgress = true;
        return true;
      }
    }, {
      key: "apply",
      value: function apply() {
        if (!this._inProgress) {
          return;
        }

        var visual = this._complexVisual;
        var selectionBit = visual.getSelectionBit();
        var p = this._fragmentGeo.position;

        var m = this._fragmentGeo.matrix.clone();

        m.multiply(new THREE__namespace.Matrix4().makeTranslation(-p.x, -p.y, -p.z));

        this._bakeAtomTransform(m, 1 << selectionBit);

        visual.enableSubset(1 << selectionBit, true);
        visual.getComplex().onAtomPositionChanged();
        visual.finalizeEdit();
      }
    }, {
      key: "discard",
      value: function discard() {
        if (!this._inProgress) {
          return;
        }

        var visual = this._complexVisual;

        var selection = this._complexVisual.getSelectionGeo();

        this._fragmentGeo.parent.remove(this._fragmentGeo);

        visual.enableSubset(1 << visual.getSelectionBit(), true);

        for (var i = 0; i < selection.children.length; ++i) {
          var node = selection.children[i];

          if (node.visible) {
            selection.remove(node);
          } else {
            node.visible = true;
          }
        }

        visual.finalizeEdit();
      }
    }, {
      key: "isFreeRotationAllowed",
      value: function isFreeRotationAllowed() {
        return this._fragmentBoundAtoms.length < 2;
      }
    }, {
      key: "getAltObj",
      value: function getAltObj() {
        var res = {
          objects: [],
          pivot: new THREE__namespace.Vector3(0, 0, 0)
        };
        res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
        var boundAtoms = this._fragmentBoundAtoms;

        if (boundAtoms.length === 1) {
          if (boundAtoms[0].bonds.length === 1) {
            var bond = boundAtoms[0].bonds[0];
            res.axis = new THREE__namespace.Vector3().subVectors(bond._right.position, bond._left.position);
            res.axis.normalize();
            res.axis.transformDirection(this._complexVisual.matrixWorld);
          }
        } else if (boundAtoms.length === 2) {
          res.axis = new THREE__namespace.Vector3().subVectors(boundAtoms[1].position, boundAtoms[0].position);
          res.axis.normalize();
          res.axis.transformDirection(this._complexVisual.matrixWorld);
        }

        return res;
      }
    }, {
      key: "_getSelectionBorderAtoms",
      value: function _getSelectionBorderAtoms() {
        var complex = this._complexVisual.getComplex();

        var selectionMask = 1 << this._complexVisual.getSelectionBit();

        var atomHash = {};
        complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              atomHash[bond._left.index] = 1;
            }
          } else if (bond._right.mask & selectionMask) {
            atomHash[bond._right.index] = 1;
          }
        });
        var atoms = [];
        var keys = Object.keys(atomHash);

        for (var i = 0, n = keys.length; i < n; ++i) {
          var idx = keys[i];
          atoms.push(complex._atoms[idx]);
        }

        return atoms;
      }
    }, {
      key: "_bakeAtomTransform",
      value: function _bakeAtomTransform(matrix, mask) {
        this._complexVisual.getComplex().forEachAtom(function (atom) {
          if (atom.mask & mask) {
            atom.position.applyMatrix4(matrix);
          }
        });
      }
    }]);

    return ComplexFragmentEditor;
  }(ComplexEditor);

  var ComplexVisualEdit = {
    ComponentEditor: ComplexComponentEditor,
    FragmentEditor: ComplexFragmentEditor
  };

  function _createSuper$y(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$y(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$y() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var selectors$2 = chem.selectors;

  function lookupAndCreate(entityList, specs) {
    if (!Array.isArray(specs)) {
      specs = [specs];
    }

    var _specs = specs,
        _specs2 = _slicedToArray(_specs, 2),
        id = _specs2[0],
        opts = _specs2[1];

    var Entity = entityList.get(id) || entityList.first;
    return new Entity(opts);
  }

  var ComplexVisual = /*#__PURE__*/function (_Visual) {
    _inherits(ComplexVisual, _Visual);

    var _super = _createSuper$y(ComplexVisual);

    function ComplexVisual(name, dataSource) {
      var _this;

      _classCallCheck(this, ComplexVisual);

      _this = _super.call(this, name, dataSource);
      _this._complex = dataSource;
      _this._reprList = [];
      _this._repr = null;
      _this._reprListChanged = true;
      _this._selectionBit = 0;
      _this._reprUsedBits = 0;
      _this._selectionCount = 0;
      _this._selectionGeometry = new THREE__namespace.Group();
      return _this;
    }

    _createClass(ComplexVisual, [{
      key: "getBoundaries",
      value: function getBoundaries() {
        return this._complex.getBoundaries();
      }
    }, {
      key: "release",
      value: function release() {
        if (this._selectionGeometry.parent) {
          this._selectionGeometry.remove(this._selectionGeometry);
        }

        Visual.prototype.release.call(this);
      }
    }, {
      key: "getComplex",
      value: function getComplex() {
        return this._complex;
      }
    }, {
      key: "getSelectionCount",
      value: function getSelectionCount() {
        return this._selectionCount;
      }
    }, {
      key: "getSelectionGeo",
      value: function getSelectionGeo() {
        return this._selectionGeometry;
      }
    }, {
      key: "getSelectionBit",
      value: function getSelectionBit() {
        return this._selectionBit;
      }
    }, {
      key: "getEditor",
      value: function getEditor() {
        return this._editor;
      }
    }, {
      key: "resetReps",
      value: function resetReps(reps) {
        if (this._complex) {
          this._complex.clearAtomBits(~0);
        }

        this._reprListChanged = true;
        this._reprUsedBits = 0;
        this._reprList.length = reps.length;

        for (var i = 0, n = reps.length; i < n; ++i) {
          var rep = reps[i];
          var selector = void 0;
          var selectorString = void 0;

          if (typeof rep.selector === 'string') {
            selectorString = rep.selector;

            var _selectors$parse = selectors$2.parse(selectorString);

            selector = _selectors$parse.selector;
          } else if (typeof rep.selector === 'undefined') {
            selectorString = settings$1.now.presets.default[0].selector;

            var _selectors$parse2 = selectors$2.parse(selectorString);

            selector = _selectors$parse2.selector;
          } else {
            selector = rep.selector;
            selectorString = selector.toString();
          }

          var mode = lookupAndCreate(modes$1, rep.mode);
          var colorer = lookupAndCreate(colorers$1, rep.colorer);
          var material = materials$1.get(rep.material) || materials$1.first;
          this._reprList[i] = new Representation(i, mode, colorer, selector);

          this._reprList[i].setMaterialPreset(material);

          this._reprList[i].selectorString = selectorString;

          if (this._complex) {
            this._complex.markAtoms(selector, 1 << i);
          }

          this._reprUsedBits |= 1 << i;
        }

        this._repr = reps.length > 0 ? this._reprList[0] : null;
        this._selectionBit = reps.length;
        this._reprUsedBits |= 1 << this._selectionBit;
        this._selectionCount = 0;

        if (this._complex) {
          this._complex.update();
        }
      }
    }, {
      key: "repCount",
      value: function repCount() {
        return this._reprList.length;
      }
    }, {
      key: "repCurrent",
      value: function repCurrent(index) {
        if (index >= 0 && index < this._reprList.length) {
          this._repr = this._reprList[index];
        } else {
          index = this._reprList.indexOf(this._repr);
        }

        return index;
      }
    }, {
      key: "rep",
      value: function rep(index, _rep) {
        if (!_rep && (index === undefined || index instanceof Object)) {
          _rep = index;
          index = this.repCurrent();
        }

        if (index < 0 || index > this._reprList.length) {
          logger.error("Rep ".concat(index, " does not exist!"));
          return null;
        }

        if (index === this._reprList.length) {
          var res = this.repAdd(_rep);
          logger.warn("Rep ".concat(index, " does not exist! New representation was created."));
          return {
            desc: res.desc,
            index: index,
            status: 'created'
          };
        }

        var target = this._reprList[index];
        var desc = {
          selector: target.selectorString,
          mode: target.mode.identify(),
          colorer: target.colorer.identify(),
          material: target.materialPreset.id
        };

        if (_rep) {
          var diff = target.change(_rep, this._complex, lookupAndCreate(modes$1, _rep.mode), lookupAndCreate(colorers$1, _rep.colorer));

          if (!___default["default"].isEmpty(diff)) {
            target.needsRebuild = true;

            for (var key in diff) {
              if (diff.hasOwnProperty(key)) {
                desc[key] = diff[key];
                logger.debug("rep[".concat(index, "].").concat(key, " changed to ").concat(diff[key]));
              }
            }

            if (diff.mode && target.mode.isSurface && (settings$1.now.resolution === 'ultra' || settings$1.now.resolution === 'high')) {
              logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
              settings$1.set('resolution', 'medium');
            }

            return {
              desc: desc,
              index: index,
              status: 'changed'
            };
          }
        }

        return {
          desc: desc,
          index: index,
          status: ''
        };
      }
    }, {
      key: "repGet",
      value: function repGet(index) {
        if (index === undefined || index instanceof Object) {
          index = this.repCurrent();
        }

        if (index < 0 || index >= this._reprList.length) {
          return null;
        }

        return this._reprList[index];
      }
    }, {
      key: "_getFreeReprIdx",
      value: function _getFreeReprIdx() {
        var bits = this._reprUsedBits;

        for (var i = 0; i <= ComplexVisual.NUM_REPRESENTATION_BITS; ++i, bits >>= 1) {
          if ((bits & 1) === 0) {
            return i;
          }
        }

        return -1;
      }
    }, {
      key: "repAdd",
      value: function repAdd(rep) {
        if (this._reprList.length >= ComplexVisual.NUM_REPRESENTATION_BITS) {
          return null;
        }

        var newSelectionBit = this._getFreeReprIdx();

        if (newSelectionBit < 0) {
          return null;
        }

        var originalSelection = this.buildSelectorFromMask(1 << this._selectionBit);
        var def = settings$1.now.presets.default[0];

        var desc = ___default["default"].merge({
          selector: def.selector,
          mode: def.mode,
          colorer: def.colorer,
          material: def.material
        }, rep);

        var selector = typeof desc.selector === 'string' ? selectors$2.parse(desc.selector).selector : desc.selector;
        var target = new Representation(this._selectionBit, lookupAndCreate(modes$1, desc.mode), lookupAndCreate(colorers$1, desc.colorer), selector);
        target.selectorString = selector.toString();
        target.setMaterialPreset(materials$1.get(desc.material));
        target.markAtoms(this._complex);

        this._reprList.push(target);

        this._selectionBit = newSelectionBit;
        this._reprUsedBits |= 1 << this._selectionBit;

        this._complex.markAtoms(originalSelection, 1 << this._selectionBit);

        return {
          desc: desc,
          index: this._reprList.length - 1
        };
      }
    }, {
      key: "repRemove",
      value: function repRemove(index) {
        if (index === undefined) {
          index = this.repCurrent();
        }

        var count = this._reprList.length;

        if (index < 0 || index >= count || count <= 1) {
          return;
        }

        var target = this._reprList[index];
        target.unmarkAtoms(this._complex);
        this._reprUsedBits &= ~(1 << target.index);

        this._reprList.splice(index, 1);

        if (target === this._repr) {
          --count;
          index = index < count ? index : count - 1;
          this._repr = this._reprList[index];
        }

        this._reprListChanged = true;
      }
    }, {
      key: "repHide",
      value: function repHide(index, hide) {
        if (hide === undefined) {
          hide = true;
        }

        if (index < 0 || index >= this._reprList.length) {
          return;
        }

        var target = this._reprList[index];
        target.show(!hide);
      }
    }, {
      key: "select",
      value: function select(selector, append) {
        if (append) {
          this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
        } else {
          this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
        }

        this._complex.updateStructuresMask();

        this.rebuildSelectionGeometry();
      }
    }, {
      key: "resetSelectionMask",
      value: function resetSelectionMask() {
        if (this._selectionCount !== 0) {
          this._selectionCount = 0;

          if (this._complex) {
            this._complex.clearAtomBits(1 << this._selectionBit);
          }
        }
      }
    }, {
      key: "updateSelectionMask",
      value: function updateSelectionMask(pickedObj) {
        var self = this;
        var atom = pickedObj.atom;
        var residue = pickedObj.residue,
            chain = pickedObj.chain,
            molecule = pickedObj.molecule;
        var setMask = 1 << this._selectionBit;
        var clearMask = ~setMask;

        if (atom) {
          residue = atom.residue;
          chain = residue._chain;
          molecule = residue._molecule;

          if (atom.mask & setMask) {
            atom.mask &= clearMask;
            residue._mask &= clearMask;
            chain._mask &= clearMask;

            if (molecule) {
              molecule.mask &= clearMask;
            }

            this._selectionCount--;
          } else {
            atom.mask |= setMask;
            this._selectionCount++;
            residue.collectMask();
            chain.collectMask();

            if (molecule) {
              molecule.collectMask();
            }
          }
        } else if (residue) {
          chain = residue._chain;
          molecule = residue._molecule;

          if (residue._mask & setMask) {
            residue._mask &= clearMask;
            chain._mask &= clearMask;
            residue.forEachAtom(function (a) {
              if (a.mask & setMask) {
                a.mask &= clearMask;
                self._selectionCount--;
              }
            });
          } else {
            residue._mask |= setMask;
            residue.forEachAtom(function (a) {
              if (!(a.mask & setMask)) {
                a.mask |= setMask;
                self._selectionCount++;
              }
            });
            chain.collectMask();

            if (molecule) {
              molecule.collectMask();
            }
          }
        } else if (chain || molecule) {
          var obj = chain || molecule;

          if (obj._mask & setMask) {
            obj._mask &= clearMask;
            obj.forEachResidue(function (r) {
              if (r._mask & setMask) {
                r._mask &= clearMask;
                r.forEachAtom(function (a) {
                  if (a.mask & setMask) {
                    a.mask &= clearMask;
                    self._selectionCount--;
                  }
                });
                r._mask &= clearMask;
              }
            });
          } else {
            obj._mask |= setMask;
            obj.forEachResidue(function (r) {
              if (!(r._mask & setMask)) {
                r._mask |= setMask;
                r.forEachAtom(function (a) {
                  if (!(a.mask & setMask)) {
                    a.mask |= setMask;
                    self._selectionCount++;
                  }
                });
                var otherObj = chain ? r.getMolecule() : r.getChain();

                if (otherObj) {
                  otherObj.collectMask();
                }
              }
            });
          }
        } else {
          this.resetSelectionMask();
        }
      }
    }, {
      key: "expandSelection",
      value: function expandSelection() {
        var self = this;
        var selectionMask = 1 << this._selectionBit;
        var tmpMask = 1 << 31;

        this._complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              bond._right.mask |= tmpMask;
            }
          } else if (bond._right.mask & selectionMask) {
            bond._left.mask |= tmpMask;
          }
        });

        var deselectionMask = ~tmpMask;

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & tmpMask) {
            atom.mask = atom.mask & deselectionMask | selectionMask;
            ++self._selectionCount;
          }
        });

        this._complex.updateStructuresMask();
      }
    }, {
      key: "shrinkSelection",
      value: function shrinkSelection() {
        var self = this;
        var selectionMask = 1 << this._selectionBit;
        var tmpMask = 1 << 31;

        this._complex.forEachBond(function (bond) {
          if (bond._left.mask & selectionMask) {
            if ((bond._right.mask & selectionMask) === 0) {
              bond._left.mask |= tmpMask;
            }
          } else if (bond._right.mask & selectionMask) {
            bond._right.mask |= tmpMask;
          }
        });

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & selectionMask && atom.bonds.length === 1) {
            atom.mask |= tmpMask;
          }
        });

        var deselectionMask = ~(selectionMask | tmpMask);

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & tmpMask) {
            atom.mask &= deselectionMask;
            --self._selectionCount;
          }
        });

        this._complex.updateStructuresMask();
      }
    }, {
      key: "getSelectedComponent",
      value: function getSelectedComponent() {
        var selectionMask = 1 << this._selectionBit;
        var component = null;
        var multiple = false;

        this._complex.forEachAtom(function (atom) {
          if (atom.mask & selectionMask) {
            if (component === null) {
              component = atom.residue._component;
            } else if (component !== atom.residue._component) {
              multiple = true;
            }
          }
        });

        return multiple ? null : component;
      }
    }, {
      key: "getSelectionCenter",
      value: function getSelectionCenter(center, includesAtom, selRule) {
        center.set(0.0, 0.0, 0.0);
        var count = 0;

        this._complex.forEachAtom(function (atom) {
          if (includesAtom(atom, selRule)) {
            center.add(atom.position);
            count++;
          }
        });

        if (count === 0) {
          return false;
        }

        center.divideScalar(count);
        center.applyMatrix4(this.matrix);
        return true;
      }
    }, {
      key: "needsRebuild",
      value: function needsRebuild() {
        if (this._reprListChanged) {
          return true;
        }

        var reprList = this._reprList;

        for (var i = 0, n = reprList.length; i < n; ++i) {
          var repr = reprList[i];

          if (repr.needsRebuild) {
            return true;
          }
        }

        return false;
      }
    }, {
      key: "rebuild",
      value: function rebuild() {
        var self = this;
        gfxutils.clearTree(this);
        return new Promise(function (resolve) {
          var complex = self._complex;

          if (!complex) {
            resolve();
            return;
          }

          var errorOccured = false;
          setTimeout(function () {
            console.time('build');
            var reprList = self._reprList;
            var palette = palettes$1.get(settings$1.now.palette) || palettes$1.first;
            var hasGeometry = false;

            for (var i = 0, n = reprList.length; i < n; ++i) {
              var repr = reprList[i];
              repr.colorer.palette = palette;

              if (repr.needsRebuild) {
                repr.reset();

                try {
                  repr.buildGeometry(complex);
                } catch (e) {
                  if (e instanceof utils.OutOfMemoryError) {
                    repr.needsRebuild = false;
                    repr.reset();
                    logger.error("Not enough memory to build geometry for representation ".concat(repr.index + 1));
                    errorOccured = true;
                  } else {
                    throw e;
                  }
                }
              }

              hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);

              if (repr.geo) {
                self.add(repr.geo);
              }
            }

            self._reprListChanged = false;
            console.timeEnd('build');
            resolve();
          }, 10);
        });
      }
    }, {
      key: "setNeedsRebuild",
      value: function setNeedsRebuild() {
        var reprList = this._reprList;

        for (var i = 0, n = reprList.length; i < n; ++i) {
          reprList[i].needsRebuild = true;
        }
      }
    }, {
      key: "rebuildSelectionGeometry",
      value: function rebuildSelectionGeometry() {
        var mask = 1 << this._selectionBit;
        gfxutils.clearTree(this._selectionGeometry);

        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var repr = this._reprList[i];
          var sg = repr.buildSelectionGeometry(mask);

          if (!sg) {
            continue;
          }

          this._selectionGeometry.add(sg);

          for (var j = 0; j < sg.children.length; j++) {
            var m = sg.children[j];

            if (this._editor && this._editor._componentTransforms) {
              var t = this._editor._componentTransforms[m._component._index];

              if (t) {
                m.position.copy(t.position);
                m.quaternion.copy(t.quaternion);
              }
            }
          }

          gfxutils.applySelectionMaterial(sg);
        }
      }
    }, {
      key: "_buildSelectorFromSortedLists",
      value: function _buildSelectorFromSortedLists(atoms, residues, chains) {
        var complex = this._complex;

        function optimizeList(list) {
          var result = [];
          var k = 0;
          var first = NaN;
          var last = NaN;

          for (var i = 0, n = list.length; i < n; ++i) {
            var value = list[i];

            if (value === last + 1) {
              last = value;
            } else {
              if (!Number.isNaN(first)) {
                result[k++] = new selectors$2.Range(first, last);
              }

              first = last = value;
            }
          }

          if (!Number.isNaN(first)) {
            result[k] = new selectors$2.Range(first, last);
          }

          return result;
        }

        var expression = null;

        if (chains.length === complex._chains.length) {
          expression = selectors$2.all();
        } else {
          var selector;

          if (chains.length > 0) {
            selector = selectors$2.chain(chains);
            expression = expression ? selectors$2.or(expression, selector) : selector;
          }

          if (Object.keys(residues).length > 0) {
            for (var ch in residues) {
              if (residues.hasOwnProperty(ch)) {
                selector = selectors$2.and(selectors$2.chain(ch), selectors$2.residx(optimizeList(residues[ch])));
                expression = expression ? selectors$2.or(expression, selector) : selector;
              }
            }
          }

          if (atoms.length > 0) {
            selector = selectors$2.serial(optimizeList(atoms));
            expression = expression ? selectors$2.or(expression, selector) : selector;
          }

          if (!expression) {
            expression = selectors$2.none();
          }
        }

        return expression;
      }
    }, {
      key: "buildSelectorFromMask",
      value: function buildSelectorFromMask(mask) {
        var complex = this._complex;
        var chains = [];
        var residues = {};
        var atoms = [];
        complex.forEachChain(function (chain) {
          if (chain._mask & mask) {
            chains.push(chain._name);
          }
        });
        complex.forEachResidue(function (residue) {
          if (residue._mask & mask && !(residue._chain._mask & mask)) {
            var c = residue._chain._name;

            if (!(c in residues)) {
              residues[c] = [residue._index];
            } else {
              residues[c].push(residue._index);
            }
          }
        });
        complex.forEachAtom(function (atom) {
          if (atom.mask & mask && !(atom.residue._mask & mask)) {
            atoms.push(atom.serial);
          }
        });
        return this._buildSelectorFromSortedLists(atoms, residues, chains);
      }
    }, {
      key: "forSelectedResidues",
      value: function forSelectedResidues(process) {
        var selectionMask = 1 << this._selectionBit;

        this._complex.forEachResidue(function (residue) {
          if (residue._mask & selectionMask) {
            process(residue);
          }
        });
      }
    }, {
      key: "beginComponentEdit",
      value: function beginComponentEdit() {
        if (this._editor) {
          return null;
        }

        var editor = new ComplexVisualEdit.ComponentEditor(this);

        if (!editor.begin()) {
          return null;
        }

        this._editor = editor;
        return editor;
      }
    }, {
      key: "beginFragmentEdit",
      value: function beginFragmentEdit() {
        if (this._editor) {
          return null;
        }

        var editor = new ComplexVisualEdit.FragmentEditor(this);

        if (!editor.begin()) {
          return null;
        }

        this._editor = editor;
        return editor;
      }
    }, {
      key: "finalizeEdit",
      value: function finalizeEdit() {
        this._editor = null;
      }
    }, {
      key: "setMaterialValues",
      value: function setMaterialValues(values) {
        var needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var rep = this._reprList[i];
          rep.material.setValues(values);

          if (needTraverse) {
            rep.geo.traverse(function (object) {
              if (object instanceof THREE__namespace.Mesh) {
                object.material.setValues(values);

                if (process !== undefined) {
                  process(object);
                }

                object.material.needsUpdate = true;
              }
            });
          }
        }
      }
    }, {
      key: "setUberOptions",
      value: function setUberOptions(values) {
        for (var i = 0, n = this._reprList.length; i < n; ++i) {
          var rep = this._reprList[i];
          rep.material.setUberOptions(values);
        }
      }
    }, {
      key: "within",
      value: function within(selector, radius) {
        var vw = this._complex.getVoxelWorld();

        if (vw === null) {
          return false;
        }

        var selectionMask = 1 << this._selectionBit;

        this._complex.markAtoms(selector, selectionMask);

        if (vw) {
          vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), function (atom) {
            atom.mask |= selectionMask;
          });
        }

        this._selectionCount = this._complex.countAtomsByMask(selectionMask);

        this._complex.updateStructuresMask();

        return this.buildSelectorFromMask(selectionMask);
      }
    }]);

    return ComplexVisual;
  }(Visual);

  ComplexVisual.NUM_REPRESENTATION_BITS = 30;

  var vertexVolumeFaces = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  pos = position.xyz + 0.5;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

  var fragmentVolumeFaces = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(pos, 0.5);\r\n}";

  var vertexVolume = "varying vec4 screenSpacePos;\r\n\r\nvoid main() {\r\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = screenSpacePos;\r\n}";

  var fragmentVolume = "uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r\n\r\nuniform vec3 _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\n#define NO_COLOR vec4(0., 0., 0., 0.)\r\n\r\nvec4 sample3DTexture(vec3 texCoord) {\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r\n  vec3 textCoord = boxCoord;\r\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r\n\r\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r\n    return NO_COLOR;\r\n\r\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r\n\r\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r\n    return NO_COLOR;\r\n\r\n  return sample3DTexture(textCoord);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir) {\r\n  float d = 1. / 128.;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n\r\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r\n  vec3 coordInc = mix(\r\n    vec3(\r\n      sample3DTextureInclined(iter + dx).x,\r\n      sample3DTextureInclined(iter + dy).x,\r\n      sample3DTextureInclined(iter + dz).x\r\n    ),\r\n    vec3(0. ,0. , 0.),\r\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r\n  );\r\n\r\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r\n  vec3 coordDec = mix(\r\n    vec3(0. ,0. , 0.),\r\n    vec3(\r\n      sample3DTextureInclined(iter - dx).x,\r\n      sample3DTextureInclined(iter - dy).x,\r\n      sample3DTextureInclined(iter - dz).x\r\n    ),\r\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r\n  );\r\n\r\n  vec3 N = normalize(coordInc - coordDec);\r\n  float dif = max(0.0, dot(N, dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r\n  for (int i = 0; i < 5; i++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\r\n  for (int j = 0; j < 5; j++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r\n  vec3 step = stepSize * dir, iterator = start, left, right;\r\n  vec4 acc = NO_COLOR;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    iterator = iterator + step;\r\n    vol = sample3DTextureInclined(iterator).r;\r\n    if (length(iterator - back) <= stepSize || (vol > tr))\r\n      break;\r\n  }\r\n\r\n  if (vol > tr)\r\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r\n\r\n  return acc;\r\n}\r\n\r\nfloat easeOut(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return 1.0 - (1.0 - t) * (1.0 - t);\r\n}\r\n\r\nfloat easeIn(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return t * t;\r\n}\r\n\r\nvec3 GetColSimple(float vol) {\r\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 acc = NO_COLOR, iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r\n  vec3 step, col, colOld, right;\r\n  float tr0 = _isoLevel0.x;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n\r\n  for (int k = 0; k < 3; k++) {\r\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r\n    kd = 140. * tr0 * stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize * dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r\n      break;\r\n    iterator = iso.xyz;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetColSimple(tr0);\r\n    curStepSize = stepSize;\r\n    for (int i = 0; i < STEPS_COUNT; i++) {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTextureInclined(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetColSimple(vol);\r\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r\n      vec3 colMid = GetColSimple(vol);\r\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n\r\n    if (molD > molDist) {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist) * dir;\r\n      vol = sample3DTextureInclined(right).r;\r\n    } else {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n\r\n    alpha = (1. - r) * curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetColSimple(vol);\r\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r\n    vec3 colMid = GetColSimple(vol);\r\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1. * sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  float stepSize = 1.0 / float(STEPS_COUNT);\r\n  float len = length(back - start);\r\n  vec3 step = stepSize * dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    if (float(i) * stepSize > len)\r\n      break;\r\n    iterator = iterator + step;\r\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r\n  }\r\n\r\n  return vec4(1.,1.,1., acc);\r\n}\r\n\r\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r\n  vec4 col = NO_COLOR;\r\n\r\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r\n    float dif =  CalcColor(tst.xyz, dir);\r\n    dif = 0.9 * dif * dif;\r\n    col = vec4(dif, dif, dif, 1);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main() {\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0) {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  } else {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001) {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  #ifdef ISO_MODE\r\n    gl_FragColor = IsoRender(start, back, molDist, dir);\r\n  #else\r\n    gl_FragColor = VolRender(start, back, molDist, dir);\r\n  #endif\r\n}\r\n";

  var vertexFarPlane = "varying vec4 volPos;\r\nuniform float aspectRatio;\r\nuniform float farZ;\r\nuniform float tanHalfFOV;\r\nuniform mat4  matWorld2Volume;\r\n\r\nvoid main() {\r\n  // rescale plane to fill in the whole far plane area seen from camera\r\n  vec3 pos = position.xyz;\r\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r\n  pos.y = pos.y * tanHalfFOV * farZ;\r\n  // common transformation\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  // calc pos in volume CS\r\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  volPos = volPos + 0.5;\r\n  volPos.w = 0.5;\r\n}\r\n";

  var fragmentFarPlane = "varying vec4 volPos;\r\n\r\nvoid main() {\r\n  gl_FragColor = volPos;\r\n}";

  function _createSuper$x(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$x(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$x() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var volumeUniforms = THREE__namespace.UniformsUtils.merge([{
    volumeDim: {
      type: 'v3',
      value: new THREE__namespace.Vector3(512, 512, 512)
    },
    tileTex: {
      type: 't',
      value: null
    },
    tileTexSize: {
      type: 'v2',
      value: new THREE__namespace.Vector2(512, 512)
    },
    tileStride: {
      type: 'v2',
      value: new THREE__namespace.Vector2(512, 512)
    },
    boxAngles: {
      type: 'v3',
      value: new THREE__namespace.Vector3(1, 1, 1)
    },
    delta: {
      type: 'v3',
      value: new THREE__namespace.Vector3(0, 0, 0)
    },
    _isoLevel0: {
      type: 'v2',
      value: new THREE__namespace.Vector3(0.5, 0.75, 1.0)
    },
    _flipV: {
      type: 'f',
      value: 0.0
    },
    _BFLeft: {
      type: 't',
      value: null
    },
    _BFRight: {
      type: 't',
      value: null
    },
    _FFLeft: {
      type: 't',
      value: null
    },
    _FFRight: {
      type: 't',
      value: null
    },
    _WFFLeft: {
      type: 't',
      value: null
    },
    _WFFRight: {
      type: 't',
      value: null
    }
  }]);

  function overrideUniforms(params, defUniforms) {
    var uniforms = THREE__namespace.UniformsUtils.clone(defUniforms);

    for (var p in params) {
      if (uniforms.hasOwnProperty(p)) {
        uniforms[p].value = params[p];
      }
    }

    return uniforms;
  }

  function facesPosMaterialParams(params, sideType) {
    return {
      uniforms: overrideUniforms(params, {}),
      vertexShader: vertexVolumeFaces,
      fragmentShader: fragmentVolumeFaces,
      transparent: false,
      depthTest: false,
      depthWrite: false,
      side: sideType
    };
  }

  var BackFacePosMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial) {
    _inherits(BackFacePosMaterial, _THREE$ShaderMaterial);

    var _super = _createSuper$x(BackFacePosMaterial);

    function BackFacePosMaterial(params) {
      _classCallCheck(this, BackFacePosMaterial);

      var backFaceParams = facesPosMaterialParams(params, THREE__namespace.BackSide);
      return _super.call(this, backFaceParams);
    }

    return BackFacePosMaterial;
  }(THREE__namespace.ShaderMaterial);

  var ShaderParams = function ShaderParams(params, uniforms, vertexShader, fragmentShader) {
    _classCallCheck(this, ShaderParams);

    this.uniforms = overrideUniforms(params, uniforms);
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.transparent = false;
    this.depthTest = false;
    this.depthWrite = false;
    this.side = THREE__namespace.FrontSide;
  };

  var BackFacePosMaterialFarPlane = /*#__PURE__*/function (_THREE$ShaderMaterial2) {
    _inherits(BackFacePosMaterialFarPlane, _THREE$ShaderMaterial2);

    var _super2 = _createSuper$x(BackFacePosMaterialFarPlane);

    function BackFacePosMaterialFarPlane(params) {
      _classCallCheck(this, BackFacePosMaterialFarPlane);

      var matUniforms = THREE__namespace.UniformsUtils.merge([{
        aspectRatio: {
          type: 'f',
          value: 0.0
        },
        farZ: {
          type: 'f',
          value: 0.0
        },
        tanHalfFOV: {
          type: 'f',
          value: 0.0
        },
        matWorld2Volume: {
          type: '4fv',
          value: new THREE__namespace.Matrix4()
        }
      }]);
      var shaderParams = new ShaderParams(params, matUniforms, vertexFarPlane, fragmentFarPlane);
      return _super2.call(this, shaderParams);
    }

    return BackFacePosMaterialFarPlane;
  }(THREE__namespace.ShaderMaterial);

  var FrontFacePosMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial3) {
    _inherits(FrontFacePosMaterial, _THREE$ShaderMaterial3);

    var _super3 = _createSuper$x(FrontFacePosMaterial);

    function FrontFacePosMaterial(params) {
      _classCallCheck(this, FrontFacePosMaterial);

      var frontFaceParams = facesPosMaterialParams(params, THREE__namespace.FrontSide);
      return _super3.call(this, frontFaceParams);
    }

    return FrontFacePosMaterial;
  }(THREE__namespace.ShaderMaterial);

  var VolumeMaterial = /*#__PURE__*/function (_THREE$ShaderMaterial4) {
    _inherits(VolumeMaterial, _THREE$ShaderMaterial4);

    var _super4 = _createSuper$x(VolumeMaterial);

    function VolumeMaterial(params) {
      var _this;

      _classCallCheck(this, VolumeMaterial);

      var shaderParams = new ShaderParams(params, volumeUniforms, vertexVolume, fragmentVolume);
      shaderParams.transparent = true;
      shaderParams.depthTest = true;
      _this = _super4.call(this, shaderParams);

      _this.updateDefines();

      return _this;
    }

    _createClass(VolumeMaterial, [{
      key: "updateDefines",
      value: function updateDefines() {
        this.defines = {
          ISO_MODE: settings$1.now.modes.VD.isoMode,
          STEPS_COUNT: settings$1.now.modes.VD.polyComplexity[settings$1.now.resolution] * 100
        };
        this.needsUpdate = true;
      }
    }]);

    return VolumeMaterial;
  }(THREE__namespace.ShaderMaterial);

  var VolumeMaterial$1 = {
    BackFacePosMaterial: BackFacePosMaterial,
    BackFacePosMaterialFarPlane: BackFacePosMaterialFarPlane,
    FrontFacePosMaterial: FrontFacePosMaterial,
    VolumeMaterial: VolumeMaterial
  };

  function _createSuper$w(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$w(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$w() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeMesh = /*#__PURE__*/function (_THREE$Mesh) {
    _inherits(VolumeMesh, _THREE$Mesh);

    var _super = _createSuper$w(VolumeMesh);

    function VolumeMesh() {
      var _this;

      _classCallCheck(this, VolumeMesh);

      var geo = new THREE__namespace.BufferGeometry();
      _this = _super.call(this, geo);

      _defineProperty(_assertThisInitialized(_this), "volumeInfo", {});

      _this.clipPlane = new THREE__namespace.Plane();
      var size = new THREE__namespace.Vector3(0.5, 0.5, 0.5);
      _this.size = size;
      _this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];
      _this.faces = [{
        indices: [],
        norm: new THREE__namespace.Vector3(0, 0, -1)
      }, {
        indices: [],
        norm: new THREE__namespace.Vector3(0, 0, 1)
      }, {
        indices: [],
        norm: new THREE__namespace.Vector3(0, -1, 0)
      }, {
        indices: [],
        norm: new THREE__namespace.Vector3(0, 1, 0)
      }, {
        indices: [],
        norm: new THREE__namespace.Vector3(-1, 0, 0)
      }, {
        indices: [],
        norm: new THREE__namespace.Vector3(1, 0, 0)
      }, {
        indices: [],
        norm: new THREE__namespace.Vector3(0, 0, 0)
      }];
      _this.vertices = [new THREE__namespace.Vector3(-size.x, -size.y, -size.z), new THREE__namespace.Vector3(-size.x, size.y, -size.z), new THREE__namespace.Vector3(size.x, -size.y, -size.z), new THREE__namespace.Vector3(size.x, size.y, -size.z), new THREE__namespace.Vector3(-size.x, -size.y, size.z), new THREE__namespace.Vector3(-size.x, size.y, size.z), new THREE__namespace.Vector3(size.x, -size.y, size.z), new THREE__namespace.Vector3(size.x, size.y, size.z), new THREE__namespace.Vector3(0.0, 0.0, 0.0), new THREE__namespace.Vector3(0.0, 0.0, 0.0), new THREE__namespace.Vector3(0.0, 0.0, 0.0), new THREE__namespace.Vector3(0.0, 0.0, 0.0), new THREE__namespace.Vector3(0.0, 0.0, 0.0), new THREE__namespace.Vector3(0.0, 0.0, 0.0)];
      geo.setAttribute('position', new THREE__namespace.BufferAttribute(new Float32Array(_this.vertices.length * 3), 3));
      _this.name = 'VolumeMesh';
      return _this;
    }

    _createClass(VolumeMesh, [{
      key: "_updateVertices",
      value: function _updateVertices() {
        var corners = VolumeMesh._corners;
        var edges = VolumeMesh._edges;
        var edgeIntersections = VolumeMesh._edgeIntersections;
        var i;
        var norm = this.clipPlane.normal;
        var D = this.clipPlane.constant;
        var vert = this.vertices;
        var size = this.size;
        var cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
        var edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
        var curEdge = new THREE__namespace.Vector3();
        var curEdgeInter = null;

        function CheckX() {
          if (norm.x === 0) return 0;
          var x = -(norm.dot(curEdge) + D) / norm.x;

          if (-size.x <= x && x <= size.x) {
            curEdgeInter.set(x, curEdge.y, curEdge.z);
            if (x === size.x) return 2;
            if (x === -size.x) return -2;
            return 1;
          }

          return 0;
        }

        function CheckY() {
          if (norm.y === 0) return 0;
          var y = -(norm.dot(curEdge) + D) / norm.y;

          if (-size.y <= y && y <= size.y) {
            curEdgeInter.set(curEdge.x, y, curEdge.z);
            if (y === size.y) return 2;
            if (y === -size.y) return -2;
            return 1;
          }

          return 0;
        }

        function CheckZ() {
          if (norm.z === 0) return 0;
          var z = -(norm.dot(curEdge) + D) / norm.z;

          if (-size.z <= z && z <= size.z) {
            curEdgeInter.set(curEdge.x, curEdge.y, z);
            if (z === size.z) return 2;
            if (z === -size.z) return -2;
            return 1;
          }

          return 0;
        }

        for (var curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
          var curEdgeSource = edges[curEdgeIdx];
          curEdgeInter = edgeIntersections[curEdgeIdx];
          curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
          curEdge.multiply(size);
          var flag = 0;
          if (curEdgeSource[2] === 0) flag = CheckX();
          if (curEdgeSource[3] === 0) flag = CheckY();
          if (curEdgeSource[4] === 0) flag = CheckZ();

          if (flag === -2) {
            cornerMark[curEdgeSource[0]] = 1;
          } else if (flag === 2) {
            cornerMark[curEdgeSource[1]] = 1;
          } else if (flag === 0) {
            edgeMark[curEdgeIdx] = 0;
          }
        }

        var face = {
          indices: [],
          norm: norm.clone().negate()
        };
        var nextVertex = 8;

        for (i = 0; i < 8; ++i) {
          if (cornerMark[i] === 1) {
            vert[nextVertex].set(corners[i][0], corners[i][1], corners[i][2]).multiply(size);
            face.indices.push(nextVertex++);
            edgeMark[corners[i][3]] = 0;
            edgeMark[corners[i][4]] = 0;
            edgeMark[corners[i][5]] = 0;
          }
        }

        for (i = 0; i < 12; ++i) {
          if (edgeMark[i] === 1) {
            vert[nextVertex].copy(edgeIntersections[i]);
            face.indices.push(nextVertex++);
          }
        }

        this.faces[6] = face;
        var diff = new THREE__namespace.Vector3();
        var coplanarPoint = new THREE__namespace.Vector3();
        this.clipPlane.coplanarPoint(coplanarPoint);

        for (i = 0; i < vert.length; ++i) {
          this.cullFlag[i] = false;

          if (i < 8) {
            diff.subVectors(vert[i], coplanarPoint);
            this.cullFlag[i] = norm.dot(diff) >= 0.0;
          } else if (i < 8 + face.indices.length) {
            this.cullFlag[i] = true;
          }
        }

        var positions = this.geometry.getAttribute('position');
        var idx = 0;

        for (i = 0; i < vert.length; ++i) {
          positions.array[idx++] = vert[i].x;
          positions.array[idx++] = vert[i].y;
          positions.array[idx++] = vert[i].z;
        }

        positions.needsUpdate = true;
      }
    }, {
      key: "_collectVertices",
      value: function _collectVertices(face, filter) {
        var i;
        var vert = this.vertices;
        face.indices = [];

        for (i = 0; i < vert.length; ++i) {
          if (this.cullFlag[i] && filter(vert[i])) {
            face.indices.push(i);
          }
        }
      }
    }, {
      key: "_sortIndices",
      value: function _sortIndices(face, right) {
        var i;
        var j;
        var vert = this.vertices;
        var angle = [];
        var dir = new THREE__namespace.Vector3();

        for (i = 1; i < face.indices.length; ++i) {
          dir.subVectors(vert[face.indices[i]], vert[face.indices[0]]);
          dir.normalize();
          dir.cross(right);
          dir.negate();
          angle[i] = face.norm.dot(dir);
        }

        for (i = 1; i < face.indices.length - 1; ++i) {
          for (j = i + 1; j < face.indices.length; ++j) {
            if (angle[j] < angle[i]) {
              var t = angle[i];
              angle[i] = angle[j];
              angle[j] = t;
              t = face.indices[i];
              face.indices[i] = face.indices[j];
              face.indices[j] = t;
            }
          }
        }
      }
    }, {
      key: "_updateIndices",
      value: function _updateIndices() {
        var i;
        var faceIdx;
        var face;
        var vert = this.vertices;
        var size = this.size;

        this._collectVertices(this.faces[0], function (vertex) {
          return vertex.z === -size.z;
        });

        this._collectVertices(this.faces[1], function (vertex) {
          return vertex.z === size.z;
        });

        this._collectVertices(this.faces[2], function (vertex) {
          return vertex.y === -size.y;
        });

        this._collectVertices(this.faces[3], function (vertex) {
          return vertex.y === size.y;
        });

        this._collectVertices(this.faces[4], function (vertex) {
          return vertex.x === -size.x;
        });

        this._collectVertices(this.faces[5], function (vertex) {
          return vertex.x === size.x;
        });

        var vCenter = new THREE__namespace.Vector3();
        var vRight = new THREE__namespace.Vector3();
        var vDir = new THREE__namespace.Vector3();

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];
          if (face.indices.length === 0) continue;
          vCenter.set(0, 0, 0);

          for (i = 0; i < face.indices.length; ++i) {
            vCenter.add(vert[face.indices[i]]);
          }

          vCenter.multiplyScalar(1.0 / face.indices.length);
          vRight.subVectors(vert[face.indices[0]], vCenter);
          vRight.normalize();
          var rightProj = [];

          for (i = 0; i < face.indices.length; ++i) {
            vDir.subVectors(vert[face.indices[i]], vCenter);
            rightProj[i] = vDir.dot(vRight);
          }

          for (i = 1; i < face.indices.length; ++i) {
            if (rightProj[i] < rightProj[0]) {
              var t = rightProj[0];
              rightProj[0] = rightProj[i];
              rightProj[i] = t;

              var _face$indices = _slicedToArray(face.indices, 1);

              t = _face$indices[0];
              face.indices[0] = face.indices[i];
              face.indices[i] = t;
            }
          }

          this._sortIndices(face, vRight);
        }

        var numIndices = 0;

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];

          if (face.indices.length >= 3) {
            numIndices += 3 * (face.indices.length - 2);
          }
        }

        var offset = 0;
        var indices = new Uint16Array(numIndices);

        for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
          face = this.faces[faceIdx];

          for (i = 0; i < face.indices.length - 2; ++i) {
            indices[offset] = face.indices[0];
            indices[offset + 1] = face.indices[i + 1];
            indices[offset + 2] = face.indices[i + 2];
            offset += 3;
          }
        }

        this.geometry.setIndex(new THREE__namespace.BufferAttribute(indices, 1));
      }
    }, {
      key: "setDataSource",
      value: function setDataSource(dataSource) {
        var vm = new VolumeMaterial$1.VolumeMaterial();
        var dim = dataSource.getDimensions();
        var stride = dataSource.getTiledTextureStride();
        var texture = dataSource.buildTiledTexture();
        var bbox = dataSource.getBox();
        vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
        vm.uniforms.tileTex.value = texture;
        vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
        vm.uniforms.tileStride.value.set(stride[0], stride[1]);
        Object.assign(this.volumeInfo, dataSource.getVolumeInfo());
        var volInfo = this.volumeInfo;
        vm.uniforms.delta.value.copy(volInfo.delta);
        vm.uniforms.boxAngles.value.set(volInfo.obtuseAngle[0], volInfo.obtuseAngle[1], volInfo.obtuseAngle[2]);
        this.material = vm;
        bbox.getSize(this.scale);
        bbox.getCenter(this.position);
      }
    }, {
      key: "_updateIsoLevel",
      value: function _updateIsoLevel() {
        var _settings$now$modes$V = settings$1.now.modes.VD,
            kSigma = _settings$now$modes$V.kSigma,
            kSigmaMed = _settings$now$modes$V.kSigmaMed,
            kSigmaMax = _settings$now$modes$V.kSigmaMax;
        var volInfo = this.volumeInfo;
        var mean = volInfo.dmean - volInfo.dmin;
        var span = volInfo.dmax - volInfo.dmin;

        var level = function level(k) {
          return (mean + k * volInfo.sd) / span;
        };

        this.material.uniforms._isoLevel0.value.set(level(kSigma), level(kSigmaMed), level(kSigmaMax));
      }
    }, {
      key: "rebuild",
      value: function rebuild(camera) {
        var nearClipPlaneOffset = VolumeMesh._nearClipPlaneOffset;
        var pos = VolumeMesh._pos;
        var norm = VolumeMesh._norm;
        var norm4D = VolumeMesh._norm4D;
        var matrixWorldToLocal = VolumeMesh._matrixWorldToLocal;
        var clipPlane = VolumeMesh._clipPlane;

        this._updateIsoLevel();

        camera.getWorldDirection(norm);
        camera.getWorldPosition(pos);
        pos.addScaledVector(norm, camera.near + nearClipPlaneOffset);
        matrixWorldToLocal.copy(this.matrixWorld).invert();
        pos.applyMatrix4(matrixWorldToLocal);
        norm4D.set(norm.x, norm.y, norm.z, 0.0);
        norm4D.applyMatrix4(matrixWorldToLocal);
        norm.copy(norm4D);
        norm.normalize();
        clipPlane.setFromNormalAndCoplanarPoint(norm, pos);

        if (!this.clipPlane.equals(clipPlane)) {
          this.clipPlane = clipPlane.clone();

          this._updateVertices();

          this._updateIndices();
        }
      }
    }]);

    return VolumeMesh;
  }(THREE__namespace.Mesh);

  _defineProperty(VolumeMesh, "_corners", [[-1, -1, -1, 0, 4, 8], [1, -1, -1, 0, 5, 9], [1, 1, -1, 1, 5, 10], [-1, 1, -1, 1, 4, 11], [-1, -1, 1, 2, 6, 8], [1, -1, 1, 2, 7, 9], [1, 1, 1, 3, 7, 10], [-1, 1, 1, 3, 6, 11]]);

  _defineProperty(VolumeMesh, "_edges", [[0, 1, 0, -1, -1], [2, 3, 0, 1, -1], [4, 5, 0, -1, 1], [6, 7, 0, 1, 1], [0, 3, -1, 0, -1], [1, 2, 1, 0, -1], [4, 7, -1, 0, 1], [5, 6, 1, 0, 1], [0, 4, -1, -1, 0], [1, 5, 1, -1, 0], [2, 6, -1, 1, 0], [3, 7, 1, 1, 0]]);

  _defineProperty(VolumeMesh, "_edgeIntersections", function () {
    var edgeIntersections = [];

    for (var j = 0; j < 12; ++j) {
      edgeIntersections.push(new THREE__namespace.Vector3());
    }

    return edgeIntersections;
  }());

  _defineProperty(VolumeMesh, "_nearClipPlaneOffset", 0.2);

  _defineProperty(VolumeMesh, "_pos", new THREE__namespace.Vector3());

  _defineProperty(VolumeMesh, "_norm", new THREE__namespace.Vector3());

  _defineProperty(VolumeMesh, "_norm4D", new THREE__namespace.Vector4());

  _defineProperty(VolumeMesh, "_matrixWorldToLocal", new THREE__namespace.Matrix4());

  _defineProperty(VolumeMesh, "_clipPlane", new THREE__namespace.Plane());

  function _flattenArray(input) {
    var n = input.length;
    var output = new Float32Array(n * 3);

    for (var i = 0; i < n; ++i) {
      var j = 3 * i;
      var v = input[i];
      output[j] = v.x;
      output[j + 1] = v.y;
      output[j + 2] = v.z;
    }

    return output;
  }

  var VolumeBounds = /*#__PURE__*/function () {
    function VolumeBounds(bBox, volInfo) {
      _classCallCheck(this, VolumeBounds);

      var delta = volInfo.delta;
      var obtuseAngle = volInfo.obtuseAngle;
      var bSize = new THREE__namespace.Vector3();
      bBox.getSize(bSize);
      bSize.multiplyScalar(0.5);

      var offsetVert = this._getBaseVertices(delta, obtuseAngle);

      var geometry = new THREE__namespace.BufferGeometry();
      var vertices = [];

      for (var i = 0; i < 4; i++) {
        vertices.push(offsetVert[i].clone().multiply(bSize));
        vertices.push(offsetVert[(i + 1) % 4].clone().multiply(bSize));
      }

      var translation = new THREE__namespace.Vector3(2 * bSize.x * (1 - delta.x - delta.y), 0, 0);

      for (var _i = 0; _i < 8; _i++) {
        vertices.push(vertices[_i].clone().add(translation));
      }

      for (var _i2 = 0; _i2 < 4; _i2++) {
        vertices.push(vertices[_i2 * 2].clone());
        vertices.push(vertices[_i2 * 2 + 8].clone());
      }

      var center = new THREE__namespace.Vector3();
      bBox.getCenter(center);
      vertices.forEach(function (vertex) {
        return vertex.add(center);
      });

      var flatVertices = _flattenArray(vertices);

      geometry.setAttribute('position', new THREE__namespace.BufferAttribute(flatVertices, 3));
      this._lines = new THREE__namespace.LineSegments(geometry, new THREE__namespace.LineBasicMaterial({
        color: 0xffffff
      }));

      this._lines.layers.set(gfxutils.LAYERS.VOLUME);
    }

    _createClass(VolumeBounds, [{
      key: "_getBaseVertices",
      value: function _getBaseVertices(delta, obtuseAngle) {
        var projTable = VolumeBounds._projectionTable;

        var proj = function proj(index, inv) {
          var currDelta = delta[projTable[index][0]];
          var angleValue = -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]];
          return angleValue * currDelta;
        };

        var offsetVert = [new THREE__namespace.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', 1)), -1 + 2 * proj('YZ', 1), -1), new THREE__namespace.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', 1)), -1 + 2 * proj('YZ', -1), 1), new THREE__namespace.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', -1)), 1 - 2 * proj('YZ', 1), 1), new THREE__namespace.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', -1)), 1 - 2 * proj('YZ', -1), -1)];
        return offsetVert;
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._lines;
      }
    }]);

    return VolumeBounds;
  }();

  _defineProperty(VolumeBounds, "_projectionTable", {
    XY: ['x', 2],
    XZ: ['y', 1],
    YZ: ['z', 0]
  });

  var VolumeFarPlane = /*#__PURE__*/function () {
    function VolumeFarPlane(volume, width, height) {
      _classCallCheck(this, VolumeFarPlane);

      var planeGeo = this._initPlaneGeo(width, height);

      var mat = new VolumeMaterial$1.BackFacePosMaterialFarPlane();
      this._plane = new meshes.Mesh(planeGeo, mat);
      this._plane.frustumCulled = false;
      this._plane.doubleSided = true;
      var matWorldToVolume = new THREE__namespace.Matrix4();

      this._plane._onBeforeRender = function (_renderer, _scene, camera, _geometry, _material, _group) {
        var material = this.material;

        if (!volume || !material) {
          return;
        }

        var planeCamPos = new THREE__namespace.Vector4(0, 0, -(camera.far - 0.1), 1);
        planeCamPos.applyMatrix4(camera.matrixWorld);
        this.matrix.identity();
        this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
        this.matrixWorld.copy(this.matrix);
        this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
        this.normalMatrix.getNormalMatrix(this.modelViewMatrix);
        var volumeMatrix = volume.matrixWorld;
        matWorldToVolume.copy(volumeMatrix).invert();
        material.uniforms.aspectRatio.value = camera.aspect;
        material.uniforms.farZ.value = camera.far;
        material.uniforms.tanHalfFOV.value = Math.tan(THREE__namespace.MathUtils.DEG2RAD * 0.5 * camera.fov);
        material.uniforms.matWorld2Volume.value = matWorldToVolume;
      };

      this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
    }

    _createClass(VolumeFarPlane, [{
      key: "_initPlaneGeo",
      value: function _initPlaneGeo(width, height) {
        var planeGeo = new THREE__namespace.BufferGeometry();
        width = width || 1;
        height = height || 1;
        var vertices = new Float32Array([-0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0, -0.5 * width, -0.5 * height, 0, 0.5 * width, -0.5 * height, 0]);
        planeGeo.setAttribute('position', new THREE__namespace.BufferAttribute(vertices, 3));
        planeGeo.setIndex([0, 2, 1, 2, 3, 1]);
        return planeGeo;
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._plane;
      }
    }]);

    return VolumeFarPlane;
  }();

  function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var VolumeVisual = /*#__PURE__*/function (_Visual) {
    _inherits(VolumeVisual, _Visual);

    var _super = _createSuper$v(VolumeVisual);

    function VolumeVisual(name, dataSource) {
      var _this;

      _classCallCheck(this, VolumeVisual);

      _this = _super.call(this, name, dataSource);
      _this._mesh = new VolumeMesh();

      _this._mesh.setDataSource(dataSource);

      _this.add(_this._mesh);

      _this._frame = new VolumeBounds(_this.getBoundaries().boundingBox, _this._mesh.volumeInfo);

      _this.add(_this._frame.getMesh());

      _this.showFrame(settings$1.now.modes.VD.frame);

      _this._farPlane = new VolumeFarPlane(_this._mesh, 2, 2);

      _this.add(_this._farPlane.getMesh());

      return _this;
    }

    _createClass(VolumeVisual, [{
      key: "getBoundaries",
      value: function getBoundaries() {
        var box = this._dataSource.getBox();

        var sphere = new THREE__namespace.Sphere();
        box.getBoundingSphere(sphere);
        return {
          boundingBox: box,
          boundingSphere: sphere
        };
      }
    }, {
      key: "getMesh",
      value: function getMesh() {
        return this._mesh;
      }
    }, {
      key: "showFrame",
      value: function showFrame(needShow) {
        this._frame.getMesh().material.visible = needShow;
      }
    }]);

    return VolumeVisual;
  }(Visual);

  function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var LoaderList = /*#__PURE__*/function (_EntityList) {
    _inherits(LoaderList, _EntityList);

    var _super = _createSuper$u(LoaderList);

    function LoaderList() {
      var someLoaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, LoaderList);

      return _super.call(this, someLoaders, ['types']);
    }

    _createClass(LoaderList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.type) {
          list = this._dict.types[specs.type.toLowerCase()] || [];
        } else if (specs.source) {
          return this._list.filter(function (SomeLoader) {
            return SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source);
          });
        }

        return _toConsumableArray(list);
      }
    }]);

    return LoaderList;
  }(EntityList);

  function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var Loader = /*#__PURE__*/function (_EventDispatcher) {
    _inherits(Loader, _EventDispatcher);

    var _super = _createSuper$t(Loader);

    function Loader(source, options) {
      var _this;

      _classCallCheck(this, Loader);

      _this = _super.call(this);
      _this._source = source;
      _this._options = options || {};
      _this._abort = false;
      _this._agent = null;
      return _this;
    }

    _createClass(Loader, [{
      key: "load",
      value: function load() {
        return Promise.reject(new Error('Loading from this source is not implemented'));
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;

        if (this._agent) {
          this._agent.abort();
        }
      }
    }], [{
      key: "extractName",
      value: function extractName(_source) {
        return undefined;
      }
    }]);

    return Loader;
  }(EventDispatcher);
  makeContextDependent(Loader.prototype);

  function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FileLoader = /*#__PURE__*/function (_Loader) {
    _inherits(FileLoader, _Loader);

    var _super = _createSuper$s(FileLoader);

    function FileLoader(source, options) {
      var _this;

      _classCallCheck(this, FileLoader);

      _this = _super.call(this, source, options);
      options = _this._options;
      _this._binary = options.binary === true;
      return _this;
    }

    _createClass(FileLoader, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (_this2._abort) {
            throw new Error('Loading aborted');
          }

          var blob = _this2._source;
          var reader = _this2._agent = new FileReader();
          reader.addEventListener('load', function () {
            resolve(reader.result);
          });
          reader.addEventListener('error', function () {
            reject(reader.error);
          });
          reader.addEventListener('abort', function () {
            reject(new Error('Loading aborted'));
          });
          reader.addEventListener('progress', function (event) {
            _this2.dispatchEvent(event);
          });

          if (_this2._binary) {
            reader.readAsArrayBuffer(blob);
          } else {
            reader.readAsText(blob);
          }
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(source) {
        return File && source instanceof File || Blob && source instanceof Blob;
      }
    }, {
      key: "extractName",
      value: function extractName(source) {
        return source && source.name;
      }
    }]);

    return FileLoader;
  }(Loader);
  FileLoader.types = ['file', 'blob'];

  function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var urlStartRegexp = /^(https?|ftp):\/\//i;

  var XHRLoader = /*#__PURE__*/function (_Loader) {
    _inherits(XHRLoader, _Loader);

    var _super = _createSuper$r(XHRLoader);

    function XHRLoader(source, options) {
      var _this;

      _classCallCheck(this, XHRLoader);

      _this = _super.call(this, source, options);
      options = _this._options;
      _this._binary = options.binary === true;
      return _this;
    }

    _createClass(XHRLoader, [{
      key: "load",
      value: function load() {
        var _this2 = this;

        return new Promise(function (resolve, reject) {
          if (_this2._abort) {
            throw new Error('Loading aborted');
          }

          var url = _this2._source;
          var request = _this2._agent = new XMLHttpRequest();
          request.addEventListener('load', function () {
            if (request.status === 200) {
              resolve(request.response);
            } else {
              reject(new Error("HTTP ".concat(request.status, " while fetching ").concat(url)));
            }
          });
          request.addEventListener('error', function () {
            reject(new Error('HTTP request failed'));
          });
          request.addEventListener('abort', function () {
            reject(new Error('Loading aborted'));
          });
          request.addEventListener('progress', function (event) {
            _this2.dispatchEvent(event);
          });
          request.open('GET', url);

          if (_this2._binary) {
            request.responseType = 'arraybuffer';
          } else {
            request.responseType = 'text';
          }

          request.send();
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(source) {
        return ___default["default"].isString(source) && urlStartRegexp.test(source);
      }
    }, {
      key: "extractName",
      value: function extractName(source) {
        if (source) {
          var last = (source.indexOf('?') + 1 || source.lastIndexOf('#') + 1 || source.length + 1) - 1;
          return source.slice(source.lastIndexOf('/', last) + 1, last);
        }

        return undefined;
      }
    }]);

    return XHRLoader;
  }(Loader);
  XHRLoader.types = ['url'];

  function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ImmediateLoader = /*#__PURE__*/function (_Loader) {
    _inherits(ImmediateLoader, _Loader);

    var _super = _createSuper$q(ImmediateLoader);

    function ImmediateLoader() {
      _classCallCheck(this, ImmediateLoader);

      return _super.apply(this, arguments);
    }

    _createClass(ImmediateLoader, [{
      key: "load",
      value: function load() {
        var _this = this;

        return new Promise(function (resolve) {
          if (_this._abort) {
            throw new Error('Loading aborted');
          }

          resolve(_this._source);
        });
      }
    }], [{
      key: "canProbablyLoad",
      value: function canProbablyLoad(_source) {
        return false;
      }
    }]);

    return ImmediateLoader;
  }(Loader);
  ImmediateLoader.types = ['immediate'];

  var loaders = new LoaderList([FileLoader, XHRLoader, ImmediateLoader]);

  function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ParserList = /*#__PURE__*/function (_EntityList) {
    _inherits(ParserList, _EntityList);

    var _super = _createSuper$p(ParserList);

    function ParserList() {
      var someParsers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, ParserList);

      return _super.call(this, someParsers, ['formats', 'extensions']);
    }

    _createClass(ParserList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.format) {
          list = this._dict.formats[specs.format.toLowerCase()] || [];
        } else if (specs.ext) {
          list = this._dict.extensions[specs.ext.toLowerCase()] || [];
        }

        if (list.length === 0 && !specs.format && specs.data) {
          return this._list.filter(function (SomeParser) {
            return SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data);
          });
        }

        return _toConsumableArray(list);
      }
    }]);

    return ParserList;
  }(EntityList);

  var Parser = /*#__PURE__*/function () {
    function Parser(data, options) {
      _classCallCheck(this, Parser);

      this._data = data;
      this._options = options || {};
      this._abort = false;
    }

    _createClass(Parser, [{
      key: "parseSync",
      value: function parseSync() {
        throw new Error('Parsing this type of data is not implemented');
      }
    }, {
      key: "parse",
      value: function parse() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            try {
              if (_this._abort) {
                return reject(new Error('Parsing aborted'));
              }

              return resolve(_this.parseSync());
            } catch (error) {
              return reject(error);
            }
          });
        });
      }
    }, {
      key: "getModel",
      value: function getModel() {
        this.model._parseHeader(this._data);

        return this.model;
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;
      }
    }]);

    return Parser;
  }();
  makeContextDependent(Parser.prototype);

  var Remark290 = /*#__PURE__*/function () {
    function Remark290() {
      _classCallCheck(this, Remark290);

      this.matrices = [];
      this._matrix = null;
      this._matrixIndex = -1;
    }

    _createClass(Remark290, [{
      key: "parse",
      value: function parse(stream) {
        var matrix = this._matrix;

        if (stream.readString(12, 18) === '  SMTRY') {
          var matrixRow = stream.readCharCode(19) - 49;
          var matrixData = stream.readString(20, 80).trim().split(/\s+/);
          var matrixIndex = parseInt(matrixData[0], 10);

          if (this._matrix === null || matrixIndex !== this._matrixIndex) {
            this._matrixIndex = matrixIndex;
            this._matrix = matrix = new THREE__namespace.Matrix4();
            this.matrices[this.matrices.length] = matrix;
          }

          var _matrix = matrix,
              elements = _matrix.elements;
          elements[matrixRow] = parseFloat(matrixData[1]);
          elements[matrixRow + 4] = parseFloat(matrixData[2]);
          elements[matrixRow + 8] = parseFloat(matrixData[3]);
          elements[matrixRow + 12] = parseFloat(matrixData[4]);
        }
      }
    }]);

    return Remark290;
  }();

  Remark290.prototype.id = 290;

  var Assembly$2 = chem.Assembly;

  var Remark350 = /*#__PURE__*/function () {
    function Remark350(complex) {
      _classCallCheck(this, Remark350);

      this._complex = complex;
      this.assemblies = [];
      this._assembly = null;
      this._matrix = null;
      this._matrixIndex = -1;
    }

    _createClass(Remark350, [{
      key: "parse",
      value: function parse(stream) {
        var assembly = this._assembly;
        var matrix = this._matrix;

        if (assembly && stream.readString(12, 18) === '  BIOMT') {
          var matrixRow = stream.readCharCode(19) - 49;
          var matrixData = stream.readString(20, 80).trim().split(/\s+/);
          var matrixIndex = parseInt(matrixData[0], 10);

          if (this._matrix === null || matrixIndex !== this._matrixIndex) {
            this._matrixIndex = matrixIndex;
            this._matrix = matrix = new THREE__namespace.Matrix4();
            assembly.addMatrix(matrix);
          }

          var _matrix = matrix,
              elements = _matrix.elements;
          elements[matrixRow] = parseFloat(matrixData[1]);
          elements[matrixRow + 4] = parseFloat(matrixData[2]);
          elements[matrixRow + 8] = parseFloat(matrixData[3]);
          elements[matrixRow + 12] = parseFloat(matrixData[4]);
        } else if (assembly && stream.readString(35, 41) === 'CHAINS:') {
          var entries = stream.readString(42, 80).split(',');

          for (var i = 0, n = entries.length; i < n; ++i) {
            var chain = entries[i].trim();

            if (chain.length > 0) {
              assembly.addChain(chain);
            }
          }
        } else if (stream.readString(12, 23) === 'BIOMOLECULE:') {
          this._matrix = null;
          this._matrixIndex = -1;
          this._assembly = assembly = new Assembly$2(this._complex);
          this.assemblies.push(assembly);
        }
      }
    }]);

    return Remark350;
  }();

  Remark350.prototype.id = 350;

  var PDBStream = /*#__PURE__*/function () {
    function PDBStream(data) {
      _classCallCheck(this, PDBStream);

      this._data = data;
      this._start = 0;
      this._nextCR = -1;
      this._nextLF = -1;
      this._next = -1;
      this._end = data.length;
      this.next();
    }

    _createClass(PDBStream, [{
      key: "readLine",
      value: function readLine() {
        return this._data.slice(this._start, this._next);
      }
    }, {
      key: "readChar",
      value: function readChar(pos) {
        pos = this._start + pos - 1;
        return pos < this._next ? this._data[pos] : ' ';
      }
    }, {
      key: "readCharCode",
      value: function readCharCode(pos) {
        pos = this._start + pos - 1;
        return pos < this._next ? this._data.charCodeAt(pos) : 32;
      }
    }, {
      key: "readString",
      value: function readString(begin, end) {
        var from = this._start + begin - 1;
        var to = this._start + end;
        return this._data.slice(from, to < this._next ? to : this._next);
      }
    }, {
      key: "readInt",
      value: function readInt(begin, end) {
        return parseInt(this.readString(begin, end), 10);
      }
    }, {
      key: "readFloat",
      value: function readFloat(begin, end) {
        return parseFloat(this.readString(begin, end));
      }
    }, {
      key: "end",
      value: function end() {
        return this._start >= this._end;
      }
    }, {
      key: "next",
      value: function next() {
        var start = this._next + 1;
        this._start = start < this._end ? start : this._end;

        if (this._start > this._nextCR) {
          this._nextCR = (this._data.indexOf('\r', this._start) + 1 || this._end + 1) - 1;
        }

        if (this._start > this._nextLF) {
          this._nextLF = (this._data.indexOf('\n', this._start) + 1 || this._end + 1) - 1;
        }

        this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
      }
    }]);

    return PDBStream;
  }();

  function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$8 = chem.Complex,
      Element$8 = chem.Element,
      Helix$2 = chem.Helix,
      Sheet$2 = chem.Sheet,
      Strand$2 = chem.Strand,
      Bond$4 = chem.Bond,
      Molecule$7 = chem.Molecule;
  var TAG_LENGTH = 6;

  function nameToElement$1(name) {
    var veryLong = name.trim().length === 4;
    return name.slice(0, veryLong ? 1 : 2).trim();
  }

  var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;
  var remarkParsers = {
    290: Remark290,
    350: Remark350
  };

  var PDBParser = /*#__PURE__*/function (_Parser) {
    _inherits(PDBParser, _Parser);

    var _super = _createSuper$o(PDBParser);

    function PDBParser(data, options) {
      var _this;

      _classCallCheck(this, PDBParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._sheet = null;
      _this._serialAtomMap = null;
      _this._modelId = 1;
      _this._compaundFound = false;
      _this._biomoleculeFound = false;
      _this._allowedChainsIDs = null;
      _this._lastMolId = -1;
      _this._remarks = {};
      _this._remark = null;
      _this._molecules = [];
      _this._molecule = null;
      _this._compndCurrToken = '';
      _this._options.fileType = 'pdb';
      return _this;
    }

    _createClass(PDBParser, [{
      key: "_finalize",
      value: function _finalize() {
        this._fixBondsArray();

        this._fixChains();

        var remark290 = this._remarks[290];
        this._complex.symmetry = ___default["default"].isUndefined(remark290) ? [] : remark290.matrices;
        var remark350 = this._remarks[350];
        this._complex.units = this._complex.units.concat(___default["default"].isUndefined(remark350) ? [] : remark350.assemblies);

        this._finalizeMolecules();

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        var chainDict = {};
        var i;
        var chains = this._complex._chains;

        for (i = 0; i < chains.length; ++i) {
          var chainObj = chains[i];
          var chainName = chainObj._name;
          chainDict[chainName] = chainObj;
        }

        for (i = 0; i < this._molecules.length; i++) {
          var m = this._molecules[i];
          var residues = [];

          for (var j = 0; j < m._chains.length; j++) {
            var name = m._chains[j];
            var chain = chainDict[name];
            residues = residues.concat(chain._residues.slice());
          }

          var molecule = new Molecule$7(this._complex, m._name, i + 1);
          molecule.residues = residues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_fixChains",
      value: function _fixChains() {
        var idChainMap = {};
        var complex = this._complex;

        for (var i = 0; i < complex._chains.length; i++) {
          var chain = complex._chains[i];
          idChainMap[chain._name.charCodeAt(0)] = chain;
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap = {};
        var complex = this._complex;
        var atoms = complex._atoms;

        for (var i = 0, ni = atoms.length; i < ni; ++i) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        var bonds = complex._bonds;
        var logger = this.logger;

        for (var j = 0, nj = bonds.length; j < nj; ++j) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            logger.debug('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_parseATOM",
      value: function _parseATOM(stream) {
        if (this._modelId !== 1) {
          return;
        }

        var het = stream.readCharCode(1) === 0x48;
        var serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
        var name = stream.readString(13, 16);
        var altLoc = stream.readChar(17);
        var resName = stream.readString(18, 20).trim();
        var chainID = stream.readChar(22);
        var resSeq = stream.readInt(23, 26);
        var iCode = stream.readChar(27);
        var x = stream.readFloat(31, 38);
        var y = stream.readFloat(39, 46);
        var z = stream.readFloat(47, 54);
        var occupancy = stream.readFloat(55, 60);
        var tempFactor = stream.readFloat(61, 66);
        var element = stream.readString(77, 78).trim() || nameToElement$1(name);
        var charge = stream.readInt(79, 80) || 0;

        if (this.settings.now.nowater) {
          if (resName === 'HOH' || resName === 'WAT') {
            return;
          }
        }

        name = name.trim();
        var type = Element$8.getByName(element);
        var role = Element$8.Role[name];
        var chain = this._chain;

        if (!chain || chain.getName() !== chainID) {
          this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
          this._residue = null;
        }

        var residue = this._residue;

        if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
          this._residue = residue = chain.addResidue(resName, resSeq, iCode);
        }

        var xyz = new THREE__namespace.Vector3(x, y, z);
        residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
      }
    }, {
      key: "_parseENDMDL",
      value: function _parseENDMDL() {
        this._modelId += 1;
      }
    }, {
      key: "_parseCONECT",
      value: function _parseCONECT(stream) {
        var serial0 = stream.readInt(7, 11);
        var serial1 = stream.readInt(12, 16);
        var serial2 = stream.readInt(17, 21);
        var serial3 = stream.readInt(22, 26);
        var serial4 = stream.readInt(27, 31);
        var complex = this._complex;

        if (serial1 && serial1 > serial0) {
          complex.addBond(serial0, serial1, 0, Bond$4.BondType.UNKNOWN, true);
        }

        if (serial2 && serial2 > serial0) {
          complex.addBond(serial0, serial2, 0, Bond$4.BondType.UNKNOWN, true);
        }

        if (serial3 && serial3 > serial0) {
          complex.addBond(serial0, serial3, 0, Bond$4.BondType.UNKNOWN, true);
        }

        if (serial4 && serial4 > serial0) {
          complex.addBond(serial0, serial4, 0, Bond$4.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_parseCOMPND",
      value: function _parseCOMPND(stream) {
        var str = stream.readString(11, 80);
        var tokenIdx = str.indexOf(':');
        this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;

        if (this._compndCurrToken === 'MOL_ID') {
          this._molecule = {
            _index: '',
            _chains: []
          };
          this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(';')), 10);

          this._molecules.push(this._molecule);
        } else if (this._compndCurrToken === 'MOLECULE' && this._molecule != null) {
          this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(';')).trim();
        } else if (this._compndCurrToken === 'CHAIN' && this._molecule != null) {
          var chainStr = str.substring(tokenIdx + 1, 80).trim();
          var lastChar = chainStr[chainStr.length - 1];

          if (lastChar === ';' || lastChar === ',') {
            chainStr = chainStr.slice(0, -1);
          }

          chainStr = chainStr.replace(/\s+/g, '');
          var chains = chainStr.split(',');
          this._molecule._chains = this._molecule._chains.concat(chains);
        }
      }
    }, {
      key: "_parseREMARK",
      value: function _parseREMARK(stream) {
        var remarkNum = stream.readInt(8, 10);
        var remark = this._remarks[remarkNum];

        if (___default["default"].isUndefined(remark)) {
          var RemarkParser = remarkParsers[remarkNum];

          if (___default["default"].isFunction(RemarkParser)) {
            this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
          }
        }

        if (!___default["default"].isUndefined(remark)) {
          remark.parse(stream);
        }
      }
    }, {
      key: "_parseHELIX",
      value: function _parseHELIX(stream) {
        var _this2 = this;

        var fields = [20, 22, 32, 34];

        this._parseSTRUCTURE(stream, fields, function (obj) {
          _this2._complex.addHelix(obj);

          _this2._complex.structures.push(obj);
        });
      }
    }, {
      key: "_parseSHEET",
      value: function _parseSHEET(stream) {
        var _this3 = this;

        var fields = [22, 23, 33, 34];

        this._parseSTRUCTURE(stream, fields, function (obj) {
          _this3._complex.addSheet(obj);
        });
      }
    }, {
      key: "_parseSTRUCTURE",
      value: function _parseSTRUCTURE(stream, pars, adder) {
        var startId = 0;
        var startIndex = 1;
        var endId = 2;
        var endIndex = 3;
        var codeOfS = 0x53;
        var serialNumber = stream.readInt(8, 10);
        var structureName = stream.readString(12, 14).trim();
        var comment = stream.readString(41, 70).trim();
        var helLength = stream.readInt(72, 76);
        var helixClass = stream.readInt(39, 40);
        var shWidth = stream.readInt(15, 16);
        var shCur = stream.readInt(42, 45);
        var shPrev = stream.readInt(57, 60);
        var startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
        var endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
        var startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
        var iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
        var startICode = 0;

        if (iCodeStr.length > 0) {
          startICode = iCodeStr.charCodeAt(0);
        }

        var endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
        iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
        var endICode = 0;

        if (iCodeStr.length > 0) {
          endICode = iCodeStr.charCodeAt(0);
        }

        var obj;
        var cs = this._sheet;

        if (stream.readCharCode(1) === codeOfS) {
          if (cs !== null && cs.getName() !== structureName) {
            cs = null;
            this._sheet = null;
          }

          if (cs === null) {
            this._sheet = obj = new Sheet$2(structureName, shWidth);
            adder(obj);
          } else {
            obj = cs;
          }

          var strand = new Strand$2(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
          obj.addStrand(strand);

          this._complex.structures.push(strand);
        } else {
          obj = new Helix$2(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
          adder(obj);
        }
      }
    }, {
      key: "_parseHEADER",
      value: function _parseHEADER(stream) {
        var metadata = this._complex.metadata;
        metadata.classification = stream.readString(11, 50).trim();
        metadata.date = stream.readString(51, 59).trim();
        var id = stream.readString(63, 66).trim();
        metadata.id = id;

        if (id) {
          this._complex.name = id;
        }

        metadata.format = 'pdb';
      }
    }, {
      key: "_parseTITLE",
      value: function _parseTITLE(stream) {
        var metadata = this._complex.metadata;
        metadata.title = metadata.title || [];
        var line = stream.readInt(9, 10) || 1;
        metadata.title[line - 1] = stream.readString(11, 80).trim();
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var stream = new PDBStream(this._data);
        var result = this._complex = new Complex$8();

        while (!stream.end()) {
          var tag = stream.readString(1, TAG_LENGTH);
          var func = PDBParser.tagParsers[tag];

          if (___default["default"].isFunction(func)) {
            func.call(this, stream);
          }

          stream.next();
        }

        this._finalize();

        this._serialAtomMap = null;
        this._sheet = null;
        this._residue = null;
        this._chain = null;
        this._complex = null;

        if (result.getAtomCount() === 0) {
          throw new Error('The data does not contain valid atoms');
        }

        return result;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(data) && pdbStartRegexp.test(data);
      }
    }]);

    return PDBParser;
  }(Parser);

  _defineProperty(PDBParser, "tagParsers", {
    HEADER: PDBParser.prototype._parseHEADER,
    'TITLE ': PDBParser.prototype._parseTITLE,
    'ATOM  ': PDBParser.prototype._parseATOM,
    HETATM: PDBParser.prototype._parseATOM,
    ENDMDL: PDBParser.prototype._parseENDMDL,
    CONECT: PDBParser.prototype._parseCONECT,
    COMPND: PDBParser.prototype._parseCOMPND,
    REMARK: PDBParser.prototype._parseREMARK,
    'HELIX ': PDBParser.prototype._parseHELIX,
    'SHEET ': PDBParser.prototype._parseSHEET,
    'ATOM 1': PDBParser.prototype._parseATOM,
    'ATOM 2': PDBParser.prototype._parseATOM,
    'ATOM 3': PDBParser.prototype._parseATOM,
    'ATOM 4': PDBParser.prototype._parseATOM,
    'ATOM 5': PDBParser.prototype._parseATOM,
    'ATOM 6': PDBParser.prototype._parseATOM,
    'ATOM 7': PDBParser.prototype._parseATOM,
    'ATOM 8': PDBParser.prototype._parseATOM,
    'ATOM 9': PDBParser.prototype._parseATOM
  });

  PDBParser.formats = ['pdb'];
  PDBParser.extensions = ['.pdb', '.ent'];

  function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$7 = chem.Complex,
      Element$7 = chem.Element,
      SGroup = chem.SGroup,
      Bond$3 = chem.Bond;
  var cOrderCharCodes = {
    A: 0,
    S: 1,
    D: 2,
    T: 3
  };
  var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;

  var CMLParser = /*#__PURE__*/function (_Parser) {
    _inherits(CMLParser, _Parser);

    var _super = _createSuper$n(CMLParser);

    function CMLParser(data, options) {
      var _this;

      _classCallCheck(this, CMLParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._residue = null;
      _this._serialAtomMap = null;
      _this._modelId = 1;
      _this._lastMolId = -1;
      _this._readOnlyOneMolecule = false;
      _this._options.fileType = 'cml';
      return _this;
    }

    _createClass(CMLParser, [{
      key: "_rebuidBondIndexes",
      value: function _rebuidBondIndexes(atoms, bonds) {
        var count = atoms.length;

        for (var i = 0; i < count; i++) {
          var atomId = atoms[i].id;
          var countBonds = bonds.length;

          for (var j = 0; j < countBonds; j++) {
            var idxs = bonds[j].atomRefs2.split(' ');

            if (idxs[0] === atomId) {
              bonds[j].start = i;
            }

            if (idxs[1] === atomId) {
              bonds[j].end = i;
            }
          }
        }
      }
    }, {
      key: "_createSGroup",
      value: function _createSGroup(molecule, moleculeArr) {
        var newGroup = new SGroup(molecule.id, molecule.fieldData, new THREE__namespace.Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);

        if (molecule.placement === 'Relative') {
          newGroup._center = new THREE__namespace.Vector3(0, 0, 0);
        }

        if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
          newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
        }

        if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
          newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
        }

        moleculeArr.push(newGroup);
      }
    }, {
      key: "_extractSGroup",
      value: function _extractSGroup(molecule, moleculeArr) {
        if (!Array.isArray(moleculeArr)) {
          moleculeArr = [];
        }

        if (molecule) {
          if (Array.isArray(molecule)) {
            var count = molecule.length;

            for (var i = 0; i < count; i++) {
              if (molecule[i].molecule) {
                moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i].molecule));
              }

              this._createSGroup(molecule[i], moleculeArr);
            }
          } else {
            if (molecule.molecule) {
              if (molecule.molecule) {
                moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
              }
            }

            this._createSGroup(molecule, moleculeArr);
          }
        }

        return moleculeArr;
      }
    }, {
      key: "_extractSGroups",
      value: function _extractSGroups(molecule, atoms) {
        var moleculeArr = this._extractSGroup(molecule);

        var count = atoms.length;
        var i;
        var j;

        for (i = 0; i < count; i++) {
          var atomId = atoms[i].id;

          for (j = 0; j < moleculeArr.length; j++) {
            var firstAtomRef = moleculeArr[j]._atoms.split(' ')[0];

            if (firstAtomRef === atomId) {
              if (!atoms[i].sgroupRef) {
                atoms[i].sgroupRef = [];
              }

              atoms[i].sgroupRef.push(moleculeArr[j]);
            }
          }
        }

        var atomMap = {};
        var mapEntry = null;
        var nLimon = 100000000;
        var bLow = new THREE__namespace.Vector3(nLimon, nLimon, nLimon);
        var bHight = new THREE__namespace.Vector3(-nLimon, -nLimon, -nLimon);

        function cycleFuncInner(e) {
          mapEntry = atomMap[e];

          if (mapEntry) {
            moleculeArr[j]._atoms.push(mapEntry.a);
          }
        }

        function cycleFunc(e) {
          mapEntry = atomMap[e];

          if (mapEntry) {
            bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
            bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
            cycleFuncInner(e);
          }
        }

        for (i = 0; i < atoms.length; i++) {
          atomMap[atoms[i].id] = {};
          atomMap[atoms[i].id].x = atoms[i].x2;

          if (atoms[i].x3) {
            atomMap[atoms[i].id].x = atoms[i].x3;
          }

          atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x);
          atomMap[atoms[i].id].y = atoms[i].y2;

          if (atoms[i].y3) {
            atomMap[atoms[i].id].y = atoms[i].y3;
          }

          atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y);
          atomMap[atoms[i].id].z = '0.0';

          if (atoms[i].z3) {
            atomMap[atoms[i].id].z = atoms[i].z3;
          }

          atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z);
          atomMap[atoms[i].id].a = atoms[i];
        }

        var atomsRef;

        for (j = 0; j < moleculeArr.length; j++) {
          if (moleculeArr[j]._center !== null) {
            bLow.set(nLimon, nLimon, nLimon);
            bHight.set(-nLimon, -nLimon, -nLimon);
            atomsRef = moleculeArr[j]._atoms.split(' ');
            moleculeArr[j]._atoms = [];
            atomsRef.forEach(cycleFunc);

            moleculeArr[j]._center.addVectors(bLow, bHight);

            moleculeArr[j]._center.multiplyScalar(0.5);
          } else {
            atomsRef = moleculeArr[j]._atoms.split(' ');
            moleculeArr[j]._atoms = [];
            atomsRef.forEach(cycleFuncInner);
          }
        }

        atomMap = null;
      }
    }, {
      key: "_traverseData",
      value: function _traverseData(dom) {
        function isArray(o) {
          return Object.prototype.toString.apply(o) === '[object Array]';
        }

        function parseNode(xmlNode, result) {
          if (xmlNode.nodeName === '#text' && xmlNode.nodeValue.trim() === '') {
            return;
          }

          var jsonNode = {};
          jsonNode.xmlNode = xmlNode;
          var existing = result[xmlNode.nodeName];

          if (existing) {
            if (!isArray(existing)) {
              result[xmlNode.nodeName] = [existing, jsonNode];
            } else {
              result[xmlNode.nodeName].push(jsonNode);
            }
          } else {
            result[xmlNode.nodeName] = jsonNode;
          }

          var length;
          var i;

          if (xmlNode.attributes) {
            length = xmlNode.attributes.length;

            for (i = 0; i < length; i++) {
              var attribute = xmlNode.attributes[i];
              jsonNode[attribute.nodeName] = attribute.nodeValue;
            }
          }
          length = xmlNode.childNodes.length;

          for (i = 0; i < length; i++) {
            parseNode(xmlNode.childNodes[i], jsonNode);
          }
        }

        var result = {};

        if (dom.childNodes.length) {
          parseNode(dom.childNodes[0], result);
        }

        return result;
      }
    }, {
      key: "_findSuitableMolecule",
      value: function _findSuitableMolecule(data, molSet) {
        for (var key in data) {
          if (key === 'xmlNode') {
            continue;
          } else if (key === 'molecule') {
            if (data.molecule) {
              if (data.molecule.atomArray && data.molecule.atomArray.atom) {
                molSet.push(data);
              }

              if (Array.isArray(data.molecule)) {
                for (var i = 0; i < data.molecule.length; i++) {
                  if (data.molecule[i].atomArray && data.molecule[i].atomArray.atom) {
                    molSet.push({
                      molecule: data.molecule[i]
                    });
                  }
                }
              }
            }
          } else if (data[key] && data[key] !== null && _typeof(data[key]) === 'object') {
            this._findSuitableMolecule(data[key], molSet);
          }
        }
      }
    }, {
      key: "_selectComponents",
      value: function _selectComponents(text) {
        var parser = new DOMParser();
        var doc = parser.parseFromString(text, 'application/xml');

        var traversedData = this._traverseData(doc);

        var rawData;
        var self = this;

        function prepareComponentCompound(data) {
          var atoms = [];

          if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
            if (!Array.isArray(data.molecule.atomArray.atom)) {
              atoms.push(data.molecule.atomArray.atom);
            } else {
              atoms = data.molecule.atomArray.atom;
            }
          } else if (!data.molecule) {
            var ret = {};
            ret.atomLabels = null;
            ret.labelsCount = 1;
            return ret;
          }

          if (data.molecule.molecule) {
            self._extractSGroups(data.molecule.molecule, atoms);
          }

          var atom;
          var count = atoms.length;

          for (var i = 0; i < count; i++) {
            atom = atoms[i];
            atom.edges = [];
          }

          var localBond = [];

          if (data.molecule.bondArray && data.molecule.bondArray.bond) {
            if (!Array.isArray(data.molecule.bondArray.bond)) {
              localBond.push(data.molecule.bondArray.bond);
            } else {
              localBond = data.molecule.bondArray.bond;
            }
          }

          var bond;
          count = localBond.length;

          self._rebuidBondIndexes(atoms, localBond);

          function addCurrBond(index) {
            bond = localBond[index];
            atom = atoms[bond.start];

            if (!atom) {
              return false;
            }

            atom.edges.push(bond.end);
            atom = atoms[bond.end];

            if (!atom) {
              return false;
            }

            atom.edges.push(bond.start);
            return true;
          }

          for (var _i = 0; _i < count; _i++) {
            if (!addCurrBond(_i)) {
              continue;
            }

            var orderAttr = bond.xmlNode.getAttribute('order');
            var tc = parseInt(orderAttr, 10);
            localBond[_i].order = 0;
            localBond[_i].type = Bond$3.BondType.UNKNOWN;

            if (tc > 1) {
              localBond[_i].order = tc;
            } else {
              var order = cOrderCharCodes[orderAttr];

              if (order !== undefined) {
                localBond[_i].order = order;

                if (orderAttr === 'A') {
                  localBond[_i].type = Bond$3.BondType.AROMATIC;
                }
              }
            }
          }

          count = atoms.length;

          for (var _i2 = 0; _i2 < count; _i2++) {
            atom = atoms[_i2];
            atom.edges.sort();
          }

          var labels = self._breadWidthSearch(atoms, 0);

          var retStruct = {};
          retStruct.atoms = atoms;
          retStruct.bonds = localBond;
          retStruct.labels = labels.atomLabels;
          retStruct.count = Math.min(1, labels.labelsCount);
          retStruct.curr = -1;
          retStruct.originalCML = doc;
          return retStruct;
        }

        if (traversedData.cml) {
          rawData = traversedData.cml;
        } else {
          rawData = traversedData;
        }

        var retData = [];
        var filteredData = [];

        this._findSuitableMolecule(rawData, filteredData);

        if (this._readOnlyOneMolecule && filteredData.length > 1) {
          filteredData.splice(1, filteredData.length - 1);
        }

        filteredData.forEach(function (d) {
          var rd = prepareComponentCompound(d);

          if (rd.atoms.length > 0) {
            retData.push(rd);
          }
        });
        return retData;
      }
    }, {
      key: "_packLabel",
      value: function _packLabel(compId, molId) {
        var shift = 16;
        return (molId << shift) + compId;
      }
    }, {
      key: "_unpackLabel",
      value: function _unpackLabel(l) {
        var shift = 16;
        var mask = (1 << shift) - 1;
        return {
          molId: l >>> shift,
          compId: l & mask
        };
      }
    }, {
      key: "_breadWidthSearch",
      value: function _breadWidthSearch(atoms, molID) {
        var atomLabels = new Array(atoms.length);
        var id;

        for (id = 0; id < atomLabels.length; id++) {
          atomLabels[id] = this._packLabel(0, molID);
        }

        var breadthQueue = [];
        var componentID = 0;
        var labeledAtoms = atoms.length;

        while (labeledAtoms > 0) {
          componentID++;
          var startID = -1;

          for (id = 0; id < atomLabels.length; id++) {
            if (this._unpackLabel(atomLabels[id]).compId === 0) {
              startID = id;
              break;
            }
          }

          if (startID < 0) {
            break;
          }

          breadthQueue.push(atoms[startID]);
          atomLabels[startID] = this._packLabel(componentID, molID);
          labeledAtoms--;

          while (breadthQueue.length > 0) {
            var curr = breadthQueue.shift();

            if (!curr) {
              continue;
            }

            for (var i = 0; i < curr.edges.length; i++) {
              if (atomLabels[curr.edges[i]] !== componentID) {
                breadthQueue.push(atoms[curr.edges[i]]);
                atomLabels[curr.edges[i]] = componentID;
                labeledAtoms--;
              }
            }
          }
        }

        var ret = {};
        ret.atomLabels = atomLabels;
        ret.labelsCount = componentID;
        return ret;
      }
    }, {
      key: "_parseBond",
      value: function _parseBond(eAtom, mainAtom, order, type) {
        if (eAtom >= 0) {
          var h = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];

          this._complex.addBond(h[0], h[1], order, type, true);
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap = {};
        var complex = this._complex;
        var atoms = complex._atoms;

        for (var i = 0, ni = atoms.length; i < ni; ++i) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        var bonds = complex._bonds;
        var logger = this.logger;

        for (var j = 0, nj = bonds.length; j < nj; ++j) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            logger.debug('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_parseSet",
      value: function _parseSet(varData) {
        var complex = this._complex = new Complex$7();
        var data = varData;
        var currentLabel = data.curr;
        var atoms = data.atoms,
            labels = data.labels;
        var atom = null;
        var i;
        var j;
        var count = atoms.length;

        function addFunc(a) {
          a.xmlNodeRef = atom;

          if (atom.x2) {
            atom.x3 = atom.x2;
            delete atom.x2;
          }

          if (atom.y2) {
            atom.y3 = atom.y2;
            delete atom.y2;
          }

          if (!atom.z3) {
            atom.z3 = '0.0';
          }

          atom.complexAtom = a;
        }

        var chains = {};
        var reorder = [];

        for (i = 0; i < count; i++) {
          reorder.push(i);
        }

        reorder.sort(function (a, b) {
          return labels[a] - labels[b];
        });

        for (i = 0; i < count; i++) {
          var atomCharge = 0;
          var lLabel = labels[reorder[i]];

          if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[reorder[i]];
            var atomFullNameStruct = atom.elementType;

            if (atom.sgroupRef) {
              var countRef = atom.sgroupRef.length;

              for (var k = 0; k < countRef; ++k) {
                complex._sgroups.push(atom.sgroupRef[k]);
              }
            }

            if (atom.x3 || atom.x2) {
              var currAtomComp = this._unpackLabel(lLabel).compId;

              var chainID = ' ';
              var resSeq = currAtomComp;
              var iCode = ' ';
              var strLabel = currAtomComp.toString();

              if (strLabel.length === 1) {
                strLabel = "0".concat(strLabel);
              }

              var resName = "N".concat(strLabel);
              var chain = chains[chainID];

              if (!chain || chain.getName() !== chainID) {
                chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
                this._residue = null;
              }

              var residue = this._residue;

              if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
                this._residue = residue = chain.addResidue(resName, resSeq, iCode);
              }

              var xyz = null;

              if (atom.x3) {
                xyz = new THREE__namespace.Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
              } else if (atom.x2) {
                xyz = new THREE__namespace.Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
              }

              var element = Element$7.ByName[atom.elementType.toUpperCase()];

              if (!element) {
                element = JSON.parse(JSON.stringify(Element$7.ByName[Object.keys(Element$7.ByName)[Object.keys(Element$7.ByName).length - 1]]));
                element.number += 1;
                element.name = atom.elementType.toUpperCase();
                element.fullName = 'Unknown';
                Element$7.ByName[atom.elementType.toUpperCase()] = element;
              }

              var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10);
              var added = residue.addAtom(atomFullNameStruct, element, xyz, Element$7.Role.SG, true, atomSerial, ' ', 1.0, 0.0, atomCharge);

              if (atom.hydrogenCount) {
                added.hydrogenCount = parseInt(atom.hydrogenCount, 10);
              }

              if (atom.mrvValence) {
                added.valence = parseInt(atom.mrvValence, 10);
              }

              addFunc(added);
            }
          }
        }

        chains = null;

        for (i = 0; i < data.bonds.length; i++) {
          var cb = data.bonds[i];

          if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[cb.start];

            if (!atom || !atoms[cb.end]) {
              continue;
            }

            this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ''), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10), cb.order, cb.type);
          }
        }

        for (i = 0; i < this._complex.getSGroupCount(); i++) {
          var sGrp = this._complex.getSGroups()[i];

          for (j = 0; j < sGrp._atoms.length; j++) {
            sGrp._atoms[j] = sGrp._atoms[j].complexAtom;
          }
        }

        for (i = 0; i < count; i++) {
          if (this._unpackLabel(labels[i]).molId === this._unpackLabel(currentLabel).molId) {
            atom = atoms[i];
            atom.complexAtom = null;
            delete atom.complexAtom;
          }
        }

        this._complex.originalCML = data.originalCML;

        this._fixBondsArray();

        complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
        this._serialAtomMap = null;
        this._complex = null;
        return complex;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var complexes = [];
        var self = this;

        var moleculaSet = this._selectComponents(this._data);

        moleculaSet.forEach(function (molSet) {
          molSet.curr = 2;

          if (molSet.count === 0) {
            molSet.count = 1;
          }

          for (var i = 0; i < molSet.count; i++) {
            molSet.curr = i + 1;
            complexes.push(self._parseSet(molSet, false));
          }
        });
        var totalAtomsParsed = 0;
        complexes.forEach(function (c) {
          totalAtomsParsed += c.getAtomCount();
        });

        if (totalAtomsParsed <= 0) {
          throw new Error('The data does not contain valid atoms');
        }

        if (complexes.length > 1) {
          var joinedComplex = new Complex$7();
          joinedComplex.joinComplexes(complexes);
          joinedComplex.originalCML = complexes[0].originalCML;
          return joinedComplex;
        }

        if (complexes.length === 1) {
          return complexes[0];
        }

        return new Complex$7();
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(data) && cmlStartRegexp.test(data);
      }
    }]);

    return CMLParser;
  }(Parser);

  CMLParser.formats = ['cml'];
  CMLParser.extensions = ['.cml'];

  var mmtf = {exports: {}};

  (function (module, exports) {
  !function(r,t){t(exports);}(commonjsGlobal,function(r){function t(r,t,n){for(var e=(r.byteLength,0),i=n.length;i>e;e++){var o=n.charCodeAt(e);if(128>o)r.setUint8(t++,o>>>0&127|0);else if(2048>o)r.setUint8(t++,o>>>6&31|192),r.setUint8(t++,o>>>0&63|128);else if(65536>o)r.setUint8(t++,o>>>12&15|224),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);else {if(!(1114112>o))throw new Error("bad codepoint "+o);r.setUint8(t++,o>>>18&7|240),r.setUint8(t++,o>>>12&63|128),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);}}}function n(r){for(var t=0,n=0,e=r.length;e>n;n++){var i=r.charCodeAt(n);if(128>i)t+=1;else if(2048>i)t+=2;else if(65536>i)t+=3;else {if(!(1114112>i))throw new Error("bad codepoint "+i);t+=4;}}return t}function e(r,i,o){var a=typeof r;if("string"===a){var u=n(r);if(32>u)return i.setUint8(o,160|u),t(i,o+1,r),1+u;if(256>u)return i.setUint8(o,217),i.setUint8(o+1,u),t(i,o+2,r),2+u;if(65536>u)return i.setUint8(o,218),i.setUint16(o+1,u),t(i,o+3,r),3+u;if(4294967296>u)return i.setUint8(o,219),i.setUint32(o+1,u),t(i,o+5,r),5+u}if(r instanceof Uint8Array){var u=r.byteLength,s=new Uint8Array(i.buffer);if(256>u)return i.setUint8(o,196),i.setUint8(o+1,u),s.set(r,o+2),2+u;if(65536>u)return i.setUint8(o,197),i.setUint16(o+1,u),s.set(r,o+3),3+u;if(4294967296>u)return i.setUint8(o,198),i.setUint32(o+1,u),s.set(r,o+5),5+u}if("number"===a){if(!isFinite(r))throw new Error("Number not finite: "+r);if(Math.floor(r)!==r)return i.setUint8(o,203),i.setFloat64(o+1,r),9;if(r>=0){if(128>r)return i.setUint8(o,r),1;if(256>r)return i.setUint8(o,204),i.setUint8(o+1,r),2;if(65536>r)return i.setUint8(o,205),i.setUint16(o+1,r),3;if(4294967296>r)return i.setUint8(o,206),i.setUint32(o+1,r),5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return i.setInt8(o,r),1;if(r>=-128)return i.setUint8(o,208),i.setInt8(o+1,r),2;if(r>=-32768)return i.setUint8(o,209),i.setInt16(o+1,r),3;if(r>=-2147483648)return i.setUint8(o,210),i.setInt32(o+1,r),5;throw new Error("Number too small -0x"+(-r).toString(16).substr(1))}if(null===r)return i.setUint8(o,192),1;if("boolean"===a)return i.setUint8(o,r?195:194),1;if("object"===a){var u,f=0,c=Array.isArray(r);if(c)u=r.length;else {var d=Object.keys(r);u=d.length;}var f;if(16>u?(i.setUint8(o,u|(c?144:128)),f=1):65536>u?(i.setUint8(o,c?220:222),i.setUint16(o+1,u),f=3):4294967296>u&&(i.setUint8(o,c?221:223),i.setUint32(o+1,u),f=5),c)for(var l=0;u>l;l++)f+=e(r[l],i,o+f);else for(var l=0;u>l;l++){var v=d[l];f+=e(v,i,o+f),f+=e(r[v],i,o+f);}return f}throw new Error("Unknown type "+a)}function i(r){var t=typeof r;if("string"===t){var e=n(r);if(32>e)return 1+e;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(r instanceof Uint8Array){var e=r.byteLength;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if("number"===t){if(Math.floor(r)!==r)return 9;if(r>=0){if(128>r)return 1;if(256>r)return 2;if(65536>r)return 3;if(4294967296>r)return 5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return 1;if(r>=-128)return 2;if(r>=-32768)return 3;if(r>=-2147483648)return 5;throw new Error("Number too small -0x"+r.toString(16).substr(1))}if("boolean"===t||null===r)return 1;if("object"===t){var e,o=0;if(Array.isArray(r)){e=r.length;for(var a=0;e>a;a++)o+=i(r[a]);}else {var u=Object.keys(r);e=u.length;for(var a=0;e>a;a++){var s=u[a];o+=i(s)+i(r[s]);}}if(16>e)return 1+o;if(65536>e)return 3+o;if(4294967296>e)return 5+o;throw new Error("Array or object too long 0x"+e.toString(16))}throw new Error("Unknown type "+t)}function o(r){var t=new ArrayBuffer(i(r)),n=new DataView(t);return e(r,n,0),new Uint8Array(t)}function a(r,t,n){return t?new r(t.buffer,t.byteOffset,t.byteLength/(n||1)):void 0}function u(r){return a(DataView,r)}function s(r){return a(Uint8Array,r)}function f(r){return a(Int8Array,r)}function c(r){return a(Int32Array,r,4)}function d(r){return a(Float32Array,r,4)}function l(r,t){var n=r.length/2;t||(t=new Int16Array(n));for(var e=0,i=0;n>e;++e,i+=2)t[e]=r[i]<<8^r[i+1]<<0;return t}function v(r,t){var n=r.length;t||(t=new Uint8Array(2*n));for(var e=u(t),i=0;n>i;++i)e.setInt16(2*i,r[i]);return s(t)}function g(r,t){var n=r.length/4;t||(t=new Int32Array(n));for(var e=0,i=0;n>e;++e,i+=4)t[e]=r[i]<<24^r[i+1]<<16^r[i+2]<<8^r[i+3]<<0;return t}function L(r,t){var n=r.length;t||(t=new Uint8Array(4*n));for(var e=u(t),i=0;n>i;++i)e.setInt32(4*i,r[i]);return s(t)}function h(r,t){var n=r.length;t||(t=new Float32Array(n/4));for(var e=u(t),i=u(r),o=0,a=0,s=n/4;s>o;++o,a+=4)e.setFloat32(a,i.getFloat32(a),!0);return t}function y(r,t,n){var e=r.length,i=1/t;n||(n=new Float32Array(e));for(var o=0;e>o;++o)n[o]=r[o]*i;return n}function m(r,t,n){var e=r.length;n||(n=new Int32Array(e));for(var i=0;e>i;++i)n[i]=Math.round(r[i]*t);return n}function p(r,t){var n,e;if(!t){var i=0;for(n=0,e=r.length;e>n;n+=2)i+=r[n+1];t=new r.constructor(i);}var o=0;for(n=0,e=r.length;e>n;n+=2)for(var a=r[n],u=r[n+1],s=0;u>s;++s)t[o]=a,++o;return t}function U(r){if(0===r.length)return new Int32Array;var t,n,e=2;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]&&(e+=2);var i=new Int32Array(e),o=0,a=1;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]?(i[o]=r[t-1],i[o+1]=a,a=1,o+=2):++a;return i[o]=r[r.length-1],i[o+1]=a,i}function b(r,t){var n=r.length;t||(t=new r.constructor(n)),n&&(t[0]=r[0]);for(var e=1;n>e;++e)t[e]=r[e]+t[e-1];return t}function I(r,t){var n=r.length;t||(t=new r.constructor(n)),t[0]=r[0];for(var e=1;n>e;++e)t[e]=r[e]-r[e-1];return t}function w(r,t){var n,e,i=r instanceof Int8Array?127:32767,o=-i-1,a=r.length;if(!t){var u=0;for(n=0;a>n;++n)r[n]<i&&r[n]>o&&++u;t=new Int32Array(u);}for(n=0,e=0;a>n;){for(var s=0;r[n]===i||r[n]===o;)s+=r[n],++n;s+=r[n],++n,t[e]=s,++e;}return t}function C(r,t){var n,e=t?127:32767,i=-e-1,o=r.length,a=0;for(n=0;o>n;++n){var u=r[n];0===u?++a:a+=u===e||u===i?2:u>0?Math.ceil(u/e):Math.ceil(u/i);}var s=t?new Int8Array(a):new Int16Array(a),f=0;for(n=0;o>n;++n){var u=r[n];if(u>=0)for(;u>=e;)s[f]=e,++f,u-=e;else for(;i>=u;)s[f]=i,++f,u-=i;s[f]=u,++f;}return s}function A(r,t){return b(p(r),t)}function x(r){return U(I(r))}function M(r,t,n){return y(p(r,c(n)),t,n)}function F(r,t){return U(m(r,t))}function S(r,t,n){return y(b(r,c(n)),t,n)}function E(r,t,n){return I(m(r,t),n)}function N(r,t,n){return y(w(r,c(n)),t,n)}function O(r,t,n){var e=w(r,c(n));return S(e,t,d(e))}function T(r,t,n){return C(E(r,t),n)}function k(r){var t=u(r),n=t.getInt32(0),e=t.getInt32(4),i=r.subarray(8,12),r=r.subarray(12);return [n,r,e,i]}function j(r,t,n,e){var i=new ArrayBuffer(12+e.byteLength),o=new Uint8Array(i),a=new DataView(i);return a.setInt32(0,r),a.setInt32(4,t),n&&o.set(n,8),o.set(e,12),o}function q(r){var t=r.length,n=s(r);return j(2,t,void 0,n)}function D(r){var t=r.length,n=L(r);return j(4,t,void 0,n)}function P(r,t){var n=r.length/t,e=L([t]),i=s(r);return j(5,n,e,i)}function z(r){var t=r.length,n=L(U(r));return j(6,t,void 0,n)}function B(r){var t=r.length,n=L(x(r));return j(8,t,void 0,n)}function V(r,t){var n=r.length,e=L([t]),i=L(F(r,t));return j(9,n,e,i)}function G(r,t){var n=r.length,e=L([t]),i=v(T(r,t));return j(10,n,e,i)}function R(r){var t={};return rr.forEach(function(n){void 0!==r[n]&&(t[n]=r[n]);}),r.bondAtomList&&(t.bondAtomList=D(r.bondAtomList)),r.bondOrderList&&(t.bondOrderList=q(r.bondOrderList)),t.xCoordList=G(r.xCoordList,1e3),t.yCoordList=G(r.yCoordList,1e3),t.zCoordList=G(r.zCoordList,1e3),r.bFactorList&&(t.bFactorList=G(r.bFactorList,100)),r.atomIdList&&(t.atomIdList=B(r.atomIdList)),r.altLocList&&(t.altLocList=z(r.altLocList)),r.occupancyList&&(t.occupancyList=V(r.occupancyList,100)),t.groupIdList=B(r.groupIdList),t.groupTypeList=D(r.groupTypeList),r.secStructList&&(t.secStructList=q(r.secStructList)),r.insCodeList&&(t.insCodeList=z(r.insCodeList)),r.sequenceIndexList&&(t.sequenceIndexList=B(r.sequenceIndexList)),t.chainIdList=P(r.chainIdList,4),r.chainNameList&&(t.chainNameList=P(r.chainNameList,4)),t}function H(r){function t(r){for(var t={},n=0;r>n;n++){var e=o();t[e]=o();}return t}function n(t){var n=r.subarray(a,a+t);return a+=t,n}function e(t){var n=r.subarray(a,a+t);a+=t;var e=65535;if(t>e){for(var i=[],o=0;o<n.length;o+=e)i.push(String.fromCharCode.apply(null,n.subarray(o,o+e)));return i.join("")}return String.fromCharCode.apply(null,n)}function i(r){for(var t=new Array(r),n=0;r>n;n++)t[n]=o();return t}function o(){var o,s,f=r[a];if(0===(128&f))return a++,f;if(128===(240&f))return s=15&f,a++,t(s);if(144===(240&f))return s=15&f,a++,i(s);if(160===(224&f))return s=31&f,a++,e(s);if(224===(224&f))return o=u.getInt8(a),a++,o;switch(f){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return s=u.getUint8(a+1),a+=2,n(s);case 197:return s=u.getUint16(a+1),a+=3,n(s);case 198:return s=u.getUint32(a+1),a+=5,n(s);case 202:return o=u.getFloat32(a+1),a+=5,o;case 203:return o=u.getFloat64(a+1),a+=9,o;case 204:return o=r[a+1],a+=2,o;case 205:return o=u.getUint16(a+1),a+=3,o;case 206:return o=u.getUint32(a+1),a+=5,o;case 208:return o=u.getInt8(a+1),a+=2,o;case 209:return o=u.getInt16(a+1),a+=3,o;case 210:return o=u.getInt32(a+1),a+=5,o;case 217:return s=u.getUint8(a+1),a+=2,e(s);case 218:return s=u.getUint16(a+1),a+=3,e(s);case 219:return s=u.getUint32(a+1),a+=5,e(s);case 220:return s=u.getUint16(a+1),a+=3,i(s);case 221:return s=u.getUint32(a+1),a+=5,i(s);case 222:return s=u.getUint16(a+1),a+=3,t(s);case 223:return s=u.getUint32(a+1),a+=5,t(s)}throw new Error("Unknown type 0x"+f.toString(16))}var a=0,u=new DataView(r.buffer);return o()}function W(r,t,n,e){switch(r){case 1:return h(t);case 2:return f(t);case 3:return l(t);case 4:return g(t);case 5:return s(t);case 6:return p(g(t),new Uint8Array(n));case 7:return p(g(t));case 8:return A(g(t));case 9:return M(g(t),g(e)[0]);case 10:return O(l(t),g(e)[0]);case 11:return y(l(t),g(e)[0]);case 12:return N(l(t),g(e)[0]);case 13:return N(f(t),g(e)[0]);case 14:return w(l(t));case 15:return w(f(t))}}function X(r,t){t=t||{};var n=t.ignoreFields,e={};return nr.forEach(function(t){var i=n?-1!==n.indexOf(t):!1,o=r[t];i||void 0===o||(o instanceof Uint8Array?e[t]=W.apply(null,k(o)):e[t]=o);}),e}function J(r){return String.fromCharCode.apply(null,r).replace(/\0/g,"")}function K(r,t,n){n=n||{};var e,i,o,a,u,s,f=n.firstModelOnly,c=t.onModel,d=t.onChain,l=t.onGroup,v=t.onAtom,g=t.onBond,L=0,h=0,y=0,m=0,p=0,U=-1,b=r.chainNameList,I=r.secStructList,w=r.insCodeList,C=r.sequenceIndexList,A=r.atomIdList,x=r.bFactorList,M=r.altLocList,F=r.occupancyList,S=r.bondAtomList,E=r.bondOrderList;for(e=0,i=r.chainsPerModel.length;i>e&&!(f&&L>0);++e){var N=r.chainsPerModel[L];for(c&&c({chainCount:N,modelIndex:L}),o=0;N>o;++o){var O=r.groupsPerChain[h];if(d){var T=J(r.chainIdList.subarray(4*h,4*h+4)),k=null;b&&(k=J(b.subarray(4*h,4*h+4))),d({groupCount:O,chainIndex:h,modelIndex:L,chainId:T,chainName:k});}for(a=0;O>a;++a){var j=r.groupList[r.groupTypeList[y]],q=j.atomNameList.length;if(l){var D=null;I&&(D=I[y]);var P=null;r.insCodeList&&(P=String.fromCharCode(w[y]));var z=null;C&&(z=C[y]),l({atomCount:q,groupIndex:y,chainIndex:h,modelIndex:L,groupId:r.groupIdList[y],groupType:r.groupTypeList[y],groupName:j.groupName,singleLetterCode:j.singleLetterCode,chemCompType:j.chemCompType,secStruct:D,insCode:P,sequenceIndex:z});}for(u=0;q>u;++u){if(v){var B=null;A&&(B=A[m]);var V=null;x&&(V=x[m]);var G=null;M&&(G=String.fromCharCode(M[m]));var R=null;F&&(R=F[m]),v({atomIndex:m,groupIndex:y,chainIndex:h,modelIndex:L,atomId:B,element:j.elementList[u],atomName:j.atomNameList[u],formalCharge:j.formalChargeList[u],xCoord:r.xCoordList[m],yCoord:r.yCoordList[m],zCoord:r.zCoordList[m],bFactor:V,altLoc:G,occupancy:R});}m+=1;}if(g){var H=j.bondAtomList;for(u=0,s=j.bondOrderList.length;s>u;++u)g({atomIndex1:m-q+H[2*u],atomIndex2:m-q+H[2*u+1],bondOrder:j.bondOrderList[u]});}y+=1;}h+=1;}if(p=U+1,U=m-1,g&&S)for(u=0,s=S.length;s>u;u+=2){var W=S[u],X=S[u+1];(W>=p&&U>=W||X>=p&&U>=X)&&g({atomIndex1:W,atomIndex2:X,bondOrder:E?E[u/2]:null});}L+=1;}}function Q(r){return o(R(r))}function Y(r,t){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?H(r):r,X(n,t)}function Z(r,t,n,e){function i(){try{var r=Y(o.response);n(r);}catch(t){e(t);}}var o=new XMLHttpRequest;o.addEventListener("load",i,!0),o.addEventListener("error",e,!0),o.responseType="arraybuffer",o.open("GET",t+r.toUpperCase()),o.send();}function $(r,t,n){Z(r,or,t,n);}function _(r,t,n){Z(r,ar,t,n);}var rr=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],tr=["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"],nr=rr.concat(tr),er="v1.1.0dev",ir="//mmtf.rcsb.org/v1.0/",or=ir+"full/",ar=ir+"reduced/";r.encode=Q,r.decode=Y,r.traverse=K,r.fetch=$,r.fetchReduced=_,r.version=er,r.fetchUrl=or,r.fetchReducedUrl=ar,r.encodeMsgpack=o,r.encodeMmtf=R,r.decodeMsgpack=H,r.decodeMmtf=X;});
  }(mmtf, mmtf.exports));

  var MMTF = mmtf.exports;

  function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$6 = chem.Complex,
      Chain$1 = chem.Chain,
      Atom$1 = chem.Atom,
      Element$6 = chem.Element,
      Helix$1 = chem.Helix,
      Sheet$1 = chem.Sheet,
      Strand$1 = chem.Strand,
      Bond$2 = chem.Bond,
      Assembly$1 = chem.Assembly,
      Molecule$6 = chem.Molecule;

  var ArrayComparator = /*#__PURE__*/function () {
    function ArrayComparator(original) {
      _classCallCheck(this, ArrayComparator);

      this._original = Array.from(original);

      this._original.sort();

      this._sum = 0;

      for (var i = 0; i < this._original.length; ++i) {
        this._sum += this._original[i];
      }
    }

    _createClass(ArrayComparator, [{
      key: "compare",
      value: function compare(candidate) {
        var len = candidate.length;

        if (len !== this._original.length) {
          return false;
        }

        var sum = 0;
        var i;

        for (i = 0; i < len; ++i) {
          sum += candidate[i];
        }

        if (sum !== this._sum) {
          return false;
        }

        var sorted = Array.from(candidate);
        sorted.sort();

        for (i = 0; i < len; ++i) {
          if (sorted[i] !== this._original[i]) {
            return false;
          }
        }

        return true;
      }
    }]);

    return ArrayComparator;
  }();

  ArrayComparator.prototype.constructor = ArrayComparator;
  var StructuralElementType = StructuralElement.Type;
  var secStructToType = [StructuralElementType.HELIX_PI, StructuralElementType.BEND, StructuralElementType.HELIX_ALPHA, StructuralElementType.STRAND, StructuralElementType.HELIX_310, StructuralElementType.BRIDGE, StructuralElementType.TURN, StructuralElementType.COIL];

  function getFirstByte(buf) {
    var bytes = new Uint8Array(buf, 0, 1);
    return bytes[0];
  }

  var MMTFParser = /*#__PURE__*/function (_Parser) {
    _inherits(MMTFParser, _Parser);

    var _super = _createSuper$m(MMTFParser);

    function MMTFParser(data, options) {
      var _this;

      _classCallCheck(this, MMTFParser);

      _this = _super.call(this, data, options);
      _this._options.fileType = 'mmtf';
      return _this;
    }

    _createClass(MMTFParser, [{
      key: "_onModel",
      value: function _onModel(_modelData) {}
    }, {
      key: "_onChain",
      value: function _onChain(chainData) {
        if (chainData.modelIndex !== 0) {
          return;
        }

        var chain = new Chain$1(this._complex, chainData.chainName);
        this._complex._chains[chainData.chainIndex] = chain;
        chain._index = chainData.chainIndex;
      }
    }, {
      key: "_onGroup",
      value: function _onGroup(groupData) {
        if (groupData.modelIndex !== 0) {
          return;
        }

        if (this.settings.now.nowater) {
          if (groupData.groupName === 'HOH' || groupData.groupName === 'WAT') {
            return;
          }
        }

        var chain = this._complex._chains[groupData.chainIndex];
        var icode = !groupData.insCode.charCodeAt(0) ? '' : groupData.insCode;
        var residue = chain.addResidue(groupData.groupName, groupData.groupId, icode);
        residue._index = groupData.groupIndex;

        this._updateSecStructure(this._complex, residue, groupData);
      }
    }, {
      key: "_onAtom",
      value: function _onAtom(atomData) {
        if (atomData.modelIndex !== 0) {
          return;
        }

        var altLoc = !atomData.altLoc.charCodeAt(0) ? '' : atomData.altLoc;
        var atom = new Atom$1(atomData.groupIndex, atomData.atomName, Element$6.getByName(atomData.element.toUpperCase()), new THREE__namespace.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord), Element$6.Role[atomData.atomName], false, atomData.atomId, altLoc, atomData.occupancy, atomData.bFactor, atomData.formalCharge);
        this._complex._atoms[atomData.atomIndex] = atom;
        atom.index = atomData.atomIndex;
        this._serialAtomMap[atomData.atomId] = atom;
      }
    }, {
      key: "_onBond",
      value: function _onBond(bondData) {
        var right = Math.max(bondData.atomIndex1, bondData.atomIndex2);

        if (right >= this._complex._atoms.length) {
          return;
        }

        var left = Math.min(bondData.atomIndex1, bondData.atomIndex2);

        this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, Bond$2.BondType.UNKNOWN, true);
      }
    }, {
      key: "_updateSecStructure",
      value: function _updateSecStructure(complex, residue, groupData) {
        var helixClasses = [3, -1, 1, -1, 5];

        if (!___default["default"].isUndefined(groupData) && groupData.secStruct === this._ssType) {
          residue._secondary = this._ssStruct;

          if (this._ssStruct) {
            this._ssStruct.term = residue;
          }

          return;
        }

        if (!___default["default"].isUndefined(groupData)) {
          var type = secStructToType[groupData.secStruct];
          this._ssType = groupData.secStruct;
          this._ssStart = residue;
          var struct = null;

          switch (this._ssType) {
            case -1:
            case 7:
              break;

            case 0:
            case 2:
            case 4:
              struct = new Helix$1(helixClasses[this._ssType], residue, residue, 0, '', '', 0);

              complex._helices.push(struct);

              break;

            case 3:
              {
                var sheet = new Sheet$1('', 0);

                complex._sheets.push(sheet);

                struct = new Strand$1(sheet, residue, residue, 0, null, null);
                break;
              }

            default:
              if (type !== undefined) {
                struct = new StructuralElement(type, residue, residue);
              }

              break;
          }

          this._ssStruct = struct;
          residue._secondary = struct;

          if (struct) {
            complex.structures.push(struct);
          }
        }
      }
    }, {
      key: "_updateMolecules",
      value: function _updateMolecules(mmtfData) {
        var entities = mmtfData.entityList;

        if (!entities) {
          return;
        }

        var chainsInModel0 = mmtfData.chainsPerModel[0];

        for (var i = 0; i < entities.length; i++) {
          var entity = entities[i];
          var chains = entity.chainIndexList;
          var residues = [];

          for (var j = 0; j < chains.length; j++) {
            var chainIndex = chains[j];

            if (chainIndex >= chainsInModel0) {
              continue;
            }

            var chain = this._complex._chains[chainIndex];
            residues = residues.concat(chain._residues.slice());
          }

          var molecule = new Molecule$6(this._complex, entity.description, i + 1);
          molecule.residues = residues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_traverse",
      value: function _traverse(mmtfData) {
        var self = this;
        var metadata = this._complex.metadata;
        metadata.id = mmtfData.structureId;
        metadata.title = [];
        metadata.title[0] = mmtfData.title;
        metadata.date = mmtfData.releaseDate;
        metadata.format = 'mmtf';
        var eventCallbacks = {
          onModel: function onModel(modelData) {
            self._onModel(modelData);
          },
          onChain: function onChain(chainData) {
            self._onChain(chainData);
          },
          onGroup: function onGroup(groupData) {
            self._onGroup(groupData);
          },
          onAtom: function onAtom(atomData) {
            self._onAtom(atomData);
          },
          onBond: function onBond(bondData) {
            self._onBond(bondData);
          }
        };
        this._ssType = -1;
        this._ssStruct = null;
        this._ssStart = null;
        MMTF.traverse(mmtfData, eventCallbacks);

        this._updateSecStructure(this._complex);

        this._updateMolecules(mmtfData);
      }
    }, {
      key: "_linkAtomsToResidues",
      value: function _linkAtomsToResidues() {
        for (var i = 0; i < this._complex._atoms.length; ++i) {
          var atom = this._complex._atoms[i];
          var residue = this._complex._residues[atom.residue];
          atom.residue = residue;

          residue._atoms.push(atom);
        }
      }
    }, {
      key: "_findSynonymousChains",
      value: function _findSynonymousChains() {
        var named = {};

        for (var i = 0; i < this._complex._chains.length; ++i) {
          var chain = this._complex._chains[i];
          var name = chain.getName();

          if (!named.hasOwnProperty(name)) {
            named[name] = [];
          }

          named[name].push(chain._index);
        }

        return named;
      }
    }, {
      key: "_parseAssemblyInfo",
      value: function _parseAssemblyInfo(mmtfData) {
        var i;
        var j;
        var k;
        var assemblies = [];
        var logger = this.logger;

        for (i = 0; i < mmtfData.bioAssemblyList.length; ++i) {
          var baInfo = mmtfData.bioAssemblyList[i];

          if (baInfo.transformList.length === 0) {
            continue;
          }

          var chains = baInfo.transformList[0].chainIndexList;
          var chainListCheck = new ArrayComparator(chains);
          var chainNames = {};

          for (j = 0; j < chains.length; ++j) {
            chainNames[this._complex._chains[chains[j]].getName()] = 1;
          }

          var allChains = [];
          var name = void 0;

          for (name in chainNames) {
            if (chainNames.hasOwnProperty(name)) {
              Array.prototype.push.apply(allChains, this._chainsByName[name]);
            }
          }

          if (!chainListCheck.compare(allChains)) {
            logger.debug('MMTF: Assembly is missing some of the synonymous chains. Skipping...');
          }

          var a = new Assembly$1(this._complex);

          for (name in chainNames) {
            if (chainNames.hasOwnProperty(name)) {
              a.addChain(name);
            }
          }

          a.addMatrix(new THREE__namespace.Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());

          for (j = 1; j < baInfo.transformList.length; ++j) {
            var transform = baInfo.transformList[j];

            if (!chainListCheck.compare(transform.chainIndexList)) {
              logger.debug('MMTF: Chain lists differ for different transforms in one assembly. Skipping...');
              continue;
            }

            var m = new THREE__namespace.Matrix4().fromArray(transform.matrix).transpose();

            for (k = 0; k < a.matrices.length; ++k) {
              if (a.matrices[k].equals(m)) {
                break;
              }
            }

            if (k === a.matrices.length) {
              a.addMatrix(m);
            }
          }

          a.finalize();
          assemblies.push(a);
        }

        return assemblies;
      }
    }, {
      key: "_markHeteroAtoms",
      value: function _markHeteroAtoms(mmtfData) {
        var chainsInModel0 = mmtfData.chainsPerModel[0];

        for (var i = 0; i < mmtfData.entityList.length; ++i) {
          var entity = mmtfData.entityList[i];

          if (entity.type !== 'polymer') {
            for (var j = 0; j < entity.chainIndexList.length; ++j) {
              var chainIndex = entity.chainIndexList[j];

              if (chainIndex >= chainsInModel0) {
                continue;
              }

              var chain = this._complex._chains[chainIndex];

              for (var k = 0; k < chain._residues.length; ++k) {
                var res = chain._residues[k];

                for (var m = 0; m < res._atoms.length; ++m) {
                  res._atoms[m].het = true;
                }
              }
            }
          }
        }
      }
    }, {
      key: "_joinSynonymousChains",
      value: function _joinSynonymousChains() {
        var i;
        var j;
        var primaryChainsArray = [];
        var primaryChainsHash = {};

        for (i = 0; i < this._complex._chains.length; ++i) {
          var chain = this._complex._chains[i];
          var name = chain.getName();

          if (!primaryChainsHash.hasOwnProperty(name)) {
            primaryChainsHash[name] = chain;
            chain._index = primaryChainsArray.length;
            primaryChainsArray.push(chain);
            continue;
          }

          var primary = primaryChainsHash[name];

          for (j = 0; j < chain._residues.length; ++j) {
            var residue = chain._residues[j];

            primary._residues.push(residue);

            residue._chain = primary;
          }
        }

        this._complex._chains = primaryChainsArray;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var mmtfData = MMTF.decode(this._data);
        this._complex = new Complex$6();
        this._serialAtomMap = {};

        this._traverse(mmtfData);

        this._linkAtomsToResidues();

        this._markHeteroAtoms(mmtfData);

        this._chainsByName = this._findSynonymousChains();
        Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));

        this._joinSynonymousChains();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });

        return this._complex;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isArrayBuffer(data) && (getFirstByte(data) | 1) === 0xdf;
      }
    }]);

    return MMTFParser;
  }(Parser);

  MMTFParser.formats = ['mmtf'];
  MMTFParser.extensions = ['.mmtf'];
  MMTFParser.binary = true;

  function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ParsingError = /*#__PURE__*/function (_Error) {
    _inherits(ParsingError, _Error);

    var _super = _createSuper$l(ParsingError);

    function ParsingError(message, line, column) {
      var _this;

      _classCallCheck(this, ParsingError);

      _this = _super.call(this, "data:".concat(line, ":").concat(column, ": ").concat(message));

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), ParsingError);
      }

      _this.name = 'ParsingError';
      _this.parseLine = line;
      _this.parseColumn = column;
      return _this;
    }

    return ParsingError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function _isWhitespace(ch) {
    return ch === 32 || ch === 10 || ch === 13 || ch === 9;
  }

  function _inlineIndexOf(ch0, str, idx) {
    var len = str.length;
    var ch = -1;

    while (idx < len) {
      ch = str.charCodeAt(idx);

      if (ch === ch0 || ch === 10) {
        break;
      }

      ++idx;
    }

    return ch === ch0 ? idx : -1;
  }

  function readCIF(source) {
    var i = 0;
    var j = 0;
    var n = source.length;
    var code = NaN;
    var newline = true;
    var line = 1;
    var column = 1;
    var begin;
    var state = 0;
    var result = {};
    var block = {};
    var keys = [];
    var keysCount = 0;
    var key = '';
    var values = [];
    var valuesCount = 0;
    var value;

    function _parseValue() {
      var val;

      if ((code === 46 || code === 63) && (i + 1 >= n || _isWhitespace(source.charCodeAt(i + 1)))) {
        ++column;
        ++i;
        return undefined;
      }

      if (newline && code === 59) {
        j = i;
        var lines = 0;

        do {
          j = _inlineIndexOf(10, source, j + 1);

          if (j === -1) {
            throw new ParsingError('Unterminated text block found', line, column);
          }

          ++lines;
        } while (j + 1 < n && source.charCodeAt(j + 1) !== code || j + 1 >= n);

        val = source.substring(i + 1, j).replace(/\r/g, '');
        i = j + 2;
        line += lines;
        column = 1;
        newline = false;
        return val;
      }

      if (code === 39 || code === 34) {
        j = i;

        do {
          j = _inlineIndexOf(code, source, j + 1);

          if (j === -1) {
            throw new ParsingError('Unterminated quoted string found', line, column);
          }
        } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)));

        val = source.substring(i + 1, j);
        column += j - i + 1;
        i = j + 1;
        return val;
      }

      j = i;

      while (j < n && !_isWhitespace(source.charCodeAt(j))) {
        ++j;
      }

      val = source.substring(i, j);
      column += j - i;
      i = j;
      var num = Number(val);

      if (!Number.isNaN(num)) {
        return num;
      }

      return val;
    }

    function _storeKey(tag) {
      keys[keysCount++] = tag;
    }

    function _storeValue(val) {
      var keyIndex = valuesCount % keysCount;
      values[keyIndex].push(val);
      ++valuesCount;
      return val;
    }

    while (i <= n) {
      code = source.charCodeAt(i);

      if (code === 13) ; else if (code === 10) {
        newline = true;
        ++line;
        column = 1;
      } else {
        if (code === 32 || code === 9) ; else if (code === 35) {
          i = _inlineIndexOf(10, source, i + 1);

          if (i === -1) {
            break;
          } else {
            continue;
          }
        } else if (state === 0) {
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            j = i + 5;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              result[source.substring(begin, i)] = block = {};
              state = 1;
              continue;
            } else {
              throw new ParsingError('Data block name missing', line, column);
            }
          } else if (Number.isNaN(code)) {
            break;
          } else {
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          }
        } else if (state === 1) {
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            state = 0;
            continue;
          } else if (code === 95) {
            j = i + 1;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              key = source.substring(begin, i);
              state = 2;
              continue;
            } else {
              throw new ParsingError('Tag name missing', line, column);
            }
          } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
            i += 5;
            column += 5;

            if (i < n && !_isWhitespace(source.charCodeAt(i))) {
              throw new ParsingError("Unexpected character in state ".concat(state), line, column);
            } else {
              keys = [];
              keysCount = 0;
              values = [];
              valuesCount = 0;
              state = 3;
              continue;
            }
          } else if (Number.isNaN(code)) {
            break;
          } else {
            throw new ParsingError("Unexpected character in state ".concat(state), line, column);
          }
        } else if (state === 2) {
          if (Number.isNaN(code)) {
            break;
          }

          value = _parseValue();

          ___default["default"].set(block, key, value);

          state = 1;
          continue;
        } else if (state === 3) {
          if (code === 95) {
            j = i + 1;
            begin = j;

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j;
            }

            column += j - i;
            i = j;

            if (begin < i) {
              _storeKey(source.substring(begin, i));

              continue;
            } else {
              throw new ParsingError('Tag name missing', line, column);
            }
          } else {
            if (keysCount > 0) {
              for (var keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
                value = [];
                values[keyIndex] = value;

                ___default["default"].set(block, keys[keyIndex], value);
              }

              state = 4;
              continue;
            }

            throw new ParsingError('Data tags are missing inside a loop', line, column);
          }
        } else if (state === 4) {
          if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
            state = 0;
          } else if (code === 95) {
            state = 1;
          } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
            state = 1;
          } else if (Number.isNaN(code)) {
            state = 0;
          } else {
            _storeValue(_parseValue());
          }

          continue;
        } else {
          throw new ParsingError("Unexpected internal state ".concat(state), line, column);
        }

        newline = false;
        ++column;
      }

      ++i;
    }

    if (state === 2) {
      throw new ParsingError("Unexpected end of file in state ".concat(state), line, column);
    }

    return result;
  }

  function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$5 = chem.Complex,
      Element$5 = chem.Element,
      Helix = chem.Helix,
      Sheet = chem.Sheet,
      Strand = chem.Strand,
      Assembly = chem.Assembly,
      Molecule$5 = chem.Molecule;
  var cRequiredAtomFields = ['auth_seq_id', 'Cartn_x', 'Cartn_y', 'Cartn_z', 'label_atom_id'];
  var cSecondaryCoding = {
    helx: 'helix',
    turn: 'turn',
    strn: 'strand'
  };

  function getTypeFromId(string) {
    var typeId = /[A-Za-z]+/.exec(string);

    if (!typeId) {
      return null;
    }

    return cSecondaryCoding[typeId[0].toLowerCase()];
  }

  function arrize(arrayLikeObject) {
    if (arrayLikeObject === null || arrayLikeObject === undefined || ___default["default"].isArray(arrayLikeObject)) {
      return arrayLikeObject;
    }

    return [arrayLikeObject];
  }

  function nameToElement(name) {
    var veryLong = name.trim().length === 4;
    return name.slice(0, veryLong ? 1 : 2).trim();
  }

  var AtomDataError = /*#__PURE__*/function (_Error) {
    _inherits(AtomDataError, _Error);

    var _super = _createSuper$k(AtomDataError);

    function AtomDataError(message) {
      var _this;

      _classCallCheck(this, AtomDataError);

      _this = _super.call(this);
      _this.name = 'AtomDataError';
      _this.message = message;
      return _this;
    }

    return AtomDataError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function _getOperations(operList) {
    if (!operList) {
      return null;
    }

    var idc = arrize(operList.id);
    var matrix = operList.matrix,
        vector = operList.vector;

    if (!idc || !matrix || !vector) {
      return null;
    }

    var ops = [];

    for (var i = 0, n = idc.length; i < n; ++i) {
      var mtx = new THREE__namespace.Matrix4();
      var elements = mtx.elements;

      for (var row = 0; row < 3; ++row) {
        var matrixData = matrix[row + 1];
        elements[row] = arrize(matrixData[1])[i];
        elements[row + 4] = arrize(matrixData[2])[i];
        elements[row + 8] = arrize(matrixData[3])[i];
        elements[row + 12] = arrize(vector[row + 1])[i];
      }

      ops[idc[i]] = mtx;
    }

    return ops;
  }

  function _extractOperations(assemblyGen, opsDict) {
    assemblyGen = ___default["default"].isString(assemblyGen) ? assemblyGen : "".concat(assemblyGen);
    var l = assemblyGen.replace(/\)\s*\(/g, '!').replace(/[()']/g, '');
    var groupStr = l.split('!');
    var gps = [];

    for (var grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
      var gr = groupStr[grIdx].split(',');
      var gp = [];
      var idx = 0;

      for (var i = 0, n = gr.length; i < n; ++i) {
        var s = gr[i];

        if (s.includes('-')) {
          var es = s.split('-');
          var j = parseInt(es[0], 10);
          var m = parseInt(es[1], 10);

          for (; j <= m; ++j) {
            gp[idx++] = opsDict[j];
          }
        } else {
          gp[idx++] = opsDict[s];
        }
      }

      gps.push(gp);
    }

    var matrices = [];
    var cnt = 0;

    function traverse(level, mtx) {
      for (var ii = 0, nn = gps[level].length; ii < nn; ++ii) {
        var newMtx = mtx ? mtx.clone() : new THREE__namespace.Matrix4();
        newMtx.multiplyMatrices(gps[level][ii], newMtx);

        if (level === 0) {
          matrices[cnt++] = newMtx;
        } else {
          traverse(level - 1, newMtx);
        }
      }
    }

    traverse(gps.length - 1);
    return matrices;
  }

  var CIFParser = /*#__PURE__*/function (_Parser) {
    _inherits(CIFParser, _Parser);

    var _super2 = _createSuper$k(CIFParser);

    function CIFParser(data, options) {
      var _this2;

      _classCallCheck(this, CIFParser);

      _this2 = _super2.call(this, data, options);
      _this2.asymDict = {};
      _this2.molecules = [];
      _this2._options.fileType = 'cif';
      return _this2;
    }

    _createClass(CIFParser, [{
      key: "parseSync",
      value: function parseSync() {
        this.logger.info('Parsing CIF file..');
        var data = readCIF(this._data);
        return this._toComplex(data);
      }
    }, {
      key: "_toComplex",
      value: function _toComplex(cifData) {
        var complex = new Complex$5();
        var complexData = cifData[Object.keys(cifData)[0]];

        this._extractAtoms(complex, complexData);

        this._extractSecondary(complex, complexData);

        this._extractAssemblies(complex, complexData);

        this._extractMolecules(complex, complexData);

        this._extractMetadata(complex, complexData);

        complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing
        });
        return complex;
      }
    }, {
      key: "_extractMetadata",
      value: function _extractMetadata(complex, complexData) {
        var metadata = complex.metadata;
        metadata.id = complexData.entry.id;
        metadata.classification = complexData.struct_keywords.pdbx_keywords;
        var databaserev = complexData.database_PDB_rev;
        metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : '';
        metadata.format = 'cif';
        metadata.title = [];
        metadata.title[0] = complexData.struct.title;
      }
    }, {
      key: "_extractMolecules",
      value: function _extractMolecules(complex, complexData) {
        var molData = complexData.entity;
        var names = arrize(molData.pdbx_description);
        var count = names.length;
        var i;

        for (i = 0; i < count; i++) {
          if (this.molecules[i]) {
            this.molecules[i].name = names[i];
          } else {
            this.molecules[i] = {
              name: names[i],
              residues: []
            };
          }
        }

        var molecules = complex.getMolecules();

        for (i = 0; i < count; i++) {
          var molecule = this.molecules[i];
          molecules[i] = new Molecule$5(complex, molecule.name, i + 1);
          molecules[i].residues = molecule.residues;
        }
      }
    }, {
      key: "_extractAtoms",
      value: function _extractAtoms(complex, complexData) {
        var atomData = complexData.atom_site;

        if (!atomData) {
          throw new AtomDataError('CIF parsing error: atom_site is not specified!');
        }

        for (var f = 0, n = cRequiredAtomFields.length; f < n; ++f) {
          if (!atomData[cRequiredAtomFields[f]]) {
            throw new AtomDataError("CIF parsing error: requires field ".concat(cRequiredAtomFields[f], " not found!"));
          }
        }

        var asymDict = this.asymDict;
        var resIdc = arrize(atomData.auth_seq_id);
        var x = arrize(atomData.Cartn_x);
        var y = arrize(atomData.Cartn_y);
        var z = arrize(atomData.Cartn_z);
        var names = arrize(atomData.label_atom_id);
        var count = names.length;
        var group = arrize(atomData.group_PDB) || [];
        var chainIdc = arrize(atomData.auth_asym_id) || [];
        var chainLabelIdc = arrize(atomData.label_asym_id) || [];
        var serials = arrize(atomData.id) || [];
        var iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
        var resNames = arrize(atomData.label_comp_id) || [];
        var elements = arrize(atomData.type_symbol) || [];
        var tempFactors = arrize(atomData.B_iso_or_equiv) || [];
        var occupancies = arrize(atomData.occupancy) || [];
        var charges = arrize(atomData.pdbx_formal_charge) || [];
        var altLocs = arrize(atomData.label_alt_id) || [];
        var models = arrize(atomData.pdbx_PDB_model_num) || [];
        var molecules = arrize(atomData.label_entity_id) || [];
        var chain = null;
        var residue = null;

        for (var i = 0; i < count; ++i) {
          var model = models[i] || 1;

          if (model !== 1) {
            continue;
          }

          var chainID = String(chainIdc[i] || ' ');

          if (!chain || chain.getName() !== chainID) {
            chain = complex.getChain(chainID) || complex.addChain(chainID);
          }

          asymDict[String(chainLabelIdc[i] || ' ')] = chainID;
          var resSeq = resIdc[i];
          var iCode = String(iCodes[i] || ' ');
          var resName = String(resNames[i] || '');

          if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
            residue = chain.addResidue(resName, resSeq, iCode);
            var moleculeIdx = molecules[i] - 1;
            var entity = this.molecules[moleculeIdx];

            if (!entity) {
              this.molecules[moleculeIdx] = {
                name: '',
                residues: []
              };
              entity = this.molecules[moleculeIdx];
            }

            entity.residues.push(residue);
          }

          var name = names[i];
          var element = elements[i] || nameToElement(name);
          var type = Element$5.getByName(element);
          var role = Element$5.Role[name.trim()];
          var xyz = new THREE__namespace.Vector3(x[i], y[i], z[i]);
          var het = group[i] === 'HETATM' || false;
          var serial = serials[i] || i;
          var tempFactor = tempFactors[i] || 0.0;
          var occupancy = occupancies[i] || 0.0;
          var altLoc = String(altLocs[i] || '');
          var charge = charges[i] || 0;
          residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
        }
      }
    }, {
      key: "_extractSecondary",
      value: function _extractSecondary(complex, complexData) {
        if (complexData.struct_conf) {
          this._extractConfs(complex, complexData.struct_conf);
        }

        if (complexData.struct_sheet_range) {
          this._extractSheets(complex, complexData.struct_sheet_range);
        }
      }
    }, {
      key: "_extractSheets",
      value: function _extractSheets(complex, sheetData) {
        var asymDict = this.asymDict;

        if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
          return;
        }

        var sheets = complex._sheets;

        function getSheet(name) {
          var n = sheets.length;

          for (var i = 0; i < n; ++i) {
            if (sheets[i]._name === name) {
              return sheets[i];
            }
          }

          sheets[n] = new Sheet(name, 0);
          return sheets[n];
        }

        var sheetNames = arrize(sheetData.sheet_id);
        var strandNames = arrize(sheetData.id);
        var starts = arrize(sheetData.beg_auth_seq_id);
        var ends = arrize(sheetData.end_auth_seq_id);
        var chains = arrize(sheetData.beg_label_asym_id);
        var stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
        var endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];

        for (var i = 0, n = strandNames.length; i < n; ++i) {
          var chain = complex.getChain(asymDict[chains[i]]);
          var sheet = getSheet(sheetNames[i]);
          var startIdx = starts[i];
          var endIdx = ends[i];
          var startICode = stICodes[i] || ' ';
          var endICode = endICodes[i] || ' ';
          var start = chain.findResidue(startIdx, startICode);
          var end = chain.findResidue(endIdx, endICode);

          if (!start || !end) {
            continue;
          }

          var strand = new Strand(sheet, start[0], end[0], 0, null, null);
          var residues = chain.getResidues();

          for (var r = start[1]; r <= end[1]; ++r) {
            residues[r]._secondary = strand;
          }

          sheet.addStrand(strand);
          complex.structures.push(strand);
        }
      }
    }, {
      key: "_extractConfs",
      value: function _extractConfs(complex, helicesData) {
        var asymDict = this.asymDict;

        if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
          return;
        }

        var types = arrize(helicesData.conf_type_id);
        var starts = arrize(helicesData.beg_auth_seq_id);
        var stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
        var ends = arrize(helicesData.end_auth_seq_id);
        var endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
        var comments = arrize(helicesData.details) || [];
        var lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
        var helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
        var names = arrize(helicesData.id) || [];
        var chains = arrize(helicesData.beg_label_asym_id);

        for (var i = 0, n = types.length; i < n; ++i) {
          var type = getTypeFromId(types[i]);

          if (!type) {
            continue;
          }

          var name = names[i] || types[i];
          var chain = complex.getChain(asymDict[chains[i]]);
          var startIdx = starts[i];
          var endIdx = ends[i];
          var startICode = stICodes[i] || ' ';
          var endICode = endICodes[i] || ' ';
          var start = chain.findResidue(startIdx, startICode);
          var end = chain.findResidue(endIdx, endICode);

          if (!start || !end) {
            continue;
          }

          var comment = comments[i] || '';
          var length = lengths[i] || 0;
          var helixClass = helixClasses[i] || ' ';
          var struct = void 0;

          if (type === 'helix') {
            var idx = complex._helices.length;
            struct = new Helix(helixClass, start[0], end[0], idx, name, comment, length);
            complex.addHelix(struct);
            complex.structures.push(struct);
          } else if (type === 'turn') {
            struct = new StructuralElement(StructuralElement.Type.TURN, start[0], end[0]);
            complex.structures.push(struct);
          } else {
            struct = null;
          }

          if (!struct) {
            continue;
          }

          var residues = chain.getResidues();

          for (var r = start[1]; r <= end[1]; ++r) {
            residues[r]._secondary = struct;
          }
        }
      }
    }, {
      key: "_extractAssemblies",
      value: function _extractAssemblies(complex, complexData) {
        var asymDict = this.asymDict;
        var asmGen = complexData.pdbx_struct_assembly_gen;

        if (!asmGen) {
          return;
        }

        var asmIdx = arrize(asmGen.assembly_id);
        var asmOper = arrize(asmGen.oper_expression);
        var asmList = arrize(asmGen.asym_id_list);

        if (!asmIdx || !asmOper || !asmList) {
          return;
        }

        var operList = _getOperations(complexData.pdbx_struct_oper_list);

        if (!operList) {
          return;
        }

        for (var i = 0, n = asmIdx.length; i < n; ++i) {
          var asm = new Assembly(complex);

          var assemblyOps = _extractOperations(asmOper[i], operList);

          var entries = asmList[i].split(',');

          for (var ii = 0, nn = entries.length; ii < nn; ++ii) {
            var chain = entries[ii].trim();

            if (chain.length > 0) {
              asm.addChain(asymDict[chain]);
            }
          }

          asm.matrices = assemblyOps;
          complex.units.push(asm);
        }
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(data) && /^\s*data_/i.test(data);
      }
    }]);

    return CIFParser;
  }(Parser);

  CIFParser.formats = ['cif', 'mmcif'];
  CIFParser.extensions = ['.cif', '.mmcif'];

  var valueType = {
    singular: 0,
    vector: 1,
    array: 2,
    buffer: 3
  };

  var VolumeModel = /*#__PURE__*/function () {
    function VolumeModel() {
      _classCallCheck(this, VolumeModel);

      _defineProperty(this, "_xyz2crs", []);

      _defineProperty(this, "_origin", new THREE__namespace.Vector3(0, 0, 0));

      this._header = {};
      this._boxSize = new THREE__namespace.Vector3();
      this._boxStart = new THREE__namespace.Vector3();
      this._header.delta = {};
      this._header.extent = [];
      this._header.nstart = [];
      this._header.grid = [];
      this._header.crs2xyz = [];
      this._header.cellDims = new THREE__namespace.Vector3();
      this._header.angles = [];
      this._header.origin = new THREE__namespace.Vector3(0, 0, 0);
      this._header.dmin = 0;
      this._header.dmean = 0;
      this._header.dmax = 0;
    }

    _createClass(VolumeModel, [{
      key: "_typedCheck",
      value: function _typedCheck() {
        if (___default["default"].isTypedArray(this._buff)) {
          this._buff = this._buff.buffer;
        } else if (!___default["default"].isArrayBuffer(this._buff)) {
          throw new TypeError('Expected ArrayBuffer or TypedArray');
        }
      }
    }, {
      key: "_fillHeader",
      value: function _fillHeader(headerFormat, arrays) {
        for (var key in headerFormat) {
          if (headerFormat.hasOwnProperty(key)) {
            switch (headerFormat[key][0]) {
              case valueType.singular:
                this._header[key] = arrays[headerFormat[key][1]][headerFormat[key][2]];
                break;

              case valueType.array:
                this._parseArray(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);

                break;

              case valueType.vector:
                this._parseVector(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);

                break;

              case valueType.buffer:
                this._header[key] = new Uint8Array(arrays[headerFormat[key][1]], [headerFormat[key][2]] * 4, [headerFormat[key][3]] * 4);
                break;
            }
          }
        }
      }
    }, {
      key: "_parseVector",
      value: function _parseVector(vector, arr, pos) {
        var _ref = [arr[pos], arr[pos + 1], arr[pos + 2]];
        vector.x = _ref[0];
        vector.y = _ref[1];
        vector.z = _ref[2];
      }
    }, {
      key: "_parseArray",
      value: function _parseArray(vector, arr, pos) {
        vector[0] = arr[pos];
        vector[1] = arr[pos + 1];
        vector[2] = arr[pos + 2];
      }
    }, {
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {}
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {}
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {}
    }, {
      key: "_getAxis",
      value: function _getAxis() {
        var header = this._header;
        var xScale = header.cellDims.x / header.grid[0];
        var yScale = header.cellDims.y / header.grid[1];
        var zScale = header.cellDims.z / header.grid[2];

        var _header$angles = _slicedToArray(header.angles, 3),
            alpha = _header$angles[0],
            beta = _header$angles[1],
            gamma = _header$angles[2];

        var z1 = Math.cos(beta);
        var z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
        var z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);
        var xaxis = new THREE__namespace.Vector3(xScale, 0, 0);
        var yaxis = new THREE__namespace.Vector3(Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0);
        var zaxis = new THREE__namespace.Vector3(z1 * zScale, z2 * zScale, z3 * zScale);
        return [xaxis, yaxis, zaxis];
      }
    }, {
      key: "_getXYZdim",
      value: function _getXYZdim() {
        return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
      }
    }, {
      key: "_getVolumeInfo",
      value: function _getVolumeInfo() {
        var volInfo = ___default["default"].pick(this._header, ['dmean', 'dmin', 'dmax', 'sd', 'delta']);

        volInfo.obtuseAngle = this._header.angles.map(function (angle) {
          return Number(angle >= Math.PI / 2);
        });
        return volInfo;
      }
    }, {
      key: "_setBoxParams",
      value: function _setBoxParams(xaxis, yaxis, zaxis) {
        var _this = this;

        var shiftX = 0;
        var shiftY = 0;

        var _this$_header$angles = _slicedToArray(this._header.angles, 3),
            alpha = _this$_header$angles[0],
            beta = _this$_header$angles[1],
            gamma = _this$_header$angles[2];

        if (gamma >= Math.PI / 2) {
          shiftX += Math.abs(yaxis.x);
        }

        if (beta >= Math.PI / 2) {
          shiftX += Math.abs(zaxis.x);
        }

        if (alpha >= Math.PI / 2) {
          shiftY += Math.abs(zaxis.y);
        }

        this._boxStart = new THREE__namespace.Vector3(this._origin.x - shiftX, this._origin.y - shiftY, this._origin.z);
        this._boxSize = new THREE__namespace.Vector3(Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x), Math.abs(yaxis.y) + Math.abs(zaxis.y), Math.abs(zaxis.z));

        var delta = function delta(axe, proj) {
          return Math.abs(axe[proj]) / _this._boxSize[proj];
        };

        this._header.delta.x = delta(yaxis, 'x');
        this._header.delta.y = delta(zaxis, 'x');
        this._header.delta.z = delta(zaxis, 'y');
      }
    }, {
      key: "_getXYZbox",
      value: function _getXYZbox() {
        return new THREE__namespace.Box3(this._boxStart.clone(), this._boxStart.clone().add(this._boxSize));
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {}
    }, {
      key: "parse",
      value: function parse(data) {
        this._parseHeader(data);

        this._setOrigins();

        return new Volume$2(Float32Array, this._getXYZdim(), this._getXYZbox(), 1, this._toXYZData(), this._getVolumeInfo());
      }
    }]);

    return VolumeModel;
  }();

  function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var CCP4Header = {
    extent: [valueType.array, 'u32', 0],
    type: [valueType.singular, 'u32', 3],
    nstart: [valueType.array, 'i32', 4],
    grid: [valueType.array, 'u32', 7],
    cellDims: [valueType.vector, 'f32', 10],
    angles: [valueType.array, 'f32', 13],
    crs2xyz: [valueType.array, 'i32', 16],
    dmin: [valueType.singular, 'f32', 19],
    dmax: [valueType.singular, 'f32', 20],
    dmean: [valueType.singular, 'f32', 21],
    ispg: [valueType.singular, 'u32', 22],
    nsymbt: [valueType.singular, 'u32', 23],
    lksflg: [valueType.singular, 'u32', 24],
    customData: [valueType.buffer, 'buffer', 25, 9],
    origin: [valueType.vector, 'f32', 34],
    map: [valueType.buffer, 'buffer', 52, 1],
    machine: [valueType.singular, 'u32', 53],
    sd: [valueType.singular, 'f32', 54],
    nlabel: [valueType.singular, 'f32', 55],
    label: [valueType.buffer, 'buffer', 56, 200]
  };

  var Ccp4Model = /*#__PURE__*/function (_VolumeModel) {
    _inherits(Ccp4Model, _VolumeModel);

    var _super = _createSuper$j(Ccp4Model);

    function Ccp4Model() {
      _classCallCheck(this, Ccp4Model);

      return _super.apply(this, arguments);
    }

    _createClass(Ccp4Model, [{
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {
        this._buff = _buffer;

        this._typedCheck();

        var arrays = {};
        arrays.u32 = new Uint32Array(this._buff, 0, 56);
        arrays.i32 = new Int32Array(this._buff, 0, 56);
        arrays.f32 = new Float32Array(this._buff, 0, 56);
        arrays.buffer = this._buff;
        var header = this._header;

        this._fillHeader(CCP4Header, arrays);

        header.angles.forEach(function (angle, i, a) {
          a[i] *= Math.PI / 180.0;
        });
      }
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {
        var header = this._header;

        if (header.cellDims.x === 0.0 && header.cellDims.y === 0.0 && header.cellDims.z === 0.0) {
          header.cellDims.set(1.0, 1.0, 1.0);
        }

        var crs2xyz = this._header.crs2xyz;

        if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
          crs2xyz[0] = 1;
          crs2xyz[1] = 2;
          crs2xyz[2] = 3;
        }

        var xyz2crs = this._xyz2crs;
        xyz2crs[crs2xyz[0] - 1] = 0;
        xyz2crs[crs2xyz[1] - 1] = 1;
        xyz2crs[crs2xyz[2] - 1] = 2;
      }
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {
        var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = _slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2];

        this._setAxisIndices();

        var header = this._header;
        var xyz2crs = this._xyz2crs;

        if (header.origin.x === 0.0 && header.origin.y === 0.0 && header.origin.z === 0.0) {
          this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]]);

          this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]]);

          this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]]);
        } else {
          this._origin = header.origin;
        }

        xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1);
        yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1);
        zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1);

        if (header.type === 2) {
          this._data = new Float32Array(this._buff, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
        } else {
          throw new Error("CCP4: Unsupported format ".concat(header.type));
        }

        this._setBoxParams(xaxis, yaxis, zaxis);
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {
        var header = this._header;
        var data = this._data;
        var xyz2crs = this._xyz2crs;
        var xyzData = new Float32Array(data.length);

        var dim = this._getXYZdim();

        var xSize = dim[0];
        var ySize = dim[1];
        var crsIdx = 0;
        var coord = [];
        var x;
        var y;
        var z;

        for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
          for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
            for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
              x = coord[xyz2crs[0]];
              y = coord[xyz2crs[1]];
              z = coord[xyz2crs[2]];
              xyzData[x + xSize * (y + ySize * z)] = data[crsIdx];
            }
          }
        }

        return xyzData;
      }
    }]);

    return Ccp4Model;
  }(VolumeModel);

  var CCP4Parser = /*#__PURE__*/function (_Parser) {
    _inherits(CCP4Parser, _Parser);

    var _super2 = _createSuper$j(CCP4Parser);

    function CCP4Parser(data, options) {
      var _this;

      _classCallCheck(this, CCP4Parser);

      _this = _super2.call(this, data, options);
      _this._options.fileType = 'ccp4';
      _this.model = new Ccp4Model();
      return _this;
    }

    _createClass(CCP4Parser, [{
      key: "parseSync",
      value: function parseSync() {
        return this.model.parse(this._data);
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(_data) {
        return false;
      }
    }]);

    return CCP4Parser;
  }(Parser);

  CCP4Parser.formats = ['ccp4'];
  CCP4Parser.extensions = ['.ccp4', '.map', '.mrc'];
  CCP4Parser.binary = true;

  function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$4 = chem.Complex,
      Element$4 = chem.Element,
      Molecule$4 = chem.Molecule;

  var XYZParser = /*#__PURE__*/function (_Parser) {
    _inherits(XYZParser, _Parser);

    var _super = _createSuper$i(XYZParser);

    function XYZParser(data, options) {
      var _this;

      _classCallCheck(this, XYZParser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._atomsInf = null;
      _this._options.fileType = 'xyz';
      _this._fileName = options.name;
      return _this;
    }

    _createClass(XYZParser, [{
      key: "_parseToAtomsInf",
      value: function _parseToAtomsInf(source) {
        var endnAtoms = source.indexOf('\n');
        var nAtoms = parseInt(source.substring(0, endnAtoms), 10);
        var endComment = source.indexOf('\n', endnAtoms + 1);
        var comment = source.slice(endnAtoms + 1, endComment).trim();

        if (comment.length === 0) {
          comment = this._fileName;
        }

        var startAtomsInf = endComment + source.substring(endComment).search(/\S/);
        this._atomsInf = source.substring(startAtomsInf).split(/[\s,]*\n[\s,]*/);

        if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
          this._complex.error = {
            message: 'wrong number of atoms'
          };
          return;
        }

        this._complex.metadata.format = 'xyz';
        this._complex.name = comment;
      }
    }, {
      key: "_parseAtomsInf",
      value: function _parseAtomsInf() {
        var het = true;
        var altLoc = ' ';
        var occupancy = 1;
        var tempFactor = 1;
        var charge = 0;

        var chain = this._complex.addChain('A');

        var residue = chain.addResidue('UNK', 1, ' ');

        for (var i = 0; i < this._atomsInf.length - 1; i++) {
          var words = this._atomsInf[i].split(/[\s,]+/);

          if (words.length !== 4) {
            this._complex.error = {
              message: 'missed parameters'
            };
            break;
          }

          var serial = i + 1;
          var name = words[0];
          var xyz = new THREE__namespace.Vector3(parseFloat(words[1]), parseFloat(words[2]), parseFloat(words[3]));
          var type = Element$4.getByName(name);
          var role = undefined;
          residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
        }

        var molecule = new Molecule$4(this._complex, this._complex.name, 1);
        molecule.residues = residue;
        this._complex._molecules[0] = molecule;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$4();

        this._parseToAtomsInf(this._data);

        this._parseAtomsInf();

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });

        this._complex = null;
        this._atomsInf = null;

        if (result.error) {
          throw new Error(result.error.message);
        }

        return result;
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(data) && /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data);
      }
    }]);

    return XYZParser;
  }(Parser);

  _defineProperty(XYZParser, "formats", ['xyz']);

  _defineProperty(XYZParser, "extensions", ['.xyz']);

  function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$3 = chem.Complex,
      Element$3 = chem.Element;

  var PubChemParser = /*#__PURE__*/function (_Parser) {
    _inherits(PubChemParser, _Parser);

    var _super = _createSuper$h(PubChemParser);

    function PubChemParser(data, options) {
      var _this;

      _classCallCheck(this, PubChemParser);

      _this = _super.call(this, data, options);
      _this._options.fileType = 'pubchem+json';
      return _this;
    }

    _createClass(PubChemParser, [{
      key: "parseSync",
      value: function parseSync() {
        this.logger.info('Parsing PubChem JSON file...');
        return this._toComplex(JSON.parse(this._data));
      }
    }, {
      key: "_toComplex",
      value: function _toComplex(jsonData) {
        var complex = new Complex$3();
        var complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];

        if (complexData) {
          this._extractAtoms(complex, complexData);

          complex.finalize({
            needAutoBonding: false,
            detectAromaticLoops: this.settings.now.aromatic,
            enableEditing: this.settings.now.editing
          });
        }

        return complex;
      }
    }, {
      key: "_extractAtoms",
      value: function _extractAtoms(complex, complexData) {
        var aids = complexData.atoms && complexData.atoms.aid;
        var elements = aids && complexData.atoms.element;

        if (!elements || aids.length !== elements.length) {
          throw new Error('Unable to parse atom elements');
        }

        elements = ___default["default"].fromPairs(___default["default"].zip(aids, elements));
        var atoms = {};
        var coords = complexData.coords && complexData.coords[0];
        var model = coords && coords.conformers && coords.conformers[0];
        var xs = model && model.x;
        var ys = model && model.y;
        var zs = model && model.z || [];
        aids = coords && coords.aid;

        if (!aids || !xs || !ys) {
          throw new Error('Coordinates are not found in the file');
        }

        var chain = complex.addChain(' ');
        var residue = chain.addResidue('UNK', 1, ' ');

        for (var i = 0, n = aids.length; i < n; ++i) {
          var aid = aids[i];
          var element = Element$3.ByAtomicNumber[elements[aid]];
          var xyz = new THREE__namespace.Vector3(xs[i], ys[i], zs[i] || 0.0);
          atoms[aid] = residue.addAtom(element.name, element, xyz, undefined, true, aid, ' ', 1.0, 0.0, 0);
        }

        var aids1 = complexData.bonds && complexData.bonds.aid1;
        var aids2 = complexData.bonds && complexData.bonds.aid2;
        var orders = complexData.bonds && complexData.bonds.order || [];

        if (!aids1 || !aids2 || aids1.length !== aids2.length) {
          return;
        }

        for (var j = 0, m = aids1.length; j < m; ++j) {
          complex.addBond(atoms[aids1[j]], atoms[aids2[j]], orders[j] || 1, 0, true);
        }
      }
    }], [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(data) && data[0] === '{';
      }
    }]);

    return PubChemParser;
  }(Parser);

  PubChemParser.formats = ['pubchem', 'pubchem+json', 'pc'];
  PubChemParser.extensions = ['.json'];

  var SDFStream = /*#__PURE__*/function () {
    function SDFStream(data) {
      _classCallCheck(this, SDFStream);

      this._strings = data.split(/\r?\n|\r/);
      this._currentStart = 0;
      this._currentStringIndx = 0;
    }

    _createClass(SDFStream, [{
      key: "setStart",
      value: function setStart(start) {
        if (start >= this._strings.length) {
          this._currentStart = this._strings.length - 1;
          this._currentStringIndx = this._strings.length - 1;
        } else {
          this._currentStart = start;
          this._currentStringIndx = start;
        }
      }
    }, {
      key: "getNextString",
      value: function getNextString() {
        return this._strings[++this._currentStringIndx];
      }
    }, {
      key: "getCurrentString",
      value: function getCurrentString() {
        return this._strings[this._currentStringIndx];
      }
    }, {
      key: "getStringFromStart",
      value: function getStringFromStart(numb) {
        this._currentStringIndx = this._currentStart + numb;
        return this._strings[this._currentStart + numb];
      }
    }, {
      key: "findNextDataItem",
      value: function findNextDataItem() {
        var curStr = this.getNextString();
        var res = false;

        while (!___default["default"].isUndefined(curStr) && curStr.trim() !== '$$$$') {
          if (curStr.match(/>\s+<(.*)>/)) {
            res = true;
            break;
          }

          curStr = this.getNextString();
        }

        return res;
      }
    }, {
      key: "findNextCompoundStart",
      value: function findNextCompoundStart() {
        var curStr = this.getCurrentString();

        while (!___default["default"].isUndefined(curStr) && curStr.trim() !== '$$$$') {
          curStr = this.getNextString();
        }

        this.setStart(++this._currentStringIndx);
        return this.probablyHaveDataToParse();
      }
    }, {
      key: "probablyHaveDataToParse",
      value: function probablyHaveDataToParse() {
        return this._currentStringIndx < this._strings.length - 2;
      }
    }]);

    return SDFStream;
  }();

  function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$2 = chem.Complex,
      Element$2 = chem.Element,
      Bond$1 = chem.Bond,
      Molecule$3 = chem.Molecule;
  var chargeMap = [0, 3, 2, 1, 0, -1, -2, -3];
  var orderMap$1 = [0, 1, 2, 3, 1, 1, 1, 2];
  var typeMap$1 = [Bond$1.BondType.UNKNOWN, Bond$1.BondType.COVALENT, Bond$1.BondType.COVALENT, Bond$1.BondType.COVALENT, Bond$1.BondType.AROMATIC, Bond$1.BondType.UNKNOWN, Bond$1.BondType.AROMATIC, Bond$1.BondType.AROMATIC];
  var sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/;
  var sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/;
  var fileFormat = {
    SDF: 'sdf',
    MOL: 'mol'
  };
  var possibleNameTags = ['PUBCHEM_IUPAC_TRADITIONAL_NAME', /PUBCHEM_(.+)_NAME/, /(.+)name/, /(.+)NAME/];
  var possibleIDTags = ['PUBCHEM_COMPOUND_CID', 'id', 'ID', /.*CID/, /.*ID/, /.*id/];
  var possibleTitleTags = ['msg', 'MSG', 'message', 'title', 'description', 'desc'];
  var tagsNames = ['name', 'id', 'title'];
  var tags = {
    name: possibleNameTags,
    id: possibleIDTags,
    title: possibleTitleTags
  };

  function buildChainID(index) {
    if (!index) {
      return 'A';
    }

    var codes = [];

    while (index) {
      codes.push(65 + index % 26);
      index = Math.trunc(index / 26);
    }

    if (codes.length > 1) {
      codes.reverse();
      codes[0] -= 1;
    }

    return String.fromCharCode.apply(String, codes);
  }

  var SDFParser = /*#__PURE__*/function (_Parser) {
    _inherits(SDFParser, _Parser);

    var _super = _createSuper$g(SDFParser);

    function SDFParser(data, options) {
      var _this;

      _classCallCheck(this, SDFParser);

      _this = _super.call(this, data, options);
      _this._format = 'sdf';
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._molecules = null;
      _this._metadata = {};
      _this._metadata.molecules = [];
      _this._currentMolProps = {};
      _this._compoundIndx = -1;
      _this._assemblies = [];
      _this._atomsParsed = 0;
      _this._atomsIndexes = [];
      return _this;
    }

    _createClass(SDFParser, [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(data) && sdfAndMolRegexp.test(data);
      }
    }, {
      key: "_parseHeader",
      value: function _parseHeader(stream) {
        var molecule = {};
        molecule.name = stream.getStringFromStart(0);
        var date = parseInt(stream.getStringFromStart(1).substr(10, 6).trim(), 10);
        molecule.date = date.toString() || '';
        molecule.title = stream.getStringFromStart(2);

        this._metadata.molecules.push(molecule);
      }
    }, {
      key: "_parseAtoms",
      value: function _parseAtoms(stream, atomsNum) {
        var curStr;
        var serial = this._atomsParsed;
        var chainID = buildChainID(this._compoundIndx);
        var resName = 'UNK';
        var resSeq = 1;
        this._chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
        this._residue = this._chain.addResidue(resName, resSeq, ' ');

        for (var i = 0; i < atomsNum; i++) {
          curStr = stream.getNextString();
          serial++;
          var x = parseFloat(curStr.substr(0, 10));
          var y = parseFloat(curStr.substr(10, 10));
          var z = parseFloat(curStr.substr(20, 10));
          var charge = chargeMap[parseInt(curStr.substr(36, 3), 10)];
          var xyz = new THREE__namespace.Vector3(x, y, z);
          var name = curStr.substr(31, 3).trim().toUpperCase();
          var type = Element$2.getByName(name);

          if (!this._atomsIndexes[name]) {
            this._atomsIndexes[name] = 0;
          }

          this._atomsIndexes[name] += 1;
          name += this._atomsIndexes[name];

          this._residue.addAtom(name, type, xyz, undefined, true, serial, ' ', 1.0, 0.0, charge);
        }
      }
    }, {
      key: "_parseBonds",
      value: function _parseBonds(stream, bondsNum) {
        var curStr;

        for (var i = 0; i < bondsNum; i++) {
          curStr = stream.getNextString();

          var atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed;

          var atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed;

          var bondType = parseInt(curStr.substr(6, 3), 10);

          if (atom1 > atom2) {
            var _ref = [atom2, atom1];
            atom1 = _ref[0];
            atom2 = _ref[1];
          }

          this._complex.addBond(atom1, atom2, orderMap$1[bondType] || 1, typeMap$1[bondType] || Bond$1.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_parseMOL",
      value: function _parseMOL(stream) {
        this._compoundIndx++;

        this._parseHeader(stream);

        var countsLine = stream.getStringFromStart(3);
        var atomsNum = parseInt(countsLine.substr(0, 3), 10);
        var bondsNum = parseInt(countsLine.substr(3, 3), 10);

        this._parseAtoms(stream, atomsNum);

        this._parseBonds(stream, bondsNum);

        this._atomsParsed += atomsNum;
        this._metadata.molecules[this._compoundIndx]._residues = [];

        this._metadata.molecules[this._compoundIndx]._residues.push(this._residue);
      }
    }, {
      key: "_parseDataItem",
      value: function _parseDataItem(stream) {
        var tag = stream.getCurrentString();
        var data = [];
        var curStr = stream.getNextString();

        while (curStr.trim() !== '') {
          data.push(curStr);
          curStr = stream.getNextString();
        }

        if (data.length === 1) {
          var _data = data;

          var _data2 = _slicedToArray(_data, 1);

          data = _data2[0];
        }

        this._currentMolProps[tag.replace(/[<>]/g, '').trim()] = data;
      }
    }, {
      key: "_parseCompound",
      value: function _parseCompound(stream) {
        this._parseMOL(stream);

        if (this._format === fileFormat.SDF) {
          this._currentMolProps = {};

          while (stream.findNextDataItem()) {
            this._parseDataItem(stream);
          }

          if (Object.keys(this._currentMolProps).length !== 0) {
            var molecule = this._metadata.molecules[this._compoundIndx];
            molecule.props = this._currentMolProps;

            this._tryToUpdateMoleculeData(molecule);
          }
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap;
        var complex = this._complex;
        var bonds = complex._bonds;

        for (var j = 0; j < bonds.length; j++) {
          var bond = bonds[j];

          if (bond._right < bond._left) {
            console.log('_fixBondsArray: Logic error.');
          }

          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_buildAssemblies",
      value: function _buildAssemblies() {
        var chains = this._complex._chains;

        if (chains.length === 1) {
          return this._assemblies;
        }

        for (var i = 0; i < chains.length; i++) {
          var assembly = new Assembly$3(this._complex);
          var matrix = new THREE__namespace.Matrix4();
          assembly.addMatrix(matrix);
          assembly.addChain(chains[i]._name);

          this._assemblies.push(assembly);
        }

        return this._assemblies;
      }
    }, {
      key: "_buildMolecules",
      value: function _buildMolecules() {
        this._complex._molecules = [];
        var molecules = this._metadata.molecules;

        for (var i = 0; i < molecules.length; i++) {
          var molecule = new Molecule$3(this._complex, molecules[i].name, i + 1);
          molecule.residues = molecules[i]._residues;
          this._complex._molecules[i] = molecule;
        }

        return this._complex._molecules;
      }
    }, {
      key: "_searchTag",
      value: function _searchTag(tag, props) {
        for (var i = 0; i < props.length; i++) {
          if (tag instanceof RegExp && tag.test(props[i].tag) || tag === props[i].tag) {
            return props[i].data;
          }
        }

        return undefined;
      }
    }, {
      key: "_tryToFind",
      value: function _tryToFind(tagsList, props) {
        for (var j = 0; j < tagsList.length; j++) {
          var res = this._searchTag(tagsList[j], props);

          if (res) {
            return res;
          }
        }

        return undefined;
      }
    }, {
      key: "_tryToUpdateMoleculeData",
      value: function _tryToUpdateMoleculeData(molecule) {
        var res = false;

        for (var i = 0; i < tagsNames.length; i++) {
          var tagPossibleNames = tags[tagsNames[i]];

          var data = this._tryToFind(tagPossibleNames, molecule.props);

          if (data) {
            molecule[tagsNames[i]] = data;
            res = true;
          }
        }

        molecule.name = molecule.name || molecule.id;

        if (molecule.name.match(/^\d+$/)) {
          molecule.name = "CID: ".concat(molecule.name);
        }

        return res;
      }
    }, {
      key: "_finalizeMetadata",
      value: function _finalizeMetadata() {
        var molecules = this._metadata.molecules;
        var metadata = this._complex.metadata;
        var complex = this._complex;

        if (molecules.length === 1) {
          complex.name = molecules[0].name;
          metadata.title = molecules[0].title;
          metadata.date = molecules[0].date;
          metadata.properties = molecules[0].props;
        } else if (molecules.length > 1) {
          metadata.molecules = [];

          for (var i = 0; i < molecules.length; i++) {
            metadata.molecules.push({
              name: molecules[i].name,
              date: molecules[i].date,
              title: molecules[i].title,
              properties: molecules[i].props
            });
          }
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var serialAtomMap = this._serialAtomMap = {};
        var atoms = this._complex._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var atom = atoms[i];
          serialAtomMap[atom.serial] = atom;
        }

        this._complex._finalizeBonds();

        this._fixBondsArray();

        this._finalizeMetadata();

        this._buildAssemblies();

        this._complex.units = this._complex.units.concat(this._assemblies);

        this._buildMolecules();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: false,
          enableEditing: false,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "defineFormat",
      value: function defineFormat(data) {
        var format;

        if (sdfRegExp.test(data)) {
          format = fileFormat.SDF;
        } else {
          format = fileFormat.MOL;
        }

        return format;
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$2();
        var stream = new SDFStream(this._data);
        this._format = this.defineFormat(this._data);
        result.metadata.format = this._format;

        do {
          this._parseCompound(stream);
        } while (stream.findNextCompoundStart());

        this._finalize();

        return result;
      }
    }]);

    return SDFParser;
  }(Parser);
  SDFParser.formats = ['mol', 'sdf'];
  SDFParser.extensions = ['.mol', '.sdf'];

  function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var DSN6Header = {
    nstart: [valueType.array, 'i16', 0],
    extent: [valueType.array, 'i16', 3],
    grid: [valueType.array, 'i16', 6],
    cellDims: [valueType.vector, 'i16', 9],
    angles: [valueType.array, 'i16', 12],
    div: [valueType.singular, 'i16', 15],
    adder: [valueType.singular, 'i16', 16],
    scaleFactor: [valueType.singular, 'i16', 17]
  };

  var DSN6Model = /*#__PURE__*/function (_VolumeModel) {
    _inherits(DSN6Model, _VolumeModel);

    var _super = _createSuper$f(DSN6Model);

    function DSN6Model() {
      _classCallCheck(this, DSN6Model);

      return _super.apply(this, arguments);
    }

    _createClass(DSN6Model, [{
      key: "_parseHeader",
      value: function _parseHeader(_buffer) {
        this._buff = _buffer;

        this._typedCheck();

        var arrays = {};
        arrays.i16 = new Int16Array(this._buff);

        if (arrays.i16[18] !== 100) {
          for (var i = 0, n = arrays.i16.length; i < n; ++i) {
            var val = arrays.i16[i];
            arrays.i16[i] = (val & 0xff) << 8 | val >> 8 & 0xff;
          }
        }

        if (arrays.i16[18] !== 100) {
          throw new Error('DSN6: Incorrect format ');
        }

        var header = this._header;

        this._fillHeader(DSN6Header, arrays);

        header.cellDims.multiplyScalar(1.0 / header.scaleFactor);
        header.angles.forEach(function (angle, i, a) {
          a[i] *= Math.PI / 180.0 / header.scaleFactor;
        });
        header.div /= 100;
      }
    }, {
      key: "_setAxisIndices",
      value: function _setAxisIndices() {
        this._xyz2crs[0] = 0;
        this._xyz2crs[1] = 1;
        this._xyz2crs[2] = 2;
      }
    }, {
      key: "_setOrigins",
      value: function _setOrigins() {
        var header = this._header;

        var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = _slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2];

        this._setAxisIndices();

        this._origin.addScaledVector(xaxis, header.nstart[0]);

        this._origin.addScaledVector(yaxis, header.nstart[1]);

        this._origin.addScaledVector(zaxis, header.nstart[2]);

        xaxis.multiplyScalar(header.extent[0]);
        yaxis.multiplyScalar(header.extent[1]);
        zaxis.multiplyScalar(header.extent[2]);

        this._setBoxParams(xaxis, yaxis, zaxis);
      }
    }, {
      key: "_pointCalculate",
      value: function _pointCalculate(xyzData, byteBuffer, z, y, x, pos, i) {
        var header = this._header;

        if (x < header.extent[0] && y < header.extent[1] && z < header.extent[2]) {
          var idx = x + header.extent[0] * (y + header.extent[1] * z);
          xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div;
          ++pos.counter;
        } else {
          pos.counter += 8 - i;
          return false;
        }

        return true;
      }
    }, {
      key: "_blockCalculate",
      value: function _blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos) {
        for (var k = 0; k < 8; ++k) {
          var z = 8 * zBlock + k;

          for (var j = 0; j < 8; ++j) {
            var y = 8 * yBlock + j;
            var inRange = true;
            var i = 0;

            while (inRange && i < 8) {
              var x = 8 * xBlock + i;
              inRange = this._pointCalculate(xyzData, byteBuffer, z, y, x, pos, i);
              i++;
            }
          }
        }
      }
    }, {
      key: "_toXYZData",
      value: function _toXYZData() {
        var header = this._header;
        var byteBuffer = new Uint8Array(this._buff);
        var xyzData = new Float32Array(header.extent[0] * header.extent[1] * header.extent[2]);
        var blocks = new THREE__namespace.Vector3(header.extent[0] / 8, header.extent[1] / 8, header.extent[2] / 8);
        var pos = {};
        pos.counter = 512;

        for (var zBlock = 0; zBlock < blocks.z; ++zBlock) {
          for (var yBlock = 0; yBlock < blocks.y; ++yBlock) {
            for (var xBlock = 0; xBlock < blocks.x; ++xBlock) {
              this._blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos);
            }
          }
        }

        this._calculateInfoParams(xyzData);

        return xyzData;
      }
    }, {
      key: "_calculateInfoParams",
      value: function _calculateInfoParams(xyzData) {
        this._header.dmean /= xyzData.length;
        var dispersion = 0;
        var minDensity = xyzData[0];
        var maxDensity = xyzData[0];

        for (var j = 0; j < xyzData.length; j++) {
          dispersion += Math.pow(this._header.dmean - xyzData[j], 2);

          if (xyzData[j] < minDensity) {
            minDensity = xyzData[j];
          }

          if (xyzData[j] > maxDensity) {
            maxDensity = xyzData[j];
          }
        }

        this._header.sd = Math.sqrt(dispersion / xyzData.length);
        this._header.dmax = maxDensity;
        this._header.dmin = minDensity;
      }
    }]);

    return DSN6Model;
  }(VolumeModel);

  var DSN6Parser = /*#__PURE__*/function (_Parser) {
    _inherits(DSN6Parser, _Parser);

    var _super2 = _createSuper$f(DSN6Parser);

    function DSN6Parser(data, options) {
      var _this;

      _classCallCheck(this, DSN6Parser);

      _this = _super2.call(this, data, options);
      _this._options.fileType = 'dsn6';
      _this.model = new DSN6Model();
      return _this;
    }

    _createClass(DSN6Parser, [{
      key: "parseSync",
      value: function parseSync() {
        return this.model.parse(this._data);
      }
    }], [{
      key: "canParse",
      value: function canParse(data, options) {
        if (!data) {
          return false;
        }

        return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options, 'dsn6');
      }
    }, {
      key: "canProbablyParse",
      value: function canProbablyParse(_data) {
        return false;
      }
    }]);

    return DSN6Parser;
  }(Parser);

  DSN6Parser.formats = ['dsn6'];
  DSN6Parser.extensions = ['.dsn6', '.omap'];
  DSN6Parser.binary = true;

  function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var GROReader = /*#__PURE__*/function (_PDBStream) {
    _inherits(GROReader, _PDBStream);

    var _super = _createSuper$e(GROReader);

    function GROReader(data) {
      var _this;

      _classCallCheck(this, GROReader);

      _this = _super.call(this, data);
      _this._next = -1;

      _this.next();

      return _this;
    }

    _createClass(GROReader, [{
      key: "getNext",
      value: function getNext() {
        return this._next;
      }
    }]);

    return GROReader;
  }(PDBStream);

  function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex$1 = chem.Complex,
      Element$1 = chem.Element,
      Molecule$2 = chem.Molecule;

  var GROParser = /*#__PURE__*/function (_Parser) {
    _inherits(GROParser, _Parser);

    var _super = _createSuper$d(GROParser);

    function GROParser(data, options) {
      var _this;

      _classCallCheck(this, GROParser);

      _this = _super.call(this, data, options);
      _this._time = null;
      _this._numAtoms = null;
      _this._residueNumber = null;
      _this._residueName = '';
      _this._atomName = '';
      _this._atomNumber = null;
      _this._atomPosition = [];
      _this._atomVelocity = [];
      _this._complex = null;
      _this._molecules = [];
      _this._molecule = null;
      _this._options.filetype = 'gro';
      return _this;
    }

    _createClass(GROParser, [{
      key: "canProbablyParse",
      value: function canProbablyParse(data) {
        return ___default["default"].isString(this._data) && /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(data);
      }
    }, {
      key: "_parseTitle",
      value: function _parseTitle(line) {
        var metadata = this._complex.metadata;
        metadata.id = line.readLine().trim();
        metadata.name = metadata.id.slice(metadata.id.lastIndexOf('\\') + 1, metadata.id.lastIndexOf('.'));
        metadata.format = 'gro';
      }
    }, {
      key: "_parseNumberOfAtoms",
      value: function _parseNumberOfAtoms(line) {
        this._numAtoms = line.readInt(0, line.getNext());

        if (Number.isNaN(this._numAtoms)) {
          throw new Error('Line 2 is not representing atom number. Consider checking input file');
        }
      }
    }, {
      key: "_parseAtom",
      value: function _parseAtom(line) {
        this._residueNumber = line.readInt(1, 5);
        this._residueName = line.readString(6, 10).trim();
        this._atomName = line.readString(11, 15).trim();
        this._atomNumber = line.readInt(16, 20);
        var positionX = line.readFloat(21, 28) * 10;
        var positionY = line.readFloat(29, 36) * 10;
        var positionZ = line.readFloat(37, 45) * 10;

        if (Number.isNaN(positionX) || Number.isNaN(positionY) || Number.isNaN(positionZ)) {
          this._complex.error = {
            message: "Atom position is invalid in \"".concat(line.readLine(), "\"")
          };
          return;
        }

        var type = Element$1.getByName(this._atomName[0]);

        if (type.fullName === 'Unknown') {
          this._complex.error = {
            message: "".concat(this._atomName[0], " hasn't been recognised as an atom name.")
          };
          return;
        }

        var role = Element$1.Role[this._atomName];
        var chain = this._chain;

        if (!chain) {
          this._chain = chain = this._complex.addChain('A');
        }

        var residue = this._residue;

        if (!residue || residue.getSequence() !== this._residueNumber) {
          this._residue = residue = chain.addResidue(this._residueName, this._residueNumber, ' ');
        }

        this._atomPosition = new THREE__namespace.Vector3(positionX, positionY, positionZ);
        var het = true;
        var altLoc = ' ';
        var occupancy = 1;
        var tempFactor = 1;
        var charge = 0;
        residue.addAtom(this._atomName, type, this._atomPosition, role, het, this._atomNumber, altLoc, occupancy, tempFactor, charge);
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        var molecule = new Molecule$2(this._complex, this._complex.metadata.name, 1);
        molecule.residues = this._chain._residues;
        molecule._chains = this._chain;
        this._complex._molecules[0] = molecule;

        this._molecules.push(molecule);

        this._complex.finalize({
          needAutoBonding: true,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex$1();
        var reader = new GROReader(this._data);
        var counter = 0;

        this._parseTitle(reader);

        reader.next();

        this._parseNumberOfAtoms(reader);

        reader.next();

        for (counter = 0; counter < this._numAtoms; ++counter) {
          if (!reader.end()) {
            this._parseAtom(reader);

            reader.next();
          } else break;
        }

        if (counter < this._numAtoms) {
          this._complex.error = {
            message: 'File ended unexpectedly.'
          };
        }

        if (result.error) {
          throw new Error(result.error.message);
        }

        this._finalize();

        this._atomPosition = null;
        this._complex = null;
        this._molecules = null;
        this._molecule = null;
        return result;
      }
    }]);

    return GROParser;
  }(Parser);

  GROParser.formats = ['gro'];
  GROParser.extensions = ['.gro'];

  function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var Complex = chem.Complex,
      Element = chem.Element,
      Bond = chem.Bond,
      Molecule$1 = chem.Molecule;
  var orderMap = {
    un: 0,
    1: 1,
    2: 2,
    3: 3,
    ar: 1,
    am: 1,
    nc: 0,
    du: 1
  };
  var typeMap = {
    un: Bond.BondType.UNKNOWN,
    1: Bond.BondType.COVALENT,
    2: Bond.BondType.COVALENT,
    3: Bond.BondType.COVALENT,
    ar: Bond.BondType.AROMATIC,
    am: Bond.BondType.COVALENT,
    nc: Bond.BondType.UNKNOWN,
    du: Bond.BondType.COVALENT
  };
  var resNumberRegex = /\d+$/;
  var spacesRegex = /\s+/;

  function splitToFields(str) {
    return str.trim().split(spacesRegex);
  }

  var MOL2Parser = /*#__PURE__*/function (_Parser) {
    _inherits(MOL2Parser, _Parser);

    var _super = _createSuper$c(MOL2Parser);

    function MOL2Parser(data, options) {
      var _this;

      _classCallCheck(this, MOL2Parser);

      _this = _super.call(this, data, options);
      _this._complex = null;
      _this._chain = null;
      _this._residue = null;
      _this._compoundIndx = -1;
      _this._molecules = [];
      _this._molecule = null;
      _this._currPosIdx = 0;
      _this._currStartIdx = 0;
      _this._serialAtomMap = {};
      _this._options.fileType = 'mol2';
      return _this;
    }

    _createClass(MOL2Parser, [{
      key: "_parseRawStrings",
      value: function _parseRawStrings(data) {
        return data.split(/\r?\n|\r/);
      }
    }, {
      key: "_toStringFromStart",
      value: function _toStringFromStart(numb, MOL2Data) {
        var newPosIdx = this._currStartIdx + numb;
        this._currPosIdx = newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx;
      }
    }, {
      key: "_toHeaderString",
      value: function _toHeaderString(header, MOL2Data) {
        this._toStringFromStart(0, MOL2Data);

        while (this._currPosIdx < MOL2Data.length) {
          if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header))) {
            return;
          }

          this._currPosIdx++;
        }

        this._toStringFromStart(0, MOL2Data);
      }
    }, {
      key: "_toStringFromHeader",
      value: function _toStringFromHeader(header, numb, MOL2Data) {
        this._toHeaderString(header, MOL2Data);

        var newPosIdx = this._currPosIdx + numb;

        if (MOL2Data[this._currPosIdx].match("@<TRIPOS>".concat(header)) && newPosIdx < MOL2Data.length) {
          this._currPosIdx = newPosIdx;
        }
      }
    }, {
      key: "_setStart",
      value: function _setStart(startPos, MOL2Data) {
        if (startPos >= MOL2Data.length) {
          this._currStartIdx = this._currPosIdx = MOL2Data.length - 1;
        } else {
          this._currStartIdx = this._currPosIdx = startPos;
        }
      }
    }, {
      key: "_probablyHaveDataToParse",
      value: function _probablyHaveDataToParse(MOL2Data) {
        return this._currPosIdx < MOL2Data.length - 2;
      }
    }, {
      key: "_findNextCompoundStart",
      value: function _findNextCompoundStart(MOL2Data) {
        while (this._currPosIdx < MOL2Data.length && MOL2Data[this._currPosIdx].trim() !== '@<TRIPOS>MOLECULE>') {
          this._currPosIdx++;
        }

        this._setStart(++this._currPosIdx, MOL2Data);

        return this._probablyHaveDataToParse(MOL2Data);
      }
    }, {
      key: "_parseMolecule",
      value: function _parseMolecule(MOL2Data) {
        this._toHeaderString('MOLECULE', MOL2Data);

        var metadata = this._complex.metadata;
        metadata.name = MOL2Data[++this._currPosIdx];
        metadata.format = 'mol2';
        this._molecule = {
          _index: '',
          _chains: []
        };
        this._molecule._index = this._compoundIndx + 1;

        this._molecules.push(this._molecule);
      }
    }, {
      key: "_parseAtoms",
      value: function _parseAtoms(atomsNum, MOL2Data) {
        this._toHeaderString('ATOM', MOL2Data);

        for (var i = 0; i < atomsNum; i++) {
          var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);

          if (parsedStr.length < 6) {
            throw new Error('MOL2 parsing error: Not enough information to create atom!');
          }

          var atomId = parseInt(parsedStr[0], 10);
          var atomName = parsedStr[1];
          var x = parseFloat(parsedStr[2]);
          var y = parseFloat(parsedStr[3]);
          var z = parseFloat(parsedStr[4]);
          var element = parsedStr[5].split('.')[0].toUpperCase();
          var charge = 0;

          if (parsedStr.length >= 9) {
            charge = parseFloat(parsedStr[8]) || 0.0;
          }

          var chain = this._chain;

          if (!chain) {
            this._chain = chain = this._complex.getChain('A') || this._complex.addChain('A');
            this._residue = null;
          }

          if (!this._setResidue(parsedStr)) {
            continue;
          }

          var het = false;
          var altLoc = ' ';
          var occupancy = 1.0;
          var tempFactor = 0.0;
          var type = Element.getByName(element);
          var role = Element.Role[atomName];
          var xyz = new THREE__namespace.Vector3(x, y, z);

          this._residue.addAtom(atomName, type, xyz, role, het, atomId, altLoc, occupancy, tempFactor, charge);
        }
      }
    }, {
      key: "_setResidue",
      value: function _setResidue(parsedStr) {
        var resSeq = 1;
        var resName = 'UNK';

        if (parsedStr.length >= 7) {
          resSeq = parseInt(parsedStr[6], 10);
        }

        if (parsedStr.length >= 8 && parsedStr[7] !== '<0>') {
          resName = parsedStr[7].replace(resNumberRegex, '');
        }

        if (this.settings.now.nowater) {
          if (resName === 'HOH' || resName === 'WAT') {
            return false;
          }
        }

        var residue = this._residue;
        var chain = this._chain;

        if (!residue || residue.getSequence() !== resSeq) {
          this._residue = chain.addResidue(resName, resSeq, 'A');
        }

        return true;
      }
    }, {
      key: "_parseBonds",
      value: function _parseBonds(bondsNum, MOL2Data) {
        this._toHeaderString('BOND', MOL2Data);

        for (var i = 0; i < bondsNum; i++) {
          var parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);

          if (parsedStr.length < 3) {
            throw new Error('MOL2 parsing error: Missing information about bonds!');
          }

          var originAtomId = parseInt(parsedStr[1], 10);
          var targetAtomId = parseInt(parsedStr[2], 10);
          var bondType = parsedStr[3];

          if (originAtomId > targetAtomId) {
            var _ref = [targetAtomId, originAtomId];
            originAtomId = _ref[0];
            targetAtomId = _ref[1];
          }

          this._complex.addBond(originAtomId, targetAtomId, orderMap[bondType] || 0, typeMap[bondType] || Bond.BondType.UNKNOWN, true);
        }
      }
    }, {
      key: "_fixSerialAtoms",
      value: function _fixSerialAtoms() {
        var atoms = this._complex._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var atom = atoms[i];
          this._serialAtomMap[atom.serial] = atom;
        }
      }
    }, {
      key: "_fixBondsArray",
      value: function _fixBondsArray() {
        var serialAtomMap = this._serialAtomMap;
        var complex = this._complex;

        if (Object.keys(serialAtomMap).length === 0) {
          throw new Error('MOL2 parsing error: Missing atom information!');
        }

        var bonds = complex._bonds;

        for (var j = 0; j < bonds.length; j++) {
          var bond = bonds[j];
          bond._left = serialAtomMap[bond._left] || null;
          bond._right = serialAtomMap[bond._right] || null;
        }
      }
    }, {
      key: "_finalizeMolecules",
      value: function _finalizeMolecules() {
        var chain = this._complex._chains[0];
        this._complex._molecules = [];

        for (var i = 0; i < this._molecules.length; i++) {
          var currMolecule = this._molecules[i];
          var molResidues = chain._residues;
          var molecule = new Molecule$1(this._complex, currMolecule._name, i + 1);
          molecule.residues = molResidues;
          this._complex._molecules[i] = molecule;
        }
      }
    }, {
      key: "_finalize",
      value: function _finalize() {
        this._complex._finalizeBonds();

        this._fixSerialAtoms();

        this._fixBondsArray();

        this._finalizeMolecules();

        this._complex.finalize({
          needAutoBonding: false,
          detectAromaticLoops: this.settings.now.aromatic,
          enableEditing: this.settings.now.editing,
          serialAtomMap: this._serialAtomMap
        });
      }
    }, {
      key: "_parseCompound",
      value: function _parseCompound(MOL2Data) {
        this._compoundIndx++;

        this._parseMolecule(MOL2Data);

        this._toStringFromHeader('MOLECULE', 2, MOL2Data);

        var parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex);

        var atomsNum = parsedStr[0];
        var bondsNum = parsedStr[1];

        this._parseAtoms(atomsNum, MOL2Data);

        this._parseBonds(bondsNum, MOL2Data);
      }
    }, {
      key: "parseSync",
      value: function parseSync() {
        var result = this._complex = new Complex();

        var MOL2Data = this._parseRawStrings(this._data);

        do {
          this._parseCompound(MOL2Data);
        } while (this._findNextCompoundStart(MOL2Data));

        this._finalize();

        return result;
      }
    }]);

    return MOL2Parser;
  }(Parser);

  MOL2Parser.formats = ['mol2'];
  MOL2Parser.extensions = ['.mol2', '.ml2', '.sy2'];

  var parsers = new ParserList([PDBParser, CIFParser, MMTFParser, XYZParser, CMLParser, PubChemParser, SDFParser, CCP4Parser, DSN6Parser, GROParser, MOL2Parser]);

  function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var ExporterList = /*#__PURE__*/function (_EntityList) {
    _inherits(ExporterList, _EntityList);

    var _super = _createSuper$b(ExporterList);

    function ExporterList() {
      var someExporters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      _classCallCheck(this, ExporterList);

      return _super.call(this, someExporters, ['formats']);
    }

    _createClass(ExporterList, [{
      key: "find",
      value: function find(specs) {
        var list = [];

        if (specs.format) {
          list = this._dict.formats[specs.format.toLowerCase()] || [];
        }

        return _toConsumableArray(list);
      }
    }]);

    return ExporterList;
  }(EntityList);

  var Exporter = /*#__PURE__*/function () {
    function Exporter(source, options) {
      _classCallCheck(this, Exporter);

      this._source = source;
      this._options = options || {};
      this._abort = false;
    }

    _createClass(Exporter, [{
      key: "exportSync",
      value: function exportSync() {
        throw new Error('Exporting to this source is not implemented');
      }
    }, {
      key: "export",
      value: function _export() {
        var _this = this;

        return new Promise(function (resolve, reject) {
          setTimeout(function () {
            try {
              if (_this._abort) {
                return reject(new Error('Export aborted'));
              }

              return resolve(_this.exportSync());
            } catch (error) {
              return reject(error);
            }
          });
        });
      }
    }, {
      key: "abort",
      value: function abort() {
        this._abort = true;
      }
    }]);

    return Exporter;
  }();
  makeContextDependent(Exporter.prototype);

  var PDBResult = /*#__PURE__*/function () {
    function PDBResult() {
      _classCallCheck(this, PDBResult);

      this._resultArray = [];
      this._currentStr = -1;
      this._tag = null;
      this._fixedNumeration = false;
      this._numeration = false;
      this._tagStrNum = 0;
    }

    _createClass(PDBResult, [{
      key: "getResult",
      value: function getResult() {
        this.writeString('\n', 81, 81);
        return this._resultArray.join('');
      }
    }, {
      key: "_currentStrLength",
      value: function _currentStrLength() {
        var curStr = this._resultArray[this._currentStr];
        return curStr ? curStr.length : 0;
      }
    }, {
      key: "newTag",
      value: function newTag(tag, numeration) {
        if (!tag) {
          this._tag = null;
        } else {
          this._tag = tag;
        }

        if (!___default["default"].isUndefined(numeration)) {
          if (___default["default"].isNumber(numeration)) {
            this._tagStrNum = numeration;
            this._numeration = true;
            this._fixedNumeration = true;
          } else if (___default["default"].isBoolean(numeration)) {
            this._tagStrNum = 0;
            this._numeration = numeration;
            this._fixedNumeration = false;
          }
        } else {
          this._numeration = false;
          this._fixedNumeration = false;
          this._tagStrNum = 0;
        }
      }
    }, {
      key: "newString",
      value: function newString(tag) {
        this.writeString('\n', 81, 81);
        this._currentStr++;

        this._resultArray.push('');

        if (tag) {
          this.writeString(tag, 1, 6);
        } else if (this._tag) {
          this.writeString(this._tag, 1, 6);
        }

        if (this._numeration) {
          if (!this._fixedNumeration) {
            this._tagStrNum++;
          }

          if (this._tagStrNum !== 1) {
            this.writeString(this._tagStrNum.toString(), 10, 8);
          }
        }
      }
    }, {
      key: "writeEntireString",
      value: function writeEntireString(string, maxStrPos, concat) {
        if (!maxStrPos) {
          maxStrPos = 81;
        }

        for (var j = 0; j < string.length; j++) {
          if (this._currentStrLength() === maxStrPos && j !== string.length - 1) {
            this.newString();

            if (concat) {
              this.writeString(concat.tag, concat.begin, concat.end);
            }
          }

          if (string[j] === '\n') {
            this.newString();
          } else {
            this.writeString(string[j]);
          }
        }
      }
    }, {
      key: "writeString",
      value: function writeString(string, begin, end) {
        var curStr = this._resultArray[this._currentStr];
        var str;
        var curStrLength = curStr ? curStr.length : 0;

        if (___default["default"].isUndefined(string)) {
          return;
        }

        if (!___default["default"].isNumber(begin)) {
          begin = curStrLength + 1;
        }

        if (!___default["default"].isNumber(end)) {
          end = curStrLength + string.length;
        }

        if (!___default["default"].isString(string)) {
          str = string.toString();
        } else {
          str = string;
        }

        var finish = begin < end ? end : begin;
        var start = begin < end ? begin : end;

        if (str.length > Math.abs(begin - end) + 1) {
          str = str.substr(0, Math.abs(begin - end + 1));
        }

        if (start > curStrLength + 1) {
          this._resultArray[this._currentStr] += ' '.repeat(start - curStrLength - 1);
        } else if (start <= curStrLength) {
          var cStr = this._resultArray[this._currentStr];
          this._resultArray[this._currentStr] = cStr.slice(0, start - 1);
        }

        if (end < begin) {
          var len = begin - end + 1;
          str = ' '.repeat(len - str.length) + str;
        }

        if (start === 11 && this._numeration && this._tagStrNum !== 1) {
          str = " ".concat(str);
        }

        this._resultArray[this._currentStr] += str;
        curStr = this._resultArray[this._currentStr];

        if (finish > curStr.length) {
          this._resultArray[this._currentStr] += ' '.repeat(finish - curStr.length);
        }
      }
    }, {
      key: "writeBondsArray",
      value: function writeBondsArray(bonds, atom) {
        var bondsArrays = this._getSubArrays(bonds, 4);

        for (var k = 0; k < bondsArrays.length; k++) {
          this.newString();
          this.writeString(atom.serial, 11, 7);

          for (var j = 0; j < bondsArrays[k].length; j++) {
            var serial = bondsArrays[k][j]._left.serial === atom.serial ? bondsArrays[k][j]._right.serial : bondsArrays[k][j]._left.serial;
            this.writeString(serial, 16 + 5 * j, 12 + 5 * j);
          }
        }
      }
    }, {
      key: "_getSubArrays",
      value: function _getSubArrays(arr, subArraySize) {
        var subArrays = [];

        for (var i = 0; i < arr.length; i += subArraySize) {
          subArrays.push(arr.slice(i, i + subArraySize));
        }

        return subArrays;
      }
    }, {
      key: "writeMatrix",
      value: function writeMatrix(matrix, matrixIndx, tag) {
        for (var j = 0; j < 3; j++) {
          this.newString();
          this.writeString(tag, 14, 18);
          this.writeString((j + 1).toString(), 19, 19);
          this.writeString(matrixIndx.toString(), 23, 20);

          for (var k = 0; k < 3; k++) {
            var _numb = parseFloat(matrix.elements[j * 4 + k]).toFixed(6);

            this.writeString(_numb.toString(), 33 + k * 10, 24 + k * 10);
          }

          var numb = parseFloat(matrix.elements[j * 4 + 3]).toFixed(5);
          this.writeString(numb.toString(), 68, 55);
        }
      }
    }, {
      key: "writeMatrices",
      value: function writeMatrices(matrices, string) {
        if (!matrices) {
          return;
        }

        var matrix = new THREE.Matrix4();

        for (var j = 0; j < matrices.length; j++) {
          matrix.copy(matrices[j]).transpose();
          this.writeMatrix(matrix, j + 1, string);
        }
      }
    }]);

    return PDBResult;
  }();

  function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var PDBExporter = /*#__PURE__*/function (_Exporter) {
    _inherits(PDBExporter, _Exporter);

    var _super = _createSuper$a(PDBExporter);

    function PDBExporter(source, options) {
      var _this;

      _classCallCheck(this, PDBExporter);

      _this = _super.call(this, source, options);
      _this._tags = ['HEADER', 'TITLE', 'COMPND', 'REMARK', 'HELIX', 'SHEET', 'ATOM and HETATM', 'CONECT'];
      _this._result = null;
      _this._tagExtractors = {
        HEADER: _this._extractHEADER,
        TITLE: _this._extractTITLE,
        'ATOM and HETATM': _this._extractATOM,
        CONECT: _this._extractCONECT,
        COMPND: _this._extractCOMPND,
        REMARK: _this._extractREMARK,
        HELIX: _this._extractHELIX,
        SHEET: _this._extractSHEET
      };
      _this._stringForRemark350 = 'COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\n' + 'BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\n' + 'MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\n' + 'GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\n' + 'CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.';
      _this._stringForRemark290 = 'CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\n' + 'THE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\n' + 'RECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\n' + 'RELATED MOLECULES.';
      return _this;
    }

    _createClass(PDBExporter, [{
      key: "exportSync",
      value: function exportSync() {
        var result = new PDBResult();

        if (!this._source) {
          return this._result;
        }

        for (var i = 0; i < this._tags.length; i++) {
          var tag = this._tags[i];
          var func = this._tagExtractors[tag];

          if (___default["default"].isFunction(func)) {
            func.call(this, result);
          }
        }

        this._result = result.getResult();
        return this._result;
      }
    }, {
      key: "_extractHEADER",
      value: function _extractHEADER(result) {
        if (!this._source.metadata) {
          return;
        }

        var metadata = this._source.metadata;
        result.newTag('HEADER');
        result.newString();

        if (metadata.classification) {
          result.writeString(metadata.classification, 11, 50);
        }

        if (metadata.date) {
          result.writeString(metadata.date, 51, 59);
        }

        if (metadata.id) {
          result.writeString(metadata.id, 63, 66);
        }
      }
    }, {
      key: "_extractTITLE",
      value: function _extractTITLE(result) {
        if (!this._source.metadata) {
          return;
        }

        var metadata = this._source.metadata;

        if (!metadata.title) {
          return;
        }

        result.newTag('TITLE', true);

        for (var i = 0; i < metadata.title.length; i++) {
          result.newString();
          result.writeString(metadata.title[i], 11, 80);
        }
      }
    }, {
      key: "_extractCONECT",
      value: function _extractCONECT(result) {
        if (!this._source._atoms) {
          return;
        }

        var atoms = this._source._atoms;
        result.newTag('CONECT');

        for (var i = 0; i < atoms.length; i++) {
          var fixedBonds = atoms[i].bonds.filter(function (bond) {
            return bond._fixed;
          });

          if (fixedBonds.length !== 0) {
            result.writeBondsArray(fixedBonds.reverse(), atoms[i]);
          }
        }
      }
    }, {
      key: "_extractSHEET",
      value: function _extractSHEET(result) {
        if (!this._source._sheets) {
          return;
        }

        result.newTag('SHEET');
        var sheets = this._source._sheets;

        for (var i = 0; i < sheets.length; i++) {
          if (sheets[i]._strands) {
            var strands = sheets[i]._strands;

            for (var j = 0; j < strands.length; j++) {
              result.newString();
              result.writeString(j + 1, 10, 8);
              result.writeString(sheets[i]._name, 14, 12);
              result.writeString(strands.length, 16, 15);
              result.writeString(strands[j].init._type._name, 18, 20);
              result.writeString(strands[j].init._chain._name, 22, 22);
              result.writeString(strands[j].init._sequence, 26, 23);
              result.writeString(strands[j].init._icode, 27, 27);
              result.writeString(strands[j].term._type._name, 29, 31);
              result.writeString(strands[j].init._chain._name, 33, 33);
              result.writeString(strands[j].term._sequence, 37, 34);
              result.writeString(strands[j].term._icode, 38, 38);
              result.writeString(strands[j].sense, 40, 39);
            }
          }
        }
      }
    }, {
      key: "_extractHELIX",
      value: function _extractHELIX(result) {
        if (!this._source._helices) {
          return;
        }

        result.newTag('HELIX');
        var helices = this._source._helices;

        for (var i = 0; i < helices.length; i++) {
          var helix = helices[i];

          var helixClass = ___default["default"].invert(typeByPDBHelixClass);

          result.newString();
          result.writeString(helix.serial, 10, 8);
          result.writeString(helix.name, 14, 12);
          result.writeString(helix.init._type._name, 16, 18);
          result.writeString(helix.init._chain._name, 20, 20);
          result.writeString(helix.init._sequence, 25, 22);
          result.writeString(helix.init._icode, 26, 26);
          result.writeString(helix.term._type._name, 28, 30);
          result.writeString(helix.term._chain._name, 32, 32);
          result.writeString(helix.term._sequence, 37, 34);
          result.writeString(helix.term._icode, 38, 38);
          result.writeString(helixClass[helix.type], 40, 39);
          result.writeString(helix.comment, 41, 70);
          result.writeString(helix.length, 76, 72);
        }
      }
    }, {
      key: "_extractATOM",
      value: function _extractATOM(result) {
        if (!this._source._atoms) {
          return;
        }

        var atoms = this._source._atoms;

        for (var i = 0; i < atoms.length; i++) {
          var tag = atoms[i].het ? 'HETATM' : 'ATOM';
          result.newString(tag);
          var startIndx = atoms[i].element.name.length > 1 || atoms[i].name.length > 3 ? 13 : 14;
          result.writeString(atoms[i].serial, 11, 7);
          result.writeString(atoms[i].name, startIndx, 16);
          result.writeString(String.fromCharCode(atoms[i].location), 17, 17);
          result.writeString(atoms[i].residue._type._name, 20, 18);
          result.writeString(atoms[i].residue._chain._name, 22, 22);
          result.writeString(atoms[i].residue._sequence, 26, 23);
          result.writeString(atoms[i].residue._icode, 27, 27);
          result.writeString(atoms[i].position.x.toFixed(3), 38, 31);
          result.writeString(atoms[i].position.y.toFixed(3), 46, 39);
          result.writeString(atoms[i].position.z.toFixed(3), 54, 47);
          result.writeString(atoms[i].occupancy.toFixed(2), 60, 55);
          result.writeString(atoms[i].temperature.toFixed(2), 66, 61);
          result.writeString(atoms[i].element.name, 78, 77);

          if (atoms[i].charge) {
            result.writeString(atoms[i].charge, 79, 80);
          }
        }
      }
    }, {
      key: "_extractCOMPND",
      value: function _extractCOMPND(result) {
        if (!this._source._molecules) {
          return;
        }

        var molecules = this._source._molecules;
        result.newTag('COMPND', true);

        for (var i = 0; i < molecules.length; i++) {
          var chains = this._getMoleculeChains(molecules[i]);

          result.newString();
          result.writeString("MOL_ID: ".concat(molecules[i].index, ";"), 11, 80);
          result.newString();
          result.writeString("MOLECULE: ".concat(molecules[i].name, ";"), 11, 80);
          result.newString();
          result.writeString('CHAIN: ', 11, 18);
          var chainsString = "".concat(chains.join(', '), ";");
          result.writeEntireString(chainsString, 81);
        }
      }
    }, {
      key: "_extractREMARK",
      value: function _extractREMARK(result) {
        this._Remark290(result);

        this._Remark350(result);
      }
    }, {
      key: "_Remark290",
      value: function _Remark290(result) {
        if (!this._source.symmetry) {
          return;
        }

        if (this._source.symmetry.length !== 0) {
          var matrices = this._source.symmetry;
          result.newTag('REMARK', 290);
          result.newString();
          result.newString();
          result.writeEntireString(this._stringForRemark290);
          result.writeMatrices(matrices, 'SMTRY');
          result.newString();
          result.newString();
          result.writeString('REMARK: NULL', 11, 80);
        }
      }
    }, {
      key: "_Remark350",
      value: function _Remark350(result) {
        if (!this._source.units) {
          return;
        }

        var units = this._source.units;
        var biomolIndx = 0;
        result.newTag('REMARK', 350);
        result.newString();
        result.newString();
        result.writeEntireString(this._stringForRemark350);
        var assemblies = units.filter(function (unit) {
          return unit instanceof Assembly$3;
        });

        for (var i = 0; i < assemblies.length; i++) {
          result.newString();
          result.newString();
          biomolIndx++;
          result.writeString("BIOMOLECULE: ".concat(biomolIndx), 11, 80);
          var chains = assemblies[i].chains.join(', ');
          result.newString();
          result.writeString('APPLY THE FOLLOWING TO CHAINS: ');
          result.writeEntireString(chains, 69, {
            tag: 'AND CHAINS: ',
            begin: 31,
            end: 42
          });
          var matrices = assemblies[i].matrices;
          result.writeMatrices(matrices, 'BIOMT');
        }
      }
    }, {
      key: "_getMoleculeChains",
      value: function _getMoleculeChains(molecule) {
        function getChainName(residue) {
          return residue._chain._name;
        }

        var chainNames = molecule.residues.map(getChainName);
        return chainNames.filter(function (item, pos) {
          return chainNames.indexOf(item) === pos;
        });
      }
    }]);

    return PDBExporter;
  }(Exporter);
  PDBExporter.formats = ['pdb'];
  PDBExporter.SourceClass = Complex$9;

  var FBX_POS_SIZE = 3;
  var FBX_NORM_SIZE = 3;
  var FBX_COL_SIZE = 4;

  function copyFbxPoint3(src, srcIdx, dst, dstIdx) {
    dst[dstIdx] = src[srcIdx];
    dst[dstIdx + 1] = src[srcIdx + 1];
    dst[dstIdx + 2] = src[srcIdx + 2];
  }

  function copyFbxPoint4(src, srcIdx, dst, dstIdx, value) {
    dst[dstIdx] = src[srcIdx];
    dst[dstIdx + 1] = src[srcIdx + 1];
    dst[dstIdx + 2] = src[srcIdx + 2];
    dst[dstIdx + 3] = value;
  }

  var vector4 = new THREE__namespace.Vector4();

  function copyTransformedPoint3(src, srcIdx, dst, dstIdx, opts) {
    vector4.set(src[srcIdx], src[srcIdx + 1], src[srcIdx + 2], opts.w);
    vector4.applyMatrix4(opts.matrix);
    dst[dstIdx] = vector4.x;
    dst[dstIdx + 1] = vector4.y;
    dst[dstIdx + 2] = vector4.z;
  }

  function setSubArray(src, dst, count, copyFunctor, functorOpts) {
    if ((dst.array.length - dst.start) / dst.stride < count || (src.array.length - src.start) / src.stride < count) {
      return;
    }

    if (src.stride === dst.stride) {
      dst.array.set(src.array, dst.start);
    } else {
      var idx = dst.start;
      var arridx = src.start;

      for (var i = 0; i < count; ++i, idx += dst.stride, arridx += src.stride) {
        copyFunctor(src.array, arridx, dst.array, idx, functorOpts);
      }
    }
  }

  var FBXModel = /*#__PURE__*/function () {
    function FBXModel() {
      _classCallCheck(this, FBXModel);

      this.positions = null;
      this.normals = null;
      this.colors = null;
      this.indices = null;
      this.lastPos = 0;
      this.lastNorm = 0;
      this.lastCol = 0;
      this.lastIdx = 0;
    }

    _createClass(FBXModel, [{
      key: "init",
      value: function init(vertsCount, indsCount) {
        this.positions = new Float32Array(vertsCount * FBX_POS_SIZE);
        this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE);
        this.colors = new Float32Array(vertsCount * FBX_COL_SIZE);
        this.indices = new Int32Array(indsCount);
      }
    }, {
      key: "setPositions",
      value: function setPositions(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.positions,
          start: this.lastPos,
          stride: FBX_POS_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint3);
        this.lastPos += count * FBX_POS_SIZE;
      }
    }, {
      key: "setTransformedPositions",
      value: function setTransformedPositions(array, start, count, stride, matrix) {
        var idx = this.lastPos;
        var arrIdx = start;
        var opts = {
          matrix: matrix,
          w: 1
        };

        for (var i = 0; i < count; ++i, arrIdx += stride, idx += FBX_POS_SIZE) {
          copyTransformedPoint3(array, arrIdx, this.positions, idx, opts);
        }

        this.lastPos += count * FBX_POS_SIZE;
      }
    }, {
      key: "setNormals",
      value: function setNormals(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.normals,
          start: this.lastNorm,
          stride: FBX_NORM_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint3);
        this.lastNorm += count * FBX_NORM_SIZE;
      }
    }, {
      key: "setTransformedNormals",
      value: function setTransformedNormals(array, start, count, stride, matrix) {
        var idx = this.lastNorm;
        var arrIdx = start;
        var opts = {
          matrix: matrix,
          w: 0
        };

        for (var i = 0; i < count; ++i, arrIdx += stride, idx += FBX_NORM_SIZE) {
          copyTransformedPoint3(array, arrIdx, this.normals, idx, opts);
        }

        this.lastNorm += count * FBX_NORM_SIZE;
      }
    }, {
      key: "setColors",
      value: function setColors(array, start, count, stride) {
        var src = {
          array: array,
          start: start,
          stride: stride
        };
        var dst = {
          array: this.colors,
          start: this.lastCol,
          stride: FBX_COL_SIZE
        };
        setSubArray(src, dst, count, copyFbxPoint4, 1);
        this.lastCol += count * FBX_COL_SIZE;
      }
    }, {
      key: "setIndices",
      value: function setIndices(array, start, count) {
        this.indices.set(array, this.lastIdx);
        this.lastIdx += count;
      }
    }, {
      key: "setShiftedIndices",
      value: function setShiftedIndices(array, count, shift) {
        var shifted = array.map(function (x) {
          return x + shift;
        });
        this.setIndices(shifted, 0, count);
      }
    }, {
      key: "getVerticesNumber",
      value: function getVerticesNumber() {
        return this.lastPos / FBX_POS_SIZE;
      }
    }, {
      key: "addInstance",
      value: function addInstance(matrix, geo) {
        var currentCount = this.getVerticesNumber();
        this.setShiftedIndices(geo.indices, geo.indices.length, currentCount);
        var size = geo.itemSize;
        this.setTransformedPositions(geo.positions, 0, geo.vertsCount, size.position, matrix);
        this.setTransformedNormals(geo.normals, 0, geo.vertsCount, size.normal, matrix);
        this.setColors(geo.colors, 0, geo.vertsCount, size.color);
      }
    }]);

    return FBXModel;
  }();

  var FBXGeometry = /*#__PURE__*/function () {
    function FBXGeometry() {
      _classCallCheck(this, FBXGeometry);

      this.positions = null;
      this.normals = null;
      this.colors = null;
      this.indices = null;
      this.vertsCount = 0;
      this.itemSize = null;
    }

    _createClass(FBXGeometry, [{
      key: "init",
      value: function init(geo, _info) {
        var attributes = geo.attributes;
        this.itemSize = {
          position: attributes.position.itemSize,
          normal: attributes.normal.itemSize,
          color: attributes.color.itemSize
        };
      }
    }]);

    return FBXGeometry;
  }();

  function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FBX1CGeometry = /*#__PURE__*/function (_FBXGeometry) {
    _inherits(FBX1CGeometry, _FBXGeometry);

    var _super = _createSuper$9(FBX1CGeometry);

    function FBX1CGeometry() {
      _classCallCheck(this, FBX1CGeometry);

      return _super.apply(this, arguments);
    }

    _createClass(FBX1CGeometry, [{
      key: "init",
      value: function init(geo, _info) {
        _get(_getPrototypeOf(FBX1CGeometry.prototype), "init", this).call(this, geo, _info);

        var _geo$attributes = geo.attributes,
            position = _geo$attributes.position,
            normal = _geo$attributes.normal,
            index = geo.index;
        this.vertsCount = position.count;
        this.positions = position.array;
        this.normals = normal.array;
        this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
        this.indices = index.array;
      }
    }, {
      key: "setColors",
      value: function setColors(color) {
        var offset = 0;

        for (var i = 0, l = this.colors.length, cl = this.itemSize.color; i < l; i += cl) {
          this.colors[offset++] = color.r;
          this.colors[offset++] = color.g;
          this.colors[offset++] = color.b;
        }
      }
    }]);

    return FBX1CGeometry;
  }(FBXGeometry);

  function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FBX2CCylinder = /*#__PURE__*/function (_FBXGeometry) {
    _inherits(FBX2CCylinder, _FBXGeometry);

    var _super = _createSuper$8(FBX2CCylinder);

    function FBX2CCylinder() {
      var _this;

      _classCallCheck(this, FBX2CCylinder);

      _this = _super.call(this);
      _this._cutRawStart = 0;
      _this._cutRawEnd = 0;
      _this._facesPerSlice = 0;
      return _this;
    }

    _createClass(FBX2CCylinder, [{
      key: "init",
      value: function init(geo, info) {
        _get(_getPrototypeOf(FBX2CCylinder.prototype), "init", this).call(this, geo, info);

        var position = geo.attributes.position,
            index = geo.index;
        this.vertsCount = position.count + info.addPerCylinder;
        this._facesPerSlice = info.addPerCylinder;
        this.positions = new Float32Array(this.vertsCount * position.itemSize);
        this.normals = new Float32Array(this.vertsCount * this.itemSize.normal);
        this.colors = new Float32Array(this.vertsCount * this.itemSize.color);

        this._extendVertices(geo, info);

        this.indices = new Uint32Array(index.count);

        this._extendIndices(geo, info);
      }
    }, {
      key: "_extendVertices",
      value: function _extendVertices(geo, info) {
        var position = geo.attributes.position;
        var normal = geo.attributes.normal;
        var geoParams = geo.getGeoParams();
        var cutRaw = 1;
        this._cutRawStart = cutRaw * geoParams.radialSegments;
        this._cutRawEnd = this._cutRawStart + info.addPerCylinder;
        {
          var temp = position.array.slice(0, this._cutRawEnd * position.itemSize);
          this.positions.set(temp, 0);
          temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize);
          this.normals.set(temp, 0);
        }
        {
          var _temp = position.array.slice(this._cutRawStart * position.itemSize, position.array.length);

          this.positions.set(_temp, this._cutRawEnd * position.itemSize);
          _temp = normal.array.slice(this._cutRawStart * normal.itemSize, normal.array.length);
          this.normals.set(_temp, this._cutRawEnd * normal.itemSize);
        }
      }
    }, {
      key: "_extendIndices",
      value: function _extendIndices(geo, info) {
        var index = geo.index;
        var indicesPerQuad = 6;
        var startToShift = info.addPerCylinder * indicesPerQuad;
        var shift = info.addPerCylinder;
        var shifted = index.array.slice(startToShift, index.count);
        shifted = shifted.map(function (x) {
          return x + shift;
        });
        this.indices.set(index.array, 0);
        this.indices.set(shifted, startToShift);
      }
    }, {
      key: "_setColorRange",
      value: function _setColorRange(start, end, array, color) {
        var colorSize = color.length;

        for (var i = start; i < end; i += colorSize) {
          array.set(color, i);
        }
      }
    }, {
      key: "setColors",
      value: function setColors(color1, color2) {
        var colorSize = this.itemSize.color;
        var part1End = this._cutRawEnd * colorSize;
        var part2End = part1End * 2;

        this._setColorRange(0, part1End, this.colors, color1.toArray());

        this._setColorRange(part1End, part2End, this.colors, color2.toArray());

        if (part2End < this.colors.length) {
          var capSize = (this._facesPerSlice + 1) * colorSize;
          var cap1End = part2End + capSize;

          this._setColorRange(part2End, cap1End, this.colors, color2.toArray());

          var cap2End = cap1End + capSize;

          this._setColorRange(cap1End, cap2End, this.colors, color1.toArray());
        }
      }
    }]);

    return FBX2CCylinder;
  }(FBXGeometry);

  var FBXInfoExtractor = /*#__PURE__*/function () {
    function FBXInfoExtractor() {
      _classCallCheck(this, FBXInfoExtractor);

      this._materials = [];
      this._models = [];
    }

    _createClass(FBXInfoExtractor, [{
      key: "process",
      value: function process(data) {
        this._extractModelsAndMaterials(data);

        var models = this._flattenModels();

        return {
          name: data.name,
          models: models,
          materials: this._materials
        };
      }
    }, {
      key: "_extractModelsAndMaterials",
      value: function _extractModelsAndMaterials(data) {
        var _this = this;

        var layersOfInterest = new THREE__namespace.Layers();
        layersOfInterest.set(gfxutils.LAYERS.DEFAULT);
        layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT);
        data.traverse(function (object) {
          if (object instanceof THREE__namespace.Mesh && object.layers.test(layersOfInterest) && _this.checkExportAbility(object)) {
            if (object.geometry.type === 'InstancedBufferGeometry') {
              _this._collectInstancedGeoInfo(object);
            } else {
              _this._collectGeoInfo(object);
            }
          }
        });
      }
    }, {
      key: "_reworkIndices",
      value: function _reworkIndices(indices) {
        var faceSize = 3;

        for (var i = faceSize - 1; i < indices.length; i += faceSize) {
          indices[i] *= -1;
          indices[i]--;
        }
      }
    }, {
      key: "_flattenModels",
      value: function _flattenModels() {
        var overallVertsCount = 0;

        function shift(x) {
          return x + overallVertsCount;
        }

        var combined = [];

        for (var i = 0, n = this._models.length; i < n; i++) {
          var models = this._models[i];
          var indices = [];
          var positions = [];
          var normals = [];
          var colors = [];
          overallVertsCount = 0;

          for (var j = 0; j < models.length; j++) {
            var m = models[j];
            indices.push(m.indices.map(shift));
            overallVertsCount += m.getVerticesNumber();
            positions.push(m.positions);
            normals.push(m.normals);
            colors.push(m.colors);
          }

          indices = utils.mergeTypedArraysUnsafe(indices);

          this._reworkIndices(indices);

          positions = utils.mergeTypedArraysUnsafe(positions);
          normals = utils.mergeTypedArraysUnsafe(normals);
          colors = utils.mergeTypedArraysUnsafe(colors);
          combined.push({
            indices: indices,
            positions: positions,
            normals: normals,
            colors: colors,
            verticesCount: overallVertsCount
          });
        }

        return combined;
      }
    }, {
      key: "checkExportAbility",
      value: function checkExportAbility(mesh) {
        if (mesh.geometry.attributes.position.count === 0) {
          return false;
        }

        if (mesh instanceof ZSpriteMesh) {
          logger.warn("Currently we cannot export 'sprites' modes, like BS, WV, LC. Please turn of settings 'zSprites' and try again");
          return false;
        }

        if (mesh instanceof ThickLineMesh) {
          logger.warn('Currently we cannot export Lines mode');
          return false;
        }

        return true;
      }
    }, {
      key: "_collectGeoInfo",
      value: function _collectGeoInfo(mesh) {
        var _mesh$geometry = mesh.geometry,
            _mesh$geometry$attrib = _mesh$geometry.attributes,
            position = _mesh$geometry$attrib.position,
            color = _mesh$geometry$attrib.color,
            normal = _mesh$geometry$attrib.normal,
            index = _mesh$geometry.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var vertCount = position.count;
        model.init(vertCount, index.count);

        if (matrix.isIdentity()) {
          model.setPositions(position.array, 0, vertCount, position.itemSize);
          model.setNormals(normal.array, 0, vertCount, normal.itemSize);
        } else {
          model.setTransformedPositions(position.array, 0, vertCount, position.itemSize, matrix);
          model.setTransformedNormals(normal.array, 0, vertCount, normal.itemSize, matrix);
        }

        model.setColors(color.array, 0, vertCount, color.itemSize);
        model.setIndices(index.array, 0, index.count);

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
    }, {
      key: "_collectSpheresInfo",
      value: function _collectSpheresInfo(mesh) {
        var _mesh$geometry2 = mesh.geometry,
            _mesh$geometry2$attri = _mesh$geometry2.attributes,
            position = _mesh$geometry2$attri.position,
            color = _mesh$geometry2$attri.color,
            index = _mesh$geometry2.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var instCount = mesh.geometry.instanceCount;
        var vertCount = position.count;
        var indsCount = index.count;
        model.init(instCount * vertCount, instCount * indsCount);
        var geo = new FBX1CGeometry();
        geo.init(mesh.geometry);
        var instMatrix = new THREE__namespace.Matrix4();
        var objMatrix = new THREE__namespace.Matrix4();
        var sphereColor = new THREE__namespace.Color();

        for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
          var colorIdx = instanceIndex * color.itemSize;
          sphereColor.fromArray(color.array, colorIdx);
          geo.setColors(sphereColor);

          this._getSphereInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);

          objMatrix.multiplyMatrices(matrix, instMatrix);
          model.addInstance(objMatrix, geo);
        }

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
    }, {
      key: "_collectCylindersInfo",
      value: function _collectCylindersInfo(mesh) {
        var _mesh$geometry3 = mesh.geometry,
            _mesh$geometry3$attri = _mesh$geometry3.attributes,
            position = _mesh$geometry3$attri.position,
            color = _mesh$geometry3$attri.color,
            color2 = _mesh$geometry3$attri.color2,
            index = _mesh$geometry3.index,
            matrix = mesh.matrix;
        var model = new FBXModel();
        var instCount = mesh.geometry.instanceCount;
        var oneCCylinder = new FBX1CGeometry();
        oneCCylinder.init(mesh.geometry);

        var splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry);

        var twoCCylinder = null;

        if (splittingInfo.needToSplit > 0) {
          twoCCylinder = new FBX2CCylinder();
          twoCCylinder.init(mesh.geometry, splittingInfo);
        }

        var additionalVertsCount = splittingInfo.addPerCylinder * splittingInfo.needToSplit;
        var vertCount = position.count;
        var indsCount = index.count;
        model.init(instCount * vertCount + additionalVertsCount, instCount * indsCount);
        var instMatrix = new THREE__namespace.Matrix4();
        var objMatrix = new THREE__namespace.Matrix4();
        var colorStart = new THREE__namespace.Color();
        var colorEnd = new THREE__namespace.Color();
        var geo = {};

        for (var instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
          var colorIdx = instanceIndex * color.itemSize;

          if (splittingInfo.is2Colored[instanceIndex]) {
            colorStart.fromArray(color2.array, colorIdx);
            colorEnd.fromArray(color.array, colorIdx);

            if (twoCCylinder) {
              twoCCylinder.setColors(colorStart, colorEnd);
              geo = twoCCylinder;
            }
          } else {
            colorStart.fromArray(color.array, colorIdx);
            oneCCylinder.setColors(colorStart);
            geo = oneCCylinder;
          }

          this._getCylinderInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);

          objMatrix.multiplyMatrices(matrix, instMatrix);
          model.addInstance(objMatrix, geo);
        }

        var material = this._collectMaterialInfo(mesh);

        this._addToPool(model, material);
      }
    }, {
      key: "_addToPool",
      value: function _addToPool(model, material) {
        var materialIdx = this._checkExistingMaterial(material);

        if (materialIdx < 0) {
          this._models.push([model]);

          this._materials.push(material);
        } else {
          var models = this._models[materialIdx];
          models.push(model);
        }
      }
    }, {
      key: "_checkExistingMaterial",
      value: function _checkExistingMaterial(material) {
        return ___default["default"].findIndex(this._materials, function (m) {
          return ___default["default"].isEqual(m, material);
        });
      }
    }, {
      key: "_gatherCylindersColoringInfo",
      value: function _gatherCylindersColoringInfo(geo) {
        var instCount = geo.instanceCount;
        var color1 = geo.attributes.color.array;
        var color2 = geo.attributes.color2.array;
        var stride = geo.attributes.color.itemSize;
        var is2Colored = new Array(instCount);
        var needToSplit = 0;
        var colIdx = 0;

        for (var i = 0; i < instCount; i++, colIdx += stride) {
          var differs = Math.abs(color1[colIdx] - color2[colIdx]) > 0.0000001 || Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 0.0000001 || Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 0.0000001;
          is2Colored[i] = differs;
          needToSplit += differs;
        }

        var geoParams = geo.getGeoParams();
        var addPerCylinder = geoParams.radialSegments;
        return {
          is2Colored: is2Colored,
          needToSplit: needToSplit,
          addPerCylinder: addPerCylinder
        };
      }
    }, {
      key: "_collectInstancedGeoInfo",
      value: function _collectInstancedGeoInfo(mesh) {
        if (mesh.geometry instanceof InstancedSpheresGeometry) {
          this._collectSpheresInfo(mesh);
        } else if (mesh.geometry instanceof Instanced2CCylindersGeometry) {
          this._collectCylindersInfo(mesh);
        }
      }
    }, {
      key: "_collectMaterialInfo",
      value: function _collectMaterialInfo(mesh) {
        var uberOptions = mesh.material.uberOptions;
        return {
          diffuse: uberOptions.diffuse.toArray(),
          opacity: uberOptions.opacity,
          shininess: uberOptions.shininess,
          specular: uberOptions.specular.toArray()
        };
      }
    }, {
      key: "_getCylinderInstanceMatrix",
      value: function _getCylinderInstanceMatrix(geo, instIdx, matrix) {
        var matVector1 = geo.attributes.matVector1.array;
        var matVector2 = geo.attributes.matVector2.array;
        var matVector3 = geo.attributes.matVector3.array;
        var idxOffset = instIdx * 4;
        matrix.set(matVector1[idxOffset], matVector1[idxOffset + 1], matVector1[idxOffset + 2], matVector1[idxOffset + 3], matVector2[idxOffset], matVector2[idxOffset + 1], matVector2[idxOffset + 2], matVector2[idxOffset + 3], matVector3[idxOffset], matVector3[idxOffset + 1], matVector3[idxOffset + 2], matVector3[idxOffset + 3], 0, 0, 0, 1);
      }
    }, {
      key: "_getSphereInstanceMatrix",
      value: function _getSphereInstanceMatrix(geo, instIdx, matrix) {
        var offset = geo.attributes.offset;
        var idx = instIdx * offset.itemSize;
        var x = offset.array[idx];
        var y = offset.array[idx + 1];
        var z = offset.array[idx + 2];
        var scale = offset.array[idx + 3];
        matrix.set(scale, 0, 0, x, 0, scale, 0, y, 0, 0, scale, z, 0, 0, 0, 1);
      }
    }]);

    return FBXInfoExtractor;
  }();

  var defaultDefinitions = "\nDefinitions:  {\n  Version: 100\n  Count: 3\n  ObjectType: \"Model\" {\n    Count: 1\n  }\n  ObjectType: \"Geometry\" {\n    Count: 1\n  }\n  ObjectType: \"Material\" {\n    Count: 1\n  }\n  ObjectType: \"Pose\" {\n    Count: 1\n  }\n  ObjectType: \"GlobalSettings\" {\n    Count: 1\n  }\n} ";
  var defaultProperties = "Properties60: {\n      Property: \"QuaternionInterpolate\", \"bool\", \"\",0\n      Property: \"Visibility\", \"Visibility\", \"A\",1\n      Property: \"Lcl Translation\", \"Lcl Translation\", \"A\",0.000000000000000,0.000000000000000,-1789.238037109375000\n      Property: \"Lcl Rotation\", \"Lcl Rotation\", \"A\",0.000009334667643,-0.000000000000000,0.000000000000000\n      Property: \"Lcl Scaling\", \"Lcl Scaling\", \"A\",1.000000000000000,1.000000000000000,1.000000000000000\n      Property: \"RotationOffset\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationPivot\", \"Vector3D\", \"\",0,0,0\n      Property: \"ScalingOffset\", \"Vector3D\", \"\",0,0,0\n      Property: \"ScalingPivot\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationActive\", \"bool\", \"\",0\n      Property: \"TranslationMin\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationMax\", \"Vector3D\", \"\",0,0,0\n      Property: \"TranslationMinX\", \"bool\", \"\",0\n      Property: \"TranslationMinY\", \"bool\", \"\",0\n      Property: \"TranslationMinZ\", \"bool\", \"\",0\n      Property: \"TranslationMaxX\", \"bool\", \"\",0\n      Property: \"TranslationMaxY\", \"bool\", \"\",0\n      Property: \"TranslationMaxZ\", \"bool\", \"\",0\n      Property: \"RotationOrder\", \"enum\", \"\",0\n      Property: \"RotationSpaceForLimitOnly\", \"bool\", \"\",0\n      Property: \"AxisLen\", \"double\", \"\",10\n      Property: \"PreRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"PostRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationActive\", \"bool\", \"\",0\n      Property: \"RotationMin\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationMax\", \"Vector3D\", \"\",0,0,0\n      Property: \"RotationMinX\", \"bool\", \"\",0\n      Property: \"RotationMinY\", \"bool\", \"\",0\n      Property: \"RotationMinZ\", \"bool\", \"\",0\n      Property: \"RotationMaxX\", \"bool\", \"\",0\n      Property: \"RotationMaxY\", \"bool\", \"\",0\n      Property: \"RotationMaxZ\", \"bool\", \"\",0\n      Property: \"RotationStiffnessX\", \"double\", \"\",0\n      Property: \"RotationStiffnessY\", \"double\", \"\",0\n      Property: \"RotationStiffnessZ\", \"double\", \"\",0\n      Property: \"MinDampRangeX\", \"double\", \"\",0\n      Property: \"MinDampRangeY\", \"double\", \"\",0\n      Property: \"MinDampRangeZ\", \"double\", \"\",0\n      Property: \"MaxDampRangeX\", \"double\", \"\",0\n      Property: \"MaxDampRangeY\", \"double\", \"\",0\n      Property: \"MaxDampRangeZ\", \"double\", \"\",0\n      Property: \"MinDampStrengthX\", \"double\", \"\",0\n      Property: \"MinDampStrengthY\", \"double\", \"\",0\n      Property: \"MinDampStrengthZ\", \"double\", \"\",0\n      Property: \"MaxDampStrengthX\", \"double\", \"\",0\n      Property: \"MaxDampStrengthY\", \"double\", \"\",0\n      Property: \"MaxDampStrengthZ\", \"double\", \"\",0\n      Property: \"PreferedAngleX\", \"double\", \"\",0\n      Property: \"PreferedAngleY\", \"double\", \"\",0\n      Property: \"PreferedAngleZ\", \"double\", \"\",0\n      Property: \"InheritType\", \"enum\", \"\",0\n      Property: \"ScalingActive\", \"bool\", \"\",0\n      Property: \"ScalingMin\", \"Vector3D\", \"\",1,1,1\n      Property: \"ScalingMax\", \"Vector3D\", \"\",1,1,1\n      Property: \"ScalingMinX\", \"bool\", \"\",0\n      Property: \"ScalingMinY\", \"bool\", \"\",0\n      Property: \"ScalingMinZ\", \"bool\", \"\",0\n      Property: \"ScalingMaxX\", \"bool\", \"\",0\n      Property: \"ScalingMaxY\", \"bool\", \"\",0\n      Property: \"ScalingMaxZ\", \"bool\", \"\",0\n      Property: \"GeometricTranslation\", \"Vector3D\", \"\",0,0,0\n      Property: \"GeometricRotation\", \"Vector3D\", \"\",0,0,0\n      Property: \"GeometricScaling\", \"Vector3D\", \"\",1,1,1\n      Property: \"LookAtProperty\", \"object\", \"\"\n      Property: \"UpVectorProperty\", \"object\", \"\"\n      Property: \"Show\", \"bool\", \"\",1\n      Property: \"NegativePercentShapeSupport\", \"bool\", \"\",1\n      Property: \"DefaultAttributeIndex\", \"int\", \"\",0\n      Property: \"Color\", \"Color\", \"A+\",0,0,0\n      Property: \"Size\", \"double\", \"\",100\n      Property: \"Look\", \"enum\", \"\",1\n    }";
  var defaultMaterialLayer = "\n    LayerElementMaterial: 0 {\n      Version: 101\n      Name: \"\"\n      MappingInformationType: \"AllSame\"\n      ReferenceInformationType: \"Direct\"\n      Materials: 0\n    }";
  var defaultLayerBlock = "\n    Layer: 0 {\n      Version: 100\n      LayerElement:  {\n        Type: \"LayerElementNormal\"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: \"LayerElementColor\"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: \"LayerElementMaterial\"\n        TypedIndex: 0\n      }\n    }";
  var globalSettings = "GlobalSettings: {\n    Version: 1000\n    Properties60:  {\n      Property: \"UpAxis\", \"int\", \"\",1\n      Property: \"UpAxisSign\", \"int\", \"\",1\n      Property: \"FrontAxis\", \"int\", \"\",2\n      Property: \"FrontAxisSign\", \"int\", \"\",1\n      Property: \"CoordAxis\", \"int\", \"\",0\n      Property: \"CoordAxisSign\", \"int\", \"\",1\n      Property: \"UnitScaleFactor\", \"double\", \"\",1\n    }\n  }";

  var FBXResult = /*#__PURE__*/function () {
    function FBXResult() {
      _classCallCheck(this, FBXResult);

      this._resultArray = [];
      this._info = null;
    }

    _createClass(FBXResult, [{
      key: "getResult",
      value: function getResult(info) {
        this._info = info;

        this._resultArray.push(this._writeHeader());

        this._resultArray.push(this._writeDefinitions());

        this._resultArray.push(this._writeObjects(info.models, info.materials));

        this._resultArray.push(this._writeRelations());

        this._resultArray.push(this._writeConnections());

        this._info = null;
        return this._resultArray.join('');
      }
    }, {
      key: "_writeHeader",
      value: function _writeHeader() {
        var FBXHeaderVersion = 1003;
        var FBXVersion = 6100;
        var date = new Date();
        var timeStampVersion = 1000;
        var creator = "Miew FBX Exporter v".concat(this._info.version);
        return "; FBX 6.1.0 project file\n; Created by ".concat(creator, " Copyright (c) 2015-2020 EPAM Systems, Inc.\n; For support please contact miew@epam.com\n; ----------------------------------------------------\n\nFBXHeaderExtension:  {\n  FBXHeaderVersion: ").concat(FBXHeaderVersion, "\n  FBXVersion: ").concat(FBXVersion, "\n  CreationTimeStamp:  {\n    Version: ").concat(timeStampVersion, "\n    Year: ").concat(date.getFullYear(), "\n    Month: ").concat(date.getMonth() + 1, " \n    Day: ").concat(date.getDate(), "\n    Hour: ").concat(date.getHours(), "\n    Minute: ").concat(date.getMinutes(), "\n    Second: ").concat(date.getSeconds(), "\n    Millisecond: ").concat(date.getMilliseconds(), "\n  }\n  Creator: \"").concat(creator, "\"\n  OtherFlags:  {\n    FlagPLE: 0\n  }\n}\nCreationTime: \"").concat(date, "\"\nCreator: \"").concat(creator, "\"  \n");
      }
    }, {
      key: "_writeDefinitions",
      value: function _writeDefinitions() {
        return "\n; Object definitions\n;------------------------------------------------------------------\n\n".concat(defaultDefinitions, "\n");
      }
    }, {
      key: "_models",
      value: function _models() {
        var modelVersion = 232;
        var allModels = '';
        var models = this._info.models;

        for (var i = 0; i < models.length; ++i) {
          var model = models[i];
          var vertCount = model.verticesCount;
          allModels += "\n  Model: \"Model::".concat(this._info.name, "_").concat(i, "\", \"Mesh\" {\n    Version: ").concat(modelVersion, " \n    ").concat(defaultProperties, "\n    ").concat(this._verticesIndices(model.positions, model.indices), "\n    ").concat(this._normalLayer(model.normals), " \n    ").concat(this._colorLayer(model.colors, vertCount), " \n    ").concat(defaultMaterialLayer, "  \n    ").concat(defaultLayerBlock, "\n  }");
        }

        return allModels;
      }
    }, {
      key: "_materials",
      value: function _materials() {
        var materialVersion = 102;
        var allMaterials = '';
        var materials = this._info.materials;

        for (var i = 0; i < materials.length; ++i) {
          var material = materials[i];
          allMaterials += "\n  Material: \"Material::".concat(this._info.name, "_").concat(i, "_default\", \"\" {\n    Version: ").concat(materialVersion, "\n    ShadingModel: \"lambert\"\n    MultiLayer: 0\n    ").concat(this._materialProperties(material), "\n  }");
        }

        return allMaterials;
      }
    }, {
      key: "_writeObjects",
      value: function _writeObjects() {
        return "\n; Object properties\n;------------------------------------------------------------------\n\nObjects:  {\n  ".concat(this._models(), "\n  ").concat(this._materials(), "\n  ").concat(globalSettings, "\n}\n");
      }
    }, {
      key: "_writeRelations",
      value: function _writeRelations() {
        var modelsList = '';

        for (var i = 0; i < this._info.models.length; ++i) {
          modelsList += "\n  Model: \"Model::".concat(this._info.name, "_").concat(i, "\", \"Mesh\" {\n  }");
        }

        var materialList = '';

        for (var _i = 0; _i < this._info.materials.length; ++_i) {
          materialList += "\n  Material: \"Material::".concat(this._info.name, "_").concat(_i, "_default\", \"\" {\n  }");
        }

        return "\n; Object relations\n;------------------------------------------------------------------\n\nRelations:  {\n  ".concat(modelsList, "\n  Model: \"Model::Producer Perspective\", \"Camera\" {\n  }\n  Model: \"Model::Producer Top\", \"Camera\" {\n  }\n  Model: \"Model::Producer Bottom\", \"Camera\" {\n  }\n  Model: \"Model::Producer Front\", \"Camera\" {\n  }\n  Model: \"Model::Producer Back\", \"Camera\" {\n  }\n  Model: \"Model::Producer Right\", \"Camera\" {\n  }\n  Model: \"Model::Producer Left\", \"Camera\" {\n  }\n  Model: \"Model::Camera Switcher\", \"CameraSwitcher\" {\n  }\n  ").concat(materialList, "\n}");
      }
    }, {
      key: "_writeConnections",
      value: function _writeConnections() {
        var modelsList = '';
        var name = this._info.name;

        for (var i = 0; i < this._info.models.length; ++i) {
          modelsList += "\n  Connect: \"OO\", \"Model::".concat(name, "_").concat(i, "\", \"Model::Scene\"");
        }

        var materialList = '';

        for (var _i2 = 0; _i2 < this._info.materials.length; ++_i2) {
          materialList += "\n  Connect: \"OO\", \"Material::".concat(name, "_").concat(_i2, "_default\", \"Model::").concat(name, "_").concat(_i2, "\"");
        }

        return "\n; Object connections\n;------------------------------------------------------------------\n\nConnections:  {\n  ".concat(modelsList, "\n  ").concat(materialList, "\n}");
      }
    }, {
      key: "_floatArrayToString",
      value: function _floatArrayToString(array) {
        var str = [];

        for (var i = 0; i < array.length; ++i) {
          str[i] = array[i].toFixed(6);
        }

        return str.join(',');
      }
    }, {
      key: "_colorLayer",
      value: function _colorLayer(colorArray, vertCount) {
        var layerElementColorNumber = 0;
        var layerElementColorVersion = 101;
        var layerElementColorName = '';

        var colorsStr = this._floatArrayToString(colorArray);

        var colorIndices = _toConsumableArray(Array(vertCount).keys());

        return "\n    LayerElementColor: ".concat(layerElementColorNumber, " {\n      Version: ").concat(layerElementColorVersion, "\n      Name: \"").concat(layerElementColorName, "\"\n      MappingInformationType: \"ByVertice\"\n      ReferenceInformationType: \"Direct\"\n      Colors: ").concat(colorsStr, "\n      ColorIndex: ").concat(colorIndices, "\n    }");
      }
    }, {
      key: "_normalLayer",
      value: function _normalLayer(normalArray) {
        var layerElementNormalNumber = 0;
        var layerElementNormalVersion = 101;
        var layerElementNormalName = '';

        var normalsStr = this._floatArrayToString(normalArray);

        return "\n    LayerElementNormal: ".concat(layerElementNormalNumber, " {\n      Version: ").concat(layerElementNormalVersion, "\n      Name: \"").concat(layerElementNormalName, "\"\n      MappingInformationType: \"ByVertice\"\n      ReferenceInformationType: \"Direct\" \n      Normals: ").concat(normalsStr, "\n    }");
      }
    }, {
      key: "_verticesIndices",
      value: function _verticesIndices(positions, indices) {
        var multiLayer = 0;
        var multiTake = 1;
        var shading = 'Y';
        var culling = 'CullingOff';
        var geometryVersion = 124;

        var vertStr = this._floatArrayToString(positions);

        return "MultiLayer: ".concat(multiLayer, "\n    MultiTake: ").concat(multiTake, "\n    Shading: ").concat(shading, "\n    Culling: \"").concat(culling, "\"\n    Vertices: ").concat(vertStr, "\n    PolygonVertexIndex: ").concat(indices, "\n    GeometryVersion: ").concat(geometryVersion);
      }
    }, {
      key: "_materialProperties",
      value: function _materialProperties(material) {
        return "Properties60:  {\n      Property: \"ShadingModel\", \"KString\", \"\", \"Lambert\"\n      Property: \"MultiLayer\", \"bool\", \"\",0\n      Property: \"EmissiveColor\", \"ColorRGB\", \"\",0,0,0\n      Property: \"EmissiveFactor\", \"double\", \"\",0.0000\n      Property: \"AmbientColor\", \"ColorRGB\", \"\",1,1,1\n      Property: \"AmbientFactor\", \"double\", \"\",0.0000\n      Property: \"DiffuseColor\", \"ColorRGB\", \"\",".concat(material.diffuse, "\n      Property: \"DiffuseFactor\", \"double\", \"\",1.0000\n      Property: \"Bump\", \"Vector3D\", \"\",0,0,0\n      Property: \"TransparentColor\", \"ColorRGB\", \"\",1,1,1\n      Property: \"TransparencyFactor\", \"double\", \"\",0.0000\n      Property: \"SpecularColor\", \"ColorRGB\", \"\",").concat(material.specular, "\n      Property: \"SpecularFactor\", \"double\", \"\",1.0000\n      Property: \"ShininessExponent\", \"double\", \"\",").concat(material.shininess, "\n      Property: \"ReflectionColor\", \"ColorRGB\", \"\",0,0,0\n      Property: \"ReflectionFactor\", \"double\", \"\",1\n      Property: \"Ambient\", \"ColorRGB\", \"\",1,1,1\n      Property: \"Diffuse\", \"ColorRGB\", \"\",").concat(material.diffuse, "\n      Property: \"Specular\", \"ColorRGB\", \"\",").concat(material.specular, "\n      Property: \"Shininess\", \"double\", \"\",").concat(material.shininess, "\n      Property: \"Opacity\", \"double\", \"\",").concat(material.opacity, "\n      Property: \"Reflectivity\", \"double\", \"\",0\n    }");
      }
    }]);

    return FBXResult;
  }();

  function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FBXExporter = /*#__PURE__*/function (_Exporter) {
    _inherits(FBXExporter, _Exporter);

    var _super = _createSuper$7(FBXExporter);

    function FBXExporter(source, options) {
      var _this;

      _classCallCheck(this, FBXExporter);

      _this = _super.call(this, source, options);
      _this._data = source;
      _this._version = options.miewVersion || '0.0-UNSPECIFIED';
      _this._extractor = new FBXInfoExtractor();
      return _this;
    }

    _createClass(FBXExporter, [{
      key: "exportSync",
      value: function exportSync() {
        var result = new FBXResult();

        if (!this._source) {
          return this._result;
        }

        var info = this._extractor.process(this._data);

        info.version = this._version;
        this._result = result.getResult(info);
        return this._result;
      }
    }]);

    return FBXExporter;
  }(Exporter);
  FBXExporter.formats = ['fbx'];
  FBXExporter.SourceClass = ComplexVisual;

  var exporters = new ExporterList([PDBExporter, FBXExporter]);

  var io = {
    loaders: loaders,
    parsers: parsers,
    exporters: exporters
  };

  var tempColor = new THREE__namespace.Color();

  var CSS2DRenderer = /*#__PURE__*/function () {
    function CSS2DRenderer() {
      _classCallCheck(this, CSS2DRenderer);

      this._width = 0;
      this._height = 0;
      this._widthHalf = 0;
      this._heightHalf = 0;
      this._vector = new THREE__namespace.Vector3();
      this._viewMatrix = new THREE__namespace.Matrix4();
      this._projectionMatrix = new THREE__namespace.Matrix4();
      this._domElement = document.createElement('div');
      this._domElement.style.overflow = 'hidden';
      this._domElement.style.position = 'absolute';
      this._domElement.style.top = '0';
      this._domElement.style.zIndex = '0';
      this._domElement.style.pointerEvents = 'none';
    }

    _createClass(CSS2DRenderer, [{
      key: "getElement",
      value: function getElement() {
        return this._domElement;
      }
    }, {
      key: "reset",
      value: function reset() {
        var myNode = this.getElement();

        while (myNode.firstChild) {
          myNode.removeChild(myNode.firstChild);
        }
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this._width = width;
        this._height = height;
        this._widthHalf = this._width / 2;
        this._heightHalf = this._height / 2;
        this._domElement.style.width = "".concat(width, "px");
        this._domElement.style.height = "".concat(height, "px");
      }
    }, {
      key: "_renderObject",
      value: function _renderObject(object, camera, scene) {
        function lerpColorAsHex(a, b, t) {
          tempColor.setHex(a);
          tempColor.lerp(b, t);
          return "#".concat(tempColor.getHexString());
        }

        function colorAsHex(a) {
          tempColor.setHex(a);
          return "#".concat(tempColor.getHexString());
        }

        if (object instanceof CSS2DObject) {
          this._vector.setFromMatrixPosition(object.matrixWorld);

          if (object.userData !== undefined && object.userData.offset !== undefined) {
            var localOffset = new THREE__namespace.Vector3(object.userData.offset.x, object.userData.offset.y, 0);

            this._vector.add(localOffset.multiplyScalar(object.matrixWorld.getMaxScaleOnAxis()));
          }

          this._vector.applyMatrix4(this._viewMatrix);

          var visibility = this._vector.z > -camera.near ? 'hidden' : 'visible';
          var zIndex = 10000 * (camera.far - -this._vector.z) / (camera.far - camera.near);
          var element = object.getElement();

          if (typeof scene.fog === 'undefined') {
            element.style.color = colorAsHex(object.userData.color);

            if (object.userData.background !== 'transparent') {
              element.style.background = colorAsHex(object.userData.background);
            }
          } else {
            var fogFactor = THREE__namespace.MathUtils.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
            element.style.color = lerpColorAsHex(object.userData.color, scene.fog.color, fogFactor);

            if (object.userData.background !== 'transparent') {
              element.style.background = lerpColorAsHex(object.userData.background, scene.fog.color, fogFactor);
            }
          }

          this._vector.applyMatrix4(this._projectionMatrix);

          var style = "".concat(object.userData !== {} ? object.userData.translation : 'translate(-50%, -50%) ', "translate(").concat(this._vector.x * this._widthHalf + this._widthHalf, "px,").concat(-this._vector.y * this._heightHalf + this._heightHalf, "px)");
          element.style.visibility = visibility;
          element.style.WebkitTransform = style;
          element.style.MozTransform = style;
          element.style.oTransform = style;
          element.style.transform = style;
          element.style.zIndex = Number(zIndex).toFixed(0);

          if (element.parentNode !== this._domElement) {
            this._domElement.appendChild(element);
          }
        }

        for (var i = 0, l = object.children.length; i < l; i++) {
          this._renderObject(object.children[i], camera, scene);
        }
      }
    }, {
      key: "render",
      value: function render(scene, camera) {
        scene.updateMatrixWorld();

        if (camera.parent === null) {
          camera.updateMatrixWorld();
        }

        camera.matrixWorldInverse.copy(camera.matrixWorld).invert();

        this._viewMatrix.copy(camera.matrixWorldInverse);

        this._projectionMatrix.copy(camera.projectionMatrix);

        this._renderObject(scene, camera, scene);
      }
    }]);

    return CSS2DRenderer;
  }();

  var VK_LEFT = 37;
  var VK_UP = 38;
  var VK_RIGHT = 39;
  var VK_DOWN = 40;
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    TRANSLATE: 1,
    SCALE: 2,
    TRANSLATE_PIVOT: 3
  };
  var FULL_STOP_THRESHOLD = 0.1;
  var quaternion = new THREE__namespace.Quaternion();
  var matrix4 = new THREE__namespace.Matrix4();

  function ObjectHandler(objects, camera, pivot, options) {
    this.objects = objects;

    var _objects = _slicedToArray(objects, 1);

    this.object = _objects[0];
    this.camera = camera;
    this.pivot = pivot;
    this.axis = new THREE__namespace.Vector3(0, 0, 1);
    this.options = options;
    this.lastRotation = {
      axis: new THREE__namespace.Vector3(),
      angle: 0.0
    };
  }

  ObjectHandler.prototype._rotate = function () {
    var p = new THREE__namespace.Vector3();
    var q = new THREE__namespace.Quaternion();
    var s = new THREE__namespace.Vector3();
    var m = new THREE__namespace.Matrix4();
    return function (quat) {
      var zeroPivot = this.pivot.x === 0.0 && this.pivot.y === 0.0 && this.pivot.z === 0.0;
      m.copy(this.object.matrix);

      if (zeroPivot) {
        m.multiply(matrix4.makeRotationFromQuaternion(quat));
      } else {
        m.multiply(matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
        m.multiply(matrix4.makeRotationFromQuaternion(quat));
        m.multiply(matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
      }

      m.decompose(p, q, s);

      if (!zeroPivot) {
        for (var i = 0; i < this.objects.length; ++i) {
          this.objects[i].position.copy(p);
        }
      }

      for (var j = 0; j < this.objects.length; ++j) {
        this.objects[j].quaternion.copy(q);
        this.objects[j].updateMatrix();
      }
    };
  }();

  ObjectHandler.prototype.setObjects = function (objects) {
    this.objects = objects;

    var _objects2 = _slicedToArray(objects, 1);

    this.object = _objects2[0];
  };

  ObjectHandler.prototype.rotate = function () {
    var rot = {
      axis: new THREE__namespace.Vector3(),
      angle: 0.0
    };
    return function (quat, mousePrevPos, mouseCurPos, aboutAxis) {
      this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis);
      quat.setFromAxisAngle(rot.axis, rot.angle);

      if (rot.angle) {
        this._rotate(quat);
      }

      this.lastRotation = rot;
    };
  }();

  ObjectHandler.prototype.translate = function () {
    var dir = new THREE__namespace.Vector3();
    var pivot = new THREE__namespace.Vector3();
    return function (delta) {
      dir.set(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
      var dist = dir.length();
      dir.normalize();
      dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert());
      pivot.copy(this.pivot);
      this.object.localToWorld(pivot);
      dist *= Math.abs(pivot.z - this.camera.position.z);
      dist /= this.object.matrixWorld.getMaxScaleOnAxis();

      for (var i = 0; i < this.objects.length; ++i) {
        this.objects[i].translateOnAxis(dir, dist);
      }
    };
  }();

  ObjectHandler.prototype.update = function () {
    var axis = new THREE__namespace.Vector3();
    return function (timeSinceLastUpdate, timeSinceMove) {
      if (settings$1.now.autoRotation !== 0.0) {
        if (settings$1.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0.0) {
          axis.set(0, 1, 0).transformDirection(matrix4.copy(this.object.matrixWorld).invert());
        } else {
          axis.copy(this.lastRotation.axis);
        }

        this._rotate(quaternion.setFromAxisAngle(axis, settings$1.now.autoRotation * timeSinceLastUpdate));

        return true;
      }

      if (this.options.intertia && this.lastRotation.angle) {
        var angle = this.lastRotation.angle * Math.pow(1.0 - this.options.dynamicDampingFactor, 40.0 * timeSinceMove);

        if (Math.abs(angle) <= this.options.intertiaThreshold) {
          this.lastRotation.angle = 0.0;
        } else {
          this._rotate(quaternion.setFromAxisAngle(this.lastRotation.axis, angle));

          return true;
        }
      }

      return false;
    };
  }();

  ObjectHandler.prototype.stop = function () {
    this.lastRotation.angle = 0.0;
  };

  ObjectHandler.prototype.mouse2rotation = function () {
    var center = new THREE__namespace.Vector3();
    var eye = new THREE__namespace.Vector3();
    var eyeDirection = new THREE__namespace.Vector3();
    var cameraUpDirection = new THREE__namespace.Vector3();
    var cameraSidewaysDirection = new THREE__namespace.Vector3();
    var moveDirection = new THREE__namespace.Vector3();
    var mouseDelta = new THREE__namespace.Vector2();
    return function (rot, mousePrev, mouseCur, aboutAxis) {
      if (aboutAxis) {
        rot.axis.copy(this.axis);
        rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);
      } else {
        mouseDelta.subVectors(mouseCur, mousePrev);
        var angle = mouseDelta.length();

        if (angle === 0.0) {
          return;
        }

        center.copy(this.pivot);
        this.object.localToWorld(center);
        eye.subVectors(this.camera.position, center);
        eyeDirection.copy(eye).normalize();
        cameraUpDirection.copy(this.camera.up).normalize();
        cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();
        cameraUpDirection.setLength(mouseDelta.y);
        cameraSidewaysDirection.setLength(mouseDelta.x);
        moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));
        rot.axis.crossVectors(moveDirection, eye);
        rot.angle = -angle * this.options.rotateFactor;
      }

      rot.axis.transformDirection(matrix4.copy(this.object.matrixWorld).invert());

      if (rot.angle < 0.0) {
        rot.axis.negate();
        rot.angle = -rot.angle;
      }
    };
  }();

  function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
    EventDispatcher.call(this);
    var self = this;
    this.object = object;
    this.objectPivot = objectPivot;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.getAltObj = getAltObj;
    this.enabled = true;
    this.hotkeysEnabled = true;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this.options = {
      rotateFactor: Math.PI,
      axisRotateFactor: 4 * Math.PI,
      intertia: true,
      dynamicDampingFactor: 0.1,
      intertiaThreshold: 1e-3
    };
    this._state = STATE.NONE;
    this._mousePrevPos = new THREE__namespace.Vector2();
    this._mouseCurPos = new THREE__namespace.Vector2();
    this._mainObj = new ObjectHandler([this.object], this.camera, new THREE__namespace.Vector3(0, 0, 0), this.options);
    this._altObj = new ObjectHandler([this.object], this.camera, new THREE__namespace.Vector3(0, 0, 0), this.options);
    this._affectedObj = this._mainObj;
    this._isAltObjFreeRotationAllowed = true;
    this._isTranslationAllowed = true;
    this._isKeysTranslatingObj = false;
    this._pressedKeys = [];
    this._clock = new Timer();

    this._clock.start();

    this._lastUpdateTime = this._clock.getElapsedTime();
    this._listeners = [{
      obj: self.domElement,
      type: 'mousedown',
      handler: function handler(e) {
        self.mousedown(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseup',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousemove',
      handler: function handler(e) {
        self.mousemove(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousewheel',
      handler: function handler(e) {
        self.mousewheel(e);
      }
    }, {
      obj: self.domElement,
      type: 'DOMMouseScroll',
      handler: function handler(e) {
        self.mousewheel(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseout',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchstart',
      handler: function handler(e) {
        self.touchstartend(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchend',
      handler: function handler(e) {
        self.touchstartend(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchmove',
      handler: function handler(e) {
        self.touchmove(e);
      }
    }, {
      obj: self.getKeyBindObject(),
      type: 'keydown',
      handler: function handler(e) {
        self.keydownup(e);
      }
    }, {
      obj: self.getKeyBindObject(),
      type: 'keyup',
      handler: function handler(e) {
        self.keydownup(e);
      }
    }, {
      obj: window,
      type: 'resize',
      handler: function handler() {
        self.handleResize();
      }
    }, {
      obj: window,
      type: 'blur',
      handler: function handler() {
        self.resetKeys();
      }
    }, {
      obj: self.domElement,
      type: 'contextmenu',
      handler: function handler(e) {
        self.contextmenu(e);
      }
    }];

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }

    this.handleResize();
    this.resetKeys();
    this.update();
  }

  ObjectControls.prototype = Object.create(EventDispatcher.prototype);
  ObjectControls.prototype.constructor = ObjectControls;

  ObjectControls.prototype.resetKeys = function () {
    this._pressedKeys[VK_LEFT] = false;
    this._pressedKeys[VK_UP] = false;
    this._pressedKeys[VK_RIGHT] = false;
    this._pressedKeys[VK_DOWN] = false;
  };

  ObjectControls.prototype.contextmenu = function (e) {
    e.stopPropagation();
    e.preventDefault();
  };

  ObjectControls.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect();
      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  ObjectControls.prototype.enable = function (enable) {
    this.enabled = enable;
  };

  ObjectControls.prototype.enableHotkeys = function (enable) {
    this.hotkeysEnabled = enable;
  };

  ObjectControls.prototype.allowTranslation = function (allow) {
    this._isTranslationAllowed = allow;
  };

  ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
    this._isAltObjFreeRotationAllowed = allow;
  };

  ObjectControls.prototype.keysTranslateObj = function (on) {
    this._isKeysTranslatingObj = on;
  };

  ObjectControls.prototype.isEditingAltObj = function () {
    return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
  };

  ObjectControls.prototype.convertMouseToOnCircle = function (coords, pageX, pageY) {
    var screenSize = Math.min(this.screen.width, this.screen.height);

    if (screenSize === 0) {
      coords.set(0, 0);
      return;
    }

    coords.set((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
  };

  ObjectControls.prototype.convertMouseToViewport = function (coords, pageX, pageY) {
    if (this.screen.width === 0 || this.screen.height === 0) {
      coords.set(0, 0);
      return;
    }

    coords.set(2.0 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2.0 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
  };

  ObjectControls.prototype.stop = function () {
    this._mainObj.stop();

    this._altObj.stop();
  };

  ObjectControls.prototype.rotateByMouse = function () {
    var quat = new THREE__namespace.Quaternion();
    return function (aboutZAxis) {
      this._affectedObj.rotate(quat, this._mousePrevPos, this._mouseCurPos, aboutZAxis);

      this.dispatchEvent({
        type: 'change',
        action: 'rotate',
        quaternion: quat
      });
    };
  }();

  ObjectControls.prototype.rotate = function (quat) {
    this.object.quaternion.multiply(quat);
    this.dispatchEvent({
      type: 'change',
      action: 'rotate',
      quaternion: quat
    });
  };

  ObjectControls.prototype.getOrientation = function () {
    return this.object.quaternion;
  };

  ObjectControls.prototype.setOrientation = function (quat) {
    this.object.quaternion.copy(quat);
  };

  ObjectControls.prototype.translate = function () {
    var delta = new THREE__namespace.Vector2();
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos);

      this._affectedObj.translate(delta);

      this.dispatchEvent({
        type: 'change',
        action: 'translate'
      });
    };
  }();

  ObjectControls.prototype.getScale = function () {
    return this.object.scale.x;
  };

  ObjectControls.prototype.setScale = function (scale) {
    this.object.scale.set(scale, scale, scale);
  };

  ObjectControls.prototype.scale = function (factor) {
    if (factor <= 0) {
      return;
    }

    this.setScale(this.object.scale.x * factor);
    this.dispatchEvent({
      type: 'change',
      action: 'zoom',
      factor: factor
    });
  };

  ObjectControls.prototype.update = function () {
    var shift = new THREE__namespace.Vector2();
    return function () {
      var curTime = this._clock.getElapsedTime();

      var timeSinceLastUpdate = curTime - this._lastUpdateTime;

      if (this._state === STATE.NONE) {
        var timeSinceMove = curTime - this._lastMouseMoveTime;

        if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
          this.dispatchEvent({
            type: 'change',
            action: 'auto'
          });
        }
      }

      if (this._isKeysTranslatingObj) {
        var speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
        var speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);

        if (speedX !== 0.0 || speedY !== 0.0) {
          var delta = timeSinceLastUpdate;
          var altObj = this.getAltObj();

          if (altObj.objects.length > 0) {
            this._altObj.setObjects(altObj.objects);

            this._altObj.pivot = altObj.pivot;

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }

            shift.set(delta * speedX, delta * speedY);

            this._altObj.translate(shift);

            this.dispatchEvent({
              type: 'change',
              action: 'translate'
            });
          }
        }
      }

      this._lastUpdateTime = curTime;
    };
  }();

  ObjectControls.prototype.reset = function () {
    this._state = STATE.NONE;
    this.object.quaternion.copy(quaternion.set(0, 0, 0, 1));
  };

  ObjectControls.prototype.mousedown = function (event) {
    if (this.enabled === false || this._state !== STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    if (this._state === STATE.NONE) {
      if (event.button === 0) {
        this._affectedObj.stop();

        var workWithAltObj = false;

        if (event.altKey) {
          var altObj = this.getAltObj();
          workWithAltObj = altObj.objects.length > 0;

          if (workWithAltObj) {
            this._altObj.setObjects(altObj.objects);

            this._altObj.pivot = altObj.pivot;

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone();
            } else {
              this._altObj.axis.set(0, 0, 1);
            }
          }
        }

        this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
        this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
      } else if (event.button === 2) {
        this._state = STATE.TRANSLATE_PIVOT;
      }
    }

    if (this._state === STATE.ROTATE) {
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);

      this._mousePrevPos.copy(this._mouseCurPos);
    }

    if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);

      this._mousePrevPos.copy(this._mouseCurPos);
    }
  };

  ObjectControls.prototype.mousemove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
        this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
        this._lastMouseMoveTime = this._clock.getElapsedTime();
        break;

      case STATE.TRANSLATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
        this.translate();
        break;

      case STATE.TRANSLATE_PIVOT:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
        this.translatePivotByMouse();
        break;
    }
  };

  ObjectControls.prototype.mousewheel = function (event) {
    if (this.enabled === false || !settings$1.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
      return;
    }

    event.preventDefault();
    var delta = 0;

    if (event.wheelDelta) {
      delta = event.wheelDelta / 40;
    } else if (event.detail) {
      delta = -event.detail / 3;
    }

    var factor = 1.0 + delta * 0.05;
    factor = Math.max(factor, 0.01);
    this.scale(factor);
  };

  ObjectControls.prototype.mouseup = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();
    this._state = STATE.NONE;

    if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
      this._affectedObj.stop();
    }
  };

  ObjectControls.prototype.touchstartend = function (event) {
    if (this.enabled === false) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (event.touches.length) {
      case 1:
        this._state = STATE.ROTATE;
        this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);

        this._mousePrevPos.copy(this._mouseCurPos);

        break;

      case 2:
        {
          this._mainObj.stop();

          this._altObj.stop();

          this._state = STATE.SCALE;
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
          this._scaleStart = this.object.scale.x;
          break;
        }

      default:
        this._state = STATE.NONE;
    }
  };

  ObjectControls.prototype.touchmove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos);

        this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
        this.rotateByMouse(false);
        this._lastMouseMoveTime = this._clock.getElapsedTime();
        break;

      case STATE.SCALE:
        if (settings$1.now.zooming) {
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
          var newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
          var factor = newScale / this.object.scale.x;
          this.scale(factor);
        }

        break;
    }
  };

  ObjectControls.prototype.keydownup = function (event) {
    if (this.enabled === false || this.hotkeysEnabled === false) {
      return;
    }

    switch (event.keyCode) {
      case VK_LEFT:
      case VK_UP:
      case VK_RIGHT:
      case VK_DOWN:
        this._pressedKeys[event.keyCode] = event.type === 'keydown';
        event.preventDefault();
        event.stopPropagation();
        break;
    }
  };

  ObjectControls.prototype.getKeyBindObject = function () {
    return window.top;
  };

  ObjectControls.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };

  ObjectControls.prototype.translatePivotByMouse = function () {
    var delta = new THREE__namespace.Vector2();
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos);
      this.translatePivotInWorld(settings$1.now.translationSpeed * delta.x, settings$1.now.translationSpeed * delta.y, 0);
    };
  }();

  ObjectControls.prototype.translatePivotInWorld = function (x, y, z) {
    var pos = this.objectPivot.position;
    pos.applyMatrix4(this.object.matrixWorld);
    pos.setX(pos.x + x);
    pos.setY(pos.y + y);
    pos.setZ(pos.z + z);
    pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert());
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  };

  ObjectControls.prototype.translatePivot = function (x, y, z) {
    var pos = this.objectPivot.position;
    pos.setX(pos.x + x);
    pos.setY(pos.y + y);
    pos.setZ(pos.z + z);
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  };

  ObjectControls.prototype.setPivot = function (newPivot) {
    this.objectPivot.position.copy(newPivot);
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    });
  };

  function Picker(gfxObj, camera, domElement) {
    EventDispatcher.call(this);
    var self = this;
    this.gfxObj = gfxObj;
    this.camera = camera;
    this.domElement = typeof domElement !== 'undefined' ? domElement : document;
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    };
    this._lastMousePos = new THREE__namespace.Vector2(0, 0);
    this._mouseTotalDist = 0.0;
    this._lastClickBeginTime = -1000.0;
    this._lastClickPos = new THREE__namespace.Vector2(0, 0);
    this._clickBeginTime = 0.0;
    this._clock = new Timer();

    this._clock.start();

    this._listeners = [{
      obj: self.domElement,
      type: 'mousedown',
      handler: function handler(e) {
        self.mousedown(e);
      }
    }, {
      obj: self.domElement,
      type: 'mouseup',
      handler: function handler(e) {
        self.mouseup(e);
      }
    }, {
      obj: self.domElement,
      type: 'mousemove',
      handler: function handler(e) {
        self.mousemove(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchstart',
      handler: function handler(e) {
        self.touchstart(e);
      }
    }, {
      obj: self.domElement,
      type: 'touchend',
      handler: function handler(e) {
        self.touchend(e);
      }
    }, {
      obj: window,
      type: 'resize',
      handler: function handler() {
        self.handleResize();
      }
    }];

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.addEventListener(l.type, l.handler);
    }

    this.handleResize();
  }

  Picker.prototype = Object.create(EventDispatcher.prototype);
  Picker.prototype.constructor = Picker;

  Picker.prototype.reset = function () {
    this.picked = {};
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    });
  };

  Picker.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0;
      this.screen.top = 0;
      this.screen.width = window.innerWidth;
      this.screen.height = window.innerHeight;
    } else {
      var box = this.domElement.getBoundingClientRect();
      var d = this.domElement.ownerDocument.documentElement;
      this.screen.left = box.left + window.pageXOffset - d.clientLeft;
      this.screen.top = box.top + window.pageYOffset - d.clientTop;
      this.screen.width = box.width;
      this.screen.height = box.height;
    }
  };

  Picker.prototype.pickObject = function (screenPos) {
    if (!this.gfxObj) {
      this.picked = {};
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      });
      return;
    }

    var gfxObj = this.gfxObj;
    var rayCaster = new THREE__namespace.Raycaster();
    rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld);
    rayCaster.ray.direction.set(screenPos.x, screenPos.y, 0.5).unproject(this.camera).sub(rayCaster.ray.origin).normalize();
    var clipPlane = settings$1.now.draft.clipPlane && this.clipPlaneValue ? this.clipPlaneValue : Infinity;
    var fogFarPlane = settings$1.now.fog && this.fogFarValue ? this.fogFarValue : Infinity;
    var point = rayCaster.intersectVisibleObject(gfxObj, this.camera, clipPlane, fogFarPlane);

    if (!point) {
      this.picked = {};
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      });
      return;
    }

    var picked = {};

    if (point.residue || point.atom) {
      var residue = point.residue || point.atom.residue;

      if (settings$1.now.pick === 'chain') {
        picked = {
          chain: residue.getChain()
        };
      } else if (settings$1.now.pick === 'molecule') {
        picked = {
          molecule: residue.getMolecule()
        };
      } else if (point.residue || settings$1.now.pick === 'residue') {
        picked = {
          residue: residue
        };
      } else if (point.atom) {
        picked = {
          atom: point.atom
        };
      }
    }

    this.picked = picked;
    this.dispatchEvent({
      type: 'newpick',
      obj: picked
    });
  };

  Picker.prototype.getMouseInViewport = function (pageX, pageY) {
    return new THREE__namespace.Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
  };

  Picker.prototype.mousedown = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (event.button === 0) {
      this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
      this._mouseTotalDist = 0.0;
      this._clickBeginTime = this._clock.getElapsedTime();
    }
  };

  Picker.prototype.mousemove = function (event) {
    event.preventDefault();
    event.stopPropagation();
    var pos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist += pos.sub(this._lastMousePos).length();
  };

  Picker.prototype.mouseup = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();

    if (event.button === 0) {
      if (this._mouseTotalDist < 0.01) {
        var curTime = this._clock.getElapsedTime();

        var curPos = this.getMouseInViewport(event.pageX, event.pageY);
        var timeSinceLastClickBegin = curTime - this._lastClickBeginTime;

        if (timeSinceLastClickBegin < 0.7) {
          var clickDist = new THREE__namespace.Vector2().subVectors(curPos, this._lastClickPos);

          if (clickDist.length() < 0.01) {
            this.dispatchEvent({
              type: 'dblclick',
              obj: this.picked
            });
            this._lastClickPos = curPos;
            this._lastClickBeginTime = -1000;
            return;
          }
        }

        setTimeout(function () {
          self.pickObject(curPos);
        }, 0);
        this._lastClickPos = curPos;
        this._lastClickBeginTime = this._clickBeginTime;
      }
    }
  };

  Picker.prototype.touchstart = function (event) {
    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length === 1) {
      this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
    }
  };

  Picker.prototype.touchend = function (event) {
    var self = this;
    event.preventDefault();
    event.stopPropagation();

    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
      var dist = pos.sub(this._lastTouchdownPos).length();

      if (dist < 0.01) {
        setTimeout(function () {
          self.pickObject(self._lastTouchdownPos);
        }, 0);
      }
    }
  };

  Picker.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i];
      l.obj.removeEventListener(l.type, l.handler);
    }
  };

  var Axes = /*#__PURE__*/function () {
    function Axes(target, targetCamera) {
      _classCallCheck(this, Axes);

      this._target = target;
      this._targetCamera = targetCamera;
      this._camera = new THREE__namespace.PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
      this._object = new THREE__namespace.AxesHelper(1);
      this._scene = new THREE__namespace.Scene();

      this._scene.add(this._object);

      this._full = new THREE__namespace.Vector2();

      this._update();
    }

    _createClass(Axes, [{
      key: "_update",
      value: function _update() {
        var fov = this._targetCamera.fov;
        var camera = this._camera;
        camera.aspect = this._targetCamera.aspect;
        camera.setMinimalFov(fov);
        camera.setDistanceToFit(1.0, fov);
        camera.updateProjectionMatrix();

        this._object.quaternion.copy(this._target.quaternion);
      }
    }, {
      key: "render",
      value: function render(renderer) {
        this._update();

        renderer.getSize(this._full);
        var width = this._full.width * 0.25;
        var height = this._full.height * 0.25;
        var autoClear = renderer.autoClear;
        renderer.autoClear = false;
        renderer.setViewport(0.0, 0.0, width, height);
        renderer.clear(false, true, false);
        renderer.render(this._scene, this._camera);
        renderer.setViewport(0, 0, this._full.width, this._full.height);
        renderer.autoClear = autoClear;
      }
    }]);

    return Axes;
  }();

  var cDataOffset = 12;
  var cFirstMask = 0x0fffff00;
  var cFirstShift = 8;
  var cSecMask1 = 0x000000ff;
  var cSecShift1 = 12;
  var cSecMask2 = 0xfff00000;
  var cSecShift2 = 20;
  var cThirdMask = 0x000fffff;
  var cStrMask = 0xf0000000;
  var cStrShift = 28;
  var c219 = 1 << 19;
  var c220 = 1 << 20;
  var cHelixIdx = 1;
  var cSheetIdx = 2;
  var secTypes = ['helix', 'strand'];
  var cSecNames = ['fs', 'ps', 'ns', 'us'];

  function _createSecondary(strArray, complex) {
    var residues = complex._residues;
    var nRes = residues.length;
    var resid = new Uint8Array(nRes);
    var atoms = complex._atoms;

    for (var i = 0, n = strArray.length; i < n; ++i) {
      var atom = atoms[i];
      resid[atom.residue._index] = strArray[i];
    }

    var secondary = [];
    var rIdx = 0;

    while (rIdx < nRes) {
      if (resid[rIdx] !== 0) {
        var start = rIdx;
        var val = resid[rIdx];

        while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
          ++rIdx;
        }

        secondary.push({
          start: start,
          end: rIdx,
          type: secTypes[val - 1]
        });
      }

      ++rIdx;
    }

    return secondary;
  }

  function fromUInt20ToInt20(uint20) {
    return uint20 >= c219 ? uint20 - c220 : uint20;
  }

  var FrameInfo = /*#__PURE__*/function () {
    function FrameInfo(complex, payload, callbacks) {
      _classCallCheck(this, FrameInfo);

      this._complex = complex;
      this._secondary = null;
      this.isLoading = false;
      this._framesRange = {
        start: 0,
        end: -1
      };
      this.frameIsReady = false;
      this._buffer = null;
      this._frameRequest = null;
      this._callbacks = callbacks;

      if (typeof payload === 'function') {
        this._framesRequestLength = 1;
        this._downloadDataFn = payload;
      } else {
        this.parseBinaryData(payload, true);
      }

      this.reset();
      this.setFrame(0);
    }

    _createClass(FrameInfo, [{
      key: "_prepareBuffer",
      value: function _prepareBuffer(framesStart, framesEnd) {
        if (framesStart === undefined || framesStart === null) {
          framesStart = 0;
        }

        if (framesEnd === undefined || framesEnd === null) {
          framesEnd = framesStart + this._framesRequestLength;
        }

        if (this._framesCount !== undefined) {
          framesEnd = Math.min(this._framesCount - 1, framesEnd);
        }

        if (this._downloadDataFn) {
          var self = this;

          var onDone = function onDone(data) {
            self.isLoading = false;

            if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
              self._callbacks.onLoadStatusChanged();
            }

            self._buffer = {
              data: data,
              state: 'ready',
              start: framesStart,
              end: framesEnd
            };

            if (self._frameRequest !== null) {
              var idx = self._frameRequest;
              self._frameRequest = null;
              self.setFrame(idx);
            }
          };

          var onFail = function onFail() {
            self.isLoading = false;

            if (self._callbacks && typeof self._callbacks.onError === 'function') {
              self._callbacks.onError('Streaming failed');
            }
          };

          if (!this._buffer) {
            this._buffer = {};
          }

          this._buffer.state = 'downloading';
          this.isLoading = true;

          if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
            self._callbacks.onLoadStatusChanged();
          }

          this._downloadDataFn({
            start: framesStart,
            end: framesEnd + 1
          }, onDone, onFail);
        }
      }
    }, {
      key: "_parseBuffer",
      value: function _parseBuffer() {
        if (this._buffer && this._buffer.state === 'ready') {
          this._framesRange = {
            start: this._buffer.start,
            end: this._buffer.end
          };
          this.parseBinaryData(this._buffer.data, false);

          var _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;

          if (_bufferRequestStart >= this._framesCount) {
            _bufferRequestStart = 0;
          }

          this._buffer = {
            state: 'none'
          };

          this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);

          if (this._frameRequest !== null) {
            var idx = this._frameRequest;
            this._frameRequest = null;
            this.setFrame(idx);
          }
        }
      }
    }, {
      key: "parseBinaryData",
      value: function parseBinaryData(arrayBuffer) {
        var dataView = new DataView(arrayBuffer);
        var offset = 0;
        var atomsCount = dataView.getUint32(offset, true);
        offset += 4;
        var framesCount = dataView.getUint32(offset, true);
        this._framesCount = framesCount;
        this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
        offset += 4;
        this._atomsCount = atomsCount;
        var maxSize = 1024 * 1024;
        this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
        var chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;

        if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
          throw new Error();
        }

        var complex = this._complex;
        var timeStep = dataView.getUint32(offset, true);
        var iName = 0;

        while (timeStep > 1000 && iName < cSecNames.length - 1) {
          timeStep /= 1000;
          ++iName;
        }

        this._timeStep = "".concat(timeStep.toString(), " ").concat(cSecNames[iName]);
        offset += 4;
        var secondary = [];
        var posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
        var coordIdx = 0;
        var secondaryArr = new Int8Array(atomsCount);

        for (var j = 0; j < chunkedFramesCount; ++j) {
          for (var i = 0; i < atomsCount; ++i) {
            var hiWord = dataView.getUint32(offset, true);
            offset += 4;
            var loWord = dataView.getUint32(offset, true);
            offset += 4;
            var str = (loWord & cStrMask) >>> cStrShift;
            var x = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
            var y = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
            var z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
            secondaryArr[i] = 0;

            if (str > 0 && str < 4) {
              secondaryArr[i] = cHelixIdx;
            } else if (str === 4) {
              secondaryArr[i] = cSheetIdx;
            }

            posData[coordIdx++] = x / 100;
            posData[coordIdx++] = y / 100;
            posData[coordIdx++] = z / 100;
          }

          secondary.push(_createSecondary(secondaryArr, complex));
        }

        this._secondaryData = secondary;
        this._data = posData;
      }
    }, {
      key: "nextFrame",
      value: function nextFrame() {
        this.setFrame((this._currFrame + 1) % this._framesCount);
      }
    }, {
      key: "needsColorUpdate",
      value: function needsColorUpdate(colorer) {
        return colorer instanceof SecondaryStructureColorer;
      }
    }, {
      key: "getAtomColor",
      value: function getAtomColor(colorer, atom) {
        return colorer.getResidueColor(this._residues[atom.residue._index], this._complex);
      }
    }, {
      key: "getResidueColor",
      value: function getResidueColor(colorer, residue) {
        return colorer.getResidueColor(this._residues[residue._index], this._complex);
      }
    }, {
      key: "_updateSecondary",
      value: function _updateSecondary() {
        var i;
        var myResidues = this._residues;
        var n = myResidues.length;

        for (i = 0; i < n; ++i) {
          myResidues[i]._secondary = null;
        }

        var sec = this._secondaryData[this._currFrame - this._framesRange.start];

        for (i = 0, n = sec.length; i < n; ++i) {
          var oldSec = sec[i];
          var start = oldSec.start,
              end = oldSec.end;
          var nSec = {
            _start: myResidues[start],
            _end: myResidues[end],
            type: oldSec.type,
            generic: oldSec.generic
          };

          for (var j = start; j <= end; ++j) {
            myResidues[j]._secondary = nSec;
          }
        }
      }
    }, {
      key: "reset",
      value: function reset() {
        var compRes = this._complex._residues;
        var n = compRes.length;
        this._residues = new Array(n);
        var myResidues = this._residues;

        var getSec = function getSec() {
          return this._secondary;
        };

        for (var i = 0; i < n; ++i) {
          myResidues[i] = {
            _type: compRes[i]._type,
            _isValid: compRes[i]._isValid,
            _controlPoint: null,
            _wingVector: null,
            _secondary: null,
            getSecondary: getSec
          };
        }
      }
    }, {
      key: "setFrame",
      value: function setFrame(frameIdx) {
        this.frameIsReady = false;

        if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
          this._currFrame = frameIdx;
          this._cachedResidues = false;

          this._updateSecondary();

          this.frameIsReady = true;
        } else {
          this._frameRequest = frameIdx;

          if (!this._buffer) {
            this._prepareBuffer(frameIdx);
          } else {
            var self = this;

            switch (this._buffer.state) {
              case 'none':
                this._prepareBuffer(frameIdx);

                break;

              case 'ready':
                self._parseBuffer();

                break;
            }
          }
        }
      }
    }, {
      key: "disableEvents",
      value: function disableEvents() {
        this._callbacks = null;
      }
    }, {
      key: "getAtomPos",
      value: function getAtomPos(atomIdx) {
        var vec = FrameInfo._vec;
        var self = this;
        var data = self._data;
        var idx = (self._atomsCount * (self._currFrame - self._framesRange.start) + atomIdx) * 3;
        vec.set(data[idx], data[idx + 1], data[idx + 2]);
        return vec;
      }
    }, {
      key: "getResidues",
      value: function getResidues() {
        if (this._cachedResidues) {
          return this._residues;
        }

        this._complex.updateToFrame(this);

        return this._residues;
      }
    }]);

    return FrameInfo;
  }();

  _defineProperty(FrameInfo, "_vec", new THREE__namespace.Vector3());

  var SceneObject = /*#__PURE__*/function () {
    function SceneObject(params, opts) {
      _classCallCheck(this, SceneObject);

      if (this.constructor === SceneObject) {
        throw new Error('Can not instantiate abstract class!');
      }

      this.params = params;
      this.opts = ___default["default"].merge(utils.deriveDeep(settings$1.now.objects[this.type], true), opts);
      this.needsRebuild = false;
      this._mesh = null;
      this.id = null;
    }

    _createClass(SceneObject, [{
      key: "identify",
      value: function identify() {
        var result = {
          type: this.type,
          params: this.params
        };
        var diff = utils.objectsDiff(this.opts, settings$1.now.modes[this.id]);

        if (!___default["default"].isEmpty(diff)) {
          result.opts = diff;
        }

        return result;
      }
    }, {
      key: "toString",
      value: function toString() {
        var paramsStr = "o=".concat(this.type, ",").concat(this.params.join(','));
        var optsStr = utils.compareOptionsWithDefaults(this.opts, settings$1.defaults.objects[this.type]);
        return paramsStr + optsStr;
      }
    }, {
      key: "getGeometry",
      value: function getGeometry() {
        return this._mesh;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this._mesh) {
          gfxutils.destroyObject(this._mesh);
        }
      }
    }]);

    return SceneObject;
  }();

  SceneObject.prototype.type = '__';

  function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var LinesObj = /*#__PURE__*/function (_SceneObject) {
    _inherits(LinesObj, _SceneObject);

    var _super = _createSuper$6(LinesObj);

    function LinesObj(params, opts) {
      var _this;

      _classCallCheck(this, LinesObj);

      _this = _super.call(this, params, opts);

      if (params.length < 2) {
        throw new Error('Wrong number of argumets on line object creation!');
      }

      var _params = _slicedToArray(params, 2);

      _this._id1 = _params[0];
      _this._id2 = _params[1];
      return _this;
    }

    _createClass(LinesObj, [{
      key: "_getAtomFromName",
      value: function _getAtomFromName(complex, atomId) {
        var err = " - Wrong atom format it must be '#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME' (e.g. 'A.38.CO1')";
        var atom1 = complex.getAtomByFullname(atomId);

        if (!atom1) {
          throw new Error(atomId + err);
        }

        return atom1;
      }
    }, {
      key: "build",
      value: function build(complex) {
        var geom = new THREE__namespace.BufferGeometry();
        this._atom1 = this._getAtomFromName(complex, this._id1);
        this._atom2 = this._getAtomFromName(complex, this._id2);
        var p1 = this._atom1.position;
        var p2 = this._atom2.position;
        var vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z]);
        geom.setAttribute('position', new THREE__namespace.BufferAttribute(vertices, 3));
        geom.computeBoundingBox();
        var material = new UberMaterial();
        material.setValues({
          lights: false,
          overrideColor: true,
          dashedLine: true,
          fogTransparent: settings$1.now.bg.transparent
        });
        this._line = new meshes.Line(geom, material);

        this._line.computeLineDistances();

        this._line.material.setUberOptions({
          fixedColor: new THREE__namespace.Color(this.opts.color),
          dashedLineSize: this.opts.dashSize,
          dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
        });

        this._line.material.updateUniforms();

        this._line.raycast = function (_raycaster, _intersects) {};

        this._mesh = this._line;
        var transforms = complex.getTransforms();

        if (transforms.length > 0) {
          this._mesh = new THREE__namespace.Group();

          this._mesh.add(this._line);

          meshutils.applyTransformsToMeshes(this._mesh, transforms);
        }
      }
    }, {
      key: "updateToFrame",
      value: function updateToFrame(frameData) {
        if (!this._atom1 || !this._atom2 || !this._line) {
          return;
        }

        var geo = this._line.geometry;
        geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index));
        geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index));

        this._line.computeLineDistances();

        geo.computeBoundingSphere();
        geo.verticesNeedUpdate = true;
      }
    }]);

    return LinesObj;
  }(SceneObject);

  LinesObj.prototype.constructor = LinesObj;
  LinesObj.prototype.type = 'line';

  var fragmentShader$5 = "precision highp float;\r\n\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nuniform vec2 thickness;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = thickness / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n";

  function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var OutlineMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(OutlineMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$5(OutlineMaterial);

    function OutlineMaterial(params) {
      var _this;

      _classCallCheck(this, OutlineMaterial);

      _this = _super.call(this, params);
      var settings = {
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcDepthTex: {
            type: 't',
            value: null
          },
          srcTexSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(512, 512)
          },
          color: {
            type: 'v3',
            value: null
          },
          threshold: {
            type: 'f',
            value: null
          },
          opacity: {
            type: 'f',
            value: 1.0
          },
          thickness: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1, 1)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$5,
        transparent: true,
        depthTest: false,
        depthWrite: false
      };

      _this.setValues(settings);

      return _this;
    }

    _createClass(OutlineMaterial, [{
      key: "copy",
      value: function copy(source) {
        _get(_getPrototypeOf(OutlineMaterial.prototype), "copy", this).call(this, source);

        this.depth = source.depth;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        }

        _get(_getPrototypeOf(OutlineMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.depth) {
          defines.DEPTH_OUTLINE = 1;
        }

        this.defines = defines;
      }
    }]);

    return OutlineMaterial;
  }(THREE__namespace.RawShaderMaterial);

  OutlineMaterial.prototype.depth = false;

  var fragmentShader$4 = "precision highp float;\r\n\r\n// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r\n  // visibly, thus we decided to leave calculation here for better readability.\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n";

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var FXAAMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(FXAAMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$4(FXAAMaterial);

    function FXAAMaterial(params) {
      var _this;

      _classCallCheck(this, FXAAMaterial);

      _this = _super.call(this, params);

      _this.setValues({
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          bgColor: {
            type: 'c',
            value: new THREE__namespace.Color(0xffffff)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$4,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      _this.setValues(params);

      return _this;
    }

    _createClass(FXAAMaterial, [{
      key: "copy",
      value: function copy(source) {
        _get(_getPrototypeOf(FXAAMaterial.prototype), "copy", this).call(this, source);

        this.depth = source.depth;
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        }

        _get(_getPrototypeOf(FXAAMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.bgTransparent) {
          defines.BG_TRANSPARENT = 1;
        }

        this.defines = defines;
      }
    }]);

    return FXAAMaterial;
  }(THREE__namespace.RawShaderMaterial);

  FXAAMaterial.prototype.bgTransparent = false;

  var fragmentShader$3 = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 32\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  vec4 normalData = texture2D(normalTexture, vUv);\r\n  // return for background fragments (their normals are zero vectors)\r\n  if (length(normalData.rgb) < EPSILON) {\r\n    // 0.0 in alpha component means that it is background fragment\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r\n  // normalData.a store 1.0 if normal was build for frontfaced surface\r\n  // and 0.0 in other case\r\n  if (normalData.a < EPSILON) {\r\n    normal *= -1.0;\r\n  }\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n";

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var _samplesKernel = [new THREE__namespace.Vector3(0.295184, 0.077723, 0.068429), new THREE__namespace.Vector3(-0.271976, -0.365221, 0.838363), new THREE__namespace.Vector3(0.547713, 0.467576, 0.488515), new THREE__namespace.Vector3(0.662808, -0.031733, 0.584758), new THREE__namespace.Vector3(-0.025717, 0.218955, 0.657094), new THREE__namespace.Vector3(-0.310153, -0.365223, 0.370701), new THREE__namespace.Vector3(-0.101407, -0.006313, 0.747665), new THREE__namespace.Vector3(-0.769138, 0.360399, 0.086847), new THREE__namespace.Vector3(-0.271988, -0.27514, 0.905353), new THREE__namespace.Vector3(0.09674, -0.566901, 0.700151), new THREE__namespace.Vector3(0.562872, -0.735136, 0.094647), new THREE__namespace.Vector3(0.379877, 0.359278, 0.190061), new THREE__namespace.Vector3(0.519064, -0.023055, 0.405068), new THREE__namespace.Vector3(-0.301036, 0.114696, 0.088885), new THREE__namespace.Vector3(-0.282922, 0.598305, 0.487214), new THREE__namespace.Vector3(-0.181859, 0.25167, 0.679702), new THREE__namespace.Vector3(-0.191463, -0.635818, 0.512919), new THREE__namespace.Vector3(-0.293655, 0.427423, 0.078921), new THREE__namespace.Vector3(-0.267983, 0.680534, 0.13288), new THREE__namespace.Vector3(0.139611, 0.319637, 0.477439), new THREE__namespace.Vector3(-0.352086, 0.31104, 0.653913), new THREE__namespace.Vector3(0.321032, 0.805279, 0.487345), new THREE__namespace.Vector3(0.073516, 0.820734, 0.414183), new THREE__namespace.Vector3(-0.155324, 0.589983, 0.41146), new THREE__namespace.Vector3(0.335976, 0.170782, 0.527627), new THREE__namespace.Vector3(0.46346, -0.355658, 0.167689), new THREE__namespace.Vector3(0.222654, 0.59655, 0.769406), new THREE__namespace.Vector3(0.922138, -0.04207, 0.147555), new THREE__namespace.Vector3(-0.72705, -0.329192, 0.369826), new THREE__namespace.Vector3(-0.090731, 0.53382, 0.463767), new THREE__namespace.Vector3(-0.323457, -0.876559, 0.238524), new THREE__namespace.Vector3(-0.663277, -0.372384, 0.342856)];

  var AOMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(AOMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$3(AOMaterial);

    function AOMaterial() {
      var _this;

      _classCallCheck(this, AOMaterial);

      _this = _super.call(this);

      _this.setValues({
        uniforms: {
          noiseTexture: {
            type: 't',
            value: noise.noiseTexture
          },
          noiseTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / noise.noiseWidth, 1.0 / noise.noiseHeight)
          },
          diffuseTexture: {
            type: 't',
            value: null
          },
          normalTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          camNearFar: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0, 10.0)
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE__namespace.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          samplesKernel: {
            type: 'v3v',
            value: _samplesKernel
          },
          kernelRadius: {
            type: 'f',
            value: 1.0
          },
          depthThreshold: {
            type: 'f',
            value: 1.0
          },
          factor: {
            type: 'f',
            value: 1.0
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$3,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      return _this;
    }

    return AOMaterial;
  }(THREE__namespace.RawShaderMaterial);

  var fragmentShader$2 = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = res;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb = res.rgb / weightSum;\r\n  gl_FragColor = res;\r\n}\r\n";

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var _kernelOffsets$1 = [-2.0, -1.0, 0.0, 1.0, 2.0];

  var AOHorBlurMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(AOHorBlurMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$2(AOHorBlurMaterial);

    function AOHorBlurMaterial() {
      var _this;

      _classCallCheck(this, AOHorBlurMaterial);

      _this = _super.call(this);

      _this.setValues({
        uniforms: {
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets$1
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$2,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      return _this;
    }

    return AOHorBlurMaterial;
  }(THREE__namespace.RawShaderMaterial);

  var fragmentShader$1 = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nuniform mat4  projMatrix;\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\n#ifdef USE_FOG\r\n  uniform vec2 fogNearFar;\r\n  uniform vec4 fogColor;\r\n#endif\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n  projPos.y * tanHalfFOV * abs(viewPos.z)\r\n  );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = color;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb /= weightSum;\r\n\r\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r\n    // Add fog to the result value\r\n    // Proper way to get an image with fog and ao requires formula:\r\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r\n    // We have:  AO, fogFactor, fogColor,\r\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r\n    //                                                                where molecule has been already drawn with fog)\r\n    // Transform:\r\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\r\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r\n  #else\r\n    gl_FragColor.rgb = color.rgb * res.rgb;\r\n  #endif\r\n  gl_FragColor.a = color.a;\r\n}\r\n";

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var _kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0];

  var AOVertBlurWithBlendMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(AOVertBlurWithBlendMaterial, _THREE$RawShaderMater);

    var _super = _createSuper$1(AOVertBlurWithBlendMaterial);

    function AOVertBlurWithBlendMaterial(params) {
      var _this;

      _classCallCheck(this, AOVertBlurWithBlendMaterial);

      _this = _super.call(this, params);

      _this.setValues({
        uniforms: {
          diffuseTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE__namespace.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          fogNearFar: {
            type: 'v2',
            value: new THREE__namespace.Vector2(100.0, 100.0)
          },
          fogColor: {
            type: 'v4',
            value: new THREE__namespace.Vector4(0.0, 0.5, 0.0, 1.0)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$1,
        transparent: false,
        depthTest: false,
        depthWrite: false
      });

      _this.setValues(params);

      return _this;
    }

    _createClass(AOVertBlurWithBlendMaterial, [{
      key: "setValues",
      value: function setValues(values) {
        if (typeof values === 'undefined') {
          return;
        }

        _get(_getPrototypeOf(AOVertBlurWithBlendMaterial.prototype), "setValues", this).call(this, values);

        var defines = {};

        if (this.useFog) {
          defines.USE_FOG = 1;
        }

        if (this.fogTransparent) {
          defines.FOG_TRANSPARENT = 1;
        }

        this.defines = defines;
      }
    }]);

    return AOVertBlurWithBlendMaterial;
  }(THREE__namespace.RawShaderMaterial);

  AOVertBlurWithBlendMaterial.prototype.useFog = true;
  AOVertBlurWithBlendMaterial.prototype.fogTransparent = false;

  var fragmentShader = "precision highp float;\r\n\r\nuniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n";

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  var AnaglyphMaterial = /*#__PURE__*/function (_THREE$RawShaderMater) {
    _inherits(AnaglyphMaterial, _THREE$RawShaderMater);

    var _super = _createSuper(AnaglyphMaterial);

    function AnaglyphMaterial() {
      var _this;

      _classCallCheck(this, AnaglyphMaterial);

      _this = _super.call(this);
      var settings = {
        uniforms: {
          srcL: {
            type: 't',
            value: null
          },
          srcR: {
            type: 't',
            value: null
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader,
        transparent: false,
        depthTest: false,
        depthWrite: false
      };

      _this.setValues(settings);

      return _this;
    }

    return AnaglyphMaterial;
  }(THREE__namespace.RawShaderMaterial);

  var View = /*#__PURE__*/function () {
    function View() {
      _classCallCheck(this, View);

      this.position = new THREE__namespace.Vector3(0, 0, 0);
      this.scale = 1;
      this.orientation = new THREE__namespace.Quaternion(0, 0, 0, 1);
    }

    _createClass(View, [{
      key: "set",
      value: function set(position, scale, orientation) {
        this.position = position;
        this.scale = scale;
        this.orientation = orientation;
      }
    }]);

    return View;
  }();

  var _transitionTime = 1.5;

  var ViewInterpolator = /*#__PURE__*/function () {
    function ViewInterpolator() {
      _classCallCheck(this, ViewInterpolator);
    }

    _createClass(ViewInterpolator, [{
      key: "setup",
      value: function setup(startView, endView) {
        this._startTime = undefined;
        this._endTime = undefined;
        this._isPaused = false;
        this._srcView = startView;
        this._dstView = endView;
        this._isMoving = false;
      }
    }, {
      key: "isMoving",
      value: function isMoving() {
        return this._isMoving;
      }
    }, {
      key: "wasStarted",
      value: function wasStarted() {
        return typeof this._startTime !== 'undefined' && typeof this._endTime !== 'undefined';
      }
    }, {
      key: "start",
      value: function start() {
        this._startTime = Date.now();
        var transTime = settings$1.now.interpolateViews ? _transitionTime * 1000 : 0;
        this._endTime = this._startTime + transTime;
        this._isMoving = true;
      }
    }, {
      key: "getCurrentView",
      value: function getCurrentView() {
        if (typeof this._srcView === 'undefined' || typeof this._dstView === 'undefined' || !this._isMoving || !this.wasStarted()) {
          return {
            success: false
          };
        }

        var view = this.createView();
        var time = Date.now();

        if (time > this._endTime) {
          view = this._dstView;
          this.reset();
          return {
            success: true,
            view: view
          };
        }

        var factor = (time - this._startTime) / (this._endTime - this._startTime);
        view.position.copy(this._srcView.position);
        view.position.lerp(this._dstView.position, factor);
        view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
        view.orientation.copy(this._srcView.orientation);
        view.orientation.slerp(this._dstView.orientation, factor);
        return {
          success: true,
          view: view
        };
      }
    }, {
      key: "reset",
      value: function reset() {
        this._startTime = this._endTime = 0;
        this._isMoving = false;
      }
    }, {
      key: "pause",
      value: function pause() {
        if (!this._isPaused) {
          this.setup(this.getCurrentView().view, this._dstView);
          this._isPaused = true;
        }
      }
    }, {
      key: "resume",
      value: function resume() {
        this._isPaused = false;
      }
    }, {
      key: "createView",
      value: function createView() {
        return new View();
      }
    }]);

    return ViewInterpolator;
  }();

  var MAX_COOKIE_LEN = 4000;
  var COUNT_SUFFIX = 'Cnt';

  function _chunkString(string, chunkLen) {
    var l = string.length;
    var chunks = [];

    for (var c = 0, lc = 0; lc < l; c++, lc += chunkLen) {
      chunks[c] = string.slice(lc, lc + chunkLen);
    }

    return chunks;
  }

  function Cookies(context, opts) {
    this.context = context;
    this._opts = ___default["default"].merge({
      path: '/'
    }, opts);
  }

  makeContextDependent(Cookies.prototype);

  Cookies.prototype.removeCookie = function (key) {
    var cntKey = this._toCount(key);

    var cntVal = this._getSimpleCookie(cntKey);

    if (!cntVal) {
      this._removeSimpleCookie(key);

      return;
    }

    this._removeSimpleCookie(cntKey);

    cntVal = parseInt(cntVal, 10);

    for (var i = 0; i < cntVal; ++i) {
      this._removeSimpleCookie(key + i);
    }
  };

  Cookies.prototype.setCookie = function (key, value) {
    this.removeCookie(key);
    value = encodeURIComponent(value);

    var values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1);

    var cntVal = values.length;

    if (cntVal === 1) {
      this._setSimpleCookie(key, value);

      return;
    }

    var cntKey = this._toCount(key);

    this._setSimpleCookie(cntKey, cntVal.toString());

    for (var i = 0; i < cntVal; ++i) {
      this._setSimpleCookie(key + i, values[i]);
    }
  };

  Cookies.prototype.getCookie = function (key) {
    var cntKey = this._toCount(key);

    var cntVal = this._getSimpleCookie(cntKey);

    if (!cntVal) {
      return this._getSimpleCookie(key);
    }

    cntVal = parseInt(cntVal, 10);
    var value = [];

    for (var i = 0; i < cntVal; ++i) {
      value[i] = this._getSimpleCookie(key + i);
    }

    return value.join('');
  };

  Cookies.prototype._toCount = function (key) {
    return key + COUNT_SUFFIX;
  };

  Cookies.prototype._removeSimpleCookie = function (key) {
    document.cookie = "".concat(key, "=; expires=Thu, 01 Jan 1970 00:00:01 GMT;");
  };

  Cookies.prototype._getExpirationDate = function () {
    var today = new Date();
    var EXP_PERIOD_YEARS = 10;
    today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
    return today;
  };

  Cookies.prototype._setSimpleCookie = function (key, value) {
    document.cookie = "".concat(key, "=").concat(value, ";expires=").concat(this._getExpirationDate().toUTCString(), ";path=").concat(this._opts.path);
  };

  Cookies.prototype._getSimpleCookie = function (key) {
    var matches = document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
    return matches ? decodeURIComponent(matches[1]) : '';
  };

  Cookies.prototype._exists = function (key) {
    return document.cookie.match(new RegExp("(?:^|; )".concat(key, "=([^;]*)")));
  };

  function createWebVRButton (webVRPoC) {
    function showEnterVR(button) {
      button.style.display = '';
      button.style.cursor = 'pointer';
      button.style.left = 'calc(50% - 50px)';
      button.style.width = '100px';
      button.textContent = 'ENTER VR';
      var currentSession = null;

      function onSessionEnded() {
        currentSession.removeEventListener('end', onSessionEnded);
        button.textContent = 'ENTER VR';
        currentSession = null;
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);

        webVRPoC._gfx.renderer.xr.setReferenceSpaceType('local');

        webVRPoC._gfx.renderer.xr.setSession(session);

        button.textContent = 'EXIT VR';
        currentSession = session;
      }

      button.onmouseenter = function () {
        button.style.opacity = '1.0';
      };

      button.onmouseleave = function () {
        button.style.opacity = '0.5';
      };

      button.onclick = function () {
        if (currentSession === null) {
          var sessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor']
          };
          navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
          webVRPoC.moveSceneBehindHeadset();
        } else {
          currentSession.end();
        }
      };
    }

    function showWebXRNotFound(button) {
      button.style.display = '';
      button.style.cursor = 'auto';
      button.style.left = 'calc(50% - 75px)';
      button.style.width = '150px';
      button.textContent = 'VR NOT FOUND';
      button.onmouseenter = null;
      button.onmouseleave = null;
      button.onclick = null;
    }

    function stylizeElement(element) {
      element.style.position = 'absolute';
      element.style.bottom = '20px';
      element.style.padding = '12px 6px';
      element.style.border = '1px solid #fff';
      element.style.borderRadius = '4px';
      element.style.background = 'transparent';
      element.style.color = '#fff';
      element.style.font = 'normal 13px sans-serif';
      element.style.textAlign = 'center';
      element.style.opacity = '0.5';
      element.style.outline = 'none';
      element.style.zIndex = '999';
    }

    if ('xr' in navigator) {
      var button = document.createElement('button');
      button.style.display = 'none';
      stylizeElement(button);
      navigator.xr.isSessionSupported('immersive-vr').then(function (supported) {
        return supported ? showEnterVR(button) : showWebXRNotFound(button);
      });
      return button;
    }

    var message = document.createElement('a');
    message.href = 'https://webvr.info';
    message.innerHTML = 'WEBXR NOT SUPPORTED';
    message.style.left = 'calc(50% - 90px)';
    message.style.width = '180px';
    message.style.textDecoration = 'none';
    stylizeElement(message);
    return message;
  }

  var WebVRPoC = /*#__PURE__*/function () {
    function WebVRPoC(onToggle) {
      _classCallCheck(this, WebVRPoC);

      this._mainCamera = new THREE__namespace.PerspectiveCamera();
      this._button = null;
      this._onToggle = onToggle;
      this._molContainer = new gfxutils.RCGroup();
      this._user = new gfxutils.RCGroup();
      this._scalingPivot = new THREE__namespace.Object3D();

      this._user.add(this._scalingPivot);

      this._controller1 = null;
      this._controller2 = null;
      this._pressedGripsCounter = 0;
      this._distance = 0;
      this._gfx = null;
    }

    _createClass(WebVRPoC, [{
      key: "startScalingByControllers",
      value: function startScalingByControllers() {
        this._distance = this._controller1.position.distanceTo(this._controller2.position);
        gfxutils.getMiddlePoint(this._controller1.position, this._controller2.position, this._scalingPivot.position);

        this._scalingPivot.scale.set(1, 1, 1);

        this._scalingPivot.updateMatrix();

        this._scalingPivot.updateMatrixWorld();

        this._scalingPivot.addSavingWorldTransform(this._molContainer);
      }
    }, {
      key: "stopScalingByControllers",
      value: function stopScalingByControllers() {
        this._gfx.scene.addSavingWorldTransform(this._molContainer);
      }
    }, {
      key: "handleGripsDown",
      value: function handleGripsDown(event) {
        this._pressedGripsCounter++;

        if (this._pressedGripsCounter === 2) {
          this.startScalingByControllers();
        } else if (this._pressedGripsCounter === 1) {
          event.target.addSavingWorldTransform(this._molContainer);
        }
      }
    }, {
      key: "handleGripsUp",
      value: function handleGripsUp(event) {
        this._pressedGripsCounter--;

        if (this._pressedGripsCounter === 1) {
          this.stopScalingByControllers();
          var anotherController = event.target === this._controller1 ? this._controller2 : this._controller1;
          anotherController.addSavingWorldTransform(this._molContainer);
        } else if (this._pressedGripsCounter === 0) {
          this._gfx.scene.addSavingWorldTransform(this._molContainer);
        }
      }
    }, {
      key: "enable",
      value: function enable(gfx) {
        if (!gfx) {
          logger.warn("WebVR couldn't be enabled, because gfx is not defined");
          return;
        }

        this._gfx = gfx;
        var renderer = gfx.renderer,
            camera = gfx.camera;

        if (!renderer) {
          throw new Error('No renderer is available to toggle WebVR');
        }

        if (!camera) {
          throw new Error('No camera is available to toggle WebVR');
        }

        renderer.xr.enabled = true;

        if (!this._button) {
          this._button = createWebVRButton(this);
          document.body.appendChild(this._button);
        } else {
          this._button.style.display = 'block';
        }

        this._mainFog = settings$1.now.fog;
        settings$1.set('fog', false);

        this._plugVRNodesIntoScene(gfx, renderer);

        this._setControllersListeners();

        if (this._onToggle) {
          this._onToggle(true);
        }
      }
    }, {
      key: "_plugVRNodesIntoScene",
      value: function _plugVRNodesIntoScene(gfx, renderer) {
        this._mainCamera.copy(gfx.camera);

        gfx.scene.add(this._user);
        gfx.scene.add(this._molContainer);

        this._molContainer.add(gfx.root);

        this._controller1 = renderer.xr.getController(0);
        this._controller2 = renderer.xr.getController(1);

        var mesh = this._createControllerMesh();

        this._controller1.add(mesh);

        this._controller2.add(mesh.clone());

        this._user.add(this._controller1);

        this._user.add(this._controller2);
      }
    }, {
      key: "_setControllersListeners",
      value: function _setControllersListeners() {
        var _this = this;

        this._controller1.addEventListener('selectstart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller1.addEventListener('selectend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller2.addEventListener('selectstart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller2.addEventListener('selectend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller1.addEventListener('squeezestart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller1.addEventListener('squeezeend', function (event) {
          _this.handleGripsUp(event);
        });

        this._controller2.addEventListener('squeezestart', function (event) {
          _this.handleGripsDown(event);
        });

        this._controller2.addEventListener('squeezeend', function (event) {
          _this.handleGripsUp(event);
        });
      }
    }, {
      key: "disable",
      value: function disable() {
        if (!this._gfx) {
          return;
        }

        var _this$_gfx = this._gfx,
            renderer = _this$_gfx.renderer,
            camera = _this$_gfx.camera;

        if (!renderer) {
          throw new Error('No renderer is available to toggle WebVR');
        }

        renderer.setAnimationLoop(null);
        var session = renderer.xr.getSession();

        if (session) {
          session.end();
        }

        renderer.xr.enabled = false;

        if (this._button) {
          this._button.style.display = 'none';
        }

        settings$1.set('fog', this._mainFog);

        this._unplugVRNodesFromScene(camera);

        if (this._onToggle) {
          this._onToggle(false);
        }
      }
    }, {
      key: "_unplugVRNodesFromScene",
      value: function _unplugVRNodesFromScene(camera) {
        if (this._mainCamera && camera) {
          camera.copy(this._mainCamera);
        }

        var root = this._molContainer.children[0];

        if (root) {
          this._gfx.scene.add(root);
        }

        this._molContainer.parent.remove(this._molContainer);

        if (this._user) {
          this._gfx.scene.remove(this._user);
        }

        this._molContainer = null;
        this._user = null;
        this._scalingPivot = null;
        this._user = null;
        this._controller1 = null;
        this._controller2 = null;
      }
    }, {
      key: "_createControllerMesh",
      value: function _createControllerMesh() {
        var geometry = new THREE__namespace.CylinderGeometry(0.04, 0.04, 0.3);
        var material = new UberMaterial();
        material.setValues({
          lights: false,
          overrideColor: true
        });
        material.setUberOptions({
          fixedColor: new THREE__namespace.Color(0x4444ff)
        });
        material.updateUniforms();
        var cylinder = new THREE__namespace.Mesh(geometry, material);
        cylinder.rotateX(-Math.PI / 2);
        return cylinder;
      }
    }, {
      key: "updateMoleculeScale",
      value: function updateMoleculeScale() {
        if (!this._controller1 || !this._controller2) {
          return;
        }

        var self = this;

        if (self._pressedGripsCounter === 2) {
          gfxutils.getMiddlePoint(self._controller1.position, self._controller2.position, self._scalingPivot.position);

          var dist = self._controller1.position.distanceTo(self._controller2.position);

          var scaler = dist / self._distance;

          self._scalingPivot.scale.multiplyScalar(scaler);

          self._distance = dist;
        }
      }
    }, {
      key: "moveSceneBehindHeadset",
      value: function moveSceneBehindHeadset() {
        var gfx = this._gfx;
        var camera = gfx.camera;
        var container = this._molContainer;
        container.matrix.identity();
        container.position.set(0, 0, -4.0);
        container.updateMatrix();
        container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix);
        gfx.scene.addSavingWorldTransform(container);

        if (this._onToggle) {
          this._onToggle(true);
        }
      }
    }, {
      key: "getCanvas",
      value: function getCanvas() {
        var gfx = this._gfx;
        return gfx && gfx.renderer ? gfx.renderer.domElement : null;
      }
    }]);

    return WebVRPoC;
  }();

  var fragmentScreenQuadFromDistTex = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform vec3 aberration;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  \r\n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r\n  gl_FragColor.a = 1.0;\r\n}";

  var selectors$1 = chem.selectors,
      Atom = chem.Atom,
      Residue = chem.Residue,
      Chain = chem.Chain,
      Molecule = chem.Molecule;
  var EDIT_MODE = {
    COMPLEX: 0,
    COMPONENT: 1,
    FRAGMENT: 2
  };
  var LOADER_NOT_FOUND = 'Could not find suitable loader for this source';
  var PARSER_NOT_FOUND = 'Could not find suitable parser for this source';
  var createElement = utils.createElement;

  function updateFogRange(fog, center, radius) {
    fog.near = center - radius * settings$1.now.fogNearFactor;
    fog.far = center + radius * settings$1.now.fogFarFactor;
  }

  function removeExtension(fileName) {
    var dot = fileName.lastIndexOf('.');

    if (dot >= 0) {
      fileName = fileName.substr(0, dot);
    }

    return fileName;
  }

  function hasValidResidues(complex) {
    var hasValidRes = false;
    complex.forEachComponent(function (component) {
      component.forEachResidue(function (residue) {
        if (residue._isValid) {
          hasValidRes = true;
        }
      });
    });
    return hasValidRes;
  }

  function reportProgress(log, action, percent) {
    var TOTAL_PERCENT = 100;

    if (percent !== undefined) {
      log.debug("".concat(action, "... ").concat(Math.floor(percent * TOTAL_PERCENT), "%"));
    } else {
      log.debug("".concat(action, "..."));
    }
  }

  function chooseFogColor() {
    return settings$1.now.fogColorEnable ? settings$1.now.fogColor : settings$1.now.bg.color;
  }

  function Miew(opts) {
    EventDispatcher.call(this);
    this._opts = ___default["default"].merge({
      settingsCookie: 'settings',
      cookiePath: '/'
    }, opts);
    this._gfx = null;
    this._interpolator = new ViewInterpolator();
    this._container = opts && opts.container || document.getElementById('miew-container') || ___default["default"].head(document.getElementsByClassName('miew-container')) || document.body;
    this._containerRoot = this._container;
    this._running = false;
    this._halting = false;
    this._building = false;
    this._needRender = true;
    this._hotKeysEnabled = true;
    this.settings = settings$1;
    var log = logger;
    log.console = false;
    log.level = 'info';
    this.logger = log;
    this._cookies = new Cookies(this);
    this.restoreSettings();

    if (opts && opts.settings) {
      this.settings.set(opts.settings);
    }

    this._spinner = null;
    this._loading = [];
    this._animInterval = null;
    this._visuals = {};
    this._curVisualName = null;
    this._objects = [];
    this._sourceWindow = null;
    this.reset();

    if (this._repr) {
      log.debug("Selected ".concat(this._repr.mode.name, " mode with ").concat(this._repr.colorer.name, " colorer."));
    }

    var self = this;
    Miew.registeredPlugins.forEach(function (plugin) {
      plugin.call(self);
    });

    this._initOnSettingsChanged();
  }

  Miew.prototype = Object.create(EventDispatcher.prototype);
  Miew.prototype.constructor = Miew;

  Miew.prototype.getMaxRepresentationCount = function () {
    return ComplexVisual.NUM_REPRESENTATION_BITS;
  };

  function _setContainerContents(container, element) {
    var parent = container;

    while (parent.firstChild) {
      parent.removeChild(parent.firstChild);
    }

    parent.appendChild(element);
  }

  Miew.prototype._updateShadowCamera = function () {
    var shadowMatrix = new THREE__namespace.Matrix4();
    var direction = new THREE__namespace.Vector3();
    var OBB = {
      center: new THREE__namespace.Vector3(),
      halfSize: new THREE__namespace.Vector3()
    };
    return function () {
      this._gfx.scene.updateMatrixWorld();

      for (var i = 0; i < this._gfx.scene.children.length; i++) {
        if (this._gfx.scene.children[i].type === 'DirectionalLight') {
          var light = this._gfx.scene.children[i];
          shadowMatrix.copy(light.shadow.camera.matrixWorldInverse);
          this.getOBB(shadowMatrix, OBB);
          direction.subVectors(light.target.position, light.position);
          light.position.subVectors(OBB.center, direction);
          light.target.position.copy(OBB.center);
          light.shadow.bias = 0.09;
          light.shadow.camera.bottom = -OBB.halfSize.y;
          light.shadow.camera.top = OBB.halfSize.y;
          light.shadow.camera.right = OBB.halfSize.x;
          light.shadow.camera.left = -OBB.halfSize.x;
          light.shadow.camera.near = direction.length() - OBB.halfSize.z;
          light.shadow.camera.far = direction.length() + OBB.halfSize.z;
          light.shadow.camera.updateProjectionMatrix();
        }
      }
    };
  }();

  Miew.prototype.init = function () {
    var container = this._container;
    var elem = utils.createElement('div', {
      class: 'miew-canvas'
    });

    _setContainerContents(container, elem);

    this._container = elem;
    var frag = document.createDocumentFragment();
    frag.appendChild(this._msgMode = createElement('div', {
      class: 'mode-message overlay'
    }, createElement('p', {}, 'COMPONENT EDIT MODE')));
    frag.appendChild(this._msgAtomInfo = createElement('div', {
      class: 'atom-info overlay'
    }, createElement('p', {}, '')));
    container.appendChild(frag);

    if (this._gfx !== null) {
      return true;
    }

    var self = this;

    this._showMessage('Viewer is being initialized...');

    try {
      this._initGfx();

      this._initListeners();

      this._spinner = new Spinner({
        lines: 13,
        length: 28,
        width: 14,
        radius: 42,
        color: '#fff',
        zIndex: 700
      });
      window.top.addEventListener('keydown', function (event) {
        self._onKeyDown(event);
      });
      window.top.addEventListener('keyup', function (event) {
        self._onKeyUp(event);
      });
      this._objectControls = new ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, function () {
        return self._getAltObj();
      });

      this._objectControls.addEventListener('change', function (e) {
        if (settings$1.now.shadow.on) {
          self._updateShadowCamera();
        }

        switch (e.action) {
          case 'rotate':
            self.dispatchEvent({
              type: 'rotate',
              quaternion: e.quaternion
            });
            break;

          case 'zoom':
            self.dispatchEvent({
              type: 'zoom',
              factor: e.factor
            });
            break;

          default:
            self.dispatchEvent({
              type: e.action
            });
        }

        self.dispatchEvent({
          type: 'transform'
        });
        self._needRender = true;
      });

      var gfx = this._gfx;
      this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement);

      this._picker.addEventListener('newpick', function (event) {
        self._onPick(event);
      });

      this._picker.addEventListener('dblclick', function (event) {
        self.center(event);
      });
    } catch (error) {
      if (error.name === 'TypeError' && error.message === "Cannot read property 'getExtension' of null") {
        this._showMessage('Could not create WebGL context.');
      } else if (error.message.search(/webgl/i) > 1) {
        this._showMessage(error.message);
      } else {
        this._showMessage('Viewer initialization failed.');

        throw error;
      }

      return false;
    }

    var file = this._opts && this._opts.load;

    if (file) {
      var type = this._opts && this._opts.type;
      this.load(file, {
        fileType: type,
        keepRepsInfo: true
      });
    }

    return true;
  };

  Miew.prototype.term = function () {
    this._showMessage('Viewer has been terminated.');

    this._loading.forEach(function (job) {
      job.cancel();
    });

    this._loading.length = 0;
    this.halt();
    this._gfx = null;
  };

  Miew.prototype._showMessage = function (msg) {
    var element = document.createElement('div');
    element.setAttribute('class', 'miew-message');
    element.appendChild(document.createElement('p')).appendChild(document.createTextNode(msg));

    _setContainerContents(this._container, element);
  };

  Miew.prototype._showCanvas = function () {
    _setContainerContents(this._container, this._gfx.renderer.domElement);
  };

  Miew.prototype._requestAnimationFrame = function (callback) {
    var xr = this._gfx.renderer.xr;

    if (xr && xr.enabled) {
      this._gfx.renderer.setAnimationLoop(callback);

      return;
    }

    requestAnimationFrame(callback);
  };

  function arezSpritesSupported(context) {
    return context.getExtension('EXT_frag_depth');
  }

  function isAOSupported(context) {
    return context.getExtension('WEBGL_depth_texture') && context.getExtension('WEBGL_draw_buffers');
  }

  Miew.prototype._initGfx = function () {
    var gfx = {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    };
    var webGLOptions = {
      preserveDrawingBuffer: true,
      alpha: true,
      premultipliedAlpha: false
    };

    if (settings$1.now.antialias) {
      webGLOptions.antialias = true;
    }

    gfx.renderer2d = new CSS2DRenderer();
    gfx.renderer = new THREE__namespace.WebGL1Renderer(webGLOptions);
    gfx.renderer.shadowMap.enabled = settings$1.now.shadow.on;
    gfx.renderer.shadowMap.autoUpdate = false;
    gfx.renderer.shadowMap.type = THREE__namespace.PCFShadowMap;
    capabilities.init(gfx.renderer);

    if (!arezSpritesSupported(gfx.renderer.getContext())) {
      settings$1.set('zSprites', false);
    }

    if (!isAOSupported(gfx.renderer.getContext())) {
      settings$1.set('ao', false);
    }

    gfx.renderer.autoClear = false;
    gfx.renderer.setPixelRatio(window.devicePixelRatio);
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
    gfx.renderer.clearColor();
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    gfx.camera = new THREE__namespace.PerspectiveCamera(settings$1.now.camFov, gfx.width / gfx.height, settings$1.now.camNear, settings$1.now.camFar);
    gfx.camera.setMinimalFov(settings$1.now.camFov);
    gfx.camera.position.z = settings$1.now.camDistance;
    gfx.camera.updateProjectionMatrix();
    gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);
    gfx.stereoCam = new THREE__namespace.StereoCamera();
    gfx.scene = new THREE__namespace.Scene();
    var color = chooseFogColor();
    gfx.scene.fog = new THREE__namespace.Fog(color, settings$1.now.camNear, settings$1.now.camFar);
    gfx.root = new gfxutils.RCGroup();
    gfx.scene.add(gfx.root);
    gfx.pivot = new gfxutils.RCGroup();
    gfx.root.add(gfx.pivot);
    gfx.selectionScene = new THREE__namespace.Scene();
    gfx.selectionRoot = new THREE__namespace.Group();
    gfx.selectionRoot.matrixAutoUpdate = false;
    gfx.selectionScene.add(gfx.selectionRoot);
    gfx.selectionPivot = new THREE__namespace.Group();
    gfx.selectionPivot.matrixAutoUpdate = false;
    gfx.selectionRoot.add(gfx.selectionPivot);
    var light12 = new THREE__namespace.DirectionalLight(0xffffff, 0.45);
    light12.position.set(0, 0.414, 1);
    light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
    light12.castShadow = true;
    light12.shadow.bias = 0.09;
    light12.shadow.radius = settings$1.now.shadow.radius;
    light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP);
    var pixelRatio = gfx.renderer.getPixelRatio();
    var shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio;
    light12.shadow.mapSize.width = shadowMapSize;
    light12.shadow.mapSize.height = shadowMapSize;
    light12.target.position.set(0.0, 0.0, 0.0);
    gfx.scene.add(light12);
    gfx.scene.add(light12.target);
    var light3 = new THREE__namespace.AmbientLight(0x666666);
    light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
    gfx.scene.add(light3);
    gfx.axes = new Axes(gfx.root, gfx.camera);
    var deviceWidth = gfx.width * pixelRatio;
    var deviceHeight = gfx.height * pixelRatio;
    gfx.offscreenBuf = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE__namespace.LinearFilter,
      magFilter: THREE__namespace.NearestFilter,
      format: THREE__namespace.RGBAFormat,
      depthBuffer: true
    });

    if (gfx.renderer.getContext().getExtension('WEBGL_depth_texture')) {
      gfx.offscreenBuf.depthTexture = new THREE__namespace.DepthTexture();
      gfx.offscreenBuf.depthTexture.type = THREE__namespace.UnsignedShortType;
    }

    gfx.offscreenBuf2 = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE__namespace.LinearFilter,
      magFilter: THREE__namespace.LinearFilter,
      format: THREE__namespace.RGBAFormat,
      depthBuffer: false
    });
    gfx.offscreenBuf3 = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE__namespace.LinearFilter,
      magFilter: THREE__namespace.LinearFilter,
      format: THREE__namespace.RGBAFormat,
      depthBuffer: false
    });
    gfx.offscreenBuf4 = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE__namespace.LinearFilter,
      magFilter: THREE__namespace.LinearFilter,
      format: THREE__namespace.RGBAFormat,
      depthBuffer: false
    });
    gfx.volBFTex = gfx.offscreenBuf3;
    gfx.volFFTex = gfx.offscreenBuf4;
    gfx.volWFFTex = gfx.offscreenBuf;

    if (gfx.renderer.getContext().getExtension('OES_texture_float')) {
      gfx.offscreenBuf5 = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        type: THREE__namespace.FloatType,
        depthBuffer: false
      });
      gfx.offscreenBuf6 = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        type: THREE__namespace.FloatType,
        depthBuffer: false
      });
      gfx.offscreenBuf7 = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        type: THREE__namespace.FloatType,
        depthBuffer: true
      });
      gfx.volBFTex = gfx.offscreenBuf5;
      gfx.volFFTex = gfx.offscreenBuf6;
      gfx.volWFFTex = gfx.offscreenBuf7;
    } else {
      this.logger.warn("Device doesn't support OES_texture_float extension");
    }

    gfx.stereoBufL = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE__namespace.LinearFilter,
      magFilter: THREE__namespace.LinearFilter,
      format: THREE__namespace.RGBAFormat,
      depthBuffer: false
    });
    gfx.stereoBufR = new THREE__namespace.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: THREE__namespace.LinearFilter,
      magFilter: THREE__namespace.LinearFilter,
      format: THREE__namespace.RGBAFormat,
      depthBuffer: false
    });
    this._gfx = gfx;

    this._showCanvas();

    this._embedWebXR(settings$1.now.stereo === 'WEBVR');

    this._container.appendChild(gfx.renderer2d.getElement());

    var stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.right = '0';
    stats.domElement.style.bottom = '0';

    this._container.appendChild(stats.domElement);

    this._fps = stats;

    this._fps.show(settings$1.now.fps);
  };

  Miew.prototype._initListeners = function () {
    var self = this;
    window.addEventListener('resize', function () {
      self._onResize();
    });
  };

  Miew.prototype._makeUniqueVisualName = function (baseName) {
    if (!baseName) {
      return Math.random().toString();
    }

    var name = baseName;
    var suffix = 1;

    while (this._visuals.hasOwnProperty(name)) {
      name = "".concat(baseName, " (").concat(suffix.toString(), ")");
      suffix++;
    }

    return name;
  };

  Miew.prototype._addVisual = function (visual) {
    if (!visual) {
      return null;
    }

    var name = this._makeUniqueVisualName(visual.name);

    visual.name = name;
    this._visuals[name] = visual;

    this._gfx.pivot.add(visual);

    if (visual.getSelectionGeo) {
      this._gfx.selectionPivot.add(visual.getSelectionGeo());
    }

    return name;
  };

  Miew.prototype._removeVisual = function (visual) {
    var name = '';
    var obj = null;

    if (visual instanceof Visual) {
      name = visual.name;
      obj = visual;
    } else if (typeof visual === 'string') {
      name = visual;
      obj = this._visuals[name];
    }

    if (!obj || !this._visuals.hasOwnProperty(name) || this._visuals[name] !== obj) {
      return;
    }

    if (name === this._curVisualName) {
      this._curVisualName = undefined;
    }

    delete this._visuals[name];
    obj.release();
    this._needRender = true;
  };

  Miew.prototype._forEachVisual = function (callback) {
    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        callback(this._visuals[name]);
      }
    }
  };

  Miew.prototype._releaseAllVisuals = function () {
    if (!this._gfx || !this._gfx.pivot) {
      return;
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        this._visuals[name].release();
      }
    }

    this._visuals = {};
  };

  Miew.prototype._forEachComplexVisual = function (callback) {
    if (!this._gfx || !this._gfx.pivot) {
      return;
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name) && this._visuals[name] instanceof ComplexVisual) {
        callback(this._visuals[name]);
      }
    }
  };

  Miew.prototype._getComplexVisual = function (name) {
    name = name || this._curVisualName;
    var any = null;
    var named = null;

    this._forEachComplexVisual(function (visual) {
      any = visual;

      if (visual.name === name) {
        named = visual;
      }
    });

    return named || any;
  };

  Miew.prototype._getVolumeVisual = function () {
    var any = null;

    this._forEachVisual(function (visual) {
      if (visual instanceof VolumeVisual) {
        any = visual;
      }
    });

    return any;
  };

  Miew.prototype._getVisualForComplex = function (complex) {
    if (!complex) {
      return null;
    }

    var found = null;

    this._forEachComplexVisual(function (visual) {
      if (visual.getComplex() === complex) {
        found = visual;
      }
    });

    return found;
  };

  Miew.prototype.getVisuals = function () {
    return Object.keys(this._visuals);
  };

  Miew.prototype.getComplexVisualsCount = function () {
    var count = 0;

    this._forEachComplexVisual(function () {
      return count++;
    });

    return count;
  };

  Miew.prototype.getCurrentVisual = function () {
    return this._curVisualName;
  };

  Miew.prototype.setCurrentVisual = function (name) {
    if (!this._visuals[name]) {
      return;
    }

    this._curVisualName = name;
  };

  Miew.prototype.run = function () {
    var _this = this;

    if (!this._running) {
      this._running = true;

      if (this._halting) {
        this._halting = false;
        return;
      }

      this._objectControls.enable(true);

      this._interpolator.resume();

      this._requestAnimationFrame(function () {
        return _this._onTick();
      });
    }
  };

  Miew.prototype.halt = function () {
    if (this._running) {
      this._discardComponentEdit();

      this._discardFragmentEdit();

      this._objectControls.enable(false);

      this._interpolator.pause();

      this._halting = true;
    }
  };

  Miew.prototype.enableHotKeys = function (enabled) {
    this._hotKeysEnabled = enabled;

    this._objectControls.enableHotkeys(enabled);
  };

  Miew.prototype._onResize = function () {
    this._needRender = true;
    var gfx = this._gfx;
    gfx.width = this._container.clientWidth;
    gfx.height = this._container.clientHeight;
    gfx.camera.aspect = gfx.width / gfx.height;
    gfx.camera.setMinimalFov(settings$1.now.camFov);
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setSize(gfx.width, gfx.height);
    gfx.renderer2d.setSize(gfx.width, gfx.height);
    this.dispatchEvent({
      type: 'resize'
    });
  };

  Miew.prototype._resizeOffscreenBuffers = function (width, height, stereo) {
    var gfx = this._gfx;
    stereo = stereo || 'NONE';
    var isAnaglyph = stereo === 'NONE' || stereo === 'ANAGLYPH';
    var multi = isAnaglyph ? 1 : 0.5;
    gfx.offscreenBuf.setSize(multi * width, height);
    gfx.offscreenBuf2.setSize(multi * width, height);
    gfx.offscreenBuf3.setSize(multi * width, height);
    gfx.offscreenBuf4.setSize(multi * width, height);

    if (gfx.offscreenBuf5) {
      gfx.offscreenBuf5.setSize(multi * width, height);
    }

    if (gfx.offscreenBuf6) {
      gfx.offscreenBuf6.setSize(multi * width, height);
    }

    if (gfx.offscreenBuf7) {
      gfx.offscreenBuf7.setSize(multi * width, height);
    }

    if (isAnaglyph) {
      gfx.stereoBufL.setSize(width, height);
      gfx.stereoBufR.setSize(width, height);
    }
  };

  Miew.prototype._onTick = function () {
    var _this2 = this;

    if (this._halting) {
      this._running = false;
      this._halting = false;
      return;
    }

    this._fps.update();

    this._requestAnimationFrame(function () {
      return _this2._onTick();
    });

    this._onUpdate();

    if (this._needRender) {
      this._onRender();

      this._needRender = !settings$1.now.suspendRender || settings$1.now.stereo === 'WEBVR';
    }
  };

  Miew.prototype._getBSphereRadius = function () {
    var radius = 0;

    this._forEachVisual(function (visual) {
      radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
    });

    return radius * this._objectControls.getScale();
  };

  Miew.prototype.getOBB = function () {
    var _bSphereForOneVisual = new THREE__namespace.Sphere();

    var _bBoxForOneVisual = new THREE__namespace.Box3();

    var _bBox = new THREE__namespace.Box3();

    var _invMatrix = new THREE__namespace.Matrix4();

    var _points = [new THREE__namespace.Vector3(), new THREE__namespace.Vector3(), new THREE__namespace.Vector3(), new THREE__namespace.Vector3()];
    return function (matrix, OBB) {
      _bBox.makeEmpty();

      this._forEachVisual(function (visual) {
        _bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere);

        _bSphereForOneVisual.applyMatrix4(visual.matrixWorld).applyMatrix4(matrix);

        _bSphereForOneVisual.getBoundingBox(_bBoxForOneVisual);

        _bBox.union(_bBoxForOneVisual);
      });

      _bBox.getCenter(OBB.center);

      _invMatrix.copy(matrix).invert();

      OBB.center.applyMatrix4(_invMatrix);
      var min = _bBox.min;
      var max = _bBox.max;

      _points[0].set(min.x, min.y, min.z);

      _points[1].set(max.x, min.y, min.z);

      _points[2].set(min.x, max.y, min.z);

      _points[3].set(min.x, min.y, max.z);

      for (var i = 0, l = _points.length; i < l; i++) {
        _points[i].applyMatrix4(_invMatrix);
      }

      OBB.halfSize.set(Math.abs(_points[0].x - _points[1].x), Math.abs(_points[0].y - _points[2].y), Math.abs(_points[0].z - _points[3].z)).multiplyScalar(0.5);
    };
  }();

  Miew.prototype._updateFog = function () {
    var gfx = this._gfx;

    if (settings$1.now.fog) {
      if (typeof gfx.scene.fog === 'undefined' || gfx.scene.fog === null) {
        var color = chooseFogColor();
        gfx.scene.fog = new THREE__namespace.Fog(color);

        this._setUberMaterialValues({
          fog: settings$1.now.fog
        });
      }

      updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
    } else if (gfx.scene.fog) {
      gfx.scene.fog = undefined;

      this._setUberMaterialValues({
        fog: settings$1.now.fog
      });
    }
  };

  Miew.prototype._onUpdate = function () {
    if (this.isScriptingCommandAvailable !== undefined && this.isScriptingCommandAvailable() && !this._building) {
      this.callNextCmd();
    }

    this._objectControls.update();

    this._forEachComplexVisual(function (visual) {
      visual.getComplex().update();
    });

    if (settings$1.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
      this.rebuild();
    }

    if (!this._loading.length && !this._building && !this._needRebuild()) {
      this._updateView();
    }

    this._updateFog();

    if (this._gfx.renderer.xr.enabled) {
      this.webVR.updateMoleculeScale();
    }
  };

  Miew.prototype._onRender = function () {
    var gfx = this._gfx;
    gfx.scene.updateMatrixWorld();
    gfx.camera.updateMatrixWorld();

    this._clipPlaneUpdateValue(this._getBSphereRadius());

    this._fogFarUpdateValue();

    gfx.renderer.setRenderTarget(null);
    gfx.renderer.clear();

    this._renderFrame(settings$1.now.stereo);
  };

  Miew.prototype._renderFrame = function () {
    var _anaglyphMat = new AnaglyphMaterial();

    var _size = new THREE__namespace.Vector2();

    return function (stereo) {
      var gfx = this._gfx;
      var renderer = gfx.renderer;
      renderer.getSize(_size);

      if (stereo !== 'NONE') {
        gfx.camera.focus = gfx.camera.position.z;
        gfx.stereoCam.aspect = 1.0;

        if (stereo === 'ANAGLYPH') {
          gfx.stereoCam.update(gfx.camera);
        } else {
          gfx.stereoCam.updateHalfSized(gfx.camera, settings$1.now.camFov);
        }
      }

      var pixelRatio = gfx.renderer.getPixelRatio();

      this._resizeOffscreenBuffers(_size.width * pixelRatio, _size.height * pixelRatio, stereo);

      this._renderShadowMap();

      switch (stereo) {
        case 'WEBVR':
        case 'NONE':
          this._renderScene(gfx.camera, false);

          break;

        case 'SIMPLE':
        case 'DISTORTED':
          renderer.setScissorTest(true);
          renderer.setScissor(0, 0, _size.width / 2, _size.height);
          renderer.setViewport(0, 0, _size.width / 2, _size.height);

          this._renderScene(this._gfx.stereoCam.cameraL, stereo === 'DISTORTED');

          renderer.setScissor(_size.width / 2, 0, _size.width / 2, _size.height);
          renderer.setViewport(_size.width / 2, 0, _size.width / 2, _size.height);

          this._renderScene(this._gfx.stereoCam.cameraR, stereo === 'DISTORTED');

          renderer.setScissorTest(false);
          break;

        case 'ANAGLYPH':
          this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);

          this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);

          renderer.setRenderTarget(null);
          _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture;
          _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture;
          gfx.renderer.renderScreenQuad(_anaglyphMat);
          break;
      }

      gfx.renderer2d.render(gfx.scene, gfx.camera);

      if (settings$1.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
        gfx.axes.render(renderer);
      }
    };
  }();

  Miew.prototype._onBgColorChanged = function () {
    var gfx = this._gfx;
    var color = chooseFogColor();

    if (gfx) {
      if (gfx.scene.fog) {
        gfx.scene.fog.color.set(color);
      }

      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
    }

    this._needRender = true;
  };

  Miew.prototype._onFogColorChanged = function () {
    var gfx = this._gfx;
    var color = chooseFogColor();

    if (gfx && gfx.scene.fog) {
      gfx.scene.fog.color.set(color);
    }

    this._needRender = true;
  };

  Miew.prototype._setUberMaterialValues = function (values) {
    this._gfx.root.traverse(function (obj) {
      if ((obj instanceof THREE__namespace.Mesh || obj instanceof THREE__namespace.LineSegments || obj instanceof THREE__namespace.Line) && obj.material instanceof UberMaterial) {
        obj.material.setValues(values);
        obj.material.needsUpdate = true;
      }
    });
  };

  Miew.prototype._enableMRT = function (on, renderBuffer, textureBuffer) {
    var gfx = this._gfx;
    var gl = gfx.renderer.getContext();
    var ext = gl.getExtension('WEBGL_draw_buffers');
    var properties = gfx.renderer.properties;

    if (!on) {
      ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null]);
      return;
    }

    gfx.renderer.setRenderTarget(textureBuffer);

    var tx8 = properties.get(textureBuffer.texture).__webglTexture;

    gl.bindTexture(gl.TEXTURE_2D, tx8);
    gfx.renderer.setRenderTarget(renderBuffer);

    var fb = properties.get(renderBuffer).__webglFramebuffer;

    var tx = properties.get(renderBuffer.texture).__webglTexture;

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    fb.width = renderBuffer.width;
    fb.height = renderBuffer.height;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0);
    ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
  };

  Miew.prototype._renderScene = function () {
    return function (camera, distortion, target) {
      distortion = distortion || false;
      target = target || null;
      var gfx = this._gfx;
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.setRenderTarget(target);
      gfx.renderer.clear();

      if (gfx.renderer.xr.enabled) {
        gfx.renderer.render(gfx.scene, camera);
        return;
      }

      gfx.renderer.setClearColor(0x000000, 0.0);
      gfx.renderer.setRenderTarget(gfx.offscreenBuf4);
      gfx.renderer.clearColor();
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.clear();
      var bHaveComplexes = this._getComplexVisual() !== null;

      var volumeVisual = this._getVolumeVisual();

      var ssao = bHaveComplexes && settings$1.now.ao;

      if (ssao) {
        this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4);
      }

      if (settings$1.now.transparency === 'prepass') {
        this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
      } else if (settings$1.now.transparency === 'standard') {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.render(gfx.scene, camera);
      }

      if (ssao) {
        this._enableMRT(false, null, null);
      }

      var outline = bHaveComplexes && settings$1.now.outline.on;
      var fxaa = bHaveComplexes && settings$1.now.fxaa;
      var volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
      var dstBuffer = ssao || outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
      var srcBuffer = gfx.offscreenBuf;

      if (ssao) {
        this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);

        if (!fxaa && !distortion && !volume && !outline) {
          srcBuffer = dstBuffer;
          dstBuffer = target;
          gfx.renderer.setRenderTarget(dstBuffer);
          gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
        }
      } else {
        gfx.renderer.setRenderTarget(dstBuffer);
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
      }

      if (outline) {
        srcBuffer = dstBuffer;
        dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;

        if (srcBuffer != null) {
          this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
        }
      }

      this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);

      if (volume) {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf);
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
        dstBuffer = gfx.offscreenBuf;

        this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex);

        if (!fxaa && !distortion) {
          gfx.renderer.setRenderTarget(target);
          gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
        }
      }

      srcBuffer = dstBuffer;

      if (fxaa) {
        dstBuffer = distortion ? gfx.offscreenBuf4 : target;

        this._performFXAA(srcBuffer, dstBuffer);

        srcBuffer = dstBuffer;
      }

      if (distortion) {
        dstBuffer = target;

        this._performDistortion(srcBuffer, dstBuffer, true);
      }
    };
  }();

  Miew.prototype._performDistortion = function () {
    var _scene = new THREE__namespace.Scene();

    var _camera = new THREE__namespace.OrthographicCamera(-1.0, 1.0, 1.0, -1.0, -500, 1000);

    var _material = new THREE__namespace.RawShaderMaterial({
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        aberration: {
          type: 'fv3',
          value: new THREE__namespace.Vector3(1.0)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentScreenQuadFromDistTex,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });

    var _geo = gfxutils.buildDistorionMesh(10, 10, settings$1.now.debug.stereoBarrel);

    _scene.add(new meshes.Mesh(_geo, _material));

    return function (srcBuffer, targetBuffer, mesh) {
      this._gfx.renderer.setRenderTarget(targetBuffer);

      this._gfx.renderer.clear();

      if (mesh) {
        _material.uniforms.srcTex.value = srcBuffer.texture;

        _material.uniforms.aberration.value.set(0.995, 1.0, 1.01);

        this._gfx.renderer.render(_scene, _camera);
      } else {
        this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings$1.now.debug.stereoBarrel);
      }
    };
  }();

  Miew.prototype._renderOutline = function () {
    var _outlineMaterial = new OutlineMaterial({
      depth: true
    });

    return function (camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
      var self = this;
      var gfx = self._gfx;
      _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
      _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;

      _outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);

      _outlineMaterial.uniforms.color.value = new THREE__namespace.Color(settings$1.now.outline.color);
      _outlineMaterial.uniforms.threshold.value = settings$1.now.outline.threshold;
      _outlineMaterial.uniforms.thickness.value = new THREE__namespace.Vector2(settings$1.now.outline.thickness, settings$1.now.outline.thickness);
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_outlineMaterial);
    };
  }();

  Miew.prototype._renderShadowMap = function () {
    var pars = {
      minFilter: THREE__namespace.NearestFilter,
      magFilter: THREE__namespace.NearestFilter,
      format: THREE__namespace.RGBAFormat
    };
    return function () {
      if (!settings$1.now.shadow.on) {
        return;
      }

      var gfx = this._gfx;
      var currentRenderTarget = gfx.renderer.getRenderTarget();
      var activeCubeFace = gfx.renderer.getActiveCubeFace();
      var activeMipmapLevel = gfx.renderer.getActiveMipmapLevel();
      var _state = gfx.renderer.state;

      _state.setBlending(THREE__namespace.NoBlending);

      _state.buffers.color.setClear(1, 1, 1, 1);

      _state.buffers.depth.setTest(true);

      _state.setScissorTest(false);

      for (var i = 0; i < gfx.scene.children.length; i++) {
        if (gfx.scene.children[i].type === 'DirectionalLight') {
          var light = gfx.scene.children[i];

          if (light.shadow.map == null) {
            light.shadow.map = new THREE__namespace.WebGLRenderTarget(light.shadow.mapSize.width, light.shadow.mapSize.height, pars);
            light.shadow.camera.updateProjectionMatrix();
          }

          light.shadow.updateMatrices(light);
          gfx.renderer.setRenderTarget(light.shadow.map);
          gfx.renderer.clear();
          gfx.renderer.render(gfx.scene, light.shadow.camera);
        }
      }

      gfx.renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
  }();

  Miew.prototype._hasSelectionToRender = function () {
    var selPivot = this._gfx.selectionPivot;

    for (var i = 0; i < selPivot.children.length; i++) {
      var selPivotChild = selPivot.children[i];

      if (selPivotChild.children.length > 0) {
        return true;
      }
    }

    return false;
  };

  Miew.prototype._renderSelection = function () {
    var _outlineMaterial = new OutlineMaterial();

    return function (camera, srcBuffer, targetBuffer) {
      var self = this;
      var gfx = self._gfx;
      gfx.renderer.setClearColor('black', 0);
      gfx.renderer.setRenderTarget(srcBuffer);
      gfx.renderer.clear(true, false, false);

      if (self._hasSelectionToRender()) {
        gfx.selectionRoot.matrix = gfx.root.matrix;
        gfx.selectionPivot.matrix = gfx.pivot.matrix;
        gfx.renderer.render(gfx.selectionScene, camera);
      } else {
        gfx.renderer.renderDummyQuad();
      }

      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6);
      _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;

      _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);

      gfx.renderer.renderScreenQuad(_outlineMaterial);
    };
  }();

  Miew.prototype._checkVolumeRenderingSupport = function (renderTarget) {
    if (!renderTarget) {
      return false;
    }

    var gfx = this._gfx;
    var oldRT = gfx.renderer.getRenderTarget();
    gfx.renderer.setRenderTarget(renderTarget);
    var context = gfx.renderer.getContext();
    var result = context.checkFramebufferStatus(context.FRAMEBUFFER);
    gfx.renderer.setRenderTarget(oldRT);

    if (result !== context.FRAMEBUFFER_COMPLETE) {
      this.logger.warn("Device doesn't support electron density rendering");
      return false;
    }

    return true;
  };

  Miew.prototype._renderVolume = function () {
    var volumeBFMat = new VolumeMaterial$1.BackFacePosMaterial();
    var volumeFFMat = new VolumeMaterial$1.FrontFacePosMaterial();
    var cubeOffsetMat = new THREE__namespace.Matrix4().makeTranslation(0.5, 0.5, 0.5);
    var world2colorMat = new THREE__namespace.Matrix4();
    var volumeRenderingSupported;
    return function (volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
      var gfx = this._gfx;

      if (typeof volumeRenderingSupported === 'undefined') {
        volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
      }

      if (!volumeRenderingSupported) {
        return;
      }

      var mesh = volumeVisual.getMesh();
      mesh.rebuild(gfx.camera);
      gfx.renderer.setClearColor('black', 0);
      gfx.renderer.setRenderTarget(tmpBuf1);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf2);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.clear();
      gfx.renderer.setRenderTarget(tmpBuf1);
      camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeBFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.setRenderTarget(tmpBuf2);
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.scene.overrideMaterial = volumeFFMat;
      gfx.renderer.render(gfx.scene, camera);
      gfx.scene.overrideMaterial = null;
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
      world2colorMat.copy(mesh.matrixWorld).invert();
      UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
      camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION);
      gfx.renderer.setRenderTarget(tmpBuf3);
      gfx.renderer.render(gfx.scene, camera);
      var vm = mesh.material;
      vm.uniforms._BFRight.value = tmpBuf1.texture;
      vm.uniforms._FFRight.value = tmpBuf2.texture;
      vm.uniforms._WFFRight.value = tmpBuf3.texture;
      camera.layers.set(gfxutils.LAYERS.VOLUME);
      gfx.renderer.setRenderTarget(dstBuf);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    };
  }();

  Miew.prototype._renderWithPrepassTransparency = function () {
    return function (camera, targetBuffer) {
      var gfx = this._gfx;
      gfx.renderer.setRenderTarget(targetBuffer);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
      gfx.renderer.getContext().colorMask(false, false, false, false);
      gfx.renderer.render(gfx.scene, camera);
      gfx.renderer.getContext().colorMask(true, true, true, true);
      camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
      gfx.renderer.render(gfx.scene, camera);
      camera.layers.set(gfxutils.LAYERS.DEFAULT);
    };
  }();

  Miew.prototype._performFXAA = function () {
    var _fxaaMaterial = new FXAAMaterial();

    return function (srcBuffer, targetBuffer) {
      if (typeof srcBuffer === 'undefined' || typeof targetBuffer === 'undefined') {
        return;
      }

      var gfx = this._gfx;
      gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.clear();
      _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;

      _fxaaMaterial.uniforms.srcTexelSize.value.set(1.0 / srcBuffer.width, 1.0 / srcBuffer.height);

      _fxaaMaterial.uniforms.bgColor.value.set(settings$1.now.bg.color);

      if (_fxaaMaterial.bgTransparent !== settings$1.now.bg.transparent) {
        _fxaaMaterial.setValues({
          bgTransparent: settings$1.now.bg.transparent
        });

        _fxaaMaterial.needsUpdate = true;
      }

      gfx.renderer.renderScreenQuad(_fxaaMaterial);
    };
  }();

  Miew.prototype._performAO = function () {
    var _aoMaterial = new AOMaterial();

    var _horBlurMaterial = new AOHorBlurMaterial();

    var _vertBlurMaterial = new AOVertBlurWithBlendMaterial();

    var _scale = new THREE__namespace.Vector3();

    return function (srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {
      if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
        return;
      }

      var gfx = this._gfx;
      var tanHalfFOV = Math.tan(THREE__namespace.MathUtils.DEG2RAD * 0.5 * gfx.camera.fov);
      _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
      _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;

      _aoMaterial.uniforms.srcTexelSize.value.set(1.0 / srcColorBuffer.width, 1.0 / srcColorBuffer.height);

      _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);

      _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      gfx.root.matrix.extractScale(_scale);
      _aoMaterial.uniforms.kernelRadius.value = settings$1.now.debug.ssaoKernelRadius * _scale.x;
      _aoMaterial.uniforms.depthThreshold.value = 2.0 * this._getBSphereRadius();
      _aoMaterial.uniforms.factor.value = settings$1.now.debug.ssaoFactor;
      gfx.renderer.setRenderTarget(tempBuffer1);
      gfx.renderer.renderScreenQuad(_aoMaterial);
      _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;

      _horBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer1.width, 1.0 / tempBuffer1.height);

      _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      gfx.renderer.setRenderTarget(tempBuffer);
      gfx.renderer.renderScreenQuad(_horBlurMaterial);
      _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
      _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;

      _vertBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer.width, 1.0 / tempBuffer.height);

      _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
      _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
      _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
      _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
      var fog = gfx.scene.fog;

      if (fog) {
        _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);

        _vertBlurMaterial.uniforms.fogColor.value.set(fog.color.r, fog.color.g, fog.color.b, settings$1.now.fogAlpha);
      }

      if (_vertBlurMaterial.useFog !== settings$1.now.fog || _vertBlurMaterial.fogTransparent !== settings$1.now.bg.transparent) {
        _vertBlurMaterial.setValues({
          useFog: settings$1.now.fog,
          fogTransparent: settings$1.now.bg.transparent
        });

        _vertBlurMaterial.needsUpdate = true;
      }

      gfx.renderer.setRenderTarget(targetBuffer);
      gfx.renderer.renderScreenQuad(_vertBlurMaterial);
    };
  }();

  Miew.prototype.reset = function () {
    if (this._picker) {
      this._picker.reset();
    }

    this._lastPick = null;

    this._releaseAllVisuals();

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._resetObjects();

    if (this._gfx) {
      gfxutils.clearTree(this._gfx.pivot);

      this._gfx.renderer2d.reset();
    }

    this.setNeedRender();
  };

  Miew.prototype._resetScene = function () {
    this._objectControls.reset();

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this.resetReps();
    this.resetPivot();
    this.rebuildAll();
  };

  Miew.prototype.resetView = function () {
    if (this._picker) {
      this._picker.reset();
    }

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._resetScene();

    this._forEachComplexVisual(function (visual) {
      visual.updateSelectionMask({});
      visual.rebuildSelectionGeometry();
    });
  };

  Miew.prototype._export = function (format) {
    var TheExporter = ___default["default"].head(io.exporters.find({
      format: format
    }));

    if (!TheExporter) {
      this.logger.error('Could not find suitable exporter for this source');
      return Promise.reject(new Error('Could not find suitable exporter for this source'));
    }

    this.dispatchEvent({
      type: 'exporting'
    });

    if (this._visuals[this._curVisualName] instanceof ComplexVisual) {
      var dataSource = null;

      if (TheExporter.SourceClass === ComplexVisual) {
        dataSource = this._visuals[this._curVisualName];
      } else if (TheExporter.SourceClass === Complex$9) {
        dataSource = this._visuals[this._curVisualName]._complex;
      }

      var exporter = new TheExporter(dataSource, {
        miewVersion: Miew.VERSION
      });
      return exporter.export().then(function (data) {
        return data;
      });
    }

    if (this._visuals[this._curVisualName] instanceof VolumeVisual) {
      return Promise.reject(new Error('Sorry, exporter for volume data not implemented yet'));
    }

    return Promise.reject(new Error('Unexpected format of data'));
  };

  var rePdbId = /^(?:(pdb|cif|mmtf|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i;
  var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
  var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;

  function resolveSourceShortcut(source, opts) {
    if (!___default["default"].isString(source)) {
      return source;
    }

    var matchesPdbId = rePdbId.exec(source);

    if (matchesPdbId) {
      var _matchesPdbId = _slicedToArray(matchesPdbId, 3),
          _matchesPdbId$ = _matchesPdbId[1],
          format = _matchesPdbId$ === void 0 ? 'pdb' : _matchesPdbId$,
          id = _matchesPdbId[2];

      format = format.toLowerCase();
      id = id.toUpperCase();

      switch (format) {
        case 'pdb':
          source = "https://files.rcsb.org/download/".concat(id, ".pdb");
          break;

        case 'cif':
          source = "https://files.rcsb.org/download/".concat(id, ".cif");
          break;

        case 'mmtf':
          source = "https://mmtf.rcsb.org/v1.0/full/".concat(id);
          break;

        case 'ccp4':
          source = "https://www.ebi.ac.uk/pdbe/coordinates/files/".concat(id.toLowerCase(), ".ccp4");
          break;

        case 'dsn6':
          source = "https://edmaps.rcsb.org/maps/".concat(id.toLowerCase(), "_2fofc.dsn6");
          break;

        default:
          throw new Error('Unexpected data format shortcut');
      }

      opts.fileType = format;
      opts.fileName = "".concat(id, ".").concat(format);
      opts.sourceType = 'url';
      return source;
    }

    var matchesPubchem = rePubchem.exec(source);

    if (matchesPubchem) {
      var compound = matchesPubchem[1].toLowerCase();
      source = "https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/".concat(compound, "/JSON?record_type=3d");
      opts.fileType = 'pubchem';
      opts.fileName = "".concat(compound, ".json");
      opts.sourceType = 'url';
      return source;
    }

    if (opts.sourceType === 'url' || opts.sourceType === undefined) {
      opts.sourceType = 'url';

      if (!reUrlScheme.test(source)) {
        source = utils.resolveURL(source);
      }
    }

    return source;
  }

  function updateBinaryMode(opts) {
    var binary = opts.binary;

    if (opts.fileType !== undefined) {
      var TheParser = ___default["default"].head(io.parsers.find({
        format: opts.fileType
      }));

      if (TheParser) {
        binary = TheParser.binary || false;
      } else {
        throw new Error('Could not find suitable parser for this format');
      }
    }

    if (binary === undefined && opts.fileExt !== undefined) {
      var _TheParser = ___default["default"].head(io.parsers.find({
        ext: opts.fileExt
      }));

      if (_TheParser) {
        binary = _TheParser.binary || false;
      }
    }

    if (opts.fileExt !== undefined && opts.fileExt.toLowerCase() === '.man') {
      opts.binary = true;
      opts.animation = true;
    }

    if (binary !== undefined) {
      if (opts.binary !== undefined && opts.binary !== binary) {
        opts.context.logger.warn('Overriding incorrect binary mode');
      }
    }

    opts.binary = binary || false;
  }

  function _fetchData(source, opts, job) {
    return new Promise(function (resolve) {
      if (job.shouldCancel()) {
        throw new Error('Operation cancelled');
      }

      job.notify({
        type: 'fetching'
      });
      source = resolveSourceShortcut(source, opts);

      var TheLoader = ___default["default"].head(io.loaders.find({
        type: opts.sourceType,
        source: source
      }));

      if (!TheLoader) {
        throw new Error(LOADER_NOT_FOUND);
      }

      var fileName = opts.fileName || TheLoader.extractName(source);

      if (fileName) {
        var _utils$splitFileName = utils.splitFileName(fileName),
            _utils$splitFileName2 = _slicedToArray(_utils$splitFileName, 2),
            name = _utils$splitFileName2[0],
            fileExt = _utils$splitFileName2[1];

        ___default["default"].defaults(opts, {
          name: name,
          fileExt: fileExt,
          fileName: fileName
        });
      }

      updateBinaryMode(opts);

      var newOptions = ___default["default"].get(opts, 'preset.expression');

      if (!___default["default"].isUndefined(newOptions)) {
        newOptions = JSON.parse(newOptions);

        if (newOptions && newOptions.settings) {
          var keys = ['singleUnit'];

          for (var keyIndex = 0, keyCount = keys.length; keyIndex < keyCount; ++keyIndex) {
            var key = keys[keyIndex];

            var value = ___default["default"].get(newOptions.settings, key);

            if (!___default["default"].isUndefined(value)) {
              settings$1.set(key, value);
            }
          }
        }
      }

      var loader = new TheLoader(source, opts);
      loader.context = opts.context;
      job.addEventListener('cancel', function () {
        return loader.abort();
      });
      loader.addEventListener('progress', function (event) {
        if (event.lengthComputable && event.total > 0) {
          reportProgress(loader.logger, 'Fetching', event.loaded / event.total);
        } else {
          reportProgress(loader.logger, 'Fetching');
        }
      });
      console.time('fetch');
      var promise = loader.load().then(function (data) {
        console.timeEnd('fetch');
        opts.context.logger.info('Fetching finished');
        job.notify({
          type: 'fetchingDone',
          data: data
        });
        return data;
      }).catch(function (error) {
        console.timeEnd('fetch');
        opts.context.logger.debug(error.message);

        if (error.stack) {
          opts.context.logger.debug(error.stack);
        }

        opts.context.logger.error('Fetching failed');
        job.notify({
          type: 'fetchingDone',
          error: error
        });
        throw error;
      });
      resolve(promise);
    });
  }

  function _parseData(data, opts, job) {
    if (job.shouldCancel()) {
      return Promise.reject(new Error('Operation cancelled'));
    }

    job.notify({
      type: 'parsing'
    });

    var TheParser = ___default["default"].head(io.parsers.find({
      format: opts.fileType,
      ext: opts.fileExt,
      data: data
    }));

    if (!TheParser) {
      return Promise.reject(new Error('Could not find suitable parser'));
    }

    var parser = new TheParser(data, opts);
    parser.context = opts.context;
    job.addEventListener('cancel', function () {
      return parser.abort();
    });
    console.time('parse');
    return parser.parse().then(function (dataSet) {
      console.timeEnd('parse');
      job.notify({
        type: 'parsingDone',
        data: dataSet
      });
      return dataSet;
    }).catch(function (error) {
      console.timeEnd('parse');
      opts.error = error;
      opts.context.logger.debug(error.message);

      if (error.stack) {
        opts.context.logger.debug(error.stack);
      }

      opts.context.logger.error('Parsing failed');
      job.notify({
        type: 'parsingDone',
        error: error
      });
      throw error;
    });
  }

  Miew.prototype.load = function (source, opts) {
    var _this3 = this;

    opts = ___default["default"].merge({}, opts, {
      context: this
    });

    if (!this.settings.now.use.multiFile) {
      if (this._loading.length) {
        this._loading.forEach(function (job) {
          job.cancel();
        });

        this._loading.length = 0;
      }

      if (!opts.animation) {
        this.reset(true);
      }
    }

    this._interpolator.reset();

    this.dispatchEvent({
      type: 'loading',
      options: opts,
      source: source
    });
    var job = new JobHandle();

    this._loading.push(job);

    job.addEventListener('notification', function (e) {
      _this3.dispatchEvent(e.slaveEvent);
    });

    this._spinner.spin(this._container);

    var onLoadEnd = function onLoadEnd(anything) {
      var jobIndex = _this3._loading.indexOf(job);

      if (jobIndex !== -1) {
        _this3._loading.splice(jobIndex, 1);
      }

      _this3._spinner.stop();

      _this3._refreshTitle();

      job.notify({
        type: 'loadingDone',
        anything: anything
      });
      return anything;
    };

    return _fetchData(source, opts, job).then(function (data) {
      return _parseData(data, opts, job);
    }).then(function (object) {
      var name = _this3._onLoad(object, opts);

      return onLoadEnd(name);
    }).catch(function (err) {
      _this3.logger.error('Could not load data');

      _this3.logger.debug(err);

      throw onLoadEnd(err);
    });
  };

  Miew.prototype.unload = function (name) {
    this._removeVisual(name || this.getCurrentVisual());

    this.resetPivot();

    if (settings$1.now.shadow.on) {
      this._updateShadowCamera();
    }
  };

  Miew.prototype._startAnimation = function (fileData) {
    this._stopAnimation();

    var self = this;

    var visual = this._getComplexVisual();

    if (visual === null) {
      this.logger.error('Unable to start animation - no molecule is loaded.');
      return;
    }

    try {
      this._frameInfo = new FrameInfo(visual.getComplex(), fileData, {
        onLoadStatusChanged: function onLoadStatusChanged() {
          self.dispatchEvent({
            type: 'mdPlayerStateChanged',
            state: {
              isPlaying: self._isAnimating,
              isLoading: self._frameInfo ? self._frameInfo.isLoading : true
            }
          });
        },
        onError: function onError(message) {
          self._stopAnimation();

          self.logger.error(message);
        }
      });
    } catch (e) {
      this.logger.error('Animation file does not fit to current complex!');
      return;
    }

    this._continueAnimation();
  };

  Miew.prototype._pauseAnimation = function () {
    if (this._animInterval === null) {
      return;
    }

    this._isAnimating = false;
    clearInterval(this._animInterval);
    this._animInterval = null;

    if (this._frameInfo) {
      this.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: this._isAnimating,
          isLoading: this._frameInfo.isLoading
        }
      });
    }
  };

  Miew.prototype._continueAnimation = function () {
    this._isAnimating = true;
    var minFrameTime = 1000 / settings$1.now.maxfps;
    minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
    var self = this;
    var pivot = self._gfx.pivot;

    var visual = this._getComplexVisual();

    if (visual) {
      visual.resetSelectionMask();
      visual.rebuildSelectionGeometry();
      this._msgAtomInfo.style.opacity = 0.0;
    }

    this._animInterval = setInterval(function () {
      self.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: self._isAnimating,
          isLoading: self._frameInfo.isLoading
        }
      });

      if (self._frameInfo.frameIsReady) {
        pivot.updateToFrame(self._frameInfo);

        self._updateObjsToFrame(self._frameInfo);

        self._refreshTitle(" Frame ".concat(self._frameInfo._currFrame, " of ").concat(self._frameInfo._framesCount, " time interval - ").concat(self._frameInfo._timeStep));

        try {
          self._frameInfo.nextFrame();
        } catch (e) {
          self.logger.error('Error during animation');

          self._stopAnimation();

          return;
        }

        self._needRender = true;
      }
    }, minFrameTime);
  };

  Miew.prototype._stopAnimation = function () {
    if (this._animInterval === null) {
      return;
    }

    clearInterval(this._animInterval);

    this._frameInfo.disableEvents();

    this._frameInfo = null;
    this._animInterval = null;
    this.dispatchEvent({
      type: 'mdPlayerStateChanged',
      state: null
    });
  };

  Miew.prototype._onLoad = function (dataSource, opts) {
    var gfx = this._gfx;
    var visualName = null;

    if (opts.animation) {
      this._refreshTitle();

      this._startAnimation(dataSource);

      return null;
    }

    this._stopAnimation();

    if (!opts || !opts.keepRepsInfo) {
      this._opts.reps = null;
      this._opts._objects = null;
    }

    if (dataSource.id === 'Complex') {
      var complex = dataSource;

      if (opts.fileName) {
        complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
      } else if (opts.amberFileName) {
        complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
      } else {
        complex.name = "Dynamic ".concat(opts.fileType, " molecule");
      }

      visualName = this._addVisual(new ComplexVisual(complex.name, complex));
      this._curVisualName = visualName;
      var desc = this.info();
      this.logger.info("Parsed ".concat(opts.fileName, " (").concat(desc.atoms, " atoms, ").concat(desc.bonds, " bonds, ").concat(desc.residues, " residues, ").concat(desc.chains, " chains)."));

      if (___default["default"].isNumber(this._opts.unit)) {
        complex.setCurrentUnit(this._opts.unit);
      }

      if (opts.preset) ; else if (settings$1.now.autoPreset) {
        switch (opts.fileType) {
          case 'cml':
            this.resetReps('small');
            break;

          case 'pdb':
          case 'mmtf':
          case 'cif':
            if (hasValidResidues(complex)) {
              this.resetReps('macro');
            } else {
              this.resetReps('small');
            }

            break;

          default:
            this.resetReps('default');
            break;
        }
      } else {
        this.resetReps('default');
      }
    } else if (dataSource.id === 'Volume') {
      this.resetEd();
      visualName = this._onLoadEd(dataSource);
    }

    gfx.camera.updateProjectionMatrix();

    this._updateFog();

    gfx.root.resetTransform();
    this.resetPivot();

    this._objectControls.setScale(settings$1.now.radiusToFit / this._getBSphereRadius());

    this._resetObjects();

    if (settings$1.now.autoResolution) {
      this._tweakResolution();
    }

    if (settings$1.now.shadow.on) {
      this._updateShadowCamera();
    }

    if (this._opts.view) {
      this.view(this._opts.view);
      delete this._opts.view;
    }

    this._refreshTitle();

    return visualName;
  };

  Miew.prototype.resetEd = function () {
    if (this._edLoader) {
      this._edLoader.abort();

      this._edLoader = null;
    }

    this._removeVisual(this._getVolumeVisual());

    this._needRender = true;
  };

  Miew.prototype.loadEd = function (source) {
    var _this4 = this;

    this.resetEd();

    var TheLoader = ___default["default"].head(io.loaders.find({
      source: source
    }));

    if (!TheLoader) {
      this.logger.error(LOADER_NOT_FOUND);
      return Promise.reject(new Error(LOADER_NOT_FOUND));
    }

    var loader = this._edLoader = new TheLoader(source, {
      binary: true
    });
    loader.context = this;
    return loader.load().then(function (data) {
      var TheParser = ___default["default"].head(io.parsers.find({
        format: 'ccp4'
      }));

      if (!TheParser) {
        throw new Error(PARSER_NOT_FOUND);
      }

      var parser = new TheParser(data);
      parser.context = _this4;
      return parser.parse().then(function (dataSource) {
        _this4._onLoadEd(dataSource);
      });
    }).catch(function (error) {
      _this4.logger.error('Could not load ED data');

      _this4.logger.debug(error);
    });
  };

  Miew.prototype._onLoadEd = function (dataSource) {
    dataSource.normalize();
    var volumeVisual = new VolumeVisual('volume', dataSource);
    volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME);

    var visualName = this._addVisual(volumeVisual);

    this._needRender = true;
    return visualName;
  };

  Miew.prototype._needRebuild = function () {
    var needsRebuild = false;

    this._forEachComplexVisual(function (visual) {
      needsRebuild = needsRebuild || visual.needsRebuild();
    });

    return needsRebuild;
  };

  Miew.prototype._rebuildObjects = function () {
    var self = this;
    var gfx = this._gfx;
    var i;
    var n;
    var toRemove = [];

    for (i = 0; i < gfx.pivot.children.length; ++i) {
      var child = gfx.pivot.children[i];

      if (!(child instanceof Visual)) {
        toRemove.push(child);
      }
    }

    for (i = 0; i < toRemove.length; ++i) {
      toRemove[i].parent.remove(toRemove[i]);
    }

    setTimeout(function () {
      var objList = self._objects;

      for (i = 0, n = objList.length; i < n; ++i) {
        var obj = objList[i];

        if (obj.needsRebuild) {
          obj.build();
        }

        if (obj.getGeometry()) {
          gfx.pivot.add(obj.getGeometry());
        }
      }
    }, 10);
  };

  Miew.prototype.changeUnit = function (unitIdx, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      throw new Error('There is no complex to change!');
    }

    function currentUnitInfo() {
      var unit = visual ? visual.getComplex().getCurrentUnit() : 0;
      var type = unit > 0 ? "Bio molecule ".concat(unit) : 'Asymmetric unit';
      return "Current unit: ".concat(unit, " (").concat(type, ")");
    }

    if (unitIdx === undefined) {
      return currentUnitInfo();
    }

    if (___default["default"].isString(unitIdx)) {
      unitIdx = Math.max(parseInt(unitIdx, 10), 0);
    }

    if (visual.getComplex().setCurrentUnit(unitIdx)) {
      this._resetScene();

      this._updateInfoPanel();
    }

    return currentUnitInfo();
  };

  Miew.prototype.rebuild = function () {
    var _this5 = this;

    if (this._building) {
      this.logger.warn('Miew.rebuild(): already building!');
      return;
    }

    this._building = true;
    this.dispatchEvent({
      type: 'rebuilding'
    });

    this._rebuildObjects();

    this._gfx.renderer2d.reset();

    var rebuildActions = [];

    this._forEachComplexVisual(function (visual) {
      if (visual.needsRebuild()) {
        rebuildActions.push(visual.rebuild().then(function () {
          return new Promise(function (resolve) {
            visual.rebuildSelectionGeometry();
            resolve();
          });
        }));
      }
    });

    var self = this;

    this._spinner.spin(this._container);

    Promise.all(rebuildActions).then(function () {
      self._spinner.stop();

      self._needRender = true;

      self._refreshTitle();

      _this5.dispatchEvent({
        type: 'buildingDone'
      });

      self._building = false;
    });
  };

  Miew.prototype.rebuildAll = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setNeedsRebuild();
    });
  };

  Miew.prototype._refreshTitle = function (appendix) {
    var title;
    appendix = appendix === undefined ? '' : appendix;

    var visual = this._getComplexVisual();

    if (visual) {
      title = visual.getComplex().name;
      var rep = visual.repGet(visual.repCurrent());
      title += rep ? " \u2013 ".concat(rep.mode.name, " Mode") : '';
    } else {
      title = Object.keys(this._visuals).length > 0 ? 'Unknown' : 'No Data';
    }

    title += appendix;
    this.dispatchEvent({
      type: 'titleChanged',
      data: title
    });
  };

  Miew.prototype.setNeedRender = function () {
    this._needRender = true;
  };

  Miew.prototype._extractRepresentation = function () {
    var _this6 = this;

    var changed = [];

    this._forEachComplexVisual(function (visual) {
      if (visual.getSelectionCount() === 0) {
        return;
      }

      var selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
      var defPreset = settings$1.now.presets.default;
      var res = visual.repAdd({
        selector: selector,
        mode: defPreset[0].mode.id,
        colorer: defPreset[0].colorer.id,
        material: defPreset[0].material.id
      });

      if (!res) {
        if (visual.repCount() === ComplexVisual.NUM_REPRESENTATION_BITS) {
          _this6.logger.warn("Number of representations is limited to ".concat(ComplexVisual.NUM_REPRESENTATION_BITS));
        }

        return;
      }

      _this6.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      });

      visual.repCurrent(res.index);
      changed.push(visual.name);
    });

    if (changed.length > 0) {
      this.logger.report("New representation from selection for complexes: ".concat(changed.join(', ')));
    }
  };

  Miew.prototype._setReps = function (reps) {
    reps = reps || this._opts && this._opts.reps || [];

    this._forEachComplexVisual(function (visual) {
      return visual.resetReps(reps);
    });
  };

  Miew.prototype.applyPreset = function (preset) {
    var presets = settings$1.now.presets;
    var presList = [preset || settings$1.defaults.preset, settings$1.defaults.preset, Object.keys(presets)[0]];
    var reps = null;

    for (var i = 0; !reps && i < presList.length; ++i) {
      settings$1.set('preset', presList[i]);
      reps = presets[settings$1.now.preset];

      if (!reps) {
        this.logger.warn("Unknown preset \"".concat(settings$1.now.preset, "\""));
      }
    }

    this._setReps(reps);
  };

  Miew.prototype.resetReps = function (preset) {
    var reps = this._opts && this._opts.reps;

    if (reps) {
      this._setReps(reps);
    } else {
      this.applyPreset(preset);
    }
  };

  Miew.prototype.repCount = function (name) {
    var visual = this._getComplexVisual(name);

    return visual ? visual.repCount() : 0;
  };

  Miew.prototype.repCurrent = function (index, name) {
    var visual = this._getComplexVisual(name);

    var newIdx = visual ? visual.repCurrent(index) : -1;

    if (index && newIdx !== index) {
      this.logger.warn("Representation ".concat(index, " was not found. Current rep remains unchanged."));
    }

    return newIdx;
  };

  Miew.prototype.rep = function (index, rep) {
    var visual = this._getComplexVisual('');

    if (!visual) {
      return null;
    }

    var res = visual.rep(index, rep);

    if (res.status === 'created') {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      });
    } else if (res.status === 'changed') {
      this.dispatchEvent({
        type: 'repChanged',
        index: res.index,
        name: visual.name
      });
    }

    return res.desc;
  };

  Miew.prototype.repGet = function (index, name) {
    var visual = this._getComplexVisual(name);

    return visual ? visual.repGet(index) : null;
  };

  Miew.prototype.repAdd = function (rep, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return -1;
    }

    var res = visual.repAdd(rep);

    if (res) {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: name
      });
      return res.index;
    }

    return -1;
  };

  Miew.prototype.repRemove = function (index, name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return;
    }

    visual.repRemove(index);
    this.dispatchEvent({
      type: 'repRemoved',
      index: index,
      name: name
    });
  };

  Miew.prototype.repHide = function (index, hide, name) {
    this._needRender = true;

    var visual = this._getComplexVisual(name);

    return visual ? visual.repHide(index, hide) : null;
  };

  Miew.prototype._setEditMode = function (mode) {
    this._editMode = mode;
    var elem = this._msgMode;

    if (elem) {
      elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0.0 : 1.0;

      if (mode !== EDIT_MODE.COMPLEX) {
        var t = elem.getElementsByTagName('p')[0];
        t.innerHTML = mode === EDIT_MODE.COMPONENT ? 'COMPONENT EDIT MODE' : 'FRAGMENT EDIT MODE';
      }
    }

    this.dispatchEvent({
      type: 'editModeChanged',
      data: mode === EDIT_MODE.COMPLEX
    });
  };

  Miew.prototype._enterComponentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }

    var editors = [];

    this._forEachComplexVisual(function (visual) {
      var editor = visual.beginComponentEdit();

      if (editor) {
        editors.push(editor);
      }
    });

    if (editors === []) {
      return;
    }

    this._editors = editors;
    this.logger.info('COMPONENT EDIT MODE -- ON');

    this._setEditMode(EDIT_MODE.COMPONENT);

    this._objectControls.keysTranslateObj(true);
  };

  Miew.prototype._applyComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }

    this._objectControls.stop();

    this._objectControls.keysTranslateObj(false);

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply();
    }

    this._editors = [];
    this.logger.info('COMPONENT EDIT MODE -- OFF (applied)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this.rebuildAll();
  };

  Miew.prototype._discardComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return;
    }

    this._objectControls.stop();

    this._objectControls.keysTranslateObj(false);

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard();
    }

    this._editors = [];
    this.logger.info('COMPONENT EDIT MODE -- OFF (discarded)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._needRender = true;
    this.rebuildAll();
  };

  Miew.prototype._enterFragmentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return;
    }

    var selectedVisuals = [];

    this._forEachComplexVisual(function (visual) {
      if (visual instanceof ComplexVisual && visual.getSelectionCount() > 0) {
        selectedVisuals.push(visual);
      }
    });

    if (selectedVisuals.length !== 1) {
      return;
    }

    var editor = selectedVisuals[0].beginFragmentEdit();

    if (!editor) {
      return;
    }

    this._editors = [editor];
    this.logger.info('FRAGMENT EDIT MODE -- ON (single bond)');

    this._setEditMode(EDIT_MODE.FRAGMENT);

    this._objectControls.allowTranslation(false);

    this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());

    this._needRender = true;
  };

  Miew.prototype._applyFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }

    this._objectControls.stop();

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply();
    }

    this._editors = [];
    this.logger.info('FRAGMENT EDIT MODE -- OFF (applied)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this.rebuildAll();
  };

  Miew.prototype._discardFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return;
    }

    this._objectControls.stop();

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard();
    }

    this._editors = [];
    this.logger.info('FRAGMENT EDIT MODE -- OFF (discarded)');

    this._setEditMode(EDIT_MODE.COMPLEX);

    this._objectControls.allowTranslation(true);

    this._objectControls.allowAltObjFreeRotation(true);

    this._needRender = true;
  };

  Miew.prototype._onPick = function (event) {
    if (!settings$1.now.picking) {
      return;
    }

    if (this._animInterval !== null) {
      return;
    }

    if (this._editMode === EDIT_MODE.FRAGMENT) {
      return;
    }

    if (this._objectControls.isEditingAltObj()) {
      return;
    }

    var complex = null;

    if (event.obj.atom) {
      complex = event.obj.atom.residue.getChain().getComplex();
      this._lastPick = event.obj.atom;
    } else if (event.obj.residue) {
      complex = event.obj.residue.getChain().getComplex();
      this._lastPick = event.obj.residue;
    } else if (event.obj.chain) {
      complex = event.obj.chain.getComplex();
      this._lastPick = event.obj.chain;
    } else if (event.obj.molecule) {
      complex = event.obj.molecule.complex;
      this._lastPick = event.obj.molecule;
    } else {
      this._lastPick = null;
    }

    function _updateSelection(visual) {
      visual.updateSelectionMask(event.obj);
      visual.rebuildSelectionGeometry();
    }

    if (complex) {
      var visual = this._getVisualForComplex(complex);

      if (visual) {
        _updateSelection(visual);

        this._needRender = true;
      }
    } else {
      this._forEachComplexVisual(_updateSelection);

      this._needRender = true;
    }

    this._updateInfoPanel();

    this.dispatchEvent(event);
  };

  Miew.prototype._onKeyDown = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return;
    }

    switch (event.keyCode) {
      case 'C'.charCodeAt(0):
        if (settings$1.now.editing) {
          this._enterComponentEditMode();
        }

        break;

      case 'F'.charCodeAt(0):
        if (settings$1.now.editing) {
          this._enterFragmentEditMode();
        }

        break;

      case 'A'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._applyComponentEdit();

            break;

          case EDIT_MODE.FRAGMENT:
            this._applyFragmentEdit();

            break;
        }

        break;

      case 'D'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._discardComponentEdit();

            break;

          case EDIT_MODE.FRAGMENT:
            this._discardFragmentEdit();

            break;
        }

        break;

      case 'S'.charCodeAt(0):
        event.preventDefault();
        event.stopPropagation();
        settings$1.set('ao', !settings$1.now.ao);
        this._needRender = true;
        break;

      case 107:
        event.preventDefault();
        event.stopPropagation();

        this._forEachComplexVisual(function (visual) {
          visual.expandSelection();
          visual.rebuildSelectionGeometry();
        });

        this._updateInfoPanel();

        this._needRender = true;
        break;

      case 109:
        event.preventDefault();
        event.stopPropagation();

        this._forEachComplexVisual(function (visual) {
          visual.shrinkSelection();
          visual.rebuildSelectionGeometry();
        });

        this._updateInfoPanel();

        this._needRender = true;
        break;
    }
  };

  Miew.prototype._onKeyUp = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return;
    }

    if (event.keyCode === 'X'.charCodeAt(0)) {
      this._extractRepresentation();
    }
  };

  Miew.prototype._updateInfoPanel = function () {
    var info = this._msgAtomInfo.getElementsByTagName('p')[0];

    var atom;
    var residue;
    var count = 0;

    this._forEachComplexVisual(function (visual) {
      count += visual.getSelectionCount();
    });

    while (info.firstChild) {
      info.removeChild(info.firstChild);
    }

    if (count === 0) {
      this._msgAtomInfo.style.opacity = 0.0;
      return;
    }

    var firstLine = "".concat(String(count), " atom").concat(count !== 1 ? 's' : '', " selected");

    if (this._lastPick !== null) {
      firstLine += ', the last pick:';
    }

    var secondLine = '';
    var aName = '';
    var coordLine = '';

    if (this._lastPick instanceof Atom) {
      atom = this._lastPick;
      residue = atom.residue;
      aName = atom.name;
      var location = atom.location !== 32 ? String.fromCharCode(atom.location) : '';
      secondLine = "".concat(atom.element.fullName, " #").concat(atom.serial).concat(location, ":       ").concat(residue._chain._name, ".").concat(residue._type._name).concat(residue._sequence).concat(residue._icode.trim(), ".");
      secondLine += aName;
      coordLine = "Coord: (".concat(atom.position.x.toFixed(2).toString(), ",     ").concat(atom.position.y.toFixed(2).toString(), ",     ").concat(atom.position.z.toFixed(2).toString(), ")");
    } else if (this._lastPick instanceof Residue) {
      residue = this._lastPick;
      secondLine = "".concat(residue._type._fullName, ":       ").concat(residue._chain._name, ".").concat(residue._type._name).concat(residue._sequence).concat(residue._icode.trim());
    } else if (this._lastPick instanceof Chain) {
      secondLine = "chain ".concat(this._lastPick._name);
    } else if (this._lastPick instanceof Molecule) {
      secondLine = "molecule ".concat(this._lastPick._name);
    }

    info.appendChild(document.createTextNode(firstLine));

    if (secondLine !== '') {
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(secondLine));
    }

    if (coordLine !== '') {
      info.appendChild(document.createElement('br'));
      info.appendChild(document.createTextNode(coordLine));
    }

    this._msgAtomInfo.style.opacity = 1.0;
  };

  Miew.prototype._getAltObj = function () {
    if (this._editors) {
      var altObj = null;

      for (var i = 0; i < this._editors.length; ++i) {
        var nextAltObj = this._editors[i].getAltObj();

        if (nextAltObj.objects.length > 0) {
          if (altObj) {
            altObj = null;
            break;
          }

          altObj = nextAltObj;
        }
      }

      if (altObj) {
        return altObj;
      }
    }

    return {
      objects: [],
      pivot: new THREE__namespace.Vector3(0, 0, 0)
    };
  };

  Miew.prototype.resetPivot = function () {
    var boundingBox = new THREE__namespace.Box3();
    var center = new THREE__namespace.Vector3();
    return function () {
      boundingBox.makeEmpty();

      this._forEachVisual(function (visual) {
        boundingBox.union(visual.getBoundaries().boundingBox);
      });

      boundingBox.getCenter(center);

      this._objectControls.setPivot(center.negate());

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.setPivotResidue = function () {
    var center = new THREE__namespace.Vector3();
    return function (residue) {
      var visual = this._getVisualForComplex(residue.getChain().getComplex());

      if (!visual) {
        return;
      }

      if (residue._controlPoint) {
        center.copy(residue._controlPoint);
      } else {
        var x = 0;
        var y = 0;
        var z = 0;
        var amount = residue._atoms.length;

        for (var i = 0; i < amount; ++i) {
          var p = residue._atoms[i].position;
          x += p.x / amount;
          y += p.y / amount;
          z += p.z / amount;
        }

        center.set(x, y, z);
      }

      center.applyMatrix4(visual.matrix).negate();

      this._objectControls.setPivot(center);

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.setPivotAtom = function () {
    var center = new THREE__namespace.Vector3();
    return function (atom) {
      var visual = this._getVisualForComplex(atom.residue.getChain().getComplex());

      if (!visual) {
        return;
      }

      center.copy(atom.position);
      center.applyMatrix4(visual.matrix).negate();

      this._objectControls.setPivot(center);

      this.dispatchEvent({
        type: 'transform'
      });
    };
  }();

  Miew.prototype.getSelectionCenter = function () {
    var _centerInVisual = new THREE__namespace.Vector3(0.0, 0.0, 0.0);

    return function (center, includesAtom, selector) {
      center.set(0.0, 0.0, 0.0);
      var count = 0;

      this._forEachComplexVisual(function (visual) {
        if (visual.getSelectionCenter(_centerInVisual, includesAtom, selector || visual.getSelectionBit())) {
          center.add(_centerInVisual);
          count++;
        }
      });

      if (count === 0) {
        return false;
      }

      center.divideScalar(count);
      center.negate();
      return true;
    };
  }();

  Miew.prototype.setPivotSubset = function () {
    var _center = new THREE__namespace.Vector3(0.0, 0.0, 0.0);

    function _includesInCurSelection(atom, selectionBit) {
      return atom.mask & 1 << selectionBit;
    }

    function _includesInSelector(atom, selector) {
      return selector.selector.includesAtom(atom);
    }

    return function (selector) {
      var includesAtom = selector ? _includesInSelector : _includesInCurSelection;

      if (this.getSelectionCenter(_center, includesAtom, selector)) {
        this._objectControls.setPivot(_center);

        this.dispatchEvent({
          type: 'transform'
        });
      } else {
        this.logger.warn('selection is empty. Center operation not performed');
      }
    };
  }();

  Miew.prototype.screenshot = function (width, height) {
    var gfx = this._gfx;
    var deviceWidth = gfx.renderer.domElement.width;
    var deviceHeight = gfx.renderer.domElement.height;

    function fov2Tan(fov) {
      return Math.tan(THREE__namespace.MathUtils.degToRad(0.5 * fov));
    }

    function tan2Fov(tan) {
      return THREE__namespace.MathUtils.radToDeg(Math.atan(tan)) * 2.0;
    }

    function getDataURL() {
      var dataURL;
      var currBrowser = utils.getBrowser();

      if (currBrowser === utils.browserType.SAFARI) {
        var canvas = document.createElement('canvas');
        var canvasContext = canvas.getContext('2d');
        canvas.width = width === undefined ? deviceWidth : width;
        canvas.height = height === undefined ? deviceHeight : height;
        canvasContext.drawImage(gfx.renderer.domElement, 0, 0, canvas.width, canvas.height);
        dataURL = canvas.toDataURL('image/png');
      } else {
        dataURL = gfx.renderer.domElement.toDataURL('image/png');
      }

      return dataURL;
    }

    height = height || width;
    var screenshotURI;

    if (width === undefined && height === undefined || width === deviceWidth && height === deviceHeight) {
      screenshotURI = getDataURL();
    } else {
      var originalAspect = gfx.camera.aspect;
      var originalFov = gfx.camera.fov;
      var originalTanFov2 = fov2Tan(gfx.camera.fov);
      var areaOfInterestSize = Math.min(gfx.width, gfx.height);
      var areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height;
      var shotAspect = width / height;
      gfx.renderer.setPixelRatio(1);
      gfx.camera.aspect = shotAspect;
      gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1.0));
      gfx.camera.updateProjectionMatrix();
      gfx.renderer.setDrawingBufferSize(width, height, 1);

      this._renderFrame(settings$1.now.stereo);

      screenshotURI = getDataURL();
      gfx.renderer.setPixelRatio(window.devicePixelRatio);
      gfx.camera.aspect = originalAspect;
      gfx.camera.fov = originalFov;
      gfx.camera.updateProjectionMatrix();
      gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
      this._needRender = true;
    }

    return screenshotURI;
  };

  Miew.prototype.screenshotSave = function (filename, width, height) {
    var uri = this.screenshot(width, height);
    utils.shotDownload(uri, filename);
  };

  Miew.prototype.save = function (opts) {
    var _this7 = this;

    this._export(opts.fileType).then(function (dataString) {
      var filename = _this7._visuals[_this7._curVisualName]._complex.name;
      utils.download(dataString, filename, opts.fileType);

      _this7._refreshTitle();

      _this7.dispatchEvent({
        type: 'exportingDone'
      });
    }).catch(function (error) {
      _this7.logger.error('Could not export data');

      _this7.logger.debug(error);

      _this7._refreshTitle();

      _this7.dispatchEvent({
        type: 'exportingDone',
        error: error
      });
    });
  };

  Miew.prototype._tweakResolution = function () {
    var maxPerf = [['poor', 100], ['low', 500], ['medium', 1000], ['high', 5000], ['ultra', Number.MAX_VALUE]];
    var atomCount = 0;

    this._forEachComplexVisual(function (visual) {
      atomCount += visual.getComplex().getAtomCount();
    });

    if (atomCount > 0) {
      var performance = this._gfxScore * 10e5 / atomCount;

      for (var i = 0; i < maxPerf.length; ++i) {
        if (performance < maxPerf[i][1]) {
          this._autoChangeResolution(maxPerf[i][0]);

          break;
        }
      }
    }
  };

  Miew.prototype._autoChangeResolution = function (resolution) {
    if (resolution !== settings$1.now.resolution) {
      this.logger.report("Your rendering resolution was changed to \"".concat(resolution, "\" for best performance."));
    }

    settings$1.now.resolution = resolution;
  };

  Miew.prototype.saveSettings = function () {
    this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
  };

  Miew.prototype.restoreSettings = function () {
    try {
      var cookie = this._cookies.getCookie(this._opts.settingsCookie);

      var diffs = cookie ? JSON.parse(cookie) : {};
      this.settings.applyDiffs(diffs, true);
    } catch (e) {
      this.logger.error("Cookies parse error: ".concat(e.message));
    }
  };

  Miew.prototype.resetSettings = function () {
    this.settings.reset();
  };

  Miew.prototype.setOptions = function (opts) {
    if (typeof opts === 'string') {
      opts = Miew.options.fromAttr(opts);
    }

    if (opts.reps) {
      this._opts.reps = null;
    }

    ___default["default"].merge(this._opts, opts);

    if (opts.settings) {
      this.set(opts.settings);
    }

    this._opts._objects = opts._objects;

    this._resetObjects();

    if (opts.load) {
      this.load(opts.load, {
        fileType: opts.type
      });
    }

    if (opts.preset) {
      settings$1.now.preset = opts.preset;
    }

    if (opts.reps) {
      this.resetReps(opts.preset);
    }

    if (this._opts.view) {
      this.view(this._opts.view);
      delete this._opts.view;
    }

    var visual = this._getComplexVisual();

    if (visual) {
      visual.getComplex().resetCurrentUnit();

      if (___default["default"].isNumber(opts.unit)) {
        visual.getComplex().setCurrentUnit(opts.unit);
      }

      this.resetView();
      this.rebuildAll();
    }
  };

  Miew.prototype.info = function (name) {
    var visual = this._getComplexVisual(name);

    if (!visual) {
      return {};
    }

    var complex = visual.getComplex();
    var metadata = complex.metadata;
    return {
      id: metadata.id || complex.name || 'UNKNOWN',
      title: metadata.title && metadata.title.join(' ') || 'UNKNOWN DATA',
      atoms: complex.getAtomCount(),
      bonds: complex.getBondCount(),
      residues: complex.getResidueCount(),
      chains: complex.getChainCount()
    };
  };

  Miew.prototype.addObject = function (objData, bThrow) {
    var Ctor = null;

    if (objData.type === LinesObj.prototype.type) {
      Ctor = LinesObj;
    }

    if (Ctor === null) {
      throw new Error("Unknown scene object type - ".concat(objData.type));
    }

    try {
      var newObj = new Ctor(objData.params, objData.opts);

      this._addSceneObject(newObj);
    } catch (error) {
      if (!bThrow) {
        this.logger.debug("Error during scene object creation: ".concat(error.message));
      } else {
        throw error;
      }
    }

    this._needRender = true;
  };

  Miew.prototype._addSceneObject = function (sceneObject) {
    var visual = this._getComplexVisual();

    if (sceneObject.build && visual) {
      sceneObject.build(visual.getComplex());

      this._gfx.pivot.add(sceneObject.getGeometry());
    }

    var objects = this._objects;
    objects[objects.length] = sceneObject;
  };

  Miew.prototype._updateObjsToFrame = function (frameData) {
    var objs = this._objects;

    for (var i = 0, n = objs.length; i < n; ++i) {
      if (objs[i].updateToFrame) {
        objs[i].updateToFrame(frameData);
      }
    }
  };

  Miew.prototype._resetObjects = function () {
    var objs = this._opts._objects;
    this._objects = [];

    if (objs) {
      for (var i = 0, n = objs.length; i < n; ++i) {
        this.addObject(objs[i], false);
      }
    }
  };

  Miew.prototype.removeObject = function (index) {
    var obj = this._objects[index];

    if (!obj) {
      throw new Error("Scene object with index ".concat(index, " does not exist"));
    }

    obj.destroy();

    this._objects.splice(index, 1);

    this._needRender = true;
  };

  Miew.prototype.getURL = function (opts) {
    return options$1.toURL(this.getState(___default["default"].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    })));
  };

  Miew.prototype.getScript = function (opts) {
    return options$1.toScript(this.getState(___default["default"].defaults(opts, {
      compact: true,
      settings: true,
      view: true
    })));
  };

  Miew.prototype._compareReps = function (complexVisual, compareWithDefaults) {
    var ans = {};
    var repCount = 0;

    if (complexVisual) {
      repCount = complexVisual.repCount();
    }

    var currPreset = settings$1.defaults.presets[settings$1.now.preset];
    var compare = compareWithDefaults;

    if (currPreset === undefined || currPreset.length > repCount) {
      compare = false;
      ans.preset = 'empty';
    } else if (settings$1.now.preset !== settings$1.defaults.preset) {
      ans.preset = settings$1.now.preset;
    }

    var repsDiff = [];
    var emptyReps = true;

    for (var i = 0, n = repCount; i < n; ++i) {
      repsDiff[i] = complexVisual.repGet(i).compare(compare ? currPreset[i] : null);

      if (!___default["default"].isEmpty(repsDiff[i])) {
        emptyReps = false;
      }
    }

    if (!emptyReps) {
      ans.reps = repsDiff;
    }

    return ans;
  };

  Miew.prototype.getState = function (opts) {
    var state = {};
    opts = ___default["default"].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    });

    var visual = this._getComplexVisual();

    if (visual !== null) {
      var complex = visual.getComplex();
      var metadata = complex.metadata;

      if (metadata.id) {
        var format = metadata.format ? "".concat(metadata.format, ":") : '';
        state.load = format + metadata.id;
      }

      var unit = complex.getCurrentUnit();

      if (unit !== 1) {
        state.unit = unit;
      }
    }

    var repsInfo = this._compareReps(visual, opts.compact);

    if (repsInfo.preset) {
      state.preset = repsInfo.preset;
    }

    if (repsInfo.reps) {
      state.reps = repsInfo.reps;
    }

    var objects = this._objects;
    var objectsState = [];

    for (var i = 0, n = objects.length; i < n; ++i) {
      objectsState[i] = objects[i].identify();
    }

    if (objects.length > 0) {
      state._objects = objectsState;
    }

    if (opts.view) {
      state.view = this.view();
    }

    if (opts.settings) {
      var diff = this.settings.getDiffs(false);

      if (!___default["default"].isEmpty(diff)) {
        state.settings = diff;
      }
    }

    return state;
  };

  Miew.prototype.get = function (param, value) {
    return settings$1.get(param, value);
  };

  Miew.prototype._clipPlaneUpdateValue = function (radius) {
    var clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings$1.now.draft.clipPlaneFactor, settings$1.now.camNear);
    var opts = {
      clipPlaneValue: clipPlaneValue
    };

    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions(opts);
    });

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i];

      if (obj._line) {
        obj._line.material.setUberOptions(opts);
      }
    }

    if (this._picker !== null) {
      this._picker.clipPlaneValue = clipPlaneValue;
    }
  };

  Miew.prototype._fogFarUpdateValue = function () {
    if (this._picker !== null) {
      if (this._gfx.scene.fog) {
        this._picker.fogFarValue = this._gfx.scene.fog.far;
      } else {
        this._picker.fogFarValue = undefined;
      }
    }
  };

  Miew.prototype._updateShadowmapMeshes = function (process) {
    this._forEachComplexVisual(function (visual) {
      var reprList = visual._reprList;

      for (var i = 0, n = reprList.length; i < n; ++i) {
        var repr = reprList[i];
        process(repr.geo, repr.material);
      }
    });
  };

  Miew.prototype._updateMaterials = function (values) {
    var needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    this._forEachComplexVisual(function (visual) {
      return visual.setMaterialValues(values, needTraverse, process);
    });

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i];

      if (obj._line) {
        obj._line.material.setValues(values);

        obj._line.material.needsUpdate = true;
      }
    }
  };

  Miew.prototype._fogAlphaChanged = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions({
        fogAlpha: settings$1.now.fogAlpha
      });
    });
  };

  Miew.prototype._embedWebXR = function () {
    var _this8 = this;

    if (settings$1.now.stereo !== 'WEBVR') {
      if (this.webVR) {
        this.webVR.disable();
      }

      this.webVR = null;
      return;
    }

    if (!this.webVR) {
      this.webVR = new WebVRPoC(function () {
        _this8._requestAnimationFrame(function () {
          return _this8._onTick();
        });

        _this8._needRender = true;

        _this8._onResize();
      });
    }

    this.webVR.enable(this._gfx);
  };

  Miew.prototype._initOnSettingsChanged = function () {
    var _this9 = this;

    var on = function on(props, func) {
      props = ___default["default"].isArray(props) ? props : [props];
      props.forEach(function (prop) {
        _this9.settings.addEventListener("change:".concat(prop), func);
      });
    };

    on('modes.VD.frame', function () {
      var volume = _this9._getVolumeVisual();

      if (volume === null) return;
      volume.showFrame(settings$1.now.modes.VD.frame);
      _this9._needRender = true;
    });
    on('modes.VD.isoMode', function () {
      var volume = _this9._getVolumeVisual();

      if (volume === null) return;
      volume.getMesh().material.updateDefines();
      _this9._needRender = true;
    });
    on('bg.color', function () {
      _this9._onBgColorChanged();
    });
    on('ao', function () {
      if (settings$1.now.ao && !isAOSupported(_this9._gfx.renderer.getContext())) {
        _this9.logger.warn('Your device or browser does not support ao');

        settings$1.set('ao', false);
      } else {
        var values = {
          normalsToGBuffer: settings$1.now.ao
        };

        _this9._setUberMaterialValues(values);
      }
    });
    on('zSprites', function () {
      if (settings$1.now.zSprites && !arezSpritesSupported(_this9._gfx.renderer.getContext())) {
        _this9.logger.warn('Your device or browser does not support zSprites');

        settings$1.set('zSprites', false);
      }

      _this9.rebuildAll();
    });
    on('fogColor', function () {
      _this9._onFogColorChanged();
    });
    on('fogColorEnable', function () {
      _this9._onFogColorChanged();
    });
    on('bg.transparent', function (evt) {
      var gfx = _this9._gfx;

      if (gfx) {
        gfx.renderer.setClearColor(settings$1.now.bg.color, Number(!settings$1.now.bg.transparent));
      }

      _this9._updateMaterials({
        fogTransparent: evt.value
      });

      _this9.rebuildAll();
    });
    on('draft.clipPlane', function (evt) {
      _this9._updateMaterials({
        clipPlane: evt.value
      });

      _this9.rebuildAll();
    });
    on('shadow.on', function (evt) {
      var values = {
        shadowmap: evt.value,
        shadowmapType: settings$1.now.shadow.type
      };
      var gfx = _this9._gfx;

      if (gfx) {
        gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap);
      }

      _this9._updateMaterials(values, true);

      if (values.shadowmap) {
        _this9._updateShadowCamera();

        _this9._updateShadowmapMeshes(meshutils.createShadowmapMaterial);
      } else {
        _this9._updateShadowmapMeshes(meshutils.removeShadowmapMaterial);
      }

      _this9._needRender = true;
    });
    on('shadow.type', function (evt) {
      if (settings$1.now.shadow.on) {
        _this9._updateMaterials({
          shadowmapType: evt.value
        }, true);

        _this9._needRender = true;
      }
    });
    on('shadow.radius', function (evt) {
      for (var i = 0; i < _this9._gfx.scene.children.length; i++) {
        if (_this9._gfx.scene.children[i].shadow !== undefined) {
          var light = _this9._gfx.scene.children[i];
          light.shadow.radius = evt.value;
          _this9._needRender = true;
        }
      }
    });
    on('fps', function () {
      _this9._fps.show(settings$1.now.fps);
    });
    on(['fog', 'fogNearFactor', 'fogFarFactor'], function () {
      _this9._updateFog();

      _this9._needRender = true;
    });
    on('fogAlpha', function () {
      var fogAlpha = settings$1.now.fogAlpha;

      if (fogAlpha < 0 || fogAlpha > 1) {
        _this9.logger.warn('fogAlpha must belong range [0,1]');
      }

      _this9._fogAlphaChanged();

      _this9._needRender = true;
    });
    on('autoResolution', function (evt) {
      if (evt.value && !_this9._gfxScore) {
        _this9.logger.warn('Benchmarks are missed, autoresolution will not work! ' + 'Autoresolution should be set during miew startup.');
      }
    });
    on('stereo', function () {
      _this9._embedWebXR(settings$1.now.stereo === 'WEBVR');

      _this9._needRender = true;
    });
    on(['transparency', 'palette'], function () {
      _this9.rebuildAll();
    });
    on('resolution', function () {
      _this9.rebuildAll();

      var volume = _this9._getVolumeVisual();

      if (volume) {
        volume.getMesh().material.updateDefines();
        _this9._needRender = true;
      }
    });
    on(['axes', 'fxaa', 'ao', 'outline.on', 'outline.color', 'outline.threshold', 'outline.thickness'], function () {
      _this9._needRender = true;
    });
  };

  Miew.prototype.set = function (params, value) {
    settings$1.set(params, value);
  };

  Miew.prototype.select = function (expression, append) {
    var visual = this._getComplexVisual();

    if (!visual) {
      return;
    }

    var sel = expression;

    if (___default["default"].isString(expression)) {
      sel = selectors$1.parse(expression).selector;
    }

    visual.select(sel, append);
    this._lastPick = null;

    this._updateInfoPanel();

    this._needRender = true;
  };

  var VIEW_VERSION = '1';

  Miew.prototype.view = function (expression) {
    var self = this;
    var pivot = this._gfx.pivot;
    var transform = [];
    var eulerOrder = 'ZXY';

    function encode() {
      var pos = pivot.position;
      var scale = self._objectControls.getScale() / settings$1.now.radiusToFit;
      var euler = new THREE__namespace.Euler();
      euler.setFromQuaternion(self._objectControls.getOrientation(), eulerOrder);
      transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
      return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
    }

    function decode() {
      if (expression.length === 40) {
        expression = "0".concat(expression);
      }

      var version = expression[0];
      transform = utils.arrayFromBase64(expression.substr(1), Float32Array);

      if (version !== VIEW_VERSION) {
        if (version === '0') {
          transform[3] /= 8.0;
        } else {
          self.logger.warn("Encoded view version mismatch, stored as ".concat(version, " vs ").concat(VIEW_VERSION, " expected"));
          return;
        }
      }

      var interpolator = self._interpolator;
      var srcView = interpolator.createView();
      srcView.position.copy(pivot.position);
      srcView.scale = self._objectControls.getScale();
      srcView.orientation.copy(self._objectControls.getOrientation());
      var dstView = interpolator.createView();
      dstView.position.set(transform[0], transform[1], transform[2]);

      if (self._getComplexVisual()) {
        dstView.position.sub(self._getComplexVisual().position);
      }

      dstView.scale = transform[3];
      dstView.orientation.setFromEuler(new THREE__namespace.Euler(transform[4], transform[5], transform[6], eulerOrder));
      interpolator.setup(srcView, dstView);
    }

    if (typeof expression === 'undefined') {
      return encode();
    }

    decode();
    return expression;
  };

  Miew.prototype._updateView = function () {
    var self = this;
    var pivot = this._gfx.pivot;
    var interpolator = this._interpolator;

    if (!interpolator.wasStarted()) {
      interpolator.start();
    }

    if (!interpolator.isMoving()) {
      return;
    }

    var res = interpolator.getCurrentView();

    if (res.success) {
      var curr = res.view;
      pivot.position.copy(curr.position);

      self._objectControls.setScale(curr.scale * settings$1.now.radiusToFit);

      self._objectControls.setOrientation(curr.orientation);

      this.dispatchEvent({
        type: 'transform'
      });
      self._needRender = true;
    }
  };

  Miew.prototype.translate = function (x, y, z) {
    this._objectControls.translatePivot(x, y, z);

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };

  Miew.prototype.rotate = function (x, y, z) {
    this._objectControls.rotate(new THREE__namespace.Quaternion().setFromEuler(new THREE__namespace.Euler(x, y, z, 'XYZ')));

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };

  Miew.prototype.scale = function (factor) {
    if (factor <= 0) {
      throw new RangeError('Scale should be greater than zero');
    }

    this._objectControls.scale(factor);

    this.dispatchEvent({
      type: 'transform'
    });
    this._needRender = true;
  };

  Miew.prototype.center = function (selector) {
    if (selector === undefined) {
      this.setPivotSubset();
      this._needRender = true;
      return;
    }

    if (selector.obj !== undefined && ('atom' in selector.obj || 'residue' in selector.obj)) {
      if ('atom' in selector.obj) {
        this.setPivotAtom(selector.obj.atom);
      } else {
        this.setPivotResidue(selector.obj.residue);
      }

      this._needRender = true;
      return;
    }

    if (selector.obj === undefined && selector !== '') {
      var sel = selectors$1.parse(selector);

      if (sel.error === undefined) {
        this.setPivotSubset(sel);
        this._needRender = true;
        return;
      }
    }

    this.resetPivot();
    this._needRender = true;
  };

  Miew.prototype.within = function (selector, radius) {
    var visual = this._getComplexVisual();

    if (!visual) {
      return selectors$1.None();
    }

    if (selector instanceof String) {
      selector = selectors$1.parse(selector);
    }

    var res = visual.within(selector, radius);

    if (res) {
      visual.rebuildSelectionGeometry();
      this._needRender = true;
    }

    return res;
  };

  Miew.prototype.projected = function (fullAtomName, complexName) {
    var visual = this._getComplexVisual(complexName);

    if (!visual) {
      return false;
    }

    var atom = visual.getComplex().getAtomByFullname(fullAtomName);

    if (atom === null) {
      return false;
    }

    var pos = atom.position.clone();

    this._gfx.pivot.updateMatrixWorldRecursive();

    this._gfx.camera.updateMatrixWorldRecursive();

    this._gfx.pivot.localToWorld(pos);

    pos.project(this._gfx.camera);
    return {
      x: (pos.x + 1.0) * 0.5 * this._gfx.width,
      y: (1.0 - pos.y) * 0.5 * this._gfx.height
    };
  };

  Miew.prototype.dssp = function (complexName) {
    var visual = this._getComplexVisual(complexName);

    if (!visual) {
      return;
    }

    visual.getComplex().dssp();

    visual._reprList.forEach(function (rep) {
      if (rep.mode.id === 'CA' || rep.colorer.id === 'SS') {
        rep.needsRebuild = true;
      }
    });
  };

  Miew.prototype.exportCML = function () {
    var self = this;

    function extractRotation(m) {
      var xAxis = new THREE__namespace.Vector3();
      var yAxis = new THREE__namespace.Vector3();
      var zAxis = new THREE__namespace.Vector3();
      m.extractBasis(xAxis, yAxis, zAxis);
      xAxis.normalize();
      yAxis.normalize();
      zAxis.normalize();
      var retMat = new THREE__namespace.Matrix4();
      retMat.identity();
      retMat.makeBasis(xAxis, yAxis, zAxis);
      return retMat;
    }

    function updateCMLData(complex) {
      var root = self._gfx.root;
      var mat = extractRotation(root.matrixWorld);
      var v4 = new THREE__namespace.Vector4(0, 0, 0, 0);
      var vCenter = new THREE__namespace.Vector4(0, 0, 0, 0);
      var xml = null;
      var ap = null;
      complex.forEachAtom(function (atom) {
        if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
          xml = atom.xmlNodeRef.xmlNode;
          ap = atom.position;
          v4.set(ap.x, ap.y, ap.z, 1.0);
          v4.applyMatrix4(mat);
          xml.setAttribute('x3', v4.x.toString());
          xml.setAttribute('y3', v4.y.toString());
          xml.setAttribute('z3', v4.z.toString());
          xml.removeAttribute('x2');
          xml.removeAttribute('y2');
        }
      });
      complex.forEachSGroup(function (sGroup) {
        if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
          xml = sGroup.xmlNodeRef.xmlNode;
          ap = sGroup.getPosition();
          v4.set(ap.x, ap.y, ap.z, 1.0);
          var cp = sGroup.getCentralPoint();

          if (cp === null) {
            v4.applyMatrix4(mat);
          } else {
            vCenter.set(cp.x, cp.y, cp.z, 0.0);
            v4.add(vCenter);
            v4.applyMatrix4(mat);
            vCenter.set(cp.x, cp.y, cp.z, 1.0);
            vCenter.applyMatrix4(mat);
            v4.sub(vCenter);
          }

          xml.setAttribute('x', v4.x.toString());
          xml.setAttribute('y', v4.y.toString());
          xml.setAttribute('z', v4.z.toString());
        }
      });
    }

    var visual = self._getComplexVisual();

    var complex = visual ? visual.getComplex() : null;

    if (complex && complex.originalCML) {
      updateCMLData(complex);
      var oSerializer = new XMLSerializer();
      return oSerializer.serializeToString(complex.originalCML);
    }

    return null;
  };

  Miew.prototype.motm = function () {
    settings$1.set({
      fogColorEnable: true,
      fogColor: 0x000000,
      outline: {
        on: true,
        threshold: 0.01
      },
      bg: {
        color: 0xffffff
      }
    });

    this._forEachComplexVisual(function (visual) {
      var rep = [];
      var complex = visual.getComplex();
      var palette = palettes$1.get(settings$1.now.palette);

      for (var i = 0; i < complex.getChainCount(); i++) {
        var curChainName = complex._chains[i]._name;
        var curChainColor = palette.getChainColor(curChainName);
        rep[i] = {
          selector: "chain ".concat(curChainName),
          mode: 'VW',
          colorer: ['CB', {
            color: curChainColor,
            factor: 0.9
          }],
          material: 'FL'
        };
      }

      visual.resetReps(rep);
    });
  };

  Miew.prototype.VERSION = "0.9.0+20211214.103700.4bffefe-mod" ;

  ___default["default"].assign(Miew, {
    VERSION: Miew.prototype.VERSION,
    registeredPlugins: [],
    chem: chem,
    io: io,
    modes: modes$1,
    colorers: colorers$1,
    materials: materials$1,
    palettes: palettes$1,
    options: options$1,
    settings: settings$1,
    utils: utils,
    gfx: {
      Representation: Representation
    },
    thirdParty: {
      lodash: ___default["default"],
      three: THREE__namespace
    }
  });

  var parser = (function () {
    var o = function (k, v, o, l) {
        for (o = o || {}, l = k.length; l--; o[k[l]] = v);
        return o
      },
      $V0 = [1, 60],
      $V1 = [1, 62],
      $V2 = [1, 63],
      $V3 = [1, 65],
      $V4 = [1, 66],
      $V5 = [1, 67],
      $V6 = [1, 68],
      $V7 = [1, 69],
      $V8 = [1, 80],
      $V9 = [1, 72],
      $Va = [1, 73],
      $Vb = [1, 74],
      $Vc = [1, 75],
      $Vd = [1, 99],
      $Ve = [1, 76],
      $Vf = [1, 100],
      $Vg = [1, 79],
      $Vh = [1, 51],
      $Vi = [1, 81],
      $Vj = [1, 82],
      $Vk = [1, 84],
      $Vl = [1, 83],
      $Vm = [1, 85],
      $Vn = [1, 96],
      $Vo = [1, 97],
      $Vp = [1, 98],
      $Vq = [1, 86],
      $Vr = [1, 87],
      $Vs = [1, 64],
      $Vt = [1, 70],
      $Vu = [1, 71],
      $Vv = [1, 77],
      $Vw = [1, 78],
      $Vx = [1, 53],
      $Vy = [1, 54],
      $Vz = [1, 55],
      $VA = [1, 61],
      $VB = [1, 88],
      $VC = [1, 89],
      $VD = [1, 90],
      $VE = [1, 91],
      $VF = [1, 92],
      $VG = [1, 93],
      $VH = [1, 94],
      $VI = [1, 95],
      $VJ = [1, 101],
      $VK = [1, 102],
      $VL = [1, 103],
      $VM = [1, 104],
      $VN = [1, 105],
      $VO = [1, 56],
      $VP = [1, 57],
      $VQ = [1, 58],
      $VR = [1, 59],
      $VS = [1, 115],
      $VT = [1, 111],
      $VU = [1, 114],
      $VV = [1, 112],
      $VW = [1, 113],
      $VX = [1, 118],
      $VY = [1, 117],
      $VZ = [1, 134],
      $V_ = [1, 149],
      $V$ = [1, 150],
      $V01 = [1, 157],
      $V11 = [
        5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35,
        37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70,
        72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        96, 97, 98, 99, 101
      ],
      $V21 = [
        5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35,
        37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70,
        71, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
        95, 96, 97, 98, 99, 101
      ],
      $V31 = [
        5, 6, 7, 9, 13, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 37, 38,
        41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 82,
        83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95
      ],
      $V41 = [5, 70, 72],
      $V51 = [5, 74],
      $V61 = [71, 101];
    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        error: 2,
        Program: 3,
        Command: 4,
        EOF: 5,
        RESET: 6,
        BUILD: 7,
        ALL: 8,
        HELP: 9,
        Path: 10,
        MOTM: 11,
        OneArgCommand: 12,
        GET: 13,
        STRING: 14,
        SET: 15,
        Value: 16,
        SET_SAVE: 17,
        SET_RESTORE: 18,
        SET_RESET: 19,
        PRESET: 20,
        AddRepresentation: 21,
        EditRepresentation: 22,
        REMOVE: 23,
        RepresentationReference: 24,
        HIDE: 25,
        SHOW: 26,
        LIST: 27,
        EXPAND_KEY: 28,
        SELECTOR_KEY: 29,
        SELECT: 30,
        AS: 31,
        WordAll: 32,
        SELECTOR: 33,
        WITHIN: 34,
        NUMBER: 35,
        OF: 36,
        MATERIAL: 37,
        IDENTIFIER: 38,
        ModeCMD: 39,
        ColorCMD: 40,
        VIEW: 41,
        BASE_64: 42,
        UNIT: 43,
        DSSP: 44,
        SCALE: 45,
        ROTATE: 46,
        AxesList: 47,
        TRANSLATE: 48,
        CENTER: 49,
        GetURLBranch: 50,
        Screenshot: 51,
        LINE: 52,
        ArgList: 53,
        LISTOBJ: 54,
        REMOVEOBJ: 55,
        URL: 56,
        VIEW_KEY: 57,
        SCREENSHOT: 58,
        LOAD: 59,
        Url: 60,
        FILE_KEY: 61,
        ADD: 62,
        Description: 63,
        REP: 64,
        MODE: 65,
        COLOR: 66,
        Descriptor: 67,
        RepresentationOwnProperty: 68,
        RepresentationOwnPropertyOpts: 69,
        DESC_KEY: 70,
        '=': 71,
        DESC_KEY_OPTS: 72,
        AxesArg: 73,
        DESC_KEY_AXES: 74,
        Arg: 75,
        PathWoDescKey: 76,
        HEX: 77,
        BOOL: 78,
        Word: 79,
        CommandSetWoDESC_KEY: 80,
        DescKeys: 81,
        CLEAR: 82,
        FILE_LIST: 83,
        FILE_REGISTER: 84,
        FILE_DELETE: 85,
        PRESET_ADD: 86,
        PRESET_DELETE: 87,
        PRESET_UPDATE: 88,
        PRESET_RENAME: 89,
        PRESET_OPEN: 90,
        CREATE_SCENARIO: 91,
        RESET_SCENARIO: 92,
        DELETE_SCENARIO: 93,
        ADD_SCENARIO_ITEM: 94,
        LIST_SCENARIO: 95,
        PDB_KEY: 96,
        DELAY_KEY: 97,
        PRST_KEY: 98,
        DESCRIPTION_KEY: 99,
        CommandSet: 100,
        '.': 101,
        PresetPath: 102,
        '/': 103,
        HexOrNumber: 104,
        $accept: 0,
        $end: 1
      },
      terminals_: {
        2: 'error',
        5: 'EOF',
        6: 'RESET',
        7: 'BUILD',
        8: 'ALL',
        9: 'HELP',
        11: 'MOTM',
        13: 'GET',
        14: 'STRING',
        15: 'SET',
        17: 'SET_SAVE',
        18: 'SET_RESTORE',
        19: 'SET_RESET',
        20: 'PRESET',
        23: 'REMOVE',
        25: 'HIDE',
        26: 'SHOW',
        27: 'LIST',
        28: 'EXPAND_KEY',
        29: 'SELECTOR_KEY',
        30: 'SELECT',
        31: 'AS',
        33: 'SELECTOR',
        34: 'WITHIN',
        35: 'NUMBER',
        36: 'OF',
        37: 'MATERIAL',
        38: 'IDENTIFIER',
        41: 'VIEW',
        42: 'BASE_64',
        43: 'UNIT',
        44: 'DSSP',
        45: 'SCALE',
        46: 'ROTATE',
        48: 'TRANSLATE',
        49: 'CENTER',
        52: 'LINE',
        54: 'LISTOBJ',
        55: 'REMOVEOBJ',
        56: 'URL',
        57: 'VIEW_KEY',
        58: 'SCREENSHOT',
        59: 'LOAD',
        61: 'FILE_KEY',
        62: 'ADD',
        64: 'REP',
        65: 'MODE',
        66: 'COLOR',
        70: 'DESC_KEY',
        71: '=',
        72: 'DESC_KEY_OPTS',
        74: 'DESC_KEY_AXES',
        77: 'HEX',
        78: 'BOOL',
        82: 'CLEAR',
        83: 'FILE_LIST',
        84: 'FILE_REGISTER',
        85: 'FILE_DELETE',
        86: 'PRESET_ADD',
        87: 'PRESET_DELETE',
        88: 'PRESET_UPDATE',
        89: 'PRESET_RENAME',
        90: 'PRESET_OPEN',
        91: 'CREATE_SCENARIO',
        92: 'RESET_SCENARIO',
        93: 'DELETE_SCENARIO',
        94: 'ADD_SCENARIO_ITEM',
        95: 'LIST_SCENARIO',
        96: 'PDB_KEY',
        97: 'DELAY_KEY',
        98: 'PRST_KEY',
        99: 'DESCRIPTION_KEY',
        101: '.',
        103: '/'
      },
      productions_: [
        0,
        [3, 2],
        [3, 1],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 3],
        [4, 3],
        [4, 1],
        [4, 1],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 4],
        [4, 2],
        [4, 6],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 3],
        [4, 3],
        [4, 4],
        [4, 4],
        [4, 1],
        [4, 2],
        [50, 1],
        [50, 2],
        [50, 2],
        [50, 3],
        [50, 3],
        [51, 1],
        [51, 2],
        [51, 3],
        [12, 2],
        [12, 2],
        [12, 2],
        [21, 1],
        [21, 2],
        [21, 2],
        [21, 3],
        [22, 2],
        [22, 3],
        [39, 2],
        [39, 3],
        [40, 2],
        [40, 3],
        [24, 1],
        [24, 1],
        [63, 1],
        [63, 2],
        [63, 3],
        [63, 4],
        [67, 1],
        [67, 1],
        [67, 2],
        [68, 3],
        [69, 3],
        [47, 1],
        [47, 2],
        [73, 2],
        [53, 1],
        [53, 2],
        [75, 3],
        [16, 1],
        [16, 1],
        [16, 1],
        [16, 1],
        [16, 1],
        [79, 1],
        [79, 1],
        [32, 1],
        [32, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [100, 1],
        [100, 1],
        [76, 1],
        [76, 3],
        [76, 3],
        [10, 1],
        [10, 1],
        [10, 3],
        [10, 3],
        [10, 3],
        [60, 1],
        [102, 1],
        [102, 3],
        [104, 1],
        [104, 1]
      ],
      performAction: function anonymous(
        yytext,
        yyleng,
        yylineno,
        yy,
        yystate ,
        $$ ,
        _$
      ) {
        var $0 = $$.length - 1;
        switch (yystate) {
          case 1:
            return $$[$0 - 1]
          case 3:
            this.$ = yy.miew.reset(false);
            yy.ClearContext();
            yy.miew.resetReps('empty');
            break
          case 4:
            this.$ = yy.miew.rebuild();
            break
          case 5:
            this.$ = yy.miew.rebuildAll();
            yy.miew.rebuild();
            break
          case 6:
            this.$ = yy.echo(yy.utils.help().toString());
            break
          case 7:
            this.$ = yy.echo(yy.utils.help($$[$0]).toString());
            break
          case 8:
            this.$ = yy.miew.motm();
            break
          case 10:
          case 11:
            this.$ = yy.utils.propagateProp($$[$0]);
            yy.echo(yy.miew.get($$[$0]).toString());
            break
          case 12:
          case 13:
            this.$ = yy.miew.set(
              $$[$0 - 1],
              yy.utils.propagateProp($$[$0 - 1], $$[$0])
            );
            break
          case 14:
            this.$ = yy.miew.saveSettings();
            break
          case 15:
            this.$ = yy.miew.restoreSettings();
            break
          case 16:
            this.$ = yy.miew.resetSettings();
            break
          case 17:
            this.$ = yy.miew.resetReps();
            break
          case 18:
            this.$ = yy.miew.applyPreset($$[$0]);
            break
          case 21:
            this.$ = yy.miew.repRemove($$[$0]);
            yy.representations.remove($$[$0]);
            break
          case 22:
            this.$ = yy.miew.repHide($$[$0]);
            break
          case 23:
            this.$ = yy.miew.repHide($$[$0], false);
            break
          case 24:
            this.$ = yy.echo(
              yy.utils.listRep(yy.miew, yy.representations, $$[$0], '-e')
            );
            break
          case 25:
            this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
            break
          case 26:
            this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
            break
          case 27:
            this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
            break
          case 28:
            this.$ = yy.miew.select(
              yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0], true)
            );
            break
          case 29:
            this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg(
              $$[$0 - 3].toLowerCase(),
              $$[$0 - 2],
              true
            );
            yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
            break
          case 30:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              selector: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0])
            });
            break
          case 31:
            this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(
              yy.utils.checkArg('select', $$[$0 - 2], true),
              Number($$[$0 - 4])
            );
            break
          case 32:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              material: yy.utils.checkArg(
                $$[$0 - 1].toLowerCase(),
                $$[$0].toUpperCase()
              )
            });
            break
          case 35:
            this.$ = yy.echo(yy.miew.view());
            break
          case 36:
          case 37:
            this.$ = yy.miew.view($$[$0]);
            break
          case 38:
            this.$ = yy.echo(yy.miew.changeUnit());
            break
          case 39:
            this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
            break
          case 40:
            this.$ = yy.miew.dssp();
            break
          case 41:
            this.$ = yy.miew.scale($$[$0]);
            break
          case 42:
            for (var i = 0, n = $$[$0].length; i < n; i++) {
              yy.miew.rotate(
                ($$[$0][i]['x'] * Math.PI) / 180.0,
                ($$[$0][i]['y'] * Math.PI) / 180.0,
                ($$[$0][i]['z'] * Math.PI) / 180.0
              );
            }
            break
          case 43:
            for (var i = 0, n = $$[$0].length; i < n; i++) {
              yy.miew.translate(
                $$[$0][i]['x'] || 0,
                $$[$0][i]['y'] || 0,
                $$[$0][i]['z'] || 0
              );
            }
            break
          case 44:
            this.$ = yy.miew.center();
            break
          case 45:
            this.$ = yy.miew.center($$[$0]);
            break
          case 48:
          case 49:
            this.$ = yy.miew.addObject(
              { type: 'line', params: [$$[$0 - 1], $$[$0]] },
              true
            );
            break
          case 50:
          case 51:
            this.$ = yy.miew.addObject(
              {
                type: 'line',
                params: [$$[$0 - 2], $$[$0 - 1]],
                opts: $$[$0].toJSO(yy.utils, 'objects', 'line')
              },
              true
            );
            break
          case 52:
            this.$ = yy.echo(yy.utils.listObjs(yy.miew));
            break
          case 53:
            this.$ = yy.miew.removeObject($$[$0]);
            break
          case 54:
            this.$ = yy.echo(yy.miew.getURL({ view: false, settings: false }));
            break
          case 55:
            this.$ = yy.echo(yy.miew.getURL({ view: false, settings: true }));
            break
          case 56:
            this.$ = yy.echo(yy.miew.getURL({ view: true, settings: false }));
            break
          case 57:
          case 58:
            this.$ = yy.echo(yy.miew.getURL({ view: true, settings: true }));
            break
          case 59:
            this.$ = yy.miew.screenshotSave();
            break
          case 60:
            this.$ = yy.miew.screenshotSave('', Number($$[$0]));
            break
          case 61:
            this.$ = yy.miew.screenshotSave(
              '',
              Number($$[$0 - 1]),
              Number($$[$0])
            );
            break
          case 62:
          case 63:
          case 64:
            this.$ = yy.utils.load(yy.miew, $$[$0]);
            yy.representations.clear();
            break
          case 65:
            this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
            break
          case 66:
            this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
            break
          case 67:
            this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
            break
          case 68:
            this.$ = yy.echo(
              yy.representations.add($$[$0 - 1], yy.miew.repAdd($$[$0]))
            );
            break
          case 69:
            this.$ = yy.miew.rep($$[$0]);
            yy.miew.repCurrent($$[$0]);
            break
          case 70:
            this.$ = yy.miew.rep($$[$0 - 1], $$[$0]);
            yy.miew.repCurrent($$[$0 - 1]);
            break
          case 71:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              mode: yy.utils.checkArg(
                $$[$0 - 1].toLowerCase(),
                $$[$0].toUpperCase()
              )
            });
            break
          case 72:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              mode: new Array(
                yy.utils.checkArg(
                  $$[$0 - 2].toLowerCase(),
                  $$[$0 - 1].toUpperCase()
                ),
                $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase())
              )
            });
            break
          case 73:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              colorer: yy.utils.checkArg(
                $$[$0 - 1].toLowerCase(),
                $$[$0].toUpperCase()
              )
            });
            break
          case 74:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              colorer: new Array(
                yy.utils.checkArg(
                  $$[$0 - 2].toLowerCase(),
                  $$[$0 - 1].toUpperCase()
                ),
                $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase())
              )
            });
            break
          case 75:
            this.$ = Number(yy.representations.get($$[$0]));
            break
          case 76:
          case 92:
            this.$ = Number($$[$0]);
            break
          case 77:
            this.$ = $$[$0];
            break
          case 78:
            this.$ = yy._.assign($$[$0 - 1], $$[$0]);
            break
          case 79:
            this.$ = yy._.assign($$[$0 - 2], $$[$0 - 1], $$[$0]);
            break
          case 80:
            this.$ = yy._.assign($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0]);
            break
          case 81:
          case 82:
            this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
            break
          case 83:
            this.$ = yy.CreateObjectPair(
              $$[$0 - 1].key,
              new Array(
                $$[$0 - 1].val,
                $$[$0].toJSO(yy.utils, $$[$0 - 1].key, $$[$0 - 1].val)
              )
            );
            break
          case 84:
          case 85:
            this.$ = Object.create({
              key: yy.keyRemap($$[$0 - 2]),
              val: yy.utils.checkArg($$[$0 - 2], $$[$0])
            });
            break
          case 86:
            this.$ = [$$[$0]];
            break
          case 87:
            this.$ = $$[$0 - 1].concat($$[$0]);
            break
          case 88:
            this.$ = yy.CreateObjectPair($$[$0 - 1].toLowerCase(), Number($$[$0]));
            break
          case 89:
            this.$ = new yy.ArgList($$[$0]);
            break
          case 90:
            this.$ = $$[$0 - 1].append($$[$0]);
            break
          case 91:
            this.$ = new yy.Arg($$[$0 - 2], $$[$0]);
            break
          case 93:
            this.$ = parseInt($$[$0]);
            break
          case 94:
            this.$ = JSON.parse($$[$0]);
            break
          case 95:
          case 96:
            this.$ = String($$[$0]);
            break
          case 157:
          case 158:
          case 161:
          case 162:
          case 163:
            this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
            break
          case 166:
            this.$ = $$[$0 - 2] = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
            break
        }
      },
      table: [
        {
          3: 1,
          4: 2,
          5: [1, 3],
          6: [1, 4],
          7: [1, 5],
          9: [1, 6],
          11: [1, 7],
          12: 8,
          13: [1, 9],
          15: [1, 10],
          17: [1, 11],
          18: [1, 12],
          19: [1, 13],
          20: [1, 14],
          21: 15,
          22: 16,
          23: [1, 17],
          25: [1, 18],
          26: [1, 19],
          27: [1, 20],
          30: [1, 21],
          33: [1, 22],
          34: [1, 23],
          37: [1, 24],
          39: 25,
          40: 26,
          41: [1, 27],
          43: [1, 28],
          44: [1, 29],
          45: [1, 30],
          46: [1, 31],
          48: [1, 32],
          49: [1, 33],
          50: 34,
          51: 35,
          52: [1, 36],
          54: [1, 37],
          55: [1, 38],
          56: [1, 44],
          58: [1, 45],
          59: [1, 39],
          62: [1, 40],
          64: [1, 41],
          65: [1, 42],
          66: [1, 43]
        },
        { 1: [3] },
        { 5: [1, 46] },
        { 1: [2, 2] },
        { 5: [2, 3] },
        { 5: [2, 4], 8: [1, 47] },
        {
          5: [2, 6],
          6: $V0,
          7: $V1,
          9: $V2,
          10: 48,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 8] },
        { 5: [2, 9] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 106,
          13: $V3,
          14: [1, 107],
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 108,
          13: $V3,
          14: [1, 109],
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 14] },
        { 5: [2, 15] },
        { 5: [2, 16] },
        { 5: [2, 17], 14: $VS, 16: 110, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 5: [2, 19] },
        { 5: [2, 20] },
        { 24: 116, 35: $VX, 38: $VY },
        { 24: 119, 35: $VX, 38: $VY },
        { 24: 120, 35: $VX, 38: $VY },
        { 5: [2, 25], 24: 121, 28: [1, 122], 29: [1, 123], 35: $VX, 38: $VY },
        { 14: [1, 124] },
        { 14: [1, 125] },
        { 35: [1, 126] },
        { 38: [1, 127] },
        { 5: [2, 33] },
        { 5: [2, 34] },
        { 5: [2, 35], 14: [1, 128], 42: [1, 129] },
        { 5: [2, 38], 35: [1, 130] },
        { 5: [2, 40] },
        { 35: [1, 131] },
        { 47: 132, 73: 133, 74: $VZ },
        { 47: 135, 73: 133, 74: $VZ },
        { 5: [2, 44], 14: [1, 136] },
        { 5: [2, 46] },
        { 5: [2, 47] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 138,
          13: $V3,
          14: [1, 137],
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 52] },
        { 35: [1, 139] },
        { 14: [1, 143], 38: [1, 141], 60: 140, 61: [1, 142] },
        {
          5: [2, 65],
          38: [1, 144],
          63: 145,
          67: 146,
          68: 147,
          69: 148,
          70: $V_,
          72: $V$
        },
        { 24: 151, 35: $VX, 38: $VY },
        { 38: [1, 152] },
        { 38: [1, 153] },
        { 5: [2, 54], 29: [1, 154], 57: [1, 155] },
        { 5: [2, 59], 35: [1, 156] },
        { 1: [2, 1] },
        { 5: [2, 5] },
        { 5: [2, 7], 101: $V01 },
        o($V11, [2, 159]),
        o($V11, [2, 160]),
        o($V21, [2, 97]),
        o($V21, [2, 98]),
        o($V11, [2, 147]),
        o($V11, [2, 148]),
        o($V11, [2, 149]),
        o($V11, [2, 150]),
        o($V11, [2, 151]),
        o($V11, [2, 152]),
        o($V11, [2, 153]),
        o($V21, [2, 101]),
        o($V21, [2, 102]),
        o($V21, [2, 103]),
        o($V21, [2, 104]),
        o($V21, [2, 105]),
        o($V21, [2, 106]),
        o($V21, [2, 107]),
        o($V21, [2, 108]),
        o($V21, [2, 109]),
        o($V21, [2, 110]),
        o($V21, [2, 111]),
        o($V21, [2, 112]),
        o($V21, [2, 113]),
        o($V21, [2, 114]),
        o($V21, [2, 115]),
        o($V21, [2, 116]),
        o($V21, [2, 117]),
        o($V21, [2, 118]),
        o($V21, [2, 119]),
        o($V21, [2, 120]),
        o($V21, [2, 121]),
        o($V21, [2, 122]),
        o($V21, [2, 123]),
        o($V21, [2, 124]),
        o($V21, [2, 125]),
        o($V21, [2, 126]),
        o($V21, [2, 127]),
        o($V21, [2, 128]),
        o($V21, [2, 129]),
        o($V21, [2, 130]),
        o($V21, [2, 131]),
        o($V21, [2, 132]),
        o($V21, [2, 133]),
        o($V21, [2, 134]),
        o($V21, [2, 135]),
        o($V21, [2, 136]),
        o($V21, [2, 137]),
        o($V21, [2, 138]),
        o($V21, [2, 139]),
        o($V21, [2, 140]),
        o($V21, [2, 141]),
        o($V21, [2, 142]),
        o($V21, [2, 143]),
        o($V21, [2, 144]),
        o($V21, [2, 145]),
        o($V21, [2, 146]),
        { 5: [2, 10], 101: $V01 },
        { 5: [2, 11] },
        { 14: $VS, 16: 158, 35: $VT, 38: $VU, 77: $VV, 78: $VW, 101: $V01 },
        { 14: $VS, 16: 159, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 5: [2, 18] },
        o($V31, [2, 92]),
        o($V31, [2, 93]),
        o($V31, [2, 94]),
        o($V31, [2, 95]),
        o($V31, [2, 96]),
        { 5: [2, 21] },
        o($V41, [2, 75]),
        o($V41, [2, 76]),
        { 5: [2, 22] },
        { 5: [2, 23] },
        { 5: [2, 24] },
        { 5: [2, 26] },
        { 5: [2, 27] },
        { 5: [2, 28], 31: [1, 160] },
        { 5: [2, 30] },
        { 36: [1, 161] },
        { 5: [2, 32] },
        { 5: [2, 36] },
        { 5: [2, 37] },
        { 5: [2, 39] },
        { 5: [2, 41] },
        { 5: [2, 42], 73: 162, 74: $VZ },
        o($V51, [2, 86]),
        { 35: [1, 163] },
        { 5: [2, 43], 73: 162, 74: $VZ },
        { 5: [2, 45] },
        { 14: [1, 164] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 165,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR,
          101: $V01
        },
        { 5: [2, 53] },
        { 5: [2, 62] },
        { 5: [2, 63] },
        { 5: [2, 64] },
        { 5: [2, 164] },
        { 5: [2, 66], 63: 166, 67: 146, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        { 5: [2, 67] },
        { 5: [2, 77], 67: 167, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        o($V41, [2, 81]),
        o($V41, [2, 82], {
          80: 52,
          53: 168,
          75: 169,
          76: 170,
          79: 171,
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        }),
        { 71: [1, 172] },
        { 71: [1, 173] },
        { 5: [2, 69], 63: 174, 67: 146, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        {
          5: [2, 71],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 175,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 73],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 176,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        { 5: [2, 55], 57: [1, 177] },
        { 5: [2, 56], 29: [1, 178] },
        { 5: [2, 60], 35: [1, 179] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          35: [1, 181],
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 180,
          80: 52,
          81: 182,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 12] },
        { 5: [2, 13] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          32: 183,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 184,
          80: 52,
          81: 185,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 14: [1, 186] },
        o($V51, [2, 87]),
        o($V51, [2, 88]),
        {
          5: [2, 48],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 187,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 49],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 188,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          101: $V01
        },
        { 5: [2, 68] },
        { 5: [2, 78], 67: 189, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        o($V41, [2, 83], {
          80: 52,
          76: 170,
          79: 171,
          75: 190,
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        }),
        o($V31, [2, 89]),
        { 71: [1, 191], 101: [1, 192] },
        o($V61, [2, 156]),
        { 14: $VS, 16: 193, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 14: $VS, 16: 194, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 5: [2, 70] },
        {
          5: [2, 72],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 74],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        { 5: [2, 57] },
        { 5: [2, 58] },
        { 5: [2, 61] },
        o($V11, [2, 161]),
        o($V11, [2, 162]),
        o($V11, [2, 163]),
        { 5: [2, 29] },
        { 5: [2, 99] },
        { 5: [2, 100] },
        { 31: [1, 195] },
        {
          5: [2, 50],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 51],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        { 5: [2, 79], 67: 196, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        o($V31, [2, 90]),
        { 14: $VS, 16: 197, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          35: [1, 199],
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          79: 198,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        o($V41, [2, 84]),
        o($V31, [2, 85]),
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          32: 200,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 184,
          80: 52,
          81: 185,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 80] },
        o($V31, [2, 91]),
        o($V61, [2, 157]),
        o($V61, [2, 158]),
        { 5: [2, 31] }
      ],
      defaultActions: {
        3: [2, 2],
        4: [2, 3],
        7: [2, 8],
        8: [2, 9],
        11: [2, 14],
        12: [2, 15],
        13: [2, 16],
        15: [2, 19],
        16: [2, 20],
        25: [2, 33],
        26: [2, 34],
        29: [2, 40],
        34: [2, 46],
        35: [2, 47],
        37: [2, 52],
        46: [2, 1],
        47: [2, 5],
        107: [2, 11],
        110: [2, 18],
        116: [2, 21],
        119: [2, 22],
        120: [2, 23],
        121: [2, 24],
        122: [2, 26],
        123: [2, 27],
        125: [2, 30],
        127: [2, 32],
        128: [2, 36],
        129: [2, 37],
        130: [2, 39],
        131: [2, 41],
        136: [2, 45],
        139: [2, 53],
        140: [2, 62],
        141: [2, 63],
        142: [2, 64],
        143: [2, 164],
        145: [2, 67],
        158: [2, 12],
        159: [2, 13],
        166: [2, 68],
        174: [2, 70],
        177: [2, 57],
        178: [2, 58],
        179: [2, 61],
        183: [2, 29],
        184: [2, 99],
        185: [2, 100],
        196: [2, 80],
        200: [2, 31]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str);
        } else {
          var error = new Error(str);
          error.hash = hash;
          throw error
        }
      },
      parse: function parse(input) {
        var self = this,
          stack = [0],
          tstack = [],
          vstack = [null],
          lstack = [],
          table = this.table,
          yytext = '',
          yylineno = 0,
          yyleng = 0,
          TERROR = 2,
          EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
          }
        }
        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;
        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {};
        }
        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;
        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError;
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function lex() {
          var token;
          token = tstack.pop() || lexer.lex() || EOF;
          if (typeof token !== 'number') {
            if (token instanceof Array) {
              tstack = token;
              token = tstack.pop();
            }
            token = self.symbols_[token] || token;
          }
          return token
        }
        var symbol,
          state,
          action,
          r,
          yyval = {},
          p,
          len,
          newState,
          expected;
        while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
            action = this.defaultActions[state];
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex();
            }
            action = table[state] && table[state][symbol];
          }
          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = '';
            expected = [];
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'");
              }
            }
            if (lexer.showPosition) {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ':\n' +
                lexer.showPosition() +
                '\nExpecting ' +
                expected.join(', ') +
                ", got '" +
                (this.terminals_[symbol] || symbol) +
                "'";
            } else {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ': Unexpected ' +
                (symbol == EOF
                  ? 'end of input'
                  : "'" + (this.terminals_[symbol] || symbol) + "'");
            }
            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            });
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error(
              'Parse Error: multiple actions possible at state: ' +
                state +
                ', token: ' +
                symbol
            )
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol);
              vstack.push(lexer.yytext);
              lstack.push(lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
              }
              break
            case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              };
              if (ranges) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ];
              }
              r = this.performAction.apply(
                yyval,
                [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
                ].concat(args)
              );
              if (typeof r !== 'undefined') {
                return r
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break
            case 3:
              return true
          }
        }
        return true
      }
    };
    var lexer = (function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
          } else {
            throw new Error(str)
          }
        },
        setInput: function (input, yy) {
          this.yy = yy || this.yy || {};
          this._input = input;
          this._more = this._backtrack = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          };
          if (this.options.ranges) {
            this.yylloc.range = [0, 0];
          }
          this.offset = 0;
          return this
        },
        input: function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
          } else {
            this.yylloc.last_column++;
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++;
          }
          this._input = this._input.slice(1);
          return ch
        },
        unput: function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1);
          this.matched = this.matched.substr(0, this.matched.length - 1);
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
          }
          var r = this.yylloc.range;
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines
              ? (lines.length === oldLines.length
                  ? this.yylloc.first_column
                  : 0) +
                oldLines[oldLines.length - lines.length].length -
                lines[0].length
              : this.yylloc.first_column - len
          };
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          this.yyleng = this.yytext.length;
          return this
        },
        more: function () {
          this._more = true;
          return this
        },
        reject: function () {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno
              }
            )
          }
          return this
        },
        less: function (n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function () {
          var past = this.matched.substr(
            0,
            this.matched.length - this.match.length
          );
          return (
            (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, '')
          )
        },
        upcomingInput: function () {
          var next = this.match;
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length);
          }
          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(
            /\n/g,
            ''
          )
        },
        showPosition: function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join('-');
          return pre + this.upcomingInput() + '\n' + c + '^'
        },
        test_match: function (match, indexed_rule) {
          var token, lines, backup;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0);
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g);
          if (lines) {
            this.yylineno += lines.length;
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines
              ? lines[lines.length - 1].length -
                lines[lines.length - 1].match(/\r?\n?/)[0].length
              : this.yylloc.last_column + match[0].length
          };
          this.yytext += match[0];
          this.match += match[0];
          this.matches = match;
          this.yyleng = this.yytext.length;
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, (this.offset += this.yyleng)];
          }
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match[0].length);
          this.matched += match[0];
          token = this.performAction.call(
            this,
            this.yy,
            this,
            indexed_rule,
            this.conditionStack[this.conditionStack.length - 1]
          );
          if (this.done && this._input) {
            this.done = false;
          }
          if (token) {
            return token
          } else if (this._backtrack) {
            for (var k in backup) {
              this[k] = backup[k];
            }
            return false
          }
          return false
        },
        next: function () {
          if (this.done) {
            return this.EOF
          }
          if (!this._input) {
            this.done = true;
          }
          var token, match, tempMatch, index;
          if (!this._more) {
            this.yytext = '';
            this.match = '';
          }
          var rules = this._currentRules();
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i]);
                if (token !== false) {
                  return token
                } else if (this._backtrack) {
                  match = false;
                  continue
                } else {
                  return false
                }
              } else if (!this.options.flex) {
                break
              }
            }
          }
          if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
              return token
            }
            return false
          }
          if (this._input === '') {
            return this.EOF
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. Unrecognized text.\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno
              }
            )
          }
        },
        lex: function lex() {
          var r = this.next();
          if (r) {
            return r
          } else {
            return this.lex()
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1;
          if (n > 0) {
            return this.conditionStack.pop()
          } else {
            return this.conditionStack[0]
          }
        },
        _currentRules: function _currentRules() {
          if (
            this.conditionStack.length &&
            this.conditionStack[this.conditionStack.length - 1]
          ) {
            return this.conditions[
              this.conditionStack[this.conditionStack.length - 1]
            ].rules
          } else {
            return this.conditions['INITIAL'].rules
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0);
          if (n >= 0) {
            return this.conditionStack[n]
          } else {
            return 'INITIAL'
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length
        },
        options: { 'case-insensitive': true },
        performAction: function anonymous(
          yy,
          yy_,
          $avoiding_name_collisions,
          YY_START
        ) {
          switch ($avoiding_name_collisions) {
            case 0 :
              break
            case 1:
              return ''
            case 2:
              return ''
            case 3:
              return 42
            case 4:
              return 35
            case 5:
              return 77
            case 6:
              return 78
            case 7:
              return 78
            case 8:
              return 8
            case 9:
              return 6
            case 10:
              return 82
            case 11:
              return 7
            case 12:
              return 9
            case 13:
              return 59
            case 14:
              return 13
            case 15:
              return 15
            case 16:
              return 17
            case 17:
              return 18
            case 18:
              return 19
            case 19:
              return 20
            case 20:
              return 11
            case 21:
              return 62
            case 22:
              return 64
            case 23:
              return 23
            case 24:
              return 25
            case 25:
              return 26
            case 26:
              return 27
            case 27:
              return 30
            case 28:
              return 34
            case 29:
              return 33
            case 30:
              return 65
            case 31:
              return 66
            case 32:
              return 37
            case 33:
              return 41
            case 34:
              return 43
            case 35:
              return 52
            case 36:
              return 54
            case 37:
              return 55
            case 38:
              return 46
            case 39:
              return 48
            case 40:
              return 45
            case 41:
              return 49
            case 42:
              return 56
            case 43:
              return 58
            case 44:
              return 44
            case 45:
              return 83
            case 46:
              return 84
            case 47:
              return 85
            case 48:
              return 86
            case 49:
              return 87
            case 50:
              return 88
            case 51:
              return 89
            case 52:
              return 90
            case 53:
              return 91
            case 54:
              return 92
            case 55:
              return 93
            case 56:
              return 94
            case 57:
              return 95
            case 58:
              return 70
            case 59:
              return 70
            case 60:
              return 72
            case 61:
              return 72
            case 62:
              return 74
            case 63:
              return 74
            case 64:
              return 74
            case 65:
              return 31
            case 66:
              return 36
            case 67:
              return 96
            case 68:
              return 97
            case 69:
              return 98
            case 70:
              return 99
            case 71:
              yy_.yytext = yy.utils.unquoteString(yy_.yytext);
              return 14
            case 72:
              return 38
            case 73:
              return 5
            case 74:
              return 101
            case 75:
              return 103
            case 76:
              return '\\'
            case 77:
              return 28
            case 78:
              return 61
            case 79:
              return 29
            case 80:
              return 57
            case 81:
              return 71
          }
        },
        rules: [
          /^(?:\s+)/i,
          /^(?:[#].*)/i,
          /^(?:\/\/.*)/i,
          /^(?:([_A-Z0-9\/\+]+==))/i,
          /^(?:-?[0-9]+(\.[0-9]+)?\b)/i,
          /^(?:0[xX][0-9A-F]+\b)/i,
          /^(?:false\b)/i,
          /^(?:true\b)/i,
          /^(?:all\b)/i,
          /^(?:reset\b)/i,
          /^(?:clear\b)/i,
          /^(?:build\b)/i,
          /^(?:help\b)/i,
          /^(?:load\b)/i,
          /^(?:get\b)/i,
          /^(?:set\b)/i,
          /^(?:set_save\b)/i,
          /^(?:set_restore\b)/i,
          /^(?:set_reset\b)/i,
          /^(?:preset\b)/i,
          /^(?:motm\b)/i,
          /^(?:add\b)/i,
          /^(?:rep\b)/i,
          /^(?:remove\b)/i,
          /^(?:hide\b)/i,
          /^(?:show\b)/i,
          /^(?:list\b)/i,
          /^(?:select\b)/i,
          /^(?:within\b)/i,
          /^(?:selector\b)/i,
          /^(?:mode\b)/i,
          /^(?:color\b)/i,
          /^(?:material\b)/i,
          /^(?:view\b)/i,
          /^(?:unit\b)/i,
          /^(?:line\b)/i,
          /^(?:listobj\b)/i,
          /^(?:removeobj\b)/i,
          /^(?:rotate\b)/i,
          /^(?:translate\b)/i,
          /^(?:scale\b)/i,
          /^(?:center\b)/i,
          /^(?:url\b)/i,
          /^(?:screenshot\b)/i,
          /^(?:dssp\b)/i,
          /^(?:file_list\b)/i,
          /^(?:file_register\b)/i,
          /^(?:file_delete\b)/i,
          /^(?:preset_add\b)/i,
          /^(?:preset_delete\b)/i,
          /^(?:preset_update\b)/i,
          /^(?:preset_rename\b)/i,
          /^(?:preset_open\b)/i,
          /^(?:create_scenario\b)/i,
          /^(?:reset_scenario\b)/i,
          /^(?:delete_scenario\b)/i,
          /^(?:add_scenario_item\b)/i,
          /^(?:list_scenario\b)/i,
          /^(?:s\b)/i,
          /^(?:mt\b)/i,
          /^(?:m\b)/i,
          /^(?:c\b)/i,
          /^(?:x\b)/i,
          /^(?:y\b)/i,
          /^(?:z\b)/i,
          /^(?:as\b)/i,
          /^(?:of\b)/i,
          /^(?:pdb\b)/i,
          /^(?:delay\b)/i,
          /^(?:prst\b)/i,
          /^(?:desc\b)/i,
          /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,
          /^(?:([_A-Z0-9]+))/i,
          /^(?:$)/i,
          /^(?:\.)/i,
          /^(?:\/)/i,
          /^(?:\\)/i,
          /^(?:-e\b)/i,
          /^(?:-f\b)/i,
          /^(?:-s\b)/i,
          /^(?:-v\b)/i,
          /^(?:=)/i
        ],
        conditions: {
          INITIAL: {
            rules: [
              0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
              19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
              36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
              53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
              70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81
            ],
            inclusive: true
          }
        }
      };
      return lexer
    })();
    parser.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser()
  })();
  var MiewCLIParser = { parser: parser };

  var modeIdDesc = {
    $help: ['Rendering mode shortcut', '    BS - balls and sticks mode', '    LN - lines mode', '    LC - licorice mode', '    VW - van der waals mode', '    TR - trace mode', '    TU - tube mode', '    CA - cartoon mode', '    SA - isosurface mode', '    QS - quick surface mode', '    SE - solvent excluded mode', '    TX - text mode'],
    BS: {
      $help: ['   Balls and sticks', '      aromrad = <number> #aromatic radius', '      atom = <number>    #atom radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
    },
    CA: {
      $help: ['   Cartoon', '      arrow = <number>   #arrow size', '      depth = <number>   #depth of surface', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> #', '      width = <number>  #secondary width\n']
    },
    LN: {
      $help: ['   Lines', '      atom = <number>    #atom radius', '      chunkarom = <number>', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      offsarom = <number>\n']
    },
    LC: {
      $help: ['   Licorice', '      aromrad = <number> #aromatic radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
    },
    VW: {
      $help: ['   Van der Waals', '      nothing\n']
    },
    TR: {
      $help: ['   Trace', '      radius = <number>  #tube radius\n']
    },
    TU: {
      $help: ['   Tube', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> \n']
    },
    SA: {
      $help: ['   Surface', '      zClip = <bool> #clip z plane\n']
    },
    QS: {
      $help: ['   Quick surface', '      isoValue = <number>', '      scale = <number>', '      wireframe = <bool>', '      zClip = <bool> #clip z plane\n']
    },
    SE: {
      $help: ['   Solvent excluded surface', '      zClip = <bool> #clip z plane\n']
    },
    TX: {
      $help: ['   Text mode', '      template = <format string> string that can include "{{ id }}"', '          it will be replaced by value, id can be one of next:', '          serial, name, type, sequence, residue, chain, hetatm, water\n', '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', '      dx = <number> #offset along x', '      dy = <number> #offset along y', '      dz = <number> #offset along z', '      fg = <string> #text color modificator', '           could be keyword, named color or hex', '      fg = <string> #back color modificator', '           could be keyword, named color or hex', '      showBg = <bool> #if set show background', '           plate under text']
    }
  };
  var colorDesc = {
    $help: ['Coloring mode shortcut', '    EL - color by element', '    CH - color by chain', '    SQ - color by sequence', '    RT - color by residue type', '    SS - color by secondary structure', '    UN - uniform'],
    UN: {
      $help: ['Parameters of coloring modes customization', '   Uniform', '      color = <number|color> #RGB->HEX->dec\n'],
      color: {
        $help: Object.keys(palettes$1.get(settings$1.now.palette).namedColors).sort().join('\n')
      }
    }
  };
  var materialDesc = {
    $help: ['Material shortcut', '    DF - diffuse', '    TR - transparent', '    SF - soft plastic', '    PL - glossy plastic', '    ME - metal', '    GL - glass']
  };
  var addRepDesc = {
    $help: ['Short (packed) representation description as a set of variables', '    s=<EXPRESSION>', '        selector property', '    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]', '        render mode property', '    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]', '        color mode property', '    mt=<MATERIAL_ID>', '        material property'],
    s: {
      $help: 'Selection expression string as it is in menu->representations->selection'
    },
    m: modeIdDesc,
    c: colorDesc,
    mt: materialDesc
  };
  var setGetParameterDesc = {
    $help: ['Parameters of rendering modes customization: modes', 'Parameters of colorer customization: colorers', 'Autobuild: autobuild = (<number>|<bool>)'],
    modes: modeIdDesc,
    colorers: colorDesc
  };
  var help = {
    $help: ['help (<cmd name>| <path to property>)', 'You can get detailed information about command options', '   using "help cmd.opt.opt.[...]"\n', '   you can use one line comments', '   everything started from (#|//) will be skipped', '   Example: >build //some comment\n', 'List of available commands:'],
    reset: {
      $help: ['Reload current object, delete all representations', '    Nothing will work until load new object']
    },
    load: {
      $help: ['load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])', '    Load new pdb object from selected source'],
      PDBID: {
        $help: 'pdb id in remote molecule database'
      },
      URL: {
        $help: 'url to source file'
      },
      f: {
        $help: ['open file system dialog to fetch local file', 'optionally you can determine trajectory file', 'via URL for *.top model']
      }
    },
    clear: {
      $help: 'No args. Clear terminal'
    },
    add: {
      $help: ['add [<REP_NAME>] [<DESCRIPTION>]', '    Add new item to representation set with', '    default or <DESCRIPTION> params'],
      REP_NAME: {
        $help: 'Identifier string [_,a-z,A-Z,0-9] can not start from digit'
      },
      DESCRIPTION: addRepDesc
    },
    rep: {
      $help: ['rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]', '    set current representation by name or index', '    edit current representation by <DESCRIPTION>'],
      REP_NAME: {
        $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      },
      DESCRIPTION: addRepDesc
    },
    remove: {
      $help: ['remove (<REP_NAME>|<REP_INDEX>)', 'Remove representation by name or index'],
      REP_NAME: {
        $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      }
    },
    selector: {
      $help: ['selector <EXPRESSION>', '   set selector from EXPRESSION to current representation'],
      EXPRESSION: {
        $help: 'Selection expression string as it is in menu->representations->selection'
      }
    },
    mode: {
      $help: ['mode <MODE_ID> [<PARAMETER>=<VALUE>...]', '   set rendering mode and apply parameters to current representation'],
      MODE_ID: modeIdDesc
    },
    color: {
      $help: ['color <COLORER_ID> [<PARAMETER>=<VALUE>...]', '   set colorer and apply parameters to current representation'],
      COLORER_ID: colorDesc
    },
    material: {
      $help: ['material <MATERIAL_ID>', '   set material to current representation'],
      MATERIAL_ID: materialDesc
    },
    build: {
      $help: 'build help str',
      add: {
        $help: 'build.add',
        new: {
          $help: ['add.new', 'add.new new line 1', 'add.new new line 2', 'add.new new line 3']
        }
      },
      del: {
        $help: 'build.del'
      }
    },
    list: {
      $help: ['list [-e|-s|<REP_NAME>|<REP_INDEX>]', 'Print representations if no args print list of representations', '    -e expand list and show all representations', '    -s show all user-registered selectors', '    <REP_NAME>|<REP_INDEX> show only current representation']
    },
    hide: {
      $help: ['hide (<REP_NAME>|<REP_INDEX>)', 'Hide representation referenced in args']
    },
    show: {
      $help: ['show (<REP_NAME>|<REP_INDEX>)', 'Show representation referenced in args']
    },
    get: {
      $help: ['get <PARAMETER>', 'Print <PARAMETER> value', '    <PARAMETER> - path to option use get.PARAMETER to get more info'],
      PARAMETER: setGetParameterDesc
    },
    set: {
      $help: ['set <PARAMETER> <VALUE>', 'Set <PARAMETER> with <VALUE>', '    <PARAMETER> - path to option use set.PARAMETER to get more info'],
      PARAMETER: setGetParameterDesc
    },
    set_save: {
      $help: ['set_save', 'Save current settings to cookie']
    },
    set_restore: {
      $help: ['set_restore', 'Load and apply settings from cookie']
    },
    set_reset: {
      $help: ['set_reset', 'Reset current settings to the defaults']
    },
    preset: {
      $help: ['preset [<PRESET>]', 'Reset current representation or set preset to <PRESET>'],
      PRESET: {
        $help: ['default', 'wire', 'small', 'macro']
      }
    },
    unit: {
      $help: ['unit [<unit_id>]', 'Change current biological structure view. Zero <unit_id> value means asymmetric unit,', 'positive values set an assembly with corresponding number.', 'Being called with no parameters command prints current unit information.']
    },
    view: {
      $help: ['view [<ENCODED_VIEW>]', 'Get current encoded view or set if ENCODED_VIEW placed as argument'],
      ENCODED_VIEW: {
        $help: ['encoded view matrix string (binary code)']
      }
    },
    rotate: {
      $help: ['rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...', 'Rotate scene']
    },
    scale: {
      $help: ['scale <SCALE>', 'Scale scene']
    },
    select: {
      $help: ['select <SELECTOR_STRING> [as <SELECTOR_NAME>]', 'Select atoms using selector defined in SELECTOR_STRING', '    and if SELECTOR_NAME is defined register it in viewer', '    you can use it later as a complex selector']
    },
    within: {
      $help: ['within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>', 'Build within named selector', '    DISTANCE        <number>', '    SELECTOR_STRING <string(selection language)>', '    SELECTOR_NAME   <identifier>']
    },
    url: {
      $help: ['url [-s] [-v]', 'Report URL encoded scene', '    if -s set that include settings in the URL', '    if -v set that include view in the URL']
    },
    screenshot: {
      $help: ['screenshot [<WIDTH> [<HEIGHT>]]', 'Make a screenshot of the scene', '    WIDTH  <number> in pixels', '    HEIGHT <number> in pixels, equal to WIDTH by default']
    },
    line: {
      $help: ['line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]', 'Draw dashed line between two specified atoms']
    },
    removeobj: {
      $help: ['removeobj <id>', 'Remove scene object by its index. Indices could be obtained by <listobj> command']
    },
    listobj: {
      $help: ['listobj', 'Display the list of all existing scene objects']
    }
  };

  var selectors = Miew.chem.selectors,
      modes = Miew.modes,
      colorers = Miew.colorers,
      materials = Miew.materials,
      palettes = Miew.palettes,
      options = Miew.options,
      settings = Miew.settings;

  function None() {}

  var NULL = function () {
    var obj = new None();
    return function () {
      return obj;
    };
  }();

  var RepresentationMap = /*#__PURE__*/function () {
    function RepresentationMap() {
      _classCallCheck(this, RepresentationMap);

      this.representationMap = {};
      this.representationID = {};
    }

    _createClass(RepresentationMap, [{
      key: "get",
      value: function get(strId) {
        return this.representationMap[strId] || this.representationID[strId] || '<no name>';
      }
    }, {
      key: "add",
      value: function add(strId, index) {
        if (strId === -1) {
          return 'Can not create representation: there is no data';
        }

        if (index !== undefined) {
          if (!this.representationMap.hasOwnProperty(strId)) {
            this.representationMap[strId.toString()] = index;
            this.representationID[index] = strId.toString();
          } else {
            return 'This name has already existed, registered without name';
          }
        }

        return "Representation ".concat(strId, " successfully added");
      }
    }, {
      key: "remove",
      value: function remove(index) {
        if (index && this.representationID.hasOwnProperty(index)) {
          delete this.representationMap[this.representationID[index]];
          delete this.representationID[index];
        }

        var sortedKeys = Object.keys(this.representationID).sort();

        for (var i in sortedKeys) {
          if (sortedKeys.hasOwnProperty(i)) {
            var id = sortedKeys[i];

            if (id > index) {
              this.representationID[id - 1] = this.representationID[id];
              this.representationMap[this.representationID[id]] -= 1;
              delete this.representationID[id];
            }
          }
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        this.representationMap = {};
        this.representationID = {};
      }
    }]);

    return RepresentationMap;
  }();

  var representationsStorage = new RepresentationMap();

  function keyRemap(key) {
    var keys = {
      s: 'selector',
      m: 'mode',
      c: 'colorer',
      mt: 'material',
      mode: 'modes',
      color: 'colorers',
      colorer: 'colorers',
      select: 'selector',
      material: 'materials',
      selector: 'selector'
    };
    var ans = keys[key];
    return ans === undefined ? key : ans;
  }

  var CLIUtils = /*#__PURE__*/function () {
    function CLIUtils() {
      _classCallCheck(this, CLIUtils);
    }

    _createClass(CLIUtils, [{
      key: "list",
      value: function list(miew, repMap, key) {
        var ret = '';

        if (miew && repMap !== undefined) {
          if (key === undefined || key === '-e') {
            var count = miew.repCount();

            for (var i = 0; i < count; i++) {
              ret += this.listRep(miew, repMap, i, key);
            }
          }
        }

        return ret;
      }
    }, {
      key: "listRep",
      value: function listRep(miew, repMap, repIndex, key) {
        var ret = '';
        var rep = miew.repGet(repIndex);

        if (!rep) {
          logger.warn("Rep ".concat(repIndex, " does not exist!"));
          return ret;
        }

        var index = repIndex;
        var repName = repMap.get(index);
        var mode = rep.mode,
            colorer = rep.colorer;
        var selectionStr = rep.selectorString;
        var material = rep.materialPreset;
        ret += "#".concat(index, " : ").concat(mode.name).concat(repName === '<no name>' ? '' : ", ".concat(repName), "\n");

        if (key !== undefined) {
          ret += "    selection : \"".concat(selectionStr, "\"\n");
          ret += "    mode      : (".concat(mode.id, "), ").concat(mode.name, "\n");
          ret += "    colorer   : (".concat(colorer.id, "), ").concat(colorer.name, "\n");
          ret += "    material  : (".concat(material.id, "), ").concat(material.name, "\n");
        }

        return ret;
      }
    }, {
      key: "listSelector",
      value: function listSelector(miew, context) {
        var ret = '';

        for (var k in context) {
          if (context.hasOwnProperty(k)) {
            ret += "".concat(k, " : \"").concat(context[k], "\"\n");
          }
        }

        return ret;
      }
    }, {
      key: "listObjs",
      value: function listObjs(miew) {
        var objs = miew._objects;

        if (!objs || !Array.isArray(objs) || objs.length === 0) {
          return 'There are no objects on the scene';
        }

        var strList = [];

        for (var i = 0, n = objs.length; i < n; ++i) {
          strList[i] = "".concat(i, ": ").concat(objs[i].toString());
        }

        return strList.join('\n');
      }
    }, {
      key: "joinHelpStr",
      value: function joinHelpStr(helpData) {
        if (helpData instanceof Array) {
          return helpData.join('\n');
        }

        return helpData;
      }
    }, {
      key: "help",
      value: function help$1(path) {
        if (___default["default"].isUndefined(path)) {
          return "".concat(this.joinHelpStr(help.$help), "\n").concat(___default["default"].slice(___default["default"].sortBy(___default["default"].keys(help)), 1).join(', '), "\n");
        }

        var helpItem = ___default["default"].get(help, path);

        return ___default["default"].isUndefined(helpItem) ? this.help() : "".concat(this.joinHelpStr(helpItem.$help), "\n");
      }
    }, {
      key: "load",
      value: function load(miew, arg) {
        if (miew === undefined || arg === undefined || arg === '-f') {
          return;
        }

        miew.awaitWhileCMDisInProcess();

        var finish = function finish() {
          return miew.finishAwaitingCMDInProcess();
        };

        miew.load(arg).then(finish, finish);
      }
    }, {
      key: "checkArg",
      value: function checkArg(key, arg, modificate) {
        if (key !== undefined && arg !== undefined) {
          if (keyRemap(key) === 'selector') {
            var res = selectors.parse(arg);

            if (res.error !== undefined) {
              var selExc = {
                message: res.error
              };
              throw selExc;
            }

            if (modificate !== undefined && modificate) {
              return res.selector;
            }

            return arg;
          }

          var modificators = {
            colorers: colorers,
            modes: modes,
            materials: materials
          };
          var modificator = key;
          var temp;

          while (modificator !== temp) {
            temp = modificator;
            modificator = keyRemap(temp);
          }

          if (modificators[modificator].get(arg) === undefined) {
            var exc = {
              message: "".concat(arg, " is not existed in ").concat(modificator)
            };
            throw exc;
          }

          return arg;
        }

        return NULL;
      }
    }, {
      key: "propagateProp",
      value: function propagateProp(path, arg) {
        if (path !== undefined) {
          var argExc = {};

          var adapter = options.adapters[_typeof(___default["default"].get(settings.defaults, path))];

          if (adapter === undefined) {
            var pathExc = {
              message: "".concat(path, " is not existed")
            };
            throw pathExc;
          }

          if ((path.endsWith('.color') || path.endsWith('.baseColor') || path.endsWith('.EL.carbon')) && typeof arg !== 'number') {
            arg = palettes.get(settings.now.palette).getNamedColor(arg);
          }

          if (path.endsWith('.fg') || path.endsWith('.bg')) {
            if (typeof arg !== 'number') {
              var val = palettes.get(settings.now.palette).getNamedColor(arg, true);

              if (val !== undefined) {
                arg = "0x".concat(val.toString(16));
              }
            } else {
              arg = "0x".concat(arg.toString(16));
            }
          }

          if (path.endsWith('.template')) {
            arg = arg.replace(/\\n/g, '\n');
          }

          if (arg !== undefined && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
            argExc = {
              message: "".concat(path, " must be a \"").concat(_typeof(___default["default"].get(settings.defaults, path)), "\"")
            };
            throw argExc;
          }
        }

        return arg;
      }
    }, {
      key: "unquoteString",
      value: function unquoteString(value) {
        return utils.unquoteString(value);
      }
    }]);

    return CLIUtils;
  }();

  var utilFunctions = new CLIUtils();

  function CreateObjectPair(a, b) {
    var obj = {};
    obj[a] = b;
    return obj;
  }

  function ArgList(arg) {
    if (arg instanceof this.constructor) {
      return arg;
    }

    if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }

  ArgList.prototype.append = function (value) {
    var values = this._values;
    values[values.length] = value;
    return this;
  };

  ArgList.prototype.remove = function (value) {
    var values = this._values;
    var index = values.indexOf(value);

    if (index >= 0) {
      values.splice(index, 1);
    }

    return this;
  };

  ArgList.prototype.toJSO = function (cliUtils, cmd, arg) {
    var res = {};
    var list = this._values;

    for (var i = 0, n = list.length; i < n; ++i) {
      ___default["default"].set(res, list[i].id, cliUtils.propagateProp("".concat(keyRemap(cmd), ".").concat(arg, ".").concat(list[i].id), list[i].val));
    }

    return res;
  };

  function Arg(_id, _val) {
    this.id = _id;
    this.val = _val;
  }

  var cliutils = Object.create({});
  cliutils.Arg = Arg;
  cliutils.ArgList = ArgList;
  cliutils.miew = null;
  cliutils.echo = null;
  cliutils.representations = representationsStorage;
  cliutils.utils = utilFunctions;
  cliutils._ = ___default["default"];
  cliutils.CreateObjectPair = CreateObjectPair;
  cliutils.keyRemap = keyRemap;
  cliutils.Context = selectors.Context;
  cliutils.ClearContext = selectors.ClearContext;
  cliutils.NULL = NULL;

  cliutils.notimplemented = function () {
    return this.NULL;
  };

  Miew.prototype.script = function (script, _printCallback, _errorCallback) {
    MiewCLIParser.parser.yy.miew = this;
    MiewCLIParser.parser.yy.echo = _printCallback;
    MiewCLIParser.parser.yy.error = _errorCallback;

    if (this.cmdQueue === undefined) {
      this.cmdQueue = [];
    }

    if (this.commandInAction === undefined) {
      this.commandInAction = false;
    }

    this.cmdQueue = this.cmdQueue.concat(script.split('\n'));
  };

  Miew.prototype.awaitWhileCMDisInProcess = function () {
    this.commandInAction = true;
  };

  Miew.prototype.finishAwaitingCMDInProcess = function () {
    this.commandInAction = false;
  };

  Miew.prototype.isScriptingCommandAvailable = function () {
    return this.commandInAction !== undefined && !this.commandInAction && this.cmdQueue !== undefined && this.cmdQueue.length > 0;
  };

  Miew.prototype.callNextCmd = function () {
    if (this.isScriptingCommandAvailable()) {
      var cmd = this.cmdQueue.shift();
      var res = {};
      res.success = false;

      try {
        MiewCLIParser.parser.parse(cmd);
        res.success = true;
      } catch (e) {
        res.error = e.message;
        MiewCLIParser.parser.yy.error(res.error);
        this.finishAwaitingCMDInProcess();
      }

      return res;
    }

    return '';
  };

  MiewCLIParser.parser.yy = cliutils;
  MiewCLIParser.parser.yy.parseError = MiewCLIParser.parser.parseError;

  return Miew;

}));


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"lodash":2,"three":3}]},{},[1]);
