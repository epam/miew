/** Miew - 3D Molecular Viewer v0.7.20 Copyright (c) 2015-2018 EPAM Systems, Inc. */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Miew = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var lodash = createCommonjsModule(function (module, exports) {
	(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '4.17.10';

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;

	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;

	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;

	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;

	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;

	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);

	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;

	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;

	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';

	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');

	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');

	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');

	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();

	  /** Detect free variable `exports`. */
	  var freeExports = exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      // Use `util.types` for Node.js 10+.
	      var types = freeModule && freeModule.require && freeModule.require('util').types;

	      if (types) {
	        return types;
	      }

	      // Legacy `process.binding('util')` for Node.js < 10.
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;

	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }

	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }

	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');

	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }

	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }

	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }

	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }

	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }

	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;

	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }

	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }

	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;

	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;

	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;

	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }

	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }

	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }

	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];

	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }

	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);

	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * Gets the value at `key`, unless `key` is "__proto__".
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function safeGet(object, key) {
	    return key == '__proto__'
	      ? undefined
	      : object[key];
	  }

	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }

	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }

	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }

	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }

	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }

	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }

	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];

	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());

	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;

	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());

	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;

	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);

	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());

	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }

	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	    }

	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }

	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }

	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      return index < 0 ? undefined : data[index][1];
	    }

	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }

	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }

	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }

	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }

	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }

	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;

	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }

	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;

	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }

	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }

	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }

	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }

	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);

	      this.size = data.size;
	      return result;
	    }

	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }

	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }

	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }

	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;

	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }

	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }

	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }

	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }

	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }

	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;

	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }

	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;

	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;

	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);

	      if (isSet(value)) {
	        value.forEach(function(subValue) {
	          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	        });

	        return result;
	      }

	      if (isMap(value)) {
	        value.forEach(function(subValue, key) {
	          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	        });

	        return result;
	      }

	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);

	      var props = isArr ? undefined : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }

	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];

	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;

	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);

	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;

	      predicate || (predicate = isFlattenable);
	      result || (result = []);

	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }

	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);

	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }

	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }

	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }

	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }

	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }

	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }

	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];

	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];

	      var index = -1,
	          seen = caches[0];

	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined : apply(func, object, args);
	    }

	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }

	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }

	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }

	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);

	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;

	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;

	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }

	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }

	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }

	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }

	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }

	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }

	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];

	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }

	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	            : undefined;

	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = safeGet(object, key),
	          srcValue = safeGet(source, key),
	          stacked = stack.get(srcValue);

	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;

	      var isCommon = newValue === undefined;

	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }

	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }

	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }

	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};

	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);

	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;

	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;

	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;

	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }

	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);

	      return result;
	    }

	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }

	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }

	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }

	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;

	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };

	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);

	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }

	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;

	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }

	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }

	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}

	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }

	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);

	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;

	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }

	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};

	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }

	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }

	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }

	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }

	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;

	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }

	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };

	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	      buffer.copy(result);
	      return result;
	    }

	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }

	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }

	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }

	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }

	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }

	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);

	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);

	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }

	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;

	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;

	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];

	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;

	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }

	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }

	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }

	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};

	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }

	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;

	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;

	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;

	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);

	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;

	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);

	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);

	        return chr[methodName]() + trailing;
	      };
	    }

	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);

	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;

	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }

	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }

	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);

	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }

	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;

	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];

	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }

	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));

	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };

	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;

	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);

	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];

	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);

	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined : value;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	      stack.set(array, other);
	      stack.set(other, array);

	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;

	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;

	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');

	        case mapTag:
	          var convert = mapToArray;

	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);

	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;

	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;

	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);

	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }

	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }

	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }

	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }

	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }

	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;

	      while (length--) {
	        var key = result[length],
	            value = object[key];

	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }

	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];

	      try {
	        value[symToStringTag] = undefined;
	      } catch (e) {}

	      var result = nativeObjectToString.call(value);
	      {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };

	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };

	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;

	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';

	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }

	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          result = false;

	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = new array.constructor(length);

	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case dataViewTag:
	          return cloneDataView(object, isDeep);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);

	        case mapTag:
	          return new Ctor;

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          return cloneRegExp(object);

	        case setTag:
	          return new Ctor;

	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }

	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }

	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      var type = typeof value;
	      length = length == null ? MAX_SAFE_INTEGER : length;

	      return !!length &&
	        (type == 'number' ||
	          (type != 'symbol' && reIsUint.test(value))) &&
	            (value > -1 && value % 1 == 0 && value < length);
	    }

	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }

	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }

	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;

	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	      return value === proto;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }

	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });

	      var cache = result.cache;
	      return result;
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }

	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);

	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }

	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);

	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };

	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);

	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }

	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;

	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }

	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;

	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];

	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }

	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (string.charCodeAt(0) === 46 /* . */) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, subString) {
	        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });

	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }

	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;

	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }

	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }

	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }

	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }

	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }

	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};

	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }

	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });

	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }

	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }

	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);

	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }

	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);

	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));

	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }

	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }

	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }

	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }

	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }

	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });

	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);

	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }

	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;

	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }

	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };

	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });

	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];

	      return { 'done': done, 'value': value };
	    }

	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }

	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }

	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);

	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }

	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });

	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });

	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }

	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }

	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;

	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }

	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }

	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            timeWaiting = wait - timeSinceLastCall;

	        return maxing
	          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
	          : timeWaiting;
	      }

	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;

	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }

	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }

	      function trailingEdge(time) {
	        timerId = undefined;

	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }

	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }

	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }

	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);

	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;

	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }

	    // Expose `MapCache`.
	    memoize.Cache = MapCache;

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);

	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });

	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	    });

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);

	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }

	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }

	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }

	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }

	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });

	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;

	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }

	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }

	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }

	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }

	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }

	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }

	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

	      return func(value);
	    }

	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }

	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;

	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }

	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }

	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }

	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }

	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });

	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });

	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });

	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });

	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);

	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }

	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(object, sources) {
	      object = Object(object);

	      var index = -1;
	      var length = sources.length;
	      var guard = length > 2 ? sources[2] : undefined;

	      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	        length = 1;
	      }

	      while (++index < length) {
	        var source = sources[index];
	        var props = keysIn(source);
	        var propsIndex = -1;
	        var propsLength = props.length;

	        while (++propsIndex < propsLength) {
	          var key = props[propsIndex];
	          var value = object[key];

	          if (value === undefined ||
	              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	            object[key] = source[key];
	          }
	        }
	      }

	      return object;
	    });

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, customDefaultsMerge);
	      return apply(mergeWith, undefined, args);
	    });

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }

	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }

	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }

	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      result[value] = key;
	    }, constant(identity));

	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (value != null &&
	          typeof value.toString != 'function') {
	        value = nativeObjectToString.call(value);
	      }

	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);

	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });

	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });

	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }

	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });

	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }

	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length;

	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }

	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }

	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }

	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);

	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }

	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }

	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }

	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }

	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }

	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });

	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }

	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);

	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }

	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);

	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }

	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }

	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);

	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);

	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }

	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

	      return castSlice(strSymbols, start, end).join('');
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	      return castSlice(strSymbols, 0, end).join('');
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));

	      return castSlice(strSymbols, start).join('');
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);

	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);

	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;

	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });

	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;

	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });

	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();

	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });

	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }

	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }

	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);

	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);

	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);

	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });

	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }

	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }

	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);

	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);

	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);

	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();

	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);

	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }

	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }

	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }

	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }

	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }

	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);

	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;

	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }

	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);

	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);

	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }

	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }

	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }

	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }

	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }

	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }

	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);

	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);

	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }

	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }

	    /*------------------------------------------------------------------------*/

	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;

	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;

	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();

	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };

	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };

	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });

	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;

	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });

	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });

	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];

	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;

	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(commonjsGlobal));
	});

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		( function () {

			Object.assign = function ( target ) {

				if ( target === undefined || target === null ) {

					throw new TypeError( 'Cannot convert undefined or null to object' );

				}

				var output = Object( target );

				for ( var index = 1; index < arguments.length; index ++ ) {

					var source = arguments[ index ];

					if ( source !== undefined && source !== null ) {

						for ( var nextKey in source ) {

							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

								output[ nextKey ] = source[ nextKey ];

							}

						}

					}

				}

				return output;

			};

		} )();

	}

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	var REVISION = '94';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _Math = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: ( function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var lut = [];

			for ( var i = 0; i < 256; i ++ ) {

				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

			}

			return function generateUUID() {

				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];

				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();

			};

		} )(),

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * _Math.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * _Math.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector2();
			var max = new Vector2();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal );
				max.set( maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( this.y, this.x );

			if ( angle < 0 ) angle += 2 * Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function () {

			var v1 = new Vector3();

			return function extractRotation( m ) {

				// this method does not support reflection matrices

				var te = this.elements;
				var me = m.elements;

				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;

				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;

				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;

				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;

				return this;

			};

		}(),

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function () {

			var zero = new Vector3( 0, 0, 0 );
			var one = new Vector3( 1, 1, 1 );

			return function makeRotationFromQuaternion( q ) {

				return this.compose( zero, q, one );

			};

		}(),

		lookAt: function () {

			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();

			return function lookAt( eye, target, up ) {

				var te = this.elements;

				z.subVectors( eye, target );

				if ( z.lengthSq() === 0 ) {

					// eye and target are in the same position

					z.z = 1;

				}

				z.normalize();
				x.crossVectors( up, z );

				if ( x.lengthSq() === 0 ) {

					// up and z are parallel

					if ( Math.abs( up.z ) === 1 ) {

						z.x += 0.0001;

					} else {

						z.z += 0.0001;

					}

					z.normalize();
					x.crossVectors( up, z );

				}

				x.normalize();
				y.crossVectors( z, x );

				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

				return this;

			};

		}(),

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix4( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( v ) {

			var te = this.elements;

			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

		        te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		        te[ 1 ] = ( xy + wz ) * sx;
		        te[ 2 ] = ( xz - wy ) * sx;
		        te[ 3 ] = 0;

		        te[ 4 ] = ( xy - wz ) * sy;
		        te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		        te[ 6 ] = ( yz + wx ) * sy;
		        te[ 7 ] = 0;

		        te[ 8 ] = ( xz + wy ) * sz;
		        te[ 9 ] = ( yz - wx ) * sz;
		        te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		        te[ 11 ] = 0;

		        te[ 12 ] = position.x;
		        te[ 13 ] = position.y;
		        te[ 14 ] = position.z;
		        te[ 15 ] = 1;

		        return this;

		},

		decompose: function () {

			var vector = new Vector3();
			var matrix = new Matrix4();

			return function decompose( position, quaternion, scale ) {

				var te = this.elements;

				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;

				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];

				// scale the rotation part
				matrix.copy( this );

				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;

				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;

				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;

				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;

				quaternion.setFromRotationMatrix( matrix );

				scale.x = sx;
				scale.y = sy;
				scale.z = sz;

				return this;

			};

		}(),

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this.onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this.onChangeCallback();

			return this;

		},

		setFromUnitVectors: function () {

			// assumes direction vectors vFrom and vTo are normalized

			var v1 = new Vector3();
			var r;

			var EPS = 0.000001;

			return function setFromUnitVectors( vFrom, vTo ) {

				if ( v1 === undefined ) v1 = new Vector3();

				r = vFrom.dot( vTo ) + 1;

				if ( r < EPS ) {

					r = 0;

					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

						v1.set( - vFrom.y, vFrom.x, 0 );

					} else {

						v1.set( 0, - vFrom.z, vFrom.y );

					}

				} else {

					v1.crossVectors( vFrom, vTo );

				}

				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;

				return this.normalize();

			};

		}(),

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this.onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this.onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this.onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				return this.normalize();

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this.onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function () {

			var quaternion = new Quaternion();

			return function applyEuler( euler ) {

				if ( ! ( euler && euler.isEuler ) ) {

					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

				}

				return this.applyQuaternion( quaternion.setFromEuler( euler ) );

			};

		}(),

		applyAxisAngle: function () {

			var quaternion = new Quaternion();

			return function applyAxisAngle( axis, angle ) {

				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			};

		}(),

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function () {

			var matrix = new Matrix4();

			return function project( camera ) {

				matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		unproject: function () {

			var matrix = new Matrix4();

			return function unproject( camera ) {

				matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
				return this.applyMatrix4( matrix );

			};

		}(),

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function () {

			var min = new Vector3();
			var max = new Vector3();

			return function clampScalar( minVal, maxVal ) {

				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( vector ) {

			var scalar = vector.dot( this ) / vector.lengthSq();

			return this.copy( vector ).multiplyScalar( scalar );

		},

		projectOnPlane: function () {

			var v1 = new Vector3();

			return function projectOnPlane( planeNormal ) {

				v1.copy( this ).projectOnVector( planeNormal );

				return this.sub( v1 );

			};

		}(),

		reflect: function () {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			var v1 = new Vector3();

			return function reflect( normal ) {

				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

			};

		}(),

		angleTo: function ( v ) {

			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

			// clamp, to handle numerical problems

			return Math.acos( _Math.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			var sinPhiRadius = Math.sin( s.phi ) * s.radius;

			this.x = sinPhiRadius * Math.sin( s.theta );
			this.y = Math.cos( s.phi ) * s.radius;
			this.z = sinPhiRadius * Math.cos( s.theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			this.x = c.radius * Math.sin( c.theta );
			this.y = c.y;
			this.z = c.radius * Math.cos( c.theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		applyToBufferAttribute: function () {

			var v1 = new Vector3();

			return function applyToBufferAttribute( attribute ) {

				for ( var i = 0, l = attribute.count; i < l; i ++ ) {

					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );

					v1.applyMatrix3( this );

					attribute.setXYZ( i, v1.x, v1.y, v1.z );

				}

				return attribute;

			};

		}(),

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		updateMatrix: function () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			function getDataURL( image ) {

				var canvas;

				if ( image instanceof HTMLCanvasElement ) {

					canvas = image;

				} else {

					canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = image.width;
					canvas.height = image.height;

					var context = canvas.getContext( '2d' );

					if ( image instanceof ImageData ) {

						context.putImageData( image, 0, 0 );

					} else {

						context.drawImage( image, 0, 0, image.width, image.height );

					}

				}

				if ( canvas.width > 2048 || canvas.height > 2048 ) {

					return canvas.toDataURL( 'image/jpeg', 0.6 );

				} else {

					return canvas.toDataURL( 'image/png' );

				}

			}

			var output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = _Math.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					var url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( var i = 0, l = image.length; i < l; i ++ ) {

							url.push( getDataURL( image[ i ] ) );

						}

					} else {

						// process single image

						url = getDataURL( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function () {

			var min, max;

			return function clampScalar( minVal, maxVal ) {

				if ( min === undefined ) {

					min = new Vector4();
					max = new Vector4();

				}

				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );

				return this.clamp( min, max );

			};

		}(),

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : true;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com
	 */

	function WebGLRenderTargetCube( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;

	}

	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data, width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}

	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector3();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function () {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			var scope, i, l;

			var v1 = new Vector3();

			function traverse( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			}

			return function expandByObject( object ) {

				scope = this;

				object.updateMatrixWorld( true );

				object.traverse( traverse );

				return this;

			};

		}(),

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: ( function () {

			var closestPoint = new Vector3();

			return function intersectsSphere( sphere ) {

				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );

				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

			};

		} )(),

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= plane.constant && max >= plane.constant );

		},

		intersectsTriangle: ( function () {

			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();

			var testAxis = new Vector3();

			var center = new Vector3();
			var extents = new Vector3();

			var triangleNormal = new Vector3();

			function satForAxes( axes ) {

				var i, j;

				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;

					}

				}

				return true;

			}

			return function intersectsTriangle( triangle ) {

				if ( this.isEmpty() ) {

					return false;

				}

				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );

				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );

				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );

				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {

					return false;

				}

				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );

			};

		} )(),

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector3();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		getBoundingSphere: function () {

			var v1 = new Vector3();

			return function getBoundingSphere( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' );
					target = new Sphere();

				}

				this.getCenter( target.center );

				target.radius = this.getSize( v1 ).length() * 0.5;

				return target;

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function ( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty( ) ) return this;

			var m = matrix.elements;

			var xax = m[ 0 ] * this.min.x, xay = m[ 1 ] * this.min.x, xaz = m[ 2 ] * this.min.x;
			var xbx = m[ 0 ] * this.max.x, xby = m[ 1 ] * this.max.x, xbz = m[ 2 ] * this.max.x;
			var yax = m[ 4 ] * this.min.y, yay = m[ 5 ] * this.min.y, yaz = m[ 6 ] * this.min.y;
			var ybx = m[ 4 ] * this.max.y, yby = m[ 5 ] * this.max.y, ybz = m[ 6 ] * this.max.y;
			var zax = m[ 8 ] * this.min.z, zay = m[ 9 ] * this.min.z, zaz = m[ 10 ] * this.min.z;
			var zbx = m[ 8 ] * this.max.z, zby = m[ 9 ] * this.max.z, zbz = m[ 10 ] * this.max.z;

			this.min.x = Math.min( xax, xbx ) + Math.min( yax, ybx ) + Math.min( zax, zbx ) + m[ 12 ];
			this.min.y = Math.min( xay, xby ) + Math.min( yay, yby ) + Math.min( zay, zby ) + m[ 13 ];
			this.min.z = Math.min( xaz, xbz ) + Math.min( yaz, ybz ) + Math.min( zaz, zbz ) + m[ 14 ];
			this.max.x = Math.max( xax, xbx ) + Math.max( yax, ybx ) + Math.max( zax, zbx ) + m[ 12 ];
			this.max.y = Math.max( xay, xby ) + Math.max( yay, yby ) + Math.max( zay, zby ) + m[ 13 ];
			this.max.z = Math.max( xaz, xbz ) + Math.max( yaz, ybz ) + Math.max( zaz, zbz ) + m[ 14 ];

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function () {

			var box = new Box3();

			return function setFromPoints( points, optionalCenter ) {

				var center = this.center;

				if ( optionalCenter !== undefined ) {

					center.copy( optionalCenter );

				} else {

					box.setFromPoints( points ).getCenter( center );

				}

				var maxRadiusSq = 0;

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

				}

				this.radius = Math.sqrt( maxRadiusSq );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, target ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		},

		getBoundingBox: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function setFromCoplanarPoints( a, b, c ) {

				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

				this.setFromNormalAndCoplanarPoint( normal, a );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function () {

			var v1 = new Vector3();

			return function intersectLine( line, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();

				}

				var direction = line.delta( v1 );

				var denominator = this.normal.dot( direction );

				if ( denominator === 0 ) {

					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {

						return target.copy( line.start );

					}

					// Unsure if this is the correct method to handle this case.
					return undefined;

				}

				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

				if ( t < 0 || t > 1 ) {

					return undefined;

				}

				return target.copy( direction ).multiplyScalar( t ).add( line.start );

			};

		}(),

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function () {

			var v1 = new Vector3();
			var m1 = new Matrix3();

			return function applyMatrix4( matrix, optionalNormalMatrix ) {

				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );

				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

				this.constant = - referencePoint.dot( normal );

				return this;

			};

		}(),

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function () {

			var sphere = new Sphere();

			return function intersectsObject( object ) {

				var geometry = object.geometry;

				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSprite: function () {

			var sphere = new Sphere();

			return function intersectsSprite( sprite ) {

				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );

				return this.intersectsSphere( sphere );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function () {

			var p1 = new Vector3(),
				p2 = new Vector3();

			return function intersectsBox( box ) {

				var planes = this.planes;

				for ( var i = 0; i < 6; i ++ ) {

					var plane = planes[ i ];

					p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
					p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
					p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
					p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

					var d1 = plane.distanceToPoint( p1 );
					var d2 = plane.distanceToPoint( p2 );

					// if both outside plane, no intersection

					if ( d1 < 0 && d2 < 0 ) {

						return false;

					}

				}

				return true;

			};

		}(),

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

	var begin_vertex = "\nvec3 transformed = vec3( position );\n";

	var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

	var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n";

	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n";

	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n";

	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

	var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";

	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

	var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";

	var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";

	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";

	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

	var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n";

	var lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n";

	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n";

	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

	var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n";

	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n";

	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n";

	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n";

	var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n";

	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n";

	var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n";

	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n";

	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n";

	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";

	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";

	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n";

	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n";

	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n";

	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

	var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n";

	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n";

	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n";

	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

	var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_pars_maps>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";

	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";

	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n";

	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n";

	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_pars_maps: lights_pars_maps,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert
	};

	/**
	 * Uniform Utilities
	 */

	var UniformsUtils = {

		merge: function ( uniforms ) {

			var merged = {};

			for ( var u = 0; u < uniforms.length; u ++ ) {

				var tmp = this.clone( uniforms[ u ] );

				for ( var p in tmp ) {

					merged[ p ] = tmp[ p ];

				}

			}

			return merged;

		},

		clone: function ( uniforms_src ) {

			var uniforms_dst = {};

			for ( var u in uniforms_src ) {

				uniforms_dst[ u ] = {};

				for ( var p in uniforms_src[ u ] ) {

					var parameter_src = uniforms_src[ u ][ p ];

					if ( parameter_src && ( parameter_src.isColor ||
						parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
						parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
						parameter_src.isTexture ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.clone();

					} else if ( Array.isArray( parameter_src ) ) {

						uniforms_dst[ u ][ p ] = parameter_src.slice();

					} else {

						uniforms_dst[ u ][ p ] = parameter_src;

					}

				}

			}

			return uniforms_dst;

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function () {

			function hue2rgb( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			}

			return function setHSL( h, s, l ) {

				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );

				if ( s === 0 ) {

					this.r = this.g = this.b = l;

				} else {

					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;

					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );

				}

				return this;

			};

		}(),

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				// color keywords
				var hex = ColorKeywords[ style ];

				if ( hex !== undefined ) {

					// red
					this.setHex( hex );

				} else {

					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );

				}

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function ( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		},

		convertLinearToGamma: function ( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		},

		copySRGBToLinear: function () {

			function SRGBToLinear( c ) {

				return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

			}

			return function copySRGBToLinear( color ) {

				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );

				return this;

			};

		}(),

		copyLinearToSRGB: function () {

			function LinearToSRGB( c ) {

				return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

			}

			return function copyLinearToSRGB( color ) {

				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );

				return this;

			};

		}(),

		convertSRGBToLinear: function () {

			this.copySRGBToLinear( this );

			return this;

		},

		convertLinearToSRGB: function () {

			this.copyLinearToSRGB( this );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function () {

			var hsl = {};

			return function ( h, s, l ) {

				this.getHSL( hsl );

				hsl.h += h; hsl.s += s; hsl.l += l;

				this.setHSL( hsl.h, hsl.s, hsl.l );

				return this;

			};

		}(),

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},

				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		points: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: UniformsUtils.merge( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: UniformsUtils.merge( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;

		function onAnimationFrame( time, frame ) {

			if ( isAnimating === false ) return;

			animationLoop( time, frame );

			context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl ) {

		var buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = gl.FLOAT;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = gl.UNSIGNED_SHORT;

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( attribute.dynamic === false ) {

				gl.bufferData( bufferType, array, gl.STATIC_DRAW );

			} else if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else if ( updateRange.count === 0 ) {

				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this.onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this.onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this.onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this.onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this.onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this.onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = _Math.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.99999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.99999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.99999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.99999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this.onChangeCallback();

			return this;

		},

		setFromQuaternion: function () {

			var matrix = new Matrix4();

			return function setFromQuaternion( q, order, update ) {

				matrix.makeRotationFromQuaternion( q );

				return this.setFromRotationMatrix( matrix, order, update );

			};

		}(),

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function () {

			// WARNING: this discards revolution information -bhouston

			var q = new Quaternion();

			return function reorder( newOrder ) {

				q.setFromEuler( this );

				return this.setFromQuaternion( q, newOrder );

			};

		}(),

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this.onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		onChange: function ( callback ) {

			this.onChangeCallback = callback;

			return this;

		},

		onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	var object3DId = 0;

	function Object3D() {

		Object.defineProperty( this, 'id', { value: object3DId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				enumerable: true,
				value: position
			},
			rotation: {
				enumerable: true,
				value: rotation
			},
			quaternion: {
				enumerable: true,
				value: quaternion
			},
			scale: {
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix: function ( matrix ) {

			this.matrix.multiplyMatrices( matrix, this.matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function () {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			var q1 = new Quaternion();

			return function rotateOnAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.multiply( q1 );

				return this;

			};

		}(),

		rotateOnWorldAxis: function () {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			var q1 = new Quaternion();

			return function rotateOnWorldAxis( axis, angle ) {

				q1.setFromAxisAngle( axis, angle );

				this.quaternion.premultiply( q1 );

				return this;

			};

		}(),

		rotateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function rotateX( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function rotateY( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		rotateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function rotateZ( angle ) {

				return this.rotateOnAxis( v1, angle );

			};

		}(),

		translateOnAxis: function () {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			var v1 = new Vector3();

			return function translateOnAxis( axis, distance ) {

				v1.copy( axis ).applyQuaternion( this.quaternion );

				this.position.add( v1.multiplyScalar( distance ) );

				return this;

			};

		}(),

		translateX: function () {

			var v1 = new Vector3( 1, 0, 0 );

			return function translateX( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateY: function () {

			var v1 = new Vector3( 0, 1, 0 );

			return function translateY( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		translateZ: function () {

			var v1 = new Vector3( 0, 0, 1 );

			return function translateZ( distance ) {

				return this.translateOnAxis( v1, distance );

			};

		}(),

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function () {

			var m1 = new Matrix4();

			return function worldToLocal( vector ) {

				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

			};

		}(),

		lookAt: function () {

			// This method does not support objects with rotated and/or translated parent(s)

			var m1 = new Matrix4();
			var vector = new Vector3();

			return function lookAt( x, y, z ) {

				if ( x.isVector3 ) {

					vector.copy( x );

				} else {

					vector.set( x, y, z );

				}

				if ( this.isCamera ) {

					m1.lookAt( this.position, vector, this.up );

				} else {

					m1.lookAt( vector, this.position, this.up );

				}

				this.quaternion.setFromRotationMatrix( m1 );

			};

		}(),

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				object.dispatchEvent( { type: 'added' } );

				this.children.push( object );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;

				object.dispatchEvent( { type: 'removed' } );

				this.children.splice( index, 1 );

			}

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function () {

			var position = new Vector3();
			var scale = new Vector3();

			return function getWorldQuaternion( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, target, scale );

				return target;

			};

		}(),

		getWorldScale: function () {

			var position = new Vector3();
			var quaternion = new Quaternion();

			return function getWorldScale( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();

				}

				this.updateMatrixWorld( true );

				this.matrixWorld.decompose( position, quaternion, target );

				return target;

			};

		}(),

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
					target = new Vector3();

				}

				this.getWorldQuaternion( quaternion );

				return target.set( 0, 0, 1 ).applyQuaternion( quaternion );

			};

		}(),

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.geometry !== undefined ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();
		this.projectionMatrix = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );

			return this;

		},

		getWorldDirection: function () {

			var quaternion = new Quaternion();

			return function getWorldDirection( target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
					target = new Vector3();

				}

				this.getWorldQuaternion( quaternion );

				return target.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			};

		}(),

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;

				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var geometryId = 0; // Geometry uses even numbers as Id

	function Geometry() {

		Object.defineProperty( this, 'id', { value: geometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			var tempNormals = [];
			var tempUVs = [];
			var tempUVs2 = [];

			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

				scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

				if ( normals !== undefined ) {

					tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

				}

				if ( colors !== undefined ) {

					scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

				}

				if ( uvs !== undefined ) {

					tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

				}

				if ( uvs2 !== undefined ) {

					tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
				var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = this.morphTargets[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( i = 0, il = uvs2.length; i < il; i ++ ) {

				var uv = uvs2[ i ], uvCopy = [];

				if ( uv === undefined ) {

					continue;

				}

				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

					uvCopy.push( uv[ j ].clone() );

				}

				uvs1.push( uvCopy );

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = source.morphTargets;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				this.morphTargets.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectGeometry() {

		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];

		this.groups = [];

		this.morphTargets = {};

		this.skinWeights = [];
		this.skinIndices = [];

		// this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Object.assign( DirectGeometry.prototype, {

		computeGroups: function ( geometry ) {

			var group;
			var groups = [];
			var materialIndex = undefined;

			var faces = geometry.faces;

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				// materials

				if ( face.materialIndex !== materialIndex ) {

					materialIndex = face.materialIndex;

					if ( group !== undefined ) {

						group.count = ( i * 3 ) - group.start;
						groups.push( group );

					}

					group = {
						start: i * 3,
						materialIndex: materialIndex
					};

				}

			}

			if ( group !== undefined ) {

				group.count = ( i * 3 ) - group.start;
				groups.push( group );

			}

			this.groups = groups;

		},

		fromGeometry: function ( geometry ) {

			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;

			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

			// morphs

			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;

			var morphTargetsPosition;

			if ( morphTargetsLength > 0 ) {

				morphTargetsPosition = [];

				for ( var i = 0; i < morphTargetsLength; i ++ ) {

					morphTargetsPosition[ i ] = [];

				}

				this.morphTargets.position = morphTargetsPosition;

			}

			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;

			var morphTargetsNormal;

			if ( morphNormalsLength > 0 ) {

				morphTargetsNormal = [];

				for ( var i = 0; i < morphNormalsLength; i ++ ) {

					morphTargetsNormal[ i ] = [];

				}

				this.morphTargets.normal = morphTargetsNormal;

			}

			// skins

			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;

			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;

			//

			if ( vertices.length > 0 && faces.length === 0 ) {

				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );

			}

			for ( var i = 0; i < faces.length; i ++ ) {

				var face = faces[ i ];

				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

				} else {

					var normal = face.normal;

					this.normals.push( normal, normal, normal );

				}

				var vertexColors = face.vertexColors;

				if ( vertexColors.length === 3 ) {

					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

				} else {

					var color = face.color;

					this.colors.push( color, color, color );

				}

				if ( hasFaceVertexUv === true ) {

					var vertexUvs = faceVertexUvs[ 0 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				if ( hasFaceVertexUv2 === true ) {

					var vertexUvs = faceVertexUvs[ 1 ][ i ];

					if ( vertexUvs !== undefined ) {

						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

					} else {

						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

					}

				}

				// morphs

				for ( var j = 0; j < morphTargetsLength; j ++ ) {

					var morphTarget = morphTargets[ j ].vertices;

					morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

				}

				for ( var j = 0; j < morphNormalsLength; j ++ ) {

					var morphNormal = morphNormals[ j ].vertexNormals[ i ];

					morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

				}

				// skins

				if ( hasSkinIndices ) {

					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

				}

				if ( hasSkinWeights ) {

					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

				}

			}

			this.computeGroups( geometry );

			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		addAttribute: function ( name, attribute ) {

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return this;

			}

			this.attributes[ name ] = attribute;

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		removeAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function () {

			// rotate geometry around world x-axis

			var m1 = new Matrix4();

			return function rotateX( angle ) {

				m1.makeRotationX( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateY: function () {

			// rotate geometry around world y-axis

			var m1 = new Matrix4();

			return function rotateY( angle ) {

				m1.makeRotationY( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		rotateZ: function () {

			// rotate geometry around world z-axis

			var m1 = new Matrix4();

			return function rotateZ( angle ) {

				m1.makeRotationZ( angle );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		translate: function () {

			// translate geometry

			var m1 = new Matrix4();

			return function translate( x, y, z ) {

				m1.makeTranslation( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		scale: function () {

			// scale geometry

			var m1 = new Matrix4();

			return function scale( x, y, z ) {

				m1.makeScale( x, y, z );

				this.applyMatrix( m1 );

				return this;

			};

		}(),

		lookAt: function () {

			var obj = new Object3D();

			return function lookAt( vector ) {

				obj.lookAt( vector );

				obj.updateMatrix();

				this.applyMatrix( obj.matrix );

			};

		}(),

		center: function () {

			var offset = new Vector3();

			return function center() {

				this.computeBoundingBox();

				this.boundingBox.getCenter( offset ).negate();

				this.translate( offset.x, offset.y, offset.z );

				return this;

			};

		}(),

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isPoints || object.isLine ) {

				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

				}

				if ( geometry.boundingSphere !== null ) {

					this.boundingSphere = geometry.boundingSphere.clone();

				}

				if ( geometry.boundingBox !== null ) {

					this.boundingBox = geometry.boundingBox.clone();

				}

			} else if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in geometry.morphTargets ) {

				var array = [];
				var morphTargets = geometry.morphTargets[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

					array.push( attribute.copyVector3sArray( morphTarget ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var position = this.attributes.position;

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			var box = new Box3();
			var vector = new Vector3();

			return function computeBoundingSphere() {

				if ( this.boundingSphere === null ) {

					this.boundingSphere = new Sphere();

				}

				var position = this.attributes.position;

				if ( position ) {

					var center = this.boundingSphere.center;

					box.setFromBufferAttribute( position );
					box.getCenter( center );

					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

					var maxRadiusSq = 0;

					for ( var i = 0, il = position.count; i < il; i ++ ) {

						vector.x = position.getX( i );
						vector.y = position.getY( i );
						vector.z = position.getZ( i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

					}

					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

					if ( isNaN( this.boundingSphere.radius ) ) {

						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

					}

				}

			};

		}(),

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;
			var groups = this.groups;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					if ( groups.length === 0 ) {

						this.addGroup( 0, indices.length );

					}

					for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

						var group = groups[ j ];

						var start = group.start;
						var count = group.count;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							vA = indices[ i + 0 ] * 3;
							vB = indices[ i + 1 ] * 3;
							vC = indices[ i + 2 ] * 3;

							pA.fromArray( positions, vA );
							pB.fromArray( positions, vB );
							pC.fromArray( positions, vC );

							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );

							normals[ vA ] += cb.x;
							normals[ vA + 1 ] += cb.y;
							normals[ vA + 2 ] += cb.z;

							normals[ vB ] += cb.x;
							normals[ vB + 1 ] += cb.y;
							normals[ vB + 2 ] += cb.z;

							normals[ vC ] += cb.x;
							normals[ vC + 1 ] += cb.y;
							normals[ vC + 2 ] += cb.z;

						}

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeSize = attribute2.itemSize;

				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var vector = new Vector3();

			return function normalizeNormals() {

				var normals = this.attributes.normal;

				for ( var i = 0, il = normals.count; i < il; i ++ ) {

					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );

					vector.normalize();

					normals.setXYZ( i, vector.x, vector.y, vector.z );

				}

			};

		}(),

		toNonIndexed: function () {

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

			}

			var groups = this.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				var array = Array.prototype.slice.call( index.array );

				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var array = Array.prototype.slice.call( attribute.array );

				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		Geometry.call( this );

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();

	}

	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;

	// BoxBufferGeometry

	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

		BufferGeometry.call( this );

		this.type = 'BoxBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		var scope = this;

		width = width || 1;
		height = height || 1;
		depth = depth || 1;

		// segments

		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var numberOfVertices = 0;
		var groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;

			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;

			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;

			var vertexCounter = 0;
			var groupCount = 0;

			var ix, iy;

			var vector = new Vector3();

			// generate vertices, normals and uvs

			for ( iy = 0; iy < gridY1; iy ++ ) {

				var y = iy * segmentHeight - heightHalf;

				for ( ix = 0; ix < gridX1; ix ++ ) {

					var x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( iy = 0; iy < gridY; iy ++ ) {

				for ( ix = 0; ix < gridX; ix ++ ) {

					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PlaneGeometry

	function PlaneGeometry( width, height, widthSegments, heightSegments ) {

		Geometry.call( this );

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();

	}

	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = _Math.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;
		this.lights = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

		this.visible = true;

		this.userData = {};

		this.needsUpdate = true;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else if ( key === 'overdraw' ) {

					// ensure overdraw is backwards-compatible with legacy boolean type
					this[ key ] = Number( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;
			this.lights = source.lights;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.overdraw = source.overdraw;

			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;

			this.shadowSide = source.shadowSide;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	function MeshBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	MeshBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = UniformsUtils.clone( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = this.uniforms;
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		return data;

	};

	/**
	 * @author bhouston / http://clara.io
	 */

	function Ray( origin, direction ) {

		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();

	}

	Object.assign( Ray.prototype, {

		set: function ( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		},

		lookAt: function ( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		},

		recast: function () {

			var v1 = new Vector3();

			return function recast( t ) {

				this.origin.copy( this.at( t, v1 ) );

				return this;

			};

		}(),

		closestPointToPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			target.subVectors( point, this.origin );

			var directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		},

		distanceToPoint: function ( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		},

		distanceSqToPoint: function () {

			var v1 = new Vector3();

			return function distanceSqToPoint( point ) {

				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

				// point behind the ray

				if ( directionDistance < 0 ) {

					return this.origin.distanceToSquared( point );

				}

				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

				return v1.distanceToSquared( point );

			};

		}(),

		distanceSqToSegment: function () {

			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();

			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment

				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );

				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;

				if ( det > 0 ) {

					// The ray and segment are not parallel.

					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;

					if ( s0 >= 0 ) {

						if ( s1 >= - extDet ) {

							if ( s1 <= extDet ) {

								// region 0
								// Minimum at interior points of ray and segment.

								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

							} else {

								// region 1

								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

							}

						} else {

							// region 5

							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						if ( s1 <= - extDet ) {

							// region 4

							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						} else if ( s1 <= extDet ) {

							// region 3

							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;

						} else {

							// region 2

							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					}

				} else {

					// Ray and segment are parallel.

					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

				if ( optionalPointOnRay ) {

					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

				}

				if ( optionalPointOnSegment ) {

					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

				}

				return sqrDist;

			};

		}(),

		intersectSphere: function () {

			var v1 = new Vector3();

			return function intersectSphere( sphere, target ) {

				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;

				if ( d2 > radius2 ) return null;

				var thc = Math.sqrt( radius2 - d2 );

				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;

				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;

				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;

				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, target );

				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );

			};

		}(),

		intersectsSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) <= sphere.radius;

		},

		distanceToPlane: function ( plane ) {

			var denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		},

		intersectPlane: function ( plane, target ) {

			var t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		},

		intersectsPlane: function ( plane ) {

			// check if the ray lies on the plane first

			var distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			var denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		},

		intersectBox: function ( box, target ) {

			var tmin, tmax, tymin, tymax, tzmin, tzmax;

			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			var origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		},

		intersectsBox: ( function () {

			var v = new Vector3();

			return function intersectsBox( box ) {

				return this.intersectBox( box, v ) !== null;

			};

		} )(),

		intersectTriangle: function () {

			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();

			return function intersectTriangle( a, b, c, backfaceCulling, target ) {

				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );

				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;

				if ( DdN > 0 ) {

					if ( backfaceCulling ) return null;
					sign = 1;

				} else if ( DdN < 0 ) {

					sign = - 1;
					DdN = - DdN;

				} else {

					return null;

				}

				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {

					return null;

				}

				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {

					return null;

				}

				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {

					return null;

				}

				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );

				// t < 0, no intersection
				if ( QdN < 0 ) {

					return null;

				}

				// Ray intersects triangle.
				return this.at( QdN / DdN, target );

			};

		}(),

		applyMatrix4: function ( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		},

		equals: function ( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Line3( start, end ) {

		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();

	}

	Object.assign( Line3.prototype, {

		set: function ( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		},

		delta: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();

			}

			return target.subVectors( this.end, this.start );

		},

		distanceSq: function () {

			return this.start.distanceToSquared( this.end );

		},

		distance: function () {

			return this.start.distanceTo( this.end );

		},

		at: function ( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		closestPointToPointParameter: function () {

			var startP = new Vector3();
			var startEnd = new Vector3();

			return function closestPointToPointParameter( point, clampToLine ) {

				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );

				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );

				var t = startEnd_startP / startEnd2;

				if ( clampToLine ) {

					t = _Math.clamp( t, 0, 1 );

				}

				return t;

			};

		}(),

		closestPointToPoint: function ( point, clampToLine, target ) {

			var t = this.closestPointToPointParameter( point, clampToLine );

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		},

		applyMatrix4: function ( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		},

		equals: function ( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		getNormal: function () {

			var v0 = new Vector3();

			return function getNormal( a, b, c, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();

				}

				target.subVectors( c, b );
				v0.subVectors( a, b );
				target.cross( v0 );

				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq > 0 ) {

					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

				}

				return target.set( 0, 0, 0 );

			};

		}(),

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();

			return function getBarycoord( point, a, b, c, target ) {

				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );

				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );

				var denom = ( dot00 * dot11 - dot01 * dot01 );

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();

				}

				// collinear or singular triangle
				if ( denom === 0 ) {

					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );

				}

				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );

			};

		}(),

		containsPoint: function () {

			var v1 = new Vector3();

			return function containsPoint( point, a, b, c ) {

				Triangle.getBarycoord( point, a, b, c, v1 );

				return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );

			};

		}()

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		getArea: function () {

			var v0 = new Vector3();
			var v1 = new Vector3();

			return function getArea() {

				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );

				return v0.cross( v1 ).length() * 0.5;

			};

		}(),

		getMidpoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		getNormal: function ( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		},

		getPlane: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Vector3();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		getBarycoord: function ( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		intersectsBox: function ( box ) {

			return box.intersectsTriangle( this );

		},

		closestPointToPoint: function () {

			var plane = new Plane();
			var edgeList = [ new Line3(), new Line3(), new Line3() ];
			var projectedPoint = new Vector3();
			var closestPoint = new Vector3();

			return function closestPointToPoint( point, target ) {

				if ( target === undefined ) {

					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();

				}

				var minDistance = Infinity;

				// project the point onto the plane of the triangle

				plane.setFromCoplanarPoints( this.a, this.b, this.c );
				plane.projectPoint( point, projectedPoint );

				// check if the projection lies within the triangle

				if ( this.containsPoint( projectedPoint ) === true ) {

					// if so, this is the closest point

					target.copy( projectedPoint );

				} else {

					// if not, the point falls outside the triangle. the target is the closest point to the triangle's edges or vertices

					edgeList[ 0 ].set( this.a, this.b );
					edgeList[ 1 ].set( this.b, this.c );
					edgeList[ 2 ].set( this.c, this.a );

					for ( var i = 0; i < edgeList.length; i ++ ) {

						edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

						var distance = projectedPoint.distanceToSquared( closestPoint );

						if ( distance < minDistance ) {

							minDistance = distance;

							target.copy( closestPoint );

						}

					}

				}

				return target;

			};

		}(),

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

		this.drawMode = TrianglesDrawMode;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		setDrawMode: function ( value ) {

			this.drawMode = value;

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.drawMode = source.drawMode;

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {

						name = morphTargets[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		},

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			var barycoord = new Vector3();

			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();

			function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

				Triangle.getBarycoord( point, p1, p2, p3, barycoord );

				uv1.multiplyScalar( barycoord.x );
				uv2.multiplyScalar( barycoord.y );
				uv3.multiplyScalar( barycoord.z );

				uv1.add( uv2 ).add( uv3 );

				return uv1.clone();

			}

			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

				var intersect;

				if ( material.side === BackSide ) {

					intersect = ray.intersectTriangle( pC, pB, pA, true, point );

				} else {

					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

				}

				if ( intersect === null ) return null;

				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

				if ( distance < raycaster.near || distance > raycaster.far ) return null;

				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};

			}

			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {

				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );

				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );

				if ( intersection ) {

					if ( uv ) {

						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );

						intersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );

					}

					var face = new Face3( a, b, c );
					Triangle.getNormal( vA, vB, vC, face.normal );

					intersection.face = face;

				}

				return intersection;

			}

			return function raycast( raycaster, intersects ) {

				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;

				if ( material === undefined ) return;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				// Check boundingBox before continuing

				if ( geometry.boundingBox !== null ) {

					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

				}

				var intersection;

				if ( geometry.isBufferGeometry ) {

					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var uv = geometry.attributes.uv;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;

					if ( index !== null ) {

						// indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = index.getX( i );
									b = index.getX( i + 1 );
									c = index.getX( i + 2 );

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					} else if ( position !== undefined ) {

						// non-indexed buffer geometry

						if ( Array.isArray( material ) ) {

							for ( i = 0, il = groups.length; i < il; i ++ ) {

								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];

								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

								for ( j = start, jl = end; j < jl; j += 3 ) {

									a = j;
									b = j + 1;
									c = j + 2;

									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );

									if ( intersection ) {

										intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
										intersects.push( intersection );

									}

								}

							}

						} else {

							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

							for ( i = start, il = end; i < il; i += 3 ) {

								a = i;
								b = i + 1;
								c = i + 2;

								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );

								}

							}

						}

					}

				} else if ( geometry.isGeometry ) {

					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );

					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;

					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

						if ( faceMaterial === undefined ) continue;

						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];

						if ( faceMaterial.morphTargets === true ) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;

							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );

							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

								var influence = morphInfluences[ t ];

								if ( influence === 0 ) continue;

								var targets = morphTargets[ t ].vertices;

								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

							}

							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );

							fvA = vA;
							fvB = vB;
							fvC = vC;

						}

						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

						if ( intersection ) {

							if ( uvs && uvs[ f ] ) {

								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );

								intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

							}

							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );

						}

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeCamera, planeMesh;
		var boxMesh;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && background.isCubeTexture ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							uniforms: ShaderLib.cube.uniforms,
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: true,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					objects.update( boxMesh );

				}

				boxMesh.material.uniforms.tCube.value = background;

				renderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeCamera === undefined ) {

					planeCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
					);

					objects.update( planeMesh );

				}

				planeMesh.material.map = background;

				// TODO Push this to renderList

				renderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, info ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			extension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
				     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		return {

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;

			return dstArray;

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, info ) {

		var geometries = {};
		var wireframeAttributes = {};

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			// TODO Remove duplicate code

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ geometry.id ];

			}

			attribute = wireframeAttributes[ buffergeometry.id ];

			if ( attribute ) {

				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries[ geometry.id ];

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function getWireframeAttribute( geometry ) {

			var attribute = wireframeAttributes[ geometry.id ];

			if ( attribute ) return attribute;

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;

			// console.time( 'wireframe' );

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryAttributes.position.array;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			// console.timeEnd( 'wireframe' );

			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );

			attributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );

			wireframeAttributes[ geometry.id ] = attribute;

			return attribute;

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, info ) {

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

			extension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );

			info.update( count, mode, geometry.maxInstancedCount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLInfo( gl ) {

		var memory = {
			geometries: 0,
			textures: 0
		};

		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			instanceCount = instanceCount || 1;

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.TRIANGLE_STRIP:
				case gl.TRIANGLE_FAN:
					render.triangles += instanceCount * ( count - 2 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			var length = objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {

					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {

						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( geometries, info ) {

		var updateList = {};

		function update( object ) {

			var frame = info.render.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateList[ buffergeometry.id ] !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateList[ buffergeometry.id ] = frame;

			}

			return buffergeometry;

		}

		function dispose() {

			updateList = {};

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.flipY = false;

	}

	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;

	CubeTexture.prototype.isCubeTexture = true;

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyCubeTexture = new CubeTexture();

	// --- Base for inner nodes (including the root) ---

	function UniformContainer() {

		this.seq = [];
		this.map = {};

	}

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( var i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( var i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( renderer, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = renderer.allocTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValue1f( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValue1i( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValue2fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue3fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValue4fv( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValue2fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValue3fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValue4fm( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, renderer ) {

		var cache = this.cache;
		var unit = renderer.allocTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		renderer.setTexture2D( v || emptyTexture, unit );

	}

	function setValueT6( gl, v, renderer ) {

		var cache = this.cache;
		var unit = renderer.allocTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		renderer.setTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValue2iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue3iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValue4iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4

			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4

			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8b60: return setValueT6; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// Array of scalars

	function setValue1fv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1fv( this.addr, v );

		copyArray( cache, v );

	}
	function setValue1iv( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform1iv( this.addr, v );

		copyArray( cache, v );

	}

	// Array of vectors (flat or from THREE classes)

	function setValueV2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 2 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform2fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 3 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform3fv( this.addr, data );

		this.updateCache( data );

	}

	function setValueV4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniform4fv( this.addr, data );

		this.updateCache( data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 4 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix2fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM3a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 9 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix3fv( this.addr, false, data );

		this.updateCache( data );

	}

	function setValueM4a( gl, v ) {

		var cache = this.cache;
		var data = flatten( v, this.size, 16 );

		if ( arraysEqual( cache, data ) ) return;

		gl.uniformMatrix4fv( this.addr, false, data );

		this.updateCache( data );

	}

	// Array of textures (2D / Cube)

	function setValueT1a( gl, v, renderer ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( renderer, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6a( gl, v, renderer ) {

		var cache = this.cache;
		var n = v.length;

		var units = allocTexUnits( renderer, n );

		if ( arraysEqual( cache, units ) === false ) {

			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );

		}

		for ( var i = 0; i !== n; ++ i ) {

			renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4

			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4

			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE

			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // false

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // false

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		var cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		UniformContainer.call( this ); // mix-in

	}

	StructuredUniform.prototype.setValue = function ( gl, value ) {

		// Note: Don't need an extra 'renderer' parameter, since samplers
		// are not allowed in structured uniforms.

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ] );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program, renderer ) {

		UniformContainer.call( this );

		this.renderer = renderer;

		var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, this.renderer );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, renderer ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, renderer );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	function parseIncludes( string ) {

		var pattern = /^[ \t]*#include +<([\w\d.]+)>/gm;

		function replace( match, include ) {

			var replace = ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	function WebGLProgram( renderer, extensions, code, material, shader, parameters ) {

		var gl = renderer.context;

		var defines = material.defines;

		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = generateExtensions( material.extensions, parameters, extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + shader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',

				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program, renderer );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function () {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.name = shader.name;
		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities ) {

		var programs = [];

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow'
		};

		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];


		function allocateBones( object ) {

			var skeleton = object.skeleton;
			var bones = skeleton.bones;

			if ( capabilities.floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				var maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {

				encoding = GammaEncoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				shaderID: shaderID,

				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				combine: material.combine,

				vertexColors: material.vertexColors,

				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

			};

			return parameters;

		};

		this.getProgramCode = function ( material, parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( material.fragmentShader );
				array.push( material.vertexShader );

			}

			if ( material.defines !== undefined ) {

				for ( var name in material.defines ) {

					array.push( name );
					array.push( material.defines[ name ] );

				}

			}

			for ( var i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( material.onBeforeCompile.toString() );

			array.push( renderer.gammaOutput );

			return array.join();

		};

		this.acquireProgram = function ( material, shader, parameters, code ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var programInfo = programs[ p ];

				if ( programInfo.code === code ) {

					program = programInfo;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = new WeakMap();

		function get( object ) {

			var map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program && b.program && a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function push( object, geometry, material, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			( material.transparent === true ? transparent : opaque ).push( renderItem );

			renderItemsIndex ++;

		}

		function sort() {

			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = {};

		function get( scene, camera ) {

			var hash = scene.id + ',' + camera.id;
			var list = lists[ hash ];

			if ( list === undefined ) {

				// console.log( 'THREE.WebGLRenderLists:', hash );

				list = new WebGLRenderList();
				lists[ hash ] = list;

			}

			return list;

		}

		function dispose() {

			lists = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function UniformsCache() {

		var lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				var uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,

							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	var count = 0;

	function WebGLLights() {

		var cache = new UniformsCache();

		var state = {

			id: count ++,

			hash: '',

			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var viewMatrix = camera.matrixWorldInverse;

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isDirectionalLight ) {

					var uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;

					}

					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					var uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					var uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

					uniforms.shadow = light.castShadow;

					if ( light.castShadow ) {

						var shadow = light.shadow;

						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;

					}

					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					var uniforms = cache.get( light );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.hash = state.id + ',' + directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {

		var lights = new WebGLLights();

		var lightsArray = [];
		var shadowsArray = [];
		var spritesArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;
			spritesArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function pushSprite( sprite ) {

			spritesArray.push( sprite );

		}

		function setupLights( camera ) {

			lights.setup( lightsArray, shadowsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
			spritesArray: spritesArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,

			pushLight: pushLight,
			pushShadow: pushShadow,
			pushSprite: pushSprite
		};

	}

	function WebGLRenderStates() {

		var renderStates = {};

		function get( scene, camera ) {

			var hash = scene.id + ',' + camera.id;

			var renderState = renderStates[ hash ];

			if ( renderState === undefined ) {

				renderState = new WebGLRenderState();
				renderStates[ hash ] = renderState;

			}

			return renderState;

		}

		function dispose() {

			renderStates = {};

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	function MeshDistanceMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	MeshDistanceMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),

			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),

			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),

			_MorphingFlag = 1,
			_SkinningFlag = 2,

			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),

			_materialCache = {};

		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];

		// init

		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;

			var depthMaterial = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ i ] = depthMaterial;

			//

			var distanceMaterial = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ i ] = distanceMaterial;

		}

		//

		var scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			// TODO Clean up (needed in case of contextlost)
			var _gl = _renderer.context;
			var _state = _renderer.state;

			// Set GL state for depth map.
			_state.disable( _gl.BLEND );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			var faceCount;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				var shadowCamera = shadow.camera;

				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );

				if ( isPointLight ) {

					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;

					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction

					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;

				}

				if ( shadow.map === null ) {

					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";

					shadowCamera.updateProjectionMatrix();

				}

				if ( shadow.isSpotLightShadow ) {

					shadow.update( light );

				}

				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;

				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );

				if ( isPointLight ) {

					faceCount = 6;

					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position

					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

				} else {

					faceCount = 1;

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();

					// compute shadow matrix

					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);

					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				}

				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();

				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not

				for ( var face = 0; face < faceCount; face ++ ) {

					if ( isPointLight ) {

						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();

						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );

					}

					// update camera matrices and frustum

					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );

					// set object matrices & frustum culling

					renderObject( scene, camera, shadowCamera, isPointLight );

				}

			}

			scope.needsUpdate = false;

		};

		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {

			var geometry = object.geometry;

			var result = null;

			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;

			if ( isPointLight ) {

				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;

			}

			if ( ! customMaterial ) {

				var useMorphing = false;

				if ( material.morphTargets ) {

					if ( geometry && geometry.isBufferGeometry ) {

						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

					} else if ( geometry && geometry.isGeometry ) {

						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

					}

				}

				if ( object.isSkinnedMesh && material.skinning === false ) {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

				var useSkinning = object.isSkinnedMesh && material.skinning;

				var variantIndex = 0;

				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;

				result = materialVariants[ variantIndex ];

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				var keyA = result.uuid, keyB = material.uuid;

				var materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				var cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( isPointLight && result.isMeshDistanceMaterial ) {

				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, isPointLight ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					var geometry = _objects.update( object );
					var material = object.material;

					if ( Array.isArray( material ) ) {

						var groups = geometry.groups;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, isPointLight );

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {

		var vertexBuffer, elementBuffer;
		var program, attributes, uniforms;

		var texture;

		// decompose matrixWorld

		var spritePosition = new Vector3();
		var spriteRotation = new Quaternion();
		var spriteScale = new Vector3();

		function init() {

			var vertices = new Float32Array( [
				- 0.5, - 0.5, 0, 0,
				  0.5, - 0.5, 1, 0,
				  0.5, 0.5, 1, 1,
				- 0.5, 0.5, 0, 1
			] );

			var faces = new Uint16Array( [
				0, 1, 2,
				0, 2, 3
			] );

			vertexBuffer = gl.createBuffer();
			elementBuffer = gl.createBuffer();

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
			gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

			program = createProgram();

			attributes = {
				position: gl.getAttribLocation( program, 'position' ),
				uv: gl.getAttribLocation( program, 'uv' )
			};

			uniforms = {
				uvOffset: gl.getUniformLocation( program, 'uvOffset' ),
				uvScale: gl.getUniformLocation( program, 'uvScale' ),

				rotation: gl.getUniformLocation( program, 'rotation' ),
				center: gl.getUniformLocation( program, 'center' ),
				scale: gl.getUniformLocation( program, 'scale' ),

				color: gl.getUniformLocation( program, 'color' ),
				map: gl.getUniformLocation( program, 'map' ),
				opacity: gl.getUniformLocation( program, 'opacity' ),

				modelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),
				projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

				fogType: gl.getUniformLocation( program, 'fogType' ),
				fogDensity: gl.getUniformLocation( program, 'fogDensity' ),
				fogNear: gl.getUniformLocation( program, 'fogNear' ),
				fogFar: gl.getUniformLocation( program, 'fogFar' ),
				fogColor: gl.getUniformLocation( program, 'fogColor' ),
				fogDepth: gl.getUniformLocation( program, 'fogDepth' ),

				alphaTest: gl.getUniformLocation( program, 'alphaTest' )
			};

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = 8;
			canvas.height = 8;

			var context = canvas.getContext( '2d' );
			context.fillStyle = 'white';
			context.fillRect( 0, 0, 8, 8 );

			texture = new CanvasTexture( canvas );

		}

		this.render = function ( sprites, scene, camera ) {

			if ( sprites.length === 0 ) return;

			// setup gl

			if ( program === undefined ) {

				init();

			}

			state.useProgram( program );

			state.initAttributes();
			state.enableAttribute( attributes.position );
			state.enableAttribute( attributes.uv );
			state.disableUnusedAttributes();

			state.disable( gl.CULL_FACE );
			state.enable( gl.BLEND );

			gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
			gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
			gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

			gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

			gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			state.activeTexture( gl.TEXTURE0 );
			gl.uniform1i( uniforms.map, 0 );

			var oldFogType = 0;
			var sceneFogType = 0;
			var fog = scene.fog;

			if ( fog ) {

				gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

				if ( fog.isFog ) {

					gl.uniform1f( uniforms.fogNear, fog.near );
					gl.uniform1f( uniforms.fogFar, fog.far );

					gl.uniform1i( uniforms.fogType, 1 );
					oldFogType = 1;
					sceneFogType = 1;

				} else if ( fog.isFogExp2 ) {

					gl.uniform1f( uniforms.fogDensity, fog.density );

					gl.uniform1i( uniforms.fogType, 2 );
					oldFogType = 2;
					sceneFogType = 2;

				}

			} else {

				gl.uniform1i( uniforms.fogType, 0 );
				oldFogType = 0;
				sceneFogType = 0;

			}


			// update positions and sort

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];

				sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

			}

			sprites.sort( painterSortStable );

			// render all sprites

			var scale = [];
			var center = [];

			for ( var i = 0, l = sprites.length; i < l; i ++ ) {

				var sprite = sprites[ i ];
				var material = sprite.material;

				if ( material.visible === false ) continue;

				sprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );

				gl.uniform1f( uniforms.alphaTest, material.alphaTest );
				gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

				sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

				scale[ 0 ] = spriteScale.x;
				scale[ 1 ] = spriteScale.y;

				center[ 0 ] = sprite.center.x - 0.5;
				center[ 1 ] = sprite.center.y - 0.5;

				var fogType = 0;

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				}

				if ( oldFogType !== fogType ) {

					gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				if ( material.map !== null ) {

					gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
					gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

				} else {

					gl.uniform2f( uniforms.uvOffset, 0, 0 );
					gl.uniform2f( uniforms.uvScale, 1, 1 );

				}

				gl.uniform1f( uniforms.opacity, material.opacity );
				gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				gl.uniform1f( uniforms.rotation, material.rotation );
				gl.uniform2fv( uniforms.center, center );
				gl.uniform2fv( uniforms.scale, scale );

				state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
				state.buffers.depth.setTest( material.depthTest );
				state.buffers.depth.setMask( material.depthWrite );
				state.buffers.color.setMask( material.colorWrite );

				textures.setTexture2D( material.map || texture, 0 );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

				sprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );

			}

			// restore gl

			state.enable( gl.CULL_FACE );

			state.reset();

		};

		function createProgram() {

			var program = gl.createProgram();

			var vertexShader = gl.createShader( gl.VERTEX_SHADER );
			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

			gl.shaderSource( vertexShader, [

				'precision ' + capabilities.precision + ' float;',

				'#define SHADER_NAME ' + 'SpriteMaterial',

				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform float rotation;',
				'uniform vec2 center;',
				'uniform vec2 scale;',
				'uniform vec2 uvOffset;',
				'uniform vec2 uvScale;',

				'attribute vec2 position;',
				'attribute vec2 uv;',

				'varying vec2 vUV;',
				'varying float fogDepth;',

				'void main() {',

				'	vUV = uvOffset + uv * uvScale;',

				'	vec2 alignedPosition = ( position - center ) * scale;',

				'	vec2 rotatedPosition;',
				'	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'	vec4 mvPosition;',

				'	mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'	mvPosition.xy += rotatedPosition;',

				'	gl_Position = projectionMatrix * mvPosition;',

				'	fogDepth = - mvPosition.z;',

				'}'

			].join( '\n' ) );

			gl.shaderSource( fragmentShader, [

				'precision ' + capabilities.precision + ' float;',

				'#define SHADER_NAME ' + 'SpriteMaterial',

				'uniform vec3 color;',
				'uniform sampler2D map;',
				'uniform float opacity;',

				'uniform int fogType;',
				'uniform vec3 fogColor;',
				'uniform float fogDensity;',
				'uniform float fogNear;',
				'uniform float fogFar;',
				'uniform float alphaTest;',

				'varying vec2 vUV;',
				'varying float fogDepth;',

				'void main() {',

				'	vec4 texture = texture2D( map, vUV );',

				'	gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'	if ( gl_FragColor.a < alphaTest ) discard;',

				'	if ( fogType > 0 ) {',

				'		float fogFactor = 0.0;',

				'		if ( fogType == 1 ) {',

				'			fogFactor = smoothstep( fogNear, fogFar, fogDepth );',

				'		} else {',

				'			const float LOG2 = 1.442695;',
				'			fogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',
				'			fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

				'		}',

				'		gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',

				'	}',

				'}'

			].join( '\n' ) );

			gl.compileShader( vertexShader );
			gl.compileShader( fragmentShader );

			gl.attachShader( program, vertexShader );
			gl.attachShader( program, fragmentShader );

			gl.linkProgram( program );

			return program;

		}

		function painterSortStable( a, b ) {

			if ( a.renderOrder !== b.renderOrder ) {

				return a.renderOrder - b.renderOrder;

			} else if ( a.z !== b.z ) {

				return b.z - a.z;

			} else {

				return b.id - a.id;

			}

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, utils ) {

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( gl.NEVER );
									break;

								case AlwaysDepth:

									gl.depthFunc( gl.ALWAYS );
									break;

								case LessDepth:

									gl.depthFunc( gl.LESS );
									break;

								case LessEqualDepth:

									gl.depthFunc( gl.LEQUAL );
									break;

								case EqualDepth:

									gl.depthFunc( gl.EQUAL );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( gl.GEQUAL );
									break;

								case GreaterDepth:

									gl.depthFunc( gl.GREATER );
									break;

								case NotEqualDepth:

									gl.depthFunc( gl.NOTEQUAL );
									break;

								default:

									gl.depthFunc( gl.LEQUAL );

							}

						} else {

							gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( stencilTest ) {

						enable( gl.STENCIL_TEST );

					} else {

						disable( gl.STENCIL_TEST );

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var capabilities = {};

		var compressedTextureFormats = null;

		var currentProgram = null;

		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = extensions.get( 'ANGLE_instanced_arrays' );

				extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( capabilities[ id ] !== true ) {

				gl.enable( id );
				capabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( capabilities[ id ] !== false ) {

				gl.disable( id );
				capabilities[ id ] = false;

			}

		}

		function getCompressedTextureFormats() {

			if ( compressedTextureFormats === null ) {

				compressedTextureFormats = [];

				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
				     extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
				     extensions.get( 'WEBGL_compressed_texture_astc' ) ) {

					var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

					for ( var i = 0; i < formats.length; i ++ ) {

						compressedTextureFormats.push( formats[ i ] );

					}

				}

			}

			return compressedTextureFormats;

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending !== NoBlending ) {

				enable( gl.BLEND );

			} else {

				disable( gl.BLEND );

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					switch ( blending ) {

						case AdditiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

							}
							break;

						case SubtractiveBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

							}
							break;

						case MultiplyBlending:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

							} else {

								gl.blendEquation( gl.FUNC_ADD );
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

							}
							break;

						default:

							if ( premultipliedAlpha ) {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							} else {

								gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

							}

					}

				}

				currentBlendEquation = null;
				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendEquationAlpha = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

			} else {

				blendEquationAlpha = blendEquationAlpha || blendEquation;
				blendSrcAlpha = blendSrcAlpha || blendSrc;
				blendDstAlpha = blendDstAlpha || blendDst;

				if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

					gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );

					currentBlendEquation = blendEquation;
					currentBlendEquationAlpha = blendEquationAlpha;

				}

				if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

					gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );

					currentBlendSrc = blendSrc;
					currentBlendDst = blendDst;
					currentBlendSrcAlpha = blendSrcAlpha;
					currentBlendDstAlpha = blendDstAlpha;

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			capabilities = {};

			compressedTextureFormats = null;

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext ); /* global WebGL2RenderingContext */
		var _videoTextures = {};
		var _canvas;

		//

		function clampToMaxSize( image, maxSize ) {

			if ( image.width > maxSize || image.height > maxSize ) {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
					return;

				}

				// Warning: Scaling through the canvas will only work with images that use
				// premultiplied alpha.

				var scale = maxSize / Math.max( image.width, image.height );

				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = Math.floor( image.width * scale );
				canvas.height = Math.floor( image.height * scale );

				var context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

				return canvas;

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

		}

		function makePowerOfTwo( image ) {

			if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = _Math.floorPowerOfTwo( image.width );
				_canvas.height = _Math.floorPowerOfTwo( image.height );

				var context = _canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, _canvas.width, _canvas.height );

				console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + _canvas.width + 'x' + _canvas.height, image );

				return _canvas;

			}

			return image;

		}

		function textureNeedsPowerOfTwo( texture ) {

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {

			return texture.generateMipmaps && isPowerOfTwo &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			var textureProperties = properties.get( texture );

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				delete _videoTextures[ texture.id ];

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( texture.image && textureProperties.__image__webglTextureCube ) {

				// cube texture

				_gl.deleteTexture( textureProperties.__image__webglTextureCube );

			} else {

				// 2D texture

				if ( textureProperties.__webglInit === undefined ) return;

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			// remove all webgl properties
			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLRenderTargetCube ) {

				for ( var i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//



		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.image.length === 6 ) {

				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

					if ( ! textureProperties.__image__webglTextureCube ) {

						texture.addEventListener( 'dispose', onTextureDispose );

						textureProperties.__image__webglTextureCube = _gl.createTexture();

						info.memory.textures ++;

					}

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

					_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

					var cubeImage = [];

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed && ! isDataTexture ) {

							cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

						} else {

							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

						}

					}

					var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type );

					setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

					for ( var i = 0; i < 6; i ++ ) {

						if ( ! isCompressed ) {

							if ( isDataTexture ) {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

							}

						} else {

							var mipmap, mipmaps = cubeImage[ i ].mipmaps;

							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

								mipmap = mipmaps[ j ];

								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

										state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

									} else {

										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

									}

								} else {

									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

								}

							}

						}

					}

					if ( ! isCompressed ) {

						textureProperties.__maxMipLevel = 0;

					} else {

						textureProperties.__maxMipLevel = mipmaps.length - 1;

					}

					if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

						// We assume images for cube map have the same size.
						generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

					}

					textureProperties.__version = texture.version;

					if ( texture.onUpdate ) texture.onUpdate( texture );

				} else {

					state.activeTexture( _gl.TEXTURE0 + slot );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				}

			}

		}

		function setTextureCubeDynamic( texture, slot ) {

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

		}

		function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

			var extension;

			if ( isPowerOfTwoImage ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

				}

			}

			extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

			if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

				image = makePowerOfTwo( image );

			}

			var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				var internalFormat = _gl.DEPTH_COMPONENT;

				if ( texture.type === FloatType ) {

					if ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					internalFormat = _gl.DEPTH_COMPONENT32F;

				} else if ( _isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					internalFormat = _gl.DEPTH_COMPONENT16;

				}

				if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					internalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {

				generateMipmap( _gl.TEXTURE_2D, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				// FIXME: We don't support !depth !stencil
				_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( var i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

					}

				} else {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) {

					generateMipmap( _gl.TEXTURE_2D, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

			if ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {

				var target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateVideoTexture( texture ) {

			var id = texture.id;
			var frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures[ id ] !== frame ) {

				_videoTextures[ id ] = frame;
				texture.update();

			}

		}

		this.setTexture2D = setTexture2D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions ) {

		function convert( p ) {

			var extension;

			if ( p === RepeatWrapping ) return gl.REPEAT;
			if ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;
			if ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;

			if ( p === NearestFilter ) return gl.NEAREST;
			if ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;
			if ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;

			if ( p === LinearFilter ) return gl.LINEAR;
			if ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;
			if ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) return extension.HALF_FLOAT_OES;

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;

			if ( p === AddEquation ) return gl.FUNC_ADD;
			if ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;
			if ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;

			if ( p === ZeroFactor ) return gl.ZERO;
			if ( p === OneFactor ) return gl.ONE;
			if ( p === SrcColorFactor ) return gl.SRC_COLOR;
			if ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;
			if ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;
			if ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;
			if ( p === DstAlphaFactor ) return gl.DST_ALPHA;
			if ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;

			if ( p === DstColorFactor ) return gl.DST_COLOR;
			if ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;
			if ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					return p;

				}

			}

			if ( p === MinEquation || p === MaxEquation ) {

				extension = extensions.get( 'EXT_blend_minmax' );

				if ( extension !== null ) {

					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;

				}

			}

			if ( p === UnsignedInt248Type ) {

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

			}

			return 0;

		}

		return { convert: convert };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ArrayCamera( array ) {

		PerspectiveCamera.call( this );

		this.cameras = array || [];

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebVRManager( renderer ) {

		var scope = this;

		var device = null;
		var frameData = null;

		var poseTarget = null;

		var controllers = [];
		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();

		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {

			frameData = new window.VRFrameData();
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );

		}

		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();

		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );

		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		function isPresenting() {

			return device !== null && device.isPresenting === true;

		}

		var currentSize, currentPixelRatio;

		function onVRDisplayPresentChange() {

			if ( isPresenting() ) {

				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth;
				var renderHeight = eyeParameters.renderHeight;

				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();

				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );

				animation.start();

			} else if ( scope.enabled ) {

				renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );

				animation.stop();

			}

		}

		//

		var isTriggerPressed = false;

		function findGamepad( id ) {

			var gamepads = navigator.getGamepads && navigator.getGamepads();

			for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {

				var gamepad = gamepads[ i ];

				if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {

					if ( j === id ) return gamepad;

					j ++;

				}

			}

		}

		function updateControllers() {

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var gamepad = findGamepad( i );

				if ( gamepad !== undefined && gamepad.pose !== undefined ) {

					if ( gamepad.pose === null ) return;

					//  Pose

					var pose = gamepad.pose;

					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );

					if ( pose.position !== null ) controller.position.fromArray( pose.position );
					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
					controller.matrix.premultiply( standingMatrix );
					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;

					//  Trigger

					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;

					if ( isTriggerPressed !== gamepad.buttons[ buttonId ].pressed ) {

						isTriggerPressed = gamepad.buttons[ buttonId ].pressed;

						if ( isTriggerPressed ) {

							controller.dispatchEvent( { type: 'selectstart' } );

						} else {

							controller.dispatchEvent( { type: 'selectend' } );
							controller.dispatchEvent( { type: 'select' } );

						}

					}

				} else {

					controller.visible = false;

				}

			}

		}

		//

		this.enabled = false;
		this.userHeight = 1.6;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

			animation.setContext( value );

		};

		this.setPoseTarget = function ( object ) {

			if ( object !== undefined ) poseTarget = object;

		};

		this.getCamera = function ( camera ) {

			if ( device === null ) {

				camera.position.set( 0, scope.userHeight, 0 );
				return camera;

			}

			device.depthNear = camera.near;
			device.depthFar = camera.far;

			device.getFrameData( frameData );

			//

			var stageParameters = device.stageParameters;

			if ( stageParameters ) {

				standingMatrix.fromArray( stageParameters.sittingToStandingTransform );

			} else {

				standingMatrix.makeTranslation( 0, scope.userHeight, 0 );

			}


			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;

			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );

			if ( pose.orientation !== null ) {

				tempQuaternion.fromArray( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );

			}

			if ( pose.position !== null ) {

				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );

			}

			poseObject.updateMatrixWorld();

			if ( device.isPresenting === false ) return camera;

			//

			cameraL.near = camera.near;
			cameraR.near = camera.near;

			cameraL.far = camera.far;
			cameraR.far = camera.far;

			cameraVR.matrixWorld.copy( camera.matrixWorld );
			cameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );

			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );

			// TODO (mrdoob) Double check this code

			standingMatrixInverse.getInverse( standingMatrix );

			cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
			cameraR.matrixWorldInverse.multiply( standingMatrixInverse );

			var parent = poseObject.parent;

			if ( parent !== null ) {

				matrixWorldInverse.getInverse( parent.matrixWorld );

				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );

			}

			// envMap and Mirror needs camera.matrixWorld

			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );

			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );

			// HACK (mrdoob)
			// https://github.com/w3c/webvr/issues/203

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			//

			var layers = device.getLayers();

			if ( layers.length ) {

				var layer = layers[ 0 ];

				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {

					cameraL.bounds.fromArray( layer.leftBounds );

				}

				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {

					cameraR.bounds.fromArray( layer.rightBounds );

				}

			}

			updateControllers();

			return cameraVR;

		};

		this.getStandingMatrix = function () {

			return standingMatrix;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var animation = new WebGLAnimation();

		this.setAnimationLoop = function ( callback ) {

			animation.setAnimationLoop( callback );

		};

		this.submitFrame = function () {

			if ( isPresenting() ) device.submitFrame();

		};

		this.dispose = function () {

			if ( typeof window !== 'undefined' ) {

				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebXRManager( renderer ) {

		var gl = renderer.context;

		var device = null;
		var session = null;

		var frameOfRef = null;

		var pose = null;

		var controllers = [];
		var inputSources = [];

		function isPresenting() {

			return session !== null && frameOfRef !== null;


		}

		//

		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		//

		this.enabled = false;

		this.getController = function ( id ) {

			var controller = controllers[ id ];

			if ( controller === undefined ) {

				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;

				controllers[ id ] = controller;

			}

			return controller;

		};

		this.getDevice = function () {

			return device;

		};

		this.setDevice = function ( value ) {

			if ( value !== undefined ) device = value;

			gl.setCompatibleXRDevice( value );

		};

		//

		function onSessionEvent( event ) {

			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
			if ( controller ) controller.dispatchEvent( { type: event.type } );

		}

		function onSessionEnd() {

			renderer.setFramebuffer( null );
			animation.stop();

		}

		this.setSession = function ( value, options ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );

				session.baseLayer = new XRWebGLLayer( session, gl );
				session.requestFrameOfReference( options.frameOfReferenceType ).then( function ( value ) {

					frameOfRef = value;

					renderer.setFramebuffer( session.baseLayer.framebuffer );

					animation.setContext( session );
					animation.start();

				} );

				//

				inputSources = session.getInputSources();

				session.addEventListener( 'inputsourceschange', function () {

					inputSources = session.getInputSources();
					console.log( inputSources );

				} );

			}

		};

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		}

		this.getCamera = function ( camera ) {

			if ( isPresenting() ) {

				var parent = camera.parent;
				var cameras = cameraVR.cameras;

				// apply camera.parent to cameraVR

				updateCamera( cameraVR, parent );

				for ( var i = 0; i < cameras.length; i ++ ) {

					updateCamera( cameras[ i ], parent );

				}

				// update camera and its children

				camera.matrixWorld.copy( cameraVR.matrixWorld );

				var children = camera.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateMatrixWorld( true );

				}

				return cameraVR;

			}

			return camera;

		};

		this.isPresenting = isPresenting;

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getDevicePose( frameOfRef );

			if ( pose !== null ) {

				var layer = session.baseLayer;
				var views = frame.views;

				for ( var i = 0; i < views.length; i ++ ) {

					var view = views[ i ];
					var viewport = layer.getViewport( view );
					var viewMatrix = pose.getViewMatrix( view );

					var camera = cameraVR.cameras[ i ];
					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

						// HACK (mrdoob)
						// https://github.com/w3c/webvr/issues/203

						cameraVR.projectionMatrix.copy( camera.projectionMatrix );

					}

				}

			}

			//

			for ( var i = 0; i < controllers.length; i ++ ) {

				var controller = controllers[ i ];

				var inputSource = inputSources[ i ];

				if ( inputSource ) {

					var inputPose = frame.getInputPose( inputSource, frameOfRef );

					if ( inputPose !== null ) {

						controller.matrix.elements = inputPose.pointerMatrix;
						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
						controller.visible = true;

						continue;

					}

				}

				controller.visible = false;

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

		// DEPRECATED

		this.getStandingMatrix = function () {

			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
			return new THREE.Matrix4();

		};

		this.submitFrame = function () {};

	}

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		console.log( 'THREE.WebGLRenderer', REVISION );

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';

		var currentRenderList = null;
		var currentRenderState = null;

		// public properties

		this.domElement = _canvas;
		this.context = null;

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_framebuffer = null,

			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
			_currentGeometryProgram = '',

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_usedTextureUnits = 0,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3();

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );

		}

		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
		var spriteRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'OES_element_index_uint' );
			extensions.get( 'ANGLE_instanced_arrays' );

			utils = new WebGLUtils( _gl, extensions );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			state = new WebGLState( _gl, extensions, utils );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( geometries, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info );

			spriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );

			info.programs = programCache.programs;

			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// vr

		var vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );

		this.vr = vr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function () {

			return {
				width: _width,
				height: _height
			};

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( vr.isPresenting() ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function () {

			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio
			};

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function () {

			return _currentViewport;

		};

		this.setViewport = function ( x, y, width, height ) {

			_viewport.set( x, _height - y - height, width, height );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissor = function ( x, y, width, height ) {

			_scissor.set( x, _height - y - height, width, height );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		this.clearTarget = function ( renderTarget, color, depth, stencil ) {

			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			vr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program, material ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program, material );

			} );

		}

		this.renderBufferImmediate = function ( object, program, material ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

				if ( ! material.isMeshPhongMaterial &&
					! material.isMeshStandardMaterial &&
					! material.isMeshNormalMaterial &&
					material.flatShading === true ) {

					for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

						var array = object.normalArray;

						var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
						var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
						var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

						array[ i + 0 ] = nx;
						array[ i + 1 ] = ny;
						array[ i + 2 ] = nz;

						array[ i + 3 ] = nx;
						array[ i + 4 ] = ny;
						array[ i + 5 ] = nz;

						array[ i + 6 ] = nx;
						array[ i + 7 ] = ny;
						array[ i + 8 ] = nz;

					}

				}

				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.normal );

				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs && material.map ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.uv );

				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors && material.vertexColors !== NoColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				state.enableAttribute( programAttributes.color );

				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			state.setMaterial( material, frontFaceCW );

			var program = setProgram( camera, fog, material, object );
			var geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );

			var updateBuffers = false;

			if ( geometryProgram !== _currentGeometryProgram ) {

				_currentGeometryProgram = geometryProgram;
				updateBuffers = true;

			}

			if ( object.morphTargetInfluences ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( material, program, geometry );

				if ( index !== null ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );

				}

			}

			//

			var dataCount = Infinity;

			if ( index !== null ) {

				dataCount = index.count;

			} else if ( position !== undefined ) {

				dataCount = position.count;

			}

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					switch ( object.drawMode ) {

						case TrianglesDrawMode:
							renderer.setMode( _gl.TRIANGLES );
							break;

						case TriangleStripDrawMode:
							renderer.setMode( _gl.TRIANGLE_STRIP );
							break;

						case TriangleFanDrawMode:
							renderer.setMode( _gl.TRIANGLE_FAN );
							break;

					}

				}


			} else if ( object.isLine ) {

				var lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			}

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( geometry.maxInstancedCount > 0 ) {

					renderer.renderInstances( geometry, drawStart, drawCount );

				}

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( material, program, geometry ) {

			if ( geometry && geometry.isInstancedBufferGeometry ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.traverse( function ( object ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights( camera );

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							initMaterial( object.material[ i ], scene.fog, object );

						}

					} else {

						initMaterial( object.material, scene.fog, object );

					}

				}

			} );

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( vr.isPresenting() ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			vr.setAnimationLoop( callback );

			animation.start();

		};

		// Rendering

		this.render = function ( scene, camera, renderTarget, forceClear ) {

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram = '';
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( vr.enabled ) {

				camera = vr.getCamera( camera );

			}

			//

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.onBeforeRender( _this, scene, camera, renderTarget );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, _this.sortObjects );

			if ( _this.sortObjects === true ) {

				currentRenderList.sort();

			}

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights( camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			if ( this.info.autoReset ) this.info.reset();

			if ( renderTarget === undefined ) {

				renderTarget = null;

			}

			this.setRenderTarget( renderTarget );

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			// custom renderers

			var spritesArray = currentRenderState.state.spritesArray;

			spriteRenderer.render( spritesArray, scene, camera );

			// Generate mipmap if we're using any kind of mipmap filtering

			if ( renderTarget ) {

				textures.updateRenderTargetMipmap( renderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			scene.onAfterRender( _this, scene, camera );

			if ( vr.enabled ) {

				vr.submitFrame();

			}

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;

		};

		/*
		// TODO Duplicated code (Frustum)

		var _sphere = new Sphere();

		function isObjectViewable( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSpriteViewable( sprite ) {

			_sphere.center.set( 0, 0, 0 );
			_sphere.radius = 0.7071067811865476;
			_sphere.applyMatrix4( sprite.matrixWorld );

			return isSphereViewable( _sphere );

		}

		function isSphereViewable( sphere ) {

			if ( ! _frustum.intersectsSphere( sphere ) ) return false;

			var numPlanes = _clipping.numPlanes;

			if ( numPlanes === 0 ) return true;

			var planes = _this.clippingPlanes,

				center = sphere.center,
				negRad = - sphere.radius,
				i = 0;

			do {

				// out when deeper than radius in the negative halfspace
				if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

			} while ( ++ i !== numPlanes );

			return true;

		}
		*/

		function projectObject( object, camera, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						currentRenderState.pushSprite( object );

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						object.skeleton.update();

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							if ( 'viewport' in camera2 ) { // XR

								state.viewport( _currentViewport.copy( camera2.viewport ) );

							} else {

								var bounds = camera2.bounds;

								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;

								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );

							}

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

				state.setMaterial( material, frontFaceCW );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram = '';

				renderObjectImmediate( object, program, material );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		}

		function initMaterial( material, fog, object ) {

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );

			var code = programCache.getProgramCode( material, parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.code !== code ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( materialProperties.lightsHash !== lights.state.hash ) {

				properties.update( material, 'lightsHash', lights.state.hash );
				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				if ( parameters.shaderID ) {

					var shader = ShaderLib[ parameters.shaderID ];

					materialProperties.shader = {
						name: material.type,
						uniforms: UniformsUtils.clone( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};

				} else {

					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};

				}

				material.onBeforeCompile( materialProperties.shader, _this );

				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );

				materialProperties.program = program;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( material.morphTargets ) {

				material.numSupportedMorphTargets = 0;

				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

						material.numSupportedMorphTargets ++;

					}

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.shader.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = fog;

			// store the light setup it was created for

			materialProperties.lightsHash = lights.state.hash;

			if ( material.lights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, fog, material, object ) {

			_usedTextureUnits = 0;

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.needsUpdate === false ) {

				if ( materialProperties.program === undefined ) {

					material.needsUpdate = true;

				} else if ( material.fog && materialProperties.fog !== fog ) {

					material.needsUpdate = true;

				} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {

					material.needsUpdate = true;

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					material.needsUpdate = true;

				}

			}

			if ( material.needsUpdate ) {

				initMaterial( material, fog, object );
				material.needsUpdate = false;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || camera !== _currentCamera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				// Avoid unneeded uniform updates per ArrayCamera's sub-camera

				if ( _currentCamera !== ( _currentArrayCamera || camera ) ) {

					_currentCamera = ( _currentArrayCamera || camera );

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( material.lights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshLambertMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );

				} else if ( material.isMeshPhongMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshToonMaterial ) {

						refreshUniformsToon( m_uniforms, material );

					} else {

						refreshUniformsPhong( m_uniforms, material );

					}

				} else if ( material.isMeshStandardMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

					if ( material.isMeshPhysicalMaterial ) {

						refreshUniformsPhysical( m_uniforms, material );

					} else {

						refreshUniformsStandard( m_uniforms, material );

					}

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshDistanceMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
				material.uniformsNeedUpdate = false;

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value = material.color;

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			if ( material.envMap ) {

				uniforms.envMap.value = material.envMap;

				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			uniforms.map.value = material.map;

			if ( material.map !== null ) {

				if ( material.map.matrixAutoUpdate === true ) {

					material.map.updateMatrix();

				}

				uniforms.uvTransform.value.copy( material.map.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value = fog.color;

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			refreshUniformsPhong( uniforms, material );

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			if ( material.envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		// Textures

		function allocTextureUnit() {

			var textureUnit = _usedTextureUnits;

			if ( textureUnit >= capabilities.maxTextures ) {

				console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

			}

			_usedTextureUnits += 1;

			return textureUnit;

		}

		this.allocTextureUnit = allocTextureUnit;

		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function () {

			var warned = false;

			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {

				if ( texture && texture.isWebGLRenderTarget ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTexture = ( function () {

			var warned = false;

			return function setTexture( texture, slot ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;

				}

				textures.setTexture2D( texture, slot );

			};

		}() );

		this.setTextureCube = ( function () {

			var warned = false;

			return function setTextureCube( texture, slot ) {

				// backwards compatibility: peel texture.texture
				if ( texture && texture.isWebGLRenderTargetCube ) {

					if ( ! warned ) {

						console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;

					}

					texture = texture.texture;

				}

				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture && texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

					// CompressedTexture can have Array in image :/

					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );

				} else {

					// assumed: texture property of THREE.WebGLRenderTargetCube

					textures.setTextureCubeDynamic( texture, slot );

				}

			};

		}() );

		//

		this.setFramebuffer = function ( value ) {

			_framebuffer = value;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget ) {

			_currentRenderTarget = renderTarget;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = _framebuffer;
			var isCube = false;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLRenderTargetCube ) {

					framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
					isCube = true;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {

			var width = texture.image.width;
			var height = texture.image.height;
			var glFormat = utils.convert( texture.format );

			this.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( _gl.TEXTURE_2D, level || 0, glFormat, position.x, position.y, width, height, 0 );

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );

			this.setTexture2D( dstTexture, 0 );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function FogExp2( color, density ) {

		this.name = '';

		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	FogExp2.prototype.isFogExp2 = true;

	FogExp2.prototype.clone = function () {

		return new FogExp2( this.color, this.density );

	};

	FogExp2.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Fog( color, near, far ) {

		this.name = '';

		this.color = new Color( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	Fog.prototype.isFog = true;

	Fog.prototype.clone = function () {

		return new Fog( this.color, this.near, this.far );

	};

	Fog.prototype.toJSON = function ( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *	uvOffset: new THREE.Vector2(),
	 *	uvScale: new THREE.Vector2()
	 * }
	 */

	function SpriteMaterial( parameters ) {

		Material.call( this );

		this.type = 'SpriteMaterial';

		this.color = new Color( 0xffffff );
		this.map = null;

		this.rotation = 0;

		this.fog = false;
		this.lights = false;

		this.setValues( parameters );

	}

	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;

	SpriteMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.map = source.map;

		this.rotation = source.rotation;

		return this;

	};

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Sprite( material ) {

		Object3D.call( this );

		this.type = 'Sprite';

		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Sprite,

		isSprite: true,

		raycast: ( function () {

			var intersectPoint = new Vector3();
			var worldScale = new Vector3();
			var mvPosition = new Vector3();

			var alignedPosition = new Vector2();
			var rotatedPosition = new Vector2();
			var viewWorldMatrix = new Matrix4();

			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();

			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

				// compute position in camera space
				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

				// to check if rotation is not zero
				if ( sin !== undefined ) {

					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );

				} else {

					rotatedPosition.copy( alignedPosition );

				}


				vertexPosition.copy( mvPosition );
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;

				// transform to world space
				vertexPosition.applyMatrix4( viewWorldMatrix );

			}

			return function raycast( raycaster, intersects ) {

				worldScale.setFromMatrixScale( this.matrixWorld );
				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
				mvPosition.setFromMatrixPosition( this.modelViewMatrix );

				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {

					cos = Math.cos( rotation );
					sin = Math.sin( rotation );

				}

				var center = this.center;

				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );

				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );

				if ( intersect === null ) {

					// check second triangle
					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
					if ( intersect === null ) {

						return;

					}

				}

				var distance = raycaster.ray.origin.distanceTo( intersectPoint );

				if ( distance < raycaster.near || distance > raycaster.far ) return;

				intersects.push( {

					distance: distance,
					point: intersectPoint.clone(),
					face: null,
					object: this

				} );

			};

		}() ),

		clone: function () {

			return new this.constructor( this.material ).copy( this );

		},

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			return this;

		}


	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LOD() {

		Object3D.call( this );

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			for ( var i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		},

		raycast: ( function () {

			var matrixPosition = new Vector3();

			return function raycast( raycaster, intersects ) {

				matrixPosition.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( matrixPosition );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			};

		}() ),

		update: function () {

			var v1 = new Vector3();
			var v2 = new Vector3();

			return function update( camera ) {

				var levels = this.levels;

				if ( levels.length > 1 ) {

					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );

					var distance = v1.distanceTo( v2 );

					levels[ 0 ].object.visible = true;

					for ( var i = 1, l = levels.length; i < l; i ++ ) {

						if ( distance >= levels[ i ].distance ) {

							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;

						} else {

							break;

						}

					}

					for ( ; i < l; i ++ ) {

						levels[ i ].object.visible = false;

					}

				}

			};

		}(),

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	function Skeleton( bones, boneInverses ) {

		// copy the bone array

		bones = bones || [];

		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );

		// use the supplied bone inverses or calculate the inverses

		if ( boneInverses === undefined ) {

			this.calculateInverses();

		} else {

			if ( this.bones.length === boneInverses.length ) {

				this.boneInverses = boneInverses.slice( 0 );

			} else {

				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

				this.boneInverses = [];

				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	Object.assign( Skeleton.prototype, {

		calculateInverses: function () {

			this.boneInverses = [];

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.getInverse( this.bones[ i ].matrixWorld );

				}

				this.boneInverses.push( inverse );

			}

		},

		pose: function () {

			var bone, i, il;

			// recover the bind-time world matrices

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.getInverse( this.boneInverses[ i ] );

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( i = 0, il = this.bones.length; i < il; i ++ ) {

				bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		},

		update: ( function () {

			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();

			return function update() {

				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;

				// flatten bone matrices to array

				for ( var i = 0, il = bones.length; i < il; i ++ ) {

					// compute the offset between the current and the original transform

					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;

					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );

				}

				if ( boneTexture !== undefined ) {

					boneTexture.needsUpdate = true;

				}

			};

		} )(),

		clone: function () {

			return new Skeleton( this.bones, this.boneInverses );

		},

		getBoneByName: function ( name ) {

			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {

				var bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */

	function SkinnedMesh( geometry, material ) {

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

		var bones = this.initBones();
		var skeleton = new Skeleton( bones );

		this.bind( skeleton, this.matrixWorld );

		this.normalizeSkinWeights();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		initBones: function () {

			var bones = [], bone, gbone;
			var i, il;

			if ( this.geometry && this.geometry.bones !== undefined ) {

				// first, create array of 'Bone' objects from geometry data

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					// create new 'Bone' object

					bone = new Bone();
					bones.push( bone );

					// apply values

					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

				}

				// second, create bone hierarchy

				for ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {

					gbone = this.geometry.bones[ i ];

					if ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {

						// subsequent bones in the hierarchy

						bones[ gbone.parent ].add( bones[ i ] );

					} else {

						// topmost bone, immediate child of the skinned mesh

						this.add( bones[ i ] );

					}

				}

			}

			// now the bones are part of the scene graph and children of the skinned mesh.
			// let's update the corresponding matrices

			this.updateMatrixWorld( true );

			return bones;

		},

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			var scale, i;

			if ( this.geometry && this.geometry.isGeometry ) {

				for ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {

					var sw = this.geometry.skinWeights[ i ];

					scale = 1.0 / sw.manhattanLength();

					if ( scale !== Infinity ) {

						sw.multiplyScalar( scale );

					} else {

						sw.set( 1, 0, 0, 0 ); // do something reasonable

					}

				}

			} else if ( this.geometry && this.geometry.isBufferGeometry ) {

				var vec = new Vector4();

				var skinWeight = this.geometry.attributes.skinWeight;

				for ( i = 0; i < skinWeight.count; i ++ ) {

					vec.x = skinWeight.getX( i );
					vec.y = skinWeight.getY( i );
					vec.z = skinWeight.getZ( i );
					vec.w = skinWeight.getW( i );

					scale = 1.0 / vec.manhattanLength();

					if ( scale !== Infinity ) {

						vec.multiplyScalar( scale );

					} else {

						vec.set( 1, 0, 0, 0 ); // do something reasonable

					}

					skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

				}

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.getInverse( this.matrixWorld );

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.getInverse( this.bindMatrix );

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	function LineBasicMaterial( parameters ) {

		Material.call( this );

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.lights = false;

		this.setValues( parameters );

	}

	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	LineBasicMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Line( geometry, material, mode ) {

		if ( mode === 1 ) {

			console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
			return new LineSegments( geometry, material );

		}

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];

						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {

							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );

							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					lineDistances[ 0 ] = 0;

					for ( var i = 1, l = vertices.length; i < l; i ++ ) {

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );

					}

				}

				return this;

			};

		}() ),

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var precision = raycaster.linePrecision;
				var precisionSq = precision * precision;

				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

							var a = indices[ i ];
							var b = indices[ i + 1 ];

							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					} else {

						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );

							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

							if ( distSq > precisionSq ) continue;

							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

							var distance = raycaster.ray.origin.distanceTo( interRay );

							if ( distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this

							} );

						}

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var nbVertices = vertices.length;

					for ( var i = 0; i < nbVertices - 1; i += step ) {

						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: ( function () {

			var start = new Vector3();
			var end = new Vector3();

			return function computeLineDistances() {

				var geometry = this.geometry;

				if ( geometry.isBufferGeometry ) {

					// we assume non-indexed geometry

					if ( geometry.index === null ) {

						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];

						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {

							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );

							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

						}

						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

					} else {

						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

					}

				} else if ( geometry.isGeometry ) {

					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;

					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {

						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );

					}

				}

				return this;

			};

		}() )

	} );

	/**
	 * @author mgreter / http://github.com/mgreter
	 */

	function LineLoop( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineLoop';

	}

	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineLoop,

		isLineLoop: true,

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	function PointsMaterial( parameters ) {

		Material.call( this );

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.lights = false;

		this.setValues( parameters );

	}

	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;

	PointsMaterial.prototype.isPointsMaterial = true;

	PointsMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Points( geometry, material ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		raycast: ( function () {

			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();

			return function raycast( raycaster, intersects ) {

				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;

				// Checking boundingSphere distance to ray

				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;

				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

				//

				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();
				var intersectPoint = new Vector3();

				function testPoint( point, index ) {

					var rayPointDistanceSq = ray.distanceSqToPoint( point );

					if ( rayPointDistanceSq < localThresholdSq ) {

						ray.closestPointToPoint( point, intersectPoint );
						intersectPoint.applyMatrix4( matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectPoint );

						if ( distance < raycaster.near || distance > raycaster.far ) return;

						intersects.push( {

							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object

						} );

					}

				}

				if ( geometry.isBufferGeometry ) {

					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;

					if ( index !== null ) {

						var indices = index.array;

						for ( var i = 0, il = indices.length; i < il; i ++ ) {

							var a = indices[ i ];

							position.fromArray( positions, a * 3 );

							testPoint( position, a );

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

							position.fromArray( positions, i * 3 );

							testPoint( position, i );

						}

					}

				} else {

					var vertices = geometry.vertices;

					for ( var i = 0, l = vertices.length; i < l; i ++ ) {

						testPoint( vertices[ i ], i );

					}

				}

			};

		}() ),

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.generateMipmaps = false;

	}

	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {

		constructor: VideoTexture,

		isVideoTexture: true,

		update: function () {

			var video = this.image;

			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

				this.needsUpdate = true;

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WireframeGeometry( geometry ) {

		BufferGeometry.call( this );

		this.type = 'WireframeGeometry';

		// buffer

		var vertices = [];

		// helper variables

		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;

		// different logic for Geometry and BufferGeometry

		if ( geometry && geometry.isGeometry ) {

			// create a data structure that contains all edges without duplicates

			var faces = geometry.faces;

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( j = 0; j < 3; j ++ ) {

					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );

					key = edge[ 0 ] + ',' + edge[ 1 ];

					if ( edges[ key ] === undefined ) {

						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

					}

				}

			}

			// generate vertices

			for ( key in edges ) {

				e = edges[ key ];

				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else if ( geometry && geometry.isBufferGeometry ) {

			var position, indices, groups;
			var group, start, count;
			var index1, index2;

			vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( o = 0, ol = groups.length; o < ol; ++ o ) {

					group = groups[ o ];

					start = group.start;
					count = group.count;

					for ( i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( j = 0; j < 3; j ++ ) {

							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( key in edges ) {

					e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				position = geometry.attributes.position;

				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;

	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */

	// ParametricGeometry

	function ParametricGeometry( func, slices, stacks ) {

		Geometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();

	}

	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	// ParametricBufferGeometry

	function ParametricBufferGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricBufferGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		var EPS = 0.00001;

		var normal = new Vector3();

		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();

		var i, j;

		if ( func.length < 3 ) {

			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

		}

		// generate vertices, normals and uvs

		var sliceCount = slices + 1;

		for ( i = 0; i <= stacks; i ++ ) {

			var v = i / stacks;

			for ( j = 0; j <= slices; j ++ ) {

				var u = j / slices;

				// vertex

				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( i = 0; i < stacks; i ++ ) {

			for ( j = 0; j < slices; j ++ ) {

				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// PolyhedronGeometry

	function PolyhedronGeometry( vertices, indices, radius, detail ) {

		Geometry.call( this );

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();

	}

	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

	// PolyhedronBufferGeometry

	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

		BufferGeometry.call( this );

		this.type = 'PolyhedronBufferGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		radius = radius || 1;
		detail = detail || 0;

		// default buffer data

		var vertexBuffer = [];
		var uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		appplyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( var i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			var cols = Math.pow( 2, detail );

			// we use this multidimensional array as a data structure for creating the subdivision

			var v = [];

			var i, j;

			// construct all of the vertices for this subdivision

			for ( i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );

				var rows = cols - i;

				for ( j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( i = 0; i < cols; i ++ ) {

				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					var k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function appplyRadius( radius ) {

			var vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			var vertex = new Vector3();

			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( var i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];

				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			var stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();

			var centroid = new Vector3();

			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();

			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				var azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TetrahedronGeometry

	function TetrahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

	// TetrahedronBufferGeometry

	function TetrahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'TetrahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// OctahedronGeometry

	function OctahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;

	// OctahedronBufferGeometry

	function OctahedronBufferGeometry( radius, detail ) {

		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'OctahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// IcosahedronGeometry

	function IcosahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

	// IcosahedronBufferGeometry

	function IcosahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;

		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'IcosahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// DodecahedronGeometry

	function DodecahedronGeometry( radius, detail ) {

		Geometry.call( this );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();

	}

	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

	// DodecahedronBufferGeometry

	function DodecahedronBufferGeometry( radius, detail ) {

		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;

		var vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

		this.type = 'DodecahedronBufferGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */

	// TubeGeometry

	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

		Geometry.call( this );

		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

		// expose internals

		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;

		// create geometry

		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();

	}

	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;

	// TubeBufferGeometry

	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

		BufferGeometry.call( this );

		this.type = 'TubeBufferGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;

		var frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();

		var i, j;

		// buffer

		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( j = 0; j <= radialSegments; j ++ ) {

				var v = j / radialSegments * Math.PI * 2;

				var sin = Math.sin( v );
				var cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( j = 1; j <= tubularSegments; j ++ ) {

				for ( i = 1; i <= radialSegments; i ++ ) {

					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				for ( j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}

	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */

	// TorusKnotGeometry

	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

		Geometry.call( this );

		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();

	}

	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

	// TorusKnotBufferGeometry

	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

		BufferGeometry.call( this );

		this.type = 'TorusKnotBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, j;

		var vertex = new Vector3();
		var normal = new Vector3();

		var P1 = new Vector3();
		var P2 = new Vector3();

		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();

		// generate vertices, normals and uvs

		for ( i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			var u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				// indices

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// TorusGeometry

	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		Geometry.call( this );

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();

	}

	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;

	// TorusBufferGeometry

	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

		BufferGeometry.call( this );

		this.type = 'TorusBufferGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();

		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= radialSegments; j ++ ) {

			for ( i = 0; i <= tubularSegments; i ++ ) {

				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( j = 1; j <= radialSegments; j ++ ) {

			for ( i = 1; i <= tubularSegments; i ++ ) {

				// indices

				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];

			if ( ! outerNode ) return triangles;

			var minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( var i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation

				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order

	function linkedList( data, start, end, dim, clockwise ) {

		var i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points

	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		var p = start, again;

		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)

	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order

		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		var stop = ear, prev, next;

		// iterate through ears, slicing them one by one

		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears

			if ( ear === stop ) {

				// try filtering points and slicing again

				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes

	function isEar( ear ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {

				return false;

			}

			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		var a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed

		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;

		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		// first look for points inside the triangle in increasing z-order

		var p = ear.nextZ;

		while ( p && p.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;

		}

		// then look for points in decreasing z-order

		p = ear.prevZ;

		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;

			p = p.prevZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections

	function cureLocalIntersections( start, triangles, dim ) {

		var p = start;

		do {

			var a = p.prev, b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved

				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return p;

	}

	// try splitting polygon into two and triangulate them independently

	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two

		var a = start;

		do {

			var b = a.next.next;

			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal

					var c = splitPolygon( a, b );

					// filter colinear points around the cuts

					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half

					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes

	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		var queue = [], i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right

		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it

	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );

		if ( outerNode ) {

			var b = splitPolygon( outerNode, hole );

			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon

	function findHoleBridge( hole, outerNode ) {

		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point

		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );

				if ( x <= hx && x > qx ) {

					qx = x;

					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;

		p = m.next;

		while ( p !== stop ) {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		}

		return m;

	}

	// interlink polygon nodes in z-order

	function indexCurve( start, minX, minY, invSize ) {

		var p = start;

		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html

	function sortLinked( list ) {

		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;

				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox

	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range

		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring

	function getLeftmost( start ) {

		var p = start, leftmost = start;

		do {

			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle

	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)

	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );

	}

	// signed area of a triangle

	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal

	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect

	function intersects( p1, q1, p2, q2 ) {

		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;

		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;

	}

	// check if a polygon diagonal intersects any polygon segments

	function intersectsPolygon( a, b ) {

		var p = a;

		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {

				return true;

			}

			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon

	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon

	function middleInside( a, b ) {

		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;

		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {

				inside = ! inside;

			}

			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring

	function splitPolygon( a, b ) {

		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)

	function insertNode( i, x, y, last ) {

		var p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertice index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		var sum = 0;

		for ( var i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			var holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( var i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			var triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( var i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		var l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( var i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	// ExtrudeGeometry

	function ExtrudeGeometry( shapes, options ) {

		Geometry.call( this );

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();

	}

	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

	ExtrudeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	// ExtrudeBufferGeometry

	function ExtrudeBufferGeometry( shapes, options ) {

		BufferGeometry.call( this );

		this.type = 'ExtrudeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		var scope = this;

		var verticesArray = [];
		var uvArray = [];

		for ( var i = 0, l = shapes.length; i < l; i ++ ) {

			var shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			var placeholder = [];

			// options

			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			var steps = options.steps !== undefined ? options.steps : 1;
			var depth = options.depth !== undefined ? options.depth : 100;

			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			var extrudePath = options.extrudePath;

			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			var extrudePts, extrudeByPath = false;
			var splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;

			}

			// Variables initialization

			var ahole, h, hl; // looping of holes

			var shapePoints = shape.extractPoints( curveSegments );

			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;

			var reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			var faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			var contour = vertices; // vertices has all points but contour has only points of circumference

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					var direction_eq = false; // assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			var contourMovements = [];

			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( h = 0, hl = holes.length; h < hl; h ++ ) {

				ahole = holes[ h ];

				oneHoleMovements = [];

				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			bs = bevelSize;

			// Back facing vertices

			for ( i = 0; i < vlen; i ++ ) {

				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			var s;

			for ( s = 1; s <= steps; s ++ ) {

				for ( i = 0; i < vlen; i ++ ) {

					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {

				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );

				// contract shape

				for ( i = 0, il = contour.length; i < il; i ++ ) {

					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( i = 0, il = ahole.length; i < il; i ++ ) {

						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				var start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					var layer = 0; // steps + 1
					var offset = vlen * layer;

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( i = 0; i < flen; i ++ ) {

						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				var start = verticesArray.length / 3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( h = 0, hl = holes.length; h < hl; h ++ ) {

					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				var j, k;
				i = contour.length;

				while ( -- i >= 0 ) {

					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					var s = 0,
						sl = steps + bevelSegments * 2;

					for ( s = 0; s < sl; s ++ ) {

						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );

						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;

	ExtrudeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;
		var options = this.parameters.options;

		return toJSON( shapes, options, data );

	};

	//

	var WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}
	};

	function toJSON( shapes, options, data ) {

		//

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		//

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */

	// TextGeometry

	function TextGeometry( text, parameters ) {

		Geometry.call( this );

		this.type = 'TextGeometry';

		this.parameters = {
			text: text,
			parameters: parameters
		};

		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();

	}

	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;

	// TextBufferGeometry

	function TextBufferGeometry( text, parameters ) {

		parameters = parameters || {};

		var font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();

		}

		var shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		ExtrudeBufferGeometry.call( this, shapes, parameters );

		this.type = 'TextBufferGeometry';

	}

	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// SphereGeometry

	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = thetaStart + thetaLength;

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.set( vertex.x, vertex.y, vertex.z ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// RingGeometry

	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;

	// RingBufferGeometry

	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'RingBufferGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// some helper variables

		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;

		// generate vertices, normals and uvs

		for ( j = 0; j <= phiSegments; j ++ ) {

			for ( i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( j = 0; j < phiSegments; j ++ ) {

			var thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( i = 0; i < thetaSegments; i ++ ) {

				segment = i + thetaSegmentLevel;

				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;

	/**
	 * @author astrodud / http://astrodud.isgreat.org/
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// LatheGeometry

	function LatheGeometry( points, segments, phiStart, phiLength ) {

		Geometry.call( this );

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();

	}

	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;

	// LatheBufferGeometry

	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

		BufferGeometry.call( this );

		this.type = 'LatheBufferGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );


		// buffers

		var indices = [];
		var vertices = [];
		var uvs = [];

		// helper variables

		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;

		// generate vertices and uvs

		for ( i = 0; i <= segments; i ++ ) {

			var phi = phiStart + i * inverseSegments * phiLength;

			var sin = Math.sin( phi );
			var cos = Math.cos( phi );

			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( i = 0; i < segments; i ++ ) {

			for ( j = 0; j < ( points.length - 1 ); j ++ ) {

				base = j + i * points.length;

				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();

			// this is the buffer offset for the last line of vertices

			base = segments * points.length * 3;

			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// ShapeGeometry

	function ShapeGeometry( shapes, curveSegments ) {

		Geometry.call( this );

		this.type = 'ShapeGeometry';

		if ( typeof curveSegments === 'object' ) {

			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

			curveSegments = curveSegments.curveSegments;

		}

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();

	}

	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;

	ShapeGeometry.prototype.toJSON = function () {

		var data = Geometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	// ShapeBufferGeometry

	function ShapeBufferGeometry( shapes, curveSegments ) {

		BufferGeometry.call( this );

		this.type = 'ShapeBufferGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		curveSegments = curveSegments || 12;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var groupStart = 0;
		var groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( var i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			var i, l, shapeHole;

			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );

			var shapeVertices = points.shape;
			var shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

				// also check if holes are in the opposite direction

				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

					shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

			}

			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

				var vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

	ShapeBufferGeometry.prototype.toJSON = function () {

		var data = BufferGeometry.prototype.toJSON.call( this );

		var shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	};

	//

	function toJSON$1( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( var i = 0, l = shapes.length; i < l; i ++ ) {

				var shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function EdgesGeometry( geometry, thresholdAngle ) {

		BufferGeometry.call( this );

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		// buffer

		var vertices = [];

		// helper variables

		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];

		// prepare source geometry

		var geometry2;

		if ( geometry.isBufferGeometry ) {

			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );

		} else {

			geometry2 = geometry.clone();

		}

		geometry2.mergeVertices();
		geometry2.computeFaceNormals();

		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;

		// now create a data structure where each entry represents an edge with its adjoining faces

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );

				key = edge[ 0 ] + ',' + edge[ 1 ];

				if ( edges[ key ] === undefined ) {

					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };

				} else {

					edges[ key ].face2 = i;

				}

			}

		}

		// generate vertices

		for ( key in edges ) {

			var e = edges[ key ];

			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {

				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		// build geometry

		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// CylinderGeometry

	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;

	// CylinderBufferGeometry

	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CylinderBufferGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		var scope = this;

		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;

		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;

		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();

			var groupCount = 0;

			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( y = 0; y <= heightSegments; y ++ ) {

				var indexRow = [];

				var v = y / heightSegments;

				// calculate the radius of the current row

				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( x = 0; x <= radialSegments; x ++ ) {

					var u = x / radialSegments;

					var theta = u * thetaLength + thetaStart;

					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				for ( y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			var x, centerIndexStart, centerIndexEnd;

			var uv = new Vector2();
			var vertex = new Vector3();

			var groupCount = 0;

			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;

			// save the index of the first center vertex
			centerIndexStart = index;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex

			centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;

				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( x = 0; x < radialSegments; x ++ ) {

				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	// ConeGeometry

	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;

	// ConeBufferGeometry

	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeBufferGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */

	// CircleGeometry

	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

		Geometry.call( this );

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();

	}

	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;

	// CircleBufferGeometry

	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'CircleBufferGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// helper variables

		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			var segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;



	var Geometries = /*#__PURE__*/Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	function ShadowMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShadowMaterial';

		this.color = new Color( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;

	ShadowMaterial.prototype.isShadowMaterial = true;

	ShadowMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = { 'PHYSICAL': '' };

		this.type = 'MeshPhysicalMaterial';

		this.reflectivity = 0.5; // maps to F0 = 0.04

		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = { 'PHYSICAL': '' };

		this.reflectivity = source.reflectivity;

		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshPhongMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshPhongMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	MeshPhongMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshToonMaterial( parameters ) {

		MeshPhongMaterial.call( this );

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.gradientMap = null;

		this.setValues( parameters );

	}

	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	MeshToonMaterial.prototype.copy = function ( source ) {

		MeshPhongMaterial.prototype.copy.call( this, source );

		this.gradientMap = source.gradientMap;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshNormalMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;
		this.lights = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	MeshNormalMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshLambertMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	MeshLambertMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	function LineDashedMaterial( parameters ) {

		LineBasicMaterial.call( this );

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	LineDashedMaterial.prototype.copy = function ( source ) {

		LineBasicMaterial.prototype.copy.call( this, source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	};



	var Materials = /*#__PURE__*/Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;
			return this;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FileLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = window.decodeURIComponent( data );

				if ( isBase64 ) data = window.atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					window.setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					Cache.add( url, response );

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemEnd( url );
						scope.manager.itemError( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */

	function CompressedTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( CompressedTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope._parser( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */

	function DataTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		// override in sub classes
		this._parser = null;

	}

	Object.assign( DataTextureLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texture = new DataTexture();

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );

			loader.load( url, function ( buffer ) {

				var texData = scope._parser( buffer );

				if ( ! texData ) return;

				if ( undefined !== texData.image ) {

					texture.image = texData.image;

				} else if ( undefined !== texData.data ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
				texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

				texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

				if ( undefined !== texData.format ) {

					texture.format = texData.format;

				}
				if ( undefined !== texData.type ) {

					texture.type = texData.type;

				}

				if ( undefined !== texData.mipmaps ) {

					texture.mipmaps = texData.mipmaps;

				}

				if ( 1 === texData.mipmapCount ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function ImageLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( ImageLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function CubeTextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( CubeTextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( urls, onLoad, onProgress, onError ) {

			var texture = new CubeTexture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			var loaded = 0;

			function loadTexture( i ) {

				loader.load( urls[ i ], function ( image ) {

					texture.images[ i ] = image;

					loaded ++;

					if ( loaded === 6 ) {

						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, undefined, onError );

			}

			for ( var i = 0; i < urls.length; ++ i ) {

				loadTexture( i );

			}

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function TextureLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( TextureLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = /*#__PURE__*/Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = _Math.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Light( color, intensity ) {

		Object3D.call( this );

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;

		this.receiveShadow = undefined;

	}

	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Light,

		isLight: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function HemisphereLight( skyColor, groundColor, intensity ) {

		Light.call( this, skyColor, intensity );

		this.type = 'HemisphereLight';

		this.castShadow = undefined;

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color( groundColor );

	}

	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: HemisphereLight,

		isHemisphereLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LightShadow( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.matrix = new Matrix4();

	}

	Object.assign( LightShadow.prototype, {

		copy: function ( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function SpotLightShadow() {

		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

	}

	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: SpotLightShadow,

		isSpotLightShadow: true,

		update: function ( light ) {

			var camera = this.camera;

			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

		Light.call( this, color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: SpotLight,

		isSpotLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */


	function PointLight( color, intensity, distance, decay ) {

		Light.call( this, color, intensity );

		this.type = 'PointLight';

		Object.defineProperty( this, 'power', {
			get: function () {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;

			},
			set: function ( power ) {

				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / ( 4 * Math.PI );

			}
		} );

		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

	}

	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: PointLight,

		isPointLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function DirectionalLightShadow( ) {

		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

		constructor: DirectionalLightShadow

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DirectionalLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: DirectionalLight,

		isDirectionalLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AmbientLight( color, intensity ) {

		Light.call( this, color, intensity );

		this.type = 'AmbientLight';

		this.castShadow = undefined;

	}

	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: AmbientLight,

		isAmbientLight: true

	} );

	/**
	 * @author abelnation / http://github.com/abelnation
	 */

	function RectAreaLight( color, intensity, width, height ) {

		Light.call( this, color, intensity );

		this.type = 'RectAreaLight';

		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;

	}

	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

		constructor: RectAreaLight,

		isRectAreaLight: true,

		copy: function ( source ) {

			Light.prototype.copy.call( this, source );

			this.width = source.width;
			this.height = source.height;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Light.prototype.toJSON.call( this, meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	} );

	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function StringKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: StringKeyframeTrack,

		ValueTypeName: 'string',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,

		InterpolantFactoryMethodSmooth: undefined

	} );

	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function BooleanKeyframeTrack( name, times, values ) {

		KeyframeTrack.call( this, name, times, values );

	}

	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: BooleanKeyframeTrack,

		ValueTypeName: 'bool',
		ValueBufferType: Array,

		DefaultInterpolation: InterpolateDiscrete,

		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined

		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".

	} );

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset = i1 * stride,

				alpha = ( t - t0 ) / ( t1 - t0 );

			for ( var end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function QuaternionKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: QuaternionKeyframeTrack,

		ValueTypeName: 'quaternion',

		// ValueBufferType is inherited

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodLinear: function ( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: undefined // not yet implemented

	} );

	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function ColorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: ColorKeyframeTrack,

		ValueTypeName: 'color'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.

	} );

	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function NumberKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: NumberKeyframeTrack,

		ValueTypeName: 'number'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
					! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
					! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		}

	};

	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function KeyframeTrack( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

		this.validate();
		this.optimize();

	}

	// Static methods:

	Object.assign( KeyframeTrack, {

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		parse: function ( json ) {

			if ( json.type === undefined ) {

				throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

			}

			var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

			if ( json.times === undefined ) {

				var times = [], values = [];

				AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

				json.times = times;
				json.values = values;

			}

			// derived classes can define a static parse method
			if ( trackType.parse !== undefined ) {

				return trackType.parse( json );

			} else {

				// by default, we assume a constructor compatible with the base
				return new trackType( json.name, json.times, json.values, json.interpolation );

			}

		},

		toJSON: function ( track ) {

			var trackType = track.constructor;

			var json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				var interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		},

		_getTrackTypeForValueTypeName: function ( typeName ) {

			switch ( typeName.toLowerCase() ) {

				case 'scalar':
				case 'double':
				case 'float':
				case 'number':
				case 'integer':

					return NumberKeyframeTrack;

				case 'vector':
				case 'vector2':
				case 'vector3':
				case 'vector4':

					return VectorKeyframeTrack;

				case 'color':

					return ColorKeyframeTrack;

				case 'quaternion':

					return QuaternionKeyframeTrack;

				case 'bool':
				case 'boolean':

					return BooleanKeyframeTrack;

				case 'string':

					return StringKeyframeTrack;

			}

			throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

		}

	} );

	Object.assign( KeyframeTrack.prototype, {

		constructor: KeyframeTrack,

		TimeBufferType: Float32Array,

		ValueBufferType: Float32Array,

		DefaultInterpolation: InterpolateLinear,

		InterpolantFactoryMethodDiscrete: function ( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodLinear: function ( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		InterpolantFactoryMethodSmooth: function ( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		},

		setInterpolation: function ( interpolation ) {

			var factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return;

			}

			this.createInterpolant = factoryMethod;

		},

		getInterpolation: function () {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		},

		getValueSize: function () {

			return this.values.length / this.times.length;

		},

		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		},

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {

			if ( timeScale !== 1.0 ) {

				var times = this.times;

				for ( var i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		},

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {

			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		},

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {

			var valid = true;

			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			var times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			var prevTime = null;

			for ( var i = 0; i !== nKeys; i ++ ) {

				var currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( var i = 0, n = values.length; i !== n; ++ i ) {

						var value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		},

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {

			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				writeIndex = 1,
				lastIndex = times.length - 1;

			for ( var i = 1; i < lastIndex; ++ i ) {

				var keep = false;

				var time = times[ i ];
				var timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( var j = 0; j !== stride; ++ j ) {

							var value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						var readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( var j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			}

			return this;

		}

	} );

	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function VectorKeyframeTrack( name, times, values, interpolation ) {

		KeyframeTrack.call( this, name, times, values, interpolation );

	}

	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {

		constructor: VectorKeyframeTrack,

		ValueTypeName: 'vector'

		// ValueBufferType is inherited

		// DefaultInterpolation is inherited

	} );

	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	function AnimationClip( name, duration, tracks ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;

		this.uuid = _Math.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

		this.optimize();

	}

	Object.assign( AnimationClip, {

		parse: function ( json ) {

			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

			}

			return new AnimationClip( json.name, json.duration, tracks );

		},

		toJSON: function ( clip ) {

			var tracks = [],
				clipTracks = clip.tracks;

			var json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid

			};

			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		},

		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];

			for ( var i = 0; i < numMorphTargets; i ++ ) {

				var times = [];
				var values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new AnimationClip( name, - 1, tracks );

		},

		findByName: function ( objectOrClipArray, name ) {

			var clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( var i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		},

		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

			var animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					var name = parts[ 1 ];

					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			var clips = [];

			for ( var name in animationToMorphTargets ) {

				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		},

		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					var times = [];
					var values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			var tracks = [];

			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;

			var hierarchyTracks = animation.hierarchy || [];

			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

				var animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					var morphTargetNames = {};

					for ( var k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {

						var times = [];
						var values = [];

						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							var animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					var boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			var clip = new AnimationClip( clipName, duration, tracks );

			return clip;

		}

	} );

	Object.assign( AnimationClip.prototype, {

		resetDuration: function () {

			var tracks = this.tracks, duration = 0;

			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

				var track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

		},

		trim: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		},

		optimize: function () {

			for ( var i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function MaterialLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};

	}

	Object.assign( MaterialLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		setTextures: function ( value ) {

			this.textures = value;

		},

		parse: function ( json ) {

			var textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			var material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );

			if ( json.alphaMap !== undefined ) {

				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;

			}

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {

				var normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			return material;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function BufferGeometryLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( BufferGeometryLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var geometry = new BufferGeometry();

			var index = json.data.index;

			if ( index !== undefined ) {

				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			var attributes = json.data.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

				geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

			}

			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( var i = 0, n = groups.length; i !== n; ++ i ) {

					var group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			var boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				var center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			return geometry;

		}

	} );

	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader() {}

	Loader.Handlers = {

		handlers: [],

		add: function ( regex, loader ) {

			this.handlers.push( regex, loader );

		},

		get: function ( file ) {

			var handlers = this.handlers;

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		}

	};

	Object.assign( Loader.prototype, {

		crossOrigin: 'anonymous',

		onLoadStart: function () {},

		onLoadProgress: function () {},

		onLoadComplete: function () {},

		initMaterials: function ( materials, texturePath, crossOrigin ) {

			var array = [];

			for ( var i = 0; i < materials.length; ++ i ) {

				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

			}

			return array;

		},

		createMaterial: ( function () {

			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};

			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();

			return function createMaterial( m, texturePath, crossOrigin ) {

				// convert from old material format

				var textures = {};

				function loadTexture( path, repeat, offset, wrap, anisotropy ) {

					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );

					var texture;

					if ( loader !== null ) {

						texture = loader.load( fullPath );

					} else {

						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );

					}

					if ( repeat !== undefined ) {

						texture.repeat.fromArray( repeat );

						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

					}

					if ( offset !== undefined ) {

						texture.offset.fromArray( offset );

					}

					if ( wrap !== undefined ) {

						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

					}

					if ( anisotropy !== undefined ) {

						texture.anisotropy = anisotropy;

					}

					var uuid = _Math.generateUUID();

					textures[ uuid ] = texture;

					return uuid;

				}

				//

				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};

				for ( var name in m ) {

					var value = m[ name ];

					switch ( name ) {

						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = value;
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;

					}

				}

				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

				if ( json.opacity < 1 ) json.transparent = true;

				materialLoader.setTextures( textures );

				return materialLoader.parse( json );

			};

		} )()

	} );

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );

		},

		extractUrlBase: function ( url ) {

			var index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.substr( 0, index + 1 );

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function JSONLoader( manager ) {

		if ( typeof manager === 'boolean' ) {

			console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
			manager = undefined;

		}

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.withCredentials = false;

	}

	Object.assign( JSONLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );

			var loader = new FileLoader( this.manager );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				var json = JSON.parse( text );
				var metadata = json.metadata;

				if ( metadata !== undefined ) {

					var type = metadata.type;

					if ( type !== undefined ) {

						if ( type.toLowerCase() === 'object' ) {

							console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
							return;

						}

					}

				}

				var object = scope.parse( json, texturePath );
				onLoad( object.geometry, object.materials );

			}, onProgress, onError );

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;
			return this;

		},

		parse: ( function () {

			function parseModel( json, geometry ) {

				function isBitSet( value, position ) {

					return value & ( 1 << position );

				}

				var i, j, fi,

					offset, zLength,

					colorIndex, normalIndex, uvIndex, materialIndex,

					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,

					vertex, face, faceA, faceB, hex, normal,

					uvLayer, uv, u, v,

					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,

					scale = json.scale,

					nUvLayers = 0;


				if ( json.uvs !== undefined ) {

					// disregard empty arrays

					for ( i = 0; i < json.uvs.length; i ++ ) {

						if ( json.uvs[ i ].length ) nUvLayers ++;

					}

					for ( i = 0; i < nUvLayers; i ++ ) {

						geometry.faceVertexUvs[ i ] = [];

					}

				}

				offset = 0;
				zLength = vertices.length;

				while ( offset < zLength ) {

					vertex = new Vector3();

					vertex.x = vertices[ offset ++ ] * scale;
					vertex.y = vertices[ offset ++ ] * scale;
					vertex.z = vertices[ offset ++ ] * scale;

					geometry.vertices.push( vertex );

				}

				offset = 0;
				zLength = faces.length;

				while ( offset < zLength ) {

					type = faces[ offset ++ ];

					isQuad = isBitSet( type, 0 );
					hasMaterial = isBitSet( type, 1 );
					hasFaceVertexUv = isBitSet( type, 3 );
					hasFaceNormal = isBitSet( type, 4 );
					hasFaceVertexNormal = isBitSet( type, 5 );
					hasFaceColor = isBitSet( type, 6 );
					hasFaceVertexColor = isBitSet( type, 7 );

					// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

					if ( isQuad ) {

						faceA = new Face3();
						faceA.a = faces[ offset ];
						faceA.b = faces[ offset + 1 ];
						faceA.c = faces[ offset + 3 ];

						faceB = new Face3();
						faceB.a = faces[ offset + 1 ];
						faceB.b = faces[ offset + 2 ];
						faceB.c = faces[ offset + 3 ];

						offset += 4;

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							faceA.materialIndex = materialIndex;
							faceB.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];
								geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

								for ( j = 0; j < 4; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
									if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							faceA.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							faceB.normal.copy( faceA.normal );

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 4; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);


								if ( i !== 2 ) faceA.vertexNormals.push( normal );
								if ( i !== 0 ) faceB.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							faceA.color.setHex( hex );
							faceB.color.setHex( hex );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 4; i ++ ) {

								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];

								if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
								if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

							}

						}

						geometry.faces.push( faceA );
						geometry.faces.push( faceB );

					} else {

						face = new Face3();
						face.a = faces[ offset ++ ];
						face.b = faces[ offset ++ ];
						face.c = faces[ offset ++ ];

						if ( hasMaterial ) {

							materialIndex = faces[ offset ++ ];
							face.materialIndex = materialIndex;

						}

						// to get face <=> uv index correspondence

						fi = geometry.faces.length;

						if ( hasFaceVertexUv ) {

							for ( i = 0; i < nUvLayers; i ++ ) {

								uvLayer = json.uvs[ i ];

								geometry.faceVertexUvs[ i ][ fi ] = [];

								for ( j = 0; j < 3; j ++ ) {

									uvIndex = faces[ offset ++ ];

									u = uvLayer[ uvIndex * 2 ];
									v = uvLayer[ uvIndex * 2 + 1 ];

									uv = new Vector2( u, v );

									geometry.faceVertexUvs[ i ][ fi ].push( uv );

								}

							}

						}

						if ( hasFaceNormal ) {

							normalIndex = faces[ offset ++ ] * 3;

							face.normal.set(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

						}

						if ( hasFaceVertexNormal ) {

							for ( i = 0; i < 3; i ++ ) {

								normalIndex = faces[ offset ++ ] * 3;

								normal = new Vector3(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);

								face.vertexNormals.push( normal );

							}

						}


						if ( hasFaceColor ) {

							colorIndex = faces[ offset ++ ];
							face.color.setHex( colors[ colorIndex ] );

						}


						if ( hasFaceVertexColor ) {

							for ( i = 0; i < 3; i ++ ) {

								colorIndex = faces[ offset ++ ];
								face.vertexColors.push( new Color( colors[ colorIndex ] ) );

							}

						}

						geometry.faces.push( face );

					}

				}

			}

			function parseSkin( json, geometry ) {

				var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

				if ( json.skinWeights ) {

					for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

						var x = json.skinWeights[ i ];
						var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
						var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
						var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

						geometry.skinWeights.push( new Vector4( x, y, z, w ) );

					}

				}

				if ( json.skinIndices ) {

					for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

						var a = json.skinIndices[ i ];
						var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
						var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
						var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

						geometry.skinIndices.push( new Vector4( a, b, c, d ) );

					}

				}

				geometry.bones = json.bones;

				if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

					console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
						geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

				}

			}

			function parseMorphing( json, geometry ) {

				var scale = json.scale;

				if ( json.morphTargets !== undefined ) {

					for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

						geometry.morphTargets[ i ] = {};
						geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
						geometry.morphTargets[ i ].vertices = [];

						var dstVertices = geometry.morphTargets[ i ].vertices;
						var srcVertices = json.morphTargets[ i ].vertices;

						for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

							var vertex = new Vector3();
							vertex.x = srcVertices[ v ] * scale;
							vertex.y = srcVertices[ v + 1 ] * scale;
							vertex.z = srcVertices[ v + 2 ] * scale;

							dstVertices.push( vertex );

						}

					}

				}

				if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

					console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

					var faces = geometry.faces;
					var morphColors = json.morphColors[ 0 ].colors;

					for ( var i = 0, l = faces.length; i < l; i ++ ) {

						faces[ i ].color.fromArray( morphColors, i * 3 );

					}

				}

			}

			function parseAnimations( json, geometry ) {

				var outputAnimations = [];

				// parse old style Bone/Hierarchy animations
				var animations = [];

				if ( json.animation !== undefined ) {

					animations.push( json.animation );

				}

				if ( json.animations !== undefined ) {

					if ( json.animations.length ) {

						animations = animations.concat( json.animations );

					} else {

						animations.push( json.animations );

					}

				}

				for ( var i = 0; i < animations.length; i ++ ) {

					var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
					if ( clip ) outputAnimations.push( clip );

				}

				// parse implicit morph animations
				if ( geometry.morphTargets ) {

					// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
					var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
					outputAnimations = outputAnimations.concat( morphAnimationClips );

				}

				if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

			}

			return function parse( json, texturePath ) {

				if ( json.data !== undefined ) {

					// Geometry 4.0 spec
					json = json.data;

				}

				if ( json.scale !== undefined ) {

					json.scale = 1.0 / json.scale;

				} else {

					json.scale = 1.0;

				}

				var geometry = new Geometry();

				parseModel( json, geometry );
				parseSkin( json, geometry );
				parseMorphing( json, geometry );
				parseAnimations( json, geometry );

				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();

				if ( json.materials === undefined || json.materials.length === 0 ) {

					return { geometry: geometry };

				} else {

					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

					return { geometry: geometry, materials: materials };

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ObjectLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.texturePath = '';

	}

	Object.assign( ObjectLoader.prototype, {

		crossOrigin: 'anonymous',

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.texturePath === '' ) {

				this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

			}

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.load( url, function ( text ) {

				var json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				var metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		},

		setTexturePath: function ( value ) {

			this.texturePath = value;
			return this;

		},

		setCrossOrigin: function ( value ) {

			this.crossOrigin = value;
			return this;

		},

		parse: function ( json, onLoad ) {

			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );

			var images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );

			var object = this.parseObject( json.object, geometries, materials );

			if ( json.animations ) {

				object.animations = this.parseAnimations( json.animations );

			}

			if ( json.images === undefined || json.images.length === 0 ) {

				if ( onLoad !== undefined ) onLoad( object );

			}

			return object;

		},

		parseShape: function ( json ) {

			var shapes = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		},

		parseGeometries: function ( json, shapes ) {

			var geometries = {};

			if ( json !== undefined ) {

				var geometryLoader = new JSONLoader();
				var bufferGeometryLoader = new BufferGeometryLoader();

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var geometry;
					var data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;


						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':

							var geometryShapes = [];

							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								var shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							var extrudePath = data.options.extrudePath;

							if ( extrudePath !== undefined ) {

								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);

							break;

						case 'BufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							geometry = geometryLoader.parse( data, this.texturePath ).geometry;

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		},

		parseMaterials: function ( json, textures ) {

			var materials = {};

			if ( json !== undefined ) {

				var loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						var array = [];

						for ( var j = 0; j < data.materials.length; j ++ ) {

							array.push( loader.parse( data.materials[ j ] ) );

						}

						materials[ data.uuid ] = array;

					} else {

						materials[ data.uuid ] = loader.parse( data );

					}

				}

			}

			return materials;

		},

		parseAnimations: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var data = json[ i ];

				var clip = AnimationClip.parse( data );

				if ( data.uuid !== undefined ) clip.uuid = data.uuid;

				animations.push( clip );

			}

			return animations;

		},

		parseImages: function ( json, onLoad ) {

			var scope = this;
			var images = {};

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemEnd( url );
					scope.manager.itemError( url );

				} );

			}

			if ( json !== undefined && json.length > 0 ) {

				var manager = new LoadingManager( onLoad );

				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( var i = 0, il = json.length; i < il; i ++ ) {

					var image = json[ i ];
					var url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						images[ image.uuid ] = [];

						for ( var j = 0, jl = url.length; j < jl; j ++ ) {

							var currentUrl = url[ j ];

							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.texturePath + currentUrl;

							images[ image.uuid ].push( loadImage( path ) );

						}

					} else {

						// load single image

						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

						images[ image.uuid ] = loadImage( path );

					}

				}

			}

			return images;

		},

		parseTextures: function ( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			var textures = {};

			if ( json !== undefined ) {

				for ( var i = 0, l = json.length; i < l; i ++ ) {

					var data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					var texture;

					if ( Array.isArray( images[ data.image ] ) ) {

						texture = new CubeTexture( images[ data.image ] );

					} else {

						texture = new Texture( images[ data.image ] );

					}

					texture.needsUpdate = true;

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.format !== undefined ) texture.format = data.format;

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		},

		parseObject: function ( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					var array = [];

					for ( var i = 0, l = name.length; i < l; i ++ ) {

						var uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;

			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );

				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;

			if ( data.children !== undefined ) {

				var children = data.children;

				for ( var i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

	} );

	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};

	/**
	 * @author thespite / http://clicktorelease.com/
	 */


	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;

	}

	ImageBitmapLoader.prototype = {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				return createImageBitmap( blob, scope.options );

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemEnd( url );
				scope.manager.itemError( url );

			} );

		},

		setCrossOrigin: function ( /* value */ ) {

			return this;

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */


	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size ) {

			if ( size === undefined ) size = 100;

			var shapes = [];
			var paths = createPaths( text, size, this.data );

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	function createPaths( text, size, data ) {

		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

		var paths = [];

		var offsetX = 0, offsetY = 0;

		for ( var i = 0; i < chars.length; i ++ ) {

			var char = chars[ i ];

			if ( char === '\n' ) {

				offsetX = 0;
				offsetY -= line_height;

			} else {

				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );

			}

		}

		return paths;

	}

	function createPath( char, scale, offsetX, offsetY, data ) {

		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

		if ( ! glyph ) return;

		var path = new ShapePath();

		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if ( glyph.o ) {

			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

			for ( var i = 0, l = outline.length; i < l; ) {

				var action = outline[ i ++ ];

				switch ( action ) {

					case 'm': // moveTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.moveTo( x, y );

						break;

					case 'l': // lineTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.lineTo( x, y );

						break;

					case 'q': // quadraticCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						break;

					case 'b': // bezierCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						break;

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path };

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function FontLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( FontLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {

				var json;

				try {

					json = JSON.parse( text );

				} catch ( e ) {

					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );

				}

				var font = scope.parse( json );

				if ( onLoad ) onLoad( font );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			return new Font( json );

		},

		setPath: function ( value ) {

			this.path = value;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var context;

	var AudioContext = {

		getContext: function () {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function AudioLoader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	}

	Object.assign( AudioLoader.prototype, {

		load: function ( url, onLoad, onProgress, onError ) {

			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.load( url, function ( buffer ) {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );

				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			}, onProgress, onError );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

	}

	Object.assign( StereoCamera.prototype, {

		update: ( function () {

			var instance, focus, fov, aspect, near, far, zoom, eyeSep;

			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();

			return function update( camera ) {

				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;

				if ( needsUpdate ) {

					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;

					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/

					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;

					// translate xOffset

					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;

					// for left eye

					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraL.projectionMatrix.copy( projectionMatrix );

					// for right eye

					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;

					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

					this.cameraR.projectionMatrix.copy( projectionMatrix );

				}

				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

			};

		} )()

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CubeCamera( near, far, cubeResolution ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var fov = 90, aspect = 1;

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );

			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );

			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );

			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );

			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );

			renderer.setRenderTarget( null );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget( renderTarget );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( null );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

			return this;

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

			return this;

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var listener = this.context.listener;
				var up = this.up;

				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

				if ( listener.positionX ) {

					listener.positionX.setValueAtTime( position.x, this.context.currentTime );
					listener.positionY.setValueAtTime( position.y, this.context.currentTime );
					listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
					listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
					listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
					listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
					listener.upX.setValueAtTime( up.x, this.context.currentTime );
					listener.upY.setValueAtTime( up.y, this.context.currentTime );
					listener.upZ.setValueAtTime( up.z, this.context.currentTime );

				} else {

					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

				}

			};

		} )()

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setMediaElementSource: function ( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function () {

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			var source = this.context.createBufferSource();

			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );

			this.isPlaying = true;

			this.source = source;

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this.source.stop();
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.source.stop();
			this.offset = 0;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

			return this;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

			return this;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

			return this;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

			return this;

		},

		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;

		},

		updateMatrixWorld: ( function () {

			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();

			var orientation = new Vector3();

			return function updateMatrixWorld( force ) {

				Object3D.prototype.updateMatrixWorld.call( this, force );

				var panner = this.panner;
				this.matrixWorld.decompose( position, quaternion, scale );

				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );

				panner.setPosition( position.x, position.y, position.z );
				panner.setOrientation( orientation.x, orientation.y, orientation.z );

			};

		} )()


	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function PropertyMixer( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		var bufferType = Float64Array,
			mixFunction;

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				break;

			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;

			default:
				mixFunction = this._lerp;

		}

		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property

		this._mixBufferRegion = mixFunction;

		this.cumulativeWeight = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	Object.assign( PropertyMixer.prototype, {

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,

				currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		},

		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {

			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,

				binding = this.binding;

			this.cumulativeWeight = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				var originalValueOffset = stride * 3;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		},

		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {

			var binding = this.binding;

			var buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * 3;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			this.cumulativeWeight = 0;

		},

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {

			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		},


		// mix functions

		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( var i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		},

		_slerp: function ( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		},

		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

			var s = 1 - t;

			for ( var i = 0; i !== stride; ++ i ) {

				var j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

	} );

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';

	function Composite( targetGroup, path, optionalParsedPath ) {

		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			var bindings = this._bindings;

			for ( var i = this._targetGroup.nCachedObjects_,
					  n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {

			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );

			return function sanitizeNodeName( name ) {

				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );

			};

		}() ),

		parseTrackName: function () {

			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );

			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );

			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );

			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );

			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);

			var supportedObjectNames = [ 'material', 'materials', 'bones' ];

			return function parseTrackName( trackName ) {

				var matches = trackRe.exec( trackName );

				if ( ! matches ) {

					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

				}

				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};

				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

				if ( lastDot !== undefined && lastDot !== - 1 ) {

					var objectName = results.nodeName.substring( lastDot + 1 );

					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {

						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;

					}

				}

				if ( results.propertyName === null || results.propertyName.length === 0 ) {

					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

				}

				return results;

			};

		}(),

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;
				this.targetObject = targetObject;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;
				this.targetObject = targetObject;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						if ( ! targetObject.geometry.morphTargets ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 * 	-	Add objects you would otherwise pass as 'root' to the
	 * 		constructor or the .clipAction method of AnimationMixer.
	 *
	 * 	-	Instead pass this object as 'root'.
	 *
	 * 	-	You can also add and remove objects later when the mixer
	 * 		is running.
	 *
	 * Note:
	 *
	 *  	Objects of this class appear as one object to the mixer,
	 *  	so cache control of the individual objects must be done
	 *  	on the group.
	 *
	 * Limitation:
	 *
	 * 	- 	The animated properties must be compatible among the
	 * 		all objects in the group.
	 *
	 *  -	A single property can either be controlled through a
	 *  	target group or directly, but not both.
	 *
	 * @author tschw
	 */

	function AnimationObjectGroup() {

		this.uuid = _Math.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0;			// threshold
		// note: read by PropertyBinding.Composite

		var indices = {};
		this._indicesByUUID = indices;		// for bookkeeping

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = [];					// inside: string
		this._parsedPaths = [];				// inside: { we don't care, here }
		this._bindings = []; 				// inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

		var scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	Object.assign( AnimationObjectGroup.prototype, {

		isAnimationObjectGroup: true,

		add: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
							'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		remove: function () {

			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// remove & forget
		uncache: function () {

			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( var j = 0, m = nBindings; j !== m; ++ j ) {

							var bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		},

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_: function ( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		},

		unsubscribe_: function ( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	} );

	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */

	function AnimationAction( mixer, clip, localRoot ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;

		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( var i = 0; i !== nTracks; ++ i ) {

			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants;	// bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null;			// for the memory manager
		this._byClipCacheIndex = null;		// for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; 		// no. of repetitions when looping

		this.paused = false;				// true -> zero effective time scale
		this.enabled = true;				// false -> zero effective weight

		this.clampWhenFinished 	= false;	// keep feeding the last frame?

		this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

	}

	Object.assign( AnimationAction.prototype, {

		// State & Scheduling

		play: function () {

			this._mixer._activateAction( this );

			return this;

		},

		stop: function () {

			this._mixer._deactivateAction( this );

			return this.reset();

		},

		reset: function () {

			this.paused = false;
			this.enabled = true;

			this.time = 0;			// restart clip
			this._loopCount = - 1;	// forget previous loops
			this._startTime = null;	// forget scheduling

			return this.stopFading().stopWarping();

		},

		isRunning: function () {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
					this._startTime === null && this._mixer._isActiveAction( this );

		},

		// return true when play has been called
		isScheduled: function () {

			return this._mixer._isActiveAction( this );

		},

		startAt: function ( time ) {

			this._startTime = time;

			return this;

		},

		setLoop: function ( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		},

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		},

		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {

			return this._effectiveWeight;

		},

		fadeIn: function ( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		},

		fadeOut: function ( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		},

		crossFadeFrom: function ( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		},

		crossFadeTo: function ( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		},

		stopFading: function () {

			var weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		},

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		},

		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {

			return this._effectiveTimeScale;

		},

		setDuration: function ( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		},

		syncWith: function ( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		},

		halt: function ( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		},

		warp: function ( startTimeScale, endTimeScale, duration ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,

				timeScale = this.timeScale;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		},

		stopWarping: function () {

			var timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		},

		// Object Accessors

		getMixer: function () {

			return this._mixer;

		},

		getClip: function () {

			return this._clip;

		},

		getRoot: function () {

			return this._localRoot || this._mixer._root;

		},

		// Interna

		_update: function ( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			var startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			var weight = this._updateWeight( time );

			if ( weight > 0 ) {

				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;

				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );

				}

			}

		},

		_updateWeight: function ( time ) {

			var weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				var interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		},

		_updateTimeScale: function ( time ) {

			var timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				var interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					var interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		},

		_updateTime: function ( deltaTime ) {

			var time = this.time + deltaTime;

			if ( deltaTime === 0 ) return time;

			var duration = this._clip.duration,

				loop = this.loop,
				loopCount = this._loopCount;

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else break handle_stop;

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				var pingPong = ( loop === LoopPingPong );

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					var pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					this.time = time;
					return duration - time;

				}

			}

			this.time = time;
			return time;

		},

		_setEndings: function ( atStart, atEnd, pingPong ) {

			var settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart 	= ZeroSlopeEnding;
				settings.endingEnd		= ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		},

		_scheduleFading: function ( duration, weightNow, weightThen ) {

			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now; 				values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

			return this;

		}

	} );

	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	function AnimationMixer( root ) {

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;

		this.time = 0;

		this.timeScale = 1.0;

	}

	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: AnimationMixer,

		_bindAction: function ( action, prototypeAction ) {

			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( var i = 0; i !== nTracks; ++ i ) {

				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		},

		_activateAction: function ( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				var bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		},

		_deactivateAction: function ( action ) {

			if ( this._isActiveAction( action ) ) {

				var bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

					var binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		},

		// Memory manager

		_initMemoryManager: function () {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 		knownActions: Array< AnimationAction >	- used as prototypes
			// 		actionByRoot: AnimationAction			- lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			var scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		},

		// Memory management for AnimationAction objects

		_isActiveAction: function ( action ) {

			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		},

		_addInactiveAction: function ( action, clipUuid, rootUuid ) {

			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				var knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		},

		_removeInactiveAction: function ( action ) {

			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		},

		_removeInactiveBindingsForAction: function ( action ) {

			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		},

		_lendAction: function ( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		},

		_takeBackAction: function ( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			var actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		},

		// Memory management for PropertyMixer objects

		_addInactiveBinding: function ( binding, rootUuid, trackName ) {

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				bindings = this._bindings;

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		},

		_removeInactiveBinding: function ( binding ) {

			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			remove_empty_map: {

				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars

				delete bindingsByRoot[ rootUuid ];

			}

		},

		_lendBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		},

		_takeBackBinding: function ( binding ) {

			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		},


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant: function () {

			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		},

		_takeBackControlInterpolant: function ( interpolant ) {

			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		},

		_controlInterpolantsResultBuffer: new Float32Array( 1 ),

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject !== null ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;

			if ( actionsForClip !== undefined ) {

				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		},

		// get an existing action
		existingAction: function ( clip, optionalRoot ) {

			var root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		},

		// deactivates all previously scheduled actions
		stopAllAction: function () {

			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;

			this._nActiveActions = 0;
			this._nActiveBindings = 0;

			for ( var i = 0; i !== nActions; ++ i ) {

				actions[ i ].reset();

			}

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].useCount = 0;

			}

			return this;

		},

		// advance the time and update apply the animation
		update: function ( deltaTime ) {

			deltaTime *= this.timeScale;

			var actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( var i = 0; i !== nActions; ++ i ) {

				var action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			var bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( var i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		},

		// return this mixer's root target object
		getRoot: function () {

			return this._root;

		},

		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {

			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				var actionsToRemove = actionsForClip.knownActions;

				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					var action = actionsToRemove[ i ];

					this._deactivateAction( action );

					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		},

		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {

			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( var clipUuid in actionsByClip ) {

				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( var trackName in bindingByName ) {

					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		},

		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {

			var action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setArray: function ( array ) {

			if ( Array.isArray( array ) ) {

				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

			}

			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;

			return this;

		},

		setDynamic: function ( value ) {

			this.dynamic = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

		BufferAttribute.call( this, array, itemSize );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */

	function Raycaster( origin, direction, near, far ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( ( camera && camera.isPerspectiveCamera ) ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( ( camera && camera.isOrthographicCamera ) ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive, optionalTarget ) {

			var intersects = optionalTarget || [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The poles (phi) are at the positive and negative y axis.
	 * The equator starts at positive z.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
		this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = vec3.length();

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
				this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

			}

			return this;

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */

	function Cylindrical( radius, theta, y ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

		return this;

	}

	Object.assign( Cylindrical.prototype, {

		set: function ( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		},

		setFromVector3: function ( vec3 ) {

			this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
			this.theta = Math.atan2( vec3.x, vec3.z );
			this.y = vec3.y;

			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 */

	function Box2( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

	}

	Object.assign( Box2.prototype, {

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function () {

			var v1 = new Vector2();

			return function setFromCenterAndSize( center, size ) {

				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );

				return this;

			};

		}(),

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		},

		intersectsBox: function ( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		},

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function () {

			var v1 = new Vector2();

			return function distanceToPoint( point ) {

				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();

			};

		}(),

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function VertexNormalsHelper( object, size, hex, linewidth ) {

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xff0000;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length * 3;

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			nNormals = objGeometry.attributes.normal.count;

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;

		this.update();

	}

	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

	VertexNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			var keys = [ 'a', 'b', 'c' ];

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			if ( objGeometry && objGeometry.isGeometry ) {

				var vertices = objGeometry.vertices;

				var faces = objGeometry.faces;

				var idx = 0;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					var face = faces[ i ];

					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

						var vertex = vertices[ face[ keys[ j ] ] ];

						var normal = face.vertexNormals[ j ];

						v1.copy( vertex ).applyMatrix4( matrixWorld );

						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

						position.setXYZ( idx, v1.x, v1.y, v1.z );

						idx = idx + 1;

						position.setXYZ( idx, v2.x, v2.y, v2.z );

						idx = idx + 1;

					}

				}

			} else if ( objGeometry && objGeometry.isBufferGeometry ) {

				var objPos = objGeometry.attributes.position;

				var objNorm = objGeometry.attributes.normal;

				var idx = 0;

				// for simplicity, ignore index and drawcalls, and render every normal

				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function SpotLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new BufferGeometry();

		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;

	SpotLightHelper.prototype.dispose = function () {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	};

	SpotLightHelper.prototype.update = function () {

		var vector = new Vector3();
		var vector2 = new Vector3();

		return function update() {

			this.light.updateMatrixWorld();

			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );

			this.cone.scale.set( coneWidth, coneWidth, coneLength );

			vector.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			this.cone.lookAt( vector2.sub( vector ) );

			if ( this.color !== undefined ) {

				this.cone.material.color.set( this.color );

			} else {

				this.cone.material.color.copy( this.light.color );

			}

		};

	}();

	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function getBoneList( object ) {

		var boneList = [];

		if ( object && object.isBone ) {

			boneList.push( object );

		}

		for ( var i = 0; i < object.children.length; i ++ ) {

			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

		}

		return boneList;

	}

	function SkeletonHelper( object ) {

		var bones = getBoneList( object );

		var geometry = new BufferGeometry();

		var vertices = [];
		var colors = [];

		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );

		for ( var i = 0; i < bones.length; i ++ ) {

			var bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

		LineSegments.call( this, geometry, material );

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;

	SkeletonHelper.prototype.updateMatrixWorld = function () {

		var vector = new Vector3();

		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();

		return function updateMatrixWorld( force ) {

			var bones = this.bones;

			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );

			matrixWorldInv.getInverse( this.root.matrixWorld );

			for ( var i = 0, j = 0; i < bones.length; i ++ ) {

				var bone = bones[ i ];

				if ( bone.parent && bone.parent.isBone ) {

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );

					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );

					j += 2;

				}

			}

			geometry.getAttribute( 'position' ).needsUpdate = true;

			Object3D.prototype.updateMatrixWorld.call( this, force );

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function PointLightHelper( light, sphereSize, color ) {

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );

		Mesh.call( this, geometry, material );

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
		var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

		var d = light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.scale.set( d, d, d );

		}

		this.add( this.lightDistance );
		*/

	}

	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;

	PointLightHelper.prototype.dispose = function () {

		this.geometry.dispose();
		this.material.dispose();

	};

	PointLightHelper.prototype.update = function () {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		var d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	};

	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function RectAreaLightHelper( light, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var material = new LineBasicMaterial( { fog: false } );

		var geometry = new BufferGeometry();

		geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );

		this.line = new Line( geometry, material );
		this.add( this.line );


		this.update();

	}

	RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

	RectAreaLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	RectAreaLightHelper.prototype.update = function () {

		// calculate new dimensions of the helper

		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;

		var position = this.line.geometry.attributes.position;
		var array = position.array;

		// update vertices

		array[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;
		array[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;
		array[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;
		array[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;
		array[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;

		position.needsUpdate = true;

		if ( this.color !== undefined ) {

			this.line.material.color.set( this.color );

		} else {

			this.line.material.color.copy( this.light.color );

		}

	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function HemisphereLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;

		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );

		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

	HemisphereLightHelper.prototype.dispose = function () {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	};

	HemisphereLightHelper.prototype.update = function () {

		var vector = new Vector3();

		var color1 = new Color();
		var color2 = new Color();

		return function update() {

			var mesh = this.children[ 0 ];

			if ( this.color !== undefined ) {

				this.material.color.set( this.color );

			} else {

				var colors = mesh.geometry.getAttribute( 'color' );

				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );

				for ( var i = 0, l = colors.count; i < l; i ++ ) {

					var color = ( i < ( l / 2 ) ) ? color1 : color2;

					colors.setXYZ( i, color.r, color.g, color.b );

				}

				colors.needsUpdate = true;

			}

			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function GridHelper( size, divisions, color1, color2 ) {

		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;

		var vertices = [], colors = [];

		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			var color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	GridHelper.prototype = Object.create( LineSegments.prototype );
	GridHelper.prototype.constructor = GridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */

	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

		var vertices = [];
		var colors = [];

		var x, z;
		var v, i, j, r, color;

		// create the radials

		for ( i = 0; i <= radials; i ++ ) {

			v = ( i / radials ) * ( Math.PI * 2 );

			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( i = 0; i <= circles; i ++ ) {

			color = ( i & 1 ) ? color1 : color2;

			r = radius - ( radius / circles * i );

			for ( j = 0; j < divisions; j ++ ) {

				// first vertex

				v = ( j / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function FaceNormalsHelper( object, size, hex, linewidth ) {

		// FaceNormalsHelper only supports THREE.Geometry

		this.object = object;

		this.size = ( size !== undefined ) ? size : 1;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var width = ( linewidth !== undefined ) ? linewidth : 1;

		//

		var nNormals = 0;

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			nNormals = objGeometry.faces.length;

		} else {

			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

		}

		//

		var geometry = new BufferGeometry();

		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

		geometry.addAttribute( 'position', positions );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

		//

		this.matrixAutoUpdate = false;
		this.update();

	}

	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

	FaceNormalsHelper.prototype.update = ( function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();

		return function update() {

			this.object.updateMatrixWorld( true );

			normalMatrix.getNormalMatrix( this.object.matrixWorld );

			var matrixWorld = this.object.matrixWorld;

			var position = this.geometry.attributes.position;

			//

			var objGeometry = this.object.geometry;

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				var normal = face.normal;

				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );

				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

			position.needsUpdate = true;

		};

	}() );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function DirectionalLightHelper( light, size, color ) {

		Object3D.call( this );

		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		var material = new LineBasicMaterial( { fog: false } );

		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

	DirectionalLightHelper.prototype.dispose = function () {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	};

	DirectionalLightHelper.prototype.update = function () {

		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();

		return function update() {

			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );

			this.lightPlane.lookAt( v3 );

			if ( this.color !== undefined ) {

				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );

			} else {

				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );

			}

			this.targetLine.lookAt( v3 );
			this.targetLine.scale.z = v3.length();

		};

	}();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */

	function CameraHelper( camera ) {

		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

		var vertices = [];
		var colors = [];

		var pointMap = {};

		// colors

		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		LineSegments.call( this, geometry, material );

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.update = function () {

		var geometry, pointMap;

		var vector = new Vector3();
		var camera = new Camera();

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z ).unproject( camera );

			var points = pointMap[ point ];

			if ( points !== undefined ) {

				var position = geometry.getAttribute( 'position' );

				for ( var i = 0, l = points.length; i < l; i ++ ) {

					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

				}

			}

		}

		return function update() {

			geometry = this.geometry;
			pointMap = this.pointMap;

			var w = 1, h = 1;

			// we need just camera projection matrix
			// world matrix must be identity

			camera.projectionMatrix.copy( this.camera.projectionMatrix );

			// center / target

			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );

			// near

			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );

			// far

			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );

			// up

			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );

			// cross

			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );

			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );

			geometry.getAttribute( 'position' ).needsUpdate = true;

		};

	}();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */

	function BoxHelper( object, color ) {

		this.object = object;

		if ( color === undefined ) color = 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );

		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.matrixAutoUpdate = false;

		this.update();

	}

	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;

	BoxHelper.prototype.update = ( function () {

		var box = new Box3();

		return function update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				box.setFromObject( this.object );

			}

			if ( box.isEmpty() ) return;

			var min = box.min;
			var max = box.max;

			/*
			  5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			var position = this.geometry.attributes.position;
			var array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();

		};

	} )();

	BoxHelper.prototype.setFromObject = function ( object ) {

		this.object = object;
		this.update();

		return this;

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3Helper( box, hex ) {

		this.type = 'Box3Helper';

		this.box = box;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		var geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		this.geometry.computeBoundingSphere();

	}

	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;

	Box3Helper.prototype.updateMatrixWorld = function ( force ) {

		var box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function PlaneHelper( plane, size, hex ) {

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = ( size === undefined ) ? 1 : size;

		var color = ( hex !== undefined ) ? hex : 0xffff00;

		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );

		//

		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );

	}

	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;

	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {

		var scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		Object3D.prototype.updateMatrixWorld.call( this, force );

	};

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */

	var lineGeometry, coneGeometry;

	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		if ( lineGeometry === undefined ) {

			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;

	ArrowHelper.prototype.setDirection = ( function () {

		var axis = new Vector3();
		var radians;

		return function setDirection( dir ) {

			// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

				this.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

				this.quaternion.set( 1, 0, 0, 0 );

			} else {

				axis.set( dir.z, 0, - dir.x ).normalize();

				radians = Math.acos( dir.y );

				this.quaternion.setFromAxisAngle( axis, radians );

			}

		};

	}() );

	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	};

	ArrowHelper.prototype.setColor = function ( color ) {

		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );

	};

	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AxesHelper( size ) {

		size = size || 1;

		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		var material = new LineBasicMaterial( { vertexColors: VertexColors } );

		LineSegments.call( this, geometry, material );

	}

	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;

	var LinePieces = 1;

	function MeshFaceMaterial( materials ) {

		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;

	}

	function MultiMaterial( materials ) {

		if ( materials === undefined ) materials = [];

		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {

			return materials.slice();

		};
		return materials;

	}

	function PointCloud( geometry, material ) {

		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function Particle( material ) {

		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );

	}

	function ParticleSystem( geometry, material ) {

		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );

	}

	function PointCloudMaterial( parameters ) {

		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleBasicMaterial( parameters ) {

		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function ParticleSystemMaterial( parameters ) {

		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );

	}

	function Vertex( x, y, z ) {

		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );

	}

	//

	function DynamicBufferAttribute( array, itemSize ) {

		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );

	}

	function Int8Attribute( array, itemSize ) {

		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );

	}

	function Uint8Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );

	}

	function Uint8ClampedAttribute( array, itemSize ) {

		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );

	}

	function Int16Attribute( array, itemSize ) {

		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );

	}

	function Uint16Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );

	}

	function Int32Attribute( array, itemSize ) {

		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );

	}

	function Uint32Attribute( array, itemSize ) {

		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );

	}

	function Float32Attribute( array, itemSize ) {

		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );

	}

	function Float64Attribute( array, itemSize ) {

		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );

	}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	//

	function AxisHelper( size ) {

		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );

	}

	function BoundingBoxHelper( object, color ) {

		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );

	}

	function EdgesHelper( object, hex ) {

		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	GridHelper.prototype.setColors = function () {

		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

	};

	SkeletonHelper.prototype.update = function () {

		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

	};

	function WireframeHelper( object, hex ) {

		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

	}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	function XHRLoader( manager ) {

		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );

	}

	function BinaryTextureLoader( manager ) {

		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );

	}

	//

	Object.assign( Box2.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Line3.prototype.center = function ( optionalTarget ) {

		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	};

	Object.assign( _Math, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			var v1;

			return function getPosition() {

				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );

			};

		}(),
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {

			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Ray.prototype, {

		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionPlane: function ( plane ) {

			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		}

	} );

	Object.assign( Triangle.prototype, {

		area: function () {

			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();

		},
		barycoordFromPoint: function ( point, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );

		},
		midpoint: function ( target ) {

			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );

		},
		normal: function ( target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );

		},
		plane: function ( target ) {

			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );

		}

	} );

	Object.assign( Triangle, {

		barycoordFromPoint: function ( point, a, b, c, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );

		},
		normal: function ( a, b, c, target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Object.assign( Geometry.prototype, {

		computeTangents: function () {

			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

		},
		computeLineDistances: function () {

			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

		}

	} );

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},
		getWorldRotation: function () {

			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		copyIndicesArray: function ( /* indices */ ) {

			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

		}

	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	//

	Object.assign( ExtrudeBufferGeometry.prototype, {

		getArrays: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );

		},

		addShapeList: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );

		},

		addShape: function () {

			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );

		}

	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},
		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		animate: function ( callback ) {

			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );

		},

		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},

		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},

		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},

		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},

		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		},
		setFaceCulling: function () {

			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		}
	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.defineProperties( WebVRManager.prototype, {

		standing: {
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebVRManager: .standing has been removed.' );

			}
		}

	} );

	//

	Audio.prototype.load = function ( file ) {

		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {

			scope.setBuffer( buffer );

		} );
		return this;

	};

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	var ImageUtils = {

		crossOrigin: undefined,

		loadTexture: function ( url, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

			var loader = new TextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( url, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadTextureCube: function ( urls, mapping, onLoad, onError ) {

			console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

			var loader = new CubeTextureLoader();
			loader.setCrossOrigin( this.crossOrigin );

			var texture = loader.load( urls, onLoad, undefined, onError );

			if ( mapping ) texture.mapping = mapping;

			return texture;

		},

		loadCompressedTexture: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

		},

		loadCompressedTextureCube: function () {

			console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

		}

	};

	//

	function Projector() {

		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

		this.projectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );

		};

		this.unprojectVector = function ( vector, camera ) {

			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );

		};

		this.pickingRay = function () {

			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

		};

	}

	//

	function CanvasRenderer() {

		console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

		this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		this.clear = function () {};
		this.render = function () {};
		this.setClearColor = function () {};
		this.setSize = function () {};

	}

	//

	var SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		detach: function ( /* child, parent, scene */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		},

		attach: function ( /* child, scene, parent */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );

		}

	};

	//

	function LensFlare() {

		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );

	}

	var THREE$1 = /*#__PURE__*/Object.freeze({
		WebGLRenderTargetCube: WebGLRenderTargetCube,
		WebGLRenderTarget: WebGLRenderTarget,
		WebGLRenderer: WebGLRenderer,
		ShaderLib: ShaderLib,
		UniformsLib: UniformsLib,
		UniformsUtils: UniformsUtils,
		ShaderChunk: ShaderChunk,
		FogExp2: FogExp2,
		Fog: Fog,
		Scene: Scene,
		Sprite: Sprite,
		LOD: LOD,
		SkinnedMesh: SkinnedMesh,
		Skeleton: Skeleton,
		Bone: Bone,
		Mesh: Mesh,
		LineSegments: LineSegments,
		LineLoop: LineLoop,
		Line: Line,
		Points: Points,
		Group: Group,
		VideoTexture: VideoTexture,
		DataTexture: DataTexture,
		CompressedTexture: CompressedTexture,
		CubeTexture: CubeTexture,
		CanvasTexture: CanvasTexture,
		DepthTexture: DepthTexture,
		Texture: Texture,
		CompressedTextureLoader: CompressedTextureLoader,
		DataTextureLoader: DataTextureLoader,
		CubeTextureLoader: CubeTextureLoader,
		TextureLoader: TextureLoader,
		ObjectLoader: ObjectLoader,
		MaterialLoader: MaterialLoader,
		BufferGeometryLoader: BufferGeometryLoader,
		DefaultLoadingManager: DefaultLoadingManager,
		LoadingManager: LoadingManager,
		JSONLoader: JSONLoader,
		ImageLoader: ImageLoader,
		ImageBitmapLoader: ImageBitmapLoader,
		FontLoader: FontLoader,
		FileLoader: FileLoader,
		Loader: Loader,
		LoaderUtils: LoaderUtils,
		Cache: Cache,
		AudioLoader: AudioLoader,
		SpotLightShadow: SpotLightShadow,
		SpotLight: SpotLight,
		PointLight: PointLight,
		RectAreaLight: RectAreaLight,
		HemisphereLight: HemisphereLight,
		DirectionalLightShadow: DirectionalLightShadow,
		DirectionalLight: DirectionalLight,
		AmbientLight: AmbientLight,
		LightShadow: LightShadow,
		Light: Light,
		StereoCamera: StereoCamera,
		PerspectiveCamera: PerspectiveCamera,
		OrthographicCamera: OrthographicCamera,
		CubeCamera: CubeCamera,
		ArrayCamera: ArrayCamera,
		Camera: Camera,
		AudioListener: AudioListener,
		PositionalAudio: PositionalAudio,
		AudioContext: AudioContext,
		AudioAnalyser: AudioAnalyser,
		Audio: Audio,
		VectorKeyframeTrack: VectorKeyframeTrack,
		StringKeyframeTrack: StringKeyframeTrack,
		QuaternionKeyframeTrack: QuaternionKeyframeTrack,
		NumberKeyframeTrack: NumberKeyframeTrack,
		ColorKeyframeTrack: ColorKeyframeTrack,
		BooleanKeyframeTrack: BooleanKeyframeTrack,
		PropertyMixer: PropertyMixer,
		PropertyBinding: PropertyBinding,
		KeyframeTrack: KeyframeTrack,
		AnimationUtils: AnimationUtils,
		AnimationObjectGroup: AnimationObjectGroup,
		AnimationMixer: AnimationMixer,
		AnimationClip: AnimationClip,
		Uniform: Uniform,
		InstancedBufferGeometry: InstancedBufferGeometry,
		BufferGeometry: BufferGeometry,
		Geometry: Geometry,
		InterleavedBufferAttribute: InterleavedBufferAttribute,
		InstancedInterleavedBuffer: InstancedInterleavedBuffer,
		InterleavedBuffer: InterleavedBuffer,
		InstancedBufferAttribute: InstancedBufferAttribute,
		Face3: Face3,
		Object3D: Object3D,
		Raycaster: Raycaster,
		Layers: Layers,
		EventDispatcher: EventDispatcher,
		Clock: Clock,
		QuaternionLinearInterpolant: QuaternionLinearInterpolant,
		LinearInterpolant: LinearInterpolant,
		DiscreteInterpolant: DiscreteInterpolant,
		CubicInterpolant: CubicInterpolant,
		Interpolant: Interpolant,
		Triangle: Triangle,
		Math: _Math,
		Spherical: Spherical,
		Cylindrical: Cylindrical,
		Plane: Plane,
		Frustum: Frustum,
		Sphere: Sphere,
		Ray: Ray,
		Matrix4: Matrix4,
		Matrix3: Matrix3,
		Box3: Box3,
		Box2: Box2,
		Line3: Line3,
		Euler: Euler,
		Vector4: Vector4,
		Vector3: Vector3,
		Vector2: Vector2,
		Quaternion: Quaternion,
		Color: Color,
		ImmediateRenderObject: ImmediateRenderObject,
		VertexNormalsHelper: VertexNormalsHelper,
		SpotLightHelper: SpotLightHelper,
		SkeletonHelper: SkeletonHelper,
		PointLightHelper: PointLightHelper,
		RectAreaLightHelper: RectAreaLightHelper,
		HemisphereLightHelper: HemisphereLightHelper,
		GridHelper: GridHelper,
		PolarGridHelper: PolarGridHelper,
		FaceNormalsHelper: FaceNormalsHelper,
		DirectionalLightHelper: DirectionalLightHelper,
		CameraHelper: CameraHelper,
		BoxHelper: BoxHelper,
		Box3Helper: Box3Helper,
		PlaneHelper: PlaneHelper,
		ArrowHelper: ArrowHelper,
		AxesHelper: AxesHelper,
		Shape: Shape,
		Path: Path,
		ShapePath: ShapePath,
		Font: Font,
		CurvePath: CurvePath,
		Curve: Curve,
		ShapeUtils: ShapeUtils,
		WebGLUtils: WebGLUtils,
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material,
		Float64BufferAttribute: Float64BufferAttribute,
		Float32BufferAttribute: Float32BufferAttribute,
		Uint32BufferAttribute: Uint32BufferAttribute,
		Int32BufferAttribute: Int32BufferAttribute,
		Uint16BufferAttribute: Uint16BufferAttribute,
		Int16BufferAttribute: Int16BufferAttribute,
		Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,
		Uint8BufferAttribute: Uint8BufferAttribute,
		Int8BufferAttribute: Int8BufferAttribute,
		BufferAttribute: BufferAttribute,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve,
		REVISION: REVISION,
		MOUSE: MOUSE,
		CullFaceNone: CullFaceNone,
		CullFaceBack: CullFaceBack,
		CullFaceFront: CullFaceFront,
		CullFaceFrontBack: CullFaceFrontBack,
		FrontFaceDirectionCW: FrontFaceDirectionCW,
		FrontFaceDirectionCCW: FrontFaceDirectionCCW,
		BasicShadowMap: BasicShadowMap,
		PCFShadowMap: PCFShadowMap,
		PCFSoftShadowMap: PCFSoftShadowMap,
		FrontSide: FrontSide,
		BackSide: BackSide,
		DoubleSide: DoubleSide,
		FlatShading: FlatShading,
		SmoothShading: SmoothShading,
		NoColors: NoColors,
		FaceColors: FaceColors,
		VertexColors: VertexColors,
		NoBlending: NoBlending,
		NormalBlending: NormalBlending,
		AdditiveBlending: AdditiveBlending,
		SubtractiveBlending: SubtractiveBlending,
		MultiplyBlending: MultiplyBlending,
		CustomBlending: CustomBlending,
		AddEquation: AddEquation,
		SubtractEquation: SubtractEquation,
		ReverseSubtractEquation: ReverseSubtractEquation,
		MinEquation: MinEquation,
		MaxEquation: MaxEquation,
		ZeroFactor: ZeroFactor,
		OneFactor: OneFactor,
		SrcColorFactor: SrcColorFactor,
		OneMinusSrcColorFactor: OneMinusSrcColorFactor,
		SrcAlphaFactor: SrcAlphaFactor,
		OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,
		DstAlphaFactor: DstAlphaFactor,
		OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,
		DstColorFactor: DstColorFactor,
		OneMinusDstColorFactor: OneMinusDstColorFactor,
		SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,
		NeverDepth: NeverDepth,
		AlwaysDepth: AlwaysDepth,
		LessDepth: LessDepth,
		LessEqualDepth: LessEqualDepth,
		EqualDepth: EqualDepth,
		GreaterEqualDepth: GreaterEqualDepth,
		GreaterDepth: GreaterDepth,
		NotEqualDepth: NotEqualDepth,
		MultiplyOperation: MultiplyOperation,
		MixOperation: MixOperation,
		AddOperation: AddOperation,
		NoToneMapping: NoToneMapping,
		LinearToneMapping: LinearToneMapping,
		ReinhardToneMapping: ReinhardToneMapping,
		Uncharted2ToneMapping: Uncharted2ToneMapping,
		CineonToneMapping: CineonToneMapping,
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping,
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping,
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter,
		UnsignedByteType: UnsignedByteType,
		ByteType: ByteType,
		ShortType: ShortType,
		UnsignedShortType: UnsignedShortType,
		IntType: IntType,
		UnsignedIntType: UnsignedIntType,
		FloatType: FloatType,
		HalfFloatType: HalfFloatType,
		UnsignedShort4444Type: UnsignedShort4444Type,
		UnsignedShort5551Type: UnsignedShort5551Type,
		UnsignedShort565Type: UnsignedShort565Type,
		UnsignedInt248Type: UnsignedInt248Type,
		AlphaFormat: AlphaFormat,
		RGBFormat: RGBFormat,
		RGBAFormat: RGBAFormat,
		LuminanceFormat: LuminanceFormat,
		LuminanceAlphaFormat: LuminanceAlphaFormat,
		RGBEFormat: RGBEFormat,
		DepthFormat: DepthFormat,
		DepthStencilFormat: DepthStencilFormat,
		RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
		RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
		RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
		RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
		RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
		RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
		RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
		RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
		RGB_ETC1_Format: RGB_ETC1_Format,
		RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
		RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
		RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
		RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
		RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
		RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
		RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
		RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
		RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
		RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
		RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
		RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
		RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
		RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
		LoopOnce: LoopOnce,
		LoopRepeat: LoopRepeat,
		LoopPingPong: LoopPingPong,
		InterpolateDiscrete: InterpolateDiscrete,
		InterpolateLinear: InterpolateLinear,
		InterpolateSmooth: InterpolateSmooth,
		ZeroCurvatureEnding: ZeroCurvatureEnding,
		ZeroSlopeEnding: ZeroSlopeEnding,
		WrapAroundEnding: WrapAroundEnding,
		TrianglesDrawMode: TrianglesDrawMode,
		TriangleStripDrawMode: TriangleStripDrawMode,
		TriangleFanDrawMode: TriangleFanDrawMode,
		LinearEncoding: LinearEncoding,
		sRGBEncoding: sRGBEncoding,
		GammaEncoding: GammaEncoding,
		RGBEEncoding: RGBEEncoding,
		LogLuvEncoding: LogLuvEncoding,
		RGBM7Encoding: RGBM7Encoding,
		RGBM16Encoding: RGBM16Encoding,
		RGBDEncoding: RGBDEncoding,
		BasicDepthPacking: BasicDepthPacking,
		RGBADepthPacking: RGBADepthPacking,
		TangentSpaceNormalMap: TangentSpaceNormalMap,
		ObjectSpaceNormalMap: ObjectSpaceNormalMap,
		CubeGeometry: BoxGeometry,
		Face4: Face4,
		LineStrip: LineStrip,
		LinePieces: LinePieces,
		MeshFaceMaterial: MeshFaceMaterial,
		MultiMaterial: MultiMaterial,
		PointCloud: PointCloud,
		Particle: Particle,
		ParticleSystem: ParticleSystem,
		PointCloudMaterial: PointCloudMaterial,
		ParticleBasicMaterial: ParticleBasicMaterial,
		ParticleSystemMaterial: ParticleSystemMaterial,
		Vertex: Vertex,
		DynamicBufferAttribute: DynamicBufferAttribute,
		Int8Attribute: Int8Attribute,
		Uint8Attribute: Uint8Attribute,
		Uint8ClampedAttribute: Uint8ClampedAttribute,
		Int16Attribute: Int16Attribute,
		Uint16Attribute: Uint16Attribute,
		Int32Attribute: Int32Attribute,
		Uint32Attribute: Uint32Attribute,
		Float32Attribute: Float32Attribute,
		Float64Attribute: Float64Attribute,
		ClosedSplineCurve3: ClosedSplineCurve3,
		SplineCurve3: SplineCurve3,
		Spline: Spline,
		AxisHelper: AxisHelper,
		BoundingBoxHelper: BoundingBoxHelper,
		EdgesHelper: EdgesHelper,
		WireframeHelper: WireframeHelper,
		XHRLoader: XHRLoader,
		BinaryTextureLoader: BinaryTextureLoader,
		GeometryUtils: GeometryUtils,
		ImageUtils: ImageUtils,
		Projector: Projector,
		CanvasRenderer: CanvasRenderer,
		SceneUtils: SceneUtils,
		LensFlare: LensFlare
	});

	var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
	    for (var s, i = 1, n = arguments.length; i < n; i++) {
	        s = arguments[i];
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	            t[p] = s[p];
	    }
	    return t;
	};
	var defaults = {
	    lines: 12,
	    length: 7,
	    width: 5,
	    radius: 10,
	    scale: 1.0,
	    corners: 1,
	    color: '#000',
	    fadeColor: 'transparent',
	    animation: 'spinner-line-fade-default',
	    rotate: 0,
	    direction: 1,
	    speed: 1,
	    zIndex: 2e9,
	    className: 'spinner',
	    top: '50%',
	    left: '50%',
	    shadow: '0 0 1px transparent',
	    position: 'absolute',
	};
	var Spinner = /** @class */ (function () {
	    function Spinner(opts) {
	        if (opts === void 0) { opts = {}; }
	        this.opts = __assign({}, defaults, opts);
	    }
	    /**
	     * Adds the spinner to the given target element. If this instance is already
	     * spinning, it is automatically removed from its previous target by calling
	     * stop() internally.
	     */
	    Spinner.prototype.spin = function (target) {
	        this.stop();
	        this.el = document.createElement('div');
	        this.el.className = this.opts.className;
	        this.el.setAttribute('role', 'progressbar');
	        css(this.el, {
	            position: this.opts.position,
	            width: 0,
	            zIndex: this.opts.zIndex,
	            left: this.opts.left,
	            top: this.opts.top,
	            transform: "scale(" + this.opts.scale + ")",
	        });
	        if (target) {
	            target.insertBefore(this.el, target.firstChild || null);
	        }
	        drawLines(this.el, this.opts);
	        return this;
	    };
	    /**
	     * Stops and removes the Spinner.
	     * Stopped spinners may be reused by calling spin() again.
	     */
	    Spinner.prototype.stop = function () {
	        if (this.el) {
	            if (typeof requestAnimationFrame !== 'undefined') {
	                cancelAnimationFrame(this.animateId);
	            }
	            else {
	                clearTimeout(this.animateId);
	            }
	            if (this.el.parentNode) {
	                this.el.parentNode.removeChild(this.el);
	            }
	            this.el = undefined;
	        }
	        return this;
	    };
	    return Spinner;
	}());
	/**
	 * Sets multiple style properties at once.
	 */
	function css(el, props) {
	    for (var prop in props) {
	        el.style[prop] = props[prop];
	    }
	    return el;
	}
	/**
	 * Returns the line color from the given string or array.
	 */
	function getColor(color, idx) {
	    return typeof color == 'string' ? color : color[idx % color.length];
	}
	/**
	 * Internal method that draws the individual lines.
	 */
	function drawLines(el, opts) {
	    var borderRadius = (Math.round(opts.corners * opts.width * 500) / 1000) + 'px';
	    var shadow = 'none';
	    if (opts.shadow === true) {
	        shadow = '0 2px 4px #000'; // default shadow
	    }
	    else if (typeof opts.shadow === 'string') {
	        shadow = opts.shadow;
	    }
	    var shadows = parseBoxShadow(shadow);
	    for (var i = 0; i < opts.lines; i++) {
	        var degrees = ~~(360 / opts.lines * i + opts.rotate);
	        var backgroundLine = css(document.createElement('div'), {
	            position: 'absolute',
	            top: -opts.width / 2 + "px",
	            width: (opts.length + opts.width) + 'px',
	            height: opts.width + 'px',
	            background: getColor(opts.fadeColor, i),
	            borderRadius: borderRadius,
	            transformOrigin: 'left',
	            transform: "rotate(" + degrees + "deg) translateX(" + opts.radius + "px)",
	        });
	        var delay = i * opts.direction / opts.lines / opts.speed;
	        delay -= 1 / opts.speed; // so initial animation state will include trail
	        var line = css(document.createElement('div'), {
	            width: '100%',
	            height: '100%',
	            background: getColor(opts.color, i),
	            borderRadius: borderRadius,
	            boxShadow: normalizeShadow(shadows, degrees),
	            animation: 1 / opts.speed + "s linear " + delay + "s infinite " + opts.animation,
	        });
	        backgroundLine.appendChild(line);
	        el.appendChild(backgroundLine);
	    }
	}
	function parseBoxShadow(boxShadow) {
	    var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
	    var shadows = [];
	    for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
	        var shadow = _a[_i];
	        var matches = shadow.match(regex);
	        if (matches === null) {
	            continue; // invalid syntax
	        }
	        var x = +matches[2];
	        var y = +matches[5];
	        var xUnits = matches[4];
	        var yUnits = matches[7];
	        if (x === 0 && !xUnits) {
	            xUnits = yUnits;
	        }
	        if (y === 0 && !yUnits) {
	            yUnits = xUnits;
	        }
	        if (xUnits !== yUnits) {
	            continue; // units must match to use as coordinates
	        }
	        shadows.push({
	            prefix: matches[1] || '',
	            x: x,
	            y: y,
	            xUnits: xUnits,
	            yUnits: yUnits,
	            end: matches[8],
	        });
	    }
	    return shadows;
	}
	/**
	 * Modify box-shadow x/y offsets to counteract rotation
	 */
	function normalizeShadow(shadows, degrees) {
	    var normalized = [];
	    for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
	        var shadow = shadows_1[_i];
	        var xy = convertOffset(shadow.x, shadow.y, degrees);
	        normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
	    }
	    return normalized.join(', ');
	}
	function convertOffset(x, y, degrees) {
	    var radians = degrees * Math.PI / 180;
	    var sin = Math.sin(radians);
	    var cos = Math.cos(radians);
	    return [
	        Math.round((x * cos + y * sin) * 1000) / 1000,
	        Math.round((-x * sin + y * cos) * 1000) / 1000,
	    ];
	}

	/**
	 * This class introduces the simplest event system.
	 */
	function isUndefOrEqual(param, value) {
	  return !param || param === value;
	}

	/**
	 * Creates empty dispatcher.
	 *
	 * @exports EventDispatcher
	 * @constructor
	 */
	function EventDispatcher$1() {
	  this._handlers = {};
	}

	/**
	 * Binds callback on specific event type. Optional `context` parameter
	 * could be used as 'this' for the `callback`.
	 * @param {string}   type       Event name.
	 * @param {function} callback   Callback function.
	 * @param {Object}   [context] 'This' object for the callback.
	 */
	EventDispatcher$1.prototype.addEventListener = function (type, callback, context) {
	  var handlers = this._handlers[type];

	  if (!handlers) {
	    this._handlers[type] = [];
	    handlers = this._handlers[type];
	  }

	  var params = [callback, context];
	  function _checkPar(par) {
	    return par[0] === params[0] && par[1] === params[1];
	  }

	  if (lodash.find(handlers, _checkPar) === undefined) {
	    handlers.push(params);
	  }
	};

	/**
	 * Removes a previously-bound callback function from an object.
	 * If no `context` is specified, all versions of the `callback` with different
	 * contexts will be removed.
	 * If no `callback` is specified, all callbacks of the `type` will be removed.
	 * If no `type` is specified, callbacks for all events will be removed.
	 * @param {?string}  [type]      Event type.
	 * @param {function} [callback]  Callback function.
	 * @param {Object}   [context]  'This' object for the callback.
	 */
	EventDispatcher$1.prototype.removeEventListener = function (type, callback, context) {
	  var self = this;
	  lodash.forEach(self._handlers, function (handler, ev) {
	    lodash.remove(handler, function (values) {
	      return isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self);
	    });
	  });

	  this._handlers = lodash.omitBy(self._handlers, function (handler) {
	    return handler.length === 0;
	  });
	};

	/**
	 * Makes all the callbacks for the specific `event` to trigger.
	 * @param {Object} event      Event.
	 * @param {string} event.type Type of the event.
	 */
	EventDispatcher$1.prototype.dispatchEvent = function (event) {
	  var self = this;

	  lodash.forEach(this._handlers[event.type], function (callback) {
	    var context = callback[1] || self;
	    callback[0].apply(context, [event]);
	  });
	};

	var logLevels = {
	  debug: 0,
	  info: 1,
	  report: 2,
	  warn: 3,
	  error: 4
	};

	/**
	 * Create new Logger.
	 *
	 * @exports Logger
	 * @extends EventDispatcher
	 * @constructor
	 */
	function Logger() {
	  EventDispatcher$1.call(this);
	  /** Boolean flag that toggles output to browser console.
	   * @type {boolean}
	   */
	  this.console = false;
	  this._level = logLevels.warn;
	}

	Logger.prototype = Object.create(EventDispatcher$1.prototype);
	Logger.prototype.constructor = Logger;

	/**
	 * Create new clean instance of the logger.
	 * @returns {Logger}
	 */
	Logger.prototype.instantiate = function () {
	  return new Logger();
	};

	/**
	 * @property {string} current threshold for signals and console output.
	 * @name Logger#level
	 */
	Object.defineProperty(Logger.prototype, 'level', {
	  get: function get() {
	    var self = this;
	    return lodash.findKey(logLevels, function (lvl) {
	      return lvl === self._level;
	    });
	  },
	  set: function set(strValue) {
	    var lvlVal = logLevels[strValue];
	    if (!lodash.isNumber(lvlVal)) {
	      throw new Error('Wrong log level specified!');
	    }
	    this._level = lvlVal;
	  }
	});

	/**
	 * Returns the list of all possible level values.
	 * @returns {Array}
	 */
	Logger.prototype.levels = function () {
	  return Object.keys(logLevels);
	};

	/**
	 * Add new message with specified level.
	 * @param {string} level - level of the message, must be one of the
	 * {'debug' | 'info' | 'report' | 'warn' | 'error'}
	 * @param {string} message
	 */
	Logger.prototype.message = function (level, message) {
	  var lvlVal = logLevels[level];
	  if (!lodash.isNumber(lvlVal)) {
	    throw new Error('Wrong log level specified!');
	  }
	  this._message(lvlVal, message);
	};

	/**
	 * Shortcut for message('debug', ...);
	 * @param message
	 */
	Logger.prototype.debug = function (message) {
	  this._message(logLevels.debug, message);
	};

	/**
	 * Shortcut for message('info', ...);
	 * @param message
	 */
	Logger.prototype.info = function (message) {
	  this._message(logLevels.info, message);
	};

	/**
	 * Shortcut for message('report', ...);
	 * @param message
	 */
	Logger.prototype.report = function (message) {
	  this._message(logLevels.report, message);
	};

	/**
	 * Shortcut for message('warn', ...);
	 * @param message
	 */
	Logger.prototype.warn = function (message) {
	  this._message(logLevels.warn, message);
	};

	/**
	 * Shortcut for message('error', ...);
	 * @param message
	 */
	Logger.prototype.error = function (message) {
	  this._message(logLevels.error, message);
	};

	/**
	 * Add new message with specified level.
	 * @param {number} levelVal - level of the message
	 * @param {string} message
	 * @private
	 */
	Logger.prototype._message = function (levelVal, message) {
	  if (levelVal < this._level) {
	    return;
	  }
	  var level = lodash.findKey(logLevels, function (lvl) {
	    return lvl === levelVal;
	  });
	  message = String(message);
	  if (this.console) {
	    var output = 'miew:' + level + ': ' + message;
	    if (level === 'error') {
	      console.error(output); // NOSONAR
	    } else if (level === 'warning') {
	      console.warn(output); // NOSONAR
	    } else {
	      console.log(output); // NOSONAR
	    }
	  }
	  this.dispatchEvent({ type: 'message', level: level, message: message });
	};

	var logger = new Logger();

	////////////////////////////////////////////////////////////////////////////
	// Timer

	function Timer() {
	  this.startTime = 0;
	  this.oldTime = 0;
	  this.elapsedTime = 0;
	  this.running = false;
	}

	Timer.now = function () {
	  var p = typeof window !== 'undefined' && window.performance;
	  return p && p.now ? p.now.bind(p) : Date.now;
	}();

	Timer.prototype = {
	  constructor: Timer,

	  start: function start() {
	    this.startTime = Timer.now();
	    this.oldTime = this.startTime;
	    this.running = true;
	  },

	  stop: function stop() {
	    this.getElapsedTime();
	    this.running = false;
	  },

	  getElapsedTime: function getElapsedTime() {
	    this.update();
	    return this.elapsedTime;
	  },

	  update: function update() {
	    var delta = 0;
	    if (this.running) {
	      var newTime = Timer.now();
	      delta = 0.001 * (newTime - this.oldTime);
	      this.oldTime = newTime;
	      this.elapsedTime += delta;
	    }

	    return delta;
	  }
	};

	////////////////////////////////////////////////////////////////////////////
	// Query string

	/**
	 * Escape only dangerous chars in a query string component, use a plus instead of a space.
	 *
	 * [RFC 3986](https://tools.ietf.org/html/rfc3986) allows the following chars in the query (see 3.4):
	 *
	 *       A-Z a-z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ / ?
	 *
	 * For query string elements we need to escape ampersand, equal sign, and plus,
	 * but encodeURIComponent() function encodes anything except for the following:
	 *
	 *       A-Z a-z 0-9 - _ . ~ ! ' ( ) *
	 *
	 * @param {string} text - key or value to encode
	 * @param {string} excludeExp - regexp for symbols to exclude from encoding
	 * @returns {string} encoded string
	 */
	function encodeQueryComponent(text, excludeExp) {
	  return encodeURIComponent(text).replace(excludeExp, function (code) {
	    return String.fromCharCode(parseInt(code.substr(1), 16));
	  }).replace(/%20/g, '+');
	}

	/**
	 * Unescape dangerous chars in a query string component.
	 *
	 * @param {string} text - encoded key or value
	 * @returns {string} decoded string
	 * @see {@link encodeQueryComponent}
	 */
	function decodeQueryComponent(text) {
	  return decodeURIComponent(text.replace(/\+/g, ' '));
	}

	/**
	 * Parse URL and extract an array of parameters.
	 * @param {string?} url - URL or query string to parse
	 * @returns {Array} array of (key, value) pairs.
	 */
	function getUrlParameters(url) {
	  url = url || window.location.search;

	  var query = url.substring(url.indexOf('?') + 1);
	  var search = /([^&=]+)=?([^&]*)/g;
	  var result = [];
	  var match;

	  while ((match = search.exec(query)) !== null) {
	    result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
	  }

	  return result;
	}

	/**
	 * Parse URL and extract an array of parameters as a hash.
	 * @param {string?} url - URL or query string to parse
	 * @returns {Object}
	 */
	function getUrlParametersAsDict(url) {
	  var result = {};
	  var a = getUrlParameters(url);
	  for (var i = 0; i < a.length; ++i) {
	    result[a[i][0]] = a[i][1];
	  }
	  return result;
	}

	function resolveURL(str) {
	  if (typeof URL !== 'undefined') {
	    try {
	      if (typeof window !== 'undefined') {
	        return new URL(str, window.location).href;
	      } else {
	        return new URL(str).href;
	      }
	    } catch (error) {
	      // IE 11 has a URL object with no constructor available so just try a different approach instead
	    }
	  }
	  if (typeof document !== 'undefined') {
	    var anchor = document.createElement('a');
	    anchor.href = str;
	    return anchor.href;
	  }
	  return str;
	}

	/**
	 * Generates regular expression object that includes all symbols
	 * listed in the argument
	 * @param symbolStr {string} - String containing characters list.
	 * @returns {RegExp} - Regular expression.
	 */
	function generateRegExp(symbolStr) {
	  var symbolList = [];

	  for (var i = 0, n = symbolStr.length; i < n; ++i) {
	    symbolList[symbolList.length] = symbolStr[i].charCodeAt(0).toString(16);
	  }

	  var listStr = symbolList.join('|');

	  return new RegExp('%(?:' + listStr + ')', 'gi');
	}

	////////////////////////////////////////////////////////////////////////////
	// Create HTML element

	function createElement(tag, attrs, content) {
	  var element = document.createElement(tag);
	  var i, n;
	  if (attrs) {
	    var keys = Object.keys(attrs);
	    for (i = 0, n = keys.length; i < n; ++i) {
	      var key = keys[i];
	      element.setAttribute(key, attrs[key]);
	    }
	  }
	  if (content) {
	    if (!(content instanceof Array)) {
	      content = [content];
	    }
	    for (i = 0, n = content.length; i < n; ++i) {
	      var child = content[i];
	      if (typeof child === 'string') {
	        element.appendChild(document.createTextNode(child));
	      } else if (child instanceof HTMLElement) {
	        element.appendChild(child);
	      }
	    }
	  }
	  return element;
	}

	////////////////////////////////////////////////////////////////////////////
	// Easy inheritance

	/**
	 * Derive the class from the base.
	 * @param cls {function} - Class (constructor) to derive.
	 * @param base {function} - Class (constructor) to derive from.
	 * @param members {object=} - Optional instance members to add.
	 * @param statics {object=} - Optional static class members to add.
	 * @returns {function} Original class.
	 */
	function deriveClass(cls, base, members, statics) {
	  cls.prototype = lodash.assign(Object.create(base.prototype), { constructor: cls }, members);
	  if (statics) {
	    lodash.assign(cls, statics);
	  }
	  return cls;
	}

	////////////////////////////////////////////////////////////////////////////
	// Deep prototyping

	function deriveDeep(obj, needZeroOwnProperties) {
	  var res = obj;
	  var i, n;
	  if (obj instanceof Array) {
	    res = new Array(obj.length);
	    for (i = 0, n = obj.length; i < n; ++i) {
	      res[i] = deriveDeep(obj[i]);
	    }
	  } else if (obj instanceof Object) {
	    res = Object.create(obj);
	    var keys = Object.keys(obj);
	    for (i = 0, n = keys.length; i < n; ++i) {
	      var key = keys[i];
	      var value = obj[key];
	      var copy = deriveDeep(value);
	      if (copy !== value) {
	        res[key] = copy;
	      }
	    }
	    if (needZeroOwnProperties && Object.keys(res).length > 0) {
	      res = Object.create(res);
	    }
	  }
	  return res;
	}

	////////////////////////////////////////////////////////////////////////////
	// Colors

	function hexColor(color) {
	  var hex = ('0000000' + color.toString(16)).substr(-6);
	  return '#' + hex;
	}

	////////////////////////////////////////////////////////////////////////////
	// Debug tracing

	function DebugTracer(namespace) {
	  var enabled = false;

	  this.enable = function (on) {
	    enabled = on;
	  };

	  var indent = 0;
	  var methods = Object.keys(namespace);

	  function wrap(method_, name_) {
	    return function () {
	      var spaces = DebugTracer.spaces.substr(0, indent * 2);
	      if (enabled) {
	        logger.debug(spaces + name_ + ' {');
	      }
	      indent++;
	      var result = method_.apply(this, arguments); // eslint-disable-line no-invalid-this
	      indent--;
	      if (enabled) {
	        logger.debug(spaces + '} // ' + name_);
	      }
	      return result;
	    };
	  }

	  for (var i = 0, n = methods.length; i < n; ++i) {
	    var name = methods[i];
	    var method = namespace[name];
	    if (method instanceof Function && name !== 'constructor') {
	      namespace[name] = wrap(method, name);
	    }
	  }
	}

	DebugTracer.spaces = '                                                                                          ';

	function OutOfMemoryError(message) {
	  Error.call(this);
	  this.name = 'OutOfMemoryError';
	  this.message = message;
	}

	OutOfMemoryError.prototype = Object.create(Error.prototype);

	function allocateTyped(TypedArrayName, size) {
	  var result = null;
	  try {
	    result = new TypedArrayName(size);
	  } catch (e) {
	    if (e instanceof RangeError) {
	      throw new OutOfMemoryError(e.message);
	    } else {
	      throw e;
	    }
	  }
	  return result;
	}

	////////////////////////////////////////////////////////////////////////////
	// Float array conversion

	function bytesToBase64( /** ArrayBuffer */buffer) {
	  var bytes = new Uint8Array(buffer);
	  var binary = '';
	  for (var i = 0; i < bytes.byteLength; i++) {
	    binary += String.fromCharCode(bytes[i]);
	  }
	  return window.btoa(binary);
	}

	function bytesFromBase64( /** string */str) {
	  var binary = window.atob(str);
	  var bytes = new Uint8Array(binary.length);
	  for (var i = 0; i < bytes.length; ++i) {
	    bytes[i] = binary[i].charCodeAt(0);
	  }
	  return bytes.buffer;
	}

	function arrayToBase64( /** number[] */array, /** function */TypedArrayClass) {
	  return bytesToBase64(new TypedArrayClass(array).buffer);
	}

	function arrayFromBase64( /** string */str, /** function */TypedArrayClass) {
	  return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
	}

	//NOTE: this is 1-level comparison
	function compareOptionsWithDefaults(opts, defOpts) {
	  var optsStr = [];
	  if (defOpts && opts) {
	    var keys = Object.keys(opts);
	    for (var p = 0; p < keys.length; ++p) {
	      var key = keys[p];
	      var value = opts[key];
	      // TODO add processing for tree structure
	      if (!(value instanceof Object) && typeof defOpts[key] !== 'undefined' && defOpts[key] !== value) {
	        optsStr.push(key + ':' + value);
	      }
	    }
	    if (optsStr.length > 0) {
	      return '!' + optsStr.join();
	    }
	  }
	  return '';
	}

	function isAlmostPlainObject(o) {
	  if (lodash.isPlainObject(o)) {
	    return true;
	  }
	  var proto = o && Object.getPrototypeOf(o);
	  return !!proto && !proto.hasOwnProperty('constructor') && isAlmostPlainObject(proto);
	}

	/**
	 * Build an object that contains properties (and subproperties) of `src` different from those
	 * in `dst`. Objects are parsed recursively, other values (including arrays) are compared for
	 * equality using `_.isEqual()`.
	 * @param {!object} src - a new object to compare, may contain changed or new properties
	 * @param {!object} dst - an old reference object
	 */
	function objectsDiff(src, dst) {
	  var diff = {};
	  lodash.forIn(src, function (srcValue, key) {
	    var dstValue = dst[key];
	    if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
	      var deepDiff = objectsDiff(srcValue, dstValue);
	      if (!lodash.isEmpty(deepDiff)) {
	        diff[key] = deepDiff;
	      }
	    } else if (!lodash.isEqual(srcValue, dstValue)) {
	      diff[key] = srcValue;
	    }
	  });
	  return diff;
	}

	function forInRecursive(object, callback) {
	  function iterateThrough(obj, prefix) {
	    lodash.forIn(obj, function (value, key) {
	      var newPref = prefix + (prefix.length > 0 ? '.' : '');
	      if (value instanceof Object) {
	        iterateThrough(value, newPref + key);
	      } else if (value !== undefined) {

	        callback(value, newPref + key);
	      }
	    });
	  }
	  iterateThrough(object, '');
	}

	function enquoteString(value) {
	  if (lodash.isString(value)) {
	    return '"' + value.replace(/"/g, '\\"') + '"';
	  }
	  return value;
	}

	function unquoteString(value) {
	  if (!lodash.isString(value)) {
	    return value;
	  }
	  if (value[0] === '"' && value[value.length - 1] === '"') {
	    value = value.slice(1, value.length - 1);
	    return value.replace(/\\"/g, '"');
	  }
	  if (value[0] === "'" && value[value.length - 1] === "'") {
	    value = value.slice(1, value.length - 1);
	    return value.replace(/\\'/g, "'");
	  }
	  throw new SyntaxError('Incorrect string format, can\'t unqute it');
	}

	function getFileExtension(fileName) {
	  return fileName.slice(Math.max(0, fileName.lastIndexOf('.')) || Infinity);
	}

	function splitFileName(fileName) {
	  var ext = getFileExtension(fileName);
	  var name = fileName.slice(0, fileName.length - ext.length);
	  return [name, ext];
	}

	function dataUrlToBlob(url) {
	  var parts = url.split(/[:;,]/);
	  var partsCount = parts.length;
	  if (partsCount >= 3 && parts[partsCount - 2] === 'base64') {
	    return new Blob([bytesFromBase64(parts[partsCount - 1])]);
	  }
	  return null;
	}

	function shotOpen(url) {
	  if (typeof window !== 'undefined') {
	    window.open().document.write('<body style="margin:0"><img src="' + url + '" /></body>');
	  }
	}

	function shotDownload(dataUrl, filename) {
	  if (!dataUrl || dataUrl.substr(0, 5) !== 'data:') {
	    return;
	  }
	  if (!filename) {
	    filename = ['screenshot-', +new Date(), '.png'].join('');
	  }
	  if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
	    window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
	  } else if (typeof document !== 'undefined') {
	    var link = document.createElement('a');
	    link.download = filename;
	    link.innerHTML = 'download';
	    link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
	    document.body.appendChild(link);
	    link.click();
	    document.body.removeChild(link);
	  }
	}

	function copySubArrays(src, dst, indices, itemSize) {
	  for (var i = 0, n = indices.length; i < n; ++i) {
	    for (var j = 0; j < itemSize; ++j) {
	      dst[i * itemSize + j] = src[indices[i] * itemSize + j];
	    }
	  }
	}

	function shallowCloneNode(node) {
	  var newNode = node.cloneNode(true);
	  newNode.worldPos = node.worldPos;
	  // .style property is readonly, so "newNode.style = node.style;" won't work (and we don't need it, right?)
	  return newNode;
	}

	var unquotedStringRE = /^[a-zA-Z0-9_]*$/;
	var enquoteHelper = ['"', '', '"'];

	// verify and correct if needed selctor identifier
	function correctSelectorIdentifier(value) {
	  if (unquotedStringRE.test(value)) {
	    return value;
	  }
	  // quote incorrect identifier
	  enquoteHelper[1] = value;
	  return enquoteHelper.join('');
	}

	////////////////////////////////////////////////////////////////////////////
	// Exports

	var utils = {
	  Timer: Timer,
	  encodeQueryComponent: encodeQueryComponent,
	  decodeQueryComponent: decodeQueryComponent,
	  getUrlParameters: getUrlParameters,
	  getUrlParametersAsDict: getUrlParametersAsDict,
	  resolveURL: resolveURL,
	  generateRegExp: generateRegExp,
	  createElement: createElement,
	  deriveClass: deriveClass,
	  deriveDeep: deriveDeep,
	  hexColor: hexColor,
	  DebugTracer: DebugTracer,
	  OutOfMemoryError: OutOfMemoryError,
	  allocateTyped: allocateTyped,
	  bytesFromBase64: bytesFromBase64,
	  bytesToBase64: bytesToBase64,
	  arrayFromBase64: arrayFromBase64,
	  arrayToBase64: arrayToBase64,
	  compareOptionsWithDefaults: compareOptionsWithDefaults,
	  objectsDiff: objectsDiff,
	  forInRecursive: forInRecursive,
	  enquoteString: enquoteString,
	  unquoteString: unquoteString,
	  shotOpen: shotOpen,
	  shotDownload: shotDownload,
	  copySubArrays: copySubArrays,
	  shallowCloneNode: shallowCloneNode,
	  correctSelectorIdentifier: correctSelectorIdentifier,
	  getFileExtension: getFileExtension,
	  splitFileName: splitFileName
	};

	var now = utils.Timer.now;

	function createElement$1(tag, id, css) {
	  var element = document.createElement(tag);
	  element.id = id;
	  element.style.cssText = css;
	  return element;
	}

	function Stats() {
	  this.domElement = createElement$1('div', 'stats', 'padding:8px');
	  this._text = createElement$1('p', 'fps', 'margin:0;color:silver;font-size:large');
	  this.domElement.appendChild(this._text);

	  this._startTime = now();
	  this._prevTime = this._startTime;

	  this._deltas = new Array(20);
	  this._index = 0;
	  this._total = 0.0;
	  this._count = 0;
	}

	Stats.prototype = {
	  constructor: Stats,

	  begin: function begin() {
	    this._startTime = now();
	  },

	  end: function end() {
	    var time = now();
	    var delta = time - this._startTime;

	    if (this._count < this._deltas.length) {
	      this._count++;
	    } else {
	      this._total -= this._deltas[this._index];
	    }
	    this._total += delta;
	    this._deltas[this._index] = delta;
	    this._index = (this._index + 1) % this._deltas.length;

	    this.ms = this._total / this._count;
	    this.fps = 1000 / this.ms;

	    if (time > this._prevTime + 1000) {
	      this._text.textContent = this.fps.toPrecision(2);
	      this._prevTime = time;
	    }

	    return time;
	  },

	  update: function update() {
	    this._startTime = this.end();
	  },

	  show: function show(on) {
	    if (on === undefined) {
	      on = true;
	    }
	    this.domElement.style.display = on ? 'block' : 'none';
	  }

	};

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

	var defineProperty = function (obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

	var get = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = Object.getOwnPropertyDescriptor(object, property);

	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);

	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;

	    if (getter === undefined) {
	      return undefined;
	    }

	    return getter.call(receiver);
	  }
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};

	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var slicedToArray = function () {
	  function sliceIterator(arr, i) {
	    var _arr = [];
	    var _n = true;
	    var _d = false;
	    var _e = undefined;

	    try {
	      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	        _arr.push(_s.value);

	        if (i && _arr.length === i) break;
	      }
	    } catch (err) {
	      _d = true;
	      _e = err;
	    } finally {
	      try {
	        if (!_n && _i["return"]) _i["return"]();
	      } finally {
	        if (_d) throw _e;
	      }
	    }

	    return _arr;
	  }

	  return function (arr, i) {
	    if (Array.isArray(arr)) {
	      return arr;
	    } else if (Symbol.iterator in Object(arr)) {
	      return sliceIterator(arr, i);
	    } else {
	      throw new TypeError("Invalid attempt to destructure non-iterable instance");
	    }
	  };
	}();

	var toConsumableArray = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

	    return arr2;
	  } else {
	    return Array.from(arr);
	  }
	};

	var JobHandle = function (_EventDispatcher) {
	  inherits(JobHandle, _EventDispatcher);

	  function JobHandle() {
	    classCallCheck(this, JobHandle);

	    var _this = possibleConstructorReturn(this, (JobHandle.__proto__ || Object.getPrototypeOf(JobHandle)).call(this));

	    _this._shouldCancel = false;
	    return _this;
	  }

	  createClass(JobHandle, [{
	    key: 'cancel',
	    value: function cancel() {
	      this._shouldCancel = true;
	      this.dispatchEvent({ type: 'cancel' });
	    }
	  }, {
	    key: 'shouldCancel',
	    value: function shouldCancel() {
	      return this._shouldCancel;
	    }

	    // slaves use this to notify master about their events
	    // master routes these notifications to a single event slot

	  }, {
	    key: 'notify',
	    value: function notify(event) {
	      this.dispatchEvent({ type: 'notification', slaveEvent: event });
	    }
	  }]);
	  return JobHandle;
	}(EventDispatcher$1);

	var VERSION = 0;

	//////////////////////////////////////////////////////////////////////////
	/////////////////////     DEFAULT SETTINGS     ///////////////////////////
	//////////////////////////////////////////////////////////////////////////

	/**
	 * Polygonal complexity settings.
	 *
	 * @typedef PolyComplexity
	 * @property {number} poor
	 * @property {number} low
	 * @property {number} medium
	 * @property {number} high
	 * @property {number} ultra
	 */

	/**
	 * @alias SettingsObject
	 * @namespace
	 */
	var defaults$2 = {
	  /**
	   * Default options for all available modes.
	   * Use {@link Mode.id} as a dictionary key to access mode options.
	   *
	   * Usually you don't need to override these settings. You may specify mode options as a parameter during
	   * {@link Mode} construction.
	   *
	   * @memberof SettingsObject#
	   * @type {Object.<string, object>}
	   *
	   * @property {LinesModeOptions} LN - Lines mode options.
	   * @property {LicoriceModeOptions} LC - Licorice mode options.
	   * @property {BallsAndSticksModeOptions} BS - Balls and Sticks mode options.
	   * @property {VanDerWaalsModeOptions} VW - Van der Waals mode options.
	   * @property {TraceModeOptions} TR - Trace mode options.
	   * @property {TubeModeOptions} TU - Tube mode options.
	   * @property {CartoonModeOptions} CA - Cartoon mode options.
	   * @property {QuickSurfaceModeOptions} QS - Contact Surface mode options.
	   * @property {IsoSurfaceSASModeOptions} SA - Solvent Accessible Surface mode options.
	   * @property {IsoSurfaceSESModeOptions} SE - Solvent Excluded Surface mode options.
	   * @property {ContactSurfaceModeOptions} CS - Contact Surface mode options.
	   * @property {TextModeOptions} TX - Text mode options.
	   */
	  modes: {
	    /////////////////////    BALLS AND STICKS    ///////////////////////////
	    /**
	     * Balls and Sticks mode options.
	     *
	     * @typedef BallsAndSticksModeOptions
	     *
	     * @property {number} atom - Sphere radius as a fraction of Van der Waals atom radius.
	     * @property {number} bond - Cylinder radius in angstroms.
	     * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
	     *   available space.
	     * @property {boolean} multibond - Toggles rendering of multiple ordered bonds.
	     * @property {number} aromrad - Minor radius of a torus for aromatic loops.
	     * @property {boolean} showarom - Toggles rendering of aromatic loops.
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     */
	    BS: {
	      atom: 0.23,
	      bond: 0.15,
	      space: 0.5,
	      multibond: true,
	      aromrad: 0.1,
	      showarom: true,
	      polyComplexity: {
	        poor: 2,
	        low: 4,
	        medium: 6,
	        high: 12,
	        ultra: 32
	      }
	    },

	    ////////////////////       VAN DER WAALS      //////////////////////////
	    /**
	     * Van der Waals mode options.
	     *
	     * @typedef VanDerWaalsModeOptions
	     *
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     */
	    VW: {
	      polyComplexity: {
	        poor: 4,
	        low: 6,
	        medium: 8,
	        high: 16,
	        ultra: 32
	      }
	    },

	    ////////////////////           LINES          //////////////////////////
	    /**
	     * Lines mode options.
	     *
	     * @typedef LinesModeOptions
	     *
	     * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
	     * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
	     * @property {number} offsarom - Offset between bonds and aromatic cycle.
	     * @property {number} chunkarom - Number of pieces in a-loop arc, corresponding to atom.
	     * @property {number} atom - Collision radius for atoms picking.
	     * @property {number} lineWidth - Line width in pixels (not used in thin lines).
	     */
	    LN: {
	      multibond: true,
	      showarom: true,
	      offsarom: 0.2,
	      chunkarom: 10,
	      atom: 0.23,
	      lineWidth: 2
	    },

	    ////////////////////         LICORICE         //////////////////////////
	    /**
	     * Licorice mode options.
	     *
	     * @typedef LicoriceModeOptions
	     *
	     * @property {number} bond - Bond cylinder radius.
	     * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
	     *   available space.
	     * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
	     * @property {number} aromrad - Minor radius of a torus for aromatic loops.
	     * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
	     * @property {PolyComplexity} polyComplexity - Poly complexity values for render modes.
	     */
	    LC: {
	      bond: 0.20,
	      space: 0.0,
	      multibond: true,
	      aromrad: 0.1,
	      showarom: true,
	      polyComplexity: {
	        poor: 3,
	        low: 4,
	        medium: 6,
	        high: 12,
	        ultra: 32
	      }
	    },

	    ////////////////////          SURFACE   SAS   //////////////////////////
	    /**
	     * Solvent Accessible Surface mode options.
	     *
	     * @typedef IsoSurfaceSASModeOptions
	     *
	     * @property {boolean} zClip - Flag, that toggles z-clipping.
	     * @property {number} probeRadius - Radius of the probe.
	     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
	     *   Empty string means whole surface is visible.
	     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     */
	    SA: {
	      zClip: false,
	      probeRadius: 1.5,
	      subset: '',
	      wireframe: false,
	      polyComplexity: {
	        poor: 6,
	        low: 8,
	        medium: 16,
	        high: 30,
	        ultra: 60
	      }
	    },

	    ////////////////////          SURFACE   SES   //////////////////////////
	    /**
	     * Solvent Excluded Surface mode options.
	     *
	     * @typedef IsoSurfaceSESModeOptions
	     *
	     * @property {boolean} zClip - Flag, that toggles z-clipping.
	     * @property {number} probeRadius - Radius of the probe.
	     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
	     *   Empty string means whole surface is visible.
	     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     */
	    SE: {
	      zClip: false,
	      probeRadius: 1.5,
	      subset: '',
	      wireframe: false,
	      polyComplexity: {
	        poor: 6,
	        low: 8,
	        medium: 16,
	        high: 30,
	        ultra: 60
	      }
	    },

	    ////////////////////       QUICK SURFACE        //////////////////////////
	    /**
	     * Quick Surface mode options.
	     *
	     * @typedef QuickSurfaceModeOptions
	     *
	     * @property {number} isoValue - Isovalue of the surface to extract.
	     * @property {number} scale - Radius scale for the surface being built.
	     * @property {boolean} zClip - Flag, that toggles z-clipping.
	     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
	     *   Empty string means whole surface is visible.
	     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
	     * @property {PolyComplexity} gaussLim - Gauss lim for coloring the bigger the value, the smoother our colors are.
	     * @property {PolyComplexity} gridSpacing - Poly complexity values for render modes. In this case the value
	     *   corresponds to the grid density.
	     */
	    QS: {
	      isoValue: 0.5,
	      gaussLim: {
	        poor: 1.5,
	        low: 2.0,
	        medium: 2.5,
	        high: 3.0,
	        ultra: 4.0
	      },
	      scale: 1.0,
	      wireframe: false,
	      gridSpacing: {
	        poor: 2,
	        low: 1.5,
	        medium: 1,
	        high: 0.5,
	        ultra: 0.25
	      },
	      subset: '',
	      zClip: false
	    },

	    ////////////////////      CONTACT SURFACE       //////////////////////////
	    /**
	     * Contact Surface mode options.
	     *
	     * @typedef ContactSurfaceModeOptions
	     *
	     * @property {number} isoValue - Isovalue of the surface to extract.
	     * @property {number} probeRadius - Probe radius.
	     * @property {number} probePositions
	     * @property {boolean} zClip - Flag, that toggles z-clipping.
	     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
	     *   Empty string means whole surface is visible.
	     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
	     * @property {PolyComplexity} polyComplexity - Radius scale for the surface being built.
	     *   Poly complexity values for render modes. In this case the value corresponds to the grid density.
	     */
	    CS: {
	      probeRadius: 1.4,
	      isoValue: 1.5,
	      wireframe: false,
	      probePositions: 30,
	      polyComplexity: {
	        poor: 0.5,
	        low: 1.0,
	        medium: 1.5,
	        high: 1.75,
	        ultra: 2.0
	      },
	      subset: '',
	      zClip: false
	    },

	    ////////////////////           TRACE          //////////////////////////
	    /**
	     * Trace mode options.
	     *
	     * @typedef TraceModeOptions
	     *
	     * @property {number} radius - Cylinder radius.
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     */
	    TR: {
	      radius: 0.30,
	      polyComplexity: {
	        poor: 12,
	        low: 16,
	        medium: 32,
	        high: 64,
	        ultra: 64
	      }
	    },

	    ////////////////////           TUBE           //////////////////////////
	    /**
	     * Tube mode options.
	     *
	     * @typedef TubeModeOptions
	     *
	     * @property {number} radius - Cylinder radius.
	     * @property {number} tension - Tension for interpolation.
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
	     */
	    TU: {
	      radius: 0.30,
	      heightSegmentsRatio: 1.5,
	      tension: -0.7,
	      polyComplexity: {
	        poor: 5,
	        low: 6,
	        medium: 10,
	        high: 18,
	        ultra: 34
	      }
	    },

	    ////////////////////          CARTOON         //////////////////////////
	    /**
	     * Cartoon mode options.
	     *
	     * @typedef CartoonModeOptions
	     *
	     * @property {number} radius - Standard tube radius.
	     * @property {number} depth - Height of the secondary structure ribbon.
	     * @property {number} tension - Tension for interpolation.
	     * @proprety {object} ss - Secondary structure parameters.
	     * @proprety {object} ss.helix - Options for helices render.
	     * @proprety {number} ss.helix.width - Width of the secondary structure ribbon.
	     * @proprety {number} ss.helix.arrow - Secondary structure's arrow width.
	     * @proprety {object} ss.strand - Options for strands render.
	     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
	     * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
	     */
	    CA: {
	      radius: 0.30,
	      depth: 0.25,
	      ss: {
	        helix: {
	          width: 1.0,
	          arrow: 2.0
	        },
	        strand: {
	          width: 1.0,
	          arrow: 2.0
	        }
	      },
	      heightSegmentsRatio: 1.5,
	      tension: -0.7,
	      polyComplexity: {
	        poor: 5,
	        low: 6,
	        medium: 10,
	        high: 18,
	        ultra: 34
	      }
	    },

	    ////////////////////           TEXT           //////////////////////////
	    /**
	     * Text mode options.
	     *
	     * @typedef TextModeOptions
	     *
	     * @property {string} template - Format string for building output text.
	     * @property {string} horizontalAlign - Text alignment ('left', 'right', 'center').
	     * @property {string} verticalAlign - Vertical text box alignment ('top', 'bottom', 'middle').
	     * @property {number} dx - Text offset x in angstroms.
	     * @property {number} dy - Text offset y in angstroms.
	     * @property {number} dz - Text offset z in angstroms.
	     * @property {string} fg - Color rule for foreground.
	     * @property {string} bg - Color rule for background.
	     * @property {boolean} showBg - Flag, that toggles background rendering.
	     *
	     */
	    TX: {
	      template: '{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}',
	      horizontalAlign: 'center',
	      verticalAlign: 'middle',
	      dx: 0,
	      dy: 0,
	      dz: 1,
	      fg: 'none',
	      bg: '0x202020',
	      showBg: true
	    }
	  },

	  /**
	   * Default options for all available colorers.
	   * Use {@link Colorer.id} as a dictionary key to access colorer options.
	   *
	   * Usually you don't need to override these settings. You may specify colorer options as a parameter during
	   * {@link Colorer} construction.
	   *
	   * Not all colorers have options.
	   *
	   * @memberof SettingsObject#
	   * @type {Object.<string, object>}
	   *
	   * @property {ElementColorerOptions} EL - Element colorer options.
	   * @property {SequenceColorerOptions} SQ - Sequence colorer options.
	   * @property {MoleculeColorerOptions} MO - Molecule colorer options.
	   * @property {UniformColorerOptions} UN - Uniform colorer options.
	   * @property {ConditionalColorerOptions} CO - Conditional colorer options.
	   * @property {TemperatureColorerOptions} TM - Temperature colorer options.
	   * @property {OccupancyColorerOptions} OC - Occupancy colorer options.
	   * @property {HydrophobicityColorerOptions} HY - Hydrophobicity colorer options.
	   */
	  colorers: {
	    ////////////////////         ATOM TYPE        //////////////////////////
	    /**
	     * Element colorer options.
	     *
	     * @typedef ElementColorerOptions
	     *
	     * @property {number} carbon - Carbon color or -1 to use default.
	     */
	    EL: {
	      carbon: -1
	    },

	    ////////////////////          UNIFORM         //////////////////////////
	    /**
	     * Uniform colorer options.
	     *
	     * @typedef UniformColorerOptions
	     *
	     * @property {number} color - Single color to paint with.
	     */
	    UN: {
	      color: 0xFFFFFF
	    },

	    ////////////////////        CONDITIONAL       //////////////////////////
	    /**
	     * Conditional colorer options.
	     *
	     * @typedef ConditionalColorerOptions
	     *
	     * @property {string} subset - Selector string.
	     * @property {number} color - Color of selected atoms.
	     * @property {number} baseColor - Color of other atoms.
	     */
	    CO: {
	      subset: 'charged',
	      color: 0xFF0000,
	      baseColor: 0xFFFFFF
	    },

	    ////////////////////          CARBON         //////////////////////////
	    /**
	     * Carbon colorer options.
	     *
	     * @typedef CarbonColorerOptions
	     *
	     * @property {number} color - Single color to paint carbons
	     * @property {number} factor - Color factor for not carbon atoms.
	     */
	    CB: {
	      color: 0x909090,
	      factor: 0.6
	    },

	    ////////////////////         SEQUENCE         //////////////////////////
	    /**
	     * Sequence colorer options.
	     *
	     * @typedef SequenceColorerOptions
	     *
	     * @property {string} gradient - Name of gradient to use.
	     */
	    SQ: {
	      gradient: 'rainbow'
	    },

	    ////////////////////         TEMPERATURE      //////////////////////////
	    /**
	     * Temperature colorer options.
	     *
	     * @typedef TemperatureColorerOptions
	     *
	     * @property {string} gradient - Name of gradient to use.
	     * @property {number} min - Minimal temperature.
	     * @property {number} max - Maximal temperature.
	     */
	    TM: {
	      gradient: 'temp',
	      min: 5,
	      max: 40
	    },

	    ////////////////////         OCCUPANCY       //////////////////////////
	    /**
	     * Occupancy colorer options.
	     *
	     * @typedef OccupancyColorerOptions
	     *
	     * @property {string} gradient - Name of gradient to use.
	     */
	    OC: {
	      gradient: 'reds'
	    },

	    ////////////////////         HYDROPHOBICITY       //////////////////////////
	    /**
	     * Hydrophobicity colorer options.
	     *
	     * @typedef HydrophobicityColorerOptions
	     *
	     * @property {string} gradient - Name of gradient to use.
	     */
	    HY: {
	      gradient: 'blue-red'
	    },

	    ////////////////////         MOLECULE      //////////////////////////
	    /**
	     * Molecule colorer options.
	     *
	     * @typedef MoleculeColorerOptions
	     *
	     * @property {string} gradient - Name of gradient to use.
	     */
	    MO: {
	      gradient: 'rainbow'
	    }
	  },

	  /** @deprecated Old-fashioned atom labels, to be removed in the next major version. */
	  labels: 'no', // can be one of: no, obj, fg, bg.

	  /*
	     * Use antialiasing in WebGL.
	     * @type {boolean}
	     */
	  antialias: true,

	  /*
	     * Camera field of view in degrees.
	     * @type {number}
	     */
	  camFov: 45.0,

	  /*
	     * Camera near plane distance.
	     * @type {number}
	     */
	  camNear: 0.5,

	  /*
	     * Camera far plane distance.
	     * @type {number}
	     */
	  camFar: 100.0,

	  camDistance: 2.5,

	  radiusToFit: 1,

	  /**
	   * @type {number}
	   * @instance
	   */
	  fogNearFactor: 0.5, //[0, 1]

	  /**
	   * @type {number}
	   * @instance
	   */
	  fogFarFactor: 1, //[0, 1]
	  fogAlpha: 1.0,
	  fogColor: 0x000000,
	  fogColorEnable: false,

	  /*
	     * Palette used for molecule coloring.
	     * @type {string}
	     */
	  palette: 'JM',

	  /*
	     * Geometry resolution.
	     * @type {string}
	     */
	  resolution: 'medium',

	  autoResolution: false /*true*/

	  , autoPreset: true,

	  preset: 'default', // TODO: remove 'preset' from settings, implement autodetection

	  presets: {
	    // Default
	    default: [{
	      mode: 'BS',
	      colorer: 'EL',
	      selector: 'all',
	      material: 'SF'
	    }],

	    empty: [],

	    // Wireframe
	    wire: [{
	      mode: 'LN',
	      colorer: 'EL',
	      selector: 'all',
	      material: 'SF'
	    }],

	    // Small molecules
	    small: [{
	      mode: 'BS',
	      colorer: 'EL',
	      selector: 'all',
	      material: 'SF'
	    }],

	    // Proteins, nucleic acids etc.
	    macro: [{
	      mode: 'CA',
	      colorer: 'SS',
	      selector: 'not hetatm',
	      material: 'SF'
	    }, {
	      mode: 'BS',
	      colorer: 'EL',
	      selector: 'hetatm and not water',
	      material: 'SF'
	    }]
	  },

	  objects: {
	    line: {
	      color: 0xFFFFFFFF,
	      dashSize: 0.3,
	      gapSize: 0.05
	    }
	  },

	  /////////////////////////////////////////////////////////////////

	  /**
	   * Theme to use, 'dark' or 'light'.
	   * @type {string}
	   * @instance
	   * @deprecated Old-fashioned theme paradigma, to be removed in the next major version.
	   */
	  theme: 'dark',
	  /** @deprecated Old-fashioned theme paradigma, to be removed in the next major version. */
	  themes: {
	    dark: 0x202020,
	    light: 0xcccccc
	  },

	  bg: {
	    color: 0x202020,
	    transparent: false
	  },

	  draft: {
	    clipPlane: false,
	    clipPlaneFactor: 0.5,
	    clipPlaneSpeed: 0.00003,
	    waterBondingHack: false
	  },

	  /*
	     * Separate group for plugins.
	     * Each plugin handles its field by itself.
	     */
	  plugins: {},

	  /**
	   * @type {boolean}
	   * @instance
	   */
	  axes: true,

	  /**
	   * @type {boolean}
	   * @instance
	   */
	  fog: true,

	  /**
	   * @type {boolean}
	   * @instance
	   */
	  fps: true,

	  zSprites: true,

	  isoSurfaceFakeOpacity: true,

	  /**
	   * @type {boolean}
	   * @instance
	   */
	  suspendRender: true,

	  nowater: false,

	  /**
	   * @type {boolean}
	   * @instance
	   */
	  autobuild: true,

	  /**
	   * Anti-aliasing.
	   * @type {boolean}
	   * @instance
	   */
	  fxaa: true,
	  /**
	   * Outline depths
	   * @type {boolean}
	   * @instance
	   */
	  outline: {
	    on: false,
	    color: 0x000000,
	    threshold: 0.1
	  },

	  /**
	   * Ambient Occlusion special effect.
	   * @type {boolean}
	   * @instance
	   */
	  ao: false,

	  /**
	   * Auto-rotation with constant speed.
	   * @type {number}
	   * @instance
	   */
	  autoRotation: 0.0,

	  // maximum fps for animation
	  maxfps: 30,

	  // fbx output precision
	  fbxprec: 4,

	  /**
	   * Auto-rotation axis.
	   *
	   * - true:  complex auto-rotation is about vertical axis
	   * - false: rotation axis is defined by last user rotation
	   *
	   * @type {boolean}
	   * @instance
	   */
	  autoRotationAxisFixed: true,

	  /**
	   * Enable zooming with mouse wheel or pinch gesture.
	   * @type {boolean}
	   * @instance
	   */
	  zooming: true,

	  /** @deprecated  Move object instead of panning the camera */
	  panning: false,

	  /** @deprecated  Move object instead of panning the camera */
	  inversePanning: false,

	  /**
	   * Enable picking atoms & residues with left mouse button or touch.
	   * @type {boolean}
	   * @instance
	   */
	  picking: true,

	  /**
	   * Set picking mode ('atom', 'residue', 'chain', 'molecule').
	   * @type {string}
	   * @instance
	   */
	  pick: 'atom',

	  /**
	   * Make "component" and "fragment" editing modes available.
	   * @type {boolean}
	   * @instance
	   */
	  editing: false,

	  /**
	   * Detect aromatic loops.
	   * @type {boolean}
	   * @instance
	   */
	  aromatic: false,

	  // load only one biological unit from all those described in PDB file
	  singleUnit: true,

	  /**
	   * @type {string}
	   * @instance
	   */
	  stereo: 'NONE',

	  /**
	   * Enable smooth transition between views
	   * @type {boolean}
	   * @instance
	   */
	  interpolateViews: true,

	  // switch transparency mode ('standard', 'prepass')
	  transparency: 'prepass',

	  /**
	   * Mouse translation speed.
	   * @type {number}
	   * @instance
	   */
	  translationSpeed: 2,

	  debug: {
	    example: 3.5,
	    text: 'hello!',
	    good: true,
	    ssaoKernelRadius: 0.7,
	    ssaoFactor: 0.7,
	    stereoBarrel: 0.25
	  },
	  use: {
	    multiFile: false
	  }
	};

	//////////////////////////////////////////////////////////////////////////
	/////////////////////      SETTINGS CLASS      ///////////////////////////
	//////////////////////////////////////////////////////////////////////////

	function Settings() {
	  EventDispatcher$1.call(this);

	  this.old = null;
	  this.now = {};
	  this._changed = {};

	  this.reset();
	}

	utils.deriveClass(Settings, EventDispatcher$1, {
	  defaults: defaults$2,

	  set: function set(path, value) {
	    if (lodash.isString(path)) {
	      var oldValue = lodash.get(this.now, path);
	      if (oldValue !== value) {
	        lodash.set(this.now, path, value);
	        this._notifyChange(path, value);
	      }
	    } else {
	      var diff = utils.objectsDiff(path, this.now);
	      if (!lodash.isEmpty(diff)) {
	        lodash.merge(this.now, diff);
	        this._notifyChanges(diff);
	      }
	    }
	  },

	  get: function get(path, defaultValue) {
	    return lodash.get(this.now, path, defaultValue);
	  },

	  reset: function reset() {
	    var diff = utils.objectsDiff(defaults$2, this.now);
	    this.now = lodash.cloneDeep(defaults$2);
	    this.old = null;
	    this._notifyChanges(diff);
	    this._changed = {};
	  },

	  checkpoint: function checkpoint() {
	    this.old = lodash.cloneDeep(this.now);
	    this._changed = {};
	  },

	  _notifyChange: function _notifyChange(path, value) {
	    this._changed[path] = true;
	    this.dispatchEvent({ type: 'change:' + path, value: value });
	  },

	  _notifyChanges: function _notifyChanges(diff) {
	    var _this = this;

	    utils.forInRecursive(diff, function (deepValue, deepPath) {
	      _this._notifyChange(deepPath, deepValue);
	    });
	  },

	  changed: function changed() {
	    if (!this.old) {
	      return [];
	    }
	    var old = this.old;
	    var now = this.now;
	    var keys = lodash.filter(Object.keys(this._changed), function (key) {
	      return lodash.get(old, key) !== lodash.get(now, key);
	    });
	    return keys;
	  },

	  /** @deprecated Use Settings#set instead */
	  override: function override(other) {
	    this.set(other);
	  },

	  applyDiffs: function applyDiffs(diffs) {
	    // TODO Change inequality to >=?
	    if (diffs.hasOwnProperty('VERSION') && diffs.VERSION !== VERSION) {
	      throw new Error('Settings version does not match!');
	    }
	    // VERSION shouldn't be presented inside settings structure
	    delete diffs.VERSION;
	    this.reset();
	    this.set(diffs);
	  },

	  getDiffs: function getDiffs(versioned) {
	    var diffs = utils.objectsDiff(this.now, defaults$2);
	    if (versioned) {
	      diffs.VERSION = VERSION;
	    }
	    return diffs;
	  },

	  setPluginOpts: function setPluginOpts(plugin, opts) {
	    defaults$2.plugins[plugin] = lodash.cloneDeep(opts);
	    this.now.plugins[plugin] = lodash.cloneDeep(opts);
	  }
	});

	var settings = new Settings();

	var repIndex = 0;

	function asBoolean(value) {
	  return !(!value || value === '0' || lodash.isString(value) && value.toLowerCase() === 'false');
	}

	var adapters = {
	  'string': String,
	  'number': Number,
	  'boolean': asBoolean
	};

	// Level 1 assignment symbol
	var cL1Ass = '=';

	var cOptsSep = '!';
	// Level 2 (options) assignment symbol
	var cL2Ass = ':';
	// Level 2 (options) separator symbol
	var cLSep = ',';

	var cCommonIgnoreSymbols = '$;@/?';
	/**
	 * We may (and should) leave as is for better readability:
	 *
	 *        $ , ; : @ / ?
	 */
	/**
	 * Generate regular expression for symbols excluded for first level encryption
	 */
	function getLevel1ExcludedExpr() {
	  var cLevel1Ignores = ':,';
	  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
	}

	/**
	 * Generate regular expression for symbols excluded for first level encryption
	 * (options, etc, ..)
	 */
	function getLevel2ExcludedExpr() {
	  var cLevel2Ignores = ' ';
	  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
	}

	var cL1ExclExpr = getLevel1ExcludedExpr();
	function encodeQueryComponentL1(value) {
	  return utils.encodeQueryComponent(value, cL1ExclExpr);
	}

	var cL2ExclExpr = getLevel2ExcludedExpr();
	function encodeQueryComponentL2(value) {
	  return utils.encodeQueryComponent(value, cL2ExclExpr);
	}

	function ensureRepList(opts) {
	  var reps = opts.reps;
	  if (!reps) {
	    var presets = settings.now.presets;
	    var preset = opts.preset || settings.now.preset;
	    reps = presets[preset];
	    if (!reps) {
	      logger.warn('Unknown preset "' + preset + '"');
	      preset = Object.keys(presets)[0];
	      reps = presets[preset]; // fall back to any preset
	    }
	    opts.preset = preset;
	    opts.reps = utils.deriveDeep(reps, true);
	  }
	}

	function ensureRepAssign(opts, prop, value) {
	  ensureRepList(opts);
	  var rep = opts.reps[repIndex];
	  // prop specified twice therefore start new rep by cloning the current
	  if (rep.hasOwnProperty(prop)) {
	    if (++repIndex >= opts.reps.length) {
	      opts.reps[repIndex] = utils.deriveDeep(rep, true);
	    }
	  }
	  if (value !== undefined) {
	    opts.reps[repIndex][prop] = value;
	  }
	}

	function addObject(opts, params, options) {
	  if (opts._objects === undefined) {
	    opts._objects = [];
	  }

	  var newObj = {
	    type: options[0],
	    params: params
	  };

	  if (options[1] !== undefined) {
	    newObj.opts = options[1];
	  }

	  opts._objects[opts._objects.length] = newObj;
	}

	function parseParams(str, params) {
	  var sep = str.indexOf(',');
	  if (sep >= 0) {
	    params.push(str.substr(sep + 1).split(','));
	    return str.substr(0, sep);
	  }
	  // keep this untouched if no params were extracted
	  return str;
	}

	function extractArgs(input, defaultsDict, params) {
	  if (input) {
	    var bang = input.indexOf(cOptsSep);
	    var inputVal = parseParams(input.substr(0, bang >= 0 ? bang : undefined), params);
	    if (bang >= 0) {
	      var args = input.substr(bang + 1).split(cLSep);
	      input = inputVal;
	      if (defaultsDict) {
	        var defaults = defaultsDict[input];
	        var opts = utils.deriveDeep(defaults, true);
	        args.forEach(function (arg) {
	          var pair = arg.split(cL2Ass, 2);
	          var key = decodeURIComponent(pair[0]),
	              value = decodeURIComponent(pair[1]);
	          var adapter = adapters[_typeof(lodash.get(defaults, key))];
	          if (adapter) {
	            lodash.set(opts, key, adapter(value));
	          } else {
	            logger.warn('Unknown argument "' + key + '" for option "' + input + '"');
	          }
	        });
	        if (Object.keys(opts).length > 0) {
	          input = [input, opts];
	        }
	      }
	    } else {
	      input = inputVal;
	    }
	  }
	  return input;
	}

	var actions = {

	  //////////////////////////////////////////////////////////////////////////////
	  // Options

	  'l': 'load', 'load': String,
	  't': 'type', 'type': String,
	  'v': 'view', 'view': String,
	  'u': 'unit', 'unit': Number,
	  'menu': asBoolean,

	  //////////////////////////////////////////////////////////////////////////////
	  // Commands

	  'o': 'object', 'object': function object(value, opts) {
	    var params = [];
	    var options = extractArgs(value, settings.defaults.objects, params);
	    if (!Array.isArray(options)) {
	      options = [options];
	    }
	    addObject(opts, params[0], options);
	  },

	  'p': 'preset', 'preset': function preset(value, opts) {
	    opts.preset = value;
	    opts.reps = null;
	    ensureRepList(opts);
	  },

	  'r': 'rep', 'rep': function rep(value, opts) {
	    ensureRepList(opts);
	    repIndex = Number(value);
	    // clamp the index to one greater than the last
	    repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length;
	    // create a new rep if it is adjacent to the existing ones
	    if (repIndex === opts.reps.length) {
	      // if there is no rep to derive from, derive from the first rep of the default
	      opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings.defaults.presets.default[0], true);
	    }
	  },

	  's': 'select', 'select': function select(value, opts) {
	    ensureRepAssign(opts, 'selector', value);
	  },

	  'm': 'mode', 'mode': function mode(value, opts) {
	    ensureRepAssign(opts, 'mode', extractArgs(value, settings.defaults.modes));
	  },

	  'c': 'color', 'color': function color(value, opts) {
	    ensureRepAssign(opts, 'colorer', extractArgs(value, settings.defaults.colorers));
	  },

	  'mt': 'material', 'material': function material(value, opts) {
	    ensureRepAssign(opts, 'material', extractArgs(value, settings.defaults.materials));
	  },

	  'dup': function dup(value, opts) {
	    ensureRepList(opts);
	    var reps = opts.reps;
	    var rep = reps[repIndex];
	    if (++repIndex >= reps.length) {
	      reps[repIndex] = utils.deriveDeep(rep, true);
	    }
	  },

	  //////////////////////////////////////////////////////////////////////////////
	  // Settings shortcuts

	  'ar': 'autoResolution',

	  //////////////////////////////////////////////////////////////////////////////
	  // Deprecated

	  'background': 'theme'
	};

	function _fromArray(entries) {
	  repIndex = 0;

	  var opts = {};
	  for (var i = 0, n = entries.length; i < n; ++i) {
	    var /** string[] */entry = entries[i];
	    var /** string? */key = entry[0];
	    var /** string? */value = entry[1];
	    var /** function|string? */action = actions[key];

	    // unwind shortcuts and aliases
	    while (lodash.isString(action)) {
	      key = action;
	      action = actions[key];
	    }

	    // either set a property or use specialized parser
	    if (!action) {
	      var adapter = adapters[_typeof(lodash.get(settings.defaults, key))];
	      if (adapter) {
	        lodash.set(opts, 'settings.' + key, adapter(value));
	      } else {
	        logger.warn('Unknown option "' + key + '"');
	      }
	    } else if (lodash.isFunction(action)) {
	      var result = action(value, opts);
	      if (result !== undefined) {
	        opts[key] = result;
	      }
	    }
	  }

	  return opts;
	}

	function fromAttr(attr) {
	  return _fromArray(utils.getUrlParameters('?' + (attr || ''))); // TODO: We need different processing for attrs.
	}

	function fromURL(url) {
	  return _fromArray(utils.getUrlParameters(url));
	}

	function _processOptsForURL(opts) {
	  var str = [];
	  var i = 0;
	  utils.forInRecursive(opts, function (value, key) {
	    str[i++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
	  });
	  return str.join(cLSep);
	}

	function _processArgsForURL(args) {
	  if (!lodash.isArray(args)) {
	    return args;
	  }
	  return args[0] + (args.length < 2 ? '' : cOptsSep + _processOptsForURL(args[1]));
	}

	function _processObjForURL(objOpts) {
	  if (!objOpts || !objOpts.type) {
	    return undefined;
	  }
	  var res = objOpts.type;
	  if (lodash.isArray(objOpts.params) && objOpts.params.length > 0) {
	    res += ',' + objOpts.params.join(',');
	  }
	  if (objOpts.opts) {
	    res += cOptsSep + _processOptsForURL(objOpts.opts);
	  }
	  return res;
	}

	function toURL(opts) {
	  var stringList = [];
	  var idx = 0;

	  function checkAndAdd(prefix, value) {
	    if (value !== null && value !== undefined) {
	      stringList[idx++] = encodeQueryComponentL1(prefix) + cL1Ass + encodeQueryComponentL1(value);
	    }
	  }

	  function addReps(repList) {
	    if (!repList) {
	      return;
	    }
	    for (var i = 0, n = repList.length; i < n; ++i) {
	      if (lodash.isEmpty(repList[i])) {
	        continue;
	      }
	      checkAndAdd('r', i);
	      checkAndAdd('s', repList[i].selector);
	      checkAndAdd('m', _processArgsForURL(repList[i].mode));
	      checkAndAdd('c', _processArgsForURL(repList[i].colorer));
	      checkAndAdd('mt', _processArgsForURL(repList[i].material));
	    }
	  }

	  function addObjects(objList) {
	    if (!objList) {
	      return;
	    }
	    for (var i = 0, n = objList.length; i < n; ++i) {
	      checkAndAdd('o', _processObjForURL(objList[i]));
	    }
	  }

	  checkAndAdd('l', opts.load);
	  checkAndAdd('u', opts.unit);
	  checkAndAdd('p', opts.preset);
	  addReps(opts.reps);
	  addObjects(opts._objects);

	  checkAndAdd('v', opts.view);

	  utils.forInRecursive(opts.settings, function (value, key) {
	    // I heard these lines in the whispers of the Gods
	    // Handle preset setting in reps
	    if (key === 'preset') {
	      // TODO: remove 'preset' from settings, implement autodetection
	      return;
	    }
	    checkAndAdd(key, value);
	  });

	  var url = '';
	  if (typeof window !== 'undefined') {
	    var location = window.location;
	    url = location.protocol + '//' + location.host + location.pathname;
	  }
	  if (stringList.length > 0) {
	    url += '?' + stringList.join('&');
	  }

	  return url;
	}

	function _processOptsForScript(opts) {
	  var str = [];
	  var i = 0;
	  utils.forInRecursive(opts, function (value, key) {
	    str[i++] = key + '=' + utils.enquoteString(value);
	  });
	  return str.join(' ');
	}

	function _processArgsForScript(args) {
	  if (!lodash.isArray(args)) {
	    return args;
	  }
	  return args[0] + (args.length < 2 ? '' : ' ' + _processOptsForScript(args[1]));
	}

	function _processObjForScript(objOpts) {
	  if (!objOpts || !objOpts.type) {
	    return undefined;
	  }
	  var res = objOpts.type;
	  if (lodash.isArray(objOpts.params) && objOpts.params.length > 0) {
	    res += ' ' + objOpts.params.map(utils.enquoteString).join(' ');
	  }
	  if (objOpts.opts) {
	    res += ' ' + _processOptsForScript(objOpts.opts);
	  }
	  return res;
	}

	function _processRepsForScript(rep, index) {
	  var repString = [];
	  var strIdx = 0;
	  function localAdd(prefix, value) {
	    if (value !== null && value !== undefined) {
	      repString[strIdx++] = prefix + value;
	    }
	  }
	  if (lodash.isEmpty(rep)) {
	    return null;
	  }
	  localAdd('', index);
	  localAdd('s=', utils.enquoteString(rep.selector));
	  localAdd('m=', _processArgsForScript(rep.mode));
	  localAdd('c=', _processArgsForScript(rep.colorer));
	  localAdd('mt=', _processArgsForScript(rep.material));
	  return repString.join(' ');
	}

	function toScript(opts) {
	  var commandsList = [];
	  var idx = 0;
	  function checkAndAdd(command, value, saveQuotes) {
	    if (value !== null && value !== undefined) {
	      var quote = typeof value === 'string' && saveQuotes ? '"' : '';
	      commandsList[idx++] = command + ' ' + quote + value + quote;
	    }
	  }

	  function addReps(repList) {
	    if (!repList) {
	      return;
	    }

	    for (var i = 0, n = repList.length; i < n; ++i) {
	      checkAndAdd('rep', _processRepsForScript(repList[i], i));
	    }
	  }

	  function addObjects(objList) {
	    if (!objList) {
	      return;
	    }
	    for (var i = 0, n = objList.length; i < n; ++i) {
	      checkAndAdd('', _processObjForScript(objList[i]));
	    }
	  }

	  checkAndAdd('set', 'autobuild false');
	  checkAndAdd('load', opts.load, true);
	  checkAndAdd('unit', opts.unit);
	  checkAndAdd('preset', opts.preset);
	  addReps(opts.reps);
	  addObjects(opts._objects);

	  utils.forInRecursive(opts.settings, function (value, key) {
	    // I heard these lines in the whispers of the Gods
	    // Handle preset setting in reps
	    if (key === 'preset') {
	      return;
	    }
	    checkAndAdd('set ' + key, value, true);
	  });
	  checkAndAdd('view', opts.view);

	  // this is kind of hack
	  checkAndAdd('set', 'autobuild true');
	  return commandsList.join('\n');
	}

	var options = {
	  fromURL: fromURL,
	  fromAttr: fromAttr,
	  adapters: adapters,
	  toURL: toURL,
	  toScript: toScript
	};

	/**
	 * Atom name: simple and cooked.
	 *
	 * @param {string} name    - Simple atom name as a sting
	 * @param {object} node    - Cooked name for pretty printing
	 *
	 * @exports Atom
	 * @constructor
	 */
	function AtomName(name, node) {
	  this._node = node || null;
	  this._name = name || null;
	  if (this._node === null && this._name === null) {
	    this._name = 'Unknown';
	  }
	}

	/**
	 * Get atom full name.
	 * @returns {string} Atom simple name.
	 */
	AtomName.prototype.getString = function () {
	  return this._name || 'unknown';
	};

	/**
	 * Get atom full pretty name.
	 * @returns {object} Atom simple name.
	 */
	AtomName.prototype.getNode = function () {
	  return this._node || null;
	};

	// TODO: See ResidueType and make this Element in similar way

	function Element(number, name, fullName, weight, radius, radiusBonding, hValency) {
	  this.number = number;
	  this.name = name;
	  this.fullName = fullName;
	  this.weight = weight;
	  this.radius = radius;
	  this.radiusBonding = radiusBonding;
	  this.hydrogenValency = hValency;
	}

	Element.Constants = {
	  /* eslint-disable no-magic-numbers */
	  U1: 1,
	  Lead: 2,
	  U2: 3,
	  Wing: 4,
	  U18: 18
	  /* eslint-enable no-magic-numbers */
	};

	Element.Role = {
	  /* eslint-disable no-magic-numbers */
	  N: Element.Constants.U1,
	  CA: Element.Constants.Lead,
	  C: Element.Constants.U2,
	  O: Element.Constants.Wing,
	  SG: Element.Constants.U18
	  /* eslint-enable no-magic-numbers */
	};

	// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
	Element.ByAtomicNumber = [
	/* eslint-disable no-magic-numbers */
	null, new Element(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]), new Element(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]), new Element(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]), new Element(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]), new Element(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]), new Element(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]), new Element(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [3, 5]), new Element(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [2, 4]), new Element(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]), new Element(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]), new Element(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]), new Element(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]), new Element(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]), new Element(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]), new Element(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [3, 5]), new Element(16, 'S', 'Sulfur', 32.07, 2, 1.02, [2, 4, 6]), new Element(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [1, 3, 5, 7]), new Element(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]), new Element(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]), new Element(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]), new Element(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]), new Element(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]), new Element(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]), new Element(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]), new Element(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]), new Element(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]), new Element(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]), new Element(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]), new Element(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]), new Element(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]), new Element(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]), new Element(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]), new Element(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [3, 5]), new Element(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [2, 4, 6]), new Element(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [1, 3, 5, 7]), new Element(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]), new Element(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]), new Element(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]), new Element(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]), new Element(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]), new Element(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]), new Element(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]), new Element(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]), new Element(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]), new Element(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]), new Element(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]), new Element(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]), new Element(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]), new Element(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]), new Element(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [2, 4]), new Element(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [3, 5]), new Element(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [2, 4, 6]), new Element(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [1, 3, 5, 7]), new Element(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]), new Element(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]), new Element(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]), new Element(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]), new Element(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]), new Element(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]), new Element(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]), new Element(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]), new Element(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]), new Element(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]), new Element(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]), new Element(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]), new Element(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]), new Element(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]), new Element(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]), new Element(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]), new Element(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]), new Element(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]), new Element(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]), new Element(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]), new Element(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]), new Element(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]), new Element(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]), new Element(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]), new Element(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]), new Element(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]), new Element(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]), new Element(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [1, 3]), new Element(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [2, 4]), new Element(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [3, 5]), new Element(84, 'PO', 'Polonium', 210, 1.7, 1.68, [2, 4, 6]), new Element(85, 'AT', 'Astatine', 210, 1.7, 1.7, [1, 3, 5, 7]), new Element(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]), new Element(87, 'FR', 'Francium', 223, 1.7, 2, [1]), new Element(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]), new Element(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]), new Element(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]), new Element(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]), new Element(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]), new Element(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]), new Element(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]), new Element(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]), new Element(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]), new Element(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]), new Element(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]), new Element(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]), new Element(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]), new Element(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]), new Element(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]), new Element(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]), new Element(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]), new Element(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]), new Element(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]), new Element(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]), new Element(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]), new Element(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])];

	// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
	Element.ByName = {
	  // Duplicate atomic numbers (isotopes)
	  /* eslint-disable no-magic-numbers */
	  'D': new Element(1, 'D', 'Deuterium', 2.014, 1.2, 0.23, [1]),
	  'T': new Element(1, 'T', 'Tritium', 3.016, 1.2, 0.23, [1])
	  /* eslint-enable no-magic-numbers */

	  // All regular elements will be added later, automatically
	};

	(function () {
	  var byAtomicNumber = Element.ByAtomicNumber;
	  var byName = Element.ByName;
	  for (var i = 0, n = byAtomicNumber.length; i < n; ++i) {
	    var element = byAtomicNumber[i];
	    if (element) {
	      byName[element.name] = element;
	    }
	  }
	})();

	// find atom type by chemical element (or create if missing)
	Element.getByName = function (element) {
	  var type = Element.ByName[element];
	  if (!type) {
	    type = Element.ByName[element] = new Element(0, element, 'Unknown', 0, 1.0, 0.01, [0]);
	  }
	  return type;
	};

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Atom measurements.
	 *
	 * @param {Residue} residue    - Residue containing the atom
	 * @param {AtomName} name        - Name, unique in the residue
	 * @param {Element} type      - Chemical element reference
	 * @param {THREE.Vector3} position - Registered coordinates
	 *
	 * @param {number} role        - Role of atom inside monomer: Lead and wing are particularity interesting
	 * @param {boolean} het        - Non-standard residue indicator
	 *
	 * @param {number} serial      - Serial number, unique in the model
	 * @param {string} location    - Alternative location indicator (usually space or A-Z)
	 * @param {number} occupancy   - Occupancy percentage, from 0 to 1
	 * @param {number} temperature - Temperature
	 * @param {number} charge      - Charge
	 *
	 * @exports Atom
	 * @constructor
	 */
	function Atom(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
	  this._index = -1;
	  this._residue = residue;
	  if (name instanceof AtomName) {
	    this._name = name;
	  } else {
	    this._name = new AtomName(name);
	  }

	  this.element = type;
	  this._position = position;
	  this._role = role;
	  this._mask = 1 | 0;
	  this._index = -1;

	  this._het = het;

	  this._serial = serial;
	  this._location = (location || ' ').charCodeAt(0);
	  this._occupancy = occupancy || 1;
	  this._temperature = temperature;
	  this._charge = charge;
	  this._hydrogenCount = -1; //explicitly invalid
	  this._radicalCount = 0;
	  this._valence = -1; //explicitly invalid

	  this._bonds = [];

	  this.flags = 0x0000;
	  if (type.name === 'H') {
	    this.flags |= Atom.Flags.HYDROGEN;
	  } else if (type.name === 'C') {
	    this.flags |= Atom.Flags.CARBON;
	  }
	}

	/**
	 * Enumeration of atom flag values.
	 *
	 * @enum {number}
	 * @readonly
	 */
	Atom.Flags = {
	  CARBON: 0x0001,
	  // OXYGEN: 0x0002,
	  // NITROGEN: 0x0004,
	  HYDROGEN: 0x0008,
	  /** Non-polar hydrogen (it is also a HYDROGEN) */
	  NONPOLARH: 0x1008
	};

	/**
	 * Get atom full name.
	 * @returns {AtomName} Atom full name.
	 */
	Atom.prototype.getName = function () {
	  return this._name;
	};

	Atom.prototype.getPosition = function () {
	  return this._position;
	};

	Atom.prototype.getResidue = function () {
	  return this._residue;
	};

	Atom.prototype.getSerial = function () {
	  return this._serial;
	};

	Atom.prototype.getBonds = function () {
	  return this._bonds;
	};

	Atom.prototype.isHet = function () {
	  return this._het;
	};

	Atom.prototype.isHydrogen = function () {
	  return this.element.number === 1;
	};

	Atom.prototype.getValence = function () {
	  return this._valence === -1 ? 0 : this._valence;
	};

	Atom.prototype.getVisualName = function () {
	  var name = this.getName();
	  if (name.getString().length > 0) {
	    return name.getString();
	  } else {
	    return this.element.name.trim();
	  }
	};

	Atom.prototype.forEachBond = function (process) {
	  var bonds = this._bonds;
	  for (var i = 0, n = bonds.length; i < n; ++i) {
	    process(bonds[i]);
	  }
	};

	/** @deprecated Old-fashioned atom labels, to be removed in the next major version. */
	Atom.prototype.isLabelVisible = function () {
	  if (this.getName().getNode() !== null) {
	    return true;
	  }
	  if (this.element === null) {
	    return false;
	  }
	  if (this.element.number === Element.ByName.C.number) {
	    var n = this.getVisualName();
	    if (n === null) {
	      return false;
	    }
	    if (n.length === 1 && n.charCodeAt(0) === 0x43 && this.getBonds().length !== 0) {
	      return false;
	    }
	  }

	  return true;
	};

	Atom.prototype.getHydrogenCountBoron = function () {
	  //examples
	  //BH3*BH4(1-)*BH2(1+)*BH3(2-)*BH(2+)
	  var valence = 3; //hardcoded as 3
	  var hc = valence - this.getCharge() - this.getAtomBondsCount() - this._radicalCount;
	  return Math.max(0, hc);
	};

	Atom.prototype.getHydrogenCountTin = function () {
	  var valence = this._valence;
	  if (valence === -1) {
	    valence = this.getAtomBondsCount() - Math.abs(this.getCharge()) + this._radicalCount;
	  }

	  var defVal = this.findSuitableValence(valence);
	  if (this.getCharge() !== 0) {
	    defVal = 4;
	  }
	  //find default valency for our case
	  return Math.max(0, defVal - valence);
	};

	Atom.prototype.getHydrogenCountMetal = function () {
	  return 0;
	};

	Atom.prototype.getHydrogenCountGroup14 = function () {
	  var valence = this._valence;
	  if (valence === -1) {
	    valence = this.getAtomBondsCount() - Math.abs(this.getCharge()) + this._radicalCount;
	  }

	  var defVal = this.findSuitableValence(valence);
	  //find default valency for our case
	  return Math.max(0, defVal - valence);
	};

	Atom.prototype.getHydrogenCountNonMetal = function () {
	  // apply from Reaxys Drawing Guidelines (Version 2.04
	  // January 2012) Standard Valence – (Valence + Charge + Number of Radical(s))
	  var valence = this._valence;
	  if (valence === -1) {
	    valence = this.getAtomBondsCount() - this.getCharge() + this._radicalCount;
	  }
	  var defVal = this.findSuitableValence(valence);

	  //find default valency for our case
	  return Math.max(0, defVal - valence);
	};

	Atom.prototype.getHydrogenCountHydrogen = function () {
	  if (this.getAtomBondsCount() === 0 && this.getCharge() === 0 && this.getValence() === 0 && this._radicalCount === 0) {
	    return 1;
	  }
	  //do add in any other case
	  return 0;
	};

	Atom.prototype.getHydrogenCount = function () {
	  if (this._hydrogenCount >= 0) {
	    return this._hydrogenCount;
	  }

	  var element = this.element;
	  var val = element.hydrogenValency;
	  if (val.length === 1 && val[0] === 0) {
	    return 0;
	  }

	  switch (element.number) {
	    case 1:
	      return this.getHydrogenCountHydrogen();
	    case 3:
	    case 11:
	    case 19:
	    case 37:
	    case 55:
	    case 87: //group 1
	    case 4:
	    case 12:
	    case 20:
	    case 38:
	    case 56:
	    case 88: //group 2
	    case 13:
	    case 31:
	    case 49:
	    case 41: //group 13 but Boron
	    case 82:
	    case 83:
	      //Bi and Pb
	      return this.getHydrogenCountMetal();
	    case 6:
	    case 14:
	    case 32:
	    case 51:
	      //C, Si, Ge, Sb
	      return this.getHydrogenCountGroup14();
	    case 50:
	      //Sn
	      return this.getHydrogenCountTin();
	    case 7:
	    case 8:
	    case 9:
	    case 15:
	    case 16:
	    case 17: //N, O, F, P, S, Cl
	    case 33:
	    case 34:
	    case 35:
	    case 53:
	    case 85:
	      //As, Se, Br, I, At
	      return this.getHydrogenCountNonMetal();
	    case 5:
	      return this.getHydrogenCountBoron();
	    default:
	      return 0;
	  }
	};

	function getCylinderCount(bondOrder) {
	  return bondOrder < 2 ? 1 : bondOrder;
	}

	Atom.prototype.getAtomBondsCount = function () {
	  var explicitBonds = this.getBonds();
	  var ebCount = 0;
	  for (var i = 0; i < explicitBonds.length; i++) {
	    ebCount += getCylinderCount(explicitBonds[i].getOrder());
	  }
	  return ebCount;
	};

	Atom.prototype.findSuitableValence = function (valence) {
	  var val = this.element.hydrogenValency;
	  var defVal = val[val.length - 1];
	  for (var i = 0; i < val.length; i++) {
	    if (val[i] >= valence) {
	      defVal = val[i];
	      break;
	    }
	  }
	  return defVal;
	};

	Atom.prototype.getCharge = function () {
	  return this._charge;
	};

	Atom.prototype.getLocation = function () {
	  return this._location;
	};

	Atom.prototype.getFullName = function () {
	  var name = '';
	  if (this._residue !== null) {
	    if (this._residue._chain !== null) {
	      name += this._residue._chain.getName() + '.';
	    }

	    name += this._residue._sequence + '.';
	  }

	  name += this._name.getString();

	  return name;
	};

	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////
	var cBondTypes = {
	  /** Was generated manually */
	  UNKNOWN: 0,
	  /** Simple covalent bond */
	  COVALENT: 1,
	  /** Aromatic bond */
	  AROMATIC: 2
	};

	function getAtomPos(atom) {
	  return atom._position;
	}

	/**
	 * Bond between atoms.
	 *
	 * @param {Atom} left     - The first atom.
	 * @param {Atom} right    - The second atom.
	 * @param {number} order - Order of current bond.
	 * @param {number} type - Bond type.
	 * @param {boolean} fixed - Indicator of a pre-specified connection (in contrast with guessed one).
	 *
	 * @exports Bond
	 * @constructor
	 */
	function Bond(left, right, order, type, fixed) {
	  this._left = left;
	  this._right = right;
	  this._fixed = fixed;
	  this._index = -1;
	  if (left > right) {
	    throw new Error('In a bond atom indices must be in increasing order');
	  }
	  this._order = order;
	  this._type = type;
	}

	Bond.BondType = cBondTypes;

	Bond.prototype.BondType = cBondTypes;

	Bond.prototype.getLeft = function () {
	  return this._left;
	};

	Bond.prototype.getRight = function () {
	  return this._right;
	};

	Bond.prototype.getOrder = function () {
	  return this._order;
	};

	Bond.prototype.calcLength = function () {
	  return this._left._position.distanceTo(this._right._position);
	};

	Bond.prototype._forEachNeighbour = function (currAtom, process) {
	  var bonds = currAtom._bonds;
	  for (var i = 0, n = bonds.length; i < n; ++i) {
	    process(bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right);
	  }
	};

	Bond.prototype.forEachLevelOne = function (process) {
	  var left = this._left;
	  var right = this._right;
	  this._forEachNeighbour(left, function (atom) {
	    if (atom === right) {
	      return;
	    }
	    process(atom);
	  });
	  this._forEachNeighbour(right, function (atom) {
	    if (atom === left) {
	      return;
	    }
	    process(atom);
	  });
	};

	Bond.prototype.forEachLevelTwo = function (process) {
	  // TODO refactor this piece of an art?
	  var left = this._left;
	  var right = this._right;
	  var self = this;
	  self._forEachNeighbour(left, function (atom) {
	    if (atom === right) {
	      return;
	    }
	    self._forEachNeighbour(atom, function (l2Atom) {
	      if (l2Atom === left) {
	        return;
	      }
	      process(l2Atom);
	    });
	  });
	  self._forEachNeighbour(right, function (atom) {
	    if (atom === left) {
	      return;
	    }
	    self._forEachNeighbour(atom, function (l2Atom) {
	      if (l2Atom === right) {
	        return;
	      }
	      process(l2Atom);
	    });
	  });
	};

	Bond.prototype._fixDir = function (refPoint, currDir, posGetter) {
	  // count atoms to the right and to the left of the current plane
	  var rightCount = 0;
	  var leftCount = 0;
	  var tmpVec = refPoint.clone();
	  function checkDir(atom) {
	    tmpVec.copy(posGetter(atom));
	    tmpVec.sub(refPoint);
	    var dotProd = currDir.dot(tmpVec);
	    if (dotProd > 0) {
	      ++rightCount;
	    } else {
	      ++leftCount;
	    }
	  }
	  function checkCarbon(atom) {
	    if (atom.element.name === 'C') {
	      checkDir(atom);
	    }
	  }
	  // count all atoms to the left and right of our plane, start from level 1 and carbons
	  var stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];

	  for (var stageId = 0; stageId < stages.length; ++stageId) {
	    stages[stageId][0].call(this, stages[stageId][1]);
	    if (leftCount > rightCount) {
	      return currDir.multiplyScalar(-1);
	    } else if (leftCount < rightCount) {
	      return currDir;
	    }
	  }
	  return currDir;
	};

	Bond.prototype.calcNormalDir = function (posGetter) {
	  var left = this._left;
	  var right = this._right;
	  var first = left;
	  var second = right;
	  posGetter = posGetter === undefined ? getAtomPos : posGetter;
	  if (left._bonds.length > right._bonds.length) {
	    first = right;
	    second = left;
	  }
	  var third = first;
	  var maxNeibs = 0;
	  var bonds = second._bonds;
	  for (var i = 0, n = bonds.length; i < n; ++i) {
	    var another = bonds[i]._left;
	    if (bonds[i]._left === second) {
	      another = bonds[i]._right;
	    }
	    if (another._bonds.length > maxNeibs && another !== first) {
	      third = another;
	      maxNeibs = another._bonds.length;
	    }
	  }
	  var secondPos = posGetter(second);
	  var firstV = posGetter(first).clone().sub(secondPos);
	  var secondV = posGetter(third).clone().sub(secondPos);
	  secondV.crossVectors(firstV, secondV);
	  if (secondV.lengthSq() < 0.0001) {
	    secondV.set(0, 1, 0);
	  }
	  firstV.normalize();
	  secondV.normalize();
	  firstV.crossVectors(secondV, firstV);
	  if (firstV.lengthSq() < 0.0001) {
	    firstV.set(0, 1, 0);
	  }
	  firstV.normalize();
	  return this._fixDir(secondPos, firstV, posGetter);
	};

	/**
	 * Residue type.
	 *
	 * Predefined acid or created with HET, HETNAM, etc.
	 *
	 * @param {string} name            - Short name, either standard (ALA, MET, etc.) or non-standard one.
	 * @param {string} fullName        - Full residue name.
	 * @param {string} letterCode      - 1-letter symbol.
	 *
	 * @exports ResidueType
	 * @constructor
	 */
	function ResidueType(name, fullName, letterCode) {
	  this._name = name;
	  this._fullName = fullName;
	  this.letterCode = letterCode;
	  this.flags = 0x0000;
	}

	ResidueType.prototype.getName = function () {
	  return this._name;
	};

	// DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
	ResidueType.StandardTypes = {
	  /* eslint-disable no-magic-numbers */
	  'ALA': new ResidueType('ALA', 'Alanine', 'A'),
	  'ARG': new ResidueType('ARG', 'Arginine', 'R'),
	  'ASN': new ResidueType('ASN', 'Asparagine', 'N'),
	  'ASP': new ResidueType('ASP', 'Aspartic Acid', 'D'),
	  'CYS': new ResidueType('CYS', 'Cysteine', 'C'),
	  'GLN': new ResidueType('GLN', 'Glutamine', 'Q'),
	  'GLU': new ResidueType('GLU', 'Glutamic Acid', 'E'),
	  'GLY': new ResidueType('GLY', 'Glycine', 'G'),
	  'HIS': new ResidueType('HIS', 'Histidine', 'H'),
	  'ILE': new ResidueType('ILE', 'Isoleucine', 'I'),
	  'LEU': new ResidueType('LEU', 'Leucine', 'L'),
	  'LYS': new ResidueType('LYS', 'Lysine', 'K'),
	  'MET': new ResidueType('MET', 'Methionine', 'M'),
	  'PHE': new ResidueType('PHE', 'Phenylalanine', 'F'),
	  'PRO': new ResidueType('PRO', 'Proline', 'P'),
	  'PYL': new ResidueType('PYL', 'Pyrrolysine', 'O'),
	  'SEC': new ResidueType('SEC', 'Selenocysteine', 'U'),
	  'SER': new ResidueType('SER', 'Serine', 'S'),
	  'THR': new ResidueType('THR', 'Threonine', 'T'),
	  'TRP': new ResidueType('TRP', 'Tryptophan', 'W'),
	  'TYR': new ResidueType('TYR', 'Tyrosine', 'Y'),
	  'VAL': new ResidueType('VAL', 'Valine', 'V'),
	  'A': new ResidueType('A', 'Adenine', 'A'),
	  'C': new ResidueType('C', 'Cytosine', 'C'),
	  'G': new ResidueType('G', 'Guanine', 'G'),
	  'I': new ResidueType('I', 'Inosine', 'I'),
	  'T': new ResidueType('T', 'Thymine', 'T'),
	  'U': new ResidueType('U', 'Uracil', 'U'),
	  'DA': new ResidueType('DA', 'Adenine', 'A'),
	  'DC': new ResidueType('DC', 'Cytosine', 'C'),
	  'DG': new ResidueType('DG', 'Guanine', 'G'),
	  'DI': new ResidueType('DI', 'Inosine', 'I'),
	  'DT': new ResidueType('DT', 'Thymine', 'T'),
	  'DU': new ResidueType('DU', 'Uracil', 'U'),
	  '+A': new ResidueType('+A', 'Adenine', 'A'),
	  '+C': new ResidueType('+C', 'Cytosine', 'C'),
	  '+G': new ResidueType('+G', 'Guanine', 'G'),
	  '+I': new ResidueType('+I', 'Inosine', 'I'),
	  '+T': new ResidueType('+T', 'Thymine', 'T'),
	  '+U': new ResidueType('+U', 'Uracil', 'U'),
	  'WAT': new ResidueType('WAT', 'Water', ''),
	  'H2O': new ResidueType('H2O', 'Water', ''),
	  'HOH': new ResidueType('HOH', 'Water', ''),
	  'DOD': new ResidueType('DOD', 'Water', ''),
	  'UNK': new ResidueType('UNK', 'Unknown', ''),
	  'UNL': new ResidueType('UNL', 'Unknown Ligand', '')
	  /* eslint-enable no-magic-numbers */
	};

	/**
	 * Enumeration of residue flag values.
	 *
	 * @enum {number}
	 * @readonly
	 */
	ResidueType.Flags = {
	  // Amino acids
	  /** Amino acid residue */
	  PROTEIN: 0x0001,
	  /** Basic amino acid residue */
	  BASIC: 0x0002,
	  /** Acidic amino acid residue */
	  ACIDIC: 0x0004,
	  /** Polar uncharged side chain amino acid residue */
	  POLAR: 0x0008,
	  /** Non-polar hydrophobic side chain amino acid residue */
	  NONPOLAR: 0x0010,
	  /** Aromatic amino acid residue */
	  AROMATIC: 0x0020,

	  // Nucleic acids

	  /** Nucleic residue */
	  NUCLEIC: 0x0100,
	  /** Purine nucleic residue */
	  PURINE: 0x0200,
	  /** Pyrimidine nucleic residue */
	  PYRIMIDINE: 0x0400,
	  /** DNA */
	  DNA: 0x0800,
	  /** RNA */
	  RNA: 0x1000,

	  /** Water */
	  WATER: 0x10000
	};

	// Flag combinations
	function _addFlag(flag, list) {
	  for (var i = 0, n = list.length; i < n; ++i) {
	    var res = ResidueType.StandardTypes[list[i]];
	    if (res) {
	      res.flags |= flag;
	    }
	  }
	}

	var Flags = ResidueType.Flags;
	_addFlag(Flags.WATER, ['WAT', 'H2O', 'HOH', 'DOD']);

	_addFlag(Flags.PROTEIN, ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLY', 'GLU', 'GLN', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'PYL', 'SEC', 'SER', 'THR', 'TRP', 'TYR', 'VAL']);
	_addFlag(Flags.BASIC, ['ARG', 'HIS', 'LYS']);
	_addFlag(Flags.ACIDIC, ['ASP', 'GLU']);
	_addFlag(Flags.POLAR, ['ASN', 'CYS', 'GLN', 'SER', 'THR', 'TYR']);
	_addFlag(Flags.NONPOLAR, ['ALA', 'ILE', 'LEU', 'MET', 'PHE', 'PRO', 'TRP', 'VAL', 'GLY']);
	_addFlag(Flags.AROMATIC, ['PHE', 'TRP', 'TYR']);

	_addFlag(Flags.NUCLEIC, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I', 'C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);
	_addFlag(Flags.PURINE, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I']);
	_addFlag(Flags.PYRIMIDINE, ['C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);
	_addFlag(Flags.DNA, ['DA', 'DG', 'DI', 'DC', 'DT', 'DU']);
	_addFlag(Flags.RNA, ['A', 'G', 'I', 'C', 'T', 'U']);
	// Table of kdHydrophobicity
	var hydro = {
	  'ILE': 4.5,
	  'VAL': 4.2,
	  'LEU': 3.8,
	  'PHE': 2.8,
	  'CYS': 2.5,
	  'MET': 1.9,
	  'ALA': 1.8,
	  'GLY': -0.4,
	  'THR': -0.7,
	  'SER': -0.8,
	  'TRP': -0.9,
	  'TYR': -1.3,
	  'PRO': -1.6,
	  'HIS': -3.2,
	  'GLU': -3.5,
	  'GLN': -3.5,
	  'ASP': -3.5,
	  'ASN': -3.5,
	  'LYS': -3.9,
	  'ARG': -4.5
	};

	function _addParam(param, list) {
	  var keys = Object.keys(list);
	  for (var i = 0, n = keys.length; i < n; ++i) {
	    var key = keys[i];
	    var value = list[key];
	    ResidueType.StandardTypes[key][param] = value;
	  }
	}

	_addParam('hydrophobicity', hydro);

	//////////////////////////////////////////////////////////////////////////////

	var cNucleicControlNames = ['C3\'', 'C3*', 'P', 'H5T', 'H3T'];
	var cNucleicWing1Names = ['OP1', 'O1P'];
	var cNucleicWing2Names = ['OP2', 'O2P'];

	var cCylinderSource = ['C3\'', 'C3*', 'C1', 'C1\'', 'C1*', 'P'];
	var cCylinderTarget = [{
	  types: ['A', 'DA', 'G', 'DG'],
	  atoms: ['N1']
	}, {
	  types: ['C', 'DC'],
	  atoms: ['N3']
	}, {
	  types: ['T', 'DT', 'U', 'DU'],
	  atoms: ['O4']
	}];

	/**
	 * Residue instance.
	 *
	 * @param {Chain} chain      - Chain this residue belongs to.
	 * @param {ResidueType} type - Generic residue instance type.
	 * @param {number} sequence  - Sequence ID.
	 * @param {string} icode     - One character insertion code (usually space or A-Z).
	 *
	 * @exports Residue
	 * @constructor
	 */
	function Residue(chain, type, sequence, icode) {
	  this._chain = chain;
	  this._component = null;
	  this._type = type;
	  this._sequence = sequence;
	  this._icode = icode;
	  this._mask = 1 | 0;
	  this._index = -1;

	  this._atoms = []; // TODO: change to range
	  this._secondary = null;
	  this._firstAtom = null;
	  this._leadAtom = null;
	  this._wingAtom = null;
	  this._lastAtom = null;
	  this._controlPoint = null;
	  this._midPoint = null;
	  this._wingVector = null;
	  this._cylinders = null;
	  this._isValid = true;
	  this._het = false;
	  this._molecule = null;
	  this.temperature = null;
	  this.occupancy = null;
	}

	// Getters and setters
	Residue.prototype.getChain = function () {
	  return this._chain;
	};

	Residue.prototype.getMolecule = function () {
	  return this._molecule;
	};

	Residue.prototype.getType = function () {
	  return this._type;
	};

	Residue.prototype.getSequence = function () {
	  return this._sequence;
	};

	Residue.prototype.getSecondary = function () {
	  return this._secondary;
	};

	Residue.prototype.getICode = function () {
	  return this._icode;
	};

	// Other methods

	Residue.prototype.addAtom = function (name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
	  var atom = new Atom(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
	  var complex = this._chain.getComplex();
	  complex.addAtom(atom);
	  this._atoms.push(atom); // TODO: change to range
	  this._het = this._het || het;
	  return atom;
	};

	Residue.prototype.getAtomCount = function () {
	  return this._atoms.length;
	};

	Residue.prototype.forEachAtom = function (process) {
	  var atoms = this._atoms;
	  for (var i = 0, n = atoms.length; i < n; ++i) {
	    if (process(atoms[i])) {
	      break;
	    }
	  }
	};

	Residue.prototype._findAtomByName = function (name) {
	  var res = null;
	  this.forEachAtom(function (atom) {
	    if (atom._name._name === name) {
	      res = atom;
	      return true;
	    }
	    return false;
	  });
	  return res;
	};

	Residue.prototype._findFirstAtomInList = function (names) {
	  var res = null;
	  for (var i = 0; i < names.length; ++i) {
	    res = this._findAtomByName(names[i]);
	    if (res !== null) {
	      return res;
	    }
	  }
	  return res;
	};

	Residue.prototype.collectMask = function () {
	  var mask = 0xffffffff;
	  var atoms = this._atoms;
	  for (var i = 0, n = atoms.length; i < n; ++i) {
	    mask &= atoms[i]._mask;
	  }
	  this._mask = mask;
	};

	Residue.prototype.getCylinderTargetList = function () {
	  var type = this._type._name;
	  for (var i = 0, n = cCylinderTarget.length; i < n; ++i) {
	    for (var j = 0, m = cCylinderTarget[i].types.length; j < m; ++j) {
	      if (type === cCylinderTarget[i].types[j]) {
	        return cCylinderTarget[i].atoms;
	      }
	    }
	  }
	  return null;
	};

	Residue.prototype._detectLeadWing = function (dst, next, getAtomPosition) {
	  var leadAtom = this._findFirstAtomInList(cNucleicControlNames);
	  var wingStart = this._findFirstAtomInList(cNucleicWing1Names);
	  var wingEnd = this._findFirstAtomInList(cNucleicWing2Names);

	  if (wingStart === null && next !== null) {
	    wingStart = next._findFirstAtomInList(cNucleicWing1Names);
	  }

	  if (wingEnd === null && next !== null) {
	    wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
	  }

	  if (leadAtom === null || wingStart === null || wingEnd === null) {
	    return;
	  }

	  dst._leadAtom = leadAtom;
	  dst._controlPoint = getAtomPosition(leadAtom);
	  dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
	  dst._isValid = true;

	  var cylSource = this._findFirstAtomInList(cCylinderSource);
	  var targetList = this.getCylinderTargetList();
	  var cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;
	  if (cylSource === null || cylTarget === null) {
	    return;
	  }
	  dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
	};

	Residue.prototype.calcWing = function (prevLeadPos, currLeadPos, prevWingPos, prevWing) {
	  var vectorA = currLeadPos.clone().sub(prevLeadPos);
	  var vectorB = prevLeadPos.clone().sub(prevWingPos);
	  vectorB.crossVectors(vectorA, vectorB);
	  vectorB.crossVectors(vectorA, vectorB).normalize();
	  if (prevWing !== null && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2) {
	    vectorB.negate();
	  }
	  return vectorB;
	};

	Residue.prototype._innerFinalize = function (prevRes, prev, nextRes, dst, getAtomPosition) {
	  var bFirstInChain = prev === null;

	  var lp = getAtomPosition(this._leadAtom);
	  var currLeadPos = new Vector3(lp.x, lp.y, lp.z);
	  if ((this._type.flags & ResidueType.Flags.NUCLEIC) !== 0) {
	    this._detectLeadWing(dst, nextRes, getAtomPosition);
	    return;
	  }
	  if (bFirstInChain) {
	    //for first one in chain
	    dst._midPoint = getAtomPosition(this._firstAtom).clone();
	  } else {
	    var prevLeadPos = prev._controlPoint; //lead point of previous monomer
	    dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
	    dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
	  }
	  dst._controlPoint = currLeadPos;
	};

	Residue.prototype._finalize2 = function (prev, next) {
	  //Should be called AFTER first finalize
	  this._innerFinalize(prev, prev, next, this, function (atom) {
	    return atom._position;
	  });
	};

	Residue.prototype.isConnected = function (anotherResidue) {
	  if (this._chain !== anotherResidue._chain) {
	    return false;
	  }
	  if (this === anotherResidue) {
	    return true;
	  }
	  var res = false;
	  this.forEachAtom(function (atom) {
	    var bonds = atom._bonds;
	    for (var i = 0, n = bonds.length; i < n; ++i) {
	      var bond = bonds[i];
	      if (bond._left._residue === anotherResidue || bond._right._residue === anotherResidue) {
	        res = true;
	        return true;
	      }
	    }
	    return false;
	  });
	  return res;
	};

	Residue.prototype._finalize = function () {
	  var self = this;
	  this._firstAtom = this._atoms[0];
	  this._lastAtom = this._atoms[this._atoms.length - 1];

	  this._leadAtom = null;
	  this._wingAtom = null;

	  var tempCount = 0;
	  var temperature = 0; // average temperature
	  var occupCount = 0;
	  var occupancy = 0; // average occupancy
	  // TODO: Is it correct? Is it fast?
	  this.forEachAtom(function (a) {
	    if (self._leadAtom === null) {
	      if (a._role === Element.Constants.Lead) {
	        self._leadAtom = a;
	      }
	    }
	    if (self._wingAtom === null) {
	      if (a._role === Element.Constants.Wing) {
	        self._wingAtom = a;
	      }
	    }
	    if (a._temperature) {
	      temperature += a._temperature;
	      tempCount++;
	    }
	    if (a._occupancy) {
	      occupancy += a._occupancy;
	      occupCount++;
	    }
	    return self._leadAtom !== null && self._wingAtom !== null;
	  });

	  if (tempCount > 0) {
	    this.temperature = temperature / tempCount;
	  }
	  if (occupCount > 0) {
	    this.occupancy = occupancy / occupCount;
	  }

	  //Still try to make monomer look valid
	  if (this._leadAtom === null || this._wingAtom === null) {
	    this._isValid = false;
	  }
	  if (this._leadAtom === null) {
	    this._leadAtom = this._firstAtom;
	  }
	  if (this._wingAtom === null) {
	    this._wingAtom = this._lastAtom;
	  }
	};

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Residue chain.
	 *
	 * @param {Complex} complex - Molecular complex this chain belongs to.
	 * @param {string} name - One character identifier (usually space, A-Z, 0-9, or a-z).
	 *
	 * @exports Chain
	 * @constructor
	 */
	function Chain(complex, name) {
	  this._complex = complex;
	  this._name = name;
	  this._mask = 1 | 0;
	  this._index = -1;

	  this._residues = []; // TODO: change to range

	  this.minSequence = Number.POSITIVE_INFINITY;
	  this.maxSequence = Number.NEGATIVE_INFINITY;
	}

	Chain.prototype.getComplex = function () {
	  return this._complex;
	};

	Chain.prototype.getName = function () {
	  return this._name;
	};

	Chain.prototype.getResidues = function () {
	  return this._residues;
	};

	/**
	 * Finds thre residue with specified sequence number and inserion code
	 * @param {Number} seqNum sequence number
	 * @param {string} iCode insertion code
	 * @returns {*} Residue or null if not found
	 */
	Chain.prototype.findResidue = function (seqNum, iCode) {
	  var residues = this._residues;

	  for (var i = 0, n = residues.length; i < n; ++i) {
	    var res = residues[i];
	    if (res._sequence === seqNum && res._icode === iCode) {
	      return [res, i];
	    }
	  }

	  return null;
	};

	Chain.prototype._finalize = function () {
	  var residues = this._residues;

	  var prev = null;
	  for (var i = 0, n = residues.length; i < n; ++i) {
	    var next = i + 1 < n ? residues[i + 1] : null;
	    var curr = residues[i];
	    // TODO: skip invalid residues
	    {
	        // eslint-disable-line no-constant-condition
	        curr._finalize2(prev, next);
	        prev = curr;
	      }
	  }

	  //fix very first wing
	  if (residues.length > 1) {
	    var p = residues[1]._wingVector;
	    residues[0]._wingVector = new Vector3(p.x, p.y, p.z);
	  } else if (residues.length > 0) {
	    residues[0]._wingVector = new Vector3(1, 0, 0);
	  }
	};

	Chain.prototype.updateToFrame = function (frameData) {
	  var residues = this._residues;
	  var prev = null;
	  var prevData = null;
	  var frameRes = frameData._residues;
	  var n = residues.length;
	  function getAtomPos(atom) {
	    return frameData.getAtomPos(atom._index);
	  }

	  for (var i = 0; i < n; ++i) {
	    var curr = residues[i];
	    var currData = frameRes[curr._index];
	    var nextRes = i + 1 < n ? residues[i + 1] : null;
	    curr._innerFinalize(prev, prevData, nextRes, currData, getAtomPos);
	    prev = curr;
	    prevData = currData;
	  }

	  frameRes[residues[0]._index]._wingVector = n > 1 ? frameRes[residues[1]._index]._wingVector : new Vector3(1, 0, 0);
	};
	/**
	 * Create a new residue.
	 *
	 * @param {string} name - Residue name.
	 * @param {number} sequence - Residue sequence number.
	 * @param {string} iCode - Insertion code.
	 * @returns {Residue} - Newly created residue instance.
	 */
	Chain.prototype.addResidue = function (name, sequence, iCode) {
	  var type = this._complex.getResidueType(name);
	  if (type === null) {
	    type = this._complex.addResidueType(name);
	  }
	  var residue = new Residue(this, type, sequence, iCode);
	  this._complex.addResidue(residue);
	  this._residues.push(residue); // TODO: change to range

	  if (type.flags & (ResidueType.Flags.NUCLEIC | ResidueType.Flags.PROTEIN)) {
	    if (this.maxSequence < sequence) {
	      this.maxSequence = sequence;
	    }
	    if (this.minSequence > sequence) {
	      this.minSequence = sequence;
	    }
	  }

	  return residue;
	};

	Chain.prototype.getResidueCount = function () {
	  return this._residues.length;
	};

	Chain.prototype.forEachResidue = function (process) {
	  var residues = this._residues;
	  for (var i = 0, n = residues.length; i < n; ++i) {
	    process(residues[i]);
	  }
	};

	Chain.prototype.collectMask = function () {
	  var mask = 0xffffffff;
	  var residues = this._residues;
	  for (var i = 0, n = residues.length; i < n; ++i) {
	    mask &= residues[i]._mask;
	  }
	  this._mask = mask;
	};

	var _StructuralElement$ge;

	/** An element of protein secondary structure. */

	var StructuralElement = function () {
	  /**
	   * Create a secondary structural element of the specified type.
	   *
	   * @param {StructuralElement.Type} type Secondary structure type.
	   * @param {Residue} init Initial residue.
	   * @param {Residue} term Terminal residue.
	   */
	  function StructuralElement(type, init, term) {
	    classCallCheck(this, StructuralElement);

	    /**
	     * Secondary structure type.
	     * @type {StructuralElement.Type}
	     */
	    this.type = type;
	    /**
	     * Generic secondary structure type.
	     * @type {StructuralElement.Generic}
	     */
	    this.generic = StructuralElement.genericByType[this.type] || 'loop';
	    /**
	     * Initial residue.
	     * @type Residue
	     */
	    this.init = init;
	    /**
	     * Terminal residue.
	     * @type Residue
	     */
	    this.term = term;
	  }

	  /**
	   * An internal method for making a final pass over the complex to set all required references.
	   *
	   * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
	   * Just copying it as-is right now and hoping for the best.
	   *
	   * @param {object} serialAtomMap A dictionary of atoms
	   * @param {object} residueHash A dictionary of hashed residues to check.
	   * @param {Complex} complex The molecular complex this element belongs to.
	   */


	  createClass(StructuralElement, [{
	    key: '_finalize',
	    value: function _finalize(serialAtomMap, residueHash, complex) {
	      if (this.init instanceof Residue && this.term instanceof Residue) {
	        return;
	      }

	      // Link all intermediate residues to this structural element
	      var start = complex.splitUnifiedSerial(this.init);
	      var end = complex.splitUnifiedSerial(this.term);
	      for (var chainId = start.chain; chainId <= end.chain; chainId++) {
	        for (var serialId = start.serial; serialId <= end.serial; serialId++) {
	          for (var iCode = start.iCode; iCode <= end.iCode; iCode++) {
	            var hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);
	            if (residueHash[hashCode]) {
	              residueHash[hashCode]._secondary = this;
	            }
	          }
	        }
	      }

	      // Replace unfined serials by objects
	      this.init = residueHash[this.init];
	      this.term = residueHash[this.term];
	    }
	  }]);
	  return StructuralElement;
	}();

	/**
	 * Specific type of a secondary structural element.
	 * @enum {string}
	 * @see StructuralElement.Generic
	 */


	StructuralElement.Type = {
	  /** A strand of a [beta-sheet](https://en.wikipedia.org/wiki/Beta_sheet). */
	  STRAND: 'E',
	  /** An isolated beta-bridge (too small for a beta-sheet). */
	  BRIDGE: 'B',

	  /** A [3/10 helix](https://en.wikipedia.org/wiki/310_helix) (hydrogen bonding is 3 residues apart). */
	  HELIX_310: 'G',
	  /** An [alpha-helix](https://en.wikipedia.org/wiki/Alpha_helix) (hydrogen bonding is 4 residues apart). */
	  HELIX_ALPHA: 'H',
	  /** A [pi-helix](https://en.wikipedia.org/wiki/Pi_helix) (hydrogen bonding is 5 residues apart). */
	  HELIX_PI: 'I',
	  /** A generic helix of unspecified bonding distance. */
	  HELIX: 'X',

	  /** An isolated 3/10-like helical turn. */
	  TURN_310: '3',
	  /** An isolated alpha-like helical turn. */
	  TURN_ALPHA: '4',
	  /** An isolated pi-like helical turn. */
	  TURN_PI: '5',
	  /** An isolated helical [turn](https://en.wikipedia.org/wiki/Turn_(biochemistry)) of unspecified bonding distance. */
	  TURN: 'T',

	  /** A bend (a region of high curvature). */
	  BEND: 'S',
	  /** Just a protein section with no particular conformation. */
	  COIL: 'C'
	};

	/**
	 * Generic type of a secondary structural element.
	 * @enum {string}
	 * @see StructuralElement.Type
	 */
	StructuralElement.Generic = {
	  /** A strand of a sheet. */
	  STRAND: 'strand',
	  /** A helix. */
	  HELIX: 'helix',
	  /** Just a protein section with no particular conformation. */
	  LOOP: 'loop'
	};

	var StructuralElementType = StructuralElement.Type;
	var StructuralElementGeneric = StructuralElement.Generic;

	/**
	 * A mapping from specific types to generic ones.
	 * @type {Object<StructuralElement.Type, StructuralElement.Generic>}
	 */
	StructuralElement.genericByType = (_StructuralElement$ge = {}, defineProperty(_StructuralElement$ge, StructuralElementType.STRAND, StructuralElementGeneric.STRAND), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_310, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_ALPHA, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX_PI, StructuralElementGeneric.HELIX), defineProperty(_StructuralElement$ge, StructuralElementType.HELIX, StructuralElementGeneric.HELIX), _StructuralElement$ge);

	var StructuralElementType$1 = StructuralElement.Type;

	var typeByPDBHelixClass = {
	  1: StructuralElementType$1.HELIX_ALPHA,
	  3: StructuralElementType$1.HELIX_PI,
	  5: StructuralElementType$1.HELIX_310
	};

	/**
	 * Helical secondary structure of a protein.
	 * @extends StructuralElement
	 */

	var Helix = function (_StructuralElement) {
	  inherits(Helix, _StructuralElement);

	  /**
	   * Create a helix.
	   *
	   * @param {number} helixClass A helix class according to the
	   *   [PDB Format](http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX).
	   * @param {Residue} init Initial residue.
	   * @param {Residue} term Terminal residue.
	   * @param {number} serial Serial number of the helix (see PDB Format).
	   * @param {string} name Helix identifier (see PDB Format).
	   * @param {string} comment Comment about this helix (see PDB Format).
	   * @param {number} length Length of this helix, in residues (see PDB Format).
	   */
	  function Helix(helixClass, init, term, serial, name, comment, length) {
	    classCallCheck(this, Helix);

	    /**
	     * Serial number of the helix (see PDB Format).
	     * @type {number}
	     */
	    var _this = possibleConstructorReturn(this, (Helix.__proto__ || Object.getPrototypeOf(Helix)).call(this, typeByPDBHelixClass[helixClass] || StructuralElement.Type.HELIX, init, term));

	    _this.serial = serial;
	    /**
	     * Helix identifier (see PDB Format).
	     * @type {string}
	     */
	    _this.name = name;
	    /**
	     * Comment about this helix (see PDB Format).
	     * @type {string}
	     */
	    _this.comment = comment;
	    /**
	     * Length of this helix, in residues (see PDB Format).
	     * @type {number}
	     */
	    _this.length = length;
	    return _this;
	  }

	  return Helix;
	}(StructuralElement);

	/**
	 * A single strand of a sheet in a protein secondary structure.
	 * @extends StructuralElement
	 */

	var Strand = function (_StructuralElement) {
	  inherits(Strand, _StructuralElement);

	  /**
	   * Create a strand.
	   *
	   * @param {Sheet} sheet Parent sheet this strand belongs to.
	   * @param {Residue} init Initial residue.
	   * @param {Residue} term Terminal residue.
	   * @param {number} sense Sense of strand with respect to previous strand in the sheet.
	   *   - 0 if the first strand,
	   *   - 1 if parallel, and
	   *   - -1 if anti-parallel.
	   * @param {Atom} atomCur Atom in current strand (see PDB Format).
	   * @param {Atom} atomPrev Atom in previous strand (see PDB Format).
	   */
	  function Strand(sheet, init, term, sense, atomCur, atomPrev) {
	    classCallCheck(this, Strand);

	    /**
	     * Parent sheet this strand belongs to.
	     * @type {Sheet}
	     */
	    var _this = possibleConstructorReturn(this, (Strand.__proto__ || Object.getPrototypeOf(Strand)).call(this, StructuralElement.Type.STRAND, init, term));

	    _this.sheet = sheet;
	    /**
	     * Sense of strand with respect to previous strand in the sheet.
	     * - 0 if the first strand,
	     * - 1 if parallel, and
	     * - -1 if anti-parallel.
	     * @type {number}
	     */
	    _this.sense = sense;
	    /**
	     * Atom in current strand (see PDB Format).
	     * @type {Atom}
	     */
	    _this.atomCur = atomCur;
	    /**
	     * Atom in previous strand (see PDB Format).
	     * @type {Atom}
	     */
	    _this.atomPrev = atomPrev;
	    return _this;
	  }

	  /**
	   * An internal method for making a final pass over the complex to set all required references.
	   *
	   * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
	   * Just copying it as-is right now and hoping for the best.
	   *
	   * @param {object} serialAtomMap A dictionary of atoms
	   * @param {object} residueHash A dictionary of hashed residues to check.
	   * @param {Complex} complex The molecular complex this element belongs to.
	   *
	   * @override
	   */


	  createClass(Strand, [{
	    key: '_finalize',
	    value: function _finalize(serialAtomMap, residueHash, complex) {
	      get(Strand.prototype.__proto__ || Object.getPrototypeOf(Strand.prototype), '_finalize', this).call(this, serialAtomMap, residueHash, complex);

	      var as = this.atomCur;
	      if (as !== null && !Number.isNaN(as)) {
	        this.atomCur = serialAtomMap[as];
	      }
	      as = this.atomPrev;
	      if (as !== null && !Number.isNaN(as)) {
	        this.atomPrev = serialAtomMap[as];
	      }
	    }
	  }]);
	  return Strand;
	}(StructuralElement);

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Sheet secondary structure of a protein.
	 *
	 * @param {string} name -
	 * @param {number} width -
	 *
	 * @exports Sheet
	 * @constructor
	 */
	function Sheet(name, width) {
	  this._name = name;
	  this._width = width;

	  this._strands = [];
	}

	// Getters and setters
	Sheet.prototype.getName = function () {
	  return this._name;
	};

	Sheet.prototype.getWidth = function () {
	  return this._width;
	};

	Sheet.prototype.addStrand = function (strand) {
	  this._strands.push(strand);
	  this._width = this._strands.length;
	};

	Sheet.prototype.addEmptyStrand = function () {
	  this._strands.push(new Strand(null, null, null, null, null, null));
	};

	Sheet.prototype._finalize = function (serialAtomMap, residueHash, complex) {
	  var s = this._strands;
	  for (var i = 0, n = s.length; i < n; ++i) {
	    s[i]._finalize(serialAtomMap, residueHash, complex);
	  }
	  if (!this._width) {
	    this._width = s.length;
	  }
	  if (s.length !== this._width) {
	    throw new Error('Sheet ' + this._name + ' is inconsistent.');
	  }
	};

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Atom measurements.
	 *
	 * @param {string} id              - SGroup id
	 * @param {AtomName} name          - Name of the group
	 * @param {THREE.Vector3} position - Registered coordinates
	 * @param {array} atoms            - Atoms group consists of
	 * @param {object} saveNode        - XML node from file for saving
	 *
	 * @exports SGroup
	 * @constructor
	 */
	function SGroup(id, name, position, atoms, saveNode) {
	  this._id = id;
	  this._name = name;
	  this._position = position || new Vector3();
	  this._atoms = atoms || [];
	  this._charge = 0; //default group charge
	  this._repeat = 1; //how many times group repeated: always > 0
	  this._center = null;
	  this.xmlNodeRef = saveNode || null;
	}

	/**
	 * Get atom full name.
	 * @returns {AtomName} Atom full name.
	 */
	SGroup.prototype.getName = function () {
	  return this._name;
	};

	SGroup.prototype.getPosition = function () {
	  return this._position;
	};

	SGroup.prototype.getCentralPoint = function () {
	  return this._center;
	};

	SGroup.prototype._rebuildSGroupOnAtomChange = function () {
	  var nLimon = 100000000;
	  if (this._center === null) {
	    return; //nothing to do if we are not relative
	  }

	  var bLow = new Vector3(nLimon, nLimon, nLimon);
	  var bHight = new Vector3(-nLimon, -nLimon, -nLimon);
	  for (var j = 0, n = this._atoms.length; j < n; j++) {
	    var aPos = this._atoms[j].getPosition();
	    bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
	    bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
	  }
	  this._center.addVectors(bLow, bHight);
	  this._center.multiplyScalar(0.5);
	};

	SGroup.prototype.buildChemicalFormula = function (complex, part) {
	  var calcCharge = 0;
	  var atomsCount = 0;
	  var formula = complex._buildFormulaSimple(part, function (l, c) {
	    atomsCount = l;
	    calcCharge = c;
	  });
	  var finalCharge = this._charge + calcCharge;
	  if (finalCharge !== 0) {
	    if (this._repeat > 1) {
	      if (atomsCount > 1) {
	        formula = this._repeat.toString() + '(' + formula + ')';
	      } else {
	        formula = this._repeat.toString() + formula;
	      }
	    } else if (atomsCount > 1) {
	      formula = '(' + formula + ')';
	    }

	    if (finalCharge > 1) {
	      formula += '^' + finalCharge.toString() + '+';
	    }
	    if (finalCharge === 1) {
	      formula += '^+';
	    }
	    if (finalCharge < -1) {
	      formula += '^' + Math.abs(finalCharge).toString() + '-';
	    }
	    if (finalCharge === -1) {
	      formula += '^-';
	    }
	  } else if (this._repeat > 1) {
	    formula = this._repeat.toString() + formula;
	  }
	  return formula;
	};

	/* eslint-disable */
	// DO NOT EDIT! Automatically generated from .jison
	/* parser generated by jison 0.4.18 */
	/*
	  Returns a Parser object of the following structure:

	  Parser: {
	    yy: {}
	  }

	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),

	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),

	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },

	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }


	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }


	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var parser = function () {
	    var o = function o(k, v, _o, l) {
	        for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}return _o;
	    },
	        $V0 = [1, 4],
	        $V1 = [1, 5],
	        $V2 = [1, 6],
	        $V3 = [1, 7],
	        $V4 = [1, 8],
	        $V5 = [1, 9],
	        $V6 = [1, 11],
	        $V7 = [1, 12],
	        $V8 = [5, 7, 8, 11],
	        $V9 = [1, 17],
	        $Va = [1, 22],
	        $Vb = [1, 20],
	        $Vc = [1, 21],
	        $Vd = [5, 7, 8, 11, 19];
	    var parser = { trace: function trace() {},
	        yy: {},
	        symbols_: { "error": 2, "Program": 3, "Expression": 4, "EOF": 5, "Selector": 6, "OR": 7, "AND": 8, "NOT": 9, "(": 10, ")": 11, "SELECTOR": 12, "NAMED_SELECTOR": 13, "SELECTOR_RANGED": 14, "RangeList": 15, "SELECTOR_NAMED": 16, "NameList": 17, "Range": 18, ",": 19, "NUMBER": 20, ":": 21, "Name": 22, "IDENTIFIER": 23, "STRING": 24, "$accept": 0, "$end": 1 },
	        terminals_: { 2: "error", 5: "EOF", 7: "OR", 8: "AND", 9: "NOT", 10: "(", 11: ")", 12: "SELECTOR", 13: "NAMED_SELECTOR", 14: "SELECTOR_RANGED", 16: "SELECTOR_NAMED", 19: ",", 20: "NUMBER", 21: ":", 23: "IDENTIFIER", 24: "STRING" },
	        productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
	        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	            /* this == yyval */

	            var $0 = $$.length - 1;
	            switch (yystate) {
	                case 1:
	                    return $$[$0 - 1];
	                    break;
	                case 3:
	                    this.$ = yy.keyword('or')($$[$0 - 2], $$[$0]);
	                    break;
	                case 4:
	                    this.$ = yy.keyword('and')($$[$0 - 2], $$[$0]);
	                    break;
	                case 5:
	                    this.$ = yy.keyword('not')($$[$0]);
	                    break;
	                case 6:
	                    this.$ = $$[$0 - 1];
	                    break;
	                case 7:
	                    this.$ = yy.keyword($$[$0])();
	                    break;
	                case 8:
	                    this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
	                    break;
	                case 9:case 10:
	                    this.$ = yy.keyword($$[$0 - 1])($$[$0]);
	                    break;
	                case 11:
	                    this.$ = new yy.RangeList($$[$0]);
	                    break;
	                case 12:case 16:
	                    this.$ = $$[$0 - 2].append($$[$0]);
	                    break;
	                case 13:
	                    this.$ = new yy.Range(Number($$[$0]));
	                    break;
	                case 14:
	                    this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
	                    break;
	                case 15:
	                    this.$ = new yy.ValueList($$[$0]);
	                    break;
	            }
	        },
	        table: [{ 3: 1, 4: 2, 6: 3, 9: $V0, 10: $V1, 12: $V2, 13: $V3, 14: $V4, 16: $V5 }, { 1: [3] }, { 5: [1, 10], 7: $V6, 8: $V7 }, o($V8, [2, 2]), { 4: 13, 6: 3, 9: $V0, 10: $V1, 12: $V2, 13: $V3, 14: $V4, 16: $V5 }, { 4: 14, 6: 3, 9: $V0, 10: $V1, 12: $V2, 13: $V3, 14: $V4, 16: $V5 }, o($V8, [2, 7]), o($V8, [2, 8]), { 15: 15, 18: 16, 20: $V9 }, { 17: 18, 20: $Va, 22: 19, 23: $Vb, 24: $Vc }, { 1: [2, 1] }, { 4: 23, 6: 3, 9: $V0, 10: $V1, 12: $V2, 13: $V3, 14: $V4, 16: $V5 }, { 4: 24, 6: 3, 9: $V0, 10: $V1, 12: $V2, 13: $V3, 14: $V4, 16: $V5 }, o($V8, [2, 5]), { 7: $V6, 8: $V7, 11: [1, 25] }, o($V8, [2, 9], { 19: [1, 26] }), o($Vd, [2, 11]), o($Vd, [2, 13], { 21: [1, 27] }), o($V8, [2, 10], { 19: [1, 28] }), o($Vd, [2, 15]), o($Vd, [2, 17]), o($Vd, [2, 18]), o($Vd, [2, 19]), o([5, 7, 11], [2, 3], { 8: $V7 }), o($V8, [2, 4]), o($V8, [2, 6]), { 18: 29, 20: $V9 }, { 20: [1, 30] }, { 20: $Va, 22: 31, 23: $Vb, 24: $Vc }, o($Vd, [2, 12]), o($Vd, [2, 14]), o($Vd, [2, 16])],
	        defaultActions: { 10: [2, 1] },
	        parseError: function parseError(str, hash) {
	            if (hash.recoverable) {
	                this.trace(str);
	            } else {
	                var error = new Error(str);
	                error.hash = hash;
	                throw error;
	            }
	        },
	        parse: function parse(input) {
	            var self = this,
	                stack = [0],
	                tstack = [],
	                vstack = [null],
	                lstack = [],
	                table = this.table,
	                yytext = '',
	                yylineno = 0,
	                yyleng = 0,
	                TERROR = 2,
	                EOF = 1;
	            var args = lstack.slice.call(arguments, 1);
	            var lexer = Object.create(this.lexer);
	            var sharedState = { yy: {} };
	            for (var k in this.yy) {
	                if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
	                    sharedState.yy[k] = this.yy[k];
	                }
	            }
	            lexer.setInput(input, sharedState.yy);
	            sharedState.yy.lexer = lexer;
	            sharedState.yy.parser = this;
	            if (typeof lexer.yylloc == 'undefined') {
	                lexer.yylloc = {};
	            }
	            var yyloc = lexer.yylloc;
	            lstack.push(yyloc);
	            var ranges = lexer.options && lexer.options.ranges;
	            if (typeof sharedState.yy.parseError === 'function') {
	                this.parseError = sharedState.yy.parseError;
	            } else {
	                this.parseError = Object.getPrototypeOf(this).parseError;
	            }
	            function lex() {
	                var token;
	                token = tstack.pop() || lexer.lex() || EOF;
	                if (typeof token !== 'number') {
	                    if (token instanceof Array) {
	                        tstack = token;
	                        token = tstack.pop();
	                    }
	                    token = self.symbols_[token] || token;
	                }
	                return token;
	            }
	            var symbol,
	                preErrorSymbol,
	                state,
	                action,
	                r,
	                yyval = {},
	                p,
	                len,
	                newState,
	                expected;
	            while (true) {
	                state = stack[stack.length - 1];
	                if (this.defaultActions[state]) {
	                    action = this.defaultActions[state];
	                } else {
	                    if (symbol === null || typeof symbol == 'undefined') {
	                        symbol = lex();
	                    }
	                    action = table[state] && table[state][symbol];
	                }
	                if (typeof action === 'undefined' || !action.length || !action[0]) {
	                    var errStr = '';
	                    expected = [];
	                    for (p in table[state]) {
	                        if (this.terminals_[p] && p > TERROR) {
	                            expected.push('\'' + this.terminals_[p] + '\'');
	                        }
	                    }
	                    if (lexer.showPosition) {
	                        errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	                    } else {
	                        errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	                    }
	                    this.parseError(errStr, {
	                        text: lexer.match,
	                        token: this.terminals_[symbol] || symbol,
	                        line: lexer.yylineno,
	                        loc: yyloc,
	                        expected: expected
	                    });
	                }
	                if (action[0] instanceof Array && action.length > 1) {
	                    throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	                }
	                switch (action[0]) {
	                    case 1:
	                        stack.push(symbol);
	                        vstack.push(lexer.yytext);
	                        lstack.push(lexer.yylloc);
	                        stack.push(action[1]);
	                        symbol = null;
	                        if (!preErrorSymbol) {
	                            yyleng = lexer.yyleng;
	                            yytext = lexer.yytext;
	                            yylineno = lexer.yylineno;
	                            yyloc = lexer.yylloc;
	                        } else {
	                            symbol = preErrorSymbol;
	                            preErrorSymbol = null;
	                        }
	                        break;
	                    case 2:
	                        len = this.productions_[action[1]][1];
	                        yyval.$ = vstack[vstack.length - len];
	                        yyval._$ = {
	                            first_line: lstack[lstack.length - (len || 1)].first_line,
	                            last_line: lstack[lstack.length - 1].last_line,
	                            first_column: lstack[lstack.length - (len || 1)].first_column,
	                            last_column: lstack[lstack.length - 1].last_column
	                        };
	                        if (ranges) {
	                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
	                        }
	                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
	                        if (typeof r !== 'undefined') {
	                            return r;
	                        }
	                        if (len) {
	                            stack = stack.slice(0, -1 * len * 2);
	                            vstack = vstack.slice(0, -1 * len);
	                            lstack = lstack.slice(0, -1 * len);
	                        }
	                        stack.push(this.productions_[action[1]][0]);
	                        vstack.push(yyval.$);
	                        lstack.push(yyval._$);
	                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	                        stack.push(newState);
	                        break;
	                    case 3:
	                        return true;
	                }
	            }
	            return true;
	        } };

	    /* generated by jison-lex 0.3.4 */
	    var lexer = function () {
	        var lexer = {

	            EOF: 1,

	            parseError: function parseError(str, hash) {
	                if (this.yy.parser) {
	                    this.yy.parser.parseError(str, hash);
	                } else {
	                    throw new Error(str);
	                }
	            },

	            // resets the lexer, sets new input
	            setInput: function setInput(input, yy) {
	                this.yy = yy || this.yy || {};
	                this._input = input;
	                this._more = this._backtrack = this.done = false;
	                this.yylineno = this.yyleng = 0;
	                this.yytext = this.matched = this.match = '';
	                this.conditionStack = ['INITIAL'];
	                this.yylloc = {
	                    first_line: 1,
	                    first_column: 0,
	                    last_line: 1,
	                    last_column: 0
	                };
	                if (this.options.ranges) {
	                    this.yylloc.range = [0, 0];
	                }
	                this.offset = 0;
	                return this;
	            },

	            // consumes and returns one char from the input
	            input: function input() {
	                var ch = this._input[0];
	                this.yytext += ch;
	                this.yyleng++;
	                this.offset++;
	                this.match += ch;
	                this.matched += ch;
	                var lines = ch.match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno++;
	                    this.yylloc.last_line++;
	                } else {
	                    this.yylloc.last_column++;
	                }
	                if (this.options.ranges) {
	                    this.yylloc.range[1]++;
	                }

	                this._input = this._input.slice(1);
	                return ch;
	            },

	            // unshifts one char (or a string) into the input
	            unput: function unput(ch) {
	                var len = ch.length;
	                var lines = ch.split(/(?:\r\n?|\n)/g);

	                this._input = ch + this._input;
	                this.yytext = this.yytext.substr(0, this.yytext.length - len);
	                //this.yyleng -= len;
	                this.offset -= len;
	                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	                this.match = this.match.substr(0, this.match.length - 1);
	                this.matched = this.matched.substr(0, this.matched.length - 1);

	                if (lines.length - 1) {
	                    this.yylineno -= lines.length - 1;
	                }
	                var r = this.yylloc.range;

	                this.yylloc = {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.first_column,
	                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
	                };

	                if (this.options.ranges) {
	                    this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	                }
	                this.yyleng = this.yytext.length;
	                return this;
	            },

	            // When called from action, caches matched text and appends it on next action
	            more: function more() {
	                this._more = true;
	                return this;
	            },

	            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	            reject: function reject() {
	                if (this.options.backtrack_lexer) {
	                    this._backtrack = true;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                        text: "",
	                        token: null,
	                        line: this.yylineno
	                    });
	                }
	                return this;
	            },

	            // retain first n characters of the match
	            less: function less(n) {
	                this.unput(this.match.slice(n));
	            },

	            // displays already matched input, i.e. for error messages
	            pastInput: function pastInput() {
	                var past = this.matched.substr(0, this.matched.length - this.match.length);
	                return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
	            },

	            // displays upcoming input, i.e. for error messages
	            upcomingInput: function upcomingInput() {
	                var next = this.match;
	                if (next.length < 20) {
	                    next += this._input.substr(0, 20 - next.length);
	                }
	                return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	            },

	            // displays the character position where the lexing error occurred, i.e. for error messages
	            showPosition: function showPosition() {
	                var pre = this.pastInput();
	                var c = new Array(pre.length + 1).join("-");
	                return pre + this.upcomingInput() + "\n" + c + "^";
	            },

	            // test the lexed token: return FALSE when not a match, otherwise return token
	            test_match: function test_match(match, indexed_rule) {
	                var token, lines, backup;

	                if (this.options.backtrack_lexer) {
	                    // save context
	                    backup = {
	                        yylineno: this.yylineno,
	                        yylloc: {
	                            first_line: this.yylloc.first_line,
	                            last_line: this.last_line,
	                            first_column: this.yylloc.first_column,
	                            last_column: this.yylloc.last_column
	                        },
	                        yytext: this.yytext,
	                        match: this.match,
	                        matches: this.matches,
	                        matched: this.matched,
	                        yyleng: this.yyleng,
	                        offset: this.offset,
	                        _more: this._more,
	                        _input: this._input,
	                        yy: this.yy,
	                        conditionStack: this.conditionStack.slice(0),
	                        done: this.done
	                    };
	                    if (this.options.ranges) {
	                        backup.yylloc.range = this.yylloc.range.slice(0);
	                    }
	                }

	                lines = match[0].match(/(?:\r\n?|\n).*/g);
	                if (lines) {
	                    this.yylineno += lines.length;
	                }
	                this.yylloc = {
	                    first_line: this.yylloc.last_line,
	                    last_line: this.yylineno + 1,
	                    first_column: this.yylloc.last_column,
	                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
	                };
	                this.yytext += match[0];
	                this.match += match[0];
	                this.matches = match;
	                this.yyleng = this.yytext.length;
	                if (this.options.ranges) {
	                    this.yylloc.range = [this.offset, this.offset += this.yyleng];
	                }
	                this._more = false;
	                this._backtrack = false;
	                this._input = this._input.slice(match[0].length);
	                this.matched += match[0];
	                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	                if (this.done && this._input) {
	                    this.done = false;
	                }
	                if (token) {
	                    return token;
	                } else if (this._backtrack) {
	                    // recover context
	                    for (var k in backup) {
	                        this[k] = backup[k];
	                    }
	                    return false; // rule action called reject() implying the next rule should be tested instead.
	                }
	                return false;
	            },

	            // return next match in input
	            next: function next() {
	                if (this.done) {
	                    return this.EOF;
	                }
	                if (!this._input) {
	                    this.done = true;
	                }

	                var token, match, tempMatch, index;
	                if (!this._more) {
	                    this.yytext = '';
	                    this.match = '';
	                }
	                var rules = this._currentRules();
	                for (var i = 0; i < rules.length; i++) {
	                    tempMatch = this._input.match(this.rules[rules[i]]);
	                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                        match = tempMatch;
	                        index = i;
	                        if (this.options.backtrack_lexer) {
	                            token = this.test_match(tempMatch, rules[i]);
	                            if (token !== false) {
	                                return token;
	                            } else if (this._backtrack) {
	                                match = false;
	                                continue; // rule action called reject() implying a rule MISmatch.
	                            } else {
	                                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                                return false;
	                            }
	                        } else if (!this.options.flex) {
	                            break;
	                        }
	                    }
	                }
	                if (match) {
	                    token = this.test_match(match, rules[index]);
	                    if (token !== false) {
	                        return token;
	                    }
	                    // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                    return false;
	                }
	                if (this._input === "") {
	                    return this.EOF;
	                } else {
	                    return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                        text: "",
	                        token: null,
	                        line: this.yylineno
	                    });
	                }
	            },

	            // return next match that has a token
	            lex: function lex() {
	                var r = this.next();
	                if (r) {
	                    return r;
	                } else {
	                    return this.lex();
	                }
	            },

	            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	            begin: function begin(condition) {
	                this.conditionStack.push(condition);
	            },

	            // pop the previously active lexer condition state off the condition stack
	            popState: function popState() {
	                var n = this.conditionStack.length - 1;
	                if (n > 0) {
	                    return this.conditionStack.pop();
	                } else {
	                    return this.conditionStack[0];
	                }
	            },

	            // produce the lexer rule set which is active for the currently active lexer condition state
	            _currentRules: function _currentRules() {
	                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	                } else {
	                    return this.conditions["INITIAL"].rules;
	                }
	            },

	            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	            topState: function topState(n) {
	                n = this.conditionStack.length - 1 - Math.abs(n || 0);
	                if (n >= 0) {
	                    return this.conditionStack[n];
	                } else {
	                    return "INITIAL";
	                }
	            },

	            // alias for begin(condition)
	            pushState: function pushState(condition) {
	                this.begin(condition);
	            },

	            // return the number of states currently on the stack
	            stateStackSize: function stateStackSize() {
	                return this.conditionStack.length;
	            },
	            options: { "case-insensitive": true },
	            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
	                switch ($avoiding_name_collisions) {
	                    case 0:
	                        /* skip whitespace */
	                        break;
	                    case 1:
	                        return 20;
	                        break;
	                    case 2:
	                        return 7;
	                        break;
	                    case 3:
	                        return 8;
	                        break;
	                    case 4:
	                        return 9;
	                        break;
	                    case 5:
	                        return 12;
	                        break;
	                    case 6:
	                        return 16;
	                        break;
	                    case 7:
	                        return 14;
	                        break;
	                    case 8:
	                        return 10;
	                        break;
	                    case 9:
	                        return 11;
	                        break;
	                    case 10:
	                        return 19;
	                        break;
	                    case 11:
	                        return 21;
	                        break;
	                    case 12:
	                        return '<=';
	                        break;
	                    case 13:
	                        return '>=';
	                        break;
	                    case 14:
	                        return '<';
	                        break;
	                    case 15:
	                        return '>';
	                        break;
	                    case 16:
	                        yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);return 24;
	                        break;
	                    case 17:
	                        return 13;
	                        break;
	                    case 18:
	                        return 23;
	                        break;
	                    case 19:
	                        return 5;
	                        break;
	                    case 20:
	                        return 'INVALID';
	                        break;
	                }
	            },
	            rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
	            conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], "inclusive": true } }
	        };
	        return lexer;
	    }();
	    parser.lexer = lexer;
	    function Parser() {
	        this.yy = {};
	    }
	    Parser.prototype = parser;parser.Parser = Parser;
	    return new Parser();
	}();

	var SelectionParser = { parser: parser };
	var SelectionParser_1 = SelectionParser.parser;

	var keywords = {};

	function defineSelector(name, SelectorClass) {
	  var keyword = name.toLowerCase();
	  SelectorClass.prototype.keyword = keyword;
	  SelectorClass.prototype.name = name;

	  var factory = function factory() {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return new (Function.prototype.bind.apply(SelectorClass, [null].concat(args)))();
	  };
	  factory.SelectorClass = SelectorClass;
	  keywords[keyword] = factory;

	  return SelectorClass;
	}

	//////////////////////////////////////////////////////////////////////////////

	var Range = function () {
	  function Range(min, max) {
	    classCallCheck(this, Range);

	    this.min = min;
	    this.max = typeof max === 'undefined' ? min : max;
	  }

	  createClass(Range, [{
	    key: 'includes',
	    value: function includes(value) {
	      return this.min <= value && value <= this.max;
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      var min = this.min,
	          max = this.max;
	      return min === max ? String(min) : [min, max].join(':');
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return [this.min, this.max];
	    }
	  }]);
	  return Range;
	}();

	//////////////////////////////////////////////////////////////////////////////

	var List = function () {
	  function List(arg) {
	    classCallCheck(this, List);

	    if (arg instanceof this.constructor) {
	      return arg;
	    } else if (arg instanceof Array) {
	      this._values = arg.slice(0);
	    } else if (arg) {
	      this._values = [arg];
	    } else {
	      this._values = [];
	    }
	  }

	  createClass(List, [{
	    key: 'append',
	    value: function append(value) {
	      var values = this._values;
	      values[values.length] = value;
	      return this;
	    }
	  }, {
	    key: 'remove',
	    value: function remove(value) {
	      var values = this._values;
	      var index = values.indexOf(value);
	      if (index >= 0) {
	        values.splice(index, 1);
	      }
	      return this;
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return this._values.join(',');
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      var values = this._values,
	          result = [];
	      for (var i = 0, n = values.length; i < n; ++i) {
	        var value = values[i];
	        result[i] = value.toJSON ? value.toJSON() : value;
	      }
	      return result;
	    }
	  }]);
	  return List;
	}();

	//////////////////////////////////////////////////////////////////////////////

	var RangeList = function (_List) {
	  inherits(RangeList, _List);

	  function RangeList() {
	    classCallCheck(this, RangeList);
	    return possibleConstructorReturn(this, (RangeList.__proto__ || Object.getPrototypeOf(RangeList)).apply(this, arguments));
	  }

	  createClass(RangeList, [{
	    key: 'includes',
	    value: function includes(value) {
	      var list = this._values;
	      for (var i = 0, n = list.length; i < n; ++i) {
	        if (list[i].includes(value)) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }]);
	  return RangeList;
	}(List);

	//////////////////////////////////////////////////////////////////////////////

	var valuesArray = [];

	var ValueList = function (_List2) {
	  inherits(ValueList, _List2);

	  function ValueList(arg, caseInsensitive) {
	    var _this2, _ret;

	    classCallCheck(this, ValueList);

	    var list = (_this2 = possibleConstructorReturn(this, (ValueList.__proto__ || Object.getPrototypeOf(ValueList)).call(this, arg)), _this2);
	    if (caseInsensitive) {
	      var values = list._values;
	      for (var i = 0, n = values.length; i < n; ++i) {
	        var value = values[i];
	        if (typeof value === 'string') {
	          values[i] = value.toUpperCase();
	        }
	      }
	    }
	    return _ret = list, possibleConstructorReturn(_this2, _ret);
	  }

	  createClass(ValueList, [{
	    key: 'includes',
	    value: function includes(value) {
	      return this._values.indexOf(value) !== -1;
	    }
	  }, {
	    key: 'toString',
	    value: function toString() {
	      // Quote values that are not correct identifiers
	      var values = this._values;
	      valuesArray.length = 0;
	      for (var i = 0, n = values.length; i < n; ++i) {
	        valuesArray[i] = utils.correctSelectorIdentifier(String(values[i]));
	      }
	      return valuesArray.join(',');
	    }
	  }]);
	  return ValueList;
	}(List);

	//////////////////////////////////////////////////////////////////////////////
	// Selectors

	/** Base class for atom selectors. */


	var Selector = function () {
	  function Selector() {
	    classCallCheck(this, Selector);
	  }

	  createClass(Selector, [{
	    key: 'toString',
	    value: function toString() {
	      return this.keyword;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return [this.name];
	    }
	  }]);
	  return Selector;
	}();

	Selector.prototype.name = 'Error';
	Selector.prototype.keyword = 'error';

	/** Base class for list-based atom selectors. */

	var ListSelector = function (_Selector) {
	  inherits(ListSelector, _Selector);

	  function ListSelector(list) {
	    classCallCheck(this, ListSelector);

	    var _this3 = possibleConstructorReturn(this, (ListSelector.__proto__ || Object.getPrototypeOf(ListSelector)).call(this));

	    _this3.list = list;
	    return _this3;
	  }

	  createClass(ListSelector, [{
	    key: 'toString',
	    value: function toString() {
	      return this.keyword + ' ' + this.list;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return [this.name, this.list.toJSON()];
	    }
	  }]);
	  return ListSelector;
	}(Selector);

	var RangeListSelector = function (_ListSelector) {
	  inherits(RangeListSelector, _ListSelector);

	  function RangeListSelector(arg) {
	    classCallCheck(this, RangeListSelector);
	    return possibleConstructorReturn(this, (RangeListSelector.__proto__ || Object.getPrototypeOf(RangeListSelector)).call(this, new RangeList(arg)));
	  }

	  return RangeListSelector;
	}(ListSelector);

	var ValueListSelector = function (_ListSelector2) {
	  inherits(ValueListSelector, _ListSelector2);

	  function ValueListSelector(arg, caseSensitive) {
	    classCallCheck(this, ValueListSelector);
	    return possibleConstructorReturn(this, (ValueListSelector.__proto__ || Object.getPrototypeOf(ValueListSelector)).call(this, new ValueList(arg, !caseSensitive)));
	  }

	  return ValueListSelector;
	}(ListSelector);

	defineSelector('Serial', function (_RangeListSelector) {
	  inherits(SerialSelector, _RangeListSelector);

	  function SerialSelector() {
	    classCallCheck(this, SerialSelector);
	    return possibleConstructorReturn(this, (SerialSelector.__proto__ || Object.getPrototypeOf(SerialSelector)).apply(this, arguments));
	  }

	  createClass(SerialSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._serial);
	    }
	  }]);
	  return SerialSelector;
	}(RangeListSelector));

	defineSelector('Name', function (_ValueListSelector) {
	  inherits(NameSelector, _ValueListSelector);

	  function NameSelector() {
	    classCallCheck(this, NameSelector);
	    return possibleConstructorReturn(this, (NameSelector.__proto__ || Object.getPrototypeOf(NameSelector)).apply(this, arguments));
	  }

	  createClass(NameSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._name.getString());
	    }
	  }]);
	  return NameSelector;
	}(ValueListSelector));

	defineSelector('AltLoc', function (_ValueListSelector2) {
	  inherits(AltLocSelector, _ValueListSelector2);

	  function AltLocSelector() {
	    classCallCheck(this, AltLocSelector);
	    return possibleConstructorReturn(this, (AltLocSelector.__proto__ || Object.getPrototypeOf(AltLocSelector)).apply(this, arguments));
	  }

	  createClass(AltLocSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(String.fromCharCode(atom._location));
	    }
	  }]);
	  return AltLocSelector;
	}(ValueListSelector));

	defineSelector('Elem', function (_ValueListSelector3) {
	  inherits(ElemSelector, _ValueListSelector3);

	  function ElemSelector() {
	    classCallCheck(this, ElemSelector);
	    return possibleConstructorReturn(this, (ElemSelector.__proto__ || Object.getPrototypeOf(ElemSelector)).apply(this, arguments));
	  }

	  createClass(ElemSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom.element.name);
	    }
	  }]);
	  return ElemSelector;
	}(ValueListSelector));

	defineSelector('Residue', function (_ValueListSelector4) {
	  inherits(ResidueSelector, _ValueListSelector4);

	  function ResidueSelector() {
	    classCallCheck(this, ResidueSelector);
	    return possibleConstructorReturn(this, (ResidueSelector.__proto__ || Object.getPrototypeOf(ResidueSelector)).apply(this, arguments));
	  }

	  createClass(ResidueSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._residue._type._name);
	    }
	  }]);
	  return ResidueSelector;
	}(ValueListSelector));

	defineSelector('Sequence', function (_RangeListSelector2) {
	  inherits(SequenceSelector, _RangeListSelector2);

	  function SequenceSelector() {
	    classCallCheck(this, SequenceSelector);
	    return possibleConstructorReturn(this, (SequenceSelector.__proto__ || Object.getPrototypeOf(SequenceSelector)).apply(this, arguments));
	  }

	  createClass(SequenceSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._residue._sequence);
	    }
	  }]);
	  return SequenceSelector;
	}(RangeListSelector));

	defineSelector('ICode', function (_ValueListSelector5) {
	  inherits(ICodeSelector, _ValueListSelector5);

	  function ICodeSelector(arg) {
	    classCallCheck(this, ICodeSelector);
	    return possibleConstructorReturn(this, (ICodeSelector.__proto__ || Object.getPrototypeOf(ICodeSelector)).call(this, arg, true));
	  }

	  createClass(ICodeSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._residue._icode);
	    }
	  }]);
	  return ICodeSelector;
	}(ValueListSelector));

	defineSelector('ResIdx', function (_RangeListSelector3) {
	  inherits(ResIdxSelector, _RangeListSelector3);

	  function ResIdxSelector() {
	    classCallCheck(this, ResIdxSelector);
	    return possibleConstructorReturn(this, (ResIdxSelector.__proto__ || Object.getPrototypeOf(ResIdxSelector)).apply(this, arguments));
	  }

	  createClass(ResIdxSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._residue._index);
	    }
	  }]);
	  return ResIdxSelector;
	}(RangeListSelector));

	defineSelector('Chain', function (_ValueListSelector6) {
	  inherits(ChainSelector, _ValueListSelector6);

	  function ChainSelector(arg) {
	    classCallCheck(this, ChainSelector);
	    return possibleConstructorReturn(this, (ChainSelector.__proto__ || Object.getPrototypeOf(ChainSelector)).call(this, arg, true));
	  }

	  createClass(ChainSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.list.includes(atom._residue._chain._name);
	    }
	  }]);
	  return ChainSelector;
	}(ValueListSelector));

	defineSelector('Hetatm', function (_Selector2) {
	  inherits(HetatmSelector, _Selector2);

	  function HetatmSelector() {
	    classCallCheck(this, HetatmSelector);
	    return possibleConstructorReturn(this, (HetatmSelector.__proto__ || Object.getPrototypeOf(HetatmSelector)).apply(this, arguments));
	  }

	  createClass(HetatmSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return atom._het;
	    }
	  }]);
	  return HetatmSelector;
	}(Selector));

	defineSelector('PolarH', function (_Selector3) {
	  inherits(PolarHSelector, _Selector3);

	  function PolarHSelector() {
	    classCallCheck(this, PolarHSelector);
	    return possibleConstructorReturn(this, (PolarHSelector.__proto__ || Object.getPrototypeOf(PolarHSelector)).apply(this, arguments));
	  }

	  createClass(PolarHSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return (atom.flags & Atom.Flags.NONPOLARH) === Atom.Flags.HYDROGEN;
	    }
	  }]);
	  return PolarHSelector;
	}(Selector));

	defineSelector('NonPolarH', function (_Selector4) {
	  inherits(NonPolarHSelector, _Selector4);

	  function NonPolarHSelector() {
	    classCallCheck(this, NonPolarHSelector);
	    return possibleConstructorReturn(this, (NonPolarHSelector.__proto__ || Object.getPrototypeOf(NonPolarHSelector)).apply(this, arguments));
	  }

	  createClass(NonPolarHSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return (atom.flags & Atom.Flags.NONPOLARH) === Atom.Flags.NONPOLARH;
	    }
	  }]);
	  return NonPolarHSelector;
	}(Selector));

	defineSelector('All', function (_Selector5) {
	  inherits(AllSelector, _Selector5);

	  function AllSelector() {
	    classCallCheck(this, AllSelector);
	    return possibleConstructorReturn(this, (AllSelector.__proto__ || Object.getPrototypeOf(AllSelector)).apply(this, arguments));
	  }

	  createClass(AllSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(_atom) {
	      return true;
	    }
	  }]);
	  return AllSelector;
	}(Selector));

	defineSelector('None', function (_Selector6) {
	  inherits(NoneSelector, _Selector6);

	  function NoneSelector() {
	    classCallCheck(this, NoneSelector);
	    return possibleConstructorReturn(this, (NoneSelector.__proto__ || Object.getPrototypeOf(NoneSelector)).apply(this, arguments));
	  }

	  createClass(NoneSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(_atom) {
	      return false;
	    }
	  }]);
	  return NoneSelector;
	}(Selector));

	var NULL_SELECTOR = keywords.none();

	//////////////////////////////////////////////////////////////////////////////
	// Flag selectors

	function byResidueTypeFlag(flag, name) {
	  return defineSelector(name, function (_Selector7) {
	    inherits(_class, _Selector7);

	    function _class() {
	      classCallCheck(this, _class);
	      return possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
	    }

	    createClass(_class, [{
	      key: 'includesAtom',
	      value: function includesAtom(atom) {
	        return (atom._residue._type.flags & flag) !== 0;
	      }
	    }]);
	    return _class;
	  }(Selector));
	}

	byResidueTypeFlag(ResidueType.Flags.PROTEIN, 'Protein');
	byResidueTypeFlag(ResidueType.Flags.BASIC, 'Basic');
	byResidueTypeFlag(ResidueType.Flags.ACIDIC, 'Acidic');
	byResidueTypeFlag(ResidueType.Flags.BASIC | ResidueType.Flags.ACIDIC, 'Charged');
	byResidueTypeFlag(ResidueType.Flags.POLAR, 'Polar');
	byResidueTypeFlag(ResidueType.Flags.NONPOLAR, 'NonPolar');
	byResidueTypeFlag(ResidueType.Flags.AROMATIC, 'Aromatic');
	byResidueTypeFlag(ResidueType.Flags.NUCLEIC, 'Nucleic');
	byResidueTypeFlag(ResidueType.Flags.PURINE, 'Purine');
	byResidueTypeFlag(ResidueType.Flags.PYRIMIDINE, 'Pyrimidine');
	byResidueTypeFlag(ResidueType.Flags.WATER, 'Water');

	//////////////////////////////////////////////////////////////////////////////
	// Operators

	function defineOperator(name, priority, OperatorClass) {
	  OperatorClass.prototype.priority = priority;
	  return defineSelector(name, OperatorClass);
	}

	var PrefixOperator = function (_Selector8) {
	  inherits(PrefixOperator, _Selector8);

	  function PrefixOperator(rhs) {
	    classCallCheck(this, PrefixOperator);

	    var _this21 = possibleConstructorReturn(this, (PrefixOperator.__proto__ || Object.getPrototypeOf(PrefixOperator)).call(this));

	    _this21.rhs = rhs || NULL_SELECTOR;
	    return _this21;
	  }

	  createClass(PrefixOperator, [{
	    key: 'toString',
	    value: function toString() {
	      var rhs = this.rhs.priority && this.rhs.priority > this.priority ? '(' + this.rhs + ')' : this.rhs;
	      return this.keyword + ' ' + rhs;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return [this.name, this.rhs.toJSON()];
	    }
	  }]);
	  return PrefixOperator;
	}(Selector);

	PrefixOperator.prototype.priority = 1;

	var InfixOperator = function (_Selector9) {
	  inherits(InfixOperator, _Selector9);

	  function InfixOperator(lhs, rhs) {
	    classCallCheck(this, InfixOperator);

	    var _this22 = possibleConstructorReturn(this, (InfixOperator.__proto__ || Object.getPrototypeOf(InfixOperator)).call(this));

	    _this22.lhs = lhs || NULL_SELECTOR;
	    _this22.rhs = rhs || NULL_SELECTOR;
	    return _this22;
	  }

	  createClass(InfixOperator, [{
	    key: 'toString',
	    value: function toString() {
	      var lhs = this.lhs.priority && this.lhs.priority > this.priority ? '(' + this.lhs + ')' : this.lhs;
	      var rhs = this.rhs.priority && this.rhs.priority > this.priority ? '(' + this.rhs + ')' : this.rhs;
	      return lhs + ' ' + this.keyword + ' ' + rhs;
	    }
	  }, {
	    key: 'toJSON',
	    value: function toJSON() {
	      return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
	    }
	  }]);
	  return InfixOperator;
	}(Selector);

	InfixOperator.prototype.priority = 1000;

	defineOperator('Not', 1, function (_PrefixOperator) {
	  inherits(NotSelector, _PrefixOperator);

	  function NotSelector() {
	    classCallCheck(this, NotSelector);
	    return possibleConstructorReturn(this, (NotSelector.__proto__ || Object.getPrototypeOf(NotSelector)).apply(this, arguments));
	  }

	  createClass(NotSelector, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return !this.rhs.includesAtom(atom);
	    }
	  }]);
	  return NotSelector;
	}(PrefixOperator));

	defineOperator('And', 2, function (_InfixOperator) {
	  inherits(AndOperator, _InfixOperator);

	  function AndOperator() {
	    classCallCheck(this, AndOperator);
	    return possibleConstructorReturn(this, (AndOperator.__proto__ || Object.getPrototypeOf(AndOperator)).apply(this, arguments));
	  }

	  createClass(AndOperator, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
	    }
	  }]);
	  return AndOperator;
	}(InfixOperator));

	defineOperator('Or', 3, function (_InfixOperator2) {
	  inherits(OrOperator, _InfixOperator2);

	  function OrOperator() {
	    classCallCheck(this, OrOperator);
	    return possibleConstructorReturn(this, (OrOperator.__proto__ || Object.getPrototypeOf(OrOperator)).apply(this, arguments));
	  }

	  createClass(OrOperator, [{
	    key: 'includesAtom',
	    value: function includesAtom(atom) {
	      return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
	    }
	  }]);
	  return OrOperator;
	}(InfixOperator));

	//////////////////////////////////////////////////////////////////////////////

	var selectors = Object.create(keywords);

	// TODO: Provide consistent module exports
	selectors.Selector = Selector;
	selectors.RangeListSelector = RangeListSelector;
	selectors.ValueListSelector = ValueListSelector;
	selectors.Range = Range;
	selectors.RangeList = RangeList;
	selectors.ValueList = ValueList;
	selectors.PrefixOperator = PrefixOperator;
	selectors.InfixOperator = InfixOperator;
	selectors.Context = Object.create({});

	selectors.GetSelector = function (key) {
	  if (!selectors.Context.hasOwnProperty(key)) {
	    var exc = { message: 'selector ' + key + ' is not registered' };
	    throw exc;
	  }
	  return selectors.Context[key] || NULL_SELECTOR;
	};

	selectors.ClearContext = function () {
	  Object.keys(selectors.Context).forEach(function (k) {
	    delete selectors.Context[k];
	  });
	};

	selectors.keyword = function (key) {
	  return keywords[key.toLowerCase()] || keywords.none;
	};

	selectors.parse = function (str) {
	  var res = {};
	  try {
	    res.selector = SelectionParser_1.parse(str);
	  } catch (e) {
	    res.selector = NULL_SELECTOR;
	    res.error = e.message;
	  }
	  return res;
	};

	SelectionParser_1.yy = selectors;
	SelectionParser_1.yy.parseError = SelectionParser_1.parseError; // FIXME: workaround for incorrect JISON parser generator for AMD module

	/**
	 * Basic biological unit class.
	 *
	 * @exports BiologicalUnit
	 * @constructor
	 */
	function BiologicalUnit(complex) {
	  this._complex = complex;
	  this._selector = selectors.keyword('All')();
	  this._boundaries = {
	    boundingBox: new Box3(),
	    boundingSphere: new Sphere()
	  };
	}

	BiologicalUnit.prototype.constructor = BiologicalUnit;

	BiologicalUnit.prototype.computeBoundaries = function () {
	  var atoms = this._complex._atoms;
	  var n = atoms.length;
	  var selector = this._selector;
	  var i;

	  var boundingBox = this._boundaries.boundingBox;
	  boundingBox.makeEmpty();
	  if (n === 1) {
	    boundingBox.expandByPoint(atoms[0]._position);
	    var bbc = new Vector3();
	    boundingBox.getCenter(bbc);
	    var s = 2 * atoms[0].element.radius; //*settings.now.modes.BS.atom; FIXME N: hack commented
	    boundingBox.setFromCenterAndSize(bbc, new Vector3(s, s, s));
	  } else {
	    for (i = 0; i < n; ++i) {
	      if (selector.includesAtom(atoms[i])) {
	        boundingBox.expandByPoint(atoms[i]._position);
	      }
	    }
	  }

	  // Build bounding sphere
	  var radiusSquared = 0.0;
	  var center = new Vector3();
	  boundingBox.getCenter(center);
	  if (n === 1) {
	    // * settings.now.modes.BS.atom); FIXME N: hack commented
	    this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
	  } else {
	    for (i = 0; i < n; ++i) {
	      if (!selector.includesAtom(atoms[i])) {
	        continue;
	      }
	      var pos = atoms[i]._position;
	      var lengthSquared = center.distanceToSquared(pos);
	      if (radiusSquared < lengthSquared) {
	        radiusSquared = lengthSquared;
	      }
	    }
	    this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
	  }
	};

	BiologicalUnit.prototype.getTransforms = function () {
	  return [];
	};

	BiologicalUnit.prototype.getSelector = function () {
	  return this._selector;
	};

	BiologicalUnit.prototype.getBoundaries = function () {
	  return this._boundaries;
	};

	BiologicalUnit.prototype.finalize = function () {};

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Biological assembly.
	 *
	 * @exports Assembly
	 * @constructor
	 */
	function Assembly(complex) {
	  BiologicalUnit.call(this, complex);
	  this.chains = [];
	  this.matrices = [];
	}

	Assembly.prototype = Object.create(BiologicalUnit.prototype);
	Assembly.prototype.constructor = Assembly;

	Assembly.prototype.computeBoundaries = function () {
	  BiologicalUnit.prototype.computeBoundaries.call(this);
	  // fix up the boundaries
	  var matrices = this.matrices;
	  var oldCenter = this._boundaries.boundingSphere.center;
	  var oldRad = this._boundaries.boundingSphere.radius;
	  var boundingBox = this._boundaries.boundingBox = new Box3();
	  boundingBox.makeEmpty();
	  for (var i = 0, n = matrices.length; i < n; ++i) {
	    boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i]));
	  }

	  var newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
	  var center = new Vector3();
	  boundingBox.getCenter(center);
	  this._boundaries.boundingSphere = new Sphere().set(center, newRad);
	  boundingBox.max.addScalar(oldRad);
	  boundingBox.min.subScalar(oldRad);
	};

	/**
	 * Mark a chain as belonging to this biological assembly.
	 * @param {string} chain - chain identifier, usually a single letter
	 */
	Assembly.prototype.addChain = function (chain) {
	  this.chains[this.chains.length] = chain;
	};

	/**
	 * Add a transformation matrix.
	 * @param {THREE.Matrix4} matrix - transformation matrix
	 */
	Assembly.prototype.addMatrix = function (matrix) {
	  this.matrices[this.matrices.length] = matrix;
	};

	Assembly.prototype.getTransforms = function () {
	  return this.matrices;
	};

	Assembly.prototype.finalize = function () {
	  if (this.chains.length > 0) {
	    this._selector = selectors.keyword('Chain')(this.chains);
	  } else {
	    this._selector = selectors.keyword('None')();
	  }
	};

	/**
	 * Create new data source.
	 *
	 * @exports DataSource
	 * @this DataSource
	 * @abstract
	 * @constructor
	 * @classdesc Basic class for primary data sources used by displaying engine.
	 */
	function DataSource() {
	  if (this.constructor === DataSource) {
	    throw new Error('Can not instantiate abstract class!');
	  }
	}

	/**
	 * Mode identifier.
	 * @type {string}
	 */
	DataSource.prototype.id = '__';

	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * This class represents connected component as a part of a complex.
	 * WARNING! The whole component entity is build under the assumption that residues
	 * are placed in the chains and complex in ascending order of indices
	 *
	 * @param {Complex} complex - Molecular complex this chain belongs to.
	 *
	 * @exports Component
	 * @constructor
	 */
	function Component(complex) {
	  this._complex = complex;
	  this._index = -1;
	  this._residueIndices = [];
	  this._cycles = [];
	  this._subDivs = [];
	  this._residueCount = 0;
	}

	Component.prototype.getResidues = function () {
	  return this._complex._residues;
	};

	Component.prototype.getResidueCount = function () {
	  return this._residueCount;
	};

	Component.prototype.forEachResidue = function (process) {
	  var residues = this._complex._residues;
	  var resIdc = this._residueIndices;
	  for (var idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
	    for (var idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
	      process(residues[idx]);
	    }
	  }
	};

	Component.prototype.setSubDivs = function (subDivs) {
	  this._subDivs = subDivs;
	  var curr = 0;
	  var resIdc = [];
	  var resCnt = 0;
	  for (var i = 0, n = subDivs.length; i < n; ++i) {
	    if (i === n - 1 || subDivs[i].end + 1 !== subDivs[i + 1].start) {
	      var start = subDivs[curr].start;
	      var end = subDivs[i].end;
	      resIdc[resIdc.length] = {
	        start: start,
	        end: end
	      };
	      resCnt += end - start + 1;
	      curr = i + 1;
	    }
	  }

	  this._residueIndices = resIdc;
	  this._residueCount = resCnt;
	};

	Component.prototype.getComplex = function () {
	  return this._complex;
	};

	Component.prototype.forEachBond = function (process) {
	  var bonds = this._complex._bonds;

	  for (var i = 0, n = bonds.length; i < n; ++i) {
	    var bond = bonds[i];
	    if (bond._left._residue._component === this) {
	      process(bond);
	    }
	  }
	};

	Component.prototype.update = function () {
	  this.forEachCycle(function (cycle) {
	    cycle.update();
	  });
	};

	Component.prototype.forEachAtom = function (process) {
	  this.forEachResidue(function (residue) {
	    residue.forEachAtom(process);
	  });
	};

	Component.prototype.addCycle = function (cycle) {
	  this._cycles.push(cycle);
	};

	Component.prototype.forEachCycle = function (process) {
	  var cycles = this._cycles;
	  for (var i = 0, n = cycles.length; i < n; ++i) {
	    process(cycles[i]);
	  }
	};

	Component.prototype.markResidues = function () {
	  var self = this;
	  self.forEachResidue(function (residue) {
	    residue._component = self;
	  });
	};

	Component.prototype._forEachSubChain = function (mask, process) {
	  var residues = this._complex._residues;
	  var subs = this._subDivs;
	  for (var i = 0, n = subs.length; i < n; ++i) {
	    for (var idx = subs[i].start, last = subs[i].end; idx <= last; ++idx) {
	      var currRes = residues[idx];
	      if (mask & currRes._mask && currRes._isValid) {
	        var end = idx + 1;
	        for (; end <= last; ++end) {
	          var endRes = residues[end];
	          if (!(mask & endRes._mask && endRes._isValid)) {
	            break;
	          }
	        }
	        process(i, idx, end - 1);
	        idx = end;
	      }
	    }
	  }
	};

	Component.prototype.getMaskedSequences = function (mask) {
	  var subs = [];
	  var idx = 0;
	  this._forEachSubChain(mask, function (_subIdx, start, end) {
	    subs[idx++] = { start: start, end: end };
	  });

	  return subs;
	};

	Component.prototype.getMaskedSubdivSequences = function (mask) {
	  var subs = [];
	  var currIdx = -1;
	  var lastSubIdx = -1;
	  var subDivs = this._subDivs;

	  this._forEachSubChain(mask, function (subIdx, start, end) {
	    if (lastSubIdx !== subIdx) {
	      ++currIdx;
	      subs[currIdx] = {
	        arr: [],
	        boundaries: subDivs[subIdx]
	      };
	      lastSubIdx = subIdx;
	    }
	    subs[currIdx].arr[subs[currIdx].arr.length] = { start: start, end: end };
	  });

	  return subs;
	};

	//////////////////////////////////////////////////////////////////////////////
	var cMaxPairsForHashCode = 32;
	var cHashTableSize = 1024 * 1024;
	var cNumbersPerPair = 4;
	var cMaxNeighbours = 14;
	var cInvalidVal = -1;
	// 89237 is a large simple number, can be used for pseudo random hash code create
	var cBigPrime = 89237;

	function AtomPairs(maxPairsEstimate) {
	  var i = 0;

	  this.numPairs = 0;
	  this.numMaxPairs = maxPairsEstimate;
	  this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);
	  for (; i < maxPairsEstimate * cNumbersPerPair; i++) {
	    this.intBuffer[i] = cInvalidVal;
	  }
	  this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);
	  for (i = 0; i < cHashTableSize * cMaxPairsForHashCode; i++) {
	    this.hashBuffer[i] = cInvalidVal;
	  }
	}

	/**
	 * Destroy all pairs memory
	 */
	AtomPairs.prototype.destroy = function () {
	  this.intBuffer = null;
	  this.hashBuffer = null;
	};

	/**
	 * Add pair of atoms to collection
	 * @param {number} indexA - Index of the 1st vertex.
	 * @param {number} indexB - Index of the 2nd vertex.
	 */
	AtomPairs.prototype.addPair = function (indexA, indexB) {
	  var ia = indexA < indexB ? indexA : indexB;
	  var ib = indexA > indexB ? indexA : indexB;
	  var codeToAdd = ia + (ib << cMaxNeighbours);

	  var hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
	  var j = hashCode * cMaxPairsForHashCode;
	  var apI = 0;
	  for (; apI < cMaxPairsForHashCode; apI++) {
	    var code = this.hashBuffer[j + apI];
	    if (code === cInvalidVal) {
	      break;
	    }
	    if (code === codeToAdd) {
	      return false;
	    }
	  }
	  // add this new hash code
	  if (apI >= cMaxPairsForHashCode) {
	    throw new Error('addPair: increase cMaxPairsForHashCode');
	  }
	  this.hashBuffer[j + apI] = codeToAdd;

	  // actually add
	  if (this.numPairs >= this.numMaxPairs) {
	    throw new Error('addPair: increase num pairs');
	  }
	  j = this.numPairs * cNumbersPerPair;
	  this.intBuffer[j] = ia;
	  this.intBuffer[j + 1] = ib;
	  this.intBuffer[j + 2] = codeToAdd;
	  this.numPairs++;
	  return true;
	};

	var cEstBondsMultiplier = 4;
	var cSpaceCode = 32;
	var cBondTolerance = 0.45;
	var cEpsilon = 0.001;

	/**
	 * Get radius used for building bonds.
	 *
	 * @param {Atom} atom - Atom object.
	 * @returns {number} special value for bonding radius for this atom
	 */
	function _getBondingRadius(atom) {
	  var element = atom.element;
	  if (element) {
	    return element.radiusBonding;
	  } else {
	    throw new Error('_getBondingRadius: Logic error.');
	  }
	}

	function _isAtomEligible(atom) {
	  // build for all non-hetatm and for hetatm without bonds
	  return !atom.isHet() || atom._bonds && atom._bonds.length === 0;
	}

	function _isAtomEligibleWithWaterBondingHack(atom) {
	  // TODO: remove this hack (requested by customer)
	  var noHack = atom._residue._type._name !== 'HOH';
	  return noHack && !atom.isHet();
	}

	/**
	 * Bond between atoms.
	 *
	 * @param {Complex} complex molecular complex

	 * @exports AutoBond
	 * @constructor
	 */
	function AutoBond(complex) {
	  this._complex = complex;
	  this._maxRad = 1.8;
	  var bBox = this._complex.getDefaultBoundaries().boundingBox;
	  this._vBoxMin = bBox.min.clone();
	  this._vBoxMax = bBox.max.clone();

	  this._pairCollection = null;
	}

	/**
	 * Add existing pairs of connectors (from pdb file after its reading)
	 * @returns {number} 0
	 */
	AutoBond.prototype._addExistingPairs = function () {
	  var atoms = this._complex.getAtoms();
	  var numAtoms = atoms.length;
	  var aInd = 0;
	  var collection = this._pairCollection;

	  for (; aInd < numAtoms; aInd++) {
	    var bonds = atoms[aInd]._bonds;
	    var numBondsForAtom = bonds.length;
	    for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
	      var bond = bonds[bInd];
	      var indTo = bond._left._index;
	      if (indTo === aInd) {
	        collection.addPair(aInd, bond._right._index);
	      }
	    } // for (b) all bonds in atom
	  } // for (a)
	  return 0;
	};

	AutoBond.prototype._findPairs = function () {
	  var vw = this._complex.getVoxelWorld();
	  if (vw === null) {
	    return;
	  }

	  var atoms = this._complex._atoms;
	  var atomsNum = atoms.length;
	  var isAtomEligible = this.isAtomEligible;
	  var self = this;

	  var rA = void 0;
	  var isHydrogenA = void 0;
	  var posA = void 0;
	  var locationA = void 0;
	  var atomA = void 0;

	  var processAtom = function processAtom(atomB) {
	    if (isHydrogenA && atomB.isHydrogen()) {
	      return;
	    }

	    var locationB = atomB.getLocation();
	    if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
	      return;
	    }

	    var dist2 = posA.distanceToSquared(atomB._position);
	    var rB = atomB.element.radiusBonding;
	    var maxAcceptable = rA + rB + cBondTolerance;

	    if (dist2 > maxAcceptable * maxAcceptable) {
	      return;
	    }

	    if (dist2 < cEpsilon) {
	      return;
	    }

	    self._pairCollection.addPair(atomA._index, atomB._index);
	  };

	  for (var i = 0; i < atomsNum; ++i) {
	    atomA = atoms[i];
	    if (!isAtomEligible(atomA)) {
	      continue;
	    }

	    rA = atomA.element.radiusBonding;
	    isHydrogenA = atomA.isHydrogen();
	    posA = atomA._position;
	    locationA = atomA.getLocation();

	    vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
	  }
	};

	AutoBond.prototype._addPairs = function () {
	  var atoms = this._complex._atoms;

	  for (var i = 0, k = 0; i < this._pairCollection.numPairs; i++, k += 4) {
	    var iA = this._pairCollection.intBuffer[k];
	    var iB = this._pairCollection.intBuffer[k + 1];
	    this._addPair(atoms[iA], atoms[iB]);
	  }
	};

	AutoBond.prototype._addPair = function (atomA, atomB) {
	  var bondsA = atomA._bonds;
	  var indexA = atomA._index;
	  var indexB = atomB._index;
	  for (var j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
	    var bond = bondsA[j];
	    if (bond._left._index === indexB || bond._right._index === indexB) {
	      return;
	    }
	  }
	  var left = indexA < indexB ? atomA : atomB;
	  var right = indexA < indexB ? atomB : atomA;
	  var newBond = this._complex.addBond(left, right, 0, Bond.BondType.UNKNOWN, false);
	  bondsA.push(newBond);
	  atomB.getBonds().push(newBond);
	};

	// TODO: remove this hack (requested by customer)
	function _waterBondingHack(complex) {
	  var t = Bond.BondType.UNKNOWN;
	  var residues = complex._residues;
	  for (var i = 0, n = residues.length; i < n; i++) {
	    var residue = residues[i];
	    if (residue._type._name === 'HOH') {
	      var atoms = residue._atoms;
	      var a0 = atoms[0];
	      var a1 = atoms[1];
	      var a2 = atoms[2];
	      if (!a1 || !a2) {
	        continue;
	      }
	      var b1 = complex.addBond(a0, a1, 0, t, true);
	      var b2 = complex.addBond(a0, a2, 0, t, true);
	      a0._bonds[0] = b1;
	      a0._bonds[1] = b2;
	      a1._bonds[0] = b1;
	      a2._bonds[0] = b2;
	    }
	  }
	}

	AutoBond.prototype.build = function () {
	  // TODO verify that complex is ready
	  this._buildInner();

	  // TODO: remove this hack (requested by customer)
	  if (settings.now.draft.waterBondingHack && this._complex) {
	    _waterBondingHack(this._complex);
	  }
	};

	AutoBond.prototype._buildInner = function () {
	  var atoms = this._complex._atoms;
	  if (atoms.length < 2) {
	    return;
	  }
	  if (atoms[0]._index < 0) {
	    throw new Error('AutoBond: Atoms in complex were not indexed.');
	  }

	  this.isAtomEligible = settings.now.draft.waterBondingHack ? _isAtomEligibleWithWaterBondingHack : _isAtomEligible;

	  this._calcBoundingBox();
	  this._pairCollection = new AtomPairs(atoms.length * cEstBondsMultiplier);
	  this._addExistingPairs();
	  this._findPairs();
	  this._addPairs();
	};

	AutoBond.prototype._calcBoundingBox = function () {
	  var atoms = this._complex._atoms;
	  var nAtoms = atoms.length;
	  var maxRad = _getBondingRadius(atoms[0]);
	  for (var i = 1; i < nAtoms; ++i) {
	    maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]));
	  }
	  this._vBoxMax.addScalar(maxRad);
	  this._vBoxMin.addScalar(-maxRad);
	  this._maxRad = maxRad * 1.2;
	};

	AutoBond.prototype.destroy = function () {
	  if (this._pairCollection) {
	    this._pairCollection.destroy();
	  }
	};

	var cCrossThresh = 0.1;
	var cAromaticType = Bond.BondType.AROMATIC;
	var cAromaticAtoms = [Element.ByName.C.number, Element.ByName.N.number
	/*Element.ByName.O.number,
	  Element.ByName.S.number,*/
	];

	/** Conditions for bonds:
	 *   - Cross product with each subsequent bond to add is collinear and point to the same direction
	 *   - Each pair of a adjacent bonds belong to not more than one cycle
	 *   - If there is more than one candidates we try them in ascending order of angle values
	 */

	var _coDirVectors = function () {
	  var v1Tmp = new Vector3();
	  var v2Tmp = new Vector3();
	  var cp = new Vector3();
	  return function (v1, v2) {
	    v1Tmp.copy(v1).normalize();
	    v2Tmp.copy(v2).normalize();
	    cp.crossVectors(v1Tmp, v2Tmp);
	    if (cp.length() > cCrossThresh) {
	      return false;
	    }
	    // zero vector in out terms must be collinear to any
	    return v1Tmp.dot(v2Tmp) >= 0;
	  };
	}();

	function _insertAscending(arr, val) {
	  var idx = 0;
	  while (idx < arr.length && arr[idx] < val) {
	    ++idx;
	  }
	  arr.splice(idx, 0, val);
	}

	function _anotherAtom(bond, currAtom) {
	  return bond._left === currAtom ? bond._right : bond._left;
	}

	function _cosBetween(v1, v2) {
	  var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
	  return _Math.clamp(theta, -1, 1);
	}

	function _markAromatic(bond) {
	  bond._type = cAromaticType;
	}

	function Cycle(atomsList) {
	  this.atoms = atomsList;
	  this.update();
	}

	Cycle.prototype.update = function () {
	  var atoms = this.atoms;
	  var center = new Vector3();
	  var nA = atoms.length;
	  for (var j = 0; j < nA; ++j) {
	    center.add(atoms[j]._position);
	  }
	  center.multiplyScalar(1.0 / nA);
	  this.center = center;
	  this.radius = center.distanceTo(atoms[0]._position.clone().lerp(atoms[1]._position, 0.5));
	};

	Cycle.prototype.forEachBond = function (process) {
	  var atoms = this.atoms;
	  var nA = atoms.length;
	  var currAtom = atoms[0];
	  var nextAtom;

	  function checkBond(bond) {
	    if (bond._left === nextAtom || bond._right === nextAtom) {
	      process(bond);
	    }
	  }

	  for (var i = 0; i < nA; ++i) {
	    nextAtom = atoms[(i + 1) % nA];
	    currAtom.forEachBond(checkBond);
	    currAtom = nextAtom;
	  }
	};

	function _isAromatic(bond) {
	  return bond._type === cAromaticType;
	}

	function _isPossibleAromatic(bond) {
	  if (bond.type === cAromaticType) {
	    return true;
	  }
	  var rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
	  var leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
	  return rightIdx !== -1 && leftIdx !== -1;
	}

	function _checkCycleSimple(cycle) {
	  return cycle.length > 3;
	}

	function _checkCycleComplex(cycle) {
	  console.assert(cycle.length > 2);
	  return true;
	}

	function AromaticLoopsMarker(complex) {
	  this._complex = complex;
	  var bondsData = new Array(complex._bonds.length);
	  var bondMarks = new Array(complex._bonds.length);
	  for (var i = 0, n = bondsData.length; i < n; ++i) {
	    bondsData[i] = [];
	    bondMarks[i] = false;
	  }
	  this._bondsData = bondsData;
	  this._bondMarks = bondMarks;
	  this._resetCycles();
	}

	AromaticLoopsMarker.prototype._resetCycles = function () {
	  this._cycles = [];
	  this._currIdx = -1;
	};

	AromaticLoopsMarker.prototype._haveSameCycle = function (bondsData, bond1, bond2) {
	  var arr1 = bondsData[bond1._index];
	  var arr2 = bondsData[bond2._index];
	  var n1 = arr1.length;
	  var n2 = arr2.length;
	  var i1 = 0;
	  var i2 = 0;
	  while (i1 < n1 && i2 < n2) {
	    if (arr1[i1] === arr2[i2]) {
	      return true;
	    }
	    if (arr1[i1] > arr2[i2]) {
	      ++i2;
	    } else {
	      ++i1;
	    }
	  }
	  return false;
	};

	AromaticLoopsMarker.prototype._tryBond = function (prevBond, currRight, currDir) {
	  var bondsOrder = [];
	  var bondsData = this._bondsData;
	  var currLeft = _anotherAtom(prevBond, currRight);
	  var currVec = currRight._position.clone().sub(currLeft._position);
	  var startAtomRef = this._currStart;
	  var self = this;
	  var bondMarks = this._bondMarks;
	  var checkAromatic = this._checkBond;
	  bondMarks[prevBond._index] = true;
	  checkAromatic = checkAromatic === undefined ? _isAromatic : checkAromatic;
	  currRight.forEachBond(function (newBond) {
	    if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self._haveSameCycle(bondsData, prevBond, newBond)) {
	      return;
	    }
	    var anotherAtom = _anotherAtom(newBond, currRight);
	    var anotherVec = anotherAtom._position.clone().sub(currRight._position);
	    var val = anotherAtom === startAtomRef ? -2.0 : 1 - _cosBetween(currVec, anotherVec);
	    var newDir = anotherVec.cross(currVec);
	    if (!_coDirVectors(newDir, currDir)) {
	      return;
	    }
	    var idx = 0;
	    while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
	      ++idx;
	    }
	    bondsOrder.splice(idx, 0, { bond: newBond, val: val, dir: newDir });
	  });

	  for (var i = 0, n = bondsOrder.length; i < n; ++i) {
	    var bond = bondsOrder[i].bond;
	    var newRight = bond._left === currRight ? bond._right : bond._left;
	    if (newRight === startAtomRef) {
	      ++this._currIdx;
	      this._cycles.push([currRight]);
	      bondMarks[prevBond._index] = false;
	      return true;
	    }
	    if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
	      _insertAscending(bondsData[bond._index], this._currIdx);
	      this._cycles[this._currIdx].push(currRight);
	      bondMarks[prevBond._index] = false;
	      return true;
	    }
	  }
	  bondMarks[prevBond._index] = false;
	  return false;
	};

	AromaticLoopsMarker.prototype._startCycle = function (bond) {
	  // start from left to right
	  this._currStart = bond._left;
	  if (this._tryBond(bond, bond._right, new Vector3())) {
	    _insertAscending(this._bondsData[bond._index], this._currIdx);
	    this._cycles[this._currIdx].push(bond._left);
	  }
	};

	AromaticLoopsMarker.prototype._findLoops = function (checkBond, checkCycle) {
	  this._checkBond = checkBond;
	  var complex = this._complex;
	  var self = this;

	  complex.forEachComponent(function (component) {
	    self._resetCycles();
	    component.forEachBond(function (bond) {
	      if (checkBond(bond)) {
	        self._startCycle(bond);
	      }
	    });
	    var cycles = self._cycles;
	    for (var i = 0, n = cycles.length; i < n; ++i) {
	      var cycle = cycles[i];
	      if (!checkCycle(cycle)) {
	        continue;
	      }
	      var newCycle = new Cycle(cycle);
	      newCycle.forEachBond(_markAromatic);
	      component.addCycle(newCycle);
	    }
	  });
	};

	AromaticLoopsMarker.prototype.markCycles = function () {
	  this._findLoops(_isAromatic, _checkCycleSimple);
	};

	AromaticLoopsMarker.prototype.detectCycles = function () {
	  this._findLoops(_isPossibleAromatic, _checkCycleComplex);
	};

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Calculate min & max radius of a sphere slice between zMin & zMax
	 *
	 * @param {Vector3} center - center of the sphere
	 * @param {number} radius  - sphere radius
	 * @param {number} zMin - lower bound of the slice
	 * @param {number} zMax - upper bound of the slice
	 */
	function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
	  var dzMin = zMin - center.z;
	  var dzMax = zMax - center.z;
	  var rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0.0));
	  var rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0.0));

	  var rMin = Math.min(rzMin, rzMax);
	  var rMax;

	  if (zMin <= center.z && zMax >= center.z) {
	    // sphere's main diameter is inside slice
	    rMax = radius;
	  } else {
	    rMax = Math.max(rzMin, rzMax);
	  }

	  return [rMin, rMax];
	}

	/**
	 * Calculate min & max radius of a circle slice between yMin & yMax.
	 *
	 * To maintain analogy with _getSphereSliceRadiusRange we call radius what in fact is
	 * half-width (along X axis) of the slice, i.e. 1D-sphere radius.
	 *
	 * @param {Vector3} center - center of the circle (z can be ignored)
	 * @param {number} radius  - circle radius
	 * @param {number} yMin - lower bound of the slice
	 * @param {number} yMax - upper bound of the slice
	 * @returns {Array} - array of two numbers (min & max radius, or half-width)
	 */
	function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
	  var dyMin = yMin - center.y;
	  var dyMax = yMax - center.y;
	  var ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0.0));
	  var ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0.0));

	  var rMin = Math.min(ryMin, ryMax);
	  var rMax;

	  if (yMin <= center.y && yMax >= center.y) {
	    // slice's main diameter is inside slice
	    rMax = radius;
	  } else {
	    rMax = Math.max(ryMin, ryMax);
	  }

	  return [rMin, rMax];
	}

	/**
	 * VoxelWorld constructor
	 *
	 * @param {Box3} box - bounding box of the volume to be partitioned
	 * @param {Vector3} vCellSizeHint - target voxel size (actual voxel size may differ from this)
	 */
	function VoxelWorld(box, vCellSizeHint) {
	  var i;

	  this._box = box.clone();
	  var size = new Vector3();
	  box.getSize(size);
	  this._count = size.clone().divide(vCellSizeHint).floor();
	  this._last = this._count.clone().subScalar(1);
	  this._cellSize = size.clone().divide(this._count);
	  this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
	  this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize));

	  // array of voxels, each element contains index of first atom in voxel
	  var numVoxels = this._count.x * this._count.y * this._count.z;
	  this._voxels = utils.allocateTyped(Int32Array, numVoxels);
	  for (i = 0; i < numVoxels; ++i) {
	    this._voxels[i] = -1;
	  }

	  // array of atoms that stores multiple single-linked lists
	  // two elements for each atom: Atom ref, index of next atom (in this array
	  this._atoms = [];
	}

	/**
	 * Add all atoms from a complex to voxel world
	 *
	 * @param {Complex} complex - complex
	 */
	VoxelWorld.prototype.addAtoms = function (complex) {
	  var self = this;

	  var idx = this._atoms.length;

	  // resize array of atoms
	  this._atoms.length = this._atoms.length + 2 * complex.getAtomCount();

	  complex.forEachAtom(function (atom) {
	    // find which voxel contains this atom
	    var voxelIdx = self._findVoxel(atom._position);

	    // push current atom to the head of voxel's atom list
	    self._atoms[idx] = atom;
	    self._atoms[idx + 1] = self._voxels[voxelIdx];
	    self._voxels[voxelIdx] = idx;

	    idx += 2;
	  });
	};

	/**
	 * Get voxel that contains specified 3D point (we use clamp at the edges)
	 *
	 * @param {Vector3} point - a point in 3D
	 * @returns {number} - index of voxel
	 */
	VoxelWorld.prototype._findVoxel = function () {
	  var zero = new Vector3(0, 0, 0);
	  var voxel = new Vector3();

	  return function (point) {
	    voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
	    return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
	  };
	}();

	/**
	 * Call a function for each atom in voxel
	 *
	 * @param {number} voxel - index of voxel
	 * @param {function(Atom)} process - function to call
	 */
	VoxelWorld.prototype._forEachAtomInVoxel = function (voxel, process) {
	  for (var i = this._voxels[voxel]; i >= 0; i = this._atoms[i + 1]) {
	    process(this._atoms[i]);
	  }
	};

	/**
	 * Call a function for each voxel that is touched by given sphere. Callback also takes flag
	 * isInside specifying whether voxel lies inside the sphere entirely.
	 *
	 * @param {Vector3} center - center of the sphere
	 * @param {number} radius  - sphere radius
	 * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
	 */
	VoxelWorld.prototype._forEachVoxelWithinRadius = function () {
	  var xRange = new Vector2();
	  var yRange = new Vector2();
	  var zRange = new Vector2();

	  return function (center, radius, process) {
	    // switch to a faster method unless cell size is much smaller than sphere radius
	    if (radius / this._cellInnerR < 10) {
	      this._forEachVoxelWithinRadiusSimple(center, radius, process);
	      return;
	    }

	    var rRangeXY = void 0,
	        rRangeX = void 0,
	        xVal = void 0,
	        yVal = void 0,
	        zVal = void 0,
	        isInsideX = void 0,
	        isInsideY = void 0,
	        isInsideZ = void 0;

	    zRange.set(center.z - radius, center.z + radius);
	    zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);

	    for (var z = zRange.x; z <= zRange.y; ++z) {
	      zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];

	      isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;

	      rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);

	      yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
	      yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);

	      for (var y = yRange.x; y <= yRange.y; ++y) {
	        yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];

	        isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];

	        rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);

	        xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
	        xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);

	        for (var x = xRange.x; x <= xRange.y; ++x) {
	          xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
	          isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];

	          process(x + this._count.x * (y + this._count.y * z), isInsideX && isInsideY && isInsideZ);
	        }
	      }
	    }
	  };
	}();

	/**
	 * Call a function for each voxel that is touched by given sphere. Callback also takes flag
	 * isInside specifying whether voxel lies inside the sphere entirely.
	 * This is a version of method that doesn't try to "calculate" what voxels fall inside radius
	 * but instead just checks all voxels inside sphere's bounding box. This should be faster
	 * unless cell size is much smaller than sphere radius.
	 *
	 * @param {Vector3} center - center of the sphere
	 * @param {number} radius  - sphere radius
	 * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
	 */
	VoxelWorld.prototype._forEachVoxelWithinRadiusSimple = function () {
	  var xRange = new Vector2();
	  var yRange = new Vector2();
	  var zRange = new Vector2();
	  var vCenter = new Vector3();

	  return function (center, radius, process) {
	    var distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
	    var distInside2 = -1.0;
	    if (radius > this._cellOuterR) {
	      distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
	    }

	    // calculate bounding box for the sphere
	    xRange.set(center.x - radius, center.x + radius);
	    xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
	    xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
	    xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);

	    yRange.set(center.y - radius, center.y + radius);
	    yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
	    yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
	    yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);

	    zRange.set(center.z - radius, center.z + radius);
	    zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
	    zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
	    zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);

	    for (var z = zRange.x; z <= zRange.y; ++z) {
	      var zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
	      vCenter.z = 0.5 * (zVal[0] + zVal[1]);

	      for (var y = yRange.x; y <= yRange.y; ++y) {
	        var yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
	        vCenter.y = 0.5 * (yVal[0] + yVal[1]);

	        for (var x = xRange.x; x <= xRange.y; ++x) {
	          var xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
	          vCenter.x = 0.5 * (xVal[0] + xVal[1]);

	          var d2 = center.distanceToSquared(vCenter);
	          if (d2 <= distTouch2) {
	            process(x + this._count.x * (y + this._count.y * z), d2 <= distInside2);
	          }
	        }
	      }
	    }
	  };
	}();

	/**
	 * Call a function for each atom within given sphere
	 *
	 * @param {Vector3} center - center of the sphere
	 * @param {number} radius  - sphere radius
	 * @param {function(Atom)} process - function to call
	 */
	VoxelWorld.prototype.forEachAtomWithinRadius = function (center, radius, process) {
	  var self = this;
	  var r2 = radius * radius;

	  self._forEachVoxelWithinRadius(center, radius, function (voxel, isInside) {
	    if (isInside) {
	      self._forEachAtomInVoxel(voxel, process);
	    } else {
	      self._forEachAtomInVoxel(voxel, function (atom) {
	        if (center.distanceToSquared(atom._position) <= r2) {
	          process(atom);
	        }
	      });
	    }
	  });
	};

	/**
	 * Call a function for each atom of given complex within given distance from group of atoms defined by mask
	 *
	 * @param {Complex} complex - complex
	 * @param {number} mask - bit mask
	 * @param {number} dist - distance
	 * @param {function(Atom)} process - function to call
	 */
	VoxelWorld.prototype.forEachAtomWithinDistFromMasked = function (complex, mask, dist, process) {
	  this._forEachAtomWithinDistFromGroup(function (atomProc) {
	    complex.forEachAtom(function (atom) {
	      if ((atom._mask & mask) !== 0) {
	        atomProc(atom);
	      }
	    });
	  }, dist, process);
	};

	/**
	 * Call a function for each atom of given complex within given distance from group of atoms defined by selector
	 *
	 * @param {Complex} complex - complex
	 * @param {number} selector - selector
	 * @param {number} dist - distance
	 * @param {function(Atom)} process - function to call
	 */
	VoxelWorld.prototype.forEachAtomWithinDistFromSelected = function (complex, selector, dist, process) {
	  this._forEachAtomWithinDistFromGroup(function (atomProc) {
	    complex.forEachAtom(function (atom) {
	      if (selector.includesAtom(atom)) {
	        atomProc(atom);
	      }
	    });
	  }, dist, process);
	};

	/**
	 * Call a function for each atom of given complex within given distance from group of atoms
	 *
	 * @param {function} forEachAtom - enumerator of atoms in the group
	 * @param {number} dist - distance
	 * @param {function(Atom)} process - function to call
	 */
	VoxelWorld.prototype._forEachAtomWithinDistFromGroup = function (forEachAtom, dist, process) {
	  var self = this;
	  var r2 = dist * dist;

	  var voxels = [];
	  var atoms = [];
	  var idx = 0;

	  // build "within radius" atom list for each voxel
	  forEachAtom(function (atom) {
	    self._forEachVoxelWithinRadius(atom._position, dist, function (voxel, isInside) {
	      if (isInside) {
	        // this voxel is inside circle -- no check will be required
	        voxels[voxel] = -1;
	      } else if (typeof voxels[voxel] === 'undefined') {
	        // this voxel isn't covered yet -- start building list of atoms
	        atoms.push(atom);
	        atoms.push(-1);
	        voxels[voxel] = idx;
	        idx += 2;
	      } else if (voxels[voxel] !== -1) {
	        // this voxel has a list of atoms required for distance check -- add atom to the list
	        atoms.push(atom);
	        atoms.push(voxels[voxel]);
	        voxels[voxel] = idx;
	        idx += 2;
	      }
	    });
	  });

	  var voxel;

	  var processIfWithin = function processIfWithin(atom) {
	    if (typeof voxels[voxel] === 'undefined') {
	      return;
	    }

	    idx = voxels[voxel];
	    if (idx === -1) {
	      // this voxel is fully covered
	      process(atom);
	      return;
	    }

	    // check distance to each atom within radius from this voxel
	    for (; idx >= 0; idx = atoms[idx + 1]) {
	      if (atom._position.distanceToSquared(atoms[idx]._position) < r2) {
	        process(atom);
	        break;
	      }
	    }
	  };

	  // for each marked voxel
	  for (voxel in voxels) {
	    if (voxels.hasOwnProperty(voxel)) {
	      self._forEachAtomInVoxel(voxel, processIfWithin);
	    }
	  }
	};

	var MINIMAL_DISTANCE = 0.5;
	var MIN_HBOND_ENERGY = -9.9;
	var MAX_HBOND_ENERGY = -0.5;
	var COUPLING_CONSTANT = -27.888; // = -332 * 0.42 * 0.2
	var MAX_COUPLING_DISTANCE = 5.0; // how far is the closest atom of a potential partner residue from CA atom
	var MAX_RESIDUES_THRESHOLD = 1000;

	var HBondInfo = function () {
	  function HBondInfo(complex) {
	    classCallCheck(this, HBondInfo);

	    this._complex = complex;
	    this._hbonds = []; // array of bond info for each residue
	    if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
	      this._buildVW(); // optimized version using voxel grid
	    } else {
	      this._build(); // test all pairs of residues
	    }
	  }

	  createClass(HBondInfo, [{
	    key: 'isBond',
	    value: function isBond(from, to) {
	      if (this._hbonds[from]) {
	        var acc = this._hbonds[from].acceptor[0];
	        if (acc && acc.residue === to && acc.energy < MAX_HBOND_ENERGY) {
	          return true;
	        }
	        acc = this._hbonds[from].acceptor[1];
	        if (acc && acc.residue === to && acc.energy < MAX_HBOND_ENERGY) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }, {
	    key: '_build',
	    value: function _build() {
	      var self = this;

	      // TODO Replace quadratic algorithm with something better (use voxel grid?)
	      for (var i = 0; i < this._complex._residues.length - 1; ++i) {
	        var ri = this._complex._residues[i];
	        if ((ri.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
	          continue;
	        }

	        // get predecessor in chain
	        var preri = null;
	        if (i > 0 && this._complex._residues[i - 1].getType().flags & ResidueType.Flags.PROTEIN && ri._sequence === this._complex._residues[i - 1]._sequence + 1) {
	          preri = this._complex._residues[i - 1];
	        }

	        for (var j = i + 1; j < this._complex._residues.length; ++j) {
	          var rj = this._complex._residues[j];
	          if ((rj.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
	            continue;
	          }

	          // get predecessor in chain
	          var prerj = null;
	          if (this._complex._residues[j - 1].getType().flags & ResidueType.Flags.PROTEIN && rj._sequence === this._complex._residues[j - 1]._sequence + 1) {
	            prerj = this._complex._residues[j - 1];
	          }

	          self._calcHBondEnergy(preri, ri, rj);
	          if (j !== i + 1) {
	            self._calcHBondEnergy(prerj, rj, ri);
	          }
	        }
	      }
	    }
	  }, {
	    key: '_buildVW',
	    value: function _buildVW() {
	      var self = this;
	      var residues = this._complex._residues;
	      var ri = void 0,
	          preri = void 0;

	      var vw = this._complex.getVoxelWorld();
	      if (vw === null) {
	        return;
	      }

	      var pairs = new AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);

	      function processAtom(atom) {
	        var rj = atom._residue;

	        if (rj._index === ri._index) {
	          return;
	        }

	        if ((rj.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
	          return;
	        }

	        if (!pairs.addPair(ri._index, rj._index)) {
	          // we've seen this pair
	          return;
	        }

	        // get predecessor in chain
	        var prerj = rj._index > 0 ? residues[rj._index - 1] : null;
	        if (prerj && ((prerj.getType().flags & ResidueType.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
	          prerj = null;
	        }

	        self._calcHBondEnergy(preri, ri, rj);
	        if (rj._index !== ri._index + 1) {
	          self._calcHBondEnergy(prerj, rj, ri);
	        }
	      }

	      for (var i = 0; i < residues.length - 1; ++i) {
	        ri = residues[i];
	        if ((ri.getType().flags & ResidueType.Flags.PROTEIN) === 0) {
	          continue;
	        }

	        // get predecessor in chain
	        preri = i > 0 ? residues[i - 1] : null;
	        if (preri && ((preri.getType().flags & ResidueType.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
	          preri = null;
	        }

	        vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
	      }
	    }
	  }, {
	    key: '_residueGetCAlpha',
	    value: function _residueGetCAlpha(res) {
	      for (var i = 0; i < res._atoms.length; ++i) {
	        var name = res._atoms[i].getName().getString();
	        if (name === 'CA' || name === 'C1') {
	          return res._atoms[i].getPosition();
	        }
	      }

	      return null;
	    }
	  }, {
	    key: '_residueGetCO',
	    value: function _residueGetCO(res) {
	      var c = null,
	          o = null;

	      res.forEachAtom(function (a) {
	        if (a.getName().getString() === 'C') {
	          c = a.getPosition();
	        } else if (a.getName().getString() === 'O') {
	          o = a.getPosition();
	        }
	      });

	      return [c, o];
	    }

	    // TODO Support hydrogen defined in complex

	  }, {
	    key: '_residueGetNH',
	    value: function _residueGetNH(prev, res) {
	      var _residueGetCO2 = this._residueGetCO(prev),
	          _residueGetCO3 = slicedToArray(_residueGetCO2, 2),
	          c = _residueGetCO3[0],
	          o = _residueGetCO3[1];

	      var n = void 0;
	      res.forEachAtom(function (a) {
	        if (a.getName().getString() === 'N') {
	          n = a.getPosition();
	        }
	      });

	      if (c && o && n) {
	        // calculate hydrogen position
	        var h = c.clone();
	        h.sub(o);
	        h.multiplyScalar(1.0 / h.length());
	        h.add(n);

	        return [n, h];
	      }

	      return [null, null];
	    }
	  }, {
	    key: '_calcHBondEnergy',
	    value: function _calcHBondEnergy(predonor, donor, acceptor) {
	      var result = 0;

	      if (predonor === null) {
	        return result;
	      }

	      if (donor.getType().getName() !== 'PRO') {
	        var _residueGetNH2 = this._residueGetNH(predonor, donor),
	            _residueGetNH3 = slicedToArray(_residueGetNH2, 2),
	            n = _residueGetNH3[0],
	            h = _residueGetNH3[1];

	        var _residueGetCO4 = this._residueGetCO(acceptor),
	            _residueGetCO5 = slicedToArray(_residueGetCO4, 2),
	            c = _residueGetCO5[0],
	            o = _residueGetCO5[1];

	        if (n === null || h === null || c === null || o === null) {
	          return result;
	        }

	        var distanceHO = h.distanceTo(o);
	        var distanceHC = h.distanceTo(c);
	        var distanceNC = n.distanceTo(c);
	        var distanceNO = n.distanceTo(o);

	        if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
	          result = MIN_HBOND_ENERGY;
	        } else {
	          result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
	        }

	        // DSSP compatibility mode:
	        result = Math.round(result * 1000) / 1000;

	        if (result < MIN_HBOND_ENERGY) {
	          result = MIN_HBOND_ENERGY;
	        }
	      }

	      // update donor
	      if (typeof this._hbonds[donor._index] === 'undefined') {
	        this._hbonds[donor._index] = {
	          donor: [],
	          acceptor: []
	        };
	      }
	      var donorInfo = this._hbonds[donor._index];

	      if (donorInfo.acceptor.length < 2) {
	        donorInfo.acceptor.push({
	          residue: acceptor._index,
	          energy: result
	        });
	      }

	      if (donorInfo.acceptor.length > 1) {
	        if (result < donorInfo.acceptor[0].energy) {
	          donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
	          donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
	          donorInfo.acceptor[0].residue = acceptor._index;
	          donorInfo.acceptor[0].energy = result;
	        } else if (result < donorInfo.acceptor[1].energy) {
	          donorInfo.acceptor[1].residue = acceptor._index;
	          donorInfo.acceptor[1].energy = result;
	        }
	      }

	      // update acceptor
	      if (typeof this._hbonds[acceptor._index] === 'undefined') {
	        this._hbonds[acceptor._index] = {
	          donor: [],
	          acceptor: []
	        };
	      }
	      var accInfo = this._hbonds[acceptor._index];

	      if (accInfo.donor.length < 2) {
	        accInfo.donor.push({
	          residue: donor._index,
	          energy: result
	        });
	      }

	      if (accInfo.donor.length > 1) {
	        if (result < accInfo.donor[0].energy) {
	          accInfo.donor[1].residue = accInfo.donor[0].residue;
	          accInfo.donor[1].energy = accInfo.donor[0].energy;
	          accInfo.donor[0].residue = donor._index;
	          accInfo.donor[0].energy = result;
	        } else if (result < accInfo.donor[1].energy) {
	          accInfo.donor[1].residue = donor._index;
	          accInfo.donor[1].energy = result;
	        }
	      }

	      return result;
	    }
	  }]);
	  return HBondInfo;
	}();

	var BridgeType = Object.freeze({
	  NO_BRIDGE: 0,
	  PARALLEL: 1,
	  ANTI_PARALLEL: 2
	});

	var HelixFlag = Object.freeze({
	  START: 1,
	  MIDDLE: 2,
	  END: 3,
	  START_AND_END: 4
	});

	var StructureType = Object.freeze({
	  STRAND: 'E',
	  BRIDGE: 'B',
	  HELIX_310: 'G',
	  HELIX_ALPHA: 'H',
	  HELIX_PI: 'I',
	  TURN: 'T',
	  BEND: 'S',
	  LOOP: ' '
	});

	var SecondaryStructureMap = function () {
	  function SecondaryStructureMap(complex) {
	    classCallCheck(this, SecondaryStructureMap);

	    this._complex = complex;
	    this._build();
	  }

	  createClass(SecondaryStructureMap, [{
	    key: '_build',
	    value: function _build() {
	      var self = this;
	      this._hbonds = new HBondInfo(this._complex);
	      this._ss = []; // DSSP map by residue

	      // auxilliary data
	      this._sheet = [];
	      this._betaPartners = [];
	      this._bend = [];
	      for (var i = 0; i < this._complex.getResidues().length; ++i) {
	        this._betaPartners[i] = [];
	      }
	      this._helixFlags = [];
	      this._helixFlags[3] = [];
	      this._helixFlags[4] = [];
	      this._helixFlags[5] = [];

	      // calculate peptide chain lengths
	      this._chainLengths = [];
	      for (var _i = 0; _i < this._complex._chains.length; ++_i) {
	        var chain = this._complex._chains[_i].getResidues();
	        var len = 0;
	        for (; len < chain.length; ++len) {
	          if ((chain[len].getType().flags & ResidueType.Flags.PROTEIN) === 0) {
	            break;
	          }
	        }
	        this._chainLengths[_i] = len;
	      }

	      this._buildBetaSheets();

	      for (var _i2 = 0; _i2 < this._complex._chains.length; ++_i2) {
	        self._buildAlphaHelices(this._complex._chains[_i2].getResidues(), this._chainLengths[_i2], false);
	      }
	    }
	  }, {
	    key: '_buildAlphaHelices',
	    value: function _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
	      // Helix and Turn
	      for (var stride = 3; stride <= 5; ++stride) {
	        if (inResidues.length < stride) {
	          break;
	        }

	        for (var i = 0; i + stride < chainLength; ++i) {
	          if (this._hbonds.isBond(inResidues[i + stride]._index, inResidues[i]._index)
	          /*&& NoChainBreak(res[i], res[i + stride])*/) {
	              this._helixFlags[stride][inResidues[i + stride]._index] = HelixFlag.END;
	              for (var j = i + 1; j < i + stride; ++j) {
	                if (typeof this._helixFlags[stride][inResidues[j]._index] === 'undefined') {
	                  this._helixFlags[stride][inResidues[j]._index] = HelixFlag.MIDDLE;
	                }
	              }

	              if (this._helixFlags[stride][inResidues[i]._index] === HelixFlag.END) {
	                this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START_AND_END;
	              } else {
	                this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START;
	              }
	            }
	        }
	      }

	      for (var _i3 = 2; _i3 < chainLength - 2; ++_i3) {
	        var kappa = this._kappa(inResidues[_i3 - 2], inResidues[_i3], inResidues[_i3 + 2]);
	        this._bend[inResidues[_i3]._index] = kappa !== 360 && kappa > 70;
	      }

	      for (var _i4 = 1; _i4 + 4 < chainLength; ++_i4) {
	        if (this._isHelixStart(inResidues[_i4]._index, 4) && this._isHelixStart(inResidues[_i4 - 1]._index, 4)) {
	          for (var _j = _i4; _j <= _i4 + 3; ++_j) {
	            this._ss[inResidues[_j]._index] = StructureType.HELIX_ALPHA;
	          }
	        }
	      }

	      for (var _i5 = 1; _i5 + 3 < chainLength; ++_i5) {
	        if (this._isHelixStart(inResidues[_i5]._index, 3) && this._isHelixStart(inResidues[_i5 - 1]._index, 3)) {
	          var empty = true;
	          for (var _j2 = _i5; empty && _j2 <= _i5 + 2; ++_j2) {
	            empty = typeof this._ss[inResidues[_j2]._index] === 'undefined' || this._ss[inResidues[_j2]._index] === StructureType.HELIX_310;
	          }
	          if (empty) {
	            for (var _j3 = _i5; _j3 <= _i5 + 2; ++_j3) {
	              this._ss[inResidues[_j3]._index] = StructureType.HELIX_310;
	            }
	          }
	        }
	      }

	      for (var _i6 = 1; _i6 + 5 < chainLength; ++_i6) {
	        if (this._isHelixStart(inResidues[_i6]._index, 5) && this._isHelixStart(inResidues[_i6 - 1]._index, 5)) {
	          var _empty = true;
	          for (var _j4 = _i6; _empty && _j4 <= _i6 + 4; ++_j4) {
	            _empty = typeof this._ss[inResidues[_j4]._index] === 'undefined' || this._ss[inResidues[_j4]._index] === StructureType.HELIX_PI || inPreferPiHelices && this._ss[inResidues[_j4]._index] === StructureType.HELIX_ALPHA;
	          }
	          if (_empty) {
	            for (var _j5 = _i6; _j5 <= _i6 + 4; ++_j5) {
	              this._ss[inResidues[_j5]._index] = StructureType.HELIX_PI;
	            }
	          }
	        }
	      }

	      for (var _i7 = 1; _i7 + 1 < chainLength; ++_i7) {
	        if (typeof this._ss[inResidues[_i7]._index] === 'undefined') {
	          var isTurn = false;
	          for (var _stride = 3; _stride <= 5 && !isTurn; ++_stride) {
	            for (var k = 1; k < _stride && !isTurn; ++k) {
	              isTurn = _i7 >= k && this._isHelixStart(inResidues[_i7 - k]._index, _stride);
	            }
	          }

	          if (isTurn) {
	            this._ss[inResidues[_i7]._index] = StructureType.TURN;
	          } else if (this._bend[inResidues[_i7]._index]) {
	            this._ss[inResidues[_i7]._index] = StructureType.BEND;
	          }
	        }
	      }
	    }
	  }, {
	    key: '_residueGetCAlpha',
	    value: function _residueGetCAlpha(res) {
	      for (var i = 0; i < res._atoms.length; ++i) {
	        var name = res._atoms[i].getName().getString();
	        if (name === 'CA' || name === 'C1') {
	          return res._atoms[i].getPosition();
	        }
	      }

	      return null;
	    }
	  }, {
	    key: '_cosinusAngle',
	    value: function _cosinusAngle(p1, p2, p3, p4) {
	      var v12 = p1.clone();v12.sub(p2);
	      var v34 = p3.clone();v34.sub(p4);

	      var result = 0;

	      var x = v12.dot(v12) * v34.dot(v34);
	      if (x > 0) {
	        result = v12.dot(v34) / Math.sqrt(x);
	      }

	      return result;
	    }
	  }, {
	    key: '_kappa',
	    value: function _kappa(prevPrev, res, nextNext) {
	      var curCA = this._residueGetCAlpha(res);
	      var ppCA = this._residueGetCAlpha(prevPrev);
	      var nnCA = this._residueGetCAlpha(nextNext);
	      if (curCA === null || ppCA === null || nnCA === null) {
	        return 180;
	      }

	      var ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);
	      var skap = Math.sqrt(1 - ckap * ckap);
	      return Math.atan2(skap, ckap) * 180 / Math.PI;
	    }
	  }, {
	    key: '_isHelixStart',
	    value: function _isHelixStart(res, stride) {
	      return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
	    }
	  }, {
	    key: '_buildBetaSheets',
	    value: function _buildBetaSheets() {
	      // find bridges
	      // check each chain against each other chain, and against itself
	      var bridges = [];
	      for (var a = 0; a < this._complex._chains.length; ++a) {
	        var lenA = this._chainLengths[a];
	        if (lenA <= 4) {
	          continue;
	        }

	        var chainA = this._complex._chains[a].getResidues();

	        for (var b = a; b < this._complex._chains.length; ++b) {
	          var lenB = this._chainLengths[b];
	          if (lenB <= 4) {
	            continue;
	          }

	          var chainB = this._complex._chains[b].getResidues();

	          for (var i = 1; i + 1 < lenA; ++i) {
	            var ri = chainA[i];

	            var j = 1;
	            if (b === a) {
	              j = i + 3; // check for self-bridges forward down the chain
	            }

	            for (; j + 1 < lenB; ++j) {
	              var rj = chainB[j];

	              var type = this._testBridge(chainA, i, chainB, j);
	              if (type === BridgeType.NO_BRIDGE) {
	                continue;
	              }

	              // there is a bridge, try to attach it to previously found sequence
	              var found = false;
	              var _iteratorNormalCompletion = true;
	              var _didIteratorError = false;
	              var _iteratorError = undefined;

	              try {
	                for (var _iterator = bridges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                  var bridge = _step.value;

	                  if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
	                    continue;
	                  }

	                  if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
	                    bridge.i.push(ri._index);
	                    bridge.j.push(rj._index);
	                    found = true;
	                    break;
	                  }

	                  if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
	                    bridge.i.push(ri._index);
	                    bridge.j.unshift(rj._index);
	                    found = true;
	                    break;
	                  }
	                }

	                // this bridge cannot be attached anywhere, start a new sequence
	              } catch (err) {
	                _didIteratorError = true;
	                _iteratorError = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion && _iterator.return) {
	                    _iterator.return();
	                  }
	                } finally {
	                  if (_didIteratorError) {
	                    throw _iteratorError;
	                  }
	                }
	              }

	              if (!found) {
	                bridges.push({
	                  type: type,
	                  i: [ri._index],
	                  chainI: ri.getChain()._index,
	                  j: [rj._index],
	                  chainJ: rj.getChain()._index
	                });
	              }
	            }
	          }
	        }
	      }

	      // extend ladders
	      bridges.sort(function (a, b) {
	        if (a.chainI < b.chainI || a.chainI === b.chainI && a.i[0] < b.i[0]) {
	          return -1;
	        }
	        return 1;
	      });

	      for (var _i8 = 0; _i8 < bridges.length; ++_i8) {
	        for (var _j6 = _i8 + 1; _j6 < bridges.length; ++_j6) {
	          var ibi = bridges[_i8].i[0];
	          var iei = bridges[_i8].i[bridges[_i8].i.length - 1];
	          var jbi = bridges[_i8].j[0];
	          var jei = bridges[_i8].j[bridges[_i8].j.length - 1];
	          var ibj = bridges[_j6].i[0];
	          var iej = bridges[_j6].i[bridges[_j6].i.length - 1];
	          var jbj = bridges[_j6].j[0];
	          var jej = bridges[_j6].j[bridges[_j6].j.length - 1];

	          if (bridges[_i8].type !== bridges[_j6].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
	            continue;
	          }

	          var bulge = false;
	          if (bridges[_i8].type === BridgeType.PARALLEL) {
	            bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
	          } else {
	            bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
	          }

	          if (bulge) {
	            bridges[_i8].i = bridges[_i8].i.concat(bridges[_j6].i);
	            if (bridges[_i8].type === BridgeType.PARALLEL) {
	              bridges[_i8].j = bridges[_i8].j.concat(bridges[_j6].j);
	            } else {
	              bridges[_i8].j = bridges[_j6].j.concat(bridges[_i8].j);
	            }
	            bridges.splice(_j6--, 1);
	          }
	        }
	      }

	      // Sheet
	      var ladderset = new Set();
	      for (var _i9 = 0; _i9 < bridges.length; ++_i9) {
	        ladderset.add(bridges[_i9]);
	      }

	      var sheet = 1,
	          ladder = 0;
	      while (ladderset.size > 0) {
	        var _bridge = ladderset.values().next().value;
	        ladderset.delete(_bridge);

	        var sheetset = new Set();
	        sheetset.add(_bridge);

	        var toMove = void 0;
	        do {
	          toMove = new Set();
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;

	          try {
	            for (var _iterator2 = sheetset.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var _a = _step2.value;
	              var _iteratorNormalCompletion4 = true;
	              var _didIteratorError4 = false;
	              var _iteratorError4 = undefined;

	              try {
	                for (var _iterator4 = ladderset.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	                  var _b = _step4.value;

	                  if (this._areBridgesLinked(_a, _b)) {
	                    toMove.add(_b);
	                  }
	                }
	              } catch (err) {
	                _didIteratorError4 = true;
	                _iteratorError4 = err;
	              } finally {
	                try {
	                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
	                    _iterator4.return();
	                  }
	                } finally {
	                  if (_didIteratorError4) {
	                    throw _iteratorError4;
	                  }
	                }
	              }
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }

	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;

	          try {
	            for (var _iterator3 = toMove.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              _bridge = _step3.value;

	              sheetset.add(_bridge);
	              ladderset.delete(_bridge);
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }
	        } while (toMove.size > 0);

	        var _iteratorNormalCompletion5 = true;
	        var _didIteratorError5 = false;
	        var _iteratorError5 = undefined;

	        try {
	          for (var _iterator5 = sheetset.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	            _bridge = _step5.value;

	            _bridge.ladder = ladder;
	            _bridge.sheet = sheet;
	            _bridge.link = sheetset;
	            ++ladder;
	          }
	        } catch (err) {
	          _didIteratorError5 = true;
	          _iteratorError5 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion5 && _iterator5.return) {
	              _iterator5.return();
	            }
	          } finally {
	            if (_didIteratorError5) {
	              throw _iteratorError5;
	            }
	          }
	        }

	        ++sheet;
	      }

	      for (var _i10 = 0; _i10 < bridges.length; ++_i10) {
	        var _bridge2 = bridges[_i10];

	        // find out if any of the i and j set members already have
	        // a bridge assigned, if so, we're assigning bridge 2

	        var betai = 0,
	            betaj = 0;

	        for (var l = 0; l < _bridge2.i.length; ++l) {
	          if (this._betaPartners[_bridge2.i[l]][0]) {
	            betai = 1;
	            break;
	          }
	        }

	        for (var _l = 0; _l < _bridge2.j.length; ++_l) {
	          if (this._betaPartners[_bridge2.j[_l]][0]) {
	            betaj = 1;
	            break;
	          }
	        }

	        var ss = StructureType.BRIDGE;
	        if (_bridge2.i.length > 1) {
	          ss = StructureType.STRAND;
	        }

	        if (_bridge2.type === BridgeType.PARALLEL) {
	          var _j7 = 0;
	          for (var k = 0; k < _bridge2.i.length; ++k) {
	            this._betaPartners[_bridge2.i[k]][betai] = {
	              residue: _bridge2.j[_j7++],
	              ladder: _bridge2.ladder,
	              parallel: true
	            };
	          }

	          _j7 = 0;
	          for (var _k = 0; _k < _bridge2.j.length; ++_k) {
	            this._betaPartners[_bridge2.j[_k]][betaj] = {
	              residue: _bridge2.i[_j7++],
	              ladder: _bridge2.ladder,
	              parallel: true
	            };
	          }
	        } else {
	          var _j8 = _bridge2.j.length - 1;
	          for (var _k2 = 0; _k2 < _bridge2.i.length; ++_k2) {
	            this._betaPartners[_bridge2.i[_k2]][betai] = {
	              residue: _bridge2.j[_j8--],
	              ladder: _bridge2.ladder,
	              parallel: false
	            };
	          }

	          _j8 = _bridge2.i.length - 1;
	          for (var _k3 = 0; _k3 < _bridge2.j.length; ++_k3) {
	            this._betaPartners[_bridge2.j[_k3]][betaj] = {
	              residue: _bridge2.i[_j8--],
	              ladder: _bridge2.ladder,
	              parallel: false
	            };
	          }
	        }

	        for (var _k4 = _bridge2.i[0]; _k4 <= _bridge2.i[_bridge2.i.length - 1]; ++_k4) {
	          if (this._ss[_k4] !== StructureType.STRAND) {
	            this._ss[_k4] = ss;
	            this._sheet[_k4] = _bridge2.sheet;
	          }
	        }

	        for (var _k5 = _bridge2.j[0]; _k5 <= _bridge2.j[_bridge2.j.length - 1]; ++_k5) {
	          if (this._ss[_k5] !== StructureType.STRAND) {
	            this._ss[_k5] = ss;
	            this._sheet[_k5] = _bridge2.sheet;
	          }
	        }
	      }
	    }
	  }, {
	    key: '_testBridge',
	    value: function _testBridge(chainA, from, chainB, to) {
	      var result = BridgeType.NO_BRIDGE;

	      var a = chainA[from - 1]._index;
	      var b = chainA[from]._index;
	      var c = chainA[from + 1]._index;
	      var d = chainB[to - 1]._index;
	      var e = chainB[to]._index;
	      var f = chainB[to + 1]._index;

	      var isBond = this._hbonds.isBond.bind(this._hbonds);
	      if (isBond(c, e) && isBond(e, a) || isBond(f, b) && isBond(b, d)) {
	        result = BridgeType.PARALLEL;
	      } else if (isBond(c, d) && isBond(f, a) || isBond(e, b) && isBond(b, e)) {
	        result = BridgeType.ANTI_PARALLEL;
	      }
	      return result;
	    }

	    // return true if any of the residues in bridge a is identical to any of the residues in bridge b
	    // TODO Optimize

	  }, {
	    key: '_areBridgesLinked',
	    value: function _areBridgesLinked(a, b) {
	      var ai = new Set(a.i);
	      var aj = new Set(a.j);

	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;

	      try {
	        for (var _iterator6 = b.i[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var i = _step6.value;

	          if (ai.has(i) || aj.has(i)) {
	            return true;
	          }
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }

	      var _iteratorNormalCompletion7 = true;
	      var _didIteratorError7 = false;
	      var _iteratorError7 = undefined;

	      try {
	        for (var _iterator7 = b.j[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	          var _i11 = _step7.value;

	          if (ai.has(_i11) || aj.has(_i11)) {
	            return true;
	          }
	        }
	      } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion7 && _iterator7.return) {
	            _iterator7.return();
	          }
	        } finally {
	          if (_didIteratorError7) {
	            throw _iteratorError7;
	          }
	        }
	      }

	      return false;
	    }
	  }, {
	    key: '_hasChainBreak',
	    value: function _hasChainBreak(from, to) {
	      for (var i = from + 1; i <= to; ++i) {
	        if (this._complex._residues[i]._sequence !== this._complex._residues[i - 1]._sequence + 1) {
	          return true;
	        }
	      }
	      return false;
	    }
	  }]);
	  return SecondaryStructureMap;
	}();


	SecondaryStructureMap.StructureType = StructureType;

	var _helixClassMap, _loopMap;

	var VOXEL_SIZE = 5.0;

	/**
	 * The entire complex of the molecules under study.
	 *
	 * @exports Complex
	 * @constructor
	 */
	function Complex() {
	  this._chains = [];
	  this._components = [];
	  this._helices = [];
	  this._sheets = [];
	  this.structures = [];

	  this._residueTypes = Object.create(ResidueType.StandardTypes);
	  this._atoms = []; // TODO: preallocate
	  this._residues = []; // TODO: preallocate
	  this._bonds = []; // TODO: preallocate
	  this._sgroups = [];
	  this._molecules = [];
	  this._maskNeedsUpdate = false;

	  this.metadata = {};

	  this.symmetry = [];
	  this.units = [new BiologicalUnit(this)];
	  this._currentUnit = 0; // default biological unit is the asymmetric unit
	}

	utils.deriveClass(Complex, DataSource, {
	  id: 'Complex'
	});

	Complex.prototype.name = '';

	Complex.prototype.addAtom = function (atom) {
	  var index = this._atoms.length;
	  this._atoms.push(atom);
	  return index;
	};

	Complex.prototype.addSheet = function (sheet) {
	  var index = this._sheets.length;
	  this._sheets.push(sheet);
	  return index;
	};

	Complex.prototype.addHelix = function (helix) {
	  var index = this._helices.length;
	  this._helices.push(helix);
	  return index;
	};

	Complex.prototype.getAtoms = function () {
	  return this._atoms;
	};

	Complex.prototype.getBonds = function () {
	  return this._bonds;
	};

	Complex.prototype.getAtomCount = function () {
	  return this._atoms.length;
	};

	Complex.prototype.addResidue = function (residue) {
	  var index = this._residues.length;
	  this._residues.push(residue);
	  return index;
	};

	Complex.prototype.updateToFrame = function (frameData) {
	  this.forEachChain(function (chain) {
	    chain.updateToFrame(frameData);
	  });
	};

	Complex.prototype.addResidueType = function (resName) {
	  var rt = this._residueTypes[resName] = new ResidueType(resName, 'Unknown', '');
	  return rt;
	};

	Complex.prototype.getResidueCount = function () {
	  return this._residues.length;
	};

	Complex.prototype.getResidues = function () {
	  return this._residues;
	};

	Complex.prototype.getSGroupCount = function () {
	  return this._sgroups.length;
	};

	Complex.prototype.getSGroups = function () {
	  return this._sgroups;
	};

	/*
	   Extract atom by its fullname: #chainName#.#residueId#.#atomName#
	   */
	Complex.prototype.getAtomByFullname = function (fullName) {
	  var parts = fullName.split('.');
	  if (parts.length !== 3) {
	    return null;
	  }

	  var chainName = parts[0];
	  var resId = parseInt(parts[1], 10);
	  if (Number.isNaN(resId)) {
	    return null;
	  }
	  var atomName = parts[2].toUpperCase();

	  var currAtom = null;
	  this.forEachChain(function (chain) {
	    if (currAtom) {
	      return;
	    }
	    if (chain._name.localeCompare(chainName) === 0) {
	      chain.forEachResidue(function (residue) {
	        if (currAtom) {
	          return;
	        }
	        if (residue._sequence === resId) {
	          residue.forEachAtom(function (atom) {
	            if (currAtom) {
	              return;
	            }
	            if (atomName.localeCompare(atom._name.getString()) === 0) {
	              currAtom = atom;
	            }
	          });
	        }
	      });
	    }
	  });

	  return currAtom;
	};

	/**
	 * Create a new chain.
	 *
	 * @param {string} name - Chain name.
	 * @returns {Chain} - Newly created chain.
	 */
	Complex.prototype.addChain = function (name) {
	  var result = new Chain(this, name);
	  this._chains.push(result); // TODO: keep chains in dictionary with an (ordered?) array of keys
	  return result;
	};

	Complex.prototype.getChain = function (name) {
	  for (var i = 0, n = this._chains.length; i < n; ++i) {
	    var chain = this._chains[i];
	    if (chain.getName() === name) {
	      return chain;
	    }
	  }
	  return null;
	};

	Complex.prototype.getChainCount = function () {
	  return this._chains.length;
	};

	Complex.prototype.getMolecules = function () {
	  return this._molecules;
	};

	Complex.prototype.getMoleculeCount = function () {
	  return this._molecules.length;
	};

	Complex.prototype.forEachAtom = function (process) {
	  var atoms = this._atoms;
	  for (var i = 0, n = atoms.length; i < n; ++i) {
	    process(atoms[i]);
	  }
	};

	Complex.prototype.forEachBond = function (process) {
	  var bonds = this._bonds;
	  for (var i = 0, n = bonds.length; i < n; ++i) {
	    process(bonds[i]);
	  }
	};

	Complex.prototype.forEachResidue = function (process) {
	  var residues = this._residues;
	  for (var i = 0, n = residues.length; i < n; ++i) {
	    process(residues[i]);
	  }
	};

	Complex.prototype.forEachChain = function (process) {
	  var chains = this._chains;
	  for (var i = 0, n = chains.length; i < n; ++i) {
	    process(chains[i]);
	  }
	};

	Complex.prototype.forEachMolecule = function (process) {
	  var molecules = this._molecules;
	  var n = molecules.length;
	  for (var i = 0; i < n; ++i) {
	    process(molecules[i]);
	  }
	};

	Complex.prototype.forEachSGroup = function (process) {
	  var groups = this._sgroups;
	  for (var i = 0, n = groups.length; i < n; ++i) {
	    process(groups[i]);
	  }
	};

	Complex.prototype.forEachComponent = function (process) {
	  var components = this._components;
	  for (var i = 0, n = components.length; i < n; ++i) {
	    process(components[i]);
	  }
	};

	Complex.prototype.forEachVisibleComponent = function (process) {
	  var components = this._components;
	  for (var i = 0, n = components.length; i < n; ++i) {
	    process(components[i]);
	  }
	};

	Complex.prototype.addBond = function (left, right, order, type, fixed) {
	  var bond = new Bond(left, right, order, type, fixed);
	  this._bonds.push(bond);
	  return bond;
	};

	Complex.prototype.getBondCount = function () {
	  return this._bonds.length;
	};

	Complex.prototype.getResidueType = function (name) {
	  return this._residueTypes[name] || null;
	};

	Complex.prototype._atomNameCompare = function (a, b, hVal) {
	  var hydrogenName = Element.ByName.H.name;
	  var carbideName = Element.ByName.C.name;

	  function snc(str) {
	    if (str === carbideName) {
	      return String.fromCharCode(1);
	    }
	    if (str === hydrogenName) {
	      return String.fromCharCode(hVal);
	    }
	    return str;
	  }

	  var ca = snc(a);
	  var cb = snc(b);
	  if (ca < cb) {
	    return -1;
	  }
	  if (ca > cb) {
	    return 1;
	  }
	  return 0;
	};

	Complex.prototype._atomNameCompareCWithH = function (a, b) {
	  return this._atomNameCompare(a, b, 2);
	};

	Complex.prototype._atomNameCompareCWithoutH = function (a, b) {
	  return this._atomNameCompare(a, b, 254);
	};

	Complex.prototype._buildFormulaSimple = function (part, charge) {
	  var atoms = part.atoms;
	  var element = null;
	  var hash = {};
	  var out = '';
	  var self = this;
	  var hydrogenName = Element.ByName.H.name;
	  var actualCharge = 0;
	  atoms.forEach(function (a) {
	    var hc = a.getHydrogenCount();
	    element = a.element;
	    if (hash[element.name]) {
	      hash[element.name] += 1;
	    } else {
	      hash[element.name] = 1;
	    }
	    if (hc > 0) {
	      if (hash[hydrogenName]) {
	        hash[hydrogenName] += hc;
	      } else {
	        hash[hydrogenName] = hc;
	      }
	    }
	    actualCharge += a.getCharge();
	  });
	  var k = Object.keys(hash);
	  if (hash.C) {
	    k.sort(this._atomNameCompareCWithH.bind(this));
	  } else {
	    k.sort(function (a, b) {
	      return self._atomNameCompare(a, b, 'H'.charCodeAt(0));
	    });
	  }
	  k.forEach(function (e) {
	    var cname = e.substr(0, 1).toUpperCase() + e.substr(1).toLowerCase();
	    if (hash[e] > 1) {
	      out += cname + hash[e].toString();
	    } else {
	      out += cname;
	    }
	  });
	  if (charge === null) {
	    //apply ourselves
	    if (actualCharge !== 0) {
	      if (k.length > 1) {
	        out = '(' + out + ')';
	      }
	      if (actualCharge > 1) {
	        out += '^{' + actualCharge.toString() + '+}';
	      }
	      if (actualCharge === 1) {
	        out += '^+';
	      }
	      if (actualCharge < -1) {
	        out += '^{' + Math.abs(actualCharge).toString() + '-}';
	      }
	      if (actualCharge === -1) {
	        out += '^-';
	      }
	    }
	    if (part.repeatCount > 1) {
	      out = part.repeatCount.toString(10) + out;
	    }
	  } else {
	    charge(k.length, actualCharge);
	  }
	  return out;
	};

	Complex.prototype._buildPartFormula = function (part) {
	  if (part.owner instanceof Complex || part.owner instanceof Component) {
	    return this._buildFormulaSimple(part, null);
	  } else if (part.owner instanceof SGroup) {
	    return part.owner.buildChemicalFormula(this, part);
	  } else {
	    return '';
	  }
	};

	Complex.prototype._partCompareFunc = function (a, b) {
	  return this._partCompareFuncInt(a, b, true);
	};

	Complex.prototype._getCumulativeCharge = function (arr) {
	  var n = arr.length;
	  var cumCharge = 0;
	  for (var i = 0; i < n; i++) {
	    cumCharge += arr[i].getCharge();
	  }
	  return cumCharge;
	};

	Complex.prototype._partCompareFuncInt = function (a, b, skipH) {
	  var self = this;
	  var hydroName = Element.ByName.H.name;
	  function buildAtomArray(atms, skipHydro) {
	    var r = {};
	    atms.forEach(function (singleAtom) {
	      if (r[singleAtom.element.name]) {
	        r[singleAtom.element.name] += 1;
	      } else {
	        r[singleAtom.element.name] = 1;
	      }
	      if (!skipHydro) {
	        var hCount = singleAtom.getHydrogenCount();
	        if (hCount > 0) {
	          if (r[hydroName]) {
	            r[hydroName] += hCount;
	          } else {
	            r[hydroName] = hCount;
	          }
	        }
	      }
	    });
	    var k = Object.keys(r);
	    k.sort(self._atomNameCompareCWithoutH.bind(self));
	    return { seq: k, data: r };
	  }
	  var skipArr = [skipH, false];
	  var atomDiff;
	  for (var i = 0; i < skipArr.length; i++) {
	    var skipPar = skipArr[i];

	    var aData = buildAtomArray(a.atoms, skipPar);
	    var bData = buildAtomArray(b.atoms, skipPar);

	    for (var aIdx = 0, bIdx = 0; aIdx < aData.seq.length && bIdx < bData.seq.length;) {
	      if (aData.seq[aIdx] === bData.seq[bIdx]) {
	        if (aData.data[aData.seq[aIdx]] === bData.data[bData.seq[bIdx]]) {
	          aIdx += 1;
	          bIdx += 1;
	        } else {
	          atomDiff = bData.data[bData.seq[bIdx]] - aData.data[aData.seq[aIdx]];
	          return atomDiff;
	        }
	      } else {
	        return self._atomNameCompareCWithoutH(aData.seq[aIdx], bData.seq[bIdx]);
	      }
	    }
	    atomDiff = aData.seq.length - bData.seq.length;
	    if (atomDiff !== 0 || !skipPar) {
	      if (atomDiff === 0) {
	        return this._getCumulativeCharge(a.atoms) - this._getCumulativeCharge(b.atoms);
	      } else {
	        return atomDiff;
	      }
	    }
	  }
	  return this._getCumulativeCharge(a.atoms) - this._getCumulativeCharge(b.atoms);
	};

	Complex.prototype._checkFormulaBuildable = function () {
	  var atoms = this.getAtoms();
	  var nAtoms = atoms.length;
	  var i = 0;
	  for (; i < nAtoms; i++) {
	    var atom = atoms[i];
	    if (atom.element.number > Element.ByName.MT.number) {
	      return '}\\text{Could not create chemical formula for this structure.}{';
	    }
	  }
	  return '';
	};

	Complex.prototype.buildChemicalFormula = function () {
	  var retDelim = '*';
	  var formulaParts = []; //object array
	  var currPart = null;
	  var pAtoms = null;
	  var atomsHash = {};
	  var hEntry = null;
	  var self = this;
	  var formula = this._checkFormulaBuildable();
	  if (formula !== '') {
	    return formula;
	  }
	  this.forEachAtom(function (a) {
	    if (atomsHash[a.getSerial()]) {
	      logger.warn('Broken complex. Formula can be invalid...');
	    }
	    atomsHash[a.getSerial()] = { atom: a, taken: null };
	  });
	  //groups part goes first
	  this.forEachSGroup(function (grp) {
	    if (grp._charge === 0 && grp._repeat === 1) {
	      //if do not we have valid reason to take part ==> skip
	      return;
	    }
	    currPart = { owner: grp, atoms: [], repeatCount: 1 };
	    pAtoms = currPart.atoms;
	    grp._atoms.forEach(function (a) {
	      hEntry = atomsHash[a.getSerial()];
	      //check is not taken
	      if (hEntry.taken === null) {
	        pAtoms.push(a);
	        //mark as taken
	        hEntry.taken = grp;
	      }
	    });
	    if (currPart.atoms.length > 0) {
	      formulaParts.push(currPart);
	    }
	    currPart = null;
	  });
	  //components part
	  this.forEachComponent(function (cmp) {
	    currPart = { owner: cmp, atoms: [], repeatCount: 1 };
	    pAtoms = currPart.atoms;
	    cmp.forEachResidue(function (r) {
	      r._atoms.forEach(function (a) {
	        hEntry = atomsHash[a.getSerial()];
	        //check is not taken
	        if (hEntry.taken === null) {
	          pAtoms.push(a);
	          //mark as taken
	          hEntry.taken = cmp;
	        }
	      });
	    });
	    if (currPart.atoms.length > 0) {
	      formulaParts.push(currPart);
	    }
	    currPart = null;
	  });
	  //collect main part
	  var atomKeys = Object.keys(atomsHash);
	  atomKeys.forEach(function (a) {
	    if (a.taken === null) {
	      if (currPart === null) {
	        currPart = { owner: self, atoms: [], repeatCount: 1 };
	      }
	      currPart.atoms.push(a.atom);
	      a.taken = self;
	    }
	  });
	  //add first part
	  if (currPart !== null) {
	    if (currPart.atoms.length > 0) {
	      formulaParts.push(currPart);
	    }
	  }
	  //sort parts
	  formulaParts.sort(function (a, b) {
	    return self._partCompareFunc(a, b);
	  });
	  //now join the same parts
	  var i = formulaParts.length - 1;
	  var j = formulaParts.length - 2;
	  while (i >= 0 && j >= 0) {
	    var pi = formulaParts[i];
	    var pj = formulaParts[j];
	    if (!(pi.owner instanceof Complex || pi.owner instanceof Component)) {
	      i--;
	      if (i === j) {
	        j--;
	      }
	      continue;
	    }
	    if (!(pj.owner instanceof Complex || pj.owner instanceof Component)) {
	      j--;
	      continue;
	    }

	    if (this._partCompareFuncInt(pj, pi, false) === 0) {
	      pj.repeatCount += pi.repeatCount;
	      formulaParts.splice(i, 1);
	    }
	    j--;
	    i--;
	  }

	  //build formula for each part individually
	  formulaParts.forEach(function (p) {
	    var pf = self._buildPartFormula(p);
	    if (pf.length > 0) {
	      if (formula.length > 0) {
	        formula += retDelim;
	      }
	      formula += pf;
	    }
	  });
	  return formula;
	};

	Complex.prototype.getUnifiedSerial = function (chain, serial, iCode) {
	  /* eslint-disable no-magic-numbers */
	  var maxSerial = 65536;
	  var chainShift = maxSerial * 256;
	  /* eslint-enable no-magic-numbers */
	  return serial + iCode * maxSerial + chain * chainShift;
	};

	Complex.prototype.splitUnifiedSerial = function (uniSerial) {
	  /* eslint-disable no-magic-numbers */
	  var maxSerial = 65536;
	  var chainShift = maxSerial * 256;
	  /* eslint-enable no-magic-numbers */
	  var chainId = Math.floor(uniSerial / chainShift);
	  var remnant = uniSerial - chainId * chainShift;
	  var insCode = Math.floor(remnant / maxSerial);
	  var ser = remnant - insCode * maxSerial;
	  return { chain: chainId, serial: ser, iCode: insCode };
	};

	Complex.prototype._fillCmpEdit = function () {
	  var self = this;
	  var components = this._components;

	  function addComp() {
	    var comp = new Component(self);
	    comp._index = components.length;
	    components[comp._index] = comp;
	    return comp;
	  }

	  this.forEachChain(function (chain) {
	    var residues = chain._residues;
	    var resCount = residues.length;
	    if (resCount < 1) {
	      return;
	    }
	    var comp = addComp();
	    var currStart = residues[0]._index;

	    for (var i = 0; i < resCount; ++i) {
	      var currRes = residues[i];
	      currRes._component = comp;

	      var nextRes = i === resCount - 1 ? null : residues[i + 1];
	      if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
	        // the last condition is broken and incorrect
	        // the refactoring of the Component is required in order to fix this issue
	        comp.setSubDivs([{
	          start: currStart,
	          end: currRes._index
	        }]);
	        if (nextRes) {
	          currStart = nextRes._index;
	          comp = addComp();
	        }
	      }
	    }
	  });
	};

	// This function was added in the moment of despair
	// It was the dark times for miew
	Complex.prototype._fillCmpNoedit = function () {
	  var comp = new Component(this);
	  comp._index = 0;

	  var residues = this._residues;
	  var resCount = residues.length;
	  if (resCount === 0) {
	    return;
	  }

	  var currSubDivs = [];
	  var currStart = 0;
	  for (var i = 0; i < resCount; ++i) {
	    var currRes = residues[i];
	    currRes._component = comp;

	    var nextRes = i === resCount - 1 ? null : residues[i + 1];
	    if (!nextRes || !currRes.isConnected(nextRes)) {
	      // wrap up this interval
	      currSubDivs[currSubDivs.length] = {
	        start: currStart,
	        end: i
	      };
	      if (nextRes) {
	        currStart = i + 1;
	      }
	    }
	  }

	  comp.setSubDivs(currSubDivs);
	  this._components[comp._index] = comp;
	};

	/**
	 * Fill components information.
	 * @param {boolean} enableEditing - Restructure Complex to enable per-component editing.
	 */
	Complex.prototype._fillComponents = function (enableEditing) {
	  if (enableEditing) {
	    this._fillCmpEdit();
	  } else {
	    this._fillCmpNoedit();
	  }
	};

	Complex.prototype.getCurrentUnit = function () {
	  return this._currentUnit;
	};

	Complex.prototype.getDefaultBoundaries = function () {
	  return this.units[0].getBoundaries();
	};

	Complex.prototype.getBoundaries = function () {
	  return this.units[this._currentUnit].getBoundaries();
	};

	Complex.prototype.getTransforms = function () {
	  return this.units[this._currentUnit].getTransforms();
	};

	Complex.prototype.getSelector = function () {
	  return this.units[this._currentUnit].getSelector();
	};

	Complex.prototype.resetCurrentUnit = function () {
	  this._currentUnit = 0;
	  this.setCurrentUnit(1);
	};

	Complex.prototype.setCurrentUnit = function (newUnit) {
	  if (newUnit !== null && newUnit !== undefined && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
	    this._currentUnit = newUnit;
	    return true;
	  }
	  return false;
	};

	/**
	 * @function
	 * @deprecated Renamed to {@link Complex#getCurrentUnit}
	 */
	Complex.prototype.getCurrentStructure = Complex.prototype.getCurrentUnit;

	/**
	 * @function
	 * @deprecated Renamed to {@link Complex#resetCurrentUnit}
	 */
	Complex.prototype.resetCurrentStructure = Complex.prototype.resetCurrentUnit;

	/**
	 * @function
	 * @deprecated Renamed to {@link Complex#setCurrentUnit}
	 */
	Complex.prototype.setCurrentStructure = Complex.prototype.setCurrentUnit;

	Complex.prototype._computeBounds = function () {
	  var units = this.units;
	  for (var i = 0, n = units.length; i < n; ++i) {
	    units[i].computeBoundaries();
	  }
	};

	Complex.prototype.onAtomPositionChanged = function () {
	  this.forEachChain(function (a) {
	    a._finalize();
	  });
	  this.forEachComponent(function (c) {
	    c.update();
	  });
	  // Update bounding sphere and box
	  this._computeBounds();
	  this._finalizeBonds();
	  this.forEachSGroup(function (s) {
	    s._rebuildSGroupOnAtomChange();
	  });
	};

	Complex.prototype.update = function () {
	  if (this._maskNeedsUpdate) {
	    this.updateStructuresMask();
	    this._maskNeedsUpdate = false;
	  }
	};

	Complex.prototype._finalizeBonds = function () {

	  var bonds = this.getBonds();
	  var n = bonds.length;
	  for (var i = 0; i < n; ++i) {
	    bonds[i]._index = i;
	  }
	};

	/**
	 * Finalizes complex's inner data(i.e. after parsing).
	 * @param {objects} opts - Build bonds automatically.
	 * @param {boolean} opts.needAutoBonding     - Build bonds automatically.
	 * @param {boolean} opts.detectAromaticLoops - Find/mark aromatic loops.
	 * @param {boolean} opts.enableEditing       - Restructure Complex to enable per-component editing.
	 * @param {Array<Atom>} [opts.serialAtomMap] - Array of atoms ordered by their serials.
	 */
	Complex.prototype.finalize = function (opts) {
	  opts = opts || {};
	  // Put bonds into atoms
	  var bonds = this._bonds;
	  var i;
	  var n;
	  //remove invalid bonds
	  for (i = bonds.length - 1; i >= 0; i--) {
	    var bond = bonds[i];
	    if (bond._left === null || bond._right === null) {
	      bonds.splice(i, 1);
	    } else {
	      bond._left._bonds.push(bond);
	      bond._right._bonds.push(bond);
	    }
	  }

	  var residues = this._residues;
	  for (i = 0, n = residues.length; i < n; ++i) {
	    residues[i]._finalize();
	  }

	  this.forEachChain(function (a) {
	    a._finalize();
	  });

	  // WARNING! this MUST be done BEFORE computeBounds is called
	  var units = this.units;
	  for (i = 0, n = units.length; i < n; ++i) {
	    units[i].finalize();
	  }
	  // try setting first biomolecule by defaults
	  this.setCurrentUnit(1);

	  var residueHash = {};
	  for (i = 0, n = residues.length; i < n; ++i) {
	    var res = residues[i];
	    // This code is extremely dangerous for non-PDB formats
	    residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
	  }

	  var structures = this.structures;
	  for (i = 0, n = structures.length; i < n; ++i) {
	    structures[i]._finalize(opts.serialAtomMap, residueHash, this);
	  }

	  var helices = this._helices;
	  for (i = 0, n = helices.length; i < n; ++i) {
	    helices[i]._finalize(opts.serialAtomMap, residueHash, this);
	  }

	  var sheets = this._sheets;
	  for (i = 0, n = sheets.length; i < n; ++i) {
	    sheets[i]._finalize(opts.serialAtomMap, residueHash, this);
	  }

	  // Update bounding sphere and box
	  this._computeBounds();

	  var atoms = this._atoms;
	  for (i = 0, n = atoms.length; i < n; ++i) {
	    var currAtom = atoms[i];
	    currAtom._index = i;
	  }

	  if (opts.needAutoBonding) {
	    // console.time('AutoBonding');
	    var autoConnector = new AutoBond(this);
	    autoConnector.build();
	    autoConnector.destroy();
	    // console.timeEnd('AutoBonding');
	  }

	  var chains = this._chains;
	  for (i = 0, n = chains.length; i < n; ++i) {
	    chains[i]._index = i;
	  }

	  for (i = 0, n = residues.length; i < n; ++i) {
	    residues[i]._index = i;
	  }

	  // mark non-polar hydrogens
	  for (i = 0, n = atoms.length; i < n; ++i) {
	    var atom = atoms[i];
	    if (atom.flags & Atom.Flags.HYDROGEN && atom._bonds.length === 1) {
	      var _bond = atom._bonds[0];
	      var other = _bond._left !== atom && _bond._left || _bond._right;
	      if (other.flags & Atom.Flags.CARBON) {
	        atom.flags |= Atom.Flags.NONPOLARH;
	      }
	    }
	  }

	  this._finalizeBonds();
	  this._fillComponents(opts.enableEditing);

	  var marker = new AromaticLoopsMarker(this);
	  marker.markCycles();
	  if (opts.detectAromaticLoops) {
	    // TODO remove this condition clause, it is for debug purposes only!
	    marker.detectCycles(); // TODO add conditional detection
	  }

	  this._finalizeMolecules();
	};

	Complex.prototype._finalizeMolecules = function () {
	  // add reference to molecule into residue
	  for (var i = 0; i < this._molecules.length; i++) {
	    var molecule = this._molecules[i];
	    var count = molecule._residues.length;
	    for (var j = 0; j < count; j++) {
	      var residue = molecule._residues[j];
	      residue._molecule = molecule;
	    }
	  }
	};

	Complex.prototype.updateStructuresMask = function () {
	  var updater = function updater(structure) {
	    return structure.collectMask();
	  };
	  this.forEachResidue(updater);
	  this.forEachChain(updater);
	  this.forEachMolecule(updater);
	};

	Complex.prototype.countAtomsByMask = function (mask) {
	  var count = 0;

	  this.forEachAtom(function (atom) {
	    if ((atom._mask & mask) !== 0) {
	      count++;
	    }
	  });

	  return count;
	};

	Complex.prototype.getNumAtomsBySelector = function (selector) {
	  var count = 0;

	  this.forEachAtom(function (atom) {
	    if (selector.includesAtom(atom)) {
	      count++;
	    }
	  });

	  return count;
	};

	Complex.prototype.resetAtomMask = function (mask) {
	  this.forEachAtom(function (atom) {
	    atom._mask = mask;
	  });
	};

	Complex.prototype.markAtoms = function (selector, mask) {
	  var setMask = mask;
	  var clearMask = ~setMask;
	  var count = 0;
	  var totalSelector = selectors.keyword('And')(selector, this.getSelector());

	  this.forEachAtom(function (atom) {
	    if (totalSelector.includesAtom(atom)) {
	      atom._mask |= setMask;
	      count++;
	    } else {
	      atom._mask &= clearMask;
	    }
	  });
	  this._maskNeedsUpdate = true;

	  return count;
	};

	Complex.prototype.markAtomsAdditionally = function (selector, mask) {
	  var setMask = mask;
	  var count = 0;

	  this.forEachAtom(function (atom) {
	    if (selector.includesAtom(atom) && (atom._mask & mask) !== mask) {
	      atom._mask |= setMask;
	      count++;
	    }
	  });

	  return count;
	};

	Complex.prototype.clearAtomBits = function (mask) {
	  var clearMask = ~mask;
	  var reseter = function reseter(a) {
	    a._mask &= clearMask;
	  };
	  this.forEachAtom(reseter);
	  this.forEachResidue(reseter);
	  this.forEachChain(reseter);
	  this.forEachMolecule(reseter);
	};

	Complex.prototype.getAtomNames = function () {
	  if (this.hasOwnProperty('_atomNames')) {
	    return this._atomNames;
	  }

	  var dict = {};
	  this.forEachAtom(function (atom) {
	    dict[atom._name._name] = 1;
	  });
	  this._atomNames = Object.keys(dict);

	  return this._atomNames;
	};

	Complex.prototype.getElements = function () {
	  if (this.hasOwnProperty('_elements')) {
	    return this._elements;
	  }

	  var dict = {};
	  this.forEachAtom(function (atom) {
	    dict[atom.element.name] = 1;
	  });
	  this._elements = Object.keys(dict);

	  return this._elements;
	};

	Complex.prototype.getResidueNames = function () {
	  if (this.hasOwnProperty('_residueNames')) {
	    return this._residueNames;
	  }

	  var dict = {};
	  this.forEachResidue(function (res) {
	    dict[res._type._name] = 1;
	  });
	  this._residueNames = Object.keys(dict);

	  return this._residueNames;
	};

	Complex.prototype.getChainNames = function () {
	  if (this.hasOwnProperty('_chainNames')) {
	    return this._chainNames;
	  }

	  var dict = {};
	  this.forEachChain(function (chain) {
	    dict[chain._name] = 1;
	  });
	  this._chainNames = Object.keys(dict);

	  return this._chainNames;
	};

	Complex.prototype.getAltLocNames = function () {
	  if (this.hasOwnProperty('_altlocNames')) {
	    return this._altlocNames;
	  }

	  var dict = {};
	  this.forEachAtom(function (atom) {
	    dict[String.fromCharCode(atom._location)] = 1;
	  });
	  this._altlocNames = Object.keys(dict);

	  return this._altlocNames;
	};

	Complex.prototype.getVoxelWorld = function () {
	  if (!this.hasOwnProperty('_voxelWorld')) {
	    try {
	      this._voxelWorld = new VoxelWorld(this.getDefaultBoundaries().boundingBox, new Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));
	      this._voxelWorld.addAtoms(this);
	    } catch (e) {
	      logger.warn('Unable to create voxel world');
	      this._voxelWorld = null;
	    }
	  }

	  return this._voxelWorld;
	};

	// this function joins multiple complexes into one (this)
	// atom, bond, ... objects are reused -- so input complexes are no longer valid
	Complex.prototype.joinComplexes = function (complexes) {
	  var i, j;

	  // clear target complex
	  this._chains = [];
	  this._components = [];
	  this._helices = [];
	  this._sheets = [];
	  this.structures = [];
	  this._atoms = [];
	  this._residues = [];
	  this._bonds = [];
	  this._sgroups = [];

	  var atomBias = 0;
	  var bondBias = 0;
	  var residueBias = 0;
	  var chainBias = 0;
	  var componentBias = 0;
	  for (i = 0; i < complexes.length; ++i) {
	    var c = complexes[i];

	    // add atoms
	    for (j = 0; j < c._atoms.length; ++j) {
	      var a = c._atoms[j];
	      a._serial += atomBias;
	      a._index += atomBias;
	      this._atoms.push(a);
	    }

	    // add bonds
	    for (j = 0; j < c._bonds.length; ++j) {
	      var b = c._bonds[j];
	      b._index += bondBias;
	      this._bonds.push(b);
	    }

	    // add residues
	    for (j = 0; j < c._residues.length; ++j) {
	      var r = c._residues[j];
	      r._index += residueBias;
	      this._residues.push(r);
	    }

	    // add chains
	    for (j = 0; j < c._chains.length; ++j) {
	      var chain = c._chains[j];
	      chain._complex = this;
	      chain._index += chainBias;
	      this._chains.push(chain);
	    }

	    // add structures
	    for (j = 0; j < c.structures.length; ++j) {
	      this.structures.push(c.structures[j]);
	    }

	    // add sheets
	    for (j = 0; j < c._sheets.length; ++j) {
	      this._sheets.push(c._sheets[j]);
	    }

	    // add helices
	    for (j = 0; j < c._helices.length; ++j) {
	      this._helices.push(c._helices[j]);
	    }

	    // add SGroups
	    for (j = 0; j < c._sgroups.length; ++j) {
	      this._sgroups.push(c._sgroups[j]);
	    }

	    // add components
	    for (j = 0; j < c._components.length; ++j) {
	      var comp = c._components[j];
	      comp._complex = this;
	      comp._index += componentBias;
	      this._components.push(comp);
	    }

	    // merge residue types
	    for (var rt in c._residueTypes) {
	      if (c._residueTypes.hasOwnProperty(rt)) {
	        this._residueTypes[rt] = c._residueTypes[rt];
	      }
	    }

	    atomBias += c._atoms.length;
	    bondBias += c._bonds.length;
	    residueBias += c._residues.length;
	    chainBias += c._chains.length;
	    componentBias += c._components.length;
	  }

	  this._computeBounds();
	};

	var StructureType$1 = SecondaryStructureMap.StructureType;
	var StructuralElementType$2 = StructuralElement.Type;

	// see http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX
	var helixClassMap = (_helixClassMap = {}, defineProperty(_helixClassMap, StructureType$1.HELIX_ALPHA, 1), defineProperty(_helixClassMap, StructureType$1.HELIX_PI, 3), defineProperty(_helixClassMap, StructureType$1.HELIX_310, 5), _helixClassMap);

	var loopMap = (_loopMap = {}, defineProperty(_loopMap, StructureType$1.BRIDGE, StructuralElementType$2.BRIDGE), defineProperty(_loopMap, StructureType$1.TURN, StructuralElementType$2.TURN), defineProperty(_loopMap, StructureType$1.BEND, StructuralElementType$2.BEND), defineProperty(_loopMap, StructureType$1.LOOP, StructuralElementType$2.COIL), _loopMap);

	/**
	 * Replace secondary structure with calculated one.
	 *
	 * DSSP algorithm implementation is used.
	 *
	 * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
	 * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
	 */
	Complex.prototype.dssp = function () {
	  var ssMap = new SecondaryStructureMap(this);

	  var structures = this.structures = [];
	  var helices = this._helices = [];
	  var sheets = this._sheets = [];

	  var getSheet = function getSheet(index) {
	    var item = sheets[index];
	    if (!item) {
	      item = sheets[index] = new Sheet(String(index), 0);
	    }
	    return item;
	  };

	  var lastCode = void 0;
	  var lastSheetIndex = void 0;
	  var lastHelixIndex = 0;
	  var curStructure = null;
	  for (var i = 0, n = this._residues.length; i < n; ++i) {
	    var curCode = ssMap._ss[i];
	    var curResidue = this._residues[i];
	    var curSheetIndex = ssMap._sheet[i];

	    // expand the last structure
	    if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
	      curResidue._secondary = curStructure;
	      if (curStructure) {
	        curStructure.term = curResidue;
	      }
	      if (curStructure instanceof Helix) {
	        curStructure.length++;
	      }
	      continue;
	    }

	    // create a new structure
	    var helixClass = helixClassMap[curCode];
	    var loopType = loopMap[curCode];
	    if (curCode === StructureType$1.STRAND) {
	      var curSheet = getSheet(curSheetIndex);
	      curStructure = new Strand(curSheet, curResidue, curResidue, 0, null, null);
	      curSheet.addStrand(curStructure);
	    } else if (helixClass !== undefined) {
	      lastHelixIndex++;
	      curStructure = new Helix(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), '', 1);
	      helices.push(curStructure);
	    } else if (loopType !== undefined) {
	      curStructure = new StructuralElement(loopType, curResidue, curResidue);
	    } else {
	      curStructure = null;
	    }

	    if (curStructure) {
	      structures.push(curStructure);
	    }

	    curResidue._secondary = curStructure;

	    lastCode = curCode;
	    lastSheetIndex = curSheetIndex;
	  }

	  this._sheets = sheets.filter(function (_sheet) {
	    return true;
	  }); // squeeze sheets array
	};

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Volume constructor
	 *
	 * @param {Object} type - Float32Array, Int8Array, etc...
	 * @param {Object|Array} dimensions - number of data points on each axis (x, y, z)
	 * @param {Box3} box - bounding box defining data place in metric space,
	 *                     it's corners correspond to extreme data points
	 * @param {Number} vecSize - dimension of the field data point (1 = scalar, 3 = 3D vector)
	 * @param {Object} data - typed array of the same type as specified by the 1st parameter,
	 *                        layout: point by point along X,
	 *                                row by row along Y,
	 *                                plane by plane along Z
	 */
	function Volume(type, dimensions, box, vecSize, data) {
	  this._box = box.clone();
	  this._dimVec = Math.max(Math.floor(vecSize || 1), 1);

	  if (dimensions instanceof Array) {
	    this._dimX = dimensions[0];
	    this._dimY = dimensions[1];
	    this._dimZ = dimensions[2];
	  } else {
	    this._dimX = dimensions.x;
	    this._dimY = dimensions.y;
	    this._dimZ = dimensions.z;
	  }
	  this._dimX = Math.max(Math.floor(this._dimX), 1);
	  this._dimY = Math.max(Math.floor(this._dimY), 1);
	  this._dimZ = Math.max(Math.floor(this._dimZ), 1);

	  this._rowElements = this._dimVec * this._dimX;
	  this._planeElements = this._rowElements * this._dimY;
	  this._totalElements = this._planeElements * this._dimZ;

	  this._data = data || utils.allocateTyped(type, this._totalElements);

	  // override getter/setter for vector fields
	  switch (this._dimVec) {
	    case 1:
	      break;

	    case 2:
	      this.getValue = function (x, y, z) {
	        var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
	        return [this._data[idx], this._data[idx + 1]];
	      };

	      this.setValue = function (x, y, z) {
	        var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
	        this._data[idx] = arguments[3];
	        this._data[idx + 1] = arguments[4];
	      };

	      this.addValue = function (x, y, z) {
	        var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
	        this._data[idx] += arguments[3];
	        this._data[idx + 1] += arguments[4];
	      };
	      break;

	    case 3:
	      this.getValue = function (x, y, z) {
	        var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
	        return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
	      };

	      this.setValue = function (x, y, z) {
	        var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
	        this._data[idx] = arguments[3];
	        this._data[idx + 1] = arguments[4];
	        this._data[idx + 2] = arguments[5];
	      };

	      this.addValue = function (x, y, z) {
	        var idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
	        this._data[idx] += arguments[3];
	        this._data[idx + 1] += arguments[4];
	        this._data[idx + 2] += arguments[5];
	      };
	      break;

	    default:
	      throw new Error('Volume: invalid vector dimension');
	  }
	}

	utils.deriveClass(Volume, DataSource, {
	  id: 'Volume'
	});

	// default getter assumes it's a scalar field
	Volume.prototype.getValue = function (x, y, z) {
	  return this._data[x + y * this._rowElements + z * this._planeElements];
	};

	// default setter assumes it's a scalar field
	Volume.prototype.setValue = function (x, y, z, val) {
	  this._data[x + y * this._rowElements + z * this._planeElements] = val;
	};

	// default adder assumes it's a scalar field
	Volume.prototype.addValue = function (x, y, z, val) {
	  this._data[x + y * this._rowElements + z * this._planeElements] += val;
	};

	Volume.prototype.getDimensions = function () {
	  return [this._dimX, this._dimY, this._dimZ];
	};

	Volume.prototype.getBox = function () {
	  return this._box;
	};

	Volume.prototype.getCellSize = function () {
	  var boxSize = new Vector3();
	  this._box.getSize(boxSize);
	  var res = new Vector3();
	  res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
	  res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
	  res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
	  return res;
	};

	Volume.prototype.computeGradient = function () {
	  if (this._dimVec !== 1) {
	    // gradient can only be computed for scalar fields
	    return null;
	  }

	  // create a 3D vector field of gradients
	  var gradient = new Volume(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3);

	  // calculate cell side lengths
	  var vl = this.getCellSize();

	  // gradient axis scaling values and averaging factors, to correctly
	  // calculate the gradient for volumes with irregular cell spacing
	  var vs = new Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z);

	  // TODO Check for intended bug in VMD (min is zero)
	  function clamp(val, min, max) {
	    return Math.min(max, Math.max(min, val));
	  }

	  var xSize = this._dimX;
	  var ySize = this._dimY;
	  var zSize = this._dimZ;
	  var volMap = this._data;

	  function _voxelValue(x, y, z) {
	    return volMap[z * xSize * ySize + y * xSize + x];
	  }

	  for (var zi = 0; zi < zSize; ++zi) {
	    var zm = clamp(zi - 1, 0, zSize - 1);
	    var zp = clamp(zi + 1, 0, zSize - 1);

	    for (var yi = 0; yi < ySize; ++yi) {
	      var ym = clamp(yi - 1, 0, ySize - 1);
	      var yp = clamp(yi + 1, 0, ySize - 1);

	      for (var xi = 0; xi < xSize; ++xi) {
	        var xm = clamp(xi - 1, 0, xSize - 1);
	        var xp = clamp(xi + 1, 0, xSize - 1);

	        // Calculate the volume gradient at each grid cell.
	        // Gradients are now stored unnormalized, since we need them in pure
	        // form in order to draw field lines etc.  Shading code will now have
	        // to do renormalization for itself on-the-fly.

	        // XXX this gradient is only correct for orthogonal grids, since
	        // we're using the array index offsets rather to calculate the gradient
	        // rather than voxel coordinate offsets.  This will have to be
	        // re-worked for non-orthogonal datasets.

	        gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
	      }
	    }
	  }

	  return gradient;
	};

	Volume.prototype.normalize = function () {
	  var data = this._data;
	  var i;

	  // get min/max
	  var min = data[0];
	  var max = data[0];
	  for (i = 1; i < data.length; ++i) {
	    min = Math.min(min, data[i]);
	    max = Math.max(max, data[i]);
	  }

	  var d = 1.0 / (max - min);
	  if (d === 0) {
	    return;
	  }

	  // normalize
	  for (i = 0; i < data.length; ++i) {
	    data[i] = d * (data[i] - min);
	  }
	};

	function pow2ceil(v) {
	  var p = 2;
	  v = v - 1 >> 1;
	  while (v) {
	    p <<= 1;
	    v >>= 1;
	  }
	  return p;
	}

	Volume.prototype.getTiledTextureStride = function () {
	  return [this._dimX + 2, this._dimY + 2];
	};

	Volume.prototype.buildTiledTexture = function () {
	  var tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));

	  var width = tilesX * (this._dimX + 2) - 1;
	  width = pow2ceil(width);
	  tilesX = Math.floor(width / (this._dimX + 2));

	  var tilesY = Math.ceil(this._dimZ / tilesX);
	  var height = tilesY * (this._dimY + 2) - 1;
	  height = pow2ceil(height);

	  var data = new Uint8Array(width * height);

	  var src, dst, tileRow, row, t, x;
	  for (tileRow = 0; tileRow < tilesY; ++tileRow) {
	    // process each pixel row of this tile row
	    for (row = 0; row < this._dimY; ++row) {
	      src = tileRow * tilesX * this._planeElements + row * this._rowElements;
	      dst = width * (tileRow * (this._dimY + 2) + row);
	      // copy a series of rows through several XY planes
	      for (t = 0; t < tilesX; ++t) {
	        // copy one row of one XY plane
	        for (x = 0; x < this._dimX; ++x) {
	          data[dst++] = 255.0 * this._data[src++];
	        }

	        // repeat last pixel of previous tile
	        data[dst++] = 255.0 * this._data[src - 1];

	        if (t < tilesX - 1) {
	          // skip to the same row of next XY plane
	          src += this._planeElements - this._rowElements;
	          // repeat first pixel of next tile
	          data[dst++] = 255.0 * this._data[src];
	        }
	      }
	    }
	  }

	  // fill pixels between tile rows with copy of edge pixels
	  for (tileRow = 0; tileRow < tilesY; ++tileRow) {
	    // copy last pixel row of this tile row to the following pixel row of the texture
	    src = width * (tileRow * (this._dimY + 2) + this._dimY - 1);
	    dst = src + width;
	    for (x = 0; x < width; ++x) {
	      data[dst++] = data[src++];
	    }
	    if (tileRow < tilesY - 1) {
	      // copy first pixel row of next tile row to the preceding pixel row of the texture
	      src = width * (tileRow + 1) * (this._dimY + 2);
	      dst = src - width;
	      for (x = 0; x < width; ++x) {
	        data[dst++] = data[src++];
	      }
	    }
	  }

	  var texture = new DataTexture(data, width, height, LuminanceFormat, UnsignedByteType, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter);
	  texture.generateMipmaps = false;
	  texture.needsUpdate = true;
	  return texture;
	};

	/**********************************************************************************
	   *
	   * Methods that provide direct access to internal array (for better performance)
	   *
	   *********************************************************************************/

	Volume.prototype.getData = function () {
	  return this._data;
	};

	Volume.prototype.getDirectIdx = function (x, y, z) {
	  return x * this._dimVec + y * this._rowElements + z * this._planeElements;
	};

	Volume.prototype.getStrideX = function () {
	  return this._dimVec;
	};

	Volume.prototype.getStrideY = function () {
	  return this._rowElements;
	};

	Volume.prototype.getStrideZ = function () {
	  return this._planeElements;
	};

	//////////////////////////////////////////////////////////////////////////////

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Residue Molecule.
	 *
	 * @param {Complex} complex - Molecular complex this Molecule belongs to.
	 * @param {String} name - Molecule's name.
	 * @param {Integer} index - Molecule's index in file.
	 *
	 * @exports Molecule
	 * @constructor
	 */
	function Molecule(complex, name, index) {
	  this._complex = complex;
	  this._name = name || '';
	  this._residues = [];
	  this._mask = 1 | 0;
	  this._index = index || -1; // start with 1
	}

	Molecule.prototype.getComplex = function () {
	  return this._complex;
	};

	Molecule.prototype.getName = function () {
	  return this._name;
	};

	Molecule.prototype.getResidues = function () {
	  return this._residues;
	};

	Molecule.prototype.getIndex = function () {
	  return this._index;
	};

	Molecule.prototype.forEachResidue = function (process) {
	  var residues = this._residues;
	  for (var i = 0, n = residues.length; i < n; ++i) {
	    process(residues[i]);
	  }
	};

	Molecule.prototype.collectMask = function () {
	  var mask = 0xffffffff;
	  var residues = this._residues;
	  for (var i = 0, n = residues.length; i < n; ++i) {
	    mask &= residues[i]._mask;
	  }
	  this._mask = mask;
	};

	var chem = {
	  Atom: Atom,
	  Element: Element,
	  AtomName: AtomName,
	  Bond: Bond,
	  Residue: Residue,
	  ResidueType: ResidueType,
	  Chain: Chain,
	  Helix: Helix,
	  Strand: Strand,
	  Sheet: Sheet,
	  SGroup: SGroup,
	  Assembly: Assembly,
	  Complex: Complex,
	  Volume: Volume,
	  VoxelWorld: VoxelWorld,
	  selectors: selectors,
	  Molecule: Molecule
	};

	function CSS2DObject(element) {
	  Object3D.call(this);
	  var self = this;
	  this._element = element;
	  this._element.style.position = 'absolute';
	  this.addEventListener('removed', function () {
	    if (self._element.parentNode !== null) {
	      self._element.parentNode.removeChild(self._element);
	    }
	  });
	}

	CSS2DObject.prototype = Object.create(Object3D.prototype);
	CSS2DObject.prototype.constructor = CSS2DObject;

	CSS2DObject.prototype.getElement = function () {
	  return this._element;
	};

	/**
	 * Sets label transparency.
	 *
	 * @param {number} transp    - in [0; 1] 1 means fully transparent
	 */
	CSS2DObject.prototype.setTransparency = function (transp) {
	  var el = this.getElement();
	  if (el === null) {
	    return;
	  }
	  if (transp === 1.0) {
	    el.style.display = 'none';
	    return;
	  }
	  el.style.display = 'inline';
	  var op = 1.0 - transp;
	  var top = op.toString();
	  var op100 = op * 100;
	  el.style.opacity = top;
	  el.style.filter = 'alpha(opacity=' + op100 + ')'; // IE fallback
	};

	CSS2DObject.prototype.clone = function () {
	  var obj = new CSS2DObject(this._element);
	  obj.copy(this);
	  return obj;
	};

	function RCGroup() {
	  Group.call(this);
	}

	RCGroup.prototype = Object.create(Group.prototype);
	RCGroup.prototype.constructor = RCGroup;
	RCGroup.prototype.raycast = function (raycaster, intersects) {
	  if (!this.visible) {
	    return;
	  }

	  var children = this.children;
	  for (var i = 0, n = children.length; i < n; ++i) {
	    children[i].raycast(raycaster, intersects);
	  }
	};

	RCGroup.prototype.enableSubset = function (mask, innerOnly) {
	  var children = this.children;
	  for (var i = 0, n = children.length; i < n; ++i) {
	    if (children[i].enableSubset) {
	      children[i].enableSubset(mask, innerOnly);
	    }
	  }
	};

	RCGroup.prototype.disableSubset = function (mask, innerOnly) {
	  var children = this.children;
	  for (var i = 0, n = children.length; i < n; ++i) {
	    if (children[i].disableSubset) {
	      children[i].disableSubset(mask, innerOnly);
	    }
	  }
	};

	RCGroup.prototype.isEmpty = function () {
	  return this.children.length === 0;
	};

	RCGroup.prototype.updateToFrame = function (frameData) {
	  var children = this.children;
	  for (var i = 0, n = children.length; i < n; ++i) {
	    if (children[i].updateToFrame) {
	      children[i].updateToFrame(frameData);
	    }
	  }
	};

	RCGroup.prototype.getSubset = function (mask, innerOnly) {
	  var totalSubset = [];
	  var children = this.children;
	  for (var i = 0, n = children.length; i < n; ++i) {
	    if (children[i].getSubset) {
	      Array.prototype.push.apply(totalSubset, children[i].getSubset(mask, innerOnly));
	    }
	  }
	  return totalSubset;
	};

	var vertexShader = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\nuniform mat4 projMatrixInv; // TODO move to thick line\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n  vec3 objectNormal = vec3( normal );\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 transformedNormal = vec3(\r\n    dot(objectNormal, matVector1.xyz),\r\n    dot(objectNormal, matVector2.xyz),\r\n    dot(objectNormal, matVector3.xyz));\r\n  transformedNormal = normalMatrix * transformedNormal;\r\n#else\r\n  vec3 transformedNormal = normalMatrix * objectNormal;\r\n#endif\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n\r\n    // basic sprite size at screen plane (covers only cylinder axis)\r\n    vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n\r\n    // full sprite size in eye coords\r\n    float minZ = min(abs(p1.z), abs(p2.z));\r\n    vec2 spriteSize = INSTANCED_SPRITE_OVERSCALE  * abs(posEye.z) *\r\n      (spriteSizeScreen + 2.0 * rad / minZ);\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n";

	var fragmentShader = "#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n  uniform mat4 projectionMatrix;\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  float intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return -1.0;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point\r\n    if (t1 >= 0.0) {\r\n      point = p1;\r\n      return t1;\r\n    }\r\n    if (t2 >= 0.0) {\r\n      point = p2;\r\n      return t2;\r\n    }\r\n\r\n    return -1.0;\r\n  }\r\n\r\n  float get_sphere_point(in vec3 pixelPosEye, out vec3 point) {\r\n    // transform camera pos into sphere local coords\r\n    vec4 v = invModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\r\n    vec3 origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n    // transform (camera -> pixel) ray into cylinder local coords\r\n    v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n    vec3 ray = normalize(v.xyz);\r\n\r\n    return intersect_ray_sphere(origin, ray, point);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  float intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return -1.0;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point\r\n    float halfHeight = 0.5;\r\n    if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n      point = p1;\r\n      return t1;\r\n    }\r\n    if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n      point = p2;\r\n      return t2;\r\n    }\r\n\r\n    return -1.0;\r\n  }\r\n\r\n  float get_cylinder_point(in vec3 pixelPosEye, out vec3 point) {\r\n    // transform camera pos into cylinder local coords\r\n    vec4 v = invModelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\r\n    vec3 origin = vec3(\r\n      dot(v, invmatVec1),\r\n      dot(v, invmatVec2),\r\n      dot(v, invmatVec3));\r\n\r\n    // transform (camera -> pixel) ray into cylinder local coords\r\n    v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n    vec3 ray = vec3(\r\n      dot(v, invmatVec1),\r\n      dot(v, invmatVec2),\r\n      dot(v, invmatVec3));\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Lighting ////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n  uniform vec3 ambientLightColor;\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color * PI;\r\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor * PI;\r\n\r\n    // use loop for number\r\n    #if NUM_DIR_LIGHTS > 1\r\n      for (int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n        RE_Direct_BlinnPhong(directionalLights[i], geometry, material, reflectedLight);\r\n    #else\r\n        RE_Direct_BlinnPhong(directionalLights[0], geometry, material, reflectedLight);\r\n    #endif\r\n\r\n        RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    #if NUM_DIR_LIGHTS > 1\r\n      }\r\n    #endif\r\n\r\n    return reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular;\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (get_sphere_point(-vViewPosition, p) < 0.0) discard;\r\n    pixelPosWorld = modelMatrix * vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    // pixelPosEye = modelViewMatrix * vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n    pixelPosEye.z += instOffset.w *\r\n      (modelViewMatrix[0][2] * p.x +\r\n       modelViewMatrix[1][2] * p.y +\r\n       modelViewMatrix[2][2] * p.z);\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n  }\r\n\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (get_cylinder_point(-vViewPosition, p) < 0.0) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vec3 vertexColor = vColor;\r\n#else\r\n  vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  #ifdef CYLINDER_SPRITE\r\n    float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n  #else\r\n    float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n  #endif\r\n    // choose either color or color2\r\n  vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n#endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n#ifdef DASHED_LINE\r\n  if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n#endif\r\n\r\n// transparency prepass writes only z, so we don't need to calc the color\r\n#ifdef PREPASS_TRANSP\r\n  fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n  return;\r\n#endif\r\n\r\n  float totalOpacity = opacity;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  totalOpacity *= alphaCol;\r\n#endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n#ifdef FAKE_OPACITY\r\n  // discard pixels in checker pattern\r\n  vec2 dm_coord = floor(gl_FragCoord.xy);\r\n  dm_coord = fract(dm_coord * 0.5);\r\n  if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n  vec4 diffuseColor = vec4(diffuse, 1.0);\r\n#else\r\n  vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n#endif\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  #ifdef DOUBLE_SIDED\r\n    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\r\n  #else\r\n    float flipNormal = 1.0;\r\n  #endif\r\n  vec3 normal = normalize( vNormal ) * flipNormal;\r\n#endif\r\n\r\n  diffuseColor.rgb *= vertexColor;\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n    vec3 viewNormaInColor = 0.5*viewNormalSprites+0.5;\r\n  #else\r\n    vec3 viewNormaInColor = 0.5*viewNormal+0.5;\r\n  #endif\r\n  // [-1, 1] -> [0, 1]\r\n  gl_FragData[1] = vec4(viewNormaInColor, 1.0);\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  GeometricContext geometry = GeometricContext(normal, normalize( vViewPosition ));\r\n  BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n  vec3 outgoingLight = calcLighting(geometry, material);\r\n#else\r\n  vec3 outgoingLight = diffuseColor.rgb;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  fragColor = world2colorMatrix * pixelPosWorld;\r\n#else\r\n  #ifdef OVERRIDE_COLOR\r\n    fragColor = vec4(fixedColor, diffuseColor.a);\r\n  #else\r\n    fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n  #endif\r\n\r\n  #ifdef USE_FOG\r\n    float viewDistance;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDistance = abs(pixelPosEye.z);\r\n    #else\r\n      viewDistance = vViewPosition.z;\r\n    #endif\r\n    float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n    #ifdef FOG_TRANSPARENT\r\n      fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n    #else\r\n      fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n    #endif\r\n  #endif\r\n\r\n#endif\r\n}\r\n";

	var capabilities = {

	  precision: 'mediump',

	  /**
	   *
	   * @param {THREE.WebGLRenderer} renderer
	   */
	  init: function init(renderer) {
	    this.precision = renderer.capabilities.getMaxPrecision('highp');
	  }
	};

	//  var INSTANCED_SPRITE_OVERSCALE = 1.3;

	var defaultUniforms = UniformsUtils.merge([UniformsLib.common, //FIXME is it needed
	UniformsLib.fog, UniformsLib.lights, //FIXME simplify use only directional

	{
	  'specular': { type: 'c', value: new Color(0x111111) },
	  'shininess': { type: 'f', value: 30 },
	  'fixedColor': { type: 'c', value: new Color(0xffffff) },
	  'zOffset': { type: 'f', value: 0.0 },
	  'zClipValue': { type: 'f', value: 0.0 },
	  'clipPlaneValue': { type: 'f', value: 0.0 },
	  'invModelViewMatrix': { type: '4fv', value: new Matrix4() },
	  'world2colorMatrix': { type: '4fv', value: new Matrix4() },
	  'dashedLineSize': { type: 'f', value: 0.1 },
	  'dashedLinePeriod': { type: 'f', value: 0.2 },
	  'projMatrixInv': { type: '4fv', value: new Matrix4() },
	  'viewport': { type: 'v2', value: new Vector2() },
	  'lineWidth': { type: 'f', value: 2.0 },
	  //default value must be the same as settings
	  'fogAlpha': { type: 'f', value: 1.0 }
	}]);

	var uberOptionNames = ['shininess', 'opacity', 'zOffset', 'diffuse', 'specular', 'fixedColor', 'zClipCoef', 'zClipValue', 'clipPlaneValue', 'world2colorMatrix', 'dashedLineSize', 'dashedLinePeriod', 'projMatrixInv', 'viewport', 'lineWidth', 'fogAlpha'];

	function UberMaterial(params) {
	  RawShaderMaterial.call(this);

	  // add fog
	  this.fog = true;
	  // used for instanced geometry
	  this.instancedPos = false;
	  this.instancedMatrix = false;
	  // atoms and links color
	  this.attrColor = false;
	  // second link color for cylinders
	  this.attrColor2 = false;
	  //
	  this.attrAlphaColor = false;
	  // overrides color for all vertices (used in selection)
	  this.overrideColor = false;
	  // zsrpites
	  this.sphereSprite = false;
	  this.cylinderSprite = false;
	  // clip Surfs individually
	  this.zClip = false;
	  // clip scene with global clip plane
	  this.clipPlane = false;
	  // enable fake (chess-like) opacity
	  this.fakeOpacity = false;
	  // render only depth, don't take care about the pixel color (used for transparency depth prepass)
	  this.prepassTransparancy = false;
	  // used to render pixel positions
	  this.colorFromPos = false;
	  // used to render dashed line
	  this.dashedLine = false;
	  // mark as transparent
	  this.transparent = true;
	  // mark as thick lines
	  this.thickLine = false;
	  // makes fog begin transparency (required for transparent background)
	  this.fogTransparent = false;
	  // used to render surface normals to G buffer for ssao effect
	  this.normalsToGBuffer = false;
	  //used for toon material
	  this.toonShading = false;

	  // uber options of "root" materials are inherited from single uber-options object that resides in prototype
	  this.uberOptions = Object.create(UberMaterial.prototype.uberOptions);

	  // set default values
	  RawShaderMaterial.prototype.setValues.call(this, {
	    uniforms: UniformsUtils.clone(defaultUniforms),
	    vertexShader: this.precisionString() + vertexShader,
	    fragmentShader: this.precisionString() + fragmentShader,
	    lights: true,
	    fog: true,
	    side: DoubleSide
	  });

	  this.setValues(params);
	}

	UberMaterial.prototype = Object.create(RawShaderMaterial.prototype);
	UberMaterial.prototype.constructor = UberMaterial;

	UberMaterial.prototype.precisionString = function () {
	  var precision = capabilities.precision;
	  var str = 'precision ' + precision + ' float;\n' + 'precision ' + precision + ' int;\n\n';
	  return str;
	};

	// properties that convert to uniforms
	UberMaterial.prototype.uberOptions = {
	  diffuse: new Color(0xffffff), // used in phong lighting
	  specular: new Color(0x111111), // used in phong lighting
	  shininess: 30, // used in phong lighting
	  opacity: 1, // set mesh opacity
	  fixedColor: new Color(0xffffff), // color to override (see OVERRIDE_COLOR)
	  zOffset: 0.0, // used fo zsprites (see SPHERE_SPRITE CYLINDER_SPRITE)
	  zClipCoef: 2.0, // use for Surfs clipping (mesh param, isn't used in shader)  FIXME move to representation param
	  zClipValue: 0.0, //  value to clip Surfs in shader  (see ZCLIP)
	  clipPlaneValue: 0.0, // value to clip scene globally (see CLIPPLANE)
	  world2colorMatrix: new Matrix4(),
	  dashedLineSize: 0.1,
	  dashedLinePeriod: 0.3,
	  projMatrixInv: new Matrix4(),
	  viewport: new Vector2(800, 600),
	  lineWidth: 2.0,
	  fogAlpha: 1.0,

	  copy: function copy(source) {
	    this.diffuse.copy(source.diffuse);
	    this.specular.copy(source.specular);
	    this.shininess = source.shininess;
	    this.opacity = source.opacity;
	    this.fixedColor.copy(source.fixedColor);
	    this.zOffset = source.zOffset;
	    this.zClipCoef = source.zClipCoef;
	    this.zClipValue = source.zClipValue;
	    this.clipPlaneValue = source.clipPlaneValue;
	    this.world2colorMatrix.copy(source.world2colorMatrix);
	    this.dashedLineSize = source.dashedLineSize;
	    this.dashedLinePeriod = source.dashedLinePeriod;
	    this.projMatrixInv = source.projMatrixInv;
	    this.viewport = source.viewport;
	    this.lineWidth = source.lineWidth; // used for thick lines only
	    this.toonShading = source.toonShading;
	    this.fogAlpha = source.fogAlpha;
	  }
	};

	UberMaterial.prototype.copy = function (source) {

	  //TODO Why not RawShaderMaterial?
	  ShaderMaterial.prototype.copy.call(this, source);

	  this.fog = source.fog;
	  this.instancedPos = source.instancedPos;
	  this.instancedMatrix = source.instancedMatrix;
	  this.attrColor = source.attrColor;
	  this.attrColor2 = source.attrColor2;
	  this.attrAlphaColor = source.attrAlphaColor;
	  this.overrideColor = source.overrideColor;
	  this.sphereSprite = source.sphereSprite;
	  this.cylinderSprite = source.cylinderSprite;
	  this.zClip = source.zClip;
	  this.clipPlane = source.clipPlane;
	  this.fakeOpacity = source.fakeOpacity;
	  this.colorFromPos = source.colorFromPos;
	  this.prepassTransparancy = source.prepassTransparancy;
	  this.dashedLine = source.dashedLine;
	  this.thickLine = source.thickLine;
	  this.fogTransparent = source.fogTransparent;
	  this.normalsToGBuffer = source.normalsToGBuffer;
	  this.toonShading = source.toonShading;

	  this.uberOptions.copy(source.uberOptions);

	  return this;
	};

	// create copy of this material
	// its options are prototyped after this material's options
	UberMaterial.prototype.createInstance = function () {
	  var inst = new UberMaterial();
	  inst.copy(this);
	  inst.uberOptions = Object.create(this.uberOptions);
	  return inst;
	};

	UberMaterial.prototype.setValues = function (values) {
	  if (typeof values === 'undefined') {
	    return;
	  }

	  // set direct values
	  RawShaderMaterial.prototype.setValues.call(this, values);

	  var defines = {};
	  var extensions = {};

	  if (this.fog) {
	    defines.USE_FOG = 1;
	  }
	  if (this.instancedPos) {
	    defines.INSTANCED_POS = 1;
	  }
	  if (this.instancedMatrix) {
	    defines.INSTANCED_MATRIX = 1;
	  }
	  if (this.attrColor) {
	    defines.ATTR_COLOR = 1;
	  }
	  if (this.attrColor2) {
	    defines.ATTR_COLOR2 = 1;
	  }
	  if (this.attrAlphaColor) {
	    defines.ATTR_ALPHA_COLOR = 1;
	  }
	  if (this.overrideColor) {
	    defines.OVERRIDE_COLOR = 1;
	  }
	  if (this.sphereSprite) {
	    defines.SPHERE_SPRITE = 1;
	    extensions.fragDepth = 1;
	  }
	  if (this.cylinderSprite) {
	    defines.CYLINDER_SPRITE = 1;
	    extensions.fragDepth = 1;
	  }
	  if (this.zClip) {
	    defines.ZCLIP = 1;
	  }
	  if (this.clipPlane) {
	    defines.CLIP_PLANE = 1;
	  }
	  if (this.fakeOpacity) {
	    defines.FAKE_OPACITY = 1;
	  }
	  if (this.lights) {
	    defines.USE_LIGHTS = 1;
	  }
	  if (this.colorFromPos) {
	    defines.COLOR_FROM_POS = 1;
	  }
	  if (this.prepassTransparancy) {
	    defines.PREPASS_TRANSP = 1;
	  }
	  if (this.dashedLine) {
	    defines.DASHED_LINE = 1;
	  }
	  if (this.thickLine) {
	    defines.THICK_LINE = 1;
	  }
	  if (this.fogTransparent) {
	    defines.FOG_TRANSPARENT = 1;
	  }
	  if (this.normalsToGBuffer) {
	    extensions.drawBuffers = 1;
	    defines.NORMALS_TO_G_BUFFER = 1;
	  }
	  if (this.toonShading) {
	    defines.TOON_SHADING = 1;
	  }
	  // set dependent values
	  this.defines = defines;
	  this.extensions = extensions;
	};

	UberMaterial.prototype.setUberOptions = function (values) {
	  if (typeof values === 'undefined') {
	    return;
	  }

	  for (var key in values) {
	    if (!values.hasOwnProperty(key)) {
	      continue;
	    }

	    if (this.uberOptions[key] instanceof Color) {
	      this.uberOptions[key] = values[key].clone();
	    } else {
	      this.uberOptions[key] = values[key];
	    }
	  }
	};

	UberMaterial.prototype.clone = function (shallow) {
	  if (!shallow) {
	    return Material.prototype.clone.call(this);
	  }
	  return this.createInstance();
	};

	UberMaterial.prototype.updateUniforms = function () {
	  var self = this;

	  uberOptionNames.forEach(function (p) {
	    if (self.uniforms.hasOwnProperty(p)) {
	      if (self.uberOptions[p] instanceof Color || self.uberOptions[p] instanceof Matrix4) {
	        self.uniforms[p].value = self.uberOptions[p].clone();
	      } else {
	        self.uniforms[p].value = self.uberOptions[p];
	      }
	    }
	  });
	};

	var LAYERS = {
	  DEFAULT: 0, VOLUME: 1, TRANSPARENT: 2, PREPASS_TRANSPARENT: 3, VOLUME_BFPLANE: 4
	};

	Object3D.prototype.resetTransform = function () {
	  this.position.set(0, 0, 0);
	  this.quaternion.set(0, 0, 0, 1);
	  this.scale.set(1, 1, 1);
	};

	// update world matrix of this object and all its ancestors
	Object3D.prototype.updateMatrixWorldRecursive = function () {
	  if (this.parent != null) {
	    this.parent.updateMatrixWorldRecursive();
	  }
	  this.updateMatrixWorld();
	};
	// add object to parent, saving objects' world transform
	Object3D.prototype.addSavingWorldTransform = function () {
	  var _worldMatrixInverse = new Matrix4();

	  return function (object) {
	    if (object instanceof Object3D) {
	      _worldMatrixInverse.getInverse(this.matrixWorld);
	      _worldMatrixInverse.multiply(object.matrixWorld);
	      object.matrix.copy(_worldMatrixInverse);
	      object.matrix.decompose(object.position, object.quaternion, object.scale);
	      this.add(object);
	    }
	  };
	}();

	// render a tiny transparent quad in the center of the screen
	WebGLRenderer.prototype.renderDummyQuad = function () {

	  var _material = new MeshBasicMaterial({ transparent: true, opacity: 0.0, depthWrite: false });

	  var _scene = new Scene();
	  var _quad = new Mesh(new PlaneBufferGeometry(0.01, 0.01), _material);
	  _scene.add(_quad);

	  var _camera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
	  _camera.position.z = 100;

	  return function (renderTarget) {

	    this.render(_scene, _camera, renderTarget);
	  };
	}();

	WebGLRenderer.prototype.renderScreenQuad = function () {

	  var _scene = new Scene();
	  var _quad = new Mesh(new PlaneBufferGeometry(1.0, 1.0));
	  _scene.add(_quad);

	  var _camera = new OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
	  _camera.position.z = 100;

	  return function (material, renderTarget) {

	    _quad.material = material;
	    this.render(_scene, _camera, renderTarget);
	  };
	}();

	WebGLRenderer.prototype.renderScreenQuadFromTex = function () {

	  var _material = new ShaderMaterial({
	    uniforms: {
	      srcTex: { type: 't', value: null },
	      opacity: { type: 'f', value: 1.0 }
	    },
	    vertexShader: 'varying vec2 vUv; ' + 'void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }',
	    fragmentShader: 'varying vec2 vUv; uniform sampler2D srcTex; uniform float opacity;' + 'void main() { vec4 color = texture2D(srcTex, vUv); gl_FragColor = vec4(color.xyz, color.a * opacity); }',
	    transparent: true,
	    depthTest: false,
	    depthWrite: false
	  });

	  return function (srcTex, opacity, renderTarget) {

	    _material.uniforms.srcTex.value = srcTex;
	    _material.transparent = opacity < 1.0;
	    _material.uniforms.opacity.value = opacity;
	    this.renderScreenQuad(_material, renderTarget);
	  };
	}();

	WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function () {

	  var _material = new ShaderMaterial({
	    uniforms: {
	      srcTex: { type: 't', value: null },
	      coef: { type: 'f', value: 1.0 }
	    },
	    vertexShader: 'varying vec2 vUv; ' + 'void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }',
	    fragmentShader: 'varying vec2 vUv; uniform sampler2D srcTex; uniform float coef;' + 'void main() {' + 'vec2 uv = vUv * 2.0 - 1.0;' + 'float r2 = dot(uv, uv);' + 'vec2 tc = uv * (1.0 + coef * r2);' + 'if (!all(lessThan(abs(tc), vec2(1.0)))) discard;' + 'tc = 0.5 * (tc + 1.0);' + 'gl_FragColor = texture2D(srcTex, tc);' + '}',
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  });

	  return function (srcTex, coef, renderTarget) {

	    _material.uniforms.srcTex.value = srcTex;
	    _material.uniforms.coef.value = coef;
	    this.renderScreenQuad(_material, renderTarget);
	  };
	}();

	// TODO: move to a new Camera class?

	/**
	 * @param {number} angle - Field of view in degrees.
	 */
	PerspectiveCamera.prototype.setMinimalFov = function (angle) {
	  if (this.aspect >= 1.0) {
	    this.fov = angle;
	  } else {
	    this.fov = _Math.radToDeg(2 * Math.atan(Math.tan(_Math.degToRad(angle) * 0.5) / this.aspect));
	  }
	};

	/**
	 * @param {number} radius - Radius of bounding sphere in angstroms to fit on screen.
	 * @param {number} angle - Field of view in degrees.
	 */
	PerspectiveCamera.prototype.setDistanceToFit = function (radius, angle) {
	  this.position.z = radius / Math.sin(0.5 * _Math.degToRad(angle));
	};

	function _calcCylinderMatrix(posBegin, posEnd, radius) {
	  var posCenter = posBegin.clone().lerp(posEnd, 0.5);
	  var matScale = new Matrix4();
	  matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);

	  var matRotHalf = new Matrix4();
	  matRotHalf.makeRotationX(Math.PI / 2);

	  var matRotLook = new Matrix4();
	  var vUp = new Vector3(0, 1, 0);
	  matRotLook.lookAt(posCenter, posEnd, vUp);

	  matRotLook.multiply(matRotHalf);
	  matRotLook.multiply(matScale);
	  matRotLook.setPosition(posCenter);
	  return matRotLook;
	}

	function _calcChunkMatrix(eye, target, up, rad) {
	  var matScale = new Matrix4();
	  matScale.makeScale(rad.x, rad.y, 0);

	  var matRotLook = new Matrix4();
	  matRotLook.lookAt(eye, target, up);
	  matRotLook.multiply(matScale);
	  matRotLook.setPosition(eye);

	  return matRotLook;
	}

	function _forEachMeshInGroup(group, process) {
	  function processObj(object) {
	    if (object instanceof Mesh) {
	      process(object);
	    }
	    for (var i = 0, l = object.children.length; i < l; i++) {
	      processObj(object.children[i]);
	    }
	  }
	  processObj(group);
	}

	function _countMeshTriangles(mesh) {
	  var geom = mesh.geometry;
	  if (geom instanceof InstancedBufferGeometry) {
	    var attribs = geom.attributes;
	    for (var property in attribs) {
	      if (attribs.hasOwnProperty(property) && attribs[property] instanceof InstancedBufferAttribute) {
	        var currAttr = attribs[property];
	        var indexSize = geom.index ? geom.index.array.length / 3 : 0;
	        return indexSize * currAttr.array.length / currAttr.itemSize;
	      }
	    }
	    return 0;
	  }
	  if (geom instanceof BufferGeometry) {
	    return geom.index ? geom.index.array.length / 3 : 0;
	  }
	  return geom.faces ? geom.faces.length : 0;
	}

	function _countTriangles(group) {
	  var totalCount = 0;
	  _forEachMeshInGroup(group, function (mesh) {
	    totalCount += _countMeshTriangles(mesh);
	  });
	  return totalCount;
	}

	function _groupHasGeometryToRender(group) {
	  var hasGeoms = false;
	  group.traverse(function (node) {
	    if (node.hasOwnProperty('geometry') || node instanceof CSS2DObject) {
	      hasGeoms = true;
	    }
	  });
	  return hasGeoms;
	}

	function _buildDistorionMesh(widthSegments, heightSegements, coef) {

	  // solve equation r_u = r_d * (1 + k * r_d^2)
	  // for r_d using iterations
	  // takes: r_u^2
	  // returns: r_d / r_u  factor that can be used to distort point coords
	  function calcInverseBarrel(r2) {
	    var epsilon = 1e-5;
	    var prevR2 = 0.0;
	    var curR2 = r2;
	    var dr = 1.0;
	    while (Math.abs(curR2 - prevR2) > epsilon) {
	      dr = 1.0 + coef * curR2;
	      prevR2 = curR2;
	      curR2 = r2 / (dr * dr);
	    }

	    return 1.0 / dr;
	  }

	  var geo = new PlaneBufferGeometry(2.0, 2.0, widthSegments, heightSegements);

	  var pos = geo.getAttribute('position');
	  for (var i = 0; i < pos.count; ++i) {
	    var x = pos.array[3 * i];
	    var y = pos.array[3 * i + 1];
	    var c = calcInverseBarrel(x * x + y * y);
	    pos.setXY(i, c * x, c * y);
	  }

	  return geo;
	}

	BufferAttribute.prototype.copyAtList = function (attribute, indexList) {
	  console.assert(this.itemSize === attribute.itemSize, 'false: BufferAttribute.copyAtList buffers have different item size.');
	  var itemSize = this.itemSize;
	  for (var i = 0, n = indexList.length; i < n; ++i) {
	    for (var j = 0; j < itemSize; ++j) {
	      this.array[i * itemSize + j] = attribute.array[indexList[i] * itemSize + j];
	    }
	  }
	  return this;
	};

	function fillArray(array, value, startIndex, endIndex) {
	  startIndex = typeof startIndex !== 'undefined' ? startIndex : 0;
	  endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length;
	  for (var i = startIndex; i < endIndex; ++i) {
	    array[i] = value;
	  }
	}

	/** @param {THREE.Object3D} object - Parent object. */
	function removeChildren(object) {
	  var children = object.children;
	  for (var i = 0, n = children.length; i < n; ++i) {
	    var child = children[i];
	    child.parent = null;
	    child.dispatchEvent({ type: 'removed' });
	  }
	  object.children = [];
	}

	function clearTree(object) {
	  object.traverse(function (obj) {
	    if (obj instanceof Mesh) {
	      obj.geometry.dispose();
	    }
	  });
	  removeChildren(object);
	}

	function destroyObject(object) {
	  clearTree(object);
	  if (object.parent) {
	    object.parent.remove(object);
	  } else {
	    object.dispatchEvent({ type: 'removed' });
	  }
	}

	function applyTransformsToMeshes(root, mtc) {
	  var meshes = [];

	  var mtcCount = mtc.length;
	  if (mtcCount < 1) {
	    return;
	  }
	  root.traverse(function (object) {
	    if (object instanceof Mesh || object instanceof LineSegments || object instanceof Line) {
	      meshes[meshes.length] = object;
	    }
	  });

	  for (var i = 0, n = meshes.length; i < n; ++i) {
	    var mesh = meshes[i];
	    var parent = mesh.parent;
	    if (!parent) {
	      continue;
	    }
	    mesh.applyMatrix(mtc[0]);
	    for (var j = 1; j < mtcCount; ++j) {
	      var newMesh = new mesh.constructor(mesh.geometry, mesh.material);
	      parent.add(newMesh);
	      newMesh.applyMatrix(mtc[j]);
	    }
	  }
	}

	function processTransparentMaterial(root, material) {

	  if (!(material instanceof UberMaterial)) {
	    return;
	  }

	  var meshes = [];
	  root.traverse(function (object) {
	    if (object instanceof Mesh || object instanceof LineSegments) {
	      meshes[meshes.length] = object;
	    }
	  });

	  for (var i = 0, n = meshes.length; i < n; ++i) {
	    var mesh = meshes[i];
	    var parent = mesh.parent;
	    if (!parent) {
	      continue;
	    }
	    mesh.material.setValues({ prepassTransparancy: false, fakeOpacity: false });
	    mesh.material.needsUpdate = true;
	    mesh.layers.set(LAYERS.TRANSPARENT);

	    // copy of geometry with prepass material
	    var prepassMat = mesh.material.createInstance();
	    prepassMat.setValues({ prepassTransparancy: true, fakeOpacity: false });
	    var prepassMesh = new mesh.constructor(mesh.geometry, prepassMat);
	    prepassMesh.material.transparent = false;
	    prepassMesh.material.needsUpdate = true;
	    prepassMesh.applyMatrix(mesh.matrix);
	    prepassMesh.layers.set(LAYERS.PREPASS_TRANSPARENT);
	    parent.add(prepassMesh);
	  }
	}

	/** Traverse tree and make visible only needed meshes*/
	function makeVisibleMeshes(object, checker) {
	  if (object && object.traverse) {
	    object.traverse(function (obj) {
	      if (obj instanceof Mesh) {
	        obj.visible = checker(obj);
	      }
	    });
	  }
	}

	function applySelectionMaterial(geo) {
	  geo.traverse(function (node) {
	    if ('material' in node) {
	      node.material = node.material.clone(true);
	      // HACK: using z-offset to magically fix selection rendering artifact (on z-sprites)
	      node.material.setValues({ depthFunc: LessEqualDepth, overrideColor: true, fog: false });
	      node.material.setUberOptions({ fixedColor: new Color(0xFFFF00), zOffset: -1e-6 });
	    }
	  });
	}

	function getMiddlePoint(point1, point2, optionalTarget) {
	  var result = optionalTarget || new Vector3();

	  result.set(0, 0, 0);
	  result.addScaledVector(point1, 0.5);
	  result.addScaledVector(point2, 0.5);

	  return result;
	}

	var gfxutils = {
	  calcCylinderMatrix: _calcCylinderMatrix,
	  calcChunkMatrix: _calcChunkMatrix,
	  forEachMeshInGroup: _forEachMeshInGroup,
	  countTriangles: _countTriangles,
	  groupHasGeometryToRender: _groupHasGeometryToRender,
	  buildDistorionMesh: _buildDistorionMesh,
	  RCGroup: RCGroup,
	  fillArray: fillArray,
	  clearTree: clearTree,
	  destroyObject: destroyObject,
	  applyTransformsToMeshes: applyTransformsToMeshes,
	  processTransparentMaterial: processTransparentMaterial,
	  makeVisibleMeshes: makeVisibleMeshes,
	  applySelectionMaterial: applySelectionMaterial,
	  getMiddlePoint: getMiddlePoint,
	  LAYERS: LAYERS
	};

	var _defaultBoundaries = {
	  boundingBox: new Box3(new Vector3(-1, -1, -1), new Vector3(1, 1, 1)),
	  boundingSphere: new Sphere(new Vector3(0, 0, 0), 1)
	};

	function Visual(name, dataSource) {
	  gfxutils.RCGroup.call(this);

	  this.name = name;

	  this._dataSource = dataSource;
	}

	utils.deriveClass(Visual, gfxutils.RCGroup);

	Visual.prototype.release = function () {
	  if (this.parent) {
	    this.parent.remove(this);
	  }
	};

	Visual.prototype.getDataSource = function () {
	  return this._dataSource;
	};

	Visual.prototype.getBoundaries = function () {
	  return _defaultBoundaries;
	};

	/** An indexed list of objects or classes. */
	var EntityList = function () {
	  /**
	   * Create a list of objects.
	   * The objects can be indexed by one or more properties for the later retrieval.
	   *
	   * @param {!Array<Object>=} entities A list of objects to automatically register at creation time.
	   * @param {!Array<string>=} indices A list of property names to use for case-insensitive indexing.
	   *   By default, a single `.id` property is used.
	   * @see EntityList#register
	   */
	  function EntityList() {
	    var _this = this;

	    var entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['id'];
	    classCallCheck(this, EntityList);

	    this._list = [];
	    this._dict = {};
	    this._indices = [].concat(toConsumableArray(indices));
	    this._indices.forEach(function (index) {
	      _this._dict[index] = {};
	    });

	    entities.forEach(function (entity) {
	      return _this.register(entity);
	    });
	  }

	  /**
	   * Add a value to the end of a list.
	   * The list will contain only one copy of the value.
	   *
	   * @param {!Array} list An array.
	   * @param {*} value A value to add.
	   * @see EntityList.unregisterFromList
	   * @see EntityList.registerInDict
	   */


	  createClass(EntityList, [{
	    key: 'register',


	    /**
	     * Add an entity to this list.
	     *
	     * @param {!Object} entity An object or a class to register. The object must include all
	     *   properties specified as indices on construction.
	     * @see EntityList#unregister
	     */
	    value: function register(entity) {
	      var _this2 = this;

	      EntityList.registerInList(this._list, entity);
	      this._indices.forEach(function (index) {
	        EntityList.registerInDict(_this2._dict[index], _ensureArray(entity[index]), entity);
	      });
	    }

	    /**
	     * Remove an entity from this list.
	     *
	     * @param {!Object} entity An object or a class to unregister. The object may be
	     *   missing from the list but it must include all properties specified as indices
	     *   on construction.
	     * @see EntityList#register
	     */

	  }, {
	    key: 'unregister',
	    value: function unregister(entity) {
	      var _this3 = this;

	      EntityList.unregisterFromList(this._list, entity);
	      this._indices.forEach(function (index) {
	        EntityList.unregisterFromDict(_this3._dict[index], _ensureArray(entity[index]), entity);
	      });
	    }

	    /**
	     * An ordered list of all registered entities.
	     * It is a read-only copy, use {@link EntityList#register} and {@link EntityList#unregister}
	     * to modify it.
	     *
	     * @type {!Array<Object>}
	     */

	  }, {
	    key: 'keys',


	    /**
	     * Retrieve a list of keys for the index.
	     *
	     * @param {string=} index One of the indices specified during the list construction. If omitted,
	     *   the first of the indices is used.
	     * @returns {!Array<string>} An unordered list of keys in the index, i.e. particular property
	     *   values for all registered entities.
	     */
	    value: function keys(index) {
	      return Object.keys(this._dict[index || this._indices[0]]);
	    }

	    /**
	     * Retrieve an entity by its key.
	     *
	     * @param {string} key A case-insensitive property value to look-up.
	     * @param {string=} index One of the indices specified during the list construction. If omitted,
	     *   the first of the indices is used.
	     * @returns {Object=} An object registered in the index under the key. If there are multiple
	     *   objects under the same key, the first one is returned.
	     */

	  }, {
	    key: 'get',
	    value: function get$$1(key, index) {
	      var dict = this._dict[index || this._indices[0]];
	      if (dict) {
	        var values = dict[key && key.toLowerCase()];
	        return values && values.length > 0 ? values[0] : undefined;
	      }
	      return undefined;
	    }
	  }, {
	    key: 'all',
	    get: function get$$1() {
	      return [].concat(toConsumableArray(this._list));
	    }

	    /**
	     * The first registered entity.
	     * Use it if you do not care which entity you are referring to.
	     *
	     * @type {Object=}
	     */

	  }, {
	    key: 'first',
	    get: function get$$1() {
	      return this._list[0];
	    }
	  }], [{
	    key: 'registerInList',
	    value: function registerInList(list, value) {
	      if (!list.includes(value)) {
	        list.push(value);
	      }
	    }

	    /**
	     * Remove a value from a list if it is there.
	     *
	     * @param {!Array} list An array.
	     * @param {*} value A value to remove.
	     * @see EntityList.registerInList
	     */

	  }, {
	    key: 'unregisterFromList',
	    value: function unregisterFromList(list, value) {
	      var pos = list.indexOf(value);
	      if (pos !== -1) {
	        list.splice(pos, 1);
	      }
	    }

	    /**
	     * Add a value to a dictionary.
	     * The value may be stored under multiple different keys (aliases).
	     * There might be multiples values stored under the same key.
	     *
	     * @param {!Object<string,*>} dict A dictionary.
	     * @param {!Array<string>} keys An array of keys.
	     * @param {*} value A value to add.
	     * @see EntityList.unregisterFromDict
	     * @see EntityList.registerInList
	     */

	  }, {
	    key: 'registerInDict',
	    value: function registerInDict(dict, keys, value) {
	      keys.forEach(function (key) {
	        key = key.toLowerCase();
	        var list = dict[key] = dict[key] || [];
	        if (!list.includes(value)) {
	          list.push(value);
	        }
	      });
	    }

	    /**
	     * Remove a value from a dictionary.
	     * The value may be stored under multiple different keys (aliases).
	     * There might be multiples values stored under the same key.
	     *
	     * @param {!Object<string,*>} dict A dictionary.
	     * @param {!Array<string>} keys An array of keys.
	     * @param {*} value A value to add.
	     * @see EntityList.registerInDict
	     */

	  }, {
	    key: 'unregisterFromDict',
	    value: function unregisterFromDict(dict, keys, value) {
	      keys.forEach(function (key) {
	        key = key.toLowerCase();
	        var list = dict[key];
	        if (list) {
	          var pos = list.indexOf(value);
	          if (pos !== -1) {
	            list.splice(pos, 1);
	          }
	          if (list.length === 0) {
	            delete dict[key];
	          }
	        }
	      });
	    }
	  }]);
	  return EntityList;
	}();

	function _ensureArray(x) {
	  if (x === null || x === undefined || Array.isArray(x)) {
	    return x;
	  }
	  return [x];
	}

	function makeContextDependent(prototype) {
	  Object.defineProperties(prototype, {
	    logger: {
	      get: function get() {
	        return this.context && this.context.logger ? this.context.logger : logger;
	      }
	    },
	    settings: {
	      get: function get() {
	        return this.context && this.context.settings ? this.context.settings : settings;
	      }
	    }
	  });
	}

	//////////////////////////////////////////////////////////////////////////////


	var CollisionSphere = function () {
	  function CollisionSphere(position, radius) {
	    classCallCheck(this, CollisionSphere);

	    this._position = position;
	    this._radius = radius;
	  }

	  createClass(CollisionSphere, [{
	    key: 'raycast',
	    value: function raycast(raycaster) {

	      var sphere = CollisionSphere._sphere;
	      sphere.set(this._position, this._radius);

	      var p = raycaster.ray.intersectSphere(sphere);
	      if (p) {
	        return {
	          distance: raycaster.ray.origin.distanceTo(p),
	          point: p
	        };
	      }
	      return null;
	    }
	  }]);
	  return CollisionSphere;
	}();

	//////////////////////////////////////////////////////////////////////////////z

	CollisionSphere._sphere = new Sphere();
	var SphereCollisionGeo = function SphereCollisionGeo(base) {
	  return function (_base) {
	    inherits(_class, _base);

	    function _class(count) {
	      var _ref;

	      classCallCheck(this, _class);

	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      var _this = possibleConstructorReturn(this, (_ref = _class.__proto__ || Object.getPrototypeOf(_class)).call.apply(_ref, [this].concat(args)));

	      _this._objects = new Array(count);
	      _this.boundingSphere = null;
	      _this.boundingBox = null;
	      return _this;
	    }

	    createClass(_class, [{
	      key: 'setSphere',
	      value: function setSphere(idx, position, radius) {
	        this._objects[idx] = new CollisionSphere(position, radius);
	      }
	    }, {
	      key: 'raycast',
	      value: function raycast(raycaster, intersects) {
	        // TODO raycast with bounding sphere? How to deal with updates?
	        for (var i = 0, n = this._objects.length; i < n; ++i) {
	          var inters = this._objects[i].raycast(raycaster);
	          if (inters) {
	            inters.chunkIdx = i;
	            intersects.push(inters);
	          }
	        }
	      }
	    }, {
	      key: 'computeBoundingBox',
	      value: function computeBoundingBox() {
	        var objects = this._objects;
	        var boundingBox = this.boundingBox;
	        if (boundingBox === null) {
	          this.boundingBox = boundingBox = new Box3();
	        }
	        boundingBox.makeEmpty();
	        for (var i = 0, n = objects.length; i < n; ++i) {
	          boundingBox.expandByPoint(objects[i]._position);
	        }
	      }
	    }, {
	      key: 'computeBoundingSphere',
	      value: function computeBoundingSphere() {
	        this.computeBoundingBox();
	        var objects = this._objects;
	        var boundingBox = this.boundingBox;
	        // Build bounding sphere
	        var radiusSquared = 0.0;
	        var center = new Vector3();
	        boundingBox.getCenter(center);
	        for (var i = 0, n = objects.length; i < n; ++i) {
	          var pos = objects[i]._position;
	          var lengthSquared = center.distanceToSquared(pos);
	          if (radiusSquared < lengthSquared) {
	            radiusSquared = lengthSquared;
	          }
	        }
	        if (this.boundingSphere === null) {
	          this.boundingSphere = new Sphere();
	        }
	        this.boundingSphere.set(center, Math.sqrt(radiusSquared));
	      }
	    }]);
	    return _class;
	  }(base);
	};

	var tmpColor = new Color();

	var OFFSET_SIZE = 4;
	var COLOR_SIZE = 3;
	var copySubArrays$1 = utils.copySubArrays;

	function setArrayXYZ(arr, idx, x, y, z) {
	  arr[idx] = x;
	  arr[idx + 1] = y;
	  arr[idx + 2] = z;
	}

	function setArrayXYZW(arr, idx, x, y, z, w) {
	  arr[idx] = x;
	  arr[idx + 1] = y;
	  arr[idx + 2] = z;
	  arr[idx + 3] = w;
	}

	var InstancedSpheresGeometry = function (_SphereCollisionGeo) {
	  inherits(InstancedSpheresGeometry, _SphereCollisionGeo);

	  function InstancedSpheresGeometry(spheresCount, sphereComplexity, useZSprites) {
	    classCallCheck(this, InstancedSpheresGeometry);

	    var _this = possibleConstructorReturn(this, (InstancedSpheresGeometry.__proto__ || Object.getPrototypeOf(InstancedSpheresGeometry)).call(this, spheresCount));

	    _this._sphGeometry = useZSprites ? new PlaneBufferGeometry(2, 2, 1, 1) : new SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
	    _this._init(spheresCount, _this._sphGeometry);
	    return _this;
	  }

	  createClass(InstancedSpheresGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, itemPos, itemRad) {
	      setArrayXYZW(this._offsets, itemIdx * OFFSET_SIZE, itemPos.x, itemPos.y, itemPos.z, itemRad);
	      this.setSphere(itemIdx, itemPos, itemRad);
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(itemIdx, colorVal) {
	      tmpColor.set(colorVal);
	      setArrayXYZ(this._colors, itemIdx * COLOR_SIZE, tmpColor.r, tmpColor.g, tmpColor.b);
	    }
	  }, {
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'finishUpdate',
	    value: function finishUpdate() {
	      this.getAttribute('offset').needsUpdate = true;
	      this.getAttribute('color').needsUpdate = true;
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	      // TODO compute bounding box?
	      this.computeBoundingSphere();
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(chunkIndices, value) {
	      var alphaArr = this._alpha;
	      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	        alphaArr[chunkIndices[i]] = value;
	      }
	      this.getAttribute('alphaColor').needsUpdate = true;
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(chunkIndices) {
	      var instanceCount = chunkIndices.length;
	      var geom = new InstancedBufferGeometry();
	      this._init.call(geom, instanceCount, this._sphGeometry);

	      copySubArrays$1(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE);
	      copySubArrays$1(this._colors, geom._colors, chunkIndices, COLOR_SIZE);
	      geom.boundingSphere = this.boundingSphere;
	      geom.boundingBox = this.boundingBox;
	      return [geom];
	    }
	  }, {
	    key: '_init',
	    value: function _init(spheresCount, sphereGeo) {
	      this.copy(sphereGeo);

	      this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE);
	      this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE);
	      var alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);
	      lodash.fill(alpha, 1.0);

	      this.addAttribute('offset', new InstancedBufferAttribute(this._offsets, OFFSET_SIZE, 1));
	      this.addAttribute('color', new InstancedBufferAttribute(this._colors, COLOR_SIZE, 1));
	      this.addAttribute('alphaColor', new InstancedBufferAttribute(alpha, 1, 1));
	    }
	  }]);
	  return InstancedSpheresGeometry;
	}(SphereCollisionGeo(InstancedBufferGeometry));

	/**
	 * This class adds raycasting interface to indexed
	 * THREE.BufferGeometry.
	 * @constructor
	 */

	var RaycastableBufferGeometry = function (_THREE$BufferGeometry) {
	  inherits(RaycastableBufferGeometry, _THREE$BufferGeometry);

	  function RaycastableBufferGeometry() {
	    classCallCheck(this, RaycastableBufferGeometry);
	    return possibleConstructorReturn(this, (RaycastableBufferGeometry.__proto__ || Object.getPrototypeOf(RaycastableBufferGeometry)).call(this));
	  }

	  // This method was copied from three.js

	  createClass(RaycastableBufferGeometry, [{
	    key: 'uvIntersection',
	    value: function uvIntersection(point, p1, p2, p3, uv1, uv2, uv3) {
	      var barycoord = RaycastableBufferGeometry._barycoord;
	      Triangle.barycoordFromPoint(point, p1, p2, p3, barycoord);

	      uv1.multiplyScalar(barycoord.x);
	      uv2.multiplyScalar(barycoord.y);
	      uv3.multiplyScalar(barycoord.z);

	      uv1.add(uv2).add(uv3);
	      return uv1.clone();
	    }
	  }, {
	    key: 'checkIntersection',
	    value: function checkIntersection(object, raycaster, ray, pA, pB, pC, point) {
	      //let intersect;
	      var intersect = ray.intersectTriangle(pA, pB, pC, false, point);

	      if (intersect === null) {
	        return null;
	      }

	      return {
	        point: point.clone()
	      };
	    }
	  }, {
	    key: 'checkBufferGeometryIntersection',
	    value: function checkBufferGeometryIntersection(object, raycaster, ray, position, uv, a, b, c) {
	      var vA = RaycastableBufferGeometry._vA;
	      var vB = RaycastableBufferGeometry._vB;
	      var vC = RaycastableBufferGeometry._vC;
	      var intersectionPoint = RaycastableBufferGeometry._intersectionPoint;

	      vA.fromBufferAttribute(position, a);
	      vB.fromBufferAttribute(position, b);
	      vC.fromBufferAttribute(position, c);

	      var intersection = this.checkIntersection(object, raycaster, ray, vA, vB, vC, intersectionPoint);
	      if (intersection) {
	        if (uv) {
	          var uvA = RaycastableBufferGeometry._uvA;
	          var uvB = RaycastableBufferGeometry._uvB;
	          var uvC = RaycastableBufferGeometry._uvC;

	          uvA.fromBufferAttribute(uv, a);
	          uvB.fromBufferAttribute(uv, b);
	          uvC.fromBufferAttribute(uv, c);
	          intersection.uv = this.uvIntersection(intersectionPoint, vA, vB, vC, uvA, uvB, uvC);
	        }
	        var normal = new Vector3();
	        Triangle.getNormal(vA, vB, vC, normal);
	        intersection.face = new Face3(a, b, c, normal);
	        intersection.faceIndex = a;
	      }

	      return intersection;
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var ray = raycaster.ray;
	      if (this.boundingSphere === null) {
	        this.computeBoundingSphere();
	      }

	      if (raycaster.ray.intersectsSphere(this.boundingSphere) === false) {
	        return;
	      }

	      if (this.boundingBox !== null) {
	        if (ray.intersectsBox(this.boundingBox) === false) {
	          return;
	        }
	      }

	      var a = void 0,
	          b = void 0,
	          c = void 0;
	      var index = this.index;
	      var position = this.attributes.position;
	      var uv = this.attributes.uv;

	      if (index === null) {
	        return;
	      }
	      // indexed buffer geometry
	      for (var i = 0, l = index.count; i < l; i += 3) {
	        a = index.getX(i);
	        b = index.getX(i + 1);
	        c = index.getX(i + 2);

	        var intersection = this.checkBufferGeometryIntersection(this, raycaster, ray, position, uv, a, b, c);

	        if (intersection) {
	          intersection.faceIndex = Math.floor(i / 3); // triangle number in indices buffer semantics
	          intersects.push(intersection);
	        }
	      }
	    }
	  }]);
	  return RaycastableBufferGeometry;
	}(BufferGeometry);

	RaycastableBufferGeometry._vA = new Vector3();
	RaycastableBufferGeometry._vB = new Vector3();
	RaycastableBufferGeometry._vC = new Vector3();
	RaycastableBufferGeometry._uvA = new Vector2();
	RaycastableBufferGeometry._uvB = new Vector2();
	RaycastableBufferGeometry._uvC = new Vector2();
	RaycastableBufferGeometry._barycoord = new Vector3();
	RaycastableBufferGeometry._intersectionPoint = new Vector3();

	var MAX_IDC_16BIT = 65535;
	var VEC_SIZE = 3;
	var tmpColor$1 = new Color();

	/**
	 * This class represents geometry which consists of separate chunks.
	 * Each chunk has same index and similar geometry with equal points and faces count.
	 * Each chunk has by default only one color.
	 * @constructor
	 */

	var ChunkedObjectsGeometry = function (_RaycastableBufferGeo) {
	  inherits(ChunkedObjectsGeometry, _RaycastableBufferGeo);

	  function ChunkedObjectsGeometry(chunkGeo, chunksCount) {
	    classCallCheck(this, ChunkedObjectsGeometry);

	    var _this = possibleConstructorReturn(this, (ChunkedObjectsGeometry.__proto__ || Object.getPrototypeOf(ChunkedObjectsGeometry)).call(this));

	    if (_this.constructor === ChunkedObjectsGeometry) {
	      throw new Error('Can not instantiate abstract class!');
	    }

	    _this._chunkGeo = chunkGeo;

	    _this._init(chunkGeo, chunksCount);
	    return _this;
	  }

	  createClass(ChunkedObjectsGeometry, [{
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'finishUpdate',
	    value: function finishUpdate() {
	      this.getAttribute('position').needsUpdate = true;
	      this.getAttribute('normal').needsUpdate = true;
	      this.getAttribute('color').needsUpdate = true;
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(chunkIdx, colorVal) {
	      tmpColor$1.set(colorVal);
	      var colors = this._colors;
	      var chunkSize = this._chunkSize;
	      for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
	        var idx = i * VEC_SIZE;
	        colors[idx] = tmpColor$1.r;
	        colors[idx + 1] = tmpColor$1.g;
	        colors[idx + 2] = tmpColor$1.b;
	      }
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	      // TODO compute bounding box?
	      this.computeBoundingSphere();
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(chunkIndices, value) {
	      var alphaArr = this._alpha;
	      var chunkSize = this._chunkSize;
	      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	        var left = chunkIndices[i] * chunkSize;
	        lodash.fill(alphaArr, value, left, left + chunkSize);
	      }
	      this.getAttribute('alphaColor').needsUpdate = true;
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var inters = [];
	      get(ChunkedObjectsGeometry.prototype.__proto__ || Object.getPrototypeOf(ChunkedObjectsGeometry.prototype), 'raycast', this).call(this, raycaster, inters);
	      // TODO faceIdx to chunkIdx
	      var facesPerChunk = this._chunkGeo.index.count / 3;
	      for (var i = 0, n = inters.length; i < n; ++i) {
	        if (!inters[i].hasOwnProperty('faceIndex')) {
	          continue;
	        }
	        inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk);
	        intersects.push(inters[i]);
	      }
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(chunkIndices) {
	      var instanceCount = chunkIndices.length;
	      var geom = new BufferGeometry();
	      this._init.call(geom, this._chunkGeo, instanceCount);

	      var srcPos = this._positions;
	      var srcNorm = this._normals;
	      var srcColor = this._colors;

	      var dstPos = geom._positions;
	      var dstNorm = geom._normals;
	      var dstColor = geom._colors;

	      var chunkSize = this._chunkSize * VEC_SIZE;

	      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	        var dstPtOffset = i * chunkSize;
	        var ptIdxBegin = chunkIndices[i] * chunkSize;
	        var ptIdxEnd = ptIdxBegin + chunkSize;
	        dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
	        dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
	        dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
	      }

	      geom.boundingSphere = this.boundingSphere;
	      geom.boundingBox = this.boundingBox;
	      return [geom];
	    }
	  }, {
	    key: '_init',
	    value: function _init(chunkGeo, chunksCount) {
	      var chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
	      var chunkIndex = chunkGeo.index.array;
	      var chunkIndexSize = chunkIndex.length;
	      var pointsCount = this._chunkSize * chunksCount;
	      var use32bitIndex = pointsCount > MAX_IDC_16BIT;
	      var indexSize = chunkIndexSize * chunksCount;
	      var index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
	      this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
	      this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
	      this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
	      var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
	      lodash.fill(alpha, 1.0);

	      for (var i = 0; i < chunksCount; ++i) {
	        var offset = i * chunkIndexSize;
	        var posOffset = i * chunkSize;
	        index.set(chunkIndex, offset);
	        for (var j = 0; j < chunkIndexSize; ++j) {
	          index[offset + j] += posOffset;
	        }
	      }

	      this.setIndex(new BufferAttribute(this._index, 1));
	      this.addAttribute('position', new BufferAttribute(this._positions, VEC_SIZE));
	      this.addAttribute('normal', new BufferAttribute(this._normals, VEC_SIZE));
	      this.addAttribute('color', new BufferAttribute(this._colors, VEC_SIZE));
	      this.addAttribute('alphaColor', new BufferAttribute(alpha, 1));
	    }
	  }]);
	  return ChunkedObjectsGeometry;
	}(RaycastableBufferGeometry);

	var VEC_SIZE$1 = 3;

	var SimpleSpheresGeometry = function (_SphereCollisionGeo) {
	  inherits(SimpleSpheresGeometry, _SphereCollisionGeo);

	  function SimpleSpheresGeometry(spheresCount, sphereComplexity) {
	    classCallCheck(this, SimpleSpheresGeometry);

	    var sphGeometry = new SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);

	    var _this = possibleConstructorReturn(this, (SimpleSpheresGeometry.__proto__ || Object.getPrototypeOf(SimpleSpheresGeometry)).call(this, spheresCount, sphGeometry, spheresCount));

	    var normals = _this._normals;
	    var geoNormals = sphGeometry.attributes.normal.array;
	    var chunkSize = _this._chunkSize;
	    _this._chunkPos = _this._chunkGeo.attributes.position.array;
	    _this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$1);
	    for (var i = 0; i < spheresCount; ++i) {
	      normals.set(geoNormals, chunkSize * VEC_SIZE$1 * i);
	    }
	    return _this;
	  }

	  createClass(SimpleSpheresGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, itemPos, itemRad) {
	      var tmpPos = this._tmpPositions;
	      var chunkSize = this._chunkSize;
	      var geoPos = this._chunkPos;

	      for (var i = 0; i < chunkSize; ++i) {
	        var idx = i * 3;
	        tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
	        tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
	        tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
	      }

	      this._positions.set(tmpPos, chunkSize * itemIdx * VEC_SIZE$1);
	      this.setSphere(itemIdx, itemPos, itemRad);
	    }
	  }]);
	  return SimpleSpheresGeometry;
	}(SphereCollisionGeo(ChunkedObjectsGeometry));

	var VEC_SIZE$2 = 3;
	var centerPos = new Vector3();
	var tmpVector = new Vector3();
	var normMtx = new Matrix3();

	var Simple2CCylindersGeometry = function (_ChunkedObjectsGeomet) {
	  inherits(Simple2CCylindersGeometry, _ChunkedObjectsGeomet);

	  function Simple2CCylindersGeometry(instanceCount, polyComplexity) {
	    classCallCheck(this, Simple2CCylindersGeometry);

	    var cylGeometry = new CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);

	    var _this = possibleConstructorReturn(this, (Simple2CCylindersGeometry.__proto__ || Object.getPrototypeOf(Simple2CCylindersGeometry)).call(this, cylGeometry, 2 * instanceCount));

	    var chunkSize = _this._chunkSize;
	    _this._chunkPos = _this._chunkGeo.attributes.position.array;
	    _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
	    _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$2);
	    return _this;
	  }

	  createClass(Simple2CCylindersGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, botPos, topPos, itemRad) {
	      var chunkSize = this._chunkSize;
	      var firstOffset = chunkSize * 2 * itemIdx * VEC_SIZE$2;
	      var secondOffset = firstOffset + chunkSize * VEC_SIZE$2;

	      var tmpArray = this._tmpVector;
	      var geoPos = this._chunkPos;
	      var geoNorm = this._chunkNorms;

	      centerPos.lerpVectors(botPos, topPos, 0.5);
	      var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
	      normMtx.getNormalMatrix(mtx1);

	      var idx = void 0;
	      for (var i = 0; i < chunkSize; ++i) {
	        idx = i * VEC_SIZE$2;
	        tmpVector.fromArray(geoPos, idx);
	        tmpVector.applyMatrix4(mtx1);
	        tmpVector.toArray(tmpArray, idx);
	      }
	      this._positions.set(tmpArray, firstOffset);

	      // now shift center to get another part of the cylinder
	      centerPos.sub(botPos);
	      for (var _i = 0; _i < chunkSize; ++_i) {
	        idx = _i * VEC_SIZE$2;
	        tmpArray[idx] += centerPos.x;
	        tmpArray[idx + 1] += centerPos.y;
	        tmpArray[idx + 2] += centerPos.z;
	      }
	      this._positions.set(tmpArray, secondOffset);

	      for (var _i2 = 0; _i2 < chunkSize; ++_i2) {
	        idx = _i2 * VEC_SIZE$2;
	        tmpVector.fromArray(geoNorm, idx);
	        tmpVector.applyMatrix3(normMtx);
	        tmpVector.toArray(tmpArray, idx);
	      }
	      this._normals.set(tmpArray, firstOffset);
	      this._normals.set(tmpArray, secondOffset);
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(itemIdx, colorVal1, colorVal2) {
	      var first = 2 * itemIdx;
	      get(Simple2CCylindersGeometry.prototype.__proto__ || Object.getPrototypeOf(Simple2CCylindersGeometry.prototype), 'setColor', this).call(this, first, colorVal1);

	      var second = first + 1;
	      get(Simple2CCylindersGeometry.prototype.__proto__ || Object.getPrototypeOf(Simple2CCylindersGeometry.prototype), 'setColor', this).call(this, second, colorVal2);
	    }
	  }]);
	  return Simple2CCylindersGeometry;
	}(ChunkedObjectsGeometry);

	var MAX_POINTS_COUNT_16BIT = 65536;
	var PTS_PER_TRIANGLE = 3;

	var CylinderBufferGeometry$1 = function (_THREE$BufferGeometry) {
	  inherits(CylinderBufferGeometry$$1, _THREE$BufferGeometry);

	  function CylinderBufferGeometry$$1(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
	    classCallCheck(this, CylinderBufferGeometry$$1);

	    var _this = possibleConstructorReturn(this, (CylinderBufferGeometry$$1.__proto__ || Object.getPrototypeOf(CylinderBufferGeometry$$1)).call(this));

	    var thetaStart = 0;
	    var thetaLength = 2 * Math.PI;

	    _this.type = 'CylinderBufferGeometry';

	    _this.parameters = {
	      radiusTop: radiusTop,
	      radiusBottom: radiusBottom,
	      height: height,
	      radialSegments: radialSegments,
	      heightSegments: heightSegments,
	      openEnded: openEnded
	    };

	    var hasTop = openEnded === false && radiusTop > 0;
	    var hasBottom = openEnded === false && radiusBottom > 0;
	    var vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
	    var facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;

	    var heightHalf = height / 2;

	    /* eslint-disable no-magic-numbers */
	    var positions = new BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
	    var normals = new BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
	    var indices = new Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
	    /* eslint-enable no-magic-numbers */

	    var uvs = new BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
	    console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, 'false: Cylinder Geometry has too many vertices (65536 max).');

	    var currVtxIdx = 0;
	    var currFaceIdx = 0;
	    var tanTheta = -(radiusBottom - radiusTop) / height;

	    // setup cylinder data
	    for (var y = 0; y <= heightSegments; y++) {
	      // faces
	      if (y !== heightSegments) {
	        for (var i = 0; i < radialSegments; i++) {
	          var v1 = currVtxIdx + i;
	          var v2 = currVtxIdx + radialSegments + i;
	          var v3 = currVtxIdx + radialSegments + (i + 1) % radialSegments;
	          var v4 = currVtxIdx + (i + 1) % radialSegments;

	          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
	          currFaceIdx++;
	          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
	          currFaceIdx++;
	        }
	      }

	      // vertices
	      var v = y / heightSegments;
	      var radius = v * (radiusBottom - radiusTop) + radiusTop;

	      for (var x = 0; x < radialSegments; x++) {

	        var u = x / radialSegments;

	        var vx = radius * Math.sin(u * thetaLength + thetaStart);
	        var vy = v * height - heightHalf;
	        var vz = radius * Math.cos(u * thetaLength + thetaStart);

	        var normal = new Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();

	        positions.setXYZ(currVtxIdx, vx, vy, vz);
	        normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
	        uvs.setXY(currVtxIdx, u, v);
	        ++currVtxIdx;
	      }
	    }

	    // top cap
	    if (hasTop) {
	      var startTIdx = currVtxIdx;
	      var lastIdx = currVtxIdx + radialSegments;
	      for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
	        var currSrcIdx = currVtxIdx - radialSegments;
	        positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
	        normals.setXYZ(currVtxIdx, 0, 1, 0);
	        uvs.setXY(currVtxIdx, 1, 1);

	        var nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
	        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
	        currFaceIdx++;
	        currVtxIdx++;
	      }

	      positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
	      normals.setXYZ(currVtxIdx, 0, 1, 0);
	      uvs.setXY(currVtxIdx, 1, 1);
	      ++currVtxIdx;
	    }

	    // bottom cap
	    if (hasBottom) {
	      var startBIdx = currVtxIdx;
	      var lastBIdx = currVtxIdx + radialSegments;
	      for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
	        var currSrcBIdx = fBIdx;
	        positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
	        normals.setXYZ(currVtxIdx, 0, -1, 0);
	        uvs.setXY(currVtxIdx, 0, 0);

	        var nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
	        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
	        currFaceIdx++;
	        currVtxIdx++;
	      }

	      positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
	      normals.setXYZ(currVtxIdx, 0, -1, 0);
	      uvs.setXY(currVtxIdx, 0, 0);
	    }

	    _this.setIndex(indices);
	    _this.addAttribute('position', positions);
	    _this.addAttribute('normal', normals);
	    _this.addAttribute('uv', uvs);
	    return _this;
	  }

	  createClass(CylinderBufferGeometry$$1, [{
	    key: 'clone',
	    value: function clone() {

	      var parameters = this.parameters;

	      return new CylinderBufferGeometry$$1(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
	    }
	  }]);
	  return CylinderBufferGeometry$$1;
	}(BufferGeometry);

	var tmpColor$2 = new Color();
	var invMatrix = new Matrix4();

	var OFFSET_SIZE$1 = 4;
	var COLOR_SIZE$1 = 3;
	var copySubArrays$2 = utils.copySubArrays;

	function setArrayXYZ$1(arr, idx, x, y, z) {
	  arr[idx] = x;
	  arr[idx + 1] = y;
	  arr[idx + 2] = z;
	}

	function setArrayXYZW$1(arr, idx, x, y, z, w) {
	  arr[idx] = x;
	  arr[idx + 1] = y;
	  arr[idx + 2] = z;
	  arr[idx + 3] = w;
	}

	function sortNumber(a, b) {
	  return a - b;
	}

	function _prepareCylinderInfo(chunkIndices) {
	  chunkIndices.sort(sortNumber);
	  var chunksIdx = [];
	  var cylinderInfo = [];
	  for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	    var val = chunkIndices[i];
	    var even = (val | 0) % 2 === 0;
	    var newPar = {
	      first: false,
	      second: false
	    };
	    if (even) {
	      newPar.first = true;
	      newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1;
	      if (newPar.second) {
	        ++i;
	      }
	    } else {
	      newPar.second = true;
	    }
	    chunksIdx.push(Math.floor(val / 2));
	    cylinderInfo.push(newPar);
	  }
	  return { indices: chunksIdx, cylinderInfo: cylinderInfo };
	}

	function _assignOpacity(cylinderInfo, color1, color2) {
	  for (var i = 0, n = cylinderInfo.length; i < n; ++i) {
	    var info = cylinderInfo[i];
	    if (!info.first) {
	      color1[COLOR_SIZE$1 * i] = -0.5;
	    }
	    if (!info.second) {
	      color2[COLOR_SIZE$1 * i] = -0.5;
	    }
	  }
	}

	var Instanced2CCylindersGeometry = function (_THREE$InstancedBuffe) {
	  inherits(Instanced2CCylindersGeometry, _THREE$InstancedBuffe);

	  function Instanced2CCylindersGeometry(instanceCount, polyComplexity, useZSprites, openEnded) {
	    classCallCheck(this, Instanced2CCylindersGeometry);

	    var _this = possibleConstructorReturn(this, (Instanced2CCylindersGeometry.__proto__ || Object.getPrototypeOf(Instanced2CCylindersGeometry)).call(this));

	    _this._useZSprites = useZSprites;
	    _this._cylGeometry = useZSprites ? new PlaneBufferGeometry(2, 2, 1, 1) : new CylinderBufferGeometry$1(1, 1, 1.0, Math.max(3, polyComplexity), 2, openEnded);
	    _this._init(instanceCount, _this._cylGeometry, _this._useZSprites);

	    _this._collisionGeo = new Simple2CCylindersGeometry(instanceCount, 3);
	    return _this;
	  }

	  createClass(Instanced2CCylindersGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, botPos, topPos, itemRad) {
	      var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
	      var me = matrix.elements;
	      var mtxOffset = itemIdx * OFFSET_SIZE$1;

	      this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);
	      setArrayXYZW$1(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
	      setArrayXYZW$1(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
	      setArrayXYZW$1(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);

	      if (this._useZSprites) {
	        invMatrix.getInverse(matrix);
	        me = invMatrix.elements;
	        setArrayXYZW$1(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
	        setArrayXYZW$1(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
	        setArrayXYZW$1(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
	      }
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(itemIdx, colorVal1, colorVal2) {
	      var colorIdx = itemIdx * COLOR_SIZE$1;
	      tmpColor$2.set(colorVal1);
	      setArrayXYZ$1(this._color1, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
	      tmpColor$2.set(colorVal2);
	      setArrayXYZ$1(this._color2, colorIdx, tmpColor$2.r, tmpColor$2.g, tmpColor$2.b);
	    }
	  }, {
	    key: 'computeBoundingSphere',
	    value: function computeBoundingSphere() {
	      this._collisionGeo.computeBoundingSphere();
	      this.boundingSphere = this._collisionGeo.boundingSphere;
	    }
	  }, {
	    key: 'computeBoundingBox',
	    value: function computeBoundingBox() {
	      this._collisionGeo.computeBoundingBox();
	      this.boundingBox = this._collisionGeo.boundingBox;
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      this._collisionGeo.raycast(raycaster, intersects);
	    }
	  }, {
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'finishUpdate',
	    value: function finishUpdate() {
	      this.getAttribute('matVector1').needsUpdate = true;
	      this.getAttribute('matVector2').needsUpdate = true;
	      this.getAttribute('matVector3').needsUpdate = true;
	      this.getAttribute('color').needsUpdate = true;
	      this.getAttribute('color2').needsUpdate = true;
	      this.getAttribute('alphaColor').needsUpdate = true;
	      if (this._useZSprites) {
	        this.getAttribute('invmatVector1').needsUpdate = true;
	        this.getAttribute('invmatVector2').needsUpdate = true;
	        this.getAttribute('invmatVector3').needsUpdate = true;
	      }

	      this._collisionGeo.finishUpdate();
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	      // TODO compute bounding box?
	      this.computeBoundingSphere();
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(chunkIndices, value) {
	      var alphaArr = this._alpha;
	      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	        alphaArr[Math.floor(chunkIndices[i] / 2)] = value;
	      }
	      this.getAttribute('alphaColor').needsUpdate = true;
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(chunkIndices) {
	      var info = _prepareCylinderInfo(chunkIndices);
	      var cylinderIndices = info.indices;
	      var instanceCount = cylinderIndices.length;
	      var geom = new InstancedBufferGeometry();
	      this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);

	      copySubArrays$2(this._matVector1, geom._matVector1, cylinderIndices, OFFSET_SIZE$1);
	      copySubArrays$2(this._matVector2, geom._matVector2, cylinderIndices, OFFSET_SIZE$1);
	      copySubArrays$2(this._matVector3, geom._matVector3, cylinderIndices, OFFSET_SIZE$1);

	      if (this._useZSprites) {
	        copySubArrays$2(this._invmatVector1, geom._invmatVector1, cylinderIndices, OFFSET_SIZE$1);
	        copySubArrays$2(this._invmatVector2, geom._invmatVector2, cylinderIndices, OFFSET_SIZE$1);
	        copySubArrays$2(this._invmatVector3, geom._invmatVector3, cylinderIndices, OFFSET_SIZE$1);
	      }

	      copySubArrays$2(this._color1, geom._color1, cylinderIndices, COLOR_SIZE$1);
	      copySubArrays$2(this._color2, geom._color2, cylinderIndices, COLOR_SIZE$1);
	      _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);
	      geom.boundingSphere = this.boundingSphere;
	      geom.boundingBox = this.boundingBox;
	      return [geom];
	    }
	  }, {
	    key: '_init',
	    value: function _init(instanceCount, cylinderGeo, useZSprites) {
	      this.copy(cylinderGeo);
	      this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
	      this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
	      this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
	      this._color1 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$1);
	      this._color2 = utils.allocateTyped(Float32Array, instanceCount * COLOR_SIZE$1);
	      var alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);
	      lodash.fill(alpha, 1.0);

	      this.addAttribute('matVector1', new InstancedBufferAttribute(this._matVector1, OFFSET_SIZE$1, 1));
	      this.addAttribute('matVector2', new InstancedBufferAttribute(this._matVector2, OFFSET_SIZE$1, 1));
	      this.addAttribute('matVector3', new InstancedBufferAttribute(this._matVector3, OFFSET_SIZE$1, 1));
	      this.addAttribute('color', new InstancedBufferAttribute(this._color1, COLOR_SIZE$1, 1));
	      this.addAttribute('color2', new InstancedBufferAttribute(this._color2, COLOR_SIZE$1, 1));

	      this.addAttribute('alphaColor', new InstancedBufferAttribute(this._alpha, 1, 1));

	      if (useZSprites) {
	        this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
	        this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);
	        this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * OFFSET_SIZE$1);

	        this.addAttribute('invmatVector1', new InstancedBufferAttribute(this._invmatVector1, OFFSET_SIZE$1, 1));
	        this.addAttribute('invmatVector2', new InstancedBufferAttribute(this._invmatVector2, OFFSET_SIZE$1, 1));
	        this.addAttribute('invmatVector3', new InstancedBufferAttribute(this._invmatVector3, OFFSET_SIZE$1, 1));
	      }
	    }
	  }]);
	  return Instanced2CCylindersGeometry;
	}(InstancedBufferGeometry);

	var VEC_SIZE$3 = 3;
	var TRI_SIZE = 3;
	var tmpPrev = new Vector3();
	var tmpNext = new Vector3();

	function _createExtrudedChunkGeometry(shape, ringsCount) {
	  var geo = new BufferGeometry();
	  var ptsCount = shape.length;
	  var totalPts = ptsCount * ringsCount;
	  var type = totalPts <= 65536 ? Uint16Array : Uint32Array;
	  var facesPerChunk = (ringsCount - 1) * ptsCount * 2;
	  var indices = new BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);

	  var currVtxIdx = 0;
	  var currFaceIdx = 0;
	  for (var y = 0; y < ringsCount; y++) {
	    // faces
	    if (y !== ringsCount - 1) {
	      for (var i = 0; i < ptsCount; i++) {
	        var v1 = currVtxIdx + i;
	        var v2 = currVtxIdx + ptsCount + i;
	        var v3 = currVtxIdx + ptsCount + (i + 1) % ptsCount;
	        var v4 = currVtxIdx + (i + 1) % ptsCount;

	        indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
	        currFaceIdx++;
	        indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
	        currFaceIdx++;
	      }
	    }

	    currVtxIdx += ptsCount;
	  }

	  geo.setIndex(indices);
	  var pos = utils.allocateTyped(Float32Array, totalPts * VEC_SIZE$3);
	  geo.addAttribute('position', new BufferAttribute(pos, VEC_SIZE$3));

	  geo._positions = shape;

	  return geo;
	}

	var ExtrudedObjectsGeometry = function (_ChunkedObjectsGeomet) {
	  inherits(ExtrudedObjectsGeometry, _ChunkedObjectsGeomet);

	  function ExtrudedObjectsGeometry(shape, ringsCount, chunksCount) {
	    classCallCheck(this, ExtrudedObjectsGeometry);

	    var chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);

	    var _this = possibleConstructorReturn(this, (ExtrudedObjectsGeometry.__proto__ || Object.getPrototypeOf(ExtrudedObjectsGeometry)).call(this, chunkGeo, chunksCount));

	    _this._ringsCount = ringsCount;

	    var tmpShape = _this._tmpShape = [];
	    for (var i = 0; i < shape.length; ++i) {
	      tmpShape[i] = new Vector3();
	    }
	    return _this;
	  }

	  createClass(ExtrudedObjectsGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, matrices) {
	      var shape = this._chunkGeo._positions;
	      var ptsCount = shape.length;
	      var innerPtIdx = 0;
	      var chunkStartIdx = ptsCount * this._ringsCount * itemIdx * VEC_SIZE$3;

	      var positions = this._positions;
	      var normals = this._normals;

	      var tmpShape = this._tmpShape;
	      for (var i = 0, n = matrices.length; i < n; ++i) {
	        var mtx = matrices[i];

	        for (var j = 0; j < ptsCount; ++j) {
	          tmpShape[j].copy(shape[j]).applyMatrix4(mtx);
	        }

	        for (var _j = 0; _j < ptsCount; ++_j) {
	          var point = tmpShape[_j];
	          var nextPt = tmpShape[(_j + 1) % ptsCount];
	          var prevPt = tmpShape[(_j + ptsCount - 1) % ptsCount];

	          var vtxIdx = chunkStartIdx + innerPtIdx;

	          positions[vtxIdx] = point.x;
	          positions[vtxIdx + 1] = point.y;
	          positions[vtxIdx + 2] = point.z;

	          tmpPrev.subVectors(point, prevPt).normalize();
	          tmpNext.subVectors(point, nextPt).normalize();
	          tmpPrev.add(tmpNext).normalize();

	          normals[vtxIdx] = tmpPrev.x;
	          normals[vtxIdx + 1] = tmpPrev.y;
	          normals[vtxIdx + 2] = tmpPrev.z;
	          innerPtIdx += VEC_SIZE$3;
	        }
	      }
	    }
	  }]);
	  return ExtrudedObjectsGeometry;
	}(ChunkedObjectsGeometry);

	var MAX_IDC_16BIT$1 = 65535;
	var VERTEX_PER_SEGMENT = 4;
	var POS_SIZE = 4;
	var DIR_SIZE = 3;
	var COL_SIZE = 3;
	var tmpColor$3 = new Color();
	var direction = new Vector3();

	function setArrayXYZ$2(arr, idx, x, y, z) {
	  arr[idx] = x;
	  arr[idx + 1] = y;
	  arr[idx + 2] = z;
	}

	function setArrayXYZW$2(arr, idx, x, y, z, w) {
	  arr[idx] = x;
	  arr[idx + 1] = y;
	  arr[idx + 2] = z;
	  arr[idx + 3] = w;
	}

	function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
	  var start = startSegmentIdx * VERTEX_PER_SEGMENT;
	  var end = start + segmentsCount * VERTEX_PER_SEGMENT;
	  return arr.subarray(start * elemSize, end * elemSize);
	}

	/**
	 * This class represents lines geometry which consists of screen-aligned narrow quad of variable width.
	 *
	 * @constructor
	 *
	 * @param {number}  segmentsCount   Number of segments per chunk.
	 * collision geometry.
	 */

	var ThickLinesGeometry = function (_THREE$BufferGeometry) {
	  inherits(ThickLinesGeometry, _THREE$BufferGeometry);

	  function ThickLinesGeometry(segmentsCount) {
	    classCallCheck(this, ThickLinesGeometry);

	    var _this = possibleConstructorReturn(this, (ThickLinesGeometry.__proto__ || Object.getPrototypeOf(ThickLinesGeometry)).call(this));

	    _this._initVertices(segmentsCount);
	    return _this;
	  }

	  createClass(ThickLinesGeometry, [{
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'finishUpdate',
	    value: function finishUpdate() {
	      this.getAttribute('position').needsUpdate = true;
	      this.getAttribute('color').needsUpdate = true;
	      this.getAttribute('alphaColor').needsUpdate = true;
	      this.getAttribute('direction').needsUpdate = true;
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(segmentIdx, colorVal) {
	      tmpColor$3.set(colorVal);
	      var idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
	      setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
	      idx += COL_SIZE;
	      setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
	      idx += COL_SIZE;
	      setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
	      idx += COL_SIZE;
	      setArrayXYZ$2(this._colors, idx, tmpColor$3.r, tmpColor$3.g, tmpColor$3.b);
	    }
	  }, {
	    key: 'setSegment',
	    value: function setSegment(segmentIdx, pos1, pos2) {
	      direction.subVectors(pos1, pos2);
	      direction.normalize();
	      var positions = this._positions;
	      var directions = this._directions;
	      var idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
	      var dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
	      setArrayXYZW$2(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
	      setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
	      idx += POS_SIZE;
	      dirIdx += DIR_SIZE;
	      setArrayXYZW$2(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
	      setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
	      idx += POS_SIZE;
	      dirIdx += DIR_SIZE;
	      setArrayXYZW$2(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
	      setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
	      idx += POS_SIZE;
	      dirIdx += DIR_SIZE;
	      setArrayXYZW$2(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
	      setArrayXYZ$2(directions, dirIdx, direction.x, direction.y, direction.z);
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(startSegIdx, endSegIdx, value) {
	      var start = startSegIdx * VERTEX_PER_SEGMENT;
	      var end = endSegIdx * VERTEX_PER_SEGMENT;
	      lodash.fill(this.alpha, value, end, start);
	      this.getAttribute('alphaColor').needsUpdate = true;
	    }
	  }, {
	    key: 'getSubsetSegments',
	    value: function getSubsetSegments(startSegmentIdx, segmentsCount) {
	      return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
	    }
	  }, {
	    key: 'getSubsetColors',
	    value: function getSubsetColors(startSegmentIdx, segmentsCount) {
	      return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
	    }
	  }, {
	    key: 'getSubsetOpacities',
	    value: function getSubsetOpacities(startSegmentIdx, segmentsCount) {
	      return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
	    }
	  }, {
	    key: 'getNumVertexPerSegment',
	    value: function getNumVertexPerSegment() {
	      return VERTEX_PER_SEGMENT;
	    }
	  }, {
	    key: 'getPositionSize',
	    value: function getPositionSize() {
	      return POS_SIZE;
	    }
	  }, {
	    key: 'setSegments',
	    value: function setSegments(startSegmentIdx, positions) {
	      var startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
	      if (positions instanceof Array && positions.length === 2) {
	        this._positions.set(positions[0], startPos);
	        var startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
	        this._directions.set(positions[1], startDir); // dirs are geo part of vertex
	      } else {
	        this._positions.set(positions, startPos);
	      }
	    }
	  }, {
	    key: 'setColors',
	    value: function setColors(startSegmentIdx, colors) {
	      var start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
	      this._colors.set(colors, start);
	    }
	  }, {
	    key: '_initVertices',
	    value: function _initVertices(segmentsCount) {
	      this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
	      var pointsCount = this._buffersSize;
	      var use32bitIndex = pointsCount > MAX_IDC_16BIT$1;
	      this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
	      this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
	      this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
	      this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
	      var alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
	      lodash.fill(alpha, 1.0);

	      var index = this._index;
	      var indexOffset = 0;
	      var pointOffset = 0;
	      for (var j = 0; j < segmentsCount; j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
	        index[indexOffset] = pointOffset;
	        index[indexOffset + 1] = pointOffset + 1;
	        index[indexOffset + 2] = pointOffset + 3;
	        index[indexOffset + 3] = pointOffset;
	        index[indexOffset + 4] = pointOffset + 2;
	        index[indexOffset + 5] = pointOffset + 3;
	      }
	      this.setIndex(new BufferAttribute(this._index, 1));

	      this.addAttribute('position', new BufferAttribute(this._positions, POS_SIZE));
	      this.addAttribute('color', new BufferAttribute(this._colors, COL_SIZE));
	      this.addAttribute('alphaColor', new BufferAttribute(alpha, 1));
	      this.addAttribute('direction', new BufferAttribute(this._directions, DIR_SIZE));
	    }
	  }]);
	  return ThickLinesGeometry;
	}(BufferGeometry);

	/**
	 * This class represents geometry which consists lines. This can build bounding volumes
	 * @constructor
	 *
	 * @param {number}  segmentsCount   Number of segments per chunk.
	 */

	var LinesGeometry = function (_BaseLinesGeometry) {
	  inherits(LinesGeometry, _BaseLinesGeometry);

	  function LinesGeometry(segmentsCount) {
	    classCallCheck(this, LinesGeometry);
	    return possibleConstructorReturn(this, (LinesGeometry.__proto__ || Object.getPrototypeOf(LinesGeometry)).call(this, segmentsCount));
	  }

	  createClass(LinesGeometry, [{
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'computeBoundingSphere',
	    value: function computeBoundingSphere() {
	      var boundingBox = this.boundingBox;
	      // Build bounding sphere
	      var radiusSquared = 0.0;
	      var center = new Vector3();
	      if (boundingBox) {
	        boundingBox.getCenter(center);
	      }
	      var positions = this._positions;
	      var sphere = this.boundingSphere || new Sphere();
	      var size = this._positions.length;
	      var pos = new Vector3();
	      var posSize = this.getPositionSize();
	      for (var i = 0; i < size; i += posSize) {
	        pos.set(positions[i], positions[i + 1], positions[i + 2]);
	        var lengthSquared = center.distanceToSquared(pos);
	        if (radiusSquared < lengthSquared) {
	          radiusSquared = lengthSquared;
	        }
	      }
	      sphere.set(center, Math.sqrt(radiusSquared));
	      this.boundingSphere = sphere;
	    }
	  }, {
	    key: 'computeBoundingBox',
	    value: function computeBoundingBox() {
	      var positions = this._positions;
	      var box = new Box3();
	      var size = this._positions.length;
	      var tmpVec = new Vector3();
	      var posSize = this.getPositionSize();
	      for (var i = 0; i < size; i += posSize) {
	        tmpVec.set(positions[i], positions[i + 1], positions[i + 2]);
	        box.expandByPoint(tmpVec);
	      }
	      this.boundingBox = box;
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	      // TODO compute bounding box?
	      this.computeBoundingSphere();
	    }
	  }]);
	  return LinesGeometry;
	}(ThickLinesGeometry);

	var VEC_SIZE$4 = 3;
	var tmpVector$1 = new Vector3();
	var normMtx$1 = new Matrix3();

	var CylinderCollisionGeo = function (_ChunkedObjectsGeomet) {
	  inherits(CylinderCollisionGeo, _ChunkedObjectsGeomet);

	  function CylinderCollisionGeo(instanceCount, polyComplexity) {
	    classCallCheck(this, CylinderCollisionGeo);

	    var cylGeometry = new CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);

	    var _this = possibleConstructorReturn(this, (CylinderCollisionGeo.__proto__ || Object.getPrototypeOf(CylinderCollisionGeo)).call(this, cylGeometry, instanceCount));

	    var chunkSize = _this._chunkSize;
	    _this._chunkPos = _this._chunkGeo.attributes.position.array;
	    _this._chunkNorms = _this._chunkGeo.attributes.normal.array;
	    _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE$4);
	    return _this;
	  }

	  createClass(CylinderCollisionGeo, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, botPos, topPos, itemRad) {
	      var chunkSize = this._chunkSize;
	      var itemOffset = chunkSize * itemIdx * VEC_SIZE$4;

	      var tmpArray = this._tmpVector;
	      var geoPos = this._chunkPos;
	      var geoNorm = this._chunkNorms;

	      var mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
	      normMtx$1.getNormalMatrix(mtx1);
	      var idx = void 0;
	      for (var i = 0; i < chunkSize; ++i) {
	        idx = i * VEC_SIZE$4;
	        tmpVector$1.fromArray(geoPos, idx);
	        tmpVector$1.applyMatrix4(mtx1);
	        tmpVector$1.toArray(tmpArray, idx);
	      }
	      this._positions.set(tmpArray, itemOffset);

	      for (var _i = 0; _i < chunkSize; ++_i) {
	        idx = _i * VEC_SIZE$4;
	        tmpVector$1.fromArray(geoNorm, idx);
	        tmpVector$1.applyMatrix3(normMtx$1);
	        tmpVector$1.toArray(tmpArray, idx);
	      }
	      this._normals.set(tmpArray, itemOffset);
	    }
	  }]);
	  return CylinderCollisionGeo;
	}(ChunkedObjectsGeometry);

	var COLLISION_RAD = 0.1;

	/**
	 * This class represents geometry which consists of separate chunks.
	 * Each chunk has same index and similar geometry with equal points and faces count.
	 * Each chunk has by default only one color.
	 * @constructor
	 *
	 * @param {number}  chunksCount     Total chunks count.
	 * @param {number}  segmentsCount   Number of segments per chunk.
	 * @param {boolean} enableCollision Enable or disable collision where each segment is
	 *                                  a collidable cylinder.
	 * collision geometry.
	 */

	var ChunkedLinesGeometry = function (_LinesGeometry) {
	  inherits(ChunkedLinesGeometry, _LinesGeometry);

	  function ChunkedLinesGeometry(chunksCount, segmentsCount, enableCollision) {
	    classCallCheck(this, ChunkedLinesGeometry);

	    var _this = possibleConstructorReturn(this, (ChunkedLinesGeometry.__proto__ || Object.getPrototypeOf(ChunkedLinesGeometry)).call(this, chunksCount * segmentsCount));

	    _this._init(segmentsCount);
	    _this._collisionGeo = enableCollision ? new CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
	    return _this;
	  }

	  createClass(ChunkedLinesGeometry, [{
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'computeBoundingSphere',
	    value: function computeBoundingSphere() {
	      var collisionGeo = this._collisionGeo;
	      if (collisionGeo) {
	        collisionGeo.computeBoundingSphere();
	        this.boundingSphere = collisionGeo.boundingSphere;
	        return;
	      }
	      get(ChunkedLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(ChunkedLinesGeometry.prototype), 'computeBoundingSphere', this).call(this);
	    }
	  }, {
	    key: 'computeBoundingBox',
	    value: function computeBoundingBox() {
	      var collisionGeo = this._collisionGeo;
	      if (collisionGeo) {
	        collisionGeo.computeBoundingBox();
	        this.boundingBox = collisionGeo.boundingBox;
	        return;
	      }
	      get(ChunkedLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(ChunkedLinesGeometry.prototype), 'computeBoundingBox', this).call(this);
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var collisionGeo = this._collisionGeo;
	      if (!collisionGeo) {
	        return;
	      }
	      var segCount = this._chunkSize;
	      this._collisionGeo.raycast(raycaster, intersects);
	      for (var i = 0, n = intersects.length; i < n; ++i) {
	        var chunkIdx = intersects[i].chunkIdx;
	        if (chunkIdx === undefined) {
	          continue;
	        }
	        chunkIdx = chunkIdx / segCount | 0;
	        intersects[i].chunkIdx = chunkIdx;
	      }
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(chunkIdx, colorVal) {
	      var chunkSize = this._chunkSize;
	      for (var i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
	        get(ChunkedLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(ChunkedLinesGeometry.prototype), 'setColor', this).call(this, i, colorVal);
	      }
	    }
	  }, {
	    key: 'setSegment',
	    value: function setSegment(chunkIdx, segIdx, pos1, pos2) {
	      var chunkSize = this._chunkSize;
	      var idx = chunkIdx * chunkSize + segIdx;
	      get(ChunkedLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(ChunkedLinesGeometry.prototype), 'setSegment', this).call(this, idx, pos1, pos2);
	      if (this._collisionGeo) {
	        this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD);
	      }
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	      // TODO compute bounding box?
	      this.computeBoundingSphere();
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity(chunkIndices, value) {
	      var chunkSize = this._chunkSize;
	      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	        var left = chunkIndices[i] * chunkSize;
	        get(ChunkedLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(ChunkedLinesGeometry.prototype), 'setOpacity', this).call(this, left, left + chunkSize - 1, value);
	      }
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(chunkIndices) {
	      var instanceCount = chunkIndices.length;
	      var chunkSize = this._chunkSize;
	      var subset = new ChunkedLinesGeometry(instanceCount, chunkSize, false);
	      for (var i = 0, n = chunkIndices.length; i < n; ++i) {
	        var dstPtOffset = i * chunkSize;
	        var startSegIdx = chunkIndices[i] * chunkSize;
	        subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
	        subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
	      }

	      subset.boundingSphere = this.boundingSphere;
	      subset.boundingBox = this.boundingBox;
	      return [subset];
	    }
	  }, {
	    key: '_init',
	    value: function _init(chunkSize) {
	      this._chunkSize = chunkSize;
	    }
	  }]);
	  return ChunkedLinesGeometry;
	}(LinesGeometry);

	var COLLISION_RAD$1 = 0.3;
	var tmpVector$2 = new Vector3();

	var TwoColorLinesGeometry = function (_LinesGeometry) {
	  inherits(TwoColorLinesGeometry, _LinesGeometry);

	  function TwoColorLinesGeometry(segmentsCount) {
	    classCallCheck(this, TwoColorLinesGeometry);

	    var _this = possibleConstructorReturn(this, (TwoColorLinesGeometry.__proto__ || Object.getPrototypeOf(TwoColorLinesGeometry)).call(this, segmentsCount * 2));

	    _this._init(segmentsCount);
	    _this._collisionGeo = new Simple2CCylindersGeometry(segmentsCount, 3);
	    return _this;
	  }

	  createClass(TwoColorLinesGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, botPos, topPos) {
	      this._collisionGeo.setItem(itemIdx, botPos, topPos, COLLISION_RAD$1);
	      var offset = 2 * itemIdx; // there are two points per segment
	      tmpVector$2.lerpVectors(botPos, topPos, 0.5);
	      get(TwoColorLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(TwoColorLinesGeometry.prototype), 'setSegment', this).call(this, offset, botPos, tmpVector$2);
	      get(TwoColorLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(TwoColorLinesGeometry.prototype), 'setSegment', this).call(this, offset + 1, tmpVector$2, topPos);
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(itemIdx, colorVal1, colorVal2) {
	      var offset = 2 * itemIdx; // there are two points per segment
	      get(TwoColorLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(TwoColorLinesGeometry.prototype), 'setColor', this).call(this, offset, colorVal1);
	      get(TwoColorLinesGeometry.prototype.__proto__ || Object.getPrototypeOf(TwoColorLinesGeometry.prototype), 'setColor', this).call(this, offset + 1, colorVal2);
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      if (this._collisionGeo) {
	        this._collisionGeo.raycast(raycaster, intersects);
	      }
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(segmentIndices) {
	      var instanceCount = segmentIndices.length;
	      var subset = new TwoColorLinesGeometry(instanceCount, false);
	      for (var i = 0, n = instanceCount; i < n; ++i) {
	        var startSegIdx = segmentIndices[i];
	        subset.setSegments(i, this.getSubsetSegments(startSegIdx, 1));
	        subset.setColors(i, this.getSubsetColors(startSegIdx, 1));
	      }

	      subset.boundingSphere = this.boundingSphere;
	      subset.boundingBox = this.boundingBox;
	      return [subset];
	    }
	  }, {
	    key: '_init',
	    value: function _init(segmentsCount) {
	      this._segCounts = segmentsCount * 2;
	    }
	  }]);
	  return TwoColorLinesGeometry;
	}(LinesGeometry);

	var vectors = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 1, 0), new Vector3(0, -1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
	var vecCount = vectors.length;
	var tempPos1 = new Vector3();
	var tempPos2 = new Vector3();
	// const VEC_SIZE = 3;

	var CrossGeometry = function (_SphereCollisionGeo) {
	  inherits(CrossGeometry, _SphereCollisionGeo);

	  function CrossGeometry(chunksCount) {
	    classCallCheck(this, CrossGeometry);
	    return possibleConstructorReturn(this, (CrossGeometry.__proto__ || Object.getPrototypeOf(CrossGeometry)).call(this, chunksCount, chunksCount, vecCount / 2 | 0, false));
	  }

	  createClass(CrossGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, itemPos, itemRad) {
	      this.setSphere(itemIdx, itemPos, itemRad);

	      //const offset = itemIdx * this._chunkSize;
	      for (var i = 0; i < vecCount / 2; ++i) {
	        var first = i * 2;
	        tempPos1.x = itemPos.x + vectors[first].x * itemRad;
	        tempPos1.y = itemPos.y + vectors[first].y * itemRad;
	        tempPos1.z = itemPos.z + vectors[first].z * itemRad;
	        var second = first + 1;
	        tempPos2.x = itemPos.x + vectors[second].x * itemRad;
	        tempPos2.y = itemPos.y + vectors[second].y * itemRad;
	        tempPos2.z = itemPos.z + vectors[second].z * itemRad;
	        this.setSegment(itemIdx, i, tempPos1, tempPos2);
	      }
	    }
	  }]);
	  return CrossGeometry;
	}(SphereCollisionGeo(ChunkedLinesGeometry));

	var POS_RAD_SIZE = 4;
	var COLOR_SIZE$2 = 3;
	var tmpColor$4 = new Color();

	/**
	 * This is a base class for isosurface algorithms.
	 * @param spheresCount - number of atoms/spheres
	 * @param opts - geometry specific options
	 * @constructor
	 */

	var IsoSurfaceGeometry = function (_RaycastableBufferGeo) {
	  inherits(IsoSurfaceGeometry, _RaycastableBufferGeo);

	  function IsoSurfaceGeometry(spheresCount, opts) {
	    classCallCheck(this, IsoSurfaceGeometry);

	    var _this = possibleConstructorReturn(this, (IsoSurfaceGeometry.__proto__ || Object.getPrototypeOf(IsoSurfaceGeometry)).call(this));

	    _this._opts = opts;
	    _this.zClip = _this._opts.zClip;
	    _this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
	    _this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE$2);
	    return _this;
	  }

	  createClass(IsoSurfaceGeometry, [{
	    key: 'setItem',
	    value: function setItem(chunkIdx, pos, radius) {
	      var posRad = this._posRad;
	      var idx = POS_RAD_SIZE * chunkIdx;
	      posRad[idx++] = pos.x;
	      posRad[idx++] = pos.y;
	      posRad[idx++] = pos.z;
	      posRad[idx] = radius;
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(chunkIdx, colorVal) {
	      tmpColor$4.set(colorVal);
	      var colors = this._colors;
	      var idx = COLOR_SIZE$2 * chunkIdx;
	      colors[idx++] = tmpColor$4.r;
	      colors[idx++] = tmpColor$4.g;
	      colors[idx] = tmpColor$4.b;
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	      // TODO compute bounding box?
	      this.computeBoundingSphere();
	    }
	  }, {
	    key: 'finishUpdate',
	    value: function finishUpdate() {
	      this._build();
	    }
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity() {
	      // not implemented
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast() {}
	  }, {
	    key: 'getSubset',
	    value: function getSubset() {
	      return [];
	    }
	  }]);
	  return IsoSurfaceGeometry;
	}(RaycastableBufferGeometry);

	/**
	 * Class for marching cube
	 * Stores 8 points and 8 float values are stored together in linear array
	 * Int values for has intersection or not - in integer32 linear array
	 * Int values for bits flags - in integer32 linear array
	 *
	 */

	var IsoSurfaceMarchCube = function () {
	  function IsoSurfaceMarchCube() {
	    classCallCheck(this, IsoSurfaceMarchCube);

	    this.pointsValuesLinear = null;
	    this.hasIntersection = null;
	    this.bitsInside = null;
	  }

	  createClass(IsoSurfaceMarchCube, [{
	    key: 'create',
	    value: function create(numCellsPerSide) {
	      var vx7000000 = 0x7000000;
	      var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;
	      if (n3 > vx7000000) {
	        throw new Error('Too large cube dimension: lead to memory huge uasge');
	      }
	      this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
	      this.hasIntersection = utils.allocateTyped(Int32Array, n3);
	      this.bitsInside = utils.allocateTyped(Int32Array, n3);
	      return 0;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.bitsInside = null;
	      this.hasIntersection = null;
	      this.pointsValuesLinear = null;
	    }
	  }]);
	  return IsoSurfaceMarchCube;
	}();

	/* eslint-disable no-magic-numbers */


	IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];

	var edgeTable = [0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0];

	function _voxelGradientFast(v, point, grad) {
	  var g = v.getValue(point.x, point.y, point.z);
	  grad.set(g[0], g[1], g[2]);
	}

	// Helper class GridCell

	var GridCell = function GridCell() {
	  classCallCheck(this, GridCell);

	  this._arrSize = 8;
	  this.p = new Array(this._arrSize);
	  this.g = new Array(this._arrSize);
	  this.val = new Array(this._arrSize);
	  for (var i = 0; i < this._arrSize; ++i) {
	    this.p[i] = new Vector3();
	    this.g[i] = new Vector3();
	  }
	  this.cubeIndex = 0;
	};

	// Helper class Triangle


	var Triangle$1 = function Triangle$$1() {
	  classCallCheck(this, Triangle$$1);

	  this.a = {
	    p: new Vector3(),
	    n: new Vector3()
	  };

	  this.b = {
	    p: new Vector3(),
	    n: new Vector3()
	  };

	  this.c = {
	    p: new Vector3(),
	    n: new Vector3()
	  };
	};

	function createArray(arrSize) {

	  var arr = new Array(arrSize);
	  for (var i = 0; i < arrSize; ++i) {
	    arr[i] = new Vector3();
	  }

	  return arr;
	}

	var IsoSurface = function () {
	  function IsoSurface() {
	    classCallCheck(this, IsoSurface);

	    this._numTriangles = 0;
	    this._numVertices = 0;
	    this._position = [];
	    this._normals = [];
	    this._colors = null;
	    this._indices = [];
	    this._volumetricData = null;
	    this._xAxis = new Vector3();
	    this._yAxis = new Vector3();
	    this._zAxis = new Vector3();
	    this._xDir = new Vector3();
	    this._yDir = new Vector3();
	    this._zDir = new Vector3();
	  }

	  createClass(IsoSurface, [{
	    key: '_prepareAxesAndDirs',
	    value: function _prepareAxesAndDirs() {
	      var volData = this._volumetricData;

	      var cellSize = volData.getCellSize();

	      // calculate cell axes
	      var xAxis = this._xAxis;
	      var yAxis = this._yAxis;
	      var zAxis = this._zAxis;
	      var xDir = this._xDir;
	      var yDir = this._yDir;
	      var zDir = this._zDir;
	      //    volData.cellAxes(xAxis, yAxis, zAxis);
	      //    volData.cellDirs(xDir, yDir, zDir);

	      xAxis.set(cellSize.x, 0, 0);
	      yAxis.set(0, cellSize.y, 0);
	      zAxis.set(0, 0, cellSize.z);

	      xDir.set(1, 0, 0);
	      yDir.set(0, 1, 0);
	      zDir.set(0, 0, 1);

	      // flip normals if coordinate system is in the wrong handedness
	      var tmp = new Vector3();
	      tmp.crossVectors(xDir, yDir);
	      if (tmp.dot(zDir) < 0) {
	        xDir.negate();
	        yDir.negate();
	        zDir.negate();
	      }

	      // check that the grid is in the all-positive octant of the coordinate system
	      if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
	        return false;
	      }

	      // check that the grid is axis-aligned
	      // TODO This is a VMD way. Is it correct in our case to compare with floating zero?
	      return !(xAxis.y !== 0 || xAxis.z !== 0 || yAxis.x !== 0 || yAxis.z !== 0 || zAxis.x !== 0 || zAxis.y !== 0);
	    }
	  }, {
	    key: '_vertexInterp',
	    value: function _vertexInterp(isoLevel, grid, ind1, ind2, vertex, normal) {
	      var p1 = grid.p[ind1];
	      var p2 = grid.p[ind2];
	      var n1 = grid.g[ind1];
	      var n2 = grid.g[ind2];
	      var valP1 = grid.val[ind1];
	      var valP2 = grid.val[ind2];
	      var isoDiffP1 = isoLevel - valP1;
	      var diffValP2P1 = valP2 - valP1;

	      var mu = 0.0;

	      if (Math.abs(diffValP2P1) > 0.0) {
	        mu = isoDiffP1 / diffValP2P1;
	      }
	      mu = mu > 1.0 ? 1.0 : mu;
	      vertex.lerpVectors(p1, p2, mu);
	      normal.lerpVectors(n1, n2, mu);
	    }
	  }, {
	    key: '_polygonize',
	    value: function _polygonize(grid, isoLevel, triangles) {
	      var cubeIndex = grid.cubeIndex;
	      var i = 0;
	      var arrSize = IsoSurface._arrSize;
	      var firstIndices = IsoSurface._firstIndices;
	      var secondIndices = IsoSurface._secondIndices;
	      var vertexList = IsoSurface._vertexList;
	      var normalList = IsoSurface._normalList;

	      for (; i < arrSize; ++i) {
	        if (edgeTable[cubeIndex] & 1 << i) {
	          this._vertexInterp(isoLevel, grid, firstIndices[i], secondIndices[i], vertexList[i], normalList[i]);
	        }
	      }

	      var triCount = 0;
	      var triTblIdx = cubeIndex * 16;
	      var triTable = IsoSurface._triTable;

	      for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
	        triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]]);
	        triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]]);

	        triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i + 1]]);
	        triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i + 1]]);

	        triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i + 2]]);
	        triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i + 2]]);
	        ++triCount;
	      }

	      return triCount;
	    }
	  }, {
	    key: '_doGridPosNorms',
	    value: function _doGridPosNorms(isoValue, step, appendSimple) {
	      var vol = this._volumetricData;
	      var volData = this._volumetricData.getData();
	      var dim = vol.getDimensions();
	      var xSize = dim[0];
	      var ySize = dim[1];
	      var zSize = dim[2];
	      var stepX = step * vol.getStrideX();
	      var stepY = step * vol.getStrideY();
	      var stepZ = step * vol.getStrideZ();

	      var gc = new GridCell();
	      var gcVal = gc.val;
	      var gcValSize = gc.val.length;
	      var additions = [new Vector3(0, 0, 0), // 0
	      new Vector3(step, 0, 0), // 1
	      new Vector3(step, step, 0), // 2
	      new Vector3(0, step, 0), // 3
	      new Vector3(0, 0, step), // 4
	      new Vector3(step, 0, step), // 5
	      new Vector3(step, step, step), // 6
	      new Vector3(0, step, step) // 7
	      ];

	      var tmpTriCount = 5;
	      var triangles = new Array(tmpTriCount);
	      for (var j = 0; j < tmpTriCount; ++j) {
	        triangles[j] = new Triangle$1();
	      }

	      var appendVertex = void 0;
	      var self = this;
	      var positions = this._position;
	      var normals = this._normals;
	      if (appendSimple) {
	        // Special case for axis-aligned grid with positive unit vector normals
	        appendVertex = function () {
	          var axis = new Vector3(self._xAxis.x, self._yAxis.y, self._zAxis.z);
	          return function (triVertex) {
	            var vertex = triVertex.p.clone();
	            vertex.multiply(axis);
	            positions.push(vertex.add(self._origin));
	            normals.push(triVertex.n.clone());
	          };
	        }();
	      } else {
	        appendVertex = function () {
	          var posMtx = new Matrix3();
	          posMtx.set(self._xAxis.x, self._yAxis.x, self._zAxis.x, self._xAxis.y, self._yAxis.y, self._zAxis.y, self._xAxis.z, self._yAxis.z, self._zAxis.z);
	          var normMtx = new Matrix3();
	          normMtx.set(self._xDir.x, self._yDir.x, self._zDir.x, self._xDir.y, self._yDir.y, self._zDir.y, self._xDir.z, self._yDir.z, self._zDir.z);

	          return function (triVertex) {
	            positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self._origin));
	            normals.push(triVertex.n.clone().applyMatrix3(normMtx));
	          };
	        }();
	      }
	      var indices = this._indices;

	      var globTriCount = 0;

	      for (var z = 0; z < zSize - step; z += step) {
	        for (var y = 0; y < ySize - step; y += step) {
	          var idx = vol.getDirectIdx(0, y, z);
	          for (var x = 0; x < xSize - step; x += step, idx += stepX) {
	            /* eslint-disable no-multi-spaces */
	            /* eslint-disable computed-property-spacing */
	            gcVal[0] = volData[idx];
	            gcVal[1] = volData[idx + stepX];
	            gcVal[3] = volData[idx + stepY];
	            gcVal[2] = volData[idx + stepX + stepY];
	            gcVal[4] = volData[idx + stepZ];
	            gcVal[5] = volData[idx + stepX + stepZ];
	            gcVal[7] = volData[idx + stepY + stepZ];
	            gcVal[6] = volData[idx + stepX + stepY + stepZ];
	            /* eslint-enable no-multi-spaces */
	            /* eslint-enable computed-property-spacing */

	            // Determine the index into the edge table which
	            // tells us which vertices are inside of the surface
	            var cubeIndex = 0;
	            var i = 0;
	            for (; i < gcValSize; ++i) {
	              if (gcVal[i] < isoValue) {
	                cubeIndex |= 1 << i;
	              }
	            }

	            if (edgeTable[cubeIndex] === 0) {
	              continue;
	            }

	            gc.cubeIndex = cubeIndex;
	            for (i = 0; i < gcValSize; ++i) {
	              gc.p[i].set(x + additions[i].x, y + additions[i].y, z + additions[i].z);
	              _voxelGradientFast(this._gradient, gc.p[i], gc.g[i]);
	            }

	            // calculate vertices and facets for this cube,
	            // calculate normals by interpolating between the negated
	            // normalized volume gradients for the 8 reference voxels
	            var triCount = this._polygonize(gc, isoValue, triangles);
	            globTriCount += triCount;

	            //append triangles using different techniques
	            for (i = 0; i < triCount; ++i) {
	              indices.push(this._numTriangles * 3);
	              indices.push(this._numTriangles * 3 + 1);
	              indices.push(this._numTriangles * 3 + 2);
	              ++this._numTriangles;

	              appendVertex(triangles[i].a);
	              appendVertex(triangles[i].b);
	              appendVertex(triangles[i].c);
	            }
	          }
	        }
	      }

	      return globTriCount;
	    }
	  }, {
	    key: 'compute',
	    value: function compute(volData, origin, isoValue, step) {
	      this._volumetricData = volData;
	      this._origin = origin;

	      this._gradient = volData.computeGradient();

	      this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
	    }
	  }, {
	    key: '_remapIndices',
	    value: function _remapIndices(vertexMap, idcCount) {
	      var indices = this._indices;
	      var newIndices = utils.allocateTyped(Uint32Array, idcCount);
	      for (var i = 0; i < idcCount; ++i) {
	        indices[i] = vertexMap[indices[i]];
	        newIndices[i] = indices[i];
	      }
	      this._indices = newIndices;
	    }
	  }, {
	    key: '_remapVertices',
	    value: function _remapVertices(vertices, normals, count) {
	      var newPositions = utils.allocateTyped(Float32Array, count * 3);
	      var newNormals = utils.allocateTyped(Float32Array, count * 3);
	      for (var i = 0; i < count; ++i) {
	        var pos = vertices[i];
	        newPositions[i * 3] = pos.x;
	        newPositions[i * 3 + 1] = pos.y;
	        newPositions[i * 3 + 2] = pos.z;
	        var norm = normals[i].normalize();
	        newNormals[i * 3] = norm.x;
	        newNormals[i * 3 + 1] = norm.y;
	        newNormals[i * 3 + 2] = norm.z;
	      }
	      this._position = newPositions;
	      this._normals = newNormals;
	    }
	  }, {
	    key: 'vertexFusion',
	    value: function vertexFusion(offset, len) {
	      var faceVer = this._indices.length;
	      var vertices = this._position;
	      var normals = this._normals;
	      var oldVerCount = vertices.length | 0;
	      if (faceVer === 0 || oldVerCount === 0) {
	        return;
	      }
	      var vMap = utils.allocateTyped(Uint32Array, oldVerCount);
	      vMap[0] = 0;
	      var newVer = 1;

	      var i = 1;
	      for (; i < oldVerCount; ++i) {
	        var start = newVer - offset < 0 ? 0 : newVer - offset;
	        var end = start + len > newVer ? newVer : start + len;
	        var matchedIndex = -1;

	        for (var j = start; j < end; ++j) {
	          // TODO we are comparing floating number for exact match. What is wrong with us?
	          if (vertices[i].equals(vertices[j])) {
	            matchedIndex = j;
	            break;
	          }
	        }

	        if (matchedIndex !== -1) {
	          vMap[i] = matchedIndex;
	        } else {
	          vertices[newVer].copy(vertices[i]);
	          normals[newVer].copy(normals[i]);
	          vMap[i] = newVer;
	          ++newVer;
	        }
	      }

	      this._remapIndices(vMap, faceVer);
	      this._remapVertices(vertices, normals, newVer);
	    }

	    /// Assign per-vertex colors from a volumetric texture map (same dimensions as the original volumetric data).
	    /// Along with color dominating atom is determined for each vertex
	    /// and vertices with atom out of "visible" subset get filtered out.
	    /// XXX only handles orthogonal volumes currently

	  }, {
	    key: 'setColorVolTex',
	    value: function setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
	      var i = void 0,
	          idx = void 0;
	      var numVerts = this._position.length / 3;
	      var vertices = this._position;
	      var origin = this._origin;
	      var dim = this._volumetricData.getDimensions();
	      var xs = dim[0] - 1;
	      var ys = dim[1] - 1;
	      var zs = dim[2] - 1;

	      var colorData = colorMap.getData();
	      var strideX = colorMap.getStrideX();
	      var strideY = colorMap.getStrideY();
	      var strideZ = colorMap.getStrideZ();

	      var atomWeightData = void 0;
	      var atomStrideX = void 0;
	      var atomStrideY = void 0;
	      var atomStrideZ = void 0;

	      if (visibilitySelector !== null) {
	        atomWeightData = atomWeightMap.getData();
	        atomStrideX = atomWeightMap.getStrideX();
	        atomStrideY = atomWeightMap.getStrideY();
	        atomStrideZ = atomWeightMap.getStrideZ();
	      }

	      var xInv = 1.0 / this._xAxis.x;
	      var yInv = 1.0 / this._yAxis.y;
	      var zInv = 1.0 / this._zAxis.z;

	      var atomLookup = [];
	      var atomWeights = [];
	      var colors = utils.allocateTyped(Float32Array, numVerts * 3);

	      function interp(mu, idx1, idx2, c) {
	        c[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
	        c[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
	        c[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
	      }

	      function collectWeight(ai, coefX, coefY, coefZ) {
	        var a = atomMap[ai]; // atomWeightMap is a scalar field, so index into atom map should be the same
	        if (a != null) {
	          atomLookup[a._index] = a;
	          var w = coefX * coefY * coefZ * atomWeightData[ai];
	          if (typeof atomWeights[a._index] === 'undefined') {
	            atomWeights[a._index] = w;
	          } else {
	            atomWeights[a._index] += w;
	          }
	        }
	      }

	      var vMap = utils.allocateTyped(Int32Array, numVerts);
	      var newVerCount = 0;

	      for (i = 0; i < numVerts; i++) {
	        var ind = i * 3;
	        var vx = (vertices[ind] - origin.x) * xInv;
	        var vy = (vertices[ind + 1] - origin.y) * yInv;
	        var vz = (vertices[ind + 2] - origin.z) * zInv;
	        var x = Math.min(Math.max(vx, 0), xs) | 0;
	        var y = Math.min(Math.max(vy, 0), ys) | 0;
	        var z = Math.min(Math.max(vz, 0), zs) | 0;

	        var mux = vx - x;
	        var muy = vy - y;
	        var muz = vz - z;

	        if (visibilitySelector != null) {
	          // collect atom weights
	          atomLookup = [];
	          atomWeights = [];
	          idx = atomWeightMap.getDirectIdx(x, y, z);
	          collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
	          collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
	          collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
	          collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
	          collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
	          collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
	          collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
	          collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz);

	          // find dominant atom
	          var maxWeight = 0.0;
	          var dominantIdx = -1;
	          for (var atomIdx in atomWeights) {
	            if (atomWeights[atomIdx] > maxWeight) {
	              dominantIdx = atomIdx;
	              maxWeight = atomWeights[atomIdx];
	            }
	          }

	          if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
	            // this vertex doesn't belong to visible subset and will be skipped
	            vMap[i] = -1;
	            continue;
	          }
	        }

	        vMap[i] = newVerCount++;

	        // color tri-linear interpolation
	        var dx = x < xs ? strideX : 0;
	        var dy = y < ys ? strideY : 0;
	        var dz = z < zs ? strideZ : 0;

	        var c0 = [0, 0, 0];
	        var c1 = [0, 0, 0];
	        var c2 = [0, 0, 0];
	        var c3 = [0, 0, 0];

	        idx = colorMap.getDirectIdx(x, y, z);
	        interp(mux, idx, idx + dx, c0);
	        interp(mux, idx + dy, idx + dx + dy, c1);
	        interp(mux, idx + dz, idx + dx + dz, c2);
	        interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);

	        var cz0 = [0, 0, 0];
	        cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
	        cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
	        cz0[2] = (1 - muy) * c0[2] + muy * c1[2];

	        var cz1 = [0, 0, 0];
	        cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
	        cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
	        cz1[2] = (1 - muy) * c2[2] + muy * c3[2];

	        colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
	        colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
	        colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
	      }
	      this._colors = colors;

	      if (visibilitySelector != null) {
	        // shift visible vertices towards beginning of array
	        for (i = 0; i < numVerts; ++i) {
	          var j = vMap[i];
	          if (j < 0) {
	            continue;
	          }

	          // assert: j <= i
	          this._position[j * 3] = this._position[i * 3];
	          this._position[j * 3 + 1] = this._position[i * 3 + 1];
	          this._position[j * 3 + 2] = this._position[i * 3 + 2];
	          this._normals[j * 3] = this._normals[i * 3];
	          this._normals[j * 3 + 1] = this._normals[i * 3 + 1];
	          this._normals[j * 3 + 2] = this._normals[i * 3 + 2];
	          this._colors[j * 3] = this._colors[i * 3];
	          this._colors[j * 3 + 1] = this._colors[i * 3 + 1];
	          this._colors[j * 3 + 2] = this._colors[i * 3 + 2];
	        }

	        // rebuild index list
	        var numTriangles = this._indices.length / 3;
	        var newTriCount = 0;
	        for (i = 0; i < numTriangles; ++i) {
	          var i0 = vMap[this._indices[3 * i]];
	          var i1 = vMap[this._indices[3 * i + 1]];
	          var i2 = vMap[this._indices[3 * i + 2]];
	          if (i0 >= 0 && i1 >= 0 && i2 >= 0) {
	            this._indices[3 * newTriCount] = i0;
	            this._indices[3 * newTriCount + 1] = i1;
	            this._indices[3 * newTriCount + 2] = i2;
	            ++newTriCount;
	          }
	        }

	        // shrink arrays to data size
	        this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
	        this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
	        this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
	        this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
	      }
	    }
	  }, {
	    key: 'toMesh',
	    value: function toMesh() {
	      var geo = new BufferGeometry();
	      geo.setIndex(new BufferAttribute(this._indices, 1));
	      geo.addAttribute('position', new BufferAttribute(this._position, 3));
	      geo.addAttribute('normal', new BufferAttribute(this._normals, 3));
	      geo.addAttribute('color', new BufferAttribute(this._colors, 3));
	      geo.computeBoundingSphere();
	      return geo;
	    }
	  }]);
	  return IsoSurface;
	}();

	IsoSurface._triTable = IsoSurfaceMarchCube.prototype.striIndicesMarchCube;
	IsoSurface._arrSize = 12;
	IsoSurface._firstIndices = [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3];
	IsoSurface._secondIndices = [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7];
	IsoSurface._vertexList = createArray(IsoSurface._arrSize);
	IsoSurface._normalList = createArray(IsoSurface._arrSize);

	/**
	 * This is a base class for volumetric maps based isosurface algorithms.
	 * @param spheresCount - number of atoms/spheres
	 * @param opts - geometry specific options
	 * @constructor
	 */

	var VolumeSurfaceGeometry = function (_IsoSurfaceGeometry) {
	  inherits(VolumeSurfaceGeometry, _IsoSurfaceGeometry);

	  function VolumeSurfaceGeometry(spheresCount, opts) {
	    classCallCheck(this, VolumeSurfaceGeometry);
	    return possibleConstructorReturn(this, (VolumeSurfaceGeometry.__proto__ || Object.getPrototypeOf(VolumeSurfaceGeometry)).call(this, spheresCount, opts));
	  }

	  createClass(VolumeSurfaceGeometry, [{
	    key: '_build',
	    value: function _build() {
	      var params = this._opts;
	      this.numVoxels = [128, 128, 128];
	      this.xAxis = new Vector3(1.0, 0.0, 0.0);
	      this.yAxis = new Vector3(0.0, 1.0, 0.0);
	      this.zAxis = new Vector3(0.0, 0.0, 1.0);

	      this.origin = new Vector3(0.0, 0.0, 0.0);
	      this._visibilitySelector = params.visibilitySelector;

	      this._calcSurface(params);
	    }
	  }, {
	    key: '_findMinMax',
	    value: function _findMinMax(posRadArray) {
	      var itemSize = 4;
	      var itemsCount = posRadArray.length / itemSize;
	      var maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
	      var minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
	      for (var i = 1; i < itemsCount; ++i) {
	        var ind = i * itemSize;

	        for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
	          var tmpVal = posRadArray[ind + itemIdx];
	          maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
	          minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
	        }
	      }
	      return { maxPosRad: maxPosRad, minPosRad: minPosRad };
	    }
	  }, {
	    key: '_findNumVoxels',
	    value: function _findNumVoxels(posRadArray, params) {
	      var numVoxels = this.numVoxels;
	      var minMaxValues = this._findMinMax(posRadArray);
	      var minCoordRad = minMaxValues.minPosRad;
	      var maxCoordRad = minMaxValues.maxPosRad;

	      // minrad
	      if (minCoordRad[3] > 4.0) {
	        params.gridSpacing *= minCoordRad[3];
	      }

	      var gridPadding = params.radScale * maxCoordRad[3] * 1.7;
	      var padRad = gridPadding;
	      padRad = 0.65 * Math.sqrt(4.0 / 3.0 * Math.PI * padRad * padRad * padRad);
	      gridPadding = Math.max(gridPadding, padRad);

	      var i = 0;
	      for (; i < 3; ++i) {
	        minCoordRad[i] -= gridPadding;
	        maxCoordRad[i] += gridPadding;
	      }

	      for (i = 0; i < 3; ++i) {
	        numVoxels[i] = Math.ceil((maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing);
	      }
	      this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
	      this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
	      this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;

	      this.origin.x = minCoordRad[0];
	      this.origin.y = minCoordRad[1];
	      this.origin.z = minCoordRad[2];

	      return { bbox: minMaxValues, dim: numVoxels };
	    }
	  }, {
	    key: '_makeSurface',
	    value: function _makeSurface(surface, params) {
	      var isoSurf = new IsoSurface();
	      isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
	      isoSurf.vertexFusion(9, 9); //normalization is included

	      if (isoSurf._numTriangles > 0) {
	        isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
	        this.setIndex(new BufferAttribute(isoSurf._indices, 1));
	        this.addAttribute('position', new BufferAttribute(isoSurf._position, 3));
	        this.addAttribute('normal', new BufferAttribute(isoSurf._normals, 3));
	        this.addAttribute('color', new BufferAttribute(isoSurf._colors, 3));
	      } else {
	        // geometry should have at least empty position attributes to be processed in wireframe mode by three.js
	        this.addAttribute('position', new BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
	      }
	    }
	  }, {
	    key: '_calcSurface',
	    value: function _calcSurface(params) {
	      var packedArrays = {
	        posRad: this._posRad,
	        colors: this._colors,
	        atoms: this._opts.atoms
	      };

	      if (packedArrays.posRad.length === 0) {
	        return;
	      }
	      var boundaries = this._findNumVoxels(packedArrays.posRad, params);

	      var box = new Box3(this.origin, new Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));
	      var surface = this._computeSurface(packedArrays, box, boundaries, params);

	      this._makeSurface(surface, params);
	    }
	  }]);
	  return VolumeSurfaceGeometry;
	}(IsoSurfaceGeometry);

	var Volume$1 = chem.Volume;

	/**
	 * This class implements 'quick' isosurface geometry generation algorithm.
	 * @param spheresCount - number of atoms/spheres
	 * @param opts - geometry specific options
	 * @constructor
	 */

	var QuickSurfGeometry = function (_VolumeSurfaceGeometr) {
	  inherits(QuickSurfGeometry, _VolumeSurfaceGeometr);

	  function QuickSurfGeometry(spheresCount, opts) {
	    classCallCheck(this, QuickSurfGeometry);
	    return possibleConstructorReturn(this, (QuickSurfGeometry.__proto__ || Object.getPrototypeOf(QuickSurfGeometry)).call(this, spheresCount, opts));
	  }

	  createClass(QuickSurfGeometry, [{
	    key: '_computeSurface',
	    value: function _computeSurface(packedArrays, box, boundaries, params) {
	      // FIXME beware of shifting this multiple times!
	      this._shiftByOrigin(packedArrays.posRad);

	      var surface = {
	        volMap: new Volume$1(Float32Array, this.numVoxels, box),
	        volTexMap: new Volume$1(Float32Array, this.numVoxels, box, 3)
	      };

	      if (this._visibilitySelector != null) {
	        surface.atomMap = [];
	        surface.atomWeightMap = new Volume$1(Float32Array, this.numVoxels, box);
	      }

	      this.gaussdensity(surface, packedArrays, null, params);
	      return surface;
	    }
	  }, {
	    key: 'gaussdensity',
	    value: function gaussdensity(surface, packedArrays, atomicNum, params) {
	      var numAtoms = packedArrays.posRad.length / 4;
	      var posRad = packedArrays.posRad;
	      var colors = packedArrays.colors;
	      var numVoxels = this.numVoxels;
	      var radScale = params.radScale;
	      var gaussLim = params.gaussLim;
	      var gridSpacing = params.gridSpacing;
	      var invIsoValue = 1.0 / params.isoValue;
	      var invGridSpacing = 1.0 / gridSpacing;
	      var maxVoxelX = numVoxels[0] - 1;
	      var maxVoxelY = numVoxels[1] - 1;
	      var maxVoxelZ = numVoxels[2] - 1;
	      //TODO is densityMap and volTexMap initialized?

	      var volMap = surface.volMap;
	      var volTexMap = surface.volTexMap;
	      var volData = volMap.getData();
	      var strideX = volMap.getStrideX();

	      var volTexData = volTexMap.getData();
	      var texStrideX = volTexMap.getStrideX();

	      var atomWeightData = void 0;
	      if (this._visibilitySelector != null) {
	        atomWeightData = surface.atomWeightMap.getData();
	      }

	      var atomMap = surface.atomMap;

	      for (var i = 0; i < numAtoms; ++i) {
	        var ind = i * 4;
	        var scaledRad = posRad[ind + 3] * radScale;
	        var atomicNumFactor = atomicNum === null ? 1.0 : atomicNum[i];
	        var radInv = 1 / (2 * scaledRad * scaledRad);
	        var radLim = gaussLim * scaledRad;
	        var radLim2 = radLim * radLim;
	        radLim *= invGridSpacing;

	        var tmp = posRad[ind] * invGridSpacing;
	        var xMin = Math.max(tmp - radLim | 0, 0);
	        var xMax = Math.min(tmp + radLim | 0, maxVoxelX);
	        tmp = posRad[ind + 1] * invGridSpacing;
	        var yMin = Math.max(tmp - radLim | 0, 0);
	        var yMax = Math.min(tmp + radLim | 0, maxVoxelY);
	        tmp = posRad[ind + 2] * invGridSpacing;
	        var zMin = Math.max(tmp - radLim | 0, 0);
	        var zMax = Math.min(tmp + radLim | 0, maxVoxelZ);

	        var dz = zMin * gridSpacing - posRad[ind + 2];
	        for (var z = zMin; z <= zMax; ++z, dz += gridSpacing) {
	          var dy = yMin * gridSpacing - posRad[ind + 1];
	          for (var y = yMin; y <= yMax; ++y, dy += gridSpacing) {
	            var dy2dz2 = dy * dy + dz * dz;

	            if (dy2dz2 >= radLim2) {
	              continue;
	            }

	            var addr = volMap.getDirectIdx(xMin, y, z);
	            var texAddr = volTexMap.getDirectIdx(xMin, y, z);
	            var dx = xMin * gridSpacing - posRad[ind];
	            for (var x = xMin; x <= xMax; ++x, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
	              var r2 = dx * dx + dy2dz2;
	              var expVal = -r2 * radInv;

	              // TODO use faster exp?
	              var density = Math.exp(expVal) * atomicNumFactor;

	              // store most relevant atom (with highest density)
	              if (this._visibilitySelector != null && density > atomWeightData[addr]) {
	                //NOSONAR
	                atomWeightData[addr] = density;
	                // we use same index into atom map and atomWeightMap
	                atomMap[addr] = packedArrays.atoms[i];
	              }

	              volData[addr] += density;

	              // TODO check for volTexMap routine?
	              density *= invIsoValue;
	              var colInd = i * 3;
	              volTexData[texAddr] += density * colors[colInd];
	              volTexData[texAddr + 1] += density * colors[colInd + 1];
	              volTexData[texAddr + 2] += density * colors[colInd + 2];
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: '_shiftByOrigin',
	    value: function _shiftByOrigin(posRadArray) {
	      var originX = this.origin.x;
	      var originY = this.origin.y;
	      var originZ = this.origin.z;

	      var itemSize = 4;
	      var itemsCount = posRadArray.length / itemSize;
	      for (var i = 0; i < itemsCount; ++i) {
	        var ind = i * itemSize;

	        posRadArray[ind] -= originX;
	        posRadArray[ind + 1] -= originY;
	        posRadArray[ind + 2] -= originZ;
	      }
	    }
	  }]);
	  return QuickSurfGeometry;
	}(VolumeSurfaceGeometry);

	/**
	 * Modifed from SpatialHash
	 *
	 * Main differences are:
	 * - Optimized grid size to ensure we only ever need to look +/-1 cell
	 * - Aware of atomic radii and will only output atoms within rAtom + rExtra
	 *   (see withinRadii method)
	 *
	 * (Uses rounding rather than bitshifting as consequence of arbitrary grid size)
	 * @class
	 * @param {Float32Array} posRad - x, y, z coordinates and radiuses
	 * @param {Float32Array} min - xyz min coordinates
	 * @param {Float32Array} max - xyz max coordinates
	 * @param {number} maxDistance - max distance
	 */
	function AVHash(posRad, min, max, maxDistance) {
	  var itemSize = 4;
	  var nAtoms = posRad.length / itemSize;

	  var minX = min[0];
	  var minY = min[1];
	  var minZ = min[2];

	  var maxX = max[0];
	  var maxY = max[1];
	  var maxZ = max[2];

	  function hashFunc(w, minW) {
	    return Math.floor((w - minW) / maxDistance);
	  }

	  var iDim = hashFunc(maxX, minX) + 1;
	  var jDim = hashFunc(maxY, minY) + 1;
	  var kDim = hashFunc(maxZ, minZ) + 1;

	  var nCells = iDim * jDim * kDim;

	  var jkDim = jDim * kDim;

	  /* Get cellID for cartesian x,y,z */
	  var cellID = function cellID(x, y, z) {
	    return (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim + hashFunc(z, minZ);
	  };

	  /* Initial building, could probably be optimized further */
	  var preHash = []; // preHash[ cellID ] = [ atomId1, atomId2 ];
	  var i = void 0;
	  var cid = void 0;
	  for (i = 0; i < nAtoms; i++) {
	    var iIdx = itemSize * i;
	    cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);

	    if (preHash[cid] === undefined) {
	      preHash[cid] = [i];
	    } else {
	      preHash[cid].push(i);
	    }
	  }

	  var cellOffsets = utils.allocateTyped(Uint32Array, nCells);
	  var cellLengths = utils.allocateTyped(Uint16Array, nCells);
	  var data = utils.allocateTyped(Uint32Array, nAtoms);

	  var offset = 0;
	  var maxCellLength = 0;
	  var j = void 0;
	  for (i = 0; i < nCells; i++) {
	    var start = cellOffsets[i] = offset;

	    var subArray = preHash[i];

	    if (subArray !== undefined) {
	      for (j = 0; j < subArray.length; j++) {
	        data[offset] = subArray[j];
	        offset++;
	      }
	    }

	    var cellLength = offset - start;
	    cellLengths[i] = cellLength;

	    if (cellLength > maxCellLength) {
	      maxCellLength = cellLength;
	    }
	  }

	  // Maximum number of neighbours we could ever produce (27 adjacent cells of equal population)
	  this.neighbourListLength = 27 * maxCellLength + 1;

	  /**
	   * Populate the supplied out array with atom indices that are within rAtom + rExtra
	   * of x,y,z
	   *
	   * -1 in out array indicates the end of the list
	   *
	   * @param  {number} x - x coordinate
	   * @param  {number} y - y coordinate
	   * @param  {number} z - z coordinate
	   * @param  {number} rExtra - additional radius
	   * @param  {Float32Array} out - pre-allocated output array
	   * @return {undefined}
	   */
	  this.withinRadii = function (x, y, z, rExtra, out) {
	    var outIdx = 0;

	    var nearI = hashFunc(x, minX);
	    var nearJ = hashFunc(y, minY);
	    var nearK = hashFunc(z, minZ);

	    var loI = Math.max(0, nearI - 1);
	    var loJ = Math.max(0, nearJ - 1);
	    var loK = Math.max(0, nearK - 1);

	    var hiI = Math.min(iDim - 1, nearI + 1);
	    var hiJ = Math.min(jDim - 1, nearJ + 1);
	    var hiK = Math.min(kDim - 1, nearK + 1);

	    for (i = loI; i <= hiI; ++i) {

	      var iOffset = i * jkDim;

	      for (j = loJ; j <= hiJ; ++j) {

	        var jOffset = j * kDim;

	        for (var k = loK; k <= hiK; ++k) {

	          cid = iOffset + jOffset + k;

	          var cellStart = cellOffsets[cid];
	          var cellEnd = cellStart + cellLengths[cid];

	          for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {

	            var atomIndex = data[dataIndex];
	            var baseIndex = itemSize * atomIndex;
	            var dx = posRad[baseIndex] - x;
	            var dy = posRad[baseIndex + 1] - y;
	            var dz = posRad[baseIndex + 2] - z;
	            var rSum = posRad[baseIndex + 3] + rExtra;

	            if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
	              out[outIdx++] = data[dataIndex];
	            }
	          }
	        }
	      }
	    }
	    // Add terminator
	    out[outIdx] = -1;
	  };
	}
	function ContactSurface(packedArrays, boundaries, params, _indexList) {

	  // Field generation method adapted from AstexViewer (Mike Hartshorn)
	  // by Fred Ludlow.
	  // Other parts based heavily on NGL (Alexander Rose) EDT Surface class
	  //
	  // Should work as a drop-in alternative to EDTSurface (though some of
	  // the EDT paramters are not relevant in this method).

	  var itemSize = 4;
	  var posRad = packedArrays.posRad;
	  var colors = packedArrays.colors;
	  var atoms = packedArrays.atoms;
	  var nAtoms = posRad.length / itemSize;

	  var bbox = boundaries.bbox;

	  var min = bbox.minPosRad;
	  var max = bbox.maxPosRad;

	  var r2 = void 0; // Atom positions, expanded radii (squared)
	  var maxRadius = void 0;

	  // Parameters
	  var probeRadius = void 0,
	      scaleFactor = void 0,
	      probePositions = void 0;

	  // Cache last value for obscured test
	  var lastClip = -1;

	  // Grid params
	  var dim = void 0,
	      grid = void 0;
	  var volTex = void 0,
	      weights = void 0,
	      weightsMap = null,
	      atomMap = null;
	  var visibilitySelector = null;

	  // grid indices -> xyz coords
	  var gridx = void 0,
	      gridy = void 0,
	      gridz = void 0;

	  // Lookup tables:
	  var sinTable = void 0,
	      cosTable = void 0;

	  // Spatial Hash
	  var hash = void 0;

	  // Neighbour array to be filled by hash
	  var neighbours = void 0;

	  // Vectors for Torus Projection
	  var mid = new Vector3(0.0, 0.0, 0.0);
	  var n1 = new Vector3(0.0, 0.0, 0.0);
	  var n2 = new Vector3(0.0, 0.0, 0.0);

	  var ngTorus = void 0;

	  function init() {
	    probeRadius = params.probeRadius;
	    scaleFactor = params.scaleFactor;
	    probePositions = params.probePositions;
	    visibilitySelector = params.visibilitySelector;

	    r2 = utils.allocateTyped(Float32Array, nAtoms);
	    maxRadius = 0;
	    for (var innI = 0; innI < nAtoms; ++innI) {
	      var rExt = posRad[innI * itemSize + 3] += probeRadius;
	      if (rExt > maxRadius) {
	        maxRadius = rExt;
	      }
	      r2[innI] = rExt * rExt;
	    }

	    initializeGrid();
	    initializeAngleTables();
	    initializeHash();

	    lastClip = -1;
	  }

	  function uniformArray(TypeName, n, a) {
	    var array = utils.allocateTyped(TypeName, n);
	    for (var innI = 0; innI < n; ++innI) {
	      array[innI] = a;
	    }

	    return array;
	  }

	  function fillGridDim(a, start, step) {
	    for (var innI = 0; innI < a.length; innI++) {
	      a[innI] = start + step * innI;
	    }
	  }

	  function initializeGrid() {
	    scaleFactor = params.scaleFactor;
	    dim = boundaries.dim;

	    ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));

	    var gridSize = dim[0] * dim[1] * dim[2];
	    grid = uniformArray(Float32Array, gridSize, -1001.0);
	    volTex = utils.allocateTyped(Float32Array, gridSize * 3);
	    weights = utils.allocateTyped(Float32Array, gridSize);
	    if (visibilitySelector) {
	      weightsMap = utils.allocateTyped(Float32Array, gridSize);
	      atomMap = [];
	    }

	    gridx = utils.allocateTyped(Float32Array, dim[0]);
	    gridy = utils.allocateTyped(Float32Array, dim[1]);
	    gridz = utils.allocateTyped(Float32Array, dim[2]);

	    fillGridDim(gridx, min[0], 1 / scaleFactor);
	    fillGridDim(gridy, min[1], 1 / scaleFactor);
	    fillGridDim(gridz, min[2], 1 / scaleFactor);
	  }

	  function initializeAngleTables() {
	    var theta = 0.0;
	    var step = 2 * Math.PI / probePositions;

	    cosTable = utils.allocateTyped(Float32Array, probePositions);
	    sinTable = utils.allocateTyped(Float32Array, probePositions);
	    for (var innI = 0; innI < probePositions; innI++) {
	      cosTable[innI] = Math.cos(theta);
	      sinTable[innI] = Math.sin(theta);
	      theta += step;
	    }
	  }

	  function initializeHash() {
	    hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
	    neighbours = new Int32Array(hash.neighbourListLength);
	  }

	  function obscured(innX, innY, innZ, a, b) {
	    // Is the point at x,y,z obscured by any of the atoms
	    // specifeid by indices in neighbours. Ignore indices
	    // a and b (these are the relevant atoms in projectPoints/Torii)

	    // Cache the last clipped atom (as very often the same one in
	    // subsequent calls)
	    var ai = void 0;

	    if (lastClip !== -1) {
	      ai = lastClip;
	      if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
	        return ai;
	      } else {
	        lastClip = -1;
	      }
	    }

	    var ni = 0;
	    ai = neighbours[ni];
	    while (ai >= 0) {
	      if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
	        lastClip = ai;
	        return ai;
	      }
	      ai = neighbours[++ni];
	    }

	    lastClip = -1;

	    return -1;
	  }

	  function singleAtomObscures(ai, innX, innY, innZ) {
	    var innCI = itemSize * ai;
	    var ra2 = r2[ai];
	    var dx = posRad[innCI] - innX;
	    var dy = posRad[innCI + 1] - innY;
	    var dz = posRad[innCI + 2] - innZ;
	    var d2 = dx * dx + dy * dy + dz * dz;

	    return d2 < ra2;
	  }

	  function projectPoints() {

	    // For each atom:
	    //     Iterate over a subsection of the grid, for each point:
	    //         If current value < 0.0, unvisited, set positive
	    //
	    //         In any case: Project this point onto surface of the atomic sphere
	    //         If this projected point is not obscured by any other atom
	    //             Calcualte delta distance and set grid value to minimum of
	    //             itself and delta

	    // Should we alias frequently accessed closure constiables??
	    // Assume JS engine capable of optimizing this
	    // anyway...
	    var maxRad = 4.0;
	    var sigma = maxRad / 3;
	    var sigma2Inv = 1 / (2 * sigma * sigma);

	    for (var innI = 0; innI < nAtoms; innI++) {
	      var innCI = itemSize * innI;
	      var ax = posRad[innCI];
	      var ay = posRad[innCI + 1];
	      var az = posRad[innCI + 2];
	      var ar = posRad[innCI + 3];
	      var ar2 = r2[innI];

	      hash.withinRadii(ax, ay, az, ar, neighbours);

	      // Number of grid points, round this up...
	      var ng = Math.ceil(ar * scaleFactor);

	      // Center of the atom, mapped to grid points (take floor)
	      var iax = Math.floor(scaleFactor * (ax - min[0]));
	      var iay = Math.floor(scaleFactor * (ay - min[1]));
	      var iaz = Math.floor(scaleFactor * (az - min[2]));

	      // Extents of grid to consider for this atom
	      var minx = Math.max(0, iax - ng);
	      var miny = Math.max(0, iay - ng);
	      var minz = Math.max(0, iaz - ng);

	      // Add two to these points:
	      // - iax are floor'd values so this ensures coverage
	      // - these are loop limits (exclusive)
	      var maxx = Math.min(dim[0], iax + ng + 2);
	      var maxy = Math.min(dim[1], iay + ng + 2);
	      var maxz = Math.min(dim[2], iaz + ng + 2);

	      var colIdx = innI * 3;
	      var cr = colors[colIdx];
	      var cg = colors[colIdx + 1];
	      var cb = colors[colIdx + 2];

	      for (var iz = minz; iz < maxz; iz++) {
	        var dz = gridz[iz] - az;
	        var zOffset = dim[1] * dim[0] * iz;

	        for (var iy = miny; iy < maxy; iy++) {

	          var dy = gridy[iy] - ay;
	          var dzy2 = dz * dz + dy * dy;
	          var zyOffset = zOffset + dim[0] * iy;

	          for (var ix = minx; ix < maxx; ix++) {
	            var idx = ix + zyOffset;
	            var dx = gridx[ix] - ax;
	            var d2 = dzy2 + dx * dx;

	            if (d2 < ar2) {
	              var w = Math.exp(-d2 * sigma2Inv);
	              var cIdx = idx * 3;
	              volTex[cIdx] += cr * w;
	              volTex[cIdx + 1] += cg * w;
	              volTex[cIdx + 2] += cb * w;
	              weights[idx] += w;
	              if (visibilitySelector !== null && w > weightsMap[idx]) {
	                weightsMap[idx] = w;
	                atomMap[idx] = atoms[innI];
	              }

	              if (grid[idx] < 0.0) {
	                // Unvisited, make positive
	                grid[idx] = -grid[idx];
	              }
	              // Project on to the surface of the sphere
	              // sp is the projected point ( dx, dy, dz ) * ( ra / d )
	              var d = Math.sqrt(d2);
	              var ap = ar / d;
	              var spx = dx * ap;
	              var spy = dy * ap;
	              var spz = dz * ap;

	              spx += ax;
	              spy += ay;
	              spz += az;

	              if (obscured(spx, spy, spz, innI, -1) === -1) {
	                var dd = ar - d;
	                if (dd < grid[idx]) {
	                  grid[idx] = dd;
	                }
	              }
	            }
	          }
	        }
	      }
	    }
	  }

	  function projectTorii() {
	    for (var innI = 0; innI < nAtoms; innI++) {
	      var innIdx = itemSize * innI;
	      hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
	      var ia = 0;
	      var ni = neighbours[ia];
	      while (ni >= 0) {
	        if (innI < ni) {
	          projectTorus(innI, ni);
	        }
	        ni = neighbours[++ia];
	      }
	    }
	  }

	  function projectTorus(a, b) {

	    var aIdx = itemSize * a;
	    var bIdx = itemSize * b;
	    var xa = posRad[aIdx];
	    var ya = posRad[aIdx + 1];
	    var za = posRad[aIdx + 2];
	    var r1 = posRad[aIdx + 3];
	    var dx = mid.x = posRad[bIdx] - xa;
	    var dy = mid.y = posRad[bIdx + 1] - ya;
	    var dz = mid.z = posRad[bIdx + 2] - za;
	    var innR2 = posRad[bIdx + 3];
	    var d2 = dx * dx + dy * dy + dz * dz;

	    // This check now redundant as already done in AVHash.withinRadii
	    // if( d2 > (( r1 + r2 ) * ( r1 + r2 )) ){ return; }

	    var d = Math.sqrt(d2);

	    // Find angle between a->b vector and the circle
	    // of their intersection by cosine rule
	    var cosA = (r1 * r1 + d * d - innR2 * innR2) / (2.0 * r1 * d);

	    // distance along a->b at intersection
	    var dmp = r1 * cosA;

	    mid.normalize();

	    // Create normal to line
	    normalToLine(n1, mid);
	    n1.normalize();

	    // Cross together for second normal vector
	    n2.crossVectors(mid, n1);
	    n2.normalize();

	    // r is radius of circle of intersection
	    var rInt = Math.sqrt(r1 * r1 - dmp * dmp);

	    n1.multiplyScalar(rInt);
	    n2.multiplyScalar(rInt);
	    mid.multiplyScalar(dmp);

	    mid.x += xa;
	    mid.y += ya;
	    mid.z += za;

	    lastClip = -1;

	    var ng = ngTorus;

	    for (var innI = 0; innI < probePositions; innI++) {

	      var cost = cosTable[innI];
	      var sint = sinTable[innI];

	      var px = mid.x + cost * n1.x + sint * n2.x;
	      var py = mid.y + cost * n1.y + sint * n2.y;
	      var pz = mid.z + cost * n1.z + sint * n2.z;

	      if (obscured(px, py, pz, a, b) === -1) {

	        // As above, iterate over our grid...
	        // px, py, pz in grid coords
	        var iax = Math.floor(scaleFactor * (px - min[0]));
	        var iay = Math.floor(scaleFactor * (py - min[1]));
	        var iaz = Math.floor(scaleFactor * (pz - min[2]));

	        var minx = Math.max(0, iax - ng);
	        var miny = Math.max(0, iay - ng);
	        var minz = Math.max(0, iaz - ng);

	        var maxx = Math.min(dim[0], iax + ng + 2);
	        var maxy = Math.min(dim[1], iay + ng + 2);
	        var maxz = Math.min(dim[2], iaz + ng + 2);

	        for (var iz = minz; iz < maxz; iz++) {

	          dz = pz - gridz[iz];
	          var zOffset = dim[1] * dim[0] * iz;
	          for (var iy = miny; iy < maxy; iy++) {

	            dy = py - gridy[iy];
	            var dzy2 = dz * dz + dy * dy;
	            var zyOffset = zOffset + dim[0] * iy;
	            for (var ix = minx; ix < maxx; ix++) {

	              dx = px - gridx[ix];
	              d2 = dzy2 + dx * dx;
	              var idx = ix + zyOffset;
	              var current = grid[idx];

	              if (current > 0.0 && d2 < current * current) {
	                grid[idx] = Math.sqrt(d2);
	              }
	            }
	          }
	        }
	      }
	    }
	  }

	  function normalToLine(out, p) {
	    out.x = out.y = out.z = 1.0;
	    if (p.x !== 0) {
	      out.x = (p.y + p.z) / -p.x;
	    } else if (p.y !== 0) {
	      out.y = (p.x + p.z) / -p.y;
	    } else if (p.z !== 0) {
	      out.z = (p.x + p.y) / -p.z;
	    }
	    return out;
	  }

	  function fixNegatives() {
	    for (var innI = 0, n = grid.length; innI < n; innI++) {
	      if (grid[innI] < 0) grid[innI] = 0;
	      var w = weights[innI];
	      if (w > 0) {
	        w = 1 / w;
	        var innInnI = innI * 3;
	        volTex[innInnI] *= w;
	        volTex[innInnI + 1] *= w;
	        volTex[innInnI + 2] *= w;
	      }
	    }
	  }

	  function getVolume() {

	    // Basic steps are:
	    // 1) Initialize
	    // 2) Project points
	    // 3) Project torii
	    console.time('ContactSurface.getVolume');

	    console.time('ContactSurface.init');
	    init();
	    console.timeEnd('ContactSurface.init');

	    console.time('ContactSurface.projectPoints');
	    projectPoints();
	    console.timeEnd('ContactSurface.projectPoints');

	    console.time('ContactSurface.projectTorii');
	    projectTorii();
	    console.timeEnd('ContactSurface.projectTorii');
	    fixNegatives();
	    console.timeEnd('ContactSurface.getVolume');
	  }

	  this.build = function () {
	    // type and cutoff left in for compatibility with EDTSurface.getSurface
	    // function signature
	    getVolume();
	    this.volTexMap = volTex;
	    this.weightsMap = weightsMap;
	    this.atomMap = atomMap;
	    this.volMap = grid;
	  };
	}

	var Volume$2 = chem.Volume;

	/**
	 * This class implements 'contact' isosurface geometry generation algorithm.
	 * @param spheresCount - number of atoms/spheres
	 * @param opts - geometry specific options
	 * @constructor
	 */

	var ContactSurfaceGeometry = function (_VolumeSurfaceGeometr) {
	  inherits(ContactSurfaceGeometry, _VolumeSurfaceGeometr);

	  function ContactSurfaceGeometry(spheresCount, opts) {
	    classCallCheck(this, ContactSurfaceGeometry);
	    return possibleConstructorReturn(this, (ContactSurfaceGeometry.__proto__ || Object.getPrototypeOf(ContactSurfaceGeometry)).call(this, spheresCount, opts));
	  }

	  createClass(ContactSurfaceGeometry, [{
	    key: '_computeSurface',
	    value: function _computeSurface(packedArrays, box, boundaries, params) {
	      var contactSurface = new ContactSurface(packedArrays, boundaries, params);
	      contactSurface.build();

	      var surface = {
	        volMap: new Volume$2(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
	        volTexMap: new Volume$2(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
	        atomMap: contactSurface.atomMap,
	        atomWeightMap: new Volume$2(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
	      };
	      return surface;
	    }
	  }]);
	  return ContactSurfaceGeometry;
	}(VolumeSurfaceGeometry);

	/**
	 * Class for colored atom. Need for atom structure clusterization
	 *
	 * @param {Vector3} vCenter   Center of atom
	 * @param {number}  radiusAt  Radius of atom
	 */

	var IsoSurfaceAtomColored = function IsoSurfaceAtomColored(vCenter, radiusAt) {
	  classCallCheck(this, IsoSurfaceAtomColored);

	  this.coord = new Vector3();
	  this.coord.copy(vCenter);
	  this.radius = radiusAt;
	  this.colorX = 0.99999;
	  this.colorY = 0.0;
	  this.colorZ = 0.0;
	  this.atomType = 0;
	  this.srcAtom = null;
	};

	// suppress some JSHint warnings
	/*jshint bitwise: false*/

	/**
	 * Build normals for isosurface, using atoms information
	 *
	 * @param {number} numAtoms     - Number of atoms in molecule
	 * @param {Element} atoms      - Array of atoms
	 * @param {Vector3} vBoxMin     - Bounding box min
	 * @param {Vector3} vBoxMax     - Bounding box max
	 * @param {number} probeRadius     - Normals for output
	 *
	 */

	var IsosurfaceBuildNormals = function () {
	  function IsosurfaceBuildNormals(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
	    classCallCheck(this, IsosurfaceBuildNormals);

	    this._numAtoms = numAtoms;
	    this._atoms = atoms;
	    this._vBoxMin = new Vector3();
	    this._vBoxMax = new Vector3();
	    this._vBoxMin.copy(vBoxMin);
	    this._vBoxMax.copy(vBoxMax);
	    this._probeRadius = probeRadius;

	    this._atomsList = null;
	    this._voxelList = null;
	  }

	  createClass(IsosurfaceBuildNormals, [{
	    key: 'createVoxels',
	    value: function createVoxels() {
	      var numAtomsRefs = void 0;
	      var rad = void 0;
	      var ATOM_VOXEL_REF_SCALE = 4.5;

	      var numAtoms = this._numAtoms | 0;
	      var atoms = this._atoms;
	      var dx = this._vBoxMax.x - this._vBoxMin.x;
	      var dy = this._vBoxMax.y - this._vBoxMin.y;
	      var dz = this._vBoxMax.z - this._vBoxMin.z;
	      var w = dx < dy ? dx : dy;
	      w = dz < w ? dz : w;
	      var maxRad = 0.0;
	      var aveRad = 0.0;

	      var i = void 0;
	      for (i = 0; i < numAtoms; i++) {
	        rad = (atoms[i].radius + this._probeRadius) * 2.0;
	        maxRad = rad > maxRad ? rad : maxRad;
	        aveRad += rad;
	      }
	      var numCells = Math.floor(w / maxRad);
	      if (numCells < 2) {
	        numCells = 2;
	      }
	      aveRad /= numAtoms;

	      this._numCells = numCells;
	      this._aveRad = aveRad;
	      this._maxRad = maxRad;

	      var side = numCells;
	      var side2 = numCells * numCells;
	      var side3 = numCells * numCells * numCells;

	      var xScale = this._xScale = 1.0 / (this._vBoxMax.x - this._vBoxMin.x);
	      var yScale = this._yScale = 1.0 / (this._vBoxMax.y - this._vBoxMin.y);
	      var zScale = this._zScale = 1.0 / (this._vBoxMax.z - this._vBoxMin.z);

	      // estimate number of individual atom refs in each voxel list
	      var maxAtomsRefs = 0;

	      var xNumVoxMult = xScale * numCells;
	      var yNumVoxMult = yScale * numCells;
	      var zNumVoxMult = zScale * numCells;

	      for (i = 0; i < numAtoms; i++) {
	        var radAffect = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
	        var diaAffect = radAffect * 2.0;
	        var numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
	        var numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
	        var numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8);
	        // avoid case numVox? == 0
	        // also use loop i <=
	        numVoxX++;
	        numVoxY++;
	        numVoxZ++;
	        maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
	      } // for (i)
	      //maxAtomsRefs = numAtoms * MAX_ATOMS_IN_SINGLE_VOXEL;


	      this._voxelList = utils.allocateTyped(Int32Array, side3);
	      var atomsList = [];
	      atomsList.length = maxAtomsRefs;
	      if (this._voxelList === null || atomsList === null) {
	        return 0 - 1;
	      }
	      // init voxel list
	      for (i = 0; i < side3; i++) {
	        this._voxelList[i] = -1;
	      }
	      numAtomsRefs = 0;

	      // create voxel lists
	      for (i = 0; i < numAtoms; i++) {
	        // use multiplier 4 to locate this atom in different voxels
	        rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
	        var xIndMin = Math.floor((atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
	        var yIndMin = Math.floor((atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
	        var zIndMin = Math.floor((atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
	        var xIndMax = Math.floor((atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
	        var yIndMax = Math.floor((atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
	        var zIndMax = Math.floor((atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale);

	        xIndMin = xIndMin >= 0 ? xIndMin : 0;
	        yIndMin = yIndMin >= 0 ? yIndMin : 0;
	        zIndMin = zIndMin >= 0 ? zIndMin : 0;

	        xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
	        yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
	        zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;

	        for (var z = zIndMin; z <= zIndMax; z++) {
	          for (var y = yIndMin; y <= yIndMax; y++) {
	            for (var x = xIndMin; x <= xIndMax; x++) {
	              // add atom with index "i" to this voxel list
	              var indVoxel = x + y * side + z * side2;
	              //assert(indVoxel >= 0);
	              //assert(indVoxel < side3);

	              // add first
	              if (this._voxelList[indVoxel] < 0) {
	                atomsList[numAtomsRefs * 2 + 0] = i;
	                atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
	                this._voxelList[indVoxel] = numAtomsRefs;
	                numAtomsRefs++;
	                //assert(numAtomsRefs < maxAtomsRefs - 1);
	                continue;
	              }
	              // insert into head of list
	              var indexNext = this._voxelList[indVoxel];
	              this._voxelList[indVoxel] = numAtomsRefs;
	              atomsList[numAtomsRefs * 2 + 0] = i;
	              atomsList[numAtomsRefs * 2 + 1] = indexNext;
	              numAtomsRefs++;
	            } // for (x)
	          } // for (y)
	        } // for (z)
	      } // for (i)

	      // convert Array to Int32Array
	      this._atomsList = Int32Array.from(atomsList);

	      return 0;
	    }
	  }, {
	    key: 'destroyVoxels',
	    value: function destroyVoxels() {
	      this._atomsList = null;
	      this._voxelList = null;

	      this._atoms = null;
	      this._vertices = null;
	      this._vBoxMin = null;
	      this._vBoxMax = null;
	    }

	    /**
	     * Enumerate all atoms affecting specified point
	     *
	     * @param {Vector3}    point    - point in 3D
	     * @param {func(atom)} process  - function to call for each atom
	     */

	  }, {
	    key: 'forEachRelatedAtom',
	    value: function forEachRelatedAtom(point, process) {
	      // find corresponding voxel
	      var xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
	      var yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
	      var zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
	      var indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells;

	      // run through atoms affecting this voxel
	      var atoms = this._atoms;
	      for (var ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
	        var indexAtom = this._atomsList[ref * 2];
	        process(atoms[indexAtom]);
	      }
	    }

	    /**
	     * Get atom closest to specified point
	     *
	     * @param {Vector3} point  - point in 3D
	     *
	     * @returns {IsoSurfaceAtomColored} atom, or null if not found
	     */

	  }, {
	    key: 'getClosestAtom',
	    value: function getClosestAtom(point) {
	      var closest = null;
	      var minDist2 = Number.MAX_VALUE;

	      this.forEachRelatedAtom(point, function (atom) {
	        var dist2 = point.distanceToSquared(atom.coord);
	        if (dist2 < minDist2) {
	          minDist2 = dist2;
	          closest = atom;
	        }
	      });

	      return closest;
	    }

	    /**
	     * Build normals for isosurface, using atoms information
	     *
	     * @param {number} numVertices  - Number of vertices in final geometry (to render)
	     * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
	     * @param {Vector3} normals     - Normals for output
	     *
	     * @returns {number} 0, if success
	     */

	  }, {
	    key: 'buildNormals',
	    value: function buildNormals(numVertices, vertices, normals) {
	      var self = this;
	      var numCloseAtoms = 0;
	      var vx = 0,
	          vy = 0,
	          vz = 0;
	      var dist2 = void 0;
	      var vNormalX = 0,
	          vNormalY = 0,
	          vNormalZ = 0;
	      var koef = 0,
	          w = 0;
	      var r25 = 2.5;
	      var r01 = 0.1;

	      var maxRadAffect = this._aveRad * r25;
	      var maxRadAffect2 = maxRadAffect * maxRadAffect;
	      var expScale = -this._aveRad * r01;

	      // some stats
	      //numSlowAtoms = 0;

	      var gatherNormals = function gatherNormals(atom) {
	        var dx = vx - atom.coord.x;
	        var dy = vy - atom.coord.y;
	        var dz = vz - atom.coord.z;
	        dist2 = dx * dx + dy * dy + dz * dz;
	        if (dist2 > maxRadAffect2) {
	          return;
	        }

	        // get weight for gaussian smoothing
	        var rad = atom.radius + self._probeRadius;
	        koef = dist2 - rad * rad;
	        if (koef < 0.0) {
	          koef = -koef;
	        }
	        w = Math.exp(expScale * koef);

	        vNormalX += dx * w;
	        vNormalY += dy * w;
	        vNormalZ += dz * w;
	        numCloseAtoms++;
	      };
	      // process all vertices, one by one
	      for (var i = 0; i < numVertices; i++) {
	        vx = vertices[i].x;
	        vy = vertices[i].y;
	        vz = vertices[i].z;

	        numCloseAtoms = 0;
	        vNormalX = vNormalY = vNormalZ = 0.0;

	        this.forEachRelatedAtom(vertices[i], gatherNormals);

	        // normalize vNormal
	        dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;
	        if (numCloseAtoms > 0) {
	          koef = 1.0 / Math.sqrt(dist2);
	          vNormalX *= koef;
	          vNormalY *= koef;
	          vNormalZ *= koef;
	        }
	        normals[i].x = vNormalX;
	        normals[i].y = vNormalY;
	        normals[i].z = vNormalZ;
	      } // for (i) all vertices

	      return 0;
	    }

	    /**
	     * Build vertex colors for isosurface, using atoms information
	     *
	     * @param {number} numVertices  - Number of vertices in final geometry (to render)
	     * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
	     * @param {Vector3} colors                - Colors for output
	     * @param {number} radiusColorSmoothness  - Radius of smoothness sphere
	     *
	     * @returns {number} 0, if success
	     */

	  }, {
	    key: 'buildColors',
	    value: function buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
	      var self = this;
	      var vx = 0.0,
	          vy = 0.0,
	          vz = 0.0;
	      var koef = 0.0,
	          w = 0.0;
	      //const KOEF_ALPHA = 1.0;
	      var KOEF_ADD = 0.8;

	      var maxRadAffect = radiusColorSmoothness;
	      var maxRadAffect2 = maxRadAffect * maxRadAffect;

	      //koefAlpha = 4.4 / radiusColorSmoothness;

	      var colorsClose = [];
	      var weights = [];
	      var weightsSum = 0;

	      var gatherColors = function gatherColors(atom) {
	        var dx = vx - atom.coord.x;
	        var dy = vy - atom.coord.y;
	        var dz = vz - atom.coord.z;
	        var dist2 = dx * dx + dy * dy + dz * dz;
	        if (dist2 > maxRadAffect2) {
	          return;
	        }

	        // get weight for gaussian smoothing
	        var rad = atom.radius + self._probeRadius;
	        koef = dist2 - rad * rad;
	        if (koef < 0.0) {
	          koef = -koef;
	        }
	        //w = Math.exp(expScale * koef);
	        //w = 1.0 / (KOEF_ADD + Math.pow(koef, KOEF_ALPHA));
	        w = 1.0 / (KOEF_ADD + koef);

	        colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
	        weights.push(w); // save weights for use
	        weightsSum += w; // calc sum of weights fo further normalization
	      };

	      // process all vertices, one by one
	      for (var i = 0; i < numVertices; i++) {
	        vx = vertices[i].x;
	        vy = vertices[i].y;
	        vz = vertices[i].z;

	        colorsClose = [];
	        weights = [];
	        weightsSum = 0;

	        this.forEachRelatedAtom(vertices[i], gatherColors);

	        // normalized weighted sum of colors
	        for (var j = 0; j < colorsClose.length; ++j) {
	          var weightNormalized = weights[j] / weightsSum;
	          colors[i].x += colorsClose[j][0] * weightNormalized;
	          colors[i].y += colorsClose[j][1] * weightNormalized;
	          colors[i].z += colorsClose[j][2] * weightNormalized;
	        }
	      } // for (i) all vertices
	      return 0;
	    }
	  }]);
	  return IsosurfaceBuildNormals;
	}();

	// suppress some JSHint warnings

	var IsoSurfaceCluster = function () {
	  function IsoSurfaceCluster(fileIn, pdbAtomsIn, atomsIn, vBoxMinIn, vBoxMaxIn, numVoxelsIn, colorModeIn) {
	    classCallCheck(this, IsoSurfaceCluster);

	    this.complex = fileIn;
	    this.atoms = atomsIn;
	    this.pdbAtoms = pdbAtomsIn;
	    this.numVoxels = numVoxelsIn;
	    this.colorMode = colorModeIn;
	    this.vBoxMin = new Vector3();
	    this.vBoxMax = new Vector3();
	    this.vBoxMin.copy(vBoxMinIn);
	    this.vBoxMax.copy(vBoxMaxIn);
	    this.voxelsRefs = null;
	    this.voxels = null;
	  }

	  createClass(IsoSurfaceCluster, [{
	    key: 'destroy',
	    value: function destroy() {
	      this.atoms = null;
	      this.vBoxMin = null;
	      this.vBoxMax = null;
	      this.voxelsRefs = null;
	      this.voxels = null;
	    }
	  }, {
	    key: 'buildSimple',
	    value: function buildSimple(complex, colorer) {
	      var atomsClustered = [];
	      var indVoxel = void 0,
	          indAtomRef = void 0;
	      var atom = void 0;
	      var vColorX = 0,
	          vColorY = 0,
	          vColorZ = 0;
	      var ind = 0;

	      var cNumNeighbours = 8;
	      var cMask = 7;
	      var histTypes = [];
	      histTypes.length = cNumNeighbours;

	      var numVoxels = this.numVoxels;
	      var n3 = numVoxels * numVoxels * numVoxels;

	      var numAtoms = this.atoms.length;

	      this.voxelsRefs = utils.allocateTyped(Int32Array, numAtoms * 2);
	      this.voxels = utils.allocateTyped(Int32Array, n3);

	      // init atoms list
	      for (var i = 0, j = 0; i < numAtoms; i++, j += 2) {
	        this.voxelsRefs[j + 0] = i;
	        this.voxelsRefs[j + 1] = 0 - 1;
	      }
	      // init voxel references (-1 means no atom)
	      for (var _i = 0; _i < n3; _i++) {
	        this.voxels[_i] = -1;
	      }
	      // build atom list for each voxel
	      var xScale = 1.0 / (this.vBoxMax.x - this.vBoxMin.x);
	      var yScale = 1.0 / (this.vBoxMax.y - this.vBoxMin.y);
	      var zScale = 1.0 / (this.vBoxMax.z - this.vBoxMin.z);
	      for (var _i2 = 0; _i2 < numAtoms; _i2++) {
	        var v = this.atoms[_i2].coord;
	        var xVox = Math.floor((v.x - this.vBoxMin.x) * numVoxels * xScale);
	        var yVox = Math.floor((v.y - this.vBoxMin.y) * numVoxels * yScale);
	        var zVox = Math.floor((v.z - this.vBoxMin.z) * numVoxels * zScale);
	        indVoxel = xVox + yVox * numVoxels + zVox * numVoxels * numVoxels;
	        //assert(indVoxel >= 0);
	        //assert(indVoxel < n3);
	        indAtomRef = this.voxels[indVoxel];

	        if (indAtomRef < 0) {
	          this.voxels[indVoxel] = _i2;
	          continue;
	        }
	        while (indAtomRef >= 0) {
	          if (this.voxelsRefs[indAtomRef * 2 + 1] < 0) {
	            break;
	          }
	          indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];
	          //assert(indAtomRef < numAtoms);
	        }
	        // add new atom to list tail
	        this.voxelsRefs[indAtomRef * 2 + 1] = _i2;
	      } // for (i) all source atoms

	      // build Output atoms (clustered)
	      var numSpheres = 0;
	      for (var z = 0; z < numVoxels; z++) {
	        var indVoxelZ = z * numVoxels * numVoxels;
	        for (var y = 0; y < numVoxels; y++) {
	          var indVoxelY = y * numVoxels;
	          for (var x = 0; x < numVoxels; x++) {
	            indVoxel = x + indVoxelY + indVoxelZ;
	            indAtomRef = this.voxels[indVoxel];
	            if (indAtomRef < 0) {
	              continue;
	            }
	            // get ave position
	            var vCenterX = 0.0;
	            var vCenterY = 0.0;
	            var vCenterZ = 0.0;
	            // get num atoms in voxel
	            var numAtomsInVoxel = 0;

	            while (indAtomRef >= 0) {
	              atom = this.atoms[indAtomRef];
	              vCenterX += atom.coord.x;
	              vCenterY += atom.coord.y;
	              vCenterZ += atom.coord.z;

	              numAtomsInVoxel++;
	              indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];
	            }
	            vCenterX *= 1.0 / numAtomsInVoxel;
	            vCenterY *= 1.0 / numAtomsInVoxel;
	            vCenterZ *= 1.0 / numAtomsInVoxel;

	            // find best color (most of in histogram)
	            for (var _i3 = 0; _i3 < cNumNeighbours; _i3++) {
	              histTypes[_i3] = 0;
	            }

	            var rad = 0.0;
	            indAtomRef = this.voxels[indVoxel];
	            while (indAtomRef >= 0) {
	              atom = this.atoms[indAtomRef];
	              var vx = atom.coord.x - vCenterX;
	              var vy = atom.coord.y - vCenterY;
	              var vz = atom.coord.z - vCenterZ;
	              var dist = Math.sqrt(vx * vx + vy * vy + vz * vz) + atom.radius;
	              if (dist > rad) {
	                rad = dist;
	              }

	              ind = colorer.getIndex(complex, this.atoms[indAtomRef]);
	              ind &= cMask;
	              histTypes[ind]++;

	              // next atom in voxel
	              indAtomRef = this.voxelsRefs[indAtomRef * 2 + 1];
	            }
	            // find maximum in histogram => this is most prevalent atom type in cluster
	            var indMax = 0;
	            for (var _i4 = 1; _i4 < cNumNeighbours; _i4++) {
	              if (histTypes[_i4] > histTypes[indMax]) {
	                indMax = _i4;
	              }
	            }

	            //TODO: Earnol
	            var vCenter = new Color(colorer.getAtomColor(complex, this.atoms[indMax]));
	            if (this.colorMode === 0) {
	              vColorX = this.atomColors[indMax].x;
	              vColorY = this.atomColors[indMax].y;
	              vColorZ = this.atomColors[indMax].z;
	            }
	            if (this.colorMode === 1) {
	              var colRGB = this.complex.monomerTypeArray[ind].color; // FIXME: the array is missing
	              vColorX = colRGB.r;
	              vColorY = colRGB.g;
	              vColorZ = colRGB.b;
	            }
	            if (this.colorMode !== 1 && this.colorMode !== 0) {
	              vColorX = this.atomColors[indMax].x;
	              vColorY = this.atomColors[indMax].y;
	              vColorZ = this.atomColors[indMax].z;
	            }

	            vCenter.set(vCenterX, vCenterY, vCenterZ);
	            atomsClustered[numSpheres] = new IsoSurfaceAtomColored(vCenter, rad);
	            atomsClustered[numSpheres].colorX = vColorX;
	            atomsClustered[numSpheres].colorY = vColorY;
	            atomsClustered[numSpheres].colorZ = vColorZ;
	            numSpheres++;
	          } // for (x)
	        } // for (y)
	      } // for (z)
	      this.voxelsRefs = null;
	      this.voxels = null;
	      return atomsClustered;
	    }
	  }]);
	  return IsoSurfaceCluster;
	}();

	/* eslint-disable no-magic-numbers */


	IsoSurfaceCluster.prototype.atomColors = [new Vector3(0.80, 0.80, 0.80), // C
	new Vector3(0.99, 0.99, 0.99), // H
	new Vector3(0.90, 0.20, 0.20), // O
	new Vector3(0.20, 0.20, 0.90), // N
	new Vector3(0.30, 0.90, 0.20), // P
	new Vector3(0.90, 0.90, 0.20), // S

	new Vector3(0.0, 0.0, 0.0), // undefined
	new Vector3(0.60, 0.60, 0.60) // undefined
	];

	IsoSurfaceCluster.prototype.resiudeColors = [new Vector3(0.9, 0.9, 0.2), new Vector3(0.0, 0.9, 0.9), new Vector3(0.9, 0.1, 0.9), new Vector3(0.9, 0.4, 0.6), new Vector3(0.9, 0.6, 0.4), new Vector3(0.4, 0.6, 0.9), new Vector3(0.9, 0.4, 0.7), new Vector3(0.7, 0.3, 0.6)];

	IsoSurfaceCluster.prototype.chainColors = [new Vector3(0.1, 0.1, 0.1), new Vector3(0.3, 0.3, 0.3), new Vector3(0.7, 0.7, 0.7), new Vector3(0.9, 0.9, 0.9), new Vector3(0.5, 0.2, 0.2), new Vector3(0.3, 0.7, 0.7), new Vector3(0.7, 0.3, 0.7), new Vector3(0.8, 0.2, 0.5)];

	/**
	 * Class for geometry (triangle mesh) representation
	 *
	 *
	 * @param {number} maxNumVertices Maximum possible number of vertices in mesh
	 * @param {number} maxNumTriangles Maximum possible number of triangles in mesh
	 * @param {boolean} needVertexColors Obvious
	 */

	var IsoSurfaceGeo = function () {
	  function IsoSurfaceGeo(maxNumVertices, maxNumTriangles, needVertexColors) {
	    classCallCheck(this, IsoSurfaceGeo);

	    this._maxNumVertices = maxNumVertices;
	    this._maxNumTriangles = maxNumTriangles;
	    this._vertices = new Array(maxNumVertices);
	    this._normals = new Array(maxNumVertices);
	    this._colors = null;
	    if (needVertexColors) {
	      this._colors = new Array(maxNumVertices);
	    }
	    this._indices = new Array(maxNumTriangles * (1 + 2));
	    this._numVertices = 0;
	    this._numTriangles = 0;

	    var i = void 0;
	    for (i = 0; i < maxNumVertices; i++) {
	      this._vertices[i] = new Vector3();
	      this._normals[i] = new Vector3();
	    }
	    for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
	      this._indices[i] = -1;
	    }
	    if (needVertexColors) {
	      for (i = 0; i < maxNumVertices; i++) {
	        this._colors[i] = new Vector3();
	      }
	    }
	  }

	  createClass(IsoSurfaceGeo, [{
	    key: 'destroy',
	    value: function destroy() {
	      this._vertices = null;
	      this._normals = null;
	      this._indices = null;
	    }
	  }]);
	  return IsoSurfaceGeo;
	}();

	var COLOR_SIZE$3 = 3;
	var HASH_SIZE = 32768;
	var Element$1 = chem.Element;

	/**
	 * This class implements 'quick' isosurface geometry generation algorithm.
	 * @param spheresCount - number of atoms/spheres
	 * @param opts - geometry specific options
	 * @constructor
	 */

	var SSIsosurfaceGeometry = function (_IsoSurfaceGeometry) {
	  inherits(SSIsosurfaceGeometry, _IsoSurfaceGeometry);

	  function SSIsosurfaceGeometry(spheresCount, opts) {
	    classCallCheck(this, SSIsosurfaceGeometry);
	    return possibleConstructorReturn(this, (SSIsosurfaceGeometry.__proto__ || Object.getPrototypeOf(SSIsosurfaceGeometry)).call(this, spheresCount, opts));
	  }

	  createClass(SSIsosurfaceGeometry, [{
	    key: '_build',
	    value: function _build() {
	      // convert geoOut into arrays of positions, indices, normals
	      this._innerBuild();
	      var geoOut = this.getGeo();
	      this.destroy();
	      this._fromGeo(geoOut);
	    }
	  }, {
	    key: '_fromGeo',
	    value: function _fromGeo(geoOut) {
	      var colors = null;
	      var positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
	      var normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
	      if (geoOut._colors !== null) {
	        colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
	      }
	      var indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);

	      for (var i = 0, j = 0; i < geoOut._numVertices; i++) {
	        positions[j + 0] = geoOut._vertices[i].x;
	        positions[j + 1] = geoOut._vertices[i].y;
	        positions[j + 2] = geoOut._vertices[i].z;
	        normals[j + 0] = geoOut._normals[i].x;
	        normals[j + 1] = geoOut._normals[i].y;
	        normals[j + 2] = geoOut._normals[i].z;
	        j += 3;
	      }
	      if (colors !== null) {
	        for (var _i = 0, _j = 0; _i < geoOut._numVertices; _i++, _j += 3) {
	          colors[_j + 0] = geoOut._colors[_i].x;
	          colors[_j + 1] = geoOut._colors[_i].y;
	          colors[_j + 2] = geoOut._colors[_i].z;
	        }
	      }

	      var numTri3 = geoOut._numTriangles * (1 + 2);
	      for (var _i2 = 0; _i2 < numTri3; _i2++) {
	        indices[_i2] = geoOut._indices[_i2];
	      }

	      this.setIndex(new BufferAttribute(indices, 1));
	      this.addAttribute('position', new BufferAttribute(positions, 3));
	      this.addAttribute('normal', new BufferAttribute(normals, 3));
	      this.addAttribute('color', new BufferAttribute(colors, 3));
	      this.computeBoundingBox();
	      this.computeBoundingSphere();

	      geoOut.destroy();
	    }
	  }, {
	    key: 'convertToAtomsColored',
	    value: function convertToAtomsColored(packedArrays, atomsColored) {
	      var atoms = packedArrays.atoms;
	      var colors = packedArrays.colors;
	      for (var i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
	        var vCenter = atoms[i].getPosition();
	        var radius = atoms[i].element.radius;
	        atomsColored[i] = new IsoSurfaceAtomColored(vCenter, radius);
	        var nm = atoms[i].element.number;
	        atomsColored[i].atomType = this.getType(nm);
	        var cIdx = COLOR_SIZE$3 * i;
	        atomsColored[i].colorX = colors[cIdx++];
	        atomsColored[i].colorY = colors[cIdx++];
	        atomsColored[i].colorZ = colors[cIdx];
	        atomsColored[i].srcAtom = atoms[i];
	      }
	    }
	  }, {
	    key: 'getGeo',
	    value: function getGeo() {
	      return this.geoOut;
	    }
	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      this.atoms = null;

	      this.hashLines = null;
	      this.hashEntries = null;
	    }

	    /**
	     * Calculates bounding box for array with spheres (atoms)
	     *
	     * @param {Object}  atoms      Atoms array
	     * @param {Vector3} vBoxMin    Bounding box min point
	     * @param {Vector3} vBoxMax    Bounding box max point
	     */

	  }, {
	    key: 'getBoundingBox',
	    value: function getBoundingBox(atoms, vBoxMin, vBoxMax) {
	      var bigNum = 10000000.0;

	      vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
	      vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;

	      var probeRadius2 = this.probeRadius * this.atomRadiusScale;
	      var radMax = 0.0;
	      for (var i = 0, num = atoms.length; i < num; i++) {
	        var vCenter = atoms[i].coord;
	        var rad = atoms[i].radius + probeRadius2;
	        radMax = rad > radMax ? rad : radMax;
	        if (vCenter.x - rad < vBoxMin.x) {
	          vBoxMin.x = vCenter.x - rad;
	        }
	        if (vCenter.y - rad < vBoxMin.y) {
	          vBoxMin.y = vCenter.y - rad;
	        }
	        if (vCenter.z - rad < vBoxMin.z) {
	          vBoxMin.z = vCenter.z - rad;
	        }
	        if (vCenter.x + rad > vBoxMax.x) {
	          vBoxMax.x = vCenter.x + rad;
	        }
	        if (vCenter.y + rad > vBoxMax.y) {
	          vBoxMax.y = vCenter.y + rad;
	        }
	        if (vCenter.z + rad > vBoxMax.z) {
	          vBoxMax.z = vCenter.z + rad;
	        }
	      }
	      vBoxMin.x -= radMax;
	      vBoxMin.y -= radMax;
	      vBoxMin.z -= radMax;
	      vBoxMax.x += radMax;
	      vBoxMax.y += radMax;
	      vBoxMax.z += radMax;
	    }

	    /**
	     * Calculate (x,y,z) cordinate of the cell corner point
	     *
	     * @param {Vector3} vBoxMin Bounding box min point
	     * @param {Vector3} vBoxMax Bounding box max point
	     * @param {number} x Cell integer x coordinate
	     * @param {number} y Cell integer y coordinate
	     * @param {number} z Cell integer z coordinate
	     * @param {number} numPoints NUm points in cell on side
	     * @param {Vector3} vOut Output vector
	     */

	  }, {
	    key: 'getCornerCoord',
	    value: function getCornerCoord(vBoxMin, vBoxMax, x, y, z, numPoints, vOut) {
	      var invNP = 1.0 / (numPoints - 1.0);
	      var tx = x * invNP;
	      var ty = y * invNP;
	      var tz = z * invNP;

	      vOut.x = vBoxMin.x * (1.0 - tx) + vBoxMax.x * tx;
	      vOut.y = vBoxMin.y * (1.0 - ty) + vBoxMax.y * ty;
	      vOut.z = vBoxMin.z * (1.0 - tz) + vBoxMax.z * tz;
	    }

	    /**
	     * Calculate point of intersection of sphere surface
	     * and cell edge, given by [indexA, indexB] line
	     *
	     * @param {number} indexA Cell vertex index in [0..11]
	     * @param {number} indexB Cell vertex index in [0..11]
	     * @param {array}  sign   Sign array for all 8 vertices
	     * @param {object} cube   Cube
	     * @param {number} indexPointValue for value placement
	     * @param {Vector3} vOut  Point of intersection
	     */

	  }, {
	    key: 'buildEdgePoint',
	    value: function buildEdgePoint(indexA, indexB, sign, cube, indexPointValue, vOut) {
	      if (sign[indexA] ^ sign[indexB]) {
	        var cTwentyFour = 24;
	        var t = (0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]) / (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]);
	        var xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
	        var ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
	        var za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
	        var xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
	        var yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
	        var zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];

	        vOut.x = xa * (1.0 - t) + xb * t;
	        vOut.y = ya * (1.0 - t) + yb * t;
	        vOut.z = za * (1.0 - t) + zb * t;
	      }
	    }

	    /**
	     * Check if triangle is visible (vertices are close to atoms included in visibility set)
	     *
	     * @param {Vector3} v0 Vertex #0
	     * @param {Vector3} v1 Vertex #1
	     * @param {Vector3} v2 Vertex #2
	     * @returns {boolean} true if triangle is visible
	     */

	  }, {
	    key: 'isTriangleVisible',
	    value: function isTriangleVisible(v0, v1, v2) {
	      var a0 = this.voxelWorld.getClosestAtom(v0);
	      var a1 = this.voxelWorld.getClosestAtom(v1);
	      var a2 = this.voxelWorld.getClosestAtom(v2);
	      if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
	        return false;
	      }

	      return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
	    }

	    /**
	     * Add triangle to result geometry
	     *
	     * @param {Vector3} v0 Vertex #0
	     * @param {Vector3} v1 Vertex #1
	     * @param {Vector3} v2 Vertex #2
	     * @returns {boolean} false if no more triangles can be added
	     */

	  }, {
	    key: 'addTriangle',
	    value: function addTriangle(v0, v1, v2) {
	      if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
	        return true;
	      }

	      var geo = this.geoOut;

	      if (geo._numTriangles >= this.maxNumTriangles) {
	        return false;
	      }

	      // Add vertex with optimize
	      var indInGeo0 = this.addVertexToGeo(geo, v0);
	      var indInGeo1 = this.addVertexToGeo(geo, v1);
	      var indInGeo2 = this.addVertexToGeo(geo, v2);
	      if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
	        return false;
	      }

	      var itr = 3 * geo._numTriangles;
	      geo._indices[itr + 0] = indInGeo0;
	      geo._indices[itr + 1] = indInGeo1;
	      geo._indices[itr + 2] = indInGeo2;
	      geo._numTriangles++;
	      return true;
	    }

	    /**
	     * Build result geometry (triangle mesh) from marching cube cells
	     *
	     * @param {number} meshRes Marchnig cube vertex count on each side
	     * @param {Vector3} vBoxMin Bounding box point min
	     * @param {Vector3} vBoxMax Bounding box point max
	     * @param {number} corners float values array for each cube point
	     * @param {Vector3} vCellStep vector to next cube cell diagonal point
	     * @param {object} cube IsoSurfaceMarchCube object
	     * @returns {number} 0, if success (<0) is error
	     */

	  }, {
	    key: 'buildGeoFromCorners',
	    value: function buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
	      var arrSize = 12;
	      var cNumVerts = 8;
	      var numCells = meshRes - 1;
	      var side = meshRes;
	      var side2 = meshRes * meshRes;
	      //side3 = meshRes * meshRes * meshRes;

	      var vaEdges = new Array(arrSize);
	      for (var i = 0; i < arrSize; i++) {
	        vaEdges[i] = new Vector3();
	      }
	      var sign = [];
	      for (var _i3 = 0; _i3 < cNumVerts; _i3++) {
	        sign[_i3] = 1.0;
	      }
	      // const numCellsIntersected   = 0;
	      // const numTrianglesGenerated = 0;
	      var vCorner = new Vector3();
	      var indCell = 0;
	      var indY = 0;
	      for (var y = 0; y < numCells; y++, indY += side2) {
	        var indZ = 0;
	        for (var z = 0; z < numCells; z++, indZ += side) {
	          for (var x = 0; x < numCells; x++) {
	            if (!cube.hasIntersection[indCell]) {
	              // next cell
	              indCell++;
	              continue;
	            }
	            var bitsInside = cube.bitsInside[indCell];

	            this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner);

	            var indPointValues = indCell * (2 << 2 + 2);
	            for (var _i4 = 0, j = 0; _i4 < cNumVerts; _i4++) {
	              cube.pointsValuesLinear[indPointValues + j] = vCorner.x;j++;
	              cube.pointsValuesLinear[indPointValues + j] = vCorner.y;j++;
	              cube.pointsValuesLinear[indPointValues + j] = vCorner.z;j++;
	            }

	            //cell._points[1].x += vCellStep.x;
	            //cell._points[2].x += vCellStep.x;
	            //cell._points[5].x += vCellStep.x;
	            //cell._points[6].x += vCellStep.x;
	            cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
	            cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
	            cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
	            cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;

	            //cell._points[2].z += vCellStep.z;
	            //cell._points[3].z += vCellStep.z;
	            //cell._points[6].z += vCellStep.z;
	            //cell._points[7].z += vCellStep.z;
	            cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
	            cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
	            cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
	            cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;

	            //cell._points[4].y += vCellStep.y;
	            //cell._points[5].y += vCellStep.y;
	            //cell._points[6].y += vCellStep.y;
	            //cell._points[7].y += vCellStep.y;
	            cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
	            cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
	            cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
	            cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y;

	            // now current cell has intersections (from -x to +x) on some cube edges
	            var indValues = indPointValues + 24;
	            for (var _i5 = 0; _i5 < cNumVerts; ++_i5) {
	              sign[_i5] = cube.pointsValuesLinear[indValues + _i5] < 0.0 ? 1 : 0;
	            }

	            this.buildEdgePoint(0, 1, sign, cube, indPointValues, vaEdges[0]);
	            this.buildEdgePoint(1, 2, sign, cube, indPointValues, vaEdges[1]);
	            this.buildEdgePoint(2, 3, sign, cube, indPointValues, vaEdges[2]);
	            this.buildEdgePoint(3, 0, sign, cube, indPointValues, vaEdges[3]);

	            this.buildEdgePoint(4, 5, sign, cube, indPointValues, vaEdges[4]);
	            this.buildEdgePoint(5, 6, sign, cube, indPointValues, vaEdges[5]);
	            this.buildEdgePoint(6, 7, sign, cube, indPointValues, vaEdges[6]);
	            this.buildEdgePoint(7, 4, sign, cube, indPointValues, vaEdges[7]);

	            this.buildEdgePoint(0, 4, sign, cube, indPointValues, vaEdges[8]);
	            this.buildEdgePoint(1, 5, sign, cube, indPointValues, vaEdges[9]);
	            this.buildEdgePoint(2, 6, sign, cube, indPointValues, vaEdges[10]);
	            this.buildEdgePoint(3, 7, sign, cube, indPointValues, vaEdges[11]);

	            var offs = bitsInside * (2 << 1 + 2);
	            for (var numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
	              // s_triIndicesMarchCube is external array, defined in mold_ind.js
	              var i0 = cube.striIndicesMarchCube[offs + indTri];
	              if (i0 < 0) {
	                break;
	              }
	              var i1 = cube.striIndicesMarchCube[offs + indTri + 1];
	              var i2 = cube.striIndicesMarchCube[offs + indTri + 2];

	              if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])) {
	                return 0 - 2;
	              }
	            } // for numTri

	            // numCellsIntersected++;
	            // numTrianglesGenerated += numTri;

	            // next cell (cube)
	            indCell++;
	          } // for (x)
	        } // for (z)
	      } // for (y)
	      return 0;
	    }

	    /**
	     * Returns number of cell with intersection with at least one sphere.
	     * Using this number, we can estimate required number of vertices
	     * and triangles to build result mesh.
	     *
	     * @param {number} side Number of points in cube voxels
	     * @param {number} numCells Number of cells in cube voxels (per direction)
	     * @param {array} corners Array of float values for cube corner points
	     * @param {object} cube IsoSurfaceMarchCube object
	     * @returns {number} numIntersectedCells
	     */

	  }, {
	    key: 'getNumIntersectedCells',
	    value: function getNumIntersectedCells(side, numCells, corners, cube) {
	      var side2 = side * side;
	      var cNumVerts = 8;
	      var numIntersectedCells = 0;

	      var indCell = 0;
	      var indY = 0;
	      for (var y = 0; y < numCells; y++, indY += side2) {
	        var indZ = 0;
	        for (var z = 0; z < numCells; z++, indZ += side) {
	          for (var x = 0; x < numCells; x++) {
	            var cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
	            var indCorner = x + indZ + indY;

	            cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
	            cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
	            cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
	            cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
	            cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
	            cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
	            cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
	            cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side];

	            // check read exception
	            //assert(side2 + indCorner + side + 1 < side3);

	            // get bit flags inside
	            var bitsInside = 0;
	            for (var i = 0; i < cNumVerts; ++i) {
	              if (cube.pointsValuesLinear[cubeValuesIndex + i] < 0.0) {
	                bitsInside |= 1 << i;
	              }
	            }

	            if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
	              cube.hasIntersection[indCell] = false;
	            } else {
	              cube.hasIntersection[indCell] = true;
	              numIntersectedCells++;
	            }
	            cube.bitsInside[indCell] = bitsInside;
	            // next cell
	            indCell++;
	          } // for (x)
	        } // for (z)
	      } // for (y)
	      return numIntersectedCells;
	    }
	  }, {
	    key: 'getType',
	    value: function getType(letter) {
	      /* eslint-disable no-magic-numbers */
	      var atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];
	      /* eslint-enable no-magic-numbers */

	      if (letter < 1 || letter > atomT.length / 2 || Object.keys(Element$1.ByAtomicNumber).length * 2 !== atomT.length) {
	        throw new Error('atomT.length  should be equal Element.ByAtomicNumber.length * 2');
	      }
	      return atomT[letter * 2];
	    }

	    /**
	     * Calculate values for marching cube grid points
	     * positive values are outside sphere, negative - is inside
	     *
	     * @param {array} corners array of float values
	     * @param {number} side Number of point in cube in 1 dimennsion
	     * @param {Vector3} vBoxMin Bounding box min point
	     * @param {Vector3} vBoxMax Bounding box max point
	     * @param {array} atoms Array of input atoms
	     * @param {number} probeRad radius for atom probing
	     */

	  }, {
	    key: 'calculateGridCorners',
	    value: function calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
	      var side2 = side * side;
	      var side3 = side2 * side;
	      var vCorner = new Vector3();
	      var vDif = new Vector3();
	      /* eslint-disable no-magic-numbers */
	      var aLot = +1.0e12;
	      /* eslint-enable no-magic-numbers */

	      for (var i = 0; i < side3; i++) {
	        corners[i] = aLot; // to large value
	      }

	      var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
	      var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
	      var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);

	      for (var s = 0, numAtoms = atoms.length; s < numAtoms; s++) {
	        var atom = atoms[s];
	        var radius = atom.radius + probeRad;

	        var fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
	        var fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
	        var fz = (atom.coord.z - radius - vBoxMin.z) * zScale;

	        var indXMin = Math.floor(fx);
	        var indYMin = Math.floor(fy);
	        var indZMin = Math.floor(fz);

	        var indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
	        var indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
	        var indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);

	        indXMax++;
	        indYMax++;
	        indZMax++;
	        indXMax = indXMax <= side - 1 ? indXMax : side - 1;
	        indYMax = indYMax <= side - 1 ? indYMax : side - 1;
	        indZMax = indZMax <= side - 1 ? indZMax : side - 1;

	        for (var y = indYMin; y <= indYMax; y++) {
	          var indY = y * side2;
	          for (var z = indZMin; z <= indZMax; z++) {
	            var indZ = z * side;
	            for (var x = indXMin; x <= indXMax; x++) {
	              var ind = indY + indZ + x;
	              this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner);
	              vDif.x = vCorner.x - atom.coord.x;
	              vDif.y = vCorner.y - atom.coord.y;
	              vDif.z = vCorner.z - atom.coord.z;
	              var distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z);
	              // val: < 0, if inside sphere
	              // val: > 0, if outside sphere
	              var val = distToSphere - radius;
	              if (val < corners[ind]) {
	                corners[ind] = val;
	              }
	            } // for (x)
	          } // for (z)
	        } // for (y)
	      } // for (s)
	    }

	    /**
	     * Create memory pool for vertex hash management
	     *
	     * @param {number} maxNumVertices Maximum possible number of vertices (that will be build)
	     * @param {number} maxNumTriangles Maximum possible number of triangles (that will be build)
	     * @returns {number} 0, if success. (<0) is non memory
	     */

	  }, {
	    key: 'createVertexHash',
	    value: function createVertexHash(maxNumVertices, maxNumTriangles) {

	      this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);
	      if (this.hashLines === null) {
	        return 0 - 1;
	      }
	      for (var i = 0, j = 0; i < HASH_SIZE; i++) {
	        this.hashLines[j++] = 0; // num vertices in this hash line
	        this.hashLines[j++] = 0 - 1; // index of the first entry
	      }

	      this.maxNumVertices = maxNumVertices;
	      this.maxNumTriangles = maxNumTriangles;

	      this.numHashEtriesAllocated = maxNumVertices;
	      this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);
	      if (this.hashEntries === null) {
	        return 0 - 1;
	      }
	      for (var _i6 = 0, _j2 = 0; _i6 < this.numHashEtriesAllocated; _i6++) {
	        this.hashEntries[_j2++] = 0 - 1; // index of vertex
	        this.hashEntries[_j2++] = 0 - 1; // next hash entry index
	      }
	      this.numHashEntryIndex = 0;
	      return 0;
	    }

	    /**
	     * Allocate and return new hash entry. Just check possible amount.
	     *
	     * @returns {number} index of hash entry, that can be used for geometry add vertex functionality
	     */

	  }, {
	    key: 'getNewHashEntry',
	    value: function getNewHashEntry() {
	      if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
	        var i = this.numHashEntryIndex;
	        this.numHashEntryIndex++;
	        return i;
	      }
	      return 0 - 1;
	    }

	    /**
	     * Add vertex to geometry structure
	     * using vertex hash table to quickly check, is this vertex already exist in geometry
	     *
	     * @param {object} geoOut Geometry to build
	     * @param {Vector3} vAdd Vertex to add
	     * @returns {number} index of added (or existing) vertex in geometry.
	     */

	  }, {
	    key: 'addVertexToGeo',
	    value: function addVertexToGeo(geoOut, vAdd) {
	      var entry = void 0;
	      var oneHynberes = 0.01;
	      var n815851 = 815851;
	      var n37633 = 37633;
	      var n2453543 = 2453543;
	      var r106 = 1.0e-6;

	      var hashResolution = this.marCubeResoultion << 2;
	      var v = new Vector3();
	      var ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
	      var iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
	      var iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
	      var iHash = ix * n815851 + iz * n37633 + iy * n2453543;
	      iHash &= HASH_SIZE - 1;
	      var hLineIndex = iHash + iHash;

	      // search vertex via hash
	      // search in hash list
	      if (this.vBoxMin !== null && this.vBoxMax !== null) {
	        for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
	          var ind = this.hashEntries[entry * 2 + 0]; // vertex index
	          v.copy(geoOut._vertices[ind]);
	          v.x -= vAdd.x;
	          v.y -= vAdd.y;
	          v.z -= vAdd.z;
	          var dot2 = v.x * v.x + v.y * v.y + v.z * v.z;
	          if (dot2 < r106) {
	            return ind;
	          } // if (found)
	        } // for (entry)
	      } // search

	      // add new vertex to geometry
	      if (geoOut._numVertices >= this.maxNumVertices) {
	        return 0 - 1;
	      }

	      var iVertAdd = geoOut._numVertices;
	      geoOut._vertices[iVertAdd].copy(vAdd);

	      // add to hash
	      if (this.vBoxMin !== null && this.vBoxMax !== null) {
	        entry = this.getNewHashEntry();
	        if (entry < 0) {
	          return 0 - 1;
	        }
	        var entryFirst = this.hashLines[hLineIndex + 1];
	        this.hashLines[hLineIndex + 1] = entry;
	        this.hashEntries[entry * 2 + 0] = iVertAdd;
	        this.hashEntries[entry * 2 + 1] = entryFirst;

	        this.hashLines[hLineIndex + 0]++; // num vertices in line ++
	      }
	      geoOut._numVertices++;
	      return iVertAdd;
	    }

	    /**
	     *
	     * @param {number} side some placeholder description
	     * @param {number} probeSphereRadius some placeholder description
	     * @param {object} vBoxMin some placeholder description
	     * @param {object} vBoxMax some placeholder description
	     * @param {object} geoOut some placeholder description
	     * @param {object} corners some placeholder description
	     * @returns {number} always 0
	     */

	  }, {
	    key: 'modifyExcludedFromGeo',
	    value: function modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
	      var ind = void 0;
	      var distToSphere = void 0,
	          distToBorder = void 0;
	      var r11 = 1.1;

	      function innerBlockWorkAround() {
	        if (distToBorder > 0.0) {
	          // point is inside probe sphere
	          if (corners[ind] < 0.0) {
	            corners[ind] = distToBorder; // was inside surface, now is oustide ( > 0)
	          }
	          if (distToBorder > corners[ind]) {
	            corners[ind] = distToBorder; // find positive maximum
	          }
	        } else if (distToBorder > corners[ind]) {
	          // point is outside sphere
	          corners[ind] = distToBorder; // find negative maximum
	        }
	      }

	      var side2 = side * side;
	      var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
	      var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
	      var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);

	      var probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
	      var sideInv = 1.0 / (side - 1);

	      for (var i = 0; i < geoOut._numVertices; i++) {
	        var vCenter = geoOut._vertices[i];

	        var radEst = probeSphereRadius * r11;

	        var indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
	        var indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
	        var indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);

	        var indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
	        var indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
	        var indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);

	        indXMin = indXMin >= 0 ? indXMin : 0;
	        indYMin = indYMin >= 0 ? indYMin : 0;
	        indZMin = indZMin >= 0 ? indZMin : 0;
	        indXMax = indXMax <= side - 1 ? indXMax : side - 1;
	        indYMax = indYMax <= side - 1 ? indYMax : side - 1;
	        indZMax = indZMax <= side - 1 ? indZMax : side - 1;

	        for (var iy = indYMin; iy <= indYMax; iy++) {
	          var indY = iy * side2;
	          for (var iz = indZMin; iz <= indZMax; iz++) {
	            var indZ = iz * side;
	            for (var ix = indXMin; ix <= indXMax; ix++) {
	              ind = indY + indZ + ix;
	              //getCornerCoord(vBoxMin, vBoxMax, ix, iy, iz, side, &vCorner);
	              var t = ix * sideInv;
	              var xCorner = vBoxMin.x * (1.0 - t) + vBoxMax.x * t;
	              t = iy * sideInv;
	              var yCorner = vBoxMin.y * (1.0 - t) + vBoxMax.y * t;
	              t = iz * sideInv;
	              var zCorner = vBoxMin.z * (1.0 - t) + vBoxMax.z * t;

	              var dx = xCorner - vCenter.x;
	              var dy = yCorner - vCenter.y;
	              var dz = zCorner - vCenter.z;
	              var dist2 = dx * dx + dy * dy + dz * dz;
	              if (dist2 < probeSpRad2) {
	                distToSphere = Math.sqrt(dist2);
	                distToBorder = -(distToSphere - probeSphereRadius);
	                innerBlockWorkAround();
	              } // if (dist from corner point to sphere center more 2 radiuses)
	            } // for (ix)
	          } // for (iz)
	        } // for (iy)
	      } // for (i) all geo vertices
	      return 0;
	    }
	  }, {
	    key: '_innerBuild',
	    value: function _innerBuild() {
	      var ok = void 0;
	      var oneHundered = 100;
	      var r35 = 3.5;
	      var r12 = 1.2;

	      // performance test
	      //this.performanceTest();

	      // Create temporary atoms (but colored)
	      var packedArrays = {
	        posRad: this._posRad,
	        colors: this._colors,
	        atoms: this._opts.atoms
	      };
	      this.complex = this._opts.parent;
	      this.atoms = packedArrays.atoms;
	      this.meshResolution = this._opts.gridSpacing;
	      this.atomRadiusScale = this._opts.radScale;
	      this.colorMode = this._opts.colorMode;
	      this.probeRadius = this._opts.probeRadius;
	      this.useVertexColors = true;
	      this.excludeProbe = this._opts.excludeProbe;
	      this.visibilitySelector = this._opts.visibilitySelector;

	      this.clusterizationType = this._opts.clusterizationType;
	      this.geoOut = null;

	      this.hashLines = null;
	      this.hashEntries = null;
	      this.numHashEtriesAllocated = 0;
	      this.numHashEntryIndex = 0;
	      this.maxNumVertices = 0;
	      this.maxNumTriangles = 0;

	      var atomsColored = new Array(this.atoms.length);
	      this.convertToAtomsColored(packedArrays, atomsColored);

	      // find bbox for spheres scene
	      var vBoxMin = this.vBoxMin = new Vector3();
	      var vBoxMax = this.vBoxMax = new Vector3();
	      this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);

	      var marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2);

	      // build grid corners for Marching cube algorithm
	      var side = marCubeResoultion;
	      var side2 = side * side;
	      var side3 = side2 * side;
	      var corners = utils.allocateTyped(Float32Array, side3);

	      // settings for Clusterization
	      var numVoxels = this.meshResolution;

	      // Fix number of voxels (for clusterization) if too much
	      var numIdealVoxels = 4;
	      var numAtomsSrc = this.atoms.length;
	      if (numAtomsSrc >= oneHundered) {
	        numIdealVoxels = Math.floor(Math.pow(numAtomsSrc * 2, 1.0 / (1 + 2)));
	      }
	      if (numVoxels > numIdealVoxels) {
	        numVoxels = numIdealVoxels;
	      }
	      var rProbeRadius = this.probeRadius * this.atomRadiusScale;

	      // build clustered atoms
	      var clusterBuilder = null;
	      var atomsClustered = null;
	      if (this.clusterizationType > 0) {
	        clusterBuilder = new IsoSurfaceCluster(this.complex, this.atoms, atomsColored, vBoxMin, vBoxMax, numVoxels, this.colorMode);
	        if (this.clusterizationType === 1) {
	          atomsClustered = clusterBuilder.buildKMeans();
	        } else {
	          atomsClustered = clusterBuilder.buildSimple();
	        }
	        // redbuild bbox again due to increase of radius
	        //this.getBoundingBox(atomsClustered, vBoxMin, vBoxMax);
	        vBoxMin.x -= r35;
	        vBoxMin.y -= r35;
	        vBoxMin.z -= r35;
	        vBoxMax.x += r35;
	        vBoxMax.y += r35;
	        vBoxMax.z += r35;
	        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsClustered, rProbeRadius);
	      } else {
	        this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
	      }

	      var numCells = marCubeResoultion - 1;
	      var cube = new IsoSurfaceMarchCube();
	      ok = cube.create(numCells);
	      if (ok < 0) {
	        return ok;
	      }
	      // copy corners to cells
	      var vCellStep = new Vector3();
	      vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
	      vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
	      vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;

	      var numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
	      var maxNumVertices = Math.floor(numIntersectedCellsEstim * r12);
	      var maxNumTriangles = Math.floor(numIntersectedCellsEstim * r12 * 2);

	      this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);

	      ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
	      if (ok < 0) {
	        return ok;
	      }

	      // build voxel world (used to check triangle-to-atom tie and to calculate normals and colors)
	      var probeRadForNormalsColors = rProbeRadius;
	      if (this.excludeProbe) {
	        probeRadForNormalsColors = 0.01;
	      }
	      this.voxelWorld = null;
	      if (this.clusterizationType > 0) {
	        this.voxelWorld = new IsosurfaceBuildNormals(atomsClustered.length, atomsClustered, //NOSONAR
	        vBoxMin, vBoxMax, probeRadForNormalsColors);
	      } else {
	        this.voxelWorld = new IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
	      }
	      this.voxelWorld.createVoxels();

	      ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);
	      if (this.excludeProbe) {
	        // using 3d mesh (geoOut) as a surface points
	        // move probe sphere and try to minimuze corners values
	        this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners);

	        // delete old builded geo
	        this.geoOut._vertices = null;
	        this.geoOut._colors = null;
	        this.geoOut._indices = null;
	        this.geoOut._normals = null;
	        this.geoOut._numVertices = 0;
	        this.geoOut._numTriangles = 0;
	        this.geoOut = null;

	        // estimage geo vertices budget again
	        numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
	        maxNumVertices = Math.floor(numIntersectedCellsEstim * r12);
	        maxNumTriangles = Math.floor(numIntersectedCellsEstim * r12 * 2);

	        // creates empty new geometry
	        this.geoOut = new IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
	        ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
	        if (ok < 0) {
	          return ok;
	        }
	        // build vertices and triangles from corners values
	        ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
	      }

	      // build vertex normals
	      if (this.voxelWorld !== null) {
	        this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals);
	        // More value : more smooth color mixing
	        // value about 0.7: very rough colors borders
	        var radiusColorSmoothness = 6.5;
	        if (this.excludeProbe) {
	          radiusColorSmoothness -= 1.5;
	        }
	        if (this.useVertexColors) {
	          this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
	        }
	      }
	      this.voxelWorld.destroyVoxels();
	      this.voxelWorld = null;

	      // remove objects
	      if (clusterBuilder !== null) {
	        clusterBuilder.destroy();
	      }
	      cube.destroy();

	      return ok;
	    }
	  }]);
	  return SSIsosurfaceGeometry;
	}(IsoSurfaceGeometry);

	function createLabel(fieldTxt, className) {
	  var text = document.createElement('div');
	  text.className = className;

	  if (typeof fieldTxt === 'string') {
	    var spanText = document.createElement('span');
	    spanText.style.fontSize = '150%';
	    var strings = fieldTxt.split('\n');

	    for (var i = 0, n = strings.length; i < n; ++i) {
	      var spanNodeP = document.createElement('span');
	      var spanNodeText = document.createTextNode(strings[i]);
	      spanNodeP.appendChild(spanNodeText);
	      spanText.appendChild(spanNodeP);
	      if (i < n - 1) {
	        spanText.appendChild(document.createElement('br'));
	      }
	    }

	    text.appendChild(spanText);
	  } else {
	    text.appendChild(fieldTxt);
	    //text.style.paddingTop = '10px';
	  }
	  text.worldPos = new Vector3();
	  return text;
	}

	var LabelsGeometry = function (_EventDispatcher) {
	  inherits(LabelsGeometry, _EventDispatcher);

	  function LabelsGeometry(instanceCount, opts) {
	    classCallCheck(this, LabelsGeometry);

	    var _this = possibleConstructorReturn(this, (LabelsGeometry.__proto__ || Object.getPrototypeOf(LabelsGeometry)).call(this));

	    _this._opts = opts;
	    _this.items = [];
	    _this.needsUpdate = false;

	    var xTranslation = -50;
	    var yTranslation = -50;
	    switch (opts.horizontalAlign) {
	      case 'left':
	        xTranslation = 0;
	        break;
	      case 'right':
	        xTranslation = -100;
	        break;
	      default:
	        break;
	    }

	    switch (opts.verticalAlign) {
	      case 'top':
	        yTranslation = -100;
	        break;
	      case 'bottom':
	        yTranslation = 0;
	        break;
	      default:
	        break;
	    }

	    // TODO is code above OK?
	    var deltaPos = new Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
	    _this.userData = {
	      translation: 'translate(' + xTranslation + '%, ' + yTranslation + '%)',
	      offset: deltaPos
	    };
	    return _this;
	  }

	  createClass(LabelsGeometry, [{
	    key: 'setItem',
	    value: function setItem(itemIdx, itemPos, fieldTxt) {
	      var opts = this._opts;
	      var labels = opts.labels;
	      var text = this.items[itemIdx] || createLabel(fieldTxt, 'label label-' + labels);

	      text.worldPos.copy(itemPos);
	      text.style.textAlign = opts.horizontalAlign;
	      text.style.verticalAlign = opts.verticalAlign;
	      this.items[itemIdx] = text;
	    }
	  }, {
	    key: 'setColor',
	    value: function setColor(itemIdx, fColor, bColor) {
	      var text = this.items[itemIdx];
	      text.opts = {
	        color: fColor,
	        background: bColor
	      };
	    }
	  }, {
	    key: 'startUpdate',
	    value: function startUpdate() {
	      return true;
	    }
	  }, {
	    key: 'finishUpdate',
	    value: function finishUpdate() {
	      this.needsUpdate = true;
	      this.dispatchEvent({ type: 'update' });
	    }
	  }, {
	    key: 'finalize',
	    value: function finalize() {
	      this.finishUpdate();
	    }

	    // unimplemented functions

	  }, {
	    key: 'raycast',
	    value: function raycast() {}
	  }, {
	    key: 'setOpacity',
	    value: function setOpacity() {}
	  }, {
	    key: 'getSubset',
	    value: function getSubset() {
	      return [];
	    }
	  }]);
	  return LabelsGeometry;
	}(EventDispatcher$1);

	var geometries = {
	  InstancedSpheresGeometry: InstancedSpheresGeometry,
	  SimpleSpheresGeometry: SimpleSpheresGeometry,
	  Simple2CCylindersGeometry: Simple2CCylindersGeometry,
	  Instanced2CCylindersGeometry: Instanced2CCylindersGeometry,
	  ExtrudedObjectsGeometry: ExtrudedObjectsGeometry,
	  ChunkedLinesGeometry: ChunkedLinesGeometry,
	  TwoColorLinesGeometry: TwoColorLinesGeometry,
	  CrossGeometry: CrossGeometry,
	  QuickSurfGeometry: QuickSurfGeometry,
	  ContactSurfaceGeometry: ContactSurfaceGeometry,
	  SSIsosurfaceGeometry: SSIsosurfaceGeometry,
	  LabelsGeometry: LabelsGeometry
	};

	function UberObject (SuperClass) {
	  var NewObjectType = function (_SuperClass) {
	    inherits(NewObjectType, _SuperClass);

	    function NewObjectType() {
	      var _ref;

	      classCallCheck(this, NewObjectType);

	      for (var _len = arguments.length, rest = Array(_len), _key = 0; _key < _len; _key++) {
	        rest[_key] = arguments[_key];
	      }

	      var _this = possibleConstructorReturn(this, (_ref = NewObjectType.__proto__ || Object.getPrototypeOf(NewObjectType)).call.apply(_ref, [this].concat(rest)));

	      _this.onBeforeRender = NewObjectType.prototype.onBeforeRender;
	      return _this;
	    }

	    createClass(NewObjectType, [{
	      key: 'onBeforeRender',
	      value: function onBeforeRender(renderer, scene, camera, geometry, material, group) {
	        this._onBeforeRender(renderer, scene, camera, geometry, material, group);
	        this._update();
	      }
	    }, {
	      key: '_onBeforeRender',
	      value: function _onBeforeRender(_renderer, _scene, _camera, _geometry, _material, _group) {}
	    }, {
	      key: '_update',
	      value: function _update() {
	        var material = this.material;
	        if (!material) {
	          return;
	        }

	        if (material instanceof UberMaterial) {
	          material.updateUniforms();
	        }
	      }
	    }]);
	    return NewObjectType;
	  }(SuperClass);

	  return NewObjectType;
	}

	var Mesh$1 = UberObject(Mesh);

	var ZSpriteMesh = function (_Mesh) {
	  inherits(ZSpriteMesh, _Mesh);

	  function ZSpriteMesh(geometry, material) {
	    classCallCheck(this, ZSpriteMesh);
	    return possibleConstructorReturn(this, (ZSpriteMesh.__proto__ || Object.getPrototypeOf(ZSpriteMesh)).call(this, geometry, material));
	  }

	  createClass(ZSpriteMesh, [{
	    key: '_onBeforeRender',
	    value: function _onBeforeRender(_renderer, _scene, camera, _geometry, _material, _group) {
	      var material = this.material;
	      if (!material) {
	        return;
	      }

	      if (material.uniforms.invModelViewMatrix) {
	        // NOTE: update of modelViewMatrix inside threejs is done after onBeforeRender call,
	        // so we have to do it manually in that place
	        this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
	        // get inverse matrix
	        material.uniforms.invModelViewMatrix.value.getInverse(this.modelViewMatrix);
	        material.uniformsNeedUpdate = true;
	      }
	    }
	  }]);
	  return ZSpriteMesh;
	}(Mesh$1);

	var Mesh$2 = UberObject(Mesh);

	var ZClippedMesh = function (_Mesh) {
	  inherits(ZClippedMesh, _Mesh);

	  function ZClippedMesh(geometry, material) {
	    classCallCheck(this, ZClippedMesh);
	    return possibleConstructorReturn(this, (ZClippedMesh.__proto__ || Object.getPrototypeOf(ZClippedMesh)).call(this, geometry, material));
	  }

	  createClass(ZClippedMesh, [{
	    key: '_onBeforeRender',
	    value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
	      var geo = this.geometry;
	      var material = this.material;
	      if (!geo.zClip || !material.uberOptions) {
	        return;
	      }

	      var zClipCoef = 0.5;
	      // TODO remove these instantiations
	      var modelView = new Matrix4().multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
	      var scale = new Vector3().setFromMatrixColumn(modelView, 0);
	      var s = scale.length();

	      var center = new Vector3().copy(geo.boundingSphere.center);
	      this.localToWorld(center);
	      material.uberOptions.zClipValue = camera.position.z - center.z - s * (zClipCoef * geo.boundingSphere.radius);
	    }
	  }]);
	  return ZClippedMesh;
	}(Mesh$2);

	var TextMesh = function (_THREE$Group) {
	  inherits(TextMesh, _THREE$Group);

	  function TextMesh(geometry, _material) {
	    classCallCheck(this, TextMesh);

	    var _this = possibleConstructorReturn(this, (TextMesh.__proto__ || Object.getPrototypeOf(TextMesh)).call(this));

	    _this.geometry = geometry;

	    var self = _this;
	    self.initialized = false;
	    _this.geometry.addEventListener('update', function () {
	      self.update();
	    });
	    return _this;
	  }

	  createClass(TextMesh, [{
	    key: 'init',
	    value: function init() {
	      var children = this.children;
	      for (var i = children.length - 1; i >= 0; --i) {
	        this.remove(children[i]);
	      }

	      var items = this.geometry.items;
	      var userData = this.geometry.userData;
	      for (var _i = 0, n = items.length; _i < n; ++_i) {
	        var srcItem = items[_i];
	        if (!srcItem) {
	          continue;
	        }
	        var item = utils.shallowCloneNode(srcItem);
	        var label = new CSS2DObject(item);
	        label.userData = lodash.clone(userData);
	        var el = label.getElement();
	        el.style.visibility = 'visible';
	        label.source = srcItem;
	        this.add(label);
	      }
	      this.initialized = true;
	    }
	  }, {
	    key: 'update',
	    value: function update() {
	      var geo = this.geometry;
	      if (!geo.needsUpdate) {
	        return;
	      }
	      var children = this.children;
	      if (!this.initialized) {
	        this.init();
	      }

	      for (var i = 0, n = children.length; i < n; ++i) {
	        var child = children[i];
	        var item = child.source;
	        child.position.copy(item.worldPos);
	        child.userData.color = item.opts.color;
	        child.userData.background = item.opts.background;
	      }
	    }
	  }]);
	  return TextMesh;
	}(Group);

	var Mesh$3 = UberObject(Mesh);

	var ThickLineMesh = function (_Mesh) {
	  inherits(ThickLineMesh, _Mesh);

	  function ThickLineMesh(geometry, material) {
	    classCallCheck(this, ThickLineMesh);
	    return possibleConstructorReturn(this, (ThickLineMesh.__proto__ || Object.getPrototypeOf(ThickLineMesh)).call(this, geometry, material));
	  }

	  createClass(ThickLineMesh, [{
	    key: '_onBeforeRender',
	    value: function _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
	      var material = this.material;
	      if (!material.uberOptions) {
	        return;
	      }

	      material.uberOptions.projMatrixInv.getInverse(camera.projectionMatrix, true);
	      var viewport = renderer.getSize();
	      material.uberOptions.viewport.set(viewport.width, viewport.height);
	    }
	  }]);
	  return ThickLineMesh;
	}(Mesh$3);

	var meshes = {
	  ZClipped: ZClippedMesh,
	  ZSprite: ZSpriteMesh,
	  Text: TextMesh,
	  Line: UberObject(Line),
	  LineSegments: UberObject(LineSegments),
	  Mesh: UberObject(Mesh),
	  ThickLineMesh: ThickLineMesh
	};

	function setMatParams(params, uniforms) {
	  return function (material) {
	    material.setValues(params);
	    material.setUberOptions(uniforms);
	  };
	}

	function _createInstancedCylinders(useZSprites, openEnded) {
	  return {
	    Geometry: function Geometry(a, b) {
	      return new geometries.Instanced2CCylindersGeometry(a, b, useZSprites, openEnded);
	    },
	    Object: meshes.ZSprite,
	    initMaterial: setMatParams({
	      instancedMatrix: true,
	      attrColor: true,
	      attrColor2: true,
	      attrAlphaColor: true,
	      cylinderSprite: useZSprites
	    })
	  };
	}

	function _createLineSegmentsGeoTriplet(geo, renderParams) {
	  var thickLines = geo.prototype instanceof ThickLinesGeometry;
	  var lineWidth = renderParams.lineWidth || 0;
	  return {
	    Geometry: geo,
	    Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
	    initMaterial: setMatParams({
	      lights: false,
	      attrColor: true,
	      attrAlphaColor: true,
	      thickLine: thickLines
	    }, {
	      lineWidth: lineWidth
	    })
	  };
	}

	function _createSimpleGeoTriplet(geoClass) {
	  return {
	    Geometry: geoClass,
	    Object: meshes.Mesh,
	    initMaterial: setMatParams({
	      attrColor: true,
	      attrAlphaColor: true
	    })
	  };
	}

	function _createIsoSurfaceGeoTriplet(geoClass, caps, settings, renderParams) {
	  var surfaceOpts = {
	    wireframe: !!renderParams.wireframe,
	    fakeOpacity: settings.now.isoSurfaceFakeOpacity,
	    zClip: renderParams.zClip
	  };
	  return {
	    Geometry: geoClass,
	    Object: meshes.ZClipped,
	    initMaterial: setMatParams({
	      attrColor: true,
	      attrAlphaColor: false,
	      wireframe: surfaceOpts.wireframe,
	      fakeOpacity: surfaceOpts.fakeOpacity,
	      zClip: surfaceOpts.zClip
	    })
	  };
	}

	var MeshCreator = function () {
	  function MeshCreator() {
	    classCallCheck(this, MeshCreator);
	  }

	  createClass(MeshCreator, null, [{
	    key: 'createSpheres',
	    value: function createSpheres(caps, settings) {
	      var useZSprites = settings.now.zSprites;
	      return {
	        Geometry: function Geometry(a, b) {
	          return new geometries.InstancedSpheresGeometry(a, b, useZSprites);
	        },
	        Object: meshes.ZSprite,
	        initMaterial: setMatParams({
	          instancedPos: true,
	          attrColor: true,
	          attrAlphaColor: true,
	          sphereSprite: useZSprites
	        })
	      };
	    }

	    // TODO thisnk about interface and responsibilities

	  }, {
	    key: 'create2CClosedCylinders',
	    value: function create2CClosedCylinders(_caps, _settings) {
	      return _createInstancedCylinders(false, false);
	    }
	  }, {
	    key: 'create2CCylinders',
	    value: function create2CCylinders(caps, settings) {
	      return _createInstancedCylinders(settings.now.zSprites, true);
	    }
	  }, {
	    key: 'create2CLines',
	    value: function create2CLines(_caps, _settings, renderParams) {
	      return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
	    }
	  }, {
	    key: 'createCrosses',
	    value: function createCrosses(_caps, _settings, renderParams) {
	      return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
	    }
	  }, {
	    key: 'createExtrudedChains',
	    value: function createExtrudedChains(_caps, _settings) {
	      return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
	    }
	  }, {
	    key: 'createChunkedLines',
	    value: function createChunkedLines(_caps, _settings, renderParams) {
	      return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
	    }
	  }, {
	    key: 'createQuickSurface',
	    value: function createQuickSurface(caps, settings, renderParams) {
	      return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings, renderParams);
	    }
	  }, {
	    key: 'createContactSurface',
	    value: function createContactSurface(caps, settings, renderParams) {
	      return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings, renderParams);
	    }
	  }, {
	    key: 'createSASSES',
	    value: function createSASSES(caps, settings, renderParams) {
	      return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings, renderParams);
	    }
	  }, {
	    key: 'createLabels',
	    value: function createLabels(_caps, _settings) {
	      return {
	        Geometry: geometries.LabelsGeometry,
	        Object: meshes.Text,
	        initMaterial: function initMaterial() {}
	      };
	    }
	  }]);
	  return MeshCreator;
	}();

	var TransformGroup = function (_THREE$Object3D) {
	  inherits(TransformGroup, _THREE$Object3D);

	  function TransformGroup(geometry, geoParams, material, transforms) {
	    classCallCheck(this, TransformGroup);

	    var _this = possibleConstructorReturn(this, (TransformGroup.__proto__ || Object.getPrototypeOf(TransformGroup)).call(this));

	    _this._geometry = geometry;
	    _this._geoParams = geoParams;
	    var mat = material.createInstance();
	    geoParams.initMaterial(mat);
	    _this._material = mat;
	    _this._transforms = transforms.length > 0 ? transforms : [new Matrix4()];
	    var meshes = _this._createMeshes(geometry);
	    for (var i = 0, n = meshes.length; i < n; ++i) {
	      _this.add(meshes[i]);
	    }
	    return _this;
	  }

	  createClass(TransformGroup, [{
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var ray = TransformGroup._ray;
	      var inverseMatrix = TransformGroup._inverseMatrix;
	      var children = this.children;
	      ray.copy(raycaster.ray);
	      for (var i = 0, n = children.length; i < n; ++i) {
	        var child = children[i];
	        child.updateMatrixWorld();
	        var mtx = child.matrixWorld;
	        // TODO check near / far?
	        inverseMatrix.getInverse(mtx);
	        raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
	        var childIntersects = [];
	        this._geometry.raycast(raycaster, childIntersects);

	        for (var j = 0, ciCount = childIntersects.length; j < ciCount; ++j) {
	          var inters = childIntersects[j];
	          if (inters.point) {
	            inters.point.applyMatrix4(mtx);
	            inters.distance = ray.origin.distanceTo(inters.point);
	          }
	          inters.object = child;
	          // TODO: check raycaster near/far?
	          intersects[intersects.length] = inters;
	        }
	      }
	      raycaster.ray.copy(ray);
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(chunkIndices) {
	      var geos = this._geometry.getSubset(chunkIndices);
	      var subset = [];
	      var subIdx = 0;

	      for (var i = 0, n = geos.length; i < n; ++i) {
	        var _meshes = this._createMeshes(geos[i]);
	        for (var j = 0, meshCnt = _meshes.length; j < meshCnt; ++j) {
	          subset[subIdx++] = _meshes[j];
	        }
	      }

	      return subset;
	    }
	  }, {
	    key: '_createMeshes',
	    value: function _createMeshes(geometry) {
	      var transforms = this._transforms;
	      var Mesh$$1 = this._geoParams.Object;
	      var material = this._material;
	      var meshes = [];
	      for (var i = 0, n = transforms.length; i < n; ++i) {
	        var mesh = new Mesh$$1(geometry, material);
	        mesh.applyMatrix(transforms[i]);

	        meshes[i] = mesh;
	      }

	      return meshes;
	    }
	  }]);
	  return TransformGroup;
	}(Object3D);

	TransformGroup._inverseMatrix = new Matrix4();
	TransformGroup._ray = new Ray();

	function wrapper(Name, args) {
	  var params = [Name].concat(args);
	  return Name.bind.apply(Name, params);
	}

	var ChemGroup = function (_RCGroup) {
	  inherits(ChemGroup, _RCGroup);

	  function ChemGroup(geoParams, selection, colorer, mode, transforms, polyComplexity, material) {
	    classCallCheck(this, ChemGroup);

	    var _this = possibleConstructorReturn(this, (ChemGroup.__proto__ || Object.getPrototypeOf(ChemGroup)).call(this));

	    if (_this.constructor === ChemGroup) {
	      throw new Error('Can not instantiate abstract class!');
	    }
	    _this._selection = selection;
	    _this._mode = mode;
	    _this._colorer = colorer;
	    _this._chunksIdc = selection.chunks;
	    _this._polyComplexity = polyComplexity;
	    _this._geo = new (wrapper(geoParams.Geometry, _this._makeGeoArgs()))();
	    _this._mesh = new TransformGroup(_this._geo, geoParams, material, transforms);
	    _this.add(_this._mesh);
	    _this._build();
	    return _this;
	  }

	  createClass(ChemGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      throw new Error('ChemGroup subclass must override _makeGeoArgs() method');
	    }

	    /**
	     * Builds subset geometry by ATOMS index list
	     *
	     * @param {Number} mask - Representation mask
	     * @param {Boolean} innerOnly - if true returns inner bonds only - without halves
	     * @returns {Array} Subset geometry
	     */

	  }, {
	    key: 'getSubset',
	    value: function getSubset(mask, innerOnly) {
	      innerOnly = innerOnly !== undefined ? innerOnly : false;
	      var chunksList = this._calcChunksList(mask, innerOnly);
	      if (chunksList.length === 0) {
	        return [];
	      }
	      return this._mesh.getSubset(chunksList);
	    }
	  }, {
	    key: '_changeSubsetOpacity',
	    value: function _changeSubsetOpacity(mask, value, innerOnly) {
	      var chunksList = this._calcChunksList(mask, innerOnly);
	      if (chunksList.length === 0) {
	        return;
	      }
	      this._geo.setOpacity(chunksList, value);
	    }
	  }, {
	    key: 'enableSubset',
	    value: function enableSubset(mask, innerOnly) {
	      innerOnly = innerOnly !== undefined ? innerOnly : true;
	      this._changeSubsetOpacity(mask, 1.0, innerOnly);
	    }
	  }, {
	    key: 'disableSubset',
	    value: function disableSubset(mask, innerOnly) {
	      innerOnly = innerOnly !== undefined ? innerOnly : true;
	      this._changeSubsetOpacity(mask, 0.0, innerOnly);
	    }
	  }]);
	  return ChemGroup;
	}(RCGroup);

	var AtomsGroup = function (_ChemGroup) {
	  inherits(AtomsGroup, _ChemGroup);

	  function AtomsGroup() {
	    classCallCheck(this, AtomsGroup);
	    return possibleConstructorReturn(this, (AtomsGroup.__proto__ || Object.getPrototypeOf(AtomsGroup)).apply(this, arguments));
	  }

	  createClass(AtomsGroup, [{
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var atoms = this._selection.atoms;
	      var inters = [];
	      this._mesh.raycast(raycaster, inters);
	      var atomsIdc = this._chunksIdc;
	      // process inters array - arr object references
	      for (var i = 0, n = inters.length; i < n; ++i) {
	        if (!inters[i].hasOwnProperty('chunkIdx')) {
	          continue;
	        }
	        var atomIdx = atomsIdc[inters[i].chunkIdx];
	        if (atomIdx < atoms.length) {
	          inters[i].atom = atoms[atomIdx];
	          intersects.push(inters[i]);
	        }
	      }
	    }
	  }, {
	    key: '_calcChunksList',
	    value: function _calcChunksList(mask) {
	      var chunksList = [];
	      var atoms = this._selection.atoms;
	      var atomsIdc = this._chunksIdc;
	      for (var i = 0, n = atomsIdc.length; i < n; ++i) {
	        var atom = atoms[atomsIdc[i]];
	        if ((atom._mask & mask) !== 0) {
	          chunksList.push(i);
	        }
	      }
	      return chunksList;
	    }
	  }]);
	  return AtomsGroup;
	}(ChemGroup);

	var AtomsSphereGroup = function (_AtomsGroup) {
	  inherits(AtomsSphereGroup, _AtomsGroup);

	  function AtomsSphereGroup() {
	    classCallCheck(this, AtomsSphereGroup);
	    return possibleConstructorReturn(this, (AtomsSphereGroup.__proto__ || Object.getPrototypeOf(AtomsSphereGroup)).apply(this, arguments));
	  }

	  createClass(AtomsSphereGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      return [this._selection.chunks.length, this._polyComplexity];
	    }
	  }, {
	    key: '_build',
	    value: function _build() {
	      var atomsIdc = this._selection.chunks;
	      var atoms = this._selection.atoms;
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      for (var i = 0, n = atomsIdc.length; i < n; ++i) {
	        var atom = atoms[atomsIdc[i]];
	        geo.setItem(i, atom._position, mode.calcAtomRadius(atom));
	        geo.setColor(i, colorer.getAtomColor(atom, parent));
	      }
	      geo.finalize();
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      // TODO This method looks like a copy paste. However, it
	      // was decided to postpone animation refactoring until GFX is fixed.
	      var atomsIdc = this._selection.chunks;
	      var atoms = this._selection.atoms;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var updateColor = frameData.needsColorUpdate(colorer);
	      var geo = this._geo;
	      for (var i = 0, n = atomsIdc.length; i < n; ++i) {
	        var atom = atoms[atomsIdc[i]];
	        geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), mode.calcAtomRadius(atom));
	        if (updateColor) {
	          geo.setColor(i, frameData.getAtomColor(colorer, atom));
	        }
	      }
	      geo.finalize();
	    }
	  }]);
	  return AtomsSphereGroup;
	}(AtomsGroup);

	var AtomsSurfaceGroup = function (_AtomsSphereGroup) {
	  inherits(AtomsSurfaceGroup, _AtomsSphereGroup);

	  function AtomsSurfaceGroup() {
	    classCallCheck(this, AtomsSurfaceGroup);
	    return possibleConstructorReturn(this, (AtomsSurfaceGroup.__proto__ || Object.getPrototypeOf(AtomsSurfaceGroup)).apply(this, arguments));
	  }

	  createClass(AtomsSurfaceGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      var selectedAtoms = [];
	      var atoms = this._selection.atoms;
	      var chunks = this._selection.chunks;
	      var i = 0,
	          n = chunks.length;
	      for (; i < n; ++i) {
	        selectedAtoms[i] = atoms[chunks[i]];
	      }
	      var opts = this._mode.getSurfaceOpts();
	      opts.atoms = selectedAtoms;
	      return [n, opts];
	    }
	  }]);
	  return AtomsSurfaceGroup;
	}(AtomsSphereGroup);

	/* This is a stub class keep it until SAS/SES is refactored */

	var AtomsSASSESGroupStub = function (_AtomsSphereGroup) {
	  inherits(AtomsSASSESGroupStub, _AtomsSphereGroup);

	  function AtomsSASSESGroupStub() {
	    classCallCheck(this, AtomsSASSESGroupStub);
	    return possibleConstructorReturn(this, (AtomsSASSESGroupStub.__proto__ || Object.getPrototypeOf(AtomsSASSESGroupStub)).apply(this, arguments));
	  }

	  createClass(AtomsSASSESGroupStub, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      var selectedAtoms = [];
	      var atoms = this._selection.atoms;
	      var chunks = this._selection.chunks;
	      var i = 0,
	          n = chunks.length;
	      for (; i < n; ++i) {
	        selectedAtoms[i] = atoms[chunks[i]];
	      }
	      var opts = this._mode.getSurfaceOpts();
	      opts.atoms = selectedAtoms;
	      opts.selection = this._selection;
	      opts.colorMode = this._colorer;
	      return [n, opts];
	    }
	  }]);
	  return AtomsSASSESGroupStub;
	}(AtomsSphereGroup);

	function adjustColor(color) {
	  var r = color >> 16 & 255;
	  var g = color >> 8 & 255;
	  var b = color & 255;

	  if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
	    r = r * 3 / 10;
	    g = g * 3 / 10;
	    b = b * 3 / 10;
	  } else {
	    r = 255 - (255 - r) * 3 / 10;
	    g = 255 - (255 - g) * 3 / 10;
	    b = 255 - (255 - b) * 3 / 10;
	  }

	  return r << 16 | g << 8 | b;
	}

	function inverseColor(color) {
	  var r = color >> 16 & 255;
	  var g = color >> 8 & 255;
	  var b = color & 255;

	  return 255 - r << 16 | 255 - g << 8 | 255 - b;
	}

	function getAtomText(atom) {
	  if (atom.getName().getNode() !== null) {
	    return atom.getName().getNode();
	  }

	  if (!atom.isLabelVisible()) {
	    return null;
	  }

	  return atom.getVisualName();
	}

	var colorMappings = {
	  none: function none(c) {
	    return c;
	  },
	  adjust: adjustColor,
	  inverse: inverseColor
	};

	function propagateColor(color, rule) {
	  var result = void 0;
	  if (colorMappings.hasOwnProperty(rule)) {
	    result = utils.hexColor(colorMappings[rule](color));
	  } else {
	    var val = parseInt(rule, 16);
	    if (!Number.isNaN(val) && rule.toLowerCase().startsWith('0x')) {
	      result = utils.hexColor(val);
	    } else {
	      result = '#000000';
	    }
	  }
	  return result;
	}

	var templateMappings = {
	  serial: function serial(a) {
	    return a.getSerial();
	  },
	  name: function name(a) {
	    return a.getVisualName();
	  },
	  elem: function elem(a) {
	    return a.element.name;
	  },
	  residue: function residue(a) {
	    return a._residue.getType().getName();
	  },
	  sequence: function sequence(a) {
	    return a._residue.getSequence();
	  },
	  chain: function chain(a) {
	    return a._residue.getChain().getName();
	  },
	  hetatm: function hetatm(a) {
	    return a.isHet();
	  },
	  water: function water(a) {
	    return a._residue.getType().getName() === 'HOH' || a._residue.getType().getName() === 'WAT';
	  }
	};

	var parseTemplate = function parseTemplate(atom, str) {
	  return str.replace(/\{\{(\s*\w+\s*)\}\}/g, function (m) {
	    var key = m.replace(/\s+/g, '');
	    key = key.substring(2, key.length - 2).toLowerCase();

	    if (templateMappings.hasOwnProperty(key)) {
	      return templateMappings[key](atom);
	    }
	    return 'null';
	  });
	};

	var AtomsTextGroup = function (_AtomsGroup) {
	  inherits(AtomsTextGroup, _AtomsGroup);

	  function AtomsTextGroup() {
	    classCallCheck(this, AtomsTextGroup);
	    return possibleConstructorReturn(this, (AtomsTextGroup.__proto__ || Object.getPrototypeOf(AtomsTextGroup)).apply(this, arguments));
	  }

	  createClass(AtomsTextGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      var opts = this._mode.getLabelOpts();
	      return [this._selection.chunks.length, opts];
	    }
	  }, {
	    key: '_build',
	    value: function _build() {
	      var opts = this._mode.getLabelOpts();
	      // TODO is it correct to filter atoms here?
	      var atomsIdc = this._selection.chunks;
	      var atoms = this._selection.atoms;
	      var parent = this._selection.parent;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      for (var i = 0, n = atomsIdc.length; i < n; ++i) {
	        var atom = atoms[atomsIdc[i]];
	        var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
	        if (!text) {
	          continue;
	        }
	        var color = colorer.getAtomColor(atom, parent);
	        var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
	        var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
	        geo.setItem(i, atom.getPosition(), text);
	        geo.setColor(i, fgColor, bgColor);
	      }
	      geo.finalize();
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      // TODO This method looks like a copy paste. However, it
	      // was decided to postpone animation refactoring until GFX is fixed.
	      var opts = this._mode.getLabelOpts();
	      // TODO is it correct to filter atoms here?
	      var atomsIdc = this._selection.chunks;
	      var atoms = this._selection.atoms;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var updateColor = frameData.needsColorUpdate(colorer);
	      for (var i = 0, n = atomsIdc.length; i < n; ++i) {
	        var atom = atoms[atomsIdc[i]];
	        var text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
	        if (!text) {
	          continue;
	        }
	        var color = frameData.getAtomColor(colorer, atom);
	        var fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
	        var bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
	        geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), text);
	        if (updateColor) {
	          geo.setColor(i, fgColor, bgColor);
	        }
	      }
	      geo.finalize();
	    }
	  }]);
	  return AtomsTextGroup;
	}(AtomsGroup);

	function _slerp(omega, v1, v2, t) {
	  var oSin = Math.sin(omega);
	  return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
	}

	var AromaticGroup = function (_AtomsGroup) {
	  inherits(AromaticGroup, _AtomsGroup);

	  function AromaticGroup() {
	    classCallCheck(this, AromaticGroup);
	    return possibleConstructorReturn(this, (AromaticGroup.__proto__ || Object.getPrototypeOf(AromaticGroup)).apply(this, arguments));
	  }

	  createClass(AromaticGroup, [{
	    key: '_buildInner',
	    value: function _buildInner(radOffset, addChunk) {
	      var chunksToIdx = this._selection.chunks;

	      var prevVector = new Vector3();
	      var currVector = new Vector3();
	      var segmentsHeight = this._segmentsHeight;
	      var leprStep = 1.0 / segmentsHeight;
	      var colorer = this._colorer;

	      var cycles = this._selection.cycles;
	      var parent = this._selection.parent;
	      var chunkIdx = 0;
	      var currAtomIdx = chunksToIdx[chunkIdx];

	      for (var cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
	        var cycle = cycles[cIdx];
	        var cycAtoms = cycle.atoms;
	        var chunkPoints = [];
	        var tmpDir = [];
	        var center = cycle.center;
	        var cycleRad = cycle.radius - radOffset;
	        var n = cycAtoms.length;
	        var i = 0;
	        var prevPos = cycAtoms[n - 1]._position;
	        var currPos = cycAtoms[i]._position;
	        prevVector.subVectors(prevPos, center);
	        currVector.subVectors(currPos, center);
	        var upDir = currVector.clone().cross(prevVector).normalize();

	        for (; i < n; ++i) {
	          var omega = prevVector.angleTo(currVector);
	          tmpDir[i] = _slerp(omega, prevVector, currVector, 0.5).normalize();
	          currPos = cycAtoms[(i + 1) % n]._position;
	          prevVector.copy(currVector);
	          currVector.subVectors(currPos, center);
	        }

	        for (i = 0; i < n; ++i) {
	          if (cycAtoms[i]._index !== currAtomIdx) {
	            continue;
	          }
	          var start = tmpDir[i];
	          var end = tmpDir[(i + 1) % n];
	          var color = colorer.getAtomColor(cycAtoms[i], parent);
	          var currAngle = start.angleTo(end);

	          for (var j = 0; j <= segmentsHeight; ++j) {
	            chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
	          }

	          addChunk(chunkIdx++, color, chunkPoints, center, upDir);
	          currAtomIdx = chunksToIdx[chunkIdx];
	        }
	      }
	    }
	  }]);
	  return AromaticGroup;
	}(AtomsGroup);

	function _createShape(rad, parts) {
	  var pts = [];
	  for (var i = 0; i < parts; ++i) {
	    var a = 2 * i / parts * Math.PI;
	    pts.push(new Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
	  }
	  return pts;
	}
	var calcChunkMatrix = gfxutils.calcChunkMatrix;

	var AromaticTorusGroup = function (_AromaticGroup) {
	  inherits(AromaticTorusGroup, _AromaticGroup);

	  function AromaticTorusGroup() {
	    classCallCheck(this, AromaticTorusGroup);
	    return possibleConstructorReturn(this, (AromaticTorusGroup.__proto__ || Object.getPrototypeOf(AromaticTorusGroup)).apply(this, arguments));
	  }

	  createClass(AromaticTorusGroup, [{
	    key: '_build',
	    value: function _build() {
	      var segmentsHeight = this._segmentsHeight;
	      var torusRad = this._mode.getAromRadius();
	      var radiusV = new Vector2(torusRad, torusRad);
	      var radOffset = this._mode.calcStickRadius() + 2 * torusRad;
	      var lookAtVector = new Vector3();
	      var mtc = [];
	      var geo = this._geo;
	      this._buildInner(radOffset, function (chunkIdx, color, points, center, upDir) {
	        for (var j = 0; j <= segmentsHeight; ++j) {
	          var currPoint = points[j];
	          var currDir = currPoint.clone().sub(center).cross(upDir);
	          lookAtVector.addVectors(currPoint, currDir);
	          mtc[j] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
	        }
	        geo.setItem(chunkIdx, mtc);
	        geo.setColor(chunkIdx, color);
	      });
	      geo.finalize();
	    }
	  }, {
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      this._segmentsHeight = this._polyComplexity;
	      return [_createShape(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
	    }
	  }]);
	  return AromaticTorusGroup;
	}(AromaticGroup);

	var AromaticLinesGroup = function (_AromaticGroup) {
	  inherits(AromaticLinesGroup, _AromaticGroup);

	  function AromaticLinesGroup() {
	    classCallCheck(this, AromaticLinesGroup);
	    return possibleConstructorReturn(this, (AromaticLinesGroup.__proto__ || Object.getPrototypeOf(AromaticLinesGroup)).apply(this, arguments));
	  }

	  createClass(AromaticLinesGroup, [{
	    key: '_build',
	    value: function _build() {
	      var _this2 = this;

	      var geo = this._geo;
	      var radOffset = this._mode.getAromaticOffset();
	      this._buildInner(radOffset, function (chunkIdx, color, points) {
	        var prevPt = points[0]; //do not replace with start
	        for (var j = 1; j <= _this2._segmentsHeight; ++j) {
	          var currPoint = points[j];
	          geo.setSegment(chunkIdx, j - 1, prevPt, currPoint);
	          prevPt = currPoint;
	        }
	        geo.setColor(chunkIdx, color);
	      });
	      geo.finalize();
	    }
	  }, {
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      this._segmentsHeight = this._mode.getAromaticArcChunks();
	      return [this._selection.chunks.length, this._segmentsHeight, true];
	    }
	  }]);
	  return AromaticLinesGroup;
	}(AromaticGroup);

	var ResiduesGroup = function (_ChemGroup) {
	  inherits(ResiduesGroup, _ChemGroup);

	  function ResiduesGroup() {
	    classCallCheck(this, ResiduesGroup);
	    return possibleConstructorReturn(this, (ResiduesGroup.__proto__ || Object.getPrototypeOf(ResiduesGroup)).apply(this, arguments));
	  }

	  createClass(ResiduesGroup, [{
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var residues = this._selection.residues;
	      var inters = [];
	      this._mesh.raycast(raycaster, inters);
	      var chunksIdc = this._chunksIdc;
	      // process inters array - arr object references
	      for (var i = 0, n = inters.length; i < n; ++i) {
	        if (!inters[i].hasOwnProperty('chunkIdx')) {
	          continue;
	        }
	        var resIdx = chunksIdc[inters[i].chunkIdx];
	        if (resIdx < residues.length) {
	          inters[i].residue = residues[resIdx];
	          intersects.push(inters[i]);
	        }
	      }
	    }
	  }, {
	    key: '_calcChunksList',
	    value: function _calcChunksList(mask) {
	      var chunksList = [];
	      var residues = this._selection.residues;
	      var resIdc = this._chunksIdc;
	      for (var i = 0, n = resIdc.length; i < n; ++i) {
	        var res = residues[resIdc[i]];
	        if ((res._mask & mask) !== 0) {
	          chunksList.push(i);
	        }
	      }
	      return chunksList;
	    }
	  }]);
	  return ResiduesGroup;
	}(ChemGroup);

	var NucleicItemGroup = function (_ResiduesGroup) {
	  inherits(NucleicItemGroup, _ResiduesGroup);

	  function NucleicItemGroup() {
	    classCallCheck(this, NucleicItemGroup);
	    return possibleConstructorReturn(this, (NucleicItemGroup.__proto__ || Object.getPrototypeOf(NucleicItemGroup)).apply(this, arguments));
	  }

	  createClass(NucleicItemGroup, [{
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var residues = this._selection.residues;
	      var inters = [];
	      this._mesh.raycast(raycaster, inters);
	      var chunksIdc = this._chunksIdc;
	      // process inters array - arr object references
	      for (var i = 0, n = inters.length; i < n; ++i) {
	        if (!inters[i].hasOwnProperty('chunkIdx')) {
	          continue;
	        }
	        var resIdx = chunksIdc[Math.floor(inters[i].chunkIdx / 2)];
	        if (resIdx < residues.length) {
	          inters[i].residue = residues[resIdx];
	          intersects.push(inters[i]);
	        }
	      }
	    }
	  }, {
	    key: '_build',
	    value: function _build() {
	      var residues = this._selection.residues;
	      var parent = this._selection.parent;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var stickRad = this._mode.calcStickRadius();
	      var chunkIdx = 0;

	      var resIdc = this._selection.chunks;
	      for (var i = 0, n = resIdc.length; i < n; ++i) {
	        var res = residues[resIdc[i]];
	        var color = colorer.getResidueColor(res, parent);
	        this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
	      }
	      geo.finalize();
	    }
	  }, {
	    key: '_calcChunksList',
	    value: function _calcChunksList(mask) {
	      var chunksList = [];
	      var chunkIdx = 0;
	      var residues = this._selection.residues;
	      var resIdc = this._chunksIdc;

	      for (var i = 0, n = resIdc.length; i < n; ++i) {
	        var res = residues[resIdc[i]];
	        if ((res._mask & mask) !== 0) {
	          chunksList[chunkIdx++] = 2 * i;
	          chunksList[chunkIdx++] = 2 * i + 1;
	        }
	      }
	      return chunksList;
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      // TODO This method looks like a copy paste. However, it
	      // was decided to postpone animation refactoring until GFX is fixed.
	      var residues = frameData.getResidues();
	      var parent = this._selection.parent;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var stickRad = this._mode.calcStickRadius();
	      var chunkIdx = 0;

	      var resIdc = this._selection.chunks;
	      for (var i = 0, n = resIdc.length; i < n; ++i) {
	        var res = residues[resIdc[i]];
	        var color = colorer.getResidueColor(res, parent);
	        // TODO Pass color only when it has been changed?
	        this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
	      }
	      geo.finishUpdate();
	    }
	  }]);
	  return NucleicItemGroup;
	}(ResiduesGroup);

	var NucleicCylindersGroup = function (_NucleicItemGroup) {
	  inherits(NucleicCylindersGroup, _NucleicItemGroup);

	  function NucleicCylindersGroup() {
	    classCallCheck(this, NucleicCylindersGroup);
	    return possibleConstructorReturn(this, (NucleicCylindersGroup.__proto__ || Object.getPrototypeOf(NucleicCylindersGroup)).apply(this, arguments));
	  }

	  createClass(NucleicCylindersGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      return [this._selection.chunks.length, this._polyComplexity];
	    }
	  }, {
	    key: '_processItem',
	    value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
	      var geo = this._geo;
	      geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
	      geo.setColor(chunkIdx, color, color);
	    }
	  }]);
	  return NucleicCylindersGroup;
	}(NucleicItemGroup);

	var NucleicSpheresGroup = function (_NucleicItemGroup) {
	  inherits(NucleicSpheresGroup, _NucleicItemGroup);

	  function NucleicSpheresGroup() {
	    classCallCheck(this, NucleicSpheresGroup);
	    return possibleConstructorReturn(this, (NucleicSpheresGroup.__proto__ || Object.getPrototypeOf(NucleicSpheresGroup)).apply(this, arguments));
	  }

	  createClass(NucleicSpheresGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      return [this._selection.chunks.length * 2, this._polyComplexity];
	    }
	  }, {
	    key: '_processItem',
	    value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
	      var geo = this._geo;
	      var idx = chunkIdx * 2;
	      geo.setItem(idx, cyl1, stickRad);
	      geo.setColor(idx, color);
	      idx++;
	      geo.setItem(idx, cyl2, stickRad);
	      geo.setColor(idx, color);
	    }
	  }]);
	  return NucleicSpheresGroup;
	}(NucleicItemGroup);

	var Smooth = createCommonjsModule(function (module, exports) {
	/*
	Smooth.js version 0.1.7

	Turn arrays into smooth functions.

	Copyright 2012 Spencer Cohen
	Licensed under MIT license (see "Smooth.js MIT license.txt")
	*/

	/*Constants (these are accessible by Smooth.WHATEVER in user space)
	*/

	(function() {
	  var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, Smooth, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v, validateNumber, validateVector,
	    __hasProp = Object.prototype.hasOwnProperty,
	    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

	  Enum = {
	    /*Interpolation methods
	    */
	    METHOD_NEAREST: 'nearest',
	    METHOD_LINEAR: 'linear',
	    METHOD_CUBIC: 'cubic',
	    METHOD_LANCZOS: 'lanczos',
	    METHOD_SINC: 'sinc',
	    /*Input clipping modes
	    */
	    CLIP_CLAMP: 'clamp',
	    CLIP_ZERO: 'zero',
	    CLIP_PERIODIC: 'periodic',
	    CLIP_MIRROR: 'mirror',
	    /* Constants for control over the cubic interpolation tension
	    */
	    CUBIC_TENSION_DEFAULT: 0,
	    CUBIC_TENSION_CATMULL_ROM: 0
	  };

	  defaultConfig = {
	    method: Enum.METHOD_CUBIC,
	    cubicTension: Enum.CUBIC_TENSION_DEFAULT,
	    clip: Enum.CLIP_CLAMP,
	    scaleTo: 0,
	    sincFilterSize: 2,
	    sincWindow: void 0
	  };

	  /*Index clipping functions
	  */

	  clipClamp = function(i, n) {
	    return Math.max(0, Math.min(i, n - 1));
	  };

	  clipPeriodic = function(i, n) {
	    i = i % n;
	    if (i < 0) i += n;
	    return i;
	  };

	  clipMirror = function(i, n) {
	    var period;
	    period = 2 * (n - 1);
	    i = clipPeriodic(i, period);
	    if (i > n - 1) i = period - i;
	    return i;
	  };

	  /*
	  Abstract scalar interpolation class which provides common functionality for all interpolators
	  
	  Subclasses must override interpolate().
	  */

	  AbstractInterpolator = (function() {

	    function AbstractInterpolator(array, config) {
	      this.array = array.slice(0);
	      this.length = this.array.length;
	      if (!(this.clipHelper = {
	        clamp: this.clipHelperClamp,
	        zero: this.clipHelperZero,
	        periodic: this.clipHelperPeriodic,
	        mirror: this.clipHelperMirror
	      }[config.clip])) {
	        throw "Invalid clip: " + config.clip;
	      }
	    }

	    AbstractInterpolator.prototype.getClippedInput = function(i) {
	      if ((0 <= i && i < this.length)) {
	        return this.array[i];
	      } else {
	        return this.clipHelper(i);
	      }
	    };

	    AbstractInterpolator.prototype.clipHelperClamp = function(i) {
	      return this.array[clipClamp(i, this.length)];
	    };

	    AbstractInterpolator.prototype.clipHelperZero = function(i) {
	      return 0;
	    };

	    AbstractInterpolator.prototype.clipHelperPeriodic = function(i) {
	      return this.array[clipPeriodic(i, this.length)];
	    };

	    AbstractInterpolator.prototype.clipHelperMirror = function(i) {
	      return this.array[clipMirror(i, this.length)];
	    };

	    AbstractInterpolator.prototype.interpolate = function(t) {
	      throw 'Subclasses of AbstractInterpolator must override the interpolate() method.';
	    };

	    return AbstractInterpolator;

	  })();

	  NearestInterpolator = (function(_super) {

	    __extends(NearestInterpolator, _super);

	    function NearestInterpolator() {
	      NearestInterpolator.__super__.constructor.apply(this, arguments);
	    }

	    NearestInterpolator.prototype.interpolate = function(t) {
	      return this.getClippedInput(Math.round(t));
	    };

	    return NearestInterpolator;

	  })(AbstractInterpolator);

	  LinearInterpolator = (function(_super) {

	    __extends(LinearInterpolator, _super);

	    function LinearInterpolator() {
	      LinearInterpolator.__super__.constructor.apply(this, arguments);
	    }

	    LinearInterpolator.prototype.interpolate = function(t) {
	      var k;
	      k = Math.floor(t);
	      t -= k;
	      return (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1);
	    };

	    return LinearInterpolator;

	  })(AbstractInterpolator);

	  CubicInterpolator = (function(_super) {

	    __extends(CubicInterpolator, _super);

	    function CubicInterpolator(array, config) {
	      this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
	      CubicInterpolator.__super__.constructor.apply(this, arguments);
	    }

	    CubicInterpolator.prototype.getTangent = function(k) {
	      return this.tangentFactor * (this.getClippedInput(k + 1) - this.getClippedInput(k - 1)) / 2;
	    };

	    CubicInterpolator.prototype.interpolate = function(t) {
	      var k, m, p, t2, t3;
	      k = Math.floor(t);
	      m = [this.getTangent(k), this.getTangent(k + 1)];
	      p = [this.getClippedInput(k), this.getClippedInput(k + 1)];
	      t -= k;
	      t2 = t * t;
	      t3 = t * t2;
	      return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
	    };

	    return CubicInterpolator;

	  })(AbstractInterpolator);

	  sin = Math.sin, PI = Math.PI;

	  sinc = function(x) {
	    if (x === 0) {
	      return 1;
	    } else {
	      return sin(PI * x) / (PI * x);
	    }
	  };

	  makeLanczosWindow = function(a) {
	    return function(x) {
	      return sinc(x / a);
	    };
	  };

	  makeSincKernel = function(window) {
	    return function(x) {
	      return sinc(x) * window(x);
	    };
	  };

	  SincFilterInterpolator = (function(_super) {

	    __extends(SincFilterInterpolator, _super);

	    function SincFilterInterpolator(array, config) {
	      SincFilterInterpolator.__super__.constructor.apply(this, arguments);
	      this.a = config.sincFilterSize;
	      if (!config.sincWindow) throw 'No sincWindow provided';
	      this.kernel = makeSincKernel(config.sincWindow);
	    }

	    SincFilterInterpolator.prototype.interpolate = function(t) {
	      var k, n, sum, _ref, _ref2;
	      k = Math.floor(t);
	      sum = 0;
	      for (n = _ref = k - this.a + 1, _ref2 = k + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
	        sum += this.kernel(t - n) * this.getClippedInput(n);
	      }
	      return sum;
	    };

	    return SincFilterInterpolator;

	  })(AbstractInterpolator);

	  getColumn = function(arr, i) {
	    var row, _i, _len, _results;
	    _results = [];
	    for (_i = 0, _len = arr.length; _i < _len; _i++) {
	      row = arr[_i];
	      _results.push(row[i]);
	    }
	    return _results;
	  };

	  makeScaledFunction = function(f, baseScale, scaleRange) {
	    var scaleFactor, translation;
	    if (scaleRange.join === '0,1') {
	      return f;
	    } else {
	      scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
	      translation = scaleRange[0];
	      return function(t) {
	        return f(scaleFactor * (t - translation));
	      };
	    }
	  };

	  getType = function(x) {
	    return Object.prototype.toString.call(x).slice('[object '.length, -1);
	  };

	  validateNumber = function(n) {
	    if (isNaN(n)) throw 'NaN in Smooth() input';
	    if (getType(n) !== 'Number') throw 'Non-number in Smooth() input';
	    if (!isFinite(n)) throw 'Infinity in Smooth() input';
	  };

	  validateVector = function(v, dimension) {
	    var n, _i, _len;
	    if (getType(v) !== 'Array') throw 'Non-vector in Smooth() input';
	    if (v.length !== dimension) throw 'Inconsistent dimension in Smooth() input';
	    for (_i = 0, _len = v.length; _i < _len; _i++) {
	      n = v[_i];
	      validateNumber(n);
	    }
	  };

	  isValidNumber = function(n) {
	    return (getType(n) === 'Number') && isFinite(n) && !isNaN(n);
	  };

	  normalizeScaleTo = function(s) {
	    var invalidErr;
	    invalidErr = "scaleTo param must be number or array of two numbers";
	    switch (getType(s)) {
	      case 'Number':
	        if (!isValidNumber(s)) throw invalidErr;
	        s = [0, s];
	        break;
	      case 'Array':
	        if (s.length !== 2) throw invalidErr;
	        if (!(isValidNumber(s[0]) && isValidNumber(s[1]))) throw invalidErr;
	        break;
	      default:
	        throw invalidErr;
	    }
	    return s;
	  };

	  shallowCopy = function(obj) {
	    var copy, k, v;
	    copy = {};
	    for (k in obj) {
	      if (!__hasProp.call(obj, k)) continue;
	      v = obj[k];
	      copy[k] = v;
	    }
	    return copy;
	  };

	  Smooth = function(arr, config) {
	    var baseDomainEnd, dimension, i, interpolator, interpolatorClass, interpolators, k, n, properties, smoothFunc, v;
	    if (config == null) config = {};
	    properties = {};
	    config = shallowCopy(config);
	    properties.config = shallowCopy(config);
	    if (config.scaleTo == null) config.scaleTo = config.period;
	    if (config.sincFilterSize == null) {
	      config.sincFilterSize = config.lanczosFilterSize;
	    }
	    for (k in defaultConfig) {
	      if (!__hasProp.call(defaultConfig, k)) continue;
	      v = defaultConfig[k];
	      if (config[k] == null) config[k] = v;
	    }
	    if (!(interpolatorClass = {
	      nearest: NearestInterpolator,
	      linear: LinearInterpolator,
	      cubic: CubicInterpolator,
	      lanczos: SincFilterInterpolator,
	      sinc: SincFilterInterpolator
	    }[config.method])) {
	      throw "Invalid method: " + config.method;
	    }
	    if (config.method === 'lanczos') {
	      config.sincWindow = makeLanczosWindow(config.sincFilterSize);
	    }
	    if (arr.length < 2) throw 'Array must have at least two elements';
	    properties.count = arr.length;
	    smoothFunc = (function() {
	      var _i, _j, _len, _len2;
	      switch (getType(arr[0])) {
	        case 'Number':
	          properties.dimension = 'scalar';
	          if (Smooth.deepValidation) {
	            for (_i = 0, _len = arr.length; _i < _len; _i++) {
	              n = arr[_i];
	              validateNumber(n);
	            }
	          }
	          interpolator = new interpolatorClass(arr, config);
	          return function(t) {
	            return interpolator.interpolate(t);
	          };
	        case 'Array':
	          properties.dimension = dimension = arr[0].length;
	          if (!dimension) throw 'Vectors must be non-empty';
	          if (Smooth.deepValidation) {
	            for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
	              v = arr[_j];
	              validateVector(v, dimension);
	            }
	          }
	          interpolators = (function() {
	            var _results;
	            _results = [];
	            for (i = 0; 0 <= dimension ? i < dimension : i > dimension; 0 <= dimension ? i++ : i--) {
	              _results.push(new interpolatorClass(getColumn(arr, i), config));
	            }
	            return _results;
	          })();
	          return function(t) {
	            var interpolator, _k, _len3, _results;
	            _results = [];
	            for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
	              interpolator = interpolators[_k];
	              _results.push(interpolator.interpolate(t));
	            }
	            return _results;
	          };
	        default:
	          throw "Invalid element type: " + (getType(arr[0]));
	      }
	    })();
	    if (config.clip === 'periodic') {
	      baseDomainEnd = arr.length;
	    } else {
	      baseDomainEnd = arr.length - 1;
	    }
	    config.scaleTo || (config.scaleTo = baseDomainEnd);
	    properties.domain = normalizeScaleTo(config.scaleTo);
	    smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
	    properties.domain.sort();
	    /*copy properties
	    */
	    for (k in properties) {
	      if (!__hasProp.call(properties, k)) continue;
	      v = properties[k];
	      smoothFunc[k] = v;
	    }
	    return smoothFunc;
	  };

	  for (k in Enum) {
	    if (!__hasProp.call(Enum, k)) continue;
	    v = Enum[k];
	    Smooth[k] = v;
	  }

	  Smooth.deepValidation = true;

	  (exports !== null ? exports : window).Smooth = Smooth;

	}).call(commonjsGlobal);
	});
	var Smooth_1 = Smooth.Smooth;

	var ResidueType$1 = chem.ResidueType;

	var calcMatrix = gfxutils.calcChunkMatrix;

	function _buildStructureInterpolator(points, tension) {
	  var path = Smooth_1(points, {
	    method: Smooth_1.METHOD_CUBIC,
	    clip: Smooth_1.CLIP_CLAMP,
	    cubicTension: tension,
	    scaleTo: 1
	  });

	  return function (t, argTrans) {
	    var transformT = argTrans;
	    if (transformT === null) {
	      // map our range to the [second .. last but one]
	      transformT = function transformT(tt) {
	        return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
	      };
	    }
	    var newt = transformT(t);
	    var ans = path(newt);
	    return new Vector3(ans[0], ans[1], ans[2]);
	  };
	}

	function _addPoints(centerPoints, topPoints, idx, residue) {
	  if (!residue._isValid) {
	    centerPoints[idx] = centerPoints[idx - 1];
	    topPoints[idx] = topPoints[idx - 1];
	    return;
	  }
	  var cp = residue._controlPoint;
	  centerPoints[idx] = [cp.x, cp.y, cp.z];
	  var tp = cp.clone().add(residue._wingVector);
	  topPoints[idx] = [tp.x, tp.y, tp.z];
	}

	function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
	  var nucleic = (residue._type.flags & ResidueType$1.Flags.NUCLEIC) !== 0;
	  var nameFrom = nucleic ? 'C5\'' : 'N';
	  var nameTo = nucleic ? 'C3\'' : 'C';

	  var posFrom = void 0,
	      posTo = void 0;
	  residue.forEachAtom(function (atom) {
	    var name = atom.getVisualName();
	    if (!posFrom && name === nameFrom) {
	      posFrom = atom._position;
	    } else if (!posTo && name === nameTo) {
	      posTo = atom._position;
	    }
	  });

	  // provide a fallback for unknown residues
	  if (!(posFrom && posTo)) {
	    posFrom = residue._firstAtom._position;
	    posTo = residue._lastAtom._position;
	  }

	  if (posFrom && posTo) {
	    var shift = posTo.clone().sub(posFrom);

	    var wing = residue._wingVector;
	    var cp = residue._controlPoint;
	    var tp = cp.clone().add(wing);

	    var cpPrev = cp.clone().sub(shift);
	    var tpPrev = cpPrev.clone().add(wing);
	    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
	    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
	    ++idx;
	    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
	    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
	    ++idx;

	    centerPoints[idx] = [cp.x, cp.y, cp.z];
	    topPoints[idx] = [tp.x, tp.y, tp.z];
	    ++idx;

	    var cpNext = cp.clone().add(shift);
	    var tpNext = cpNext.clone().add(wing);
	    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
	    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
	    ++idx;
	    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
	    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
	  }
	}

	function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
	  var left = boundaries.start;
	  var right = boundaries.end;
	  function _prevIdx(idx) {
	    return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx;
	  }
	  function _nextIdx(idx) {
	    return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx;
	  }

	  var topPoints = []; // new Array(lastIdx - firstIdx + 5);
	  var centerPoints = []; // new Array(lastIdx - firstIdx + 5);
	  var arrIdx = 0;
	  function _extrapolate2(currIdx, otherIdx) {
	    var cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);
	    var tp = cp.clone().add(residues[currIdx]._wingVector);
	    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
	    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
	    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
	    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
	  }

	  // a single disconnected residue
	  var prevIdx = _prevIdx(firstIdx);
	  var nextIdx = _nextIdx(lastIdx);
	  if (prevIdx === nextIdx) {
	    _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);
	    return { centerPoints: centerPoints, topPoints: topPoints };
	  }

	  // Two points (prev-prev and next-next) are added to support edge conditions for cubic splines, they are ignored
	  // Another two (prev and next) were added to support the outside of the sub chain

	  // prev and prev-prev
	  if (firstIdx === prevIdx) {
	    // do the extrapolation
	    _extrapolate2(firstIdx, _nextIdx(firstIdx));
	  } else {
	    _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);
	    _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
	  }

	  // main loop
	  for (var idx = firstIdx; idx <= lastIdx; ++idx) {
	    _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
	  }

	  // next and next-next
	  if (nextIdx === _nextIdx(nextIdx)) {
	    // do the extrapolation
	    _extrapolate2(lastIdx, _prevIdx(lastIdx));
	  } else {
	    _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);
	    _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
	  }
	  return { centerPoints: centerPoints, topPoints: topPoints };
	}

	var CartoonHelper = function () {
	  function CartoonHelper(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
	    classCallCheck(this, CartoonHelper);

	    var pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);
	    this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
	    this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);

	    this._shift = 0.5 / (endIdx - startIdx + 2);
	    this._valueStep = (1.0 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
	    this._segmentsCount = segmentsCount;
	  }

	  createClass(CartoonHelper, [{
	    key: 'prepareMatrices',
	    value: function prepareMatrices(idx, firstRad, secondRad) {
	      var mtcCount = this._segmentsCount;
	      var outMtc = new Array(mtcCount);
	      var currRad = new Vector2(0, 0);

	      var topInterp = this._topInterp;
	      var cenInterp = this._centerInterp;

	      var currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;

	      for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
	        var lerpVal = Math.min(1.0, mtxIdx / (mtcCount - 1));
	        currRad.lerpVectors(firstRad, secondRad, lerpVal);

	        var currTop = topInterp(currentValue, null);
	        var currCenter = cenInterp(currentValue, null);
	        currentValue += this._valueStep;
	        var nextCenter = cenInterp(currentValue, null);

	        outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
	      }

	      return outMtc;
	    }
	  }]);
	  return CartoonHelper;
	}();

	function _createShape$1(rad, parts) {
	  var pts = [];

	  for (var i = 0; i < parts; ++i) {

	    var a = 2 * i / parts * Math.PI;

	    pts.push(new Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
	  }
	  return pts;
	}

	function _loopThrough(subDiv, residues, segmentsHeight, tension, mode, callback) {
	  for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
	    var subs = subDiv[subDivI].arr;
	    var boundaries = subDiv[subDivI].boundaries;
	    for (var i = 0, n = subs.length; i < n; ++i) {
	      var idc = [subs[i].start, subs[i].end];
	      var matrixHelper = new CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
	      var prevLast = null;
	      var startIdx = subs[i].start * 2;
	      var endIdx = subs[i].end * 2 + 1;
	      for (var idx = startIdx; idx <= endIdx; ++idx) {
	        var resIdx = idx / 2 | 0;
	        var currRes = residues[resIdx];
	        var firstRad = mode.getResidueRadius(currRes, idx % 2);
	        var secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);

	        var mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
	        mtc.unshift(prevLast === null ? mtc[0] : prevLast);

	        callback(currRes, mtc, resIdx);
	        prevLast = mtc[segmentsHeight];
	      }
	    }
	  }
	}

	var ResiduesSubseqGroup = function (_ResiduesGroup) {
	  inherits(ResiduesSubseqGroup, _ResiduesGroup);

	  function ResiduesSubseqGroup() {
	    classCallCheck(this, ResiduesSubseqGroup);
	    return possibleConstructorReturn(this, (ResiduesSubseqGroup.__proto__ || Object.getPrototypeOf(ResiduesSubseqGroup)).apply(this, arguments));
	  }

	  createClass(ResiduesSubseqGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      var cmpMultiplier = this._mode.getHeightSegmentsRatio();
	      this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
	      return [_createShape$1(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
	    }
	  }, {
	    key: '_build',
	    value: function _build() {
	      var residues = this._selection.residues;
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var tension = mode.getTension();
	      var geo = this._geo;
	      var chunkIdx = 0;
	      var chunkIdc = [];
	      _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode, function (currRes, mtc) {
	        var color = colorer.getResidueColor(currRes, parent);
	        chunkIdc[chunkIdx] = currRes._index;
	        geo.setItem(chunkIdx, mtc);
	        geo.setColor(chunkIdx++, color);
	      });
	      this._chunksIdc = chunkIdc;
	      geo.finalize();
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      // TODO This method looks like a copy paste. However, it
	      // was decided to postpone animation refactoring until GFX is fixed.
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var tension = mode.getTension();
	      var geo = this._geo;
	      var frameRes = frameData.getResidues();
	      var chunkIdx = 0;
	      var updateColor = frameData.needsColorUpdate(colorer);
	      _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode, function (currRes, mtc) {
	        geo.setItem(chunkIdx, mtc);
	        if (updateColor) {
	          geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
	        }
	        chunkIdx++;
	      });
	      geo.finalize();
	    }
	  }]);
	  return ResiduesSubseqGroup;
	}(ResiduesGroup);

	var ResiduesTraceGroup = function (_ChemGroup) {
	  inherits(ResiduesTraceGroup, _ChemGroup);

	  function ResiduesTraceGroup() {
	    classCallCheck(this, ResiduesTraceGroup);
	    return possibleConstructorReturn(this, (ResiduesTraceGroup.__proto__ || Object.getPrototypeOf(ResiduesTraceGroup)).apply(this, arguments));
	  }

	  createClass(ResiduesTraceGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      var subDiv = this._selection.subdivs;
	      var chunksCount = 0;
	      for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
	        var subs = subDiv[subDivI].arr;
	        for (var i = 0, n = subs.length; i < n; ++i) {
	          chunksCount += subs[i].end - subs[i].start;
	        }
	      }
	      return [chunksCount, this._polyComplexity];
	    }
	  }, {
	    key: '_build',
	    value: function _build() {
	      var residues = this._selection.residues;
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var chunkIdx = 0;
	      var chunkIdc = [];
	      var subDiv = this._selection.subdivs;
	      var stickRad = mode.calcStickRadius();

	      for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
	        var subs = subDiv[subDivI].arr;
	        for (var i = 0, n = subs.length; i < n; ++i) {
	          var startIdx = subs[i].start;
	          var endIdx = subs[i].end;
	          var prevRes = residues[startIdx];
	          for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
	            var currRes = residues[idx];
	            chunkIdc[chunkIdx] = { first: prevRes._index, second: currRes._index };
	            geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
	            geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
	            chunkIdx++;
	            prevRes = currRes;
	          }
	        }
	      }

	      this._chunksIdc = chunkIdc;
	      geo.finalize();
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      // TODO This method looks like a copy paste. However, it
	      // was decided to postpone animation refactoring until GFX is fixed.

	      var residues = frameData.getResidues();
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var chunkIdx = 0;
	      var subDiv = this._selection.subdivs;
	      var stickRad = mode.calcStickRadius();
	      var updateColor = frameData.needsColorUpdate(colorer);

	      for (var subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
	        var subs = subDiv[subDivI].arr;
	        for (var i = 0, n = subs.length; i < n; ++i) {
	          var startIdx = subs[i].start;
	          var endIdx = subs[i].end;
	          var prevRes = residues[startIdx];
	          for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
	            var currRes = residues[idx];
	            geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
	            if (updateColor) {
	              geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
	            }
	            chunkIdx++;
	            prevRes = currRes;
	          }
	        }
	      }

	      geo.finalize();
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var inters = [];
	      var residues = this._selection.residues;
	      this._mesh.raycast(raycaster, inters);
	      var chunksToIdx = this._chunksIdc;
	      // process inters array - arr object references
	      for (var i = 0, n = inters.length; i < n; ++i) {
	        if (!inters[i].hasOwnProperty('chunkIdx')) {
	          continue;
	        }
	        var chunkIdx = inters[i].chunkIdx;
	        var chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
	        var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;
	        if (resIdx < residues.length) {
	          inters[i].residue = residues[resIdx];
	          intersects.push(inters[i]);
	        }
	      }
	    }
	  }, {
	    key: '_calcChunksList',
	    value: function _calcChunksList(mask) {
	      var chunksList = [];
	      var chunksToIdx = this._chunksIdc;
	      var residues = this._selection.residues;
	      for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
	        var chunk = chunksToIdx[i];
	        if (residues[chunk.first]._mask & mask) {
	          chunksList.push(i * 2);
	        }
	        if (residues[chunk.second]._mask & mask) {
	          chunksList.push(i * 2 + 1);
	        }
	      }
	      return chunksList;
	    }
	  }]);
	  return ResiduesTraceGroup;
	}(ChemGroup);

	function getCylinderCount$1(bondOrder) {
	  return bondOrder < 2 ? 1 : bondOrder;
	}

	var BondsGroup = function (_ChemGroup) {
	  inherits(BondsGroup, _ChemGroup);

	  function BondsGroup() {
	    classCallCheck(this, BondsGroup);
	    return possibleConstructorReturn(this, (BondsGroup.__proto__ || Object.getPrototypeOf(BondsGroup)).apply(this, arguments));
	  }

	  createClass(BondsGroup, [{
	    key: '_makeGeoArgs',
	    value: function _makeGeoArgs() {
	      var drawMultiple = this._mode.drawMultiorderBonds();
	      var showAromatic = this._mode.showAromaticLoops();
	      var bondsIdc = this._selection.chunks;
	      var bonds = this._selection.bonds;
	      var bondsCount = 1;
	      for (var i = 0, n = bondsIdc.length; i < n; ++i) {
	        bondsCount += this.getBondOrder(bonds[bondsIdc[i]], drawMultiple, showAromatic);
	      }
	      return [bondsCount, this._polyComplexity];
	    }
	  }, {
	    key: 'getBondOrder',
	    value: function getBondOrder(bond, drawMultiple, showAromatic) {
	      var bondOrder = 1;
	      if (drawMultiple && (!showAromatic || bond._type !== Bond.BondType.AROMATIC)) {
	        bondOrder = getCylinderCount$1(bond._order);
	      }
	      return bondOrder;
	    }
	  }, {
	    key: 'raycast',
	    value: function raycast(raycaster, intersects) {
	      var bonds = this._selection.bonds;
	      var inters = [];
	      this._mesh.raycast(raycaster, inters);
	      var bondsIdc = this._chunksIdc;
	      // process inters array - arr object references
	      for (var i = 0, n = inters.length; i < n; ++i) {
	        if (!inters[i].hasOwnProperty('chunkIdx')) {
	          continue;
	        }
	        var chunkIdx = inters[i].chunkIdx;
	        var bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];
	        if (bondIdx < bonds.length) {
	          var bond = bonds[bondIdx];
	          inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
	          intersects.push(inters[i]);
	        }
	      }
	    }
	  }, {
	    key: '_calcChunksList',
	    value: function _calcChunksList(mask, innerOnly) {
	      var chunksList = [];
	      var bonds = this._selection.bonds;
	      var chunksToIdx = this._chunksIdc;
	      for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
	        var bond = bonds[chunksToIdx[i]];
	        if (bond._left._mask & mask && (!innerOnly || bond._right._mask & mask)) {
	          chunksList.push(2 * i);
	        }
	        if (bond._right._mask & mask && (!innerOnly || bond._left._mask & mask)) {
	          chunksList.push(2 * i + 1);
	        }
	      }
	      return chunksList;
	    }
	  }]);
	  return BondsGroup;
	}(ChemGroup);

	var BondsCylinderGroup = function (_BondsGroup) {
	  inherits(BondsCylinderGroup, _BondsGroup);

	  function BondsCylinderGroup() {
	    classCallCheck(this, BondsCylinderGroup);
	    return possibleConstructorReturn(this, (BondsCylinderGroup.__proto__ || Object.getPrototypeOf(BondsCylinderGroup)).apply(this, arguments));
	  }

	  createClass(BondsCylinderGroup, [{
	    key: '_build',
	    value: function _build() {
	      var bondsIdc = this._selection.chunks;
	      var bonds = this._selection.bonds;
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var drawMultiple = mode.drawMultiorderBonds();
	      var showAromatic = mode.showAromaticLoops();

	      var stickRad = mode.calcStickRadius();
	      var emptyOffset = mode.calcSpaceFraction();
	      var normDir = void 0;
	      var leftPos = new Vector3();
	      var rightPos = new Vector3();
	      var currBondIdx = 0;
	      var chunksToIdx = [];
	      for (var i = 0, n = bondsIdc.length; i < n; ++i) {
	        var bond = bonds[bondsIdc[i]];
	        var atom1 = bond._left;
	        var atom2 = bond._right;
	        var a1Pos = atom1._position;
	        var a2Pos = atom2._position;
	        normDir = bond.calcNormalDir();
	        var order = this.getBondOrder(bond, drawMultiple, showAromatic);
	        var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
	        var dist = 2 * minRad / order;
	        var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

	        for (var j = 0; j < order; ++j) {
	          var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
	          chunksToIdx[currBondIdx] = bond._index;
	          leftPos.copy(a1Pos);
	          leftPos.addScaledVector(normDir, scale);
	          rightPos.copy(a2Pos);
	          rightPos.addScaledVector(normDir, scale);
	          geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
	          geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
	        }
	      }

	      geo.finalize();
	      this._chunksIdc = chunksToIdx;
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      var bondsIdc = this._selection.chunks;
	      var bonds = this._selection.bonds;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var drawMultiple = mode.drawMultiorderBonds();
	      var showAromatic = mode.showAromaticLoops();

	      var stickRad = mode.calcStickRadius();
	      var emptyOffset = mode.calcSpaceFraction();
	      var normDir = void 0;
	      var leftPos = new Vector3();
	      var rightPos = new Vector3();
	      var currBondIdx = 0;
	      var updateColor = frameData.needsColorUpdate(colorer);
	      for (var i = 0, n = bondsIdc.length; i < n; ++i) {
	        var bond = bonds[bondsIdc[i]];
	        var atom1 = bond._left;
	        var atom2 = bond._right;
	        var a1Pos = frameData.getAtomPos(atom1._index).clone();
	        var a2Pos = frameData.getAtomPos(atom2._index);
	        normDir = bond.calcNormalDir();
	        var order = this.getBondOrder(bond, drawMultiple, showAromatic);
	        var minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
	        var dist = 2 * minRad / order;
	        var currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;

	        for (var j = 0; j < order; ++j) {
	          var scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
	          leftPos.copy(a1Pos);
	          leftPos.addScaledVector(normDir, scale);
	          rightPos.copy(a2Pos);
	          rightPos.addScaledVector(normDir, scale);
	          geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
	          if (updateColor) {
	            geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
	          }
	          currBondIdx++;
	        }
	      }
	      geo.finalize();
	    }
	  }]);
	  return BondsCylinderGroup;
	}(BondsGroup);

	var STEP_SIZE = 0.15;

	var BondsLinesGroup = function (_BondsGroup) {
	  inherits(BondsLinesGroup, _BondsGroup);

	  function BondsLinesGroup() {
	    classCallCheck(this, BondsLinesGroup);
	    return possibleConstructorReturn(this, (BondsLinesGroup.__proto__ || Object.getPrototypeOf(BondsLinesGroup)).apply(this, arguments));
	  }

	  createClass(BondsLinesGroup, [{
	    key: '_build',
	    value: function _build() {
	      var bondsIdc = this._selection.chunks;
	      var bonds = this._selection.bonds;
	      var parent = this._selection.parent;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var drawMultiple = mode.drawMultiorderBonds();
	      var showAromatic = mode.showAromaticLoops();

	      var bondDir = new Vector3();

	      var leftPos = new Vector3();
	      var rightPos = new Vector3();
	      var currBondIdx = 0;
	      var chunksToIdx = [];
	      for (var i = 0, n = bondsIdc.length; i < n; ++i) {
	        var bond = bonds[bondsIdc[i]];
	        var atom1 = bond._left;
	        var atom2 = bond._right;
	        var a1Pos = atom1._position;
	        var a2Pos = atom2._position;
	        var a1Hangs = atom1._bonds.length === 1;
	        var a2Hangs = atom2._bonds.length === 1;
	        bondDir.subVectors(a2Pos, a1Pos);
	        var len = bondDir.length();
	        var normDir = bond.calcNormalDir();

	        var order = this.getBondOrder(bond, drawMultiple, showAromatic);

	        for (var j = 0; j < order; ++j) {
	          leftPos.copy(a1Pos);
	          rightPos.copy(a2Pos);
	          var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
	          chunksToIdx[currBondIdx] = bond._index;
	          if (order === 2 && !a1Hangs && !a2Hangs) {
	            scale -= 0.5;
	            scale *= -1;
	          }

	          if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
	            leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
	            rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
	          }

	          scale *= STEP_SIZE;

	          leftPos.addScaledVector(normDir, scale);
	          rightPos.addScaledVector(normDir, scale);
	          geo.setItem(currBondIdx, leftPos, rightPos);
	          geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
	        }
	      }
	      geo.finalize();
	      this._chunksIdc = chunksToIdx;
	    }
	  }, {
	    key: 'updateToFrame',
	    value: function updateToFrame(frameData) {
	      // TODO This method looks like a copy paste. However, it
	      // was decided to postpone animation refactoring until GFX is fixed.
	      var bondsIdc = this._selection.chunks;
	      var bonds = this._selection.bonds;
	      var mode = this._mode;
	      var colorer = this._colorer;
	      var geo = this._geo;
	      var drawMultiple = mode.drawMultiorderBonds();
	      var showAromatic = mode.showAromaticLoops();

	      var bondDir = new Vector3();

	      var leftPos = new Vector3();
	      var rightPos = new Vector3();
	      var currBondIdx = 0;
	      var updateColor = frameData.needsColorUpdate(colorer);
	      for (var i = 0, n = bondsIdc.length; i < n; ++i) {
	        var bond = bonds[bondsIdc[i]];
	        var atom1 = bond._left;
	        var atom2 = bond._right;
	        var a1Pos = frameData.getAtomPos(atom1._index).clone();
	        var a2Pos = frameData.getAtomPos(atom2._index);
	        var a1Hangs = atom1._bonds.length === 1;
	        var a2Hangs = atom2._bonds.length === 1;
	        bondDir.subVectors(a2Pos, a1Pos);
	        var len = bondDir.length();
	        var normDir = bond.calcNormalDir();

	        var order = this.getBondOrder(bond, drawMultiple, showAromatic);

	        for (var j = 0; j < order; ++j) {
	          leftPos.copy(a1Pos);
	          rightPos.copy(a2Pos);
	          var scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
	          if (order === 2 && !a1Hangs && !a2Hangs) {
	            scale -= 0.5;
	            scale *= -1;
	          }

	          if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
	            leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
	            rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
	          }

	          scale *= STEP_SIZE;

	          leftPos.addScaledVector(normDir, scale);
	          rightPos.addScaledVector(normDir, scale);
	          geo.setItem(currBondIdx, leftPos, rightPos);
	          if (updateColor) {
	            geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
	          }
	          currBondIdx++;
	        }
	      }
	      geo.finalize();
	    }
	  }]);
	  return BondsLinesGroup;
	}(BondsGroup);

	var groups = {
	  AtomsSphereGroup: AtomsSphereGroup,
	  AtomsSurfaceGroup: AtomsSurfaceGroup,
	  AtomsSASSESGroupStub: AtomsSASSESGroupStub,
	  AtomsTextGroup: AtomsTextGroup,
	  AromaticTorusGroup: AromaticTorusGroup,
	  AromaticLinesGroup: AromaticLinesGroup,
	  NucleicCylindersGroup: NucleicCylindersGroup,
	  NucleicSpheresGroup: NucleicSpheresGroup,
	  ResiduesSubseqGroup: ResiduesSubseqGroup,
	  ResiduesTraceGroup: ResiduesTraceGroup,
	  BondsCylinderGroup: BondsCylinderGroup,
	  BondsLinesGroup: BondsLinesGroup
	};

	var AtomsProcessor = function (_RCGroup) {
	  inherits(AtomsProcessor, _RCGroup);

	  function AtomsProcessor(AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
	    classCallCheck(this, AtomsProcessor);

	    var _this = possibleConstructorReturn(this, (AtomsProcessor.__proto__ || Object.getPrototypeOf(AtomsProcessor)).call(this));

	    var self = _this;
	    _this._complex = complex;
	    _this._mode = mode;
	    var atoms = complex.getAtoms();
	    var transforms = complex.getTransforms();

	    complex.forEachComponent(function (component) {
	      var atomsIdc = [];
	      var atomCount = 0;
	      component.forEachAtom(function (atom) {
	        if (!self._checkAtom(atom, mask)) {
	          return;
	        }
	        atomsIdc[atomCount++] = atom._index;
	      });
	      if (atomCount === 0) {
	        return;
	      }
	      var atomsGroup = new AtomsGroup(geoParams, {
	        atoms: atoms,
	        chunks: atomsIdc,
	        parent: complex
	      }, colorer, mode, transforms, polyComplexity, material);
	      atomsGroup._component = component;
	      self.add(atomsGroup);
	    });
	    return _this;
	  }

	  createClass(AtomsProcessor, [{
	    key: '_checkAtom',
	    value: function _checkAtom(atom, mask) {
	      return atom._mask & mask;
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(mask, innerOnly) {
	      var totalSubset = [];
	      var children = this.children;
	      var meshIdx = 0;
	      for (var i = 0, n = children.length; i < n; ++i) {
	        if (children[i].getSubset) {
	          var chSubset = children[i].getSubset(mask, innerOnly);
	          for (var j = 0, m = chSubset.length; j < m; ++j) {
	            var subsetEl = chSubset[j];
	            subsetEl._component = children[i]._component;
	            totalSubset[meshIdx++] = subsetEl;
	          }
	        }
	      }
	      return totalSubset;
	    }
	  }]);
	  return AtomsProcessor;
	}(RCGroup);

	var OrphanAtomsProcessor = function (_AtomsProcessor) {
	  inherits(OrphanAtomsProcessor, _AtomsProcessor);

	  function OrphanAtomsProcessor(AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
	    classCallCheck(this, OrphanAtomsProcessor);
	    return possibleConstructorReturn(this, (OrphanAtomsProcessor.__proto__ || Object.getPrototypeOf(OrphanAtomsProcessor)).call(this, AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material));
	  }

	  createClass(OrphanAtomsProcessor, [{
	    key: '_checkAtom',
	    value: function _checkAtom(atom, mask) {
	      if (!(atom._mask & mask)) {
	        return false;
	      }

	      /** @deprecated Old-fashioned atom labels, to be removed in the next major version. */
	      if (this._mode.settings.now.labels !== 'no' && atom.isLabelVisible()) {
	        return false;
	      }
	      var bonds = atom._bonds;
	      for (var i = 0, n = bonds.length; i < n; ++i) {
	        if (bonds[i]._left._mask & mask && bonds[i]._right._mask & mask) {
	          return false;
	        }
	      }
	      return true;
	    }
	  }]);
	  return OrphanAtomsProcessor;
	}(AtomsProcessor);

	var ResiduesProcessor = function (_RCGroup) {
	  inherits(ResiduesProcessor, _RCGroup);

	  function ResiduesProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
	    classCallCheck(this, ResiduesProcessor);

	    var _this = possibleConstructorReturn(this, (ResiduesProcessor.__proto__ || Object.getPrototypeOf(ResiduesProcessor)).call(this));

	    var self = _this;
	    _this._complex = complex;
	    var residues = complex.getResidues();
	    var transforms = complex.getTransforms();

	    complex.forEachComponent(function (component) {
	      var chunksCount = 0;
	      var resIdc = [];
	      component.forEachResidue(function (residue) {
	        if (self._checkResidue(residue, mask)) {
	          resIdc[chunksCount++] = residue._index;
	        }
	      });

	      if (chunksCount === 0) {
	        return;
	      }
	      var residuesGroup = new ResidueGroup(geoParams, {
	        residues: residues,
	        chunks: resIdc,
	        parent: complex
	      }, colorer, mode, transforms, polyComplexity, material);
	      residuesGroup._component = component;
	      self.add(residuesGroup);
	    });
	    return _this;
	  }

	  createClass(ResiduesProcessor, [{
	    key: 'checkResidue',
	    value: function checkResidue(residue, mask) {
	      return residue._mask & mask;
	    }
	  }, {
	    key: 'getSubset',
	    value: function getSubset(mask, innerOnly) {
	      var totalSubset = [];
	      var children = this.children;
	      var meshIdx = 0;
	      for (var i = 0, n = children.length; i < n; ++i) {
	        if (children[i].getSubset) {
	          var chSubset = children[i].getSubset(mask, innerOnly);
	          for (var j = 0, m = chSubset.length; j < m; ++j) {
	            var subsetEl = chSubset[j];
	            subsetEl._component = children[i]._component;
	            totalSubset[meshIdx++] = subsetEl;
	          }
	        }
	      }
	      return totalSubset;
	    }
	  }]);
	  return ResiduesProcessor;
	}(RCGroup);

	var NucleicProcessor = function (_ResidueProcessor) {
	  inherits(NucleicProcessor, _ResidueProcessor);

	  function NucleicProcessor() {
	    classCallCheck(this, NucleicProcessor);
	    return possibleConstructorReturn(this, (NucleicProcessor.__proto__ || Object.getPrototypeOf(NucleicProcessor)).apply(this, arguments));
	  }

	  createClass(NucleicProcessor, [{
	    key: '_checkResidue',
	    value: function _checkResidue(residue, mask) {
	      return mask & residue._mask && residue._cylinders !== null;
	    }
	  }]);
	  return NucleicProcessor;
	}(ResiduesProcessor);

	var SubseqsProcessor = function (_RCGroup) {
	  inherits(SubseqsProcessor, _RCGroup);

	  function SubseqsProcessor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
	    classCallCheck(this, SubseqsProcessor);

	    var _this = possibleConstructorReturn(this, (SubseqsProcessor.__proto__ || Object.getPrototypeOf(SubseqsProcessor)).call(this));

	    var self = _this;
	    _this._complex = complex;
	    var residues = complex.getResidues();
	    var transforms = complex.getTransforms();

	    complex.forEachComponent(function (component) {
	      var subDivs = component.getMaskedSubdivSequences(mask);

	      var chunksCount = 0;
	      var resIdc = [];
	      for (var subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
	        var subs = subDivs[subDivI].arr;
	        for (var i = 0, n = subs.length; i < n; ++i) {
	          for (var j = subs[i].start, jEnd = subs[i].end; j <= jEnd; ++j) {
	            resIdc[chunksCount++] = residues[j]._index;
	          }
	        }
	      }

	      if (chunksCount === 0) {
	        return;
	      }
	      var residuesGroup = new ResidueGroup(geoParams, {
	        residues: residues,
	        chunks: resIdc,
	        subdivs: subDivs,
	        parent: complex
	      }, colorer, mode, transforms, polyComplexity, material);
	      residuesGroup._component = component;
	      self.add(residuesGroup);
	    });
	    return _this;
	  }

	  createClass(SubseqsProcessor, [{
	    key: 'getSubset',
	    value: function getSubset(mask, innerOnly) {
	      var totalSubset = [];
	      var children = this.children;
	      var meshIdx = 0;
	      for (var i = 0, n = children.length; i < n; ++i) {
	        if (children[i].getSubset) {
	          var chSubset = children[i].getSubset(mask, innerOnly);
	          for (var j = 0, m = chSubset.length; j < m; ++j) {
	            var subsetEl = chSubset[j];
	            subsetEl._component = children[i]._component;
	            totalSubset[meshIdx++] = subsetEl;
	          }
	        }
	      }
	      return totalSubset;
	    }
	  }]);
	  return SubseqsProcessor;
	}(RCGroup);

	var BondsProcessor = function (_RCGroup) {
	  inherits(BondsProcessor, _RCGroup);

	  function BondsProcessor(BondsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
	    classCallCheck(this, BondsProcessor);

	    var _this = possibleConstructorReturn(this, (BondsProcessor.__proto__ || Object.getPrototypeOf(BondsProcessor)).call(this));

	    var self = _this;
	    _this._complex = complex;
	    var bonds = complex.getBonds();
	    var transforms = complex.getTransforms();

	    complex.forEachComponent(function (component) {
	      var bondsIdc = [];
	      var bondsCount = 0;
	      component.forEachBond(function (bond) {
	        var atom1 = bond._left;
	        var atom2 = bond._right;
	        if (!(atom1._mask & mask) || !(atom2._mask & mask)) {
	          return;
	        }
	        bondsIdc[bondsCount++] = bond._index;
	      });
	      if (bondsCount === 0) {
	        return;
	      }
	      var bondsGroup = new BondsGroup(geoParams, {
	        bonds: bonds,
	        chunks: bondsIdc,
	        parent: complex
	      }, colorer, mode, transforms, polyComplexity, material);
	      bondsGroup._component = component;
	      self.add(bondsGroup);
	    });
	    return _this;
	  }

	  createClass(BondsProcessor, [{
	    key: 'getSubset',
	    value: function getSubset(mask, innerOnly) {
	      var totalSubset = [];
	      var children = this.children;
	      var meshIdx = 0;
	      for (var i = 0, n = children.length; i < n; ++i) {
	        if (children[i].getSubset) {
	          var chSubset = children[i].getSubset(mask, innerOnly);
	          for (var j = 0, m = chSubset.length; j < m; ++j) {
	            var subsetEl = chSubset[j];
	            subsetEl._component = children[i]._component;
	            totalSubset[meshIdx++] = subsetEl;
	          }
	        }
	      }
	      return totalSubset;
	    }
	  }]);
	  return BondsProcessor;
	}(RCGroup);

	var AromaticProcessor = function (_RCGroup) {
	  inherits(AromaticProcessor, _RCGroup);

	  function AromaticProcessor(AromaticGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
	    classCallCheck(this, AromaticProcessor);

	    var _this = possibleConstructorReturn(this, (AromaticProcessor.__proto__ || Object.getPrototypeOf(AromaticProcessor)).call(this));

	    var self = _this;
	    _this._complex = complex;
	    var atoms = complex.getAtoms();
	    var transforms = complex.getTransforms();
	    if (!mode.showAromaticLoops()) {
	      return possibleConstructorReturn(_this);
	    }

	    complex.forEachComponent(function (component) {
	      var atomsIdc = [];
	      var chunksCount = 0;
	      var cycles = [];
	      var cycleIdx = 0;
	      component.forEachCycle(function (cycle) {
	        var cycAtoms = cycle.atoms;
	        var perCycle = 0;
	        for (var i = 0, n = cycAtoms.length; i < n; ++i) {
	          if ((cycAtoms[i]._mask & mask) !== 0) {
	            ++perCycle;
	            atomsIdc[chunksCount++] = cycAtoms[i]._index;
	          }
	        }
	        if (perCycle > 0) {
	          cycles[cycleIdx++] = cycle;
	        }
	      });

	      var atomsGroup = new AromaticGroup(geoParams, {
	        cycles: cycles,
	        atoms: atoms,
	        chunks: atomsIdc,
	        parent: complex
	      }, colorer, mode, transforms, polyComplexity, material);
	      atomsGroup._component = component;
	      self.add(atomsGroup);
	    });
	    return _this;
	  }

	  createClass(AromaticProcessor, [{
	    key: 'getSubset',
	    value: function getSubset(mask, innerOnly) {
	      var totalSubset = [];
	      var children = this.children;
	      var meshIdx = 0;
	      for (var i = 0, n = children.length; i < n; ++i) {
	        if (children[i].getSubset) {
	          var chSubset = children[i].getSubset(mask, innerOnly);
	          for (var j = 0, m = chSubset.length; j < m; ++j) {
	            var subsetEl = chSubset[j];
	            subsetEl._component = children[i]._component;
	            totalSubset[meshIdx++] = subsetEl;
	          }
	        }
	      }
	      return totalSubset;
	    }
	  }]);
	  return AromaticProcessor;
	}(RCGroup);

	/*
	 * TODO
	 * This file is a greeting from the past. Refactor it and/or destroy.
	 */

	/** @deprecated Old-fashioned atom labels, to be removed in the next major version. */
	function _buildLabel2D(pos, color, fieldTxt) {
	  var text = document.createElement('div');
	  text.className = 'label label-sgroup';
	  text.style.color = color;
	  if (typeof fieldTxt === 'string') {
	    var spanText = document.createElement('span');
	    spanText.style.fontSize = '150%';
	    var spanNodeP = document.createElement('span');
	    var spanNodeText = document.createTextNode(fieldTxt);
	    spanNodeP.appendChild(spanNodeText);
	    spanText.appendChild(spanNodeP);
	    text.appendChild(spanText);
	  } else {
	    text.appendChild(fieldTxt);
	    //text.style.paddingTop = '10px';
	  }

	  var label = new CSS2DObject(text);
	  label.position.copy(pos);
	  label.userData = {
	    translation: 'translate(-50%, -50%)',
	    color: color
	  };
	  var el = label.getElement();
	  el.style.visibility = 'visible';
	  el.style.textAlign = 'center';
	  el.style.verticalAlign = 'middle';
	  return label;
	}

	/** @deprecated Old-fashioned atom labels, to be removed in the next major version. */

	var SGroupProcessor = function (_RCGroup) {
	  inherits(SGroupProcessor, _RCGroup);

	  function SGroupProcessor(AtomsGroup, geoParams, complex, _colorer, _mode, _polyComplexity, _mask, _material) {
	    classCallCheck(this, SGroupProcessor);

	    var _this = possibleConstructorReturn(this, (SGroupProcessor.__proto__ || Object.getPrototypeOf(SGroupProcessor)).call(this));

	    var markColor = 0xFFFF00;
	    var groupLetters = new RCGroup();

	    for (var i = 0; i < complex.getSGroupCount(); i++) {
	      var sGroup = complex.getSGroups()[i];
	      if (sGroup._center !== null) {
	        var actPos = new Vector3().copy(sGroup._position);
	        actPos.add(sGroup._center);
	        groupLetters.add(_buildLabel2D(actPos, markColor, sGroup._name));
	      } else {
	        groupLetters.add(_buildLabel2D(new Vector3().copy(sGroup._position), markColor, sGroup._name));
	      }
	    }

	    _this.add(groupLetters);
	    return _this;
	  }

	  return SGroupProcessor;
	}(RCGroup);

	var processors = {
	  Atoms: AtomsProcessor,
	  OrphanAtoms: OrphanAtomsProcessor,
	  Residues: ResiduesProcessor,
	  Nucleic: NucleicProcessor,
	  Subseqs: SubseqsProcessor,
	  Bonds: BondsProcessor,
	  Aromatic: AromaticProcessor,
	  SGroups: SGroupProcessor
	};

	function _bakeGroup(triplet, Processor, Group) {
	  return function (complex, colorer, mode, polyComplexity, mask, material) {
	    return new Processor(Group, triplet, complex, colorer, mode, polyComplexity, mask, material);
	  };
	}

	var GroupsFactory = function () {
	  function GroupsFactory() {
	    classCallCheck(this, GroupsFactory);
	  }

	  createClass(GroupsFactory, null, [{
	    key: 'AtomsSpheres',
	    value: function AtomsSpheres(caps, settings) {
	      var gfxTriplet = MeshCreator.createSpheres(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
	    }
	  }, {
	    key: 'OrphanedAtomsCrosses',
	    value: function OrphanedAtomsCrosses(caps, settings, renderParams) {
	      var gfxTriplet = MeshCreator.createCrosses(caps, settings, renderParams);

	      return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
	    }
	  }, {
	    key: 'BondsCylinders',
	    value: function BondsCylinders(caps, settings) {
	      var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
	    }
	  }, {
	    key: 'BondsLines',
	    value: function BondsLines(caps, settings, renderParams) {
	      var gfxTriplet = MeshCreator.create2CLines(caps, settings, renderParams);

	      return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
	    }
	  }, {
	    key: 'CartoonChains',
	    value: function CartoonChains(caps, settings) {
	      var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
	    }
	  }, {
	    key: 'TraceChains',
	    value: function TraceChains(caps, settings) {
	      var gfxTriplet = MeshCreator.create2CClosedCylinders(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
	    }
	  }, {
	    key: 'NucleicSpheres',
	    value: function NucleicSpheres(caps, settings) {
	      var gfxTriplet = MeshCreator.createSpheres(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
	    }
	  }, {
	    key: 'NucleicCylinders',
	    value: function NucleicCylinders(caps, settings) {
	      var gfxTriplet = MeshCreator.create2CCylinders(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
	    }
	  }, {
	    key: 'ALoopsTorus',
	    value: function ALoopsTorus(caps, settings) {
	      var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
	    }
	  }, {
	    key: 'ALoopsLines',
	    value: function ALoopsLines(caps, settings, renderParams) {
	      var gfxTriplet = MeshCreator.createChunkedLines(caps, settings, renderParams);

	      return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
	    }
	  }, {
	    key: 'QuickSurfGeo',
	    value: function QuickSurfGeo(caps, settings, renderParams) {
	      var gfxTriplet = MeshCreator.createQuickSurface(caps, settings, renderParams);

	      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
	    }
	  }, {
	    key: 'ContactSurfaceGeo',
	    value: function ContactSurfaceGeo(caps, settings, renderParams) {
	      var gfxTriplet = MeshCreator.createContactSurface(caps, settings, renderParams);

	      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
	    }
	  }, {
	    key: 'SASSESSurfaceGeo',
	    value: function SASSESSurfaceGeo(caps, settings, renderParams) {
	      var gfxTriplet = MeshCreator.createSASSES(caps, settings, renderParams);

	      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
	    }
	  }, {
	    key: 'TextLabelsGeo',
	    value: function TextLabelsGeo(caps, settings) {
	      var gfxTriplet = MeshCreator.createLabels(caps, settings);

	      return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
	    }

	    /** @deprecated Old-fashioned atom labels, to be removed in the next major version. */

	  }, {
	    key: 'SGroupsLabels',
	    value: function SGroupsLabels(_caps, _settings) {
	      return _bakeGroup(null, processors.SGroups, null);
	    }
	  }]);
	  return GroupsFactory;
	}();

	/**
	 * Create new mode.
	 *
	 * @param {object=} opts - Options to override defaults with.
	 *
	 *   These options are copied locally and not kept by reference, so the created instance will not reflect further
	 *   changes to the `opts` object. However, changes in defaults **will** affect the mode after its creation.
	 *
	 * @exports Mode
	 * @this Mode
	 * @abstract
	 * @constructor
	 * @classdesc Basic class for all available modes used for building and displaying molecule geometry.
	 */

	var Mode = function () {
	  function Mode(opts) {
	    classCallCheck(this, Mode);

	    if (this.constructor === Mode) {
	      throw new Error('Can not instantiate abstract class!');
	    }
	    /**
	     * Mode options inherited (prototyped) from defaults.
	     * @type {object}
	     */
	    this.opts = lodash.merge(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
	  }

	  /**
	   * Get mode identification, probably with options.
	   * @returns {string|Array} Mode identifier string ({@link Mode#id}) or two-element array containing both mode
	   *   identifier and options ({@link Mode#opts}).
	   * Options are returned if they were changed during or after the mode creation.
	   */


	  createClass(Mode, [{
	    key: 'identify',
	    value: function identify() {
	      var diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);
	      if (!lodash.isEmpty(diff)) {
	        return [this.id, diff];
	      }
	      return this.id;
	    }
	  }, {
	    key: 'buildGeometry',
	    value: function buildGeometry(complex, colorer, mask, material) {
	      var polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
	      var groupList = this.depGroups;
	      var groupCount = groupList.length;
	      var group = new gfxutils.RCGroup();
	      var self = this;
	      for (var i = 0; i < groupCount; ++i) {
	        var currGroup = groupList[i];
	        var renderParams = {};
	        if (lodash.isArray(currGroup)) {
	          renderParams = currGroup[1].call(this);
	          currGroup = currGroup[0];
	        }
	        var Group = GroupsFactory[currGroup](null, this.settings, renderParams);
	        var newGroup = new Group(complex, colorer, self, polyComplexity, mask, material);
	        if (newGroup.children.length > 0) {
	          group.add(newGroup);
	        }
	      }
	      return group;
	    }
	  }]);
	  return Mode;
	}();

	makeContextDependent(Mode.prototype);

	/**
	* Mode identifier.
	* @type {string}
	*/
	Mode.prototype.id = '__';

	/**
	 * Mode geo groups.
	 * @type {Array}
	 */
	Mode.prototype.depGroups = [];

	/* eslint-disable no-magic-numbers */

	/** @deprecated Old-fashioned atom labels, to be removed in the next major version. */

	var LabeledMode = function (_Mode) {
	  inherits(LabeledMode, _Mode);

	  function LabeledMode(opts) {
	    classCallCheck(this, LabeledMode);

	    var _this = possibleConstructorReturn(this, (LabeledMode.__proto__ || Object.getPrototypeOf(LabeledMode)).call(this, opts));

	    _this.depGroups = _this.depGroups.slice(0); // clone depGroups to prevent prototype edits
	    _this._staticGroups = _this.depGroups.length;
	    return _this;
	  }

	  createClass(LabeledMode, [{
	    key: 'update',
	    value: function update() {
	      var statGroups = this._staticGroups;
	      if (this.settings.now.labels === 'no') {
	        this.depGroups = this.depGroups.slice(0, statGroups);
	      } else {
	        this.depGroups[statGroups] = 'TextLabelsGeo';
	        this.depGroups[statGroups + 1] = 'SGroupsLabels';
	      }
	    }
	  }, {
	    key: 'buildGeometry',
	    value: function buildGeometry(complex, colorer, mask, material) {
	      this.update();
	      return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
	    }
	  }]);
	  return LabeledMode;
	}(Mode);

	function getRenderParams() {
	  return {
	    lineWidth: this.opts.lineWidth
	  };
	}

	var LinesMode = function (_LabeledMode) {
	  inherits(LinesMode, _LabeledMode);

	  function LinesMode(opts) {
	    classCallCheck(this, LinesMode);

	    var _this = possibleConstructorReturn(this, (LinesMode.__proto__ || Object.getPrototypeOf(LinesMode)).call(this, opts));

	    var groups = _this.depGroups;
	    for (var i = 0, n = groups.length; i < n; ++i) {
	      groups[i] = [groups[i], getRenderParams];
	    }
	    return _this;
	  }

	  createClass(LinesMode, [{
	    key: 'drawMultiorderBonds',
	    value: function drawMultiorderBonds() {
	      return this.opts.multibond;
	    }
	  }, {
	    key: 'calcAtomRadius',
	    value: function calcAtomRadius() {
	      return this.opts.atom;
	    }
	  }, {
	    key: 'getAromaticOffset',
	    value: function getAromaticOffset() {
	      return this.opts.offsarom;
	    }
	  }, {
	    key: 'getAromaticArcChunks',
	    value: function getAromaticArcChunks() {
	      return this.opts.chunkarom;
	    }
	  }, {
	    key: 'showAromaticLoops',
	    value: function showAromaticLoops() {
	      return this.opts.showarom;
	    }

	    /** @deprecated Old-fashioned atom labels, to be removed in the next major version. */

	  }, {
	    key: 'getLabelOpts',
	    value: function getLabelOpts() {
	      return {
	        fg: 'none',
	        bg: '0x202020',
	        showBg: true,
	        labels: this.settings.now.labels,
	        colors: true,
	        adjustColor: true,
	        transparent: true
	      };
	    }
	  }]);
	  return LinesMode;
	}(LabeledMode);

	LinesMode.id = 'LN';


	LinesMode.prototype.id = 'LN';
	LinesMode.prototype.name = 'Lines';
	LinesMode.prototype.shortName = 'Lines';
	LinesMode.prototype.depGroups = ['ALoopsLines', 'BondsLines', 'OrphanedAtomsCrosses'];

	/* eslint-disable no-magic-numbers */

	var LicoriceMode = function (_LabeledMode) {
	  inherits(LicoriceMode, _LabeledMode);

	  function LicoriceMode(opts) {
	    classCallCheck(this, LicoriceMode);
	    return possibleConstructorReturn(this, (LicoriceMode.__proto__ || Object.getPrototypeOf(LicoriceMode)).call(this, opts));
	  }

	  createClass(LicoriceMode, [{
	    key: 'calcAtomRadius',
	    value: function calcAtomRadius(_atom) {
	      return this.opts.bond;
	    }
	  }, {
	    key: 'calcStickRadius',
	    value: function calcStickRadius() {
	      return this.opts.bond;
	    }
	  }, {
	    key: 'calcSpaceFraction',
	    value: function calcSpaceFraction() {
	      return this.opts.space;
	    }
	  }, {
	    key: 'getAromRadius',
	    value: function getAromRadius() {
	      return this.opts.aromrad;
	    }
	  }, {
	    key: 'showAromaticLoops',
	    value: function showAromaticLoops() {
	      return this.opts.showarom;
	    }
	  }, {
	    key: 'drawMultiorderBonds',
	    value: function drawMultiorderBonds() {
	      return this.opts.multibond;
	    }

	    /** @deprecated Old-fashioned atom labels, to be removed in the next major version. */

	  }, {
	    key: 'getLabelOpts',
	    value: function getLabelOpts() {
	      return {
	        fg: 'none',
	        bg: '0x202020',
	        showBg: false,
	        labels: this.settings.now.labels,
	        colors: true,
	        adjustColor: true,
	        transparent: true
	      };
	    }
	  }]);
	  return LicoriceMode;
	}(LabeledMode);

	LicoriceMode.id = 'LC';


	LicoriceMode.prototype.id = 'LC';
	LicoriceMode.prototype.name = 'Licorice';
	LicoriceMode.prototype.shortName = 'Licorice';
	LicoriceMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

	/* eslint-disable no-magic-numbers */

	var BallsAndSticksMode = function (_LabeledMode) {
	  inherits(BallsAndSticksMode, _LabeledMode);

	  function BallsAndSticksMode(opts) {
	    classCallCheck(this, BallsAndSticksMode);
	    return possibleConstructorReturn(this, (BallsAndSticksMode.__proto__ || Object.getPrototypeOf(BallsAndSticksMode)).call(this, opts));
	  }

	  createClass(BallsAndSticksMode, [{
	    key: 'calcAtomRadius',
	    value: function calcAtomRadius(atom) {
	      return atom.element.radius * this.opts.atom;
	    }
	  }, {
	    key: 'calcStickRadius',
	    value: function calcStickRadius() {
	      return this.opts.bond;
	    }
	  }, {
	    key: 'getAromRadius',
	    value: function getAromRadius() {
	      return this.opts.aromrad;
	    }
	  }, {
	    key: 'showAromaticLoops',
	    value: function showAromaticLoops() {
	      return this.opts.showarom;
	    }
	  }, {
	    key: 'calcSpaceFraction',
	    value: function calcSpaceFraction() {
	      return this.opts.space;
	    }
	  }, {
	    key: 'drawMultiorderBonds',
	    value: function drawMultiorderBonds() {
	      return this.opts.multibond;
	    }

	    /** @deprecated Old-fashioned atom labels, to be removed in the next major version. */

	  }, {
	    key: 'getLabelOpts',
	    value: function getLabelOpts() {
	      return {
	        fg: 'none',
	        bg: '0x202020',
	        showBg: false,
	        labels: this.settings.now.labels,
	        colors: true,
	        adjustColor: true,
	        transparent: true
	      };
	    }
	  }]);
	  return BallsAndSticksMode;
	}(LabeledMode);

	BallsAndSticksMode.id = 'BS';


	BallsAndSticksMode.prototype.id = 'BS';
	BallsAndSticksMode.prototype.name = 'Balls and Sticks';
	BallsAndSticksMode.prototype.shortName = 'Balls';
	BallsAndSticksMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];

	var VanDerWaalsMode = function (_Mode) {
	  inherits(VanDerWaalsMode, _Mode);

	  function VanDerWaalsMode(opts) {
	    classCallCheck(this, VanDerWaalsMode);
	    return possibleConstructorReturn(this, (VanDerWaalsMode.__proto__ || Object.getPrototypeOf(VanDerWaalsMode)).call(this, opts));
	  }

	  createClass(VanDerWaalsMode, [{
	    key: 'calcAtomRadius',
	    value: function calcAtomRadius(atom) {
	      return atom.element.radius;
	    }
	  }]);
	  return VanDerWaalsMode;
	}(Mode);

	VanDerWaalsMode.id = 'VW';


	VanDerWaalsMode.prototype.id = 'VW';
	VanDerWaalsMode.prototype.name = 'Van der Waals';
	VanDerWaalsMode.prototype.shortName = 'VDW';
	VanDerWaalsMode.prototype.depGroups = ['AtomsSpheres'];

	var TraceMode = function (_Mode) {
	  inherits(TraceMode, _Mode);

	  function TraceMode(opts) {
	    classCallCheck(this, TraceMode);
	    return possibleConstructorReturn(this, (TraceMode.__proto__ || Object.getPrototypeOf(TraceMode)).call(this, opts));
	  }

	  createClass(TraceMode, [{
	    key: 'calcStickRadius',
	    value: function calcStickRadius() {
	      return this.opts.radius;
	    }
	  }]);
	  return TraceMode;
	}(Mode);

	TraceMode.id = 'TR';


	TraceMode.prototype.id = 'TR';
	TraceMode.prototype.name = 'Trace';
	TraceMode.prototype.shortName = 'Trace';
	TraceMode.prototype.depGroups = ['TraceChains'];

	var TubeMode = function (_Mode) {
	  inherits(TubeMode, _Mode);

	  function TubeMode(opts) {
	    classCallCheck(this, TubeMode);
	    return possibleConstructorReturn(this, (TubeMode.__proto__ || Object.getPrototypeOf(TubeMode)).call(this, opts));
	  }

	  createClass(TubeMode, [{
	    key: 'getResidueRadius',
	    value: function getResidueRadius(_residue) {
	      return this.TUBE_RADIUS;
	    }
	  }, {
	    key: 'getHeightSegmentsRatio',
	    value: function getHeightSegmentsRatio() {
	      return this.opts.heightSegmentsRatio;
	    }
	  }, {
	    key: 'getTension',
	    value: function getTension() {
	      return this.opts.tension;
	    }
	  }, {
	    key: 'buildGeometry',
	    value: function buildGeometry(complex, colorer, mask, material) {
	      var rad = this.opts.radius;
	      this.TUBE_RADIUS = new Vector2(rad, rad);

	      return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
	    }
	  }]);
	  return TubeMode;
	}(Mode);

	TubeMode.id = 'TU';


	TubeMode.prototype.id = 'TU';
	TubeMode.prototype.name = 'Tube';
	TubeMode.prototype.shortName = 'Tube';
	TubeMode.prototype.depGroups = ['CartoonChains'];

	var CartoonMode = function (_Mode) {
	  inherits(CartoonMode, _Mode);

	  function CartoonMode(opts) {
	    classCallCheck(this, CartoonMode);

	    // cache for secondary structure options
	    var _this = possibleConstructorReturn(this, (CartoonMode.__proto__ || Object.getPrototypeOf(CartoonMode)).call(this, opts));

	    _this.secCache = {};
	    return _this;
	  }

	  createClass(CartoonMode, [{
	    key: 'getResidueStartRadius',
	    value: function getResidueStartRadius(residue) {
	      var second = residue.getSecondary();
	      if (!second || !second.generic) {
	        return this.TUBE_RADIUS;
	      }
	      var secOpts = this.secCache[second.generic];
	      if (!secOpts) {
	        return this.TUBE_RADIUS;
	      }
	      if (second.term === residue) {
	        return secOpts.start;
	      }
	      return secOpts.center;
	    }
	  }, {
	    key: 'getResidueEndRadius',
	    value: function getResidueEndRadius(residue) {
	      var second = residue.getSecondary();
	      if (second === null || !second.generic) {
	        return this.TUBE_RADIUS;
	      }
	      var secOpts = this.secCache[second.generic];
	      if (!secOpts) {
	        return this.TUBE_RADIUS;
	      }
	      if (second.term === residue) {
	        return this.ARROW_END;
	      }
	      return secOpts.center;
	    }
	  }, {
	    key: 'getResidueRadius',
	    value: function getResidueRadius(residue, val) {
	      var startRad = this.getResidueStartRadius(residue);
	      if (val === 0) {
	        return startRad;
	      }

	      var endRad = this.getResidueEndRadius(residue);
	      if (val === 2) {
	        return endRad;
	      }

	      return startRad.clone().lerp(endRad, val / 2.0);
	    }

	    // TODO: remove when selection is rendered with actual geometry

	  }, {
	    key: 'calcStickRadius',
	    value: function calcStickRadius(_res) {
	      return this.opts.radius;
	    }
	  }, {
	    key: 'getHeightSegmentsRatio',
	    value: function getHeightSegmentsRatio() {
	      return this.opts.heightSegmentsRatio;
	    }
	  }, {
	    key: 'getTension',
	    value: function getTension() {
	      return this.opts.tension;
	    }
	  }, {
	    key: 'buildGeometry',
	    value: function buildGeometry(complex, colorer, mask, material) {
	      var tubeRad = this.opts.radius;
	      var secHeight = this.opts.depth;

	      this.TUBE_RADIUS = new Vector2(tubeRad, tubeRad);
	      this.ARROW_END = new Vector2(secHeight, tubeRad);
	      var secCache = {};
	      var secData = this.opts.ss;
	      /* eslint-disable guard-for-in */
	      for (var prop in secData) {
	        secCache[prop] = {
	          center: new Vector2(secHeight, secData[prop].width),
	          start: new Vector2(secHeight, secData[prop].arrow)
	        };
	      }
	      this.secCache = secCache;
	      /* eslint-enable guard-for-in */

	      return Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
	    }
	  }]);
	  return CartoonMode;
	}(Mode);

	CartoonMode.id = 'CA';


	CartoonMode.prototype.id = 'CA';
	CartoonMode.prototype.name = 'Cartoon';
	CartoonMode.prototype.shortName = 'Cartoon';
	CartoonMode.prototype.depGroups = ['CartoonChains', 'NucleicSpheres', 'NucleicCylinders'];

	var selectors$1 = chem.selectors;

	function getRenderParams$1() {
	  return {
	    wireframe: this.opts.wireframe,
	    zClip: this.opts.zClip
	  };
	}

	var SurfaceMode = function (_Mode) {
	  inherits(SurfaceMode, _Mode);

	  function SurfaceMode(opts) {
	    classCallCheck(this, SurfaceMode);

	    var _this = possibleConstructorReturn(this, (SurfaceMode.__proto__ || Object.getPrototypeOf(SurfaceMode)).call(this, opts));

	    _this.depGroups = _this.depGroups.slice(0); // clone depGroups to prevent prototype edits
	    var surfaces = _this.surfaceNames;
	    var groups = _this.depGroups;
	    for (var i = 0, n = surfaces.length; i < n; ++i) {
	      groups[groups.length] = [surfaces[i], getRenderParams$1];
	    }
	    return _this;
	  }

	  createClass(SurfaceMode, [{
	    key: 'calcAtomRadius',
	    value: function calcAtomRadius(atom) {
	      return atom.element.radius;
	    }
	  }, {
	    key: 'getVisibilitySelector',
	    value: function getVisibilitySelector() {
	      var visibilitySelector = null;
	      if (this.opts.subset !== '') {
	        var res = selectors$1.parse(this.opts.subset);
	        if (!res.error) {
	          visibilitySelector = res.selector;
	        }
	      }
	      return visibilitySelector;
	    }
	  }]);
	  return SurfaceMode;
	}(Mode);

	SurfaceMode.prototype.isSurface = true;
	SurfaceMode.prototype.surfaceNames = [];

	var QuickSurfaceMode = function (_SurfaceMode) {
	  inherits(QuickSurfaceMode, _SurfaceMode);

	  function QuickSurfaceMode(opts) {
	    classCallCheck(this, QuickSurfaceMode);
	    return possibleConstructorReturn(this, (QuickSurfaceMode.__proto__ || Object.getPrototypeOf(QuickSurfaceMode)).call(this, opts));
	  }

	  createClass(QuickSurfaceMode, [{
	    key: 'getSurfaceOpts',
	    value: function getSurfaceOpts() {
	      return {
	        useBeads: false,
	        isoValue: this.opts.isoValue,
	        gaussLim: this.opts.gaussLim[this.settings.now.resolution],
	        radScale: this.opts.scale,
	        gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
	        zClip: this.opts.zClip,
	        visibilitySelector: this.getVisibilitySelector()
	      };
	    }
	  }]);
	  return QuickSurfaceMode;
	}(SurfaceMode);

	QuickSurfaceMode.id = 'QS';


	QuickSurfaceMode.prototype.id = 'QS';
	QuickSurfaceMode.prototype.name = 'Quick Surface';
	QuickSurfaceMode.prototype.shortName = 'Quick Surf';
	QuickSurfaceMode.prototype.surfaceNames = ['QuickSurfGeo'];

	var IsoSurfaceMode = function (_SurfaceMode) {
	  inherits(IsoSurfaceMode, _SurfaceMode);

	  function IsoSurfaceMode(excludeProbe, opts) {
	    classCallCheck(this, IsoSurfaceMode);

	    var _this = possibleConstructorReturn(this, (IsoSurfaceMode.__proto__ || Object.getPrototypeOf(IsoSurfaceMode)).call(this, opts));

	    _this._excludeProbe = excludeProbe;

	    //this._isVertexNormalsRendered = false; FIXME are used?
	    //this._isSurfaceTransparent = false; FIXME are used?
	    return _this;
	  }

	  createClass(IsoSurfaceMode, [{
	    key: 'calcAtomRadius',
	    value: function calcAtomRadius(atom) {
	      return atom.element.radius;
	    }
	  }, {
	    key: 'getSurfaceOpts',
	    value: function getSurfaceOpts() {
	      return {
	        gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
	        radScale: this._radScale,
	        zClip: this.opts.zClip,
	        visibilitySelector: this.getVisibilitySelector(),
	        probeRadius: this.opts.probeRadius,
	        excludeProbe: this._excludeProbe,
	        clusterizationType: this._clusterViaKMeans
	      };
	    }
	  }]);
	  return IsoSurfaceMode;
	}(SurfaceMode);

	IsoSurfaceMode.prototype.id = 'SU';
	IsoSurfaceMode.prototype.name = 'Surface';
	IsoSurfaceMode.prototype.shortName = 'Surface';
	IsoSurfaceMode.prototype.surfaceNames = ['SASSESSurfaceGeo'];

	IsoSurfaceMode.prototype._radScale = 1;
	// TODO: move to advanced visualization UI next 3 params
	IsoSurfaceMode.prototype._clusterViaKMeans = 0; // 0: no cluster, 1: KMeans, 2: SimplestClusterization
	IsoSurfaceMode.prototype._excludeProbe = false;

	var IsoSurfaceSASMode = function (_IsoSurfaceMode) {
	  inherits(IsoSurfaceSASMode, _IsoSurfaceMode);

	  function IsoSurfaceSASMode(opts) {
	    classCallCheck(this, IsoSurfaceSASMode);
	    return possibleConstructorReturn(this, (IsoSurfaceSASMode.__proto__ || Object.getPrototypeOf(IsoSurfaceSASMode)).call(this, false, opts));
	  }

	  return IsoSurfaceSASMode;
	}(IsoSurfaceMode);

	IsoSurfaceSASMode.id = 'SA';


	IsoSurfaceSASMode.prototype.id = 'SA';
	IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface';
	IsoSurfaceSASMode.prototype.shortName = 'SAS';

	var IsoSurfaceSESMode = function (_IsoSurfaceMode) {
	  inherits(IsoSurfaceSESMode, _IsoSurfaceMode);

	  function IsoSurfaceSESMode(opts) {
	    classCallCheck(this, IsoSurfaceSESMode);
	    return possibleConstructorReturn(this, (IsoSurfaceSESMode.__proto__ || Object.getPrototypeOf(IsoSurfaceSESMode)).call(this, true, opts));
	  }

	  return IsoSurfaceSESMode;
	}(IsoSurfaceMode);

	IsoSurfaceSESMode.id = 'SE';


	IsoSurfaceSESMode.prototype.id = 'SE';
	IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface';
	IsoSurfaceSESMode.prototype.shortName = 'SES';

	var ContactSurfaceMode = function (_SurfaceMode) {
	  inherits(ContactSurfaceMode, _SurfaceMode);

	  function ContactSurfaceMode(opts) {
	    classCallCheck(this, ContactSurfaceMode);
	    return possibleConstructorReturn(this, (ContactSurfaceMode.__proto__ || Object.getPrototypeOf(ContactSurfaceMode)).call(this, opts));
	  }

	  createClass(ContactSurfaceMode, [{
	    key: 'getSurfaceOpts',
	    value: function getSurfaceOpts() {
	      return {
	        probeRadius: this.opts.probeRadius,
	        radScale: this.opts.polyComplexity[this.settings.now.resolution],
	        scaleFactor: this.opts.polyComplexity[this.settings.now.resolution], // TODO rename all params
	        gridSpacing: 1.0 / this.opts.polyComplexity[this.settings.now.resolution], // TODO rename all params
	        isoValue: this.opts.isoValue,
	        probePositions: this.opts.probePositions,
	        zClip: this.opts.zClip,
	        visibilitySelector: this.getVisibilitySelector()
	      };
	    }
	  }]);
	  return ContactSurfaceMode;
	}(SurfaceMode);

	ContactSurfaceMode.id = 'CS';


	ContactSurfaceMode.prototype.id = 'CS';
	ContactSurfaceMode.prototype.name = 'Contact Surface';
	ContactSurfaceMode.prototype.shortName = 'Contact Surf';
	ContactSurfaceMode.prototype.isSurface = true;
	ContactSurfaceMode.prototype.surfaceNames = ['ContactSurfaceGeo'];

	var TextMode = function (_Mode) {
	  inherits(TextMode, _Mode);

	  function TextMode(opts) {
	    classCallCheck(this, TextMode);
	    return possibleConstructorReturn(this, (TextMode.__proto__ || Object.getPrototypeOf(TextMode)).call(this, opts));
	  }

	  createClass(TextMode, [{
	    key: 'getTemplateOptions',
	    value: function getTemplateOptions() {
	      return this.opts.template;
	    }
	  }, {
	    key: 'getLabelOpts',
	    value: function getLabelOpts() {
	      return lodash.merge(this.opts, {
	        labels: this.settings.now.labels,
	        colors: true,
	        adjustColor: true,
	        transparent: true
	      });
	    }
	  }]);
	  return TextMode;
	}(Mode);

	TextMode.id = 'TX';


	TextMode.prototype.id = 'TX';
	TextMode.prototype.name = 'Text mode';
	TextMode.prototype.shortName = 'Text';
	TextMode.prototype.depGroups = ['TextLabelsGeo'];

	var modes = new EntityList([LinesMode, LicoriceMode, BallsAndSticksMode, VanDerWaalsMode, TraceMode, TubeMode, CartoonMode, QuickSurfaceMode, IsoSurfaceSASMode, IsoSurfaceSESMode, ContactSurfaceMode, TextMode]);

	/** @deprecated */
	Object.defineProperty(modes, 'list', {
	  get: function get() {
	    return this.all;
	  }
	});

	/** @deprecated */
	Object.defineProperty(modes, 'any', {
	  get: function get() {
	    return this.first;
	  }
	});

	/** @deprecated */
	Object.defineProperty(modes, 'descriptions', {
	  get: function get() {
	    return lodash.map(this._list, function (m) {
	      return lodash.pick(m.prototype, ['id', 'name']);
	    });
	  }
	});

	/** @deprecated */
	modes.create = function (mode, opts) {
	  if (!opts && mode instanceof Array) {
	    opts = mode[1];
	    mode = mode[0];
	  }
	  var Mode = this.get(mode) || this.first;
	  return new Mode(opts);
	};

	function clamp(x, a, b) {
	  return x <= b ? x < 0 ? 0 : x : b;
	}

	function lerpColor(c1, c2, alpha) {
	  var beta = 1 - alpha;
	  var r1 = c1 >> 16 & 0xff,
	      g1 = c1 >> 8 & 0xff,
	      b1 = c1 & 0xff;
	  var r2 = c2 >> 16 & 0xff,
	      g2 = c2 >> 8 & 0xff,
	      b2 = c2 & 0xff;
	  var r = beta * r1 + alpha * r2,
	      g = beta * g1 + alpha * g2,
	      b = beta * b1 + alpha * b2;
	  return r << 16 | g << 8 | b;
	}

	function Palette(name, id) {
	  this.name = name || 'Custom';
	  this.id = id || 'CP';
	}

	Palette.prototype = {

	  constructor: Palette,

	  /* eslint-disable no-magic-numbers */

	  colors: [0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0x808080],

	  minRangeColor: 0x000000,
	  midRangeColor: 0x7F7F7F,
	  maxRangeColor: 0xFFFFFF,

	  defaultElementColor: 0xFFFFFF,
	  elementColors: {},

	  defaultResidueColor: 0xFFFFFF,
	  residueColors: {},

	  chainColors: [0xFFFFFF],

	  defaultSecondaryColor: 0xFFFFFF,
	  secondaryColors: {},

	  defaultGradientColor: 0x000000,

	  defaultNamedColor: 0xFFFFFF,
	  namedColorsArray: [['indianred', 0xcd5c5c], ['lightcoral', 0xf08080], ['salmon', 0xfa8072], ['darksalmon', 0xe9967a], ['lightsalmon', 0xffa07a], ['crimson', 0xdc143c], ['red', 0xff0000], ['firebrick', 0xb22222], ['darkred', 0x8b0000], ['pink', 0xffc0cb], ['lightpink', 0xffb6c1], ['hotpink', 0xff69b4], ['deeppink', 0xff1493], ['mediumvioletred', 0xc71585], ['palevioletred', 0xdb7093], ['coral', 0xff7f50], ['tomato', 0xff6347], ['orangered', 0xff4500], ['darkorange', 0xff8c00], ['orange', 0xffa500], ['gold', 0xffd700], ['yellow', 0xffff00], ['lightyellow', 0xffffe0], ['lemonchiffon', 0xfffacd], ['lightgoldenrodyellow', 0xfafad2], ['papayawhip', 0xffefd5], ['moccasin', 0xffe4b5], ['peachpuff', 0xffdab9], ['palegoldenrod', 0xeee8aa], ['khaki', 0xf0e68c], ['darkkhaki', 0xbdb76b], ['lavender', 0xe6e6fa], ['thistle', 0xd8bfd8], ['plum', 0xdda0dd], ['violet', 0xee82ee], ['orchid', 0xda70d6], ['fuchsia', 0xff00ff], ['magenta', 0xff00ff], ['mediumorchid', 0xba55d3], ['mediumpurple', 0x9370db], ['rebeccapurple', 0x663399], ['blueviolet', 0x8a2be2], ['darkviolet', 0x9400d3], ['darkorchid', 0x9932cc], ['darkmagenta', 0x8b008b], ['purple', 0x800080], ['indigo', 0x4b0082], ['slateblue', 0x6a5acd], ['mediumslateblue', 0x7b68ee], ['darkslateblue', 0x483d8b], ['greenyellow', 0xadff2f], ['chartreuse', 0x7fff00], ['lawngreen', 0x7cfc00], ['lime', 0x00ff00], ['limegreen', 0x32cd32], ['palegreen', 0x98fb98], ['lightgreen', 0x90ee90], ['mediumspringgreen', 0x00fa9a], ['springgreen', 0x00ff7f], ['mediumseagreen', 0x3cb371], ['seagreen', 0x2e8b57], ['forestgreen', 0x228b22], ['green', 0x008000], ['darkgreen', 0x006400], ['yellowgreen', 0x9acd32], ['olivedrab', 0x6b8e23], ['olive', 0x808000], ['darkolivegreen', 0x556b2f], ['mediumaquamarine', 0x66cdaa], ['darkseagreen', 0x8fbc8f], ['lightseagreen', 0x20b2aa], ['darkcyan', 0x008b8b], ['teal', 0x008080], ['aqua', 0x00ffff], ['cyan', 0x00ffff], ['lightcyan', 0xe0ffff], ['paleturquoise', 0xafeeee], ['aquamarine', 0x7fffd4], ['turquoise', 0x40e0d0], ['mediumturquoise', 0x48d1cc], ['darkturquoise', 0x00ced1], ['cadetblue', 0x5f9ea0], ['steelblue', 0x4682b4], ['lightsteelblue', 0xb0c4de], ['powderblue', 0xb0e0e6], ['lightblue', 0xadd8e6], ['skyblue', 0x87ceeb], ['lightskyblue', 0x87cefa], ['deepskyblue', 0x00bfff], ['dodgerblue', 0x1e90ff], ['cornflowerblue', 0x6495ed], ['royalblue', 0x4169e1], ['blue', 0x0000ff], ['mediumblue', 0x0000cd], ['darkblue', 0x00008b], ['navy', 0x000080], ['midnightblue', 0x191970], ['cornsilk', 0xfff8dc], ['blanchedalmond', 0xffebcd], ['bisque', 0xffe4c4], ['navajowhite', 0xffdead], ['wheat', 0xf5deb3], ['burlywood', 0xdeb887], ['tan', 0xd2b48c], ['rosybrown', 0xbc8f8f], ['sandybrown', 0xf4a460], ['goldenrod', 0xdaa520], ['darkgoldenrod', 0xb8860b], ['peru', 0xcd853f], ['chocolate', 0xd2691e], ['saddlebrown', 0x8b4513], ['sienna', 0xa0522d], ['brown', 0xa52a2a], ['maroon', 0x800000], ['white', 0xffffff], ['snow', 0xfffafa], ['honeydew', 0xf0fff0], ['mintcream', 0xf5fffa], ['azure', 0xf0ffff], ['aliceblue', 0xf0f8ff], ['ghostwhite', 0xf8f8ff], ['whitesmoke', 0xf5f5f5], ['seashell', 0xfff5ee], ['beige', 0xf5f5dc], ['oldlace', 0xfdf5e6], ['floralwhite', 0xfffaf0], ['ivory', 0xfffff0], ['antiquewhite', 0xfaebd7], ['linen', 0xfaf0e6], ['lavenderblush', 0xfff0f5], ['mistyrose', 0xffe4e1], ['gainsboro', 0xdcdcdc], ['lightgray', 0xd3d3d3], ['silver', 0xc0c0c0], ['darkgray', 0xa9a9a9], ['gray', 0x808080], ['dimgray', 0x696969], ['lightslategray', 0x778899], ['slategray', 0x708090], ['darkslategray', 0x2f4f4f], ['black', 0x000000]],

	  namedColors: {},
	  /* eslint-enable no-magic-numbers */

	  gradients: {
	    'rainbow': [0x0000ff, // blue
	    0x00ffff, // cyan
	    0x00ff00, // green
	    0xffff00, // yellow
	    0xff0000],
	    'temp': [0x0000ff, // blue
	    0x007fff, // light-blue
	    0xffffff, // white
	    0xff7f00, // orange
	    0xff0000],
	    'hot': [0xffffff, // white
	    0xff7f00, // orange
	    0xff0000],
	    'cold': [0xffffff, // white
	    0x007fff, // light-blue
	    0x0000ff],
	    'blue-red': [0x0000ff, // blue
	    0xffffff, // white
	    0xff0000],
	    'reds': [0xffffff, // white
	    0xff0000],
	    'blues': [0xffffff, // white
	    0x0000ff]
	  },

	  getElementColor: function getElementColor(name) {
	    var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    var color = this.elementColors[name];
	    return color === undefined && !asIs ? this.defaultElementColor : color;
	  },

	  getResidueColor: function getResidueColor(name) {
	    var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    var color = this.residueColors[name];
	    return color === undefined && !asIs ? this.defaultResidueColor : color;
	  },

	  getChainColor: function getChainColor(name) {
	    var chain = name.charCodeAt(0);
	    chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 0x1F) % this.chainColors.length;
	    return this.chainColors[chain];
	  },

	  getSecondaryColor: function getSecondaryColor(type) {
	    var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    var color = this.secondaryColors[type];
	    return color === undefined && !asIs ? this.defaultSecondaryColor : color;
	  },

	  getSequentialColor: function getSequentialColor(index) {
	    var colors = this.colors;
	    var len = colors.length;
	    return index < 0 ? colors[index % len + len] : colors[index % len];
	  },

	  getGradientColor: function getGradientColor(value, gradientName) {
	    var gradient = this.gradients[gradientName];
	    if (!gradient) {
	      return this.defaultNamedColor;
	    } else {
	      var count = gradient.length;
	      var index = value * (count - 1);
	      var left = Math.floor(index);
	      var right = clamp(left + 1, 0, count - 1);
	      left = clamp(left, 0, count - 1);
	      return lerpColor(gradient[left], gradient[right], index - left);
	    }
	  },

	  getNamedColor: function getNamedColor(name) {
	    var asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    var color = this.namedColors[name];
	    return color === undefined && !asIs ? this.defaultNamedColor : color;
	  }
	};

	var namedColorsArray = Palette.prototype.namedColorsArray;
	var namedColors = Palette.prototype.namedColors;

	for (var i = 0, length = namedColorsArray.length; i < length; ++i) {
	  var namedColor = namedColorsArray[i];
	  namedColors[namedColor[0]] = namedColor[1];
	}

	var palette = new Palette('CPK', 'CP');

	// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
	palette.elementColors = {
	  /* eslint-disable no-magic-numbers */
	  H: 0xFFFFFF,
	  C: 0x202020,
	  N: 0x2060FF,
	  O: 0xEE2010,
	  F: 0x00FF00,
	  P: 0x8020FF,
	  S: 0xFFFF00,
	  CL: 0x00BB00,
	  FE: 0xD0D0D0,
	  CO: 0xD0D0D0,
	  NI: 0xD0D0D0,
	  CU: 0xD0D0D0,
	  BR: 0x008800,
	  I: 0x005500
	  /* eslint-enable no-magic-numbers */
	};

	var _palette$secondaryCol;

	var palette$1 = new Palette('Jmol', 'JM');

	palette$1.colors = [
	/* eslint-disable no-magic-numbers */
	0x0000FF, // blue
	0x0055FF, //
	0x00ABFF, //
	0x00FFFF, // cyan
	0x00FFAB, //
	0x00FF55, //
	0x00FF00, // green
	0x55FF00, //
	0xABFF00, //
	0xFFFF00, // yellow
	0xFFAB00, //
	0xFF5500, //
	0xFF0000, // red
	0xFF0055, //
	0xFF00AB, //
	0xFF00FF, // magenta
	0xAB00FF, //
	0x5500FF];

	// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
	palette$1.elementColors = {
	  /* eslint-disable no-magic-numbers */
	  H: 0xFFFFFF,
	  D: 0xFFFFC0,
	  T: 0xFFFFA0,
	  HE: 0xD9FFFF,
	  LI: 0xCC80FF,
	  BE: 0xC2FF00,
	  B: 0xFFB5B5,
	  C: 0x909090,
	  N: 0x3050F8,
	  O: 0xFF0D0D,
	  F: 0x90E050,
	  NE: 0xB3E3F5,
	  NA: 0xAB5CF2,
	  MG: 0x8AFF00,
	  AL: 0xBFA6A6,
	  SI: 0xF0C8A0,
	  P: 0xFF8000,
	  S: 0xFFFF30,
	  CL: 0x1FF01F,
	  AR: 0x80D1E3,
	  K: 0x8F40D4,
	  CA: 0x3DFF00,
	  SC: 0xE6E6E6,
	  TI: 0xBFC2C7,
	  V: 0xA6A6AB,
	  CR: 0x8A99C7,
	  MN: 0x9C7AC7,
	  FE: 0xE06633,
	  CO: 0xF090A0,
	  NI: 0x50D050,
	  CU: 0xC88033,
	  ZN: 0x7D80B0,
	  GA: 0xC28F8F,
	  GE: 0x668F8F,
	  AS: 0xBD80E3,
	  SE: 0xFFA100,
	  BR: 0xA62929,
	  KR: 0x5CB8D1,
	  RB: 0x702EB0,
	  SR: 0x00FF00,
	  Y: 0x94FFFF,
	  ZR: 0x94E0E0,
	  NB: 0x73C2C9,
	  MO: 0x54B5B5,
	  TC: 0x3B9E9E,
	  RU: 0x248F8F,
	  RH: 0x0A7D8C,
	  PD: 0x006985,
	  AG: 0xC0C0C0,
	  CD: 0xFFD98F,
	  IN: 0xA67573,
	  SN: 0x668080,
	  SB: 0x9E63B5,
	  TE: 0xD47A00,
	  I: 0x940094,
	  XE: 0x429EB0,
	  CS: 0x57178F,
	  BA: 0x00C900,
	  LA: 0x70D4FF,
	  CE: 0xFFFFC7,
	  PR: 0xD9FFC7,
	  ND: 0xC7FFC7,
	  PM: 0xA3FFC7,
	  SM: 0x8FFFC7,
	  EU: 0x61FFC7,
	  GD: 0x45FFC7,
	  TB: 0x30FFC7,
	  DY: 0x1FFFC7,
	  HO: 0x00FF9C,
	  ER: 0x00E675,
	  TM: 0x00D452,
	  YB: 0x00BF38,
	  LU: 0x00AB24,
	  HF: 0x4DC2FF,
	  TA: 0x4DA6FF,
	  W: 0x2194D6,
	  RE: 0x267DAB,
	  OS: 0x266696,
	  IR: 0x175487,
	  PT: 0xD0D0E0,
	  AU: 0xFFD123,
	  HG: 0xB8B8D0,
	  TL: 0xA6544D,
	  PB: 0x575961,
	  BI: 0x9E4FB5,
	  PO: 0xAB5C00,
	  AT: 0x754F45,
	  RN: 0x428296,
	  FR: 0x420066,
	  RA: 0x007D00,
	  AC: 0x70ABFA,
	  TH: 0x00BAFF,
	  PA: 0x00A1FF,
	  U: 0x008FFF,
	  NP: 0x0080FF,
	  PU: 0x006BFF,
	  AM: 0x545CF2,
	  CM: 0x785CE3,
	  BK: 0x8A4FE3,
	  CF: 0xA136D4,
	  ES: 0xB31FD4,
	  FM: 0xB31FBA,
	  MD: 0xB30DA6,
	  NO: 0xBD0D87,
	  LR: 0xC70066,
	  RF: 0xCC0059,
	  DB: 0xD1004F,
	  SG: 0xD90045,
	  BH: 0xE00038,
	  HS: 0xE6002E,
	  MT: 0xEB0026
	  /* eslint-enable no-magic-numbers */
	};

	palette$1.defaultResidueColor = 0xBEA06E;

	// DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
	palette$1.residueColors = {
	  /* eslint-disable no-magic-numbers */
	  'ALA': 0xC8C8C8,
	  'ARG': 0x145AFF,
	  'ASN': 0x00DCDC,
	  'ASP': 0xE60A0A,
	  'CYS': 0xE6E600,
	  'GLN': 0x00DCDC,
	  'GLU': 0xE60A0A,
	  'GLY': 0xEBEBEB,
	  'HIS': 0x8282D2,
	  'ILE': 0x0F820F,
	  'LEU': 0x0F820F,
	  'LYS': 0x145AFF,
	  'MET': 0xE6E600,
	  'PHE': 0x3232AA,
	  'PRO': 0xDC9682,
	  'SER': 0xFA9600,
	  'THR': 0xFA9600,
	  'TRP': 0xB45AB4,
	  'TYR': 0x3232AA,
	  'VAL': 0x0F820F,
	  'A': 0xA0A0FF,
	  'C': 0xFF8C4B,
	  'G': 0xFF7070,
	  'I': 0x80FFFF,
	  'T': 0xA0FFA0,
	  'U': 0xFF8080,
	  'DA': 0xA0A0FF,
	  'DC': 0xFF8C4B,
	  'DG': 0xFF7070,
	  'DI': 0x80FFFF,
	  'DT': 0xA0FFA0,
	  'DU': 0xFF8080,
	  '+A': 0xA0A0FF,
	  '+C': 0xFF8C4B,
	  '+G': 0xFF7070,
	  '+I': 0x80FFFF,
	  '+T': 0xA0FFA0,
	  '+U': 0xFF8080
	  /* eslint-enable no-magic-numbers */
	};

	palette$1.chainColors = [
	// ' '->0 'A'->1, 'B'->2
	0xFFffffff, // ' ' & '0' white
	//
	0xFFC0D0FF, // skyblue
	0xFFB0FFB0, // pastel green
	0xFFFFC0C8, // pink
	0xFFFFFF80, // pastel yellow
	0xFFFFC0FF, // pastel magenta
	0xFFB0F0F0, // pastel cyan
	0xFFFFD070, // pastel gold
	0xFFF08080, // lightcoral

	0xFFF5DEB3, // wheat
	0xFF00BFFF, // deepskyblue
	0xFFCD5C5C, // indianred
	0xFF66CDAA, // mediumaquamarine
	0xFF9ACD32, // yellowgreen
	0xFFEE82EE, // violet
	0xFF00CED1, // darkturquoise
	0xFF00FF7F, // springgreen
	0xFF3CB371, // mediumseagreen

	0xFF00008B, // darkblue
	0xFFBDB76B, // darkkhaki
	0xFF006400, // darkgreen
	0xFF800000, // maroon
	0xFF808000, // olive
	0xFF800080, // purple
	0xFF008080, // teal
	0xFFB8860B, // darkgoldenrod
	0xFFB22222];

	var StructuralElementType$3 = StructuralElement.Type;

	palette$1.secondaryColors = (_palette$secondaryCol = {}, defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_ALPHA, 0xFF0080), defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_PI, 0x600080), defineProperty(_palette$secondaryCol, StructuralElementType$3.HELIX_310, 0xA00080), defineProperty(_palette$secondaryCol, StructuralElementType$3.STRAND, 0xFFC800), defineProperty(_palette$secondaryCol, StructuralElementType$3.TURN, 0x6080FF), defineProperty(_palette$secondaryCol, 'dna', 0xAE00FE), defineProperty(_palette$secondaryCol, 'rna', 0xFD0162), _palette$secondaryCol);

	var _palette$secondaryCol$1;

	var palette$2 = new Palette('VMD', 'VM');

	palette$2.colors = [
	/* eslint-disable no-magic-numbers */
	0x0000FF, // blue
	0xFF0000, // red
	0x606060, // gray
	0xFF8000, // orange
	0xFFFF00, // yellow
	0x808033, // tan
	0x999999, // silver
	0x00FF00, // green
	0xFFFFFF, // white
	0xFF9999, // pink
	0x40C0C0, // cyan
	0xA600A6, // purple
	0x80E666, // lime
	0xE666B3, // mauve
	0x804D00, // ochre
	0x8080C0 // ice blue
	/* eslint-enable no-magic-numbers */
	];

	palette$2.defaultElementColor = 0x804D00;

	// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
	palette$2.elementColors = {
	  /* eslint-disable no-magic-numbers */
	  H: 0xFFFFFF,
	  C: 0x40BFBF,
	  N: 0x0000FF,
	  O: 0xFF0000,
	  P: 0x808033,
	  S: 0xFFFF00
	  /* eslint-enable no-magic-numbers */
	};

	palette$2.defaultResidueColor = 0x40C0C0;

	// DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
	palette$2.residueColors = {
	  /* eslint-disable no-magic-numbers */
	  'ALA': 0x0000FF,
	  'ARG': 0xFFFFFF,
	  'ASN': 0x808033,
	  'ASP': 0xFF0000,
	  'CYS': 0xFFFF00,
	  'GLN': 0xFF8000,
	  'GLU': 0xFF9999,
	  'GLY': 0xFFFFFF,
	  'HIS': 0x40C0C0,
	  'ILE': 0x00FF00,
	  'LEU': 0xFF9999,
	  'LYS': 0x40C0C0,
	  'MET': 0xFFFF00,
	  'PHE': 0xA600A6,
	  'PRO': 0x804C00,
	  'SER': 0xFFFF00,
	  'THR': 0xE666B3,
	  'TRP': 0x999999,
	  'TYR': 0x00FF00,
	  'VAL': 0x808033,
	  'A': 0x0000FF,
	  'C': 0xFF8000,
	  'G': 0xFFFF00,
	  'T': 0xA600A6,
	  'U': 0x00FF00,
	  'DA': 0x0000FF,
	  'DC': 0xFF8000,
	  'DG': 0xFFFF00,
	  'DT': 0xA600A6,
	  'DU': 0x00FF00,
	  '+A': 0x0000FF,
	  '+C': 0xFF8000,
	  '+G': 0xFFFF00,
	  '+T': 0xA600A6,
	  '+U': 0x00FF00,
	  'WAT': 0x40C0C0,
	  'H2O': 0x40C0C0,
	  'HOH': 0x40C0C0
	  /* eslint-enable no-magic-numbers */
	};

	palette$2.chainColors = [0xFFFFFF].concat(palette$2.colors);

	var StructuralElementType$4 = StructuralElement.Type;

	palette$2.secondaryColors = (_palette$secondaryCol$1 = {}, defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_ALPHA, 0xA600A6), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_310, 0x0000FF), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.HELIX_PI, 0xFF0000), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.STRAND, 0xFFFF00), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.BRIDGE, 0x808033), defineProperty(_palette$secondaryCol$1, StructuralElementType$4.TURN, 0x40C0C0), _palette$secondaryCol$1);

	var palettes = new EntityList([palette, palette$1, palette$2]);

	/** @deprecated */
	Object.defineProperty(palettes, 'list', {
	  get: function get() {
	    return this.all;
	  }
	});

	/** @deprecated */
	Object.defineProperty(palettes, 'any', {
	  get: function get() {
	    return this.first;
	  }
	});

	/**
	 * Create new colorer.
	 *
	 * @param {object=} opts - Options to override defaults with.
	 *
	 *   These options are copied locally and not kept by reference, so the created instance will not reflect further
	 *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
	 *
	 * @exports Colorer
	 * @this Colorer
	 * @abstract
	 * @constructor
	 * @classdesc Basic class for all available coloring algorithms used for building and displaying molecule geometry.
	 */

	var Colorer = function () {
	  function Colorer(opts) {
	    classCallCheck(this, Colorer);

	    if (this.constructor === Colorer) {
	      throw new Error('Can not instantiate abstract class!');
	    }
	    /**
	     * Colorer options inherited (prototyped) from defaults.
	     * @type {object}
	     */
	    this.opts = lodash.merge(utils.deriveDeep(settings.now.colorers[this.id], true), opts);
	    /**
	     * Palette in use.
	     * @type {Palette}
	     */
	    this.palette = palettes.first;
	  }

	  /**
	   * Get Colorer identification, probably with options.
	   * @returns {string|Array} Colorer identifier string ({@link Colorer#id}) or two-element array containing both colorer
	   *   identifier and options ({@link Colorer#opts}).
	   * Options are returned if they were changed during or after colorer creation.
	   */


	  createClass(Colorer, [{
	    key: 'identify',
	    value: function identify() {
	      var diff = utils.objectsDiff(this.opts, settings.now.colorers[this.id]);
	      if (!lodash.isEmpty(diff)) {
	        return [this.id, diff];
	      }
	      return this.id;
	    }
	  }]);
	  return Colorer;
	}();

	/**
	 * Colorer identifier.
	 * @type {string}
	 */

	Colorer.prototype.id = '__';

	/**
	 * Create new colorer.
	 *
	 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
	 *
	 * @see Element
	 *
	 * @exports ElementColorer
	 * @augments Colorer
	 * @constructor
	 * @classdesc Coloring algorithm based on chemical element.
	 */

	var ElementColorer = function (_Colorer) {
	  inherits(ElementColorer, _Colorer);

	  // 'AT' is @deprecated backward compatibility after renaming [A]tom [T]ype -> [EL]ement

	  function ElementColorer(opts) {
	    classCallCheck(this, ElementColorer);
	    return possibleConstructorReturn(this, (ElementColorer.__proto__ || Object.getPrototypeOf(ElementColorer)).call(this, opts));
	  }

	  createClass(ElementColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, _complex) {
	      var type = atom.element.name;
	      if (type === 'C' && this.opts.carbon >= 0) {
	        return this.opts.carbon;
	      }
	      return this.palette.getElementColor(type);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(_residue, _complex) {
	      return this.palette.defaultResidueColor;
	    }
	  }]);
	  return ElementColorer;
	}(Colorer);

	ElementColorer.id = ['EL', 'AT'];


	ElementColorer.prototype.id = 'EL';
	ElementColorer.prototype.aliases = ['AT']; // @deprecated
	ElementColorer.prototype.name = 'Element';
	ElementColorer.prototype.shortName = 'Element';

	/**
	 * Coloring algorithm based on residue type.
	 *
	 * @see ResidueType
	 *
	 * @exports ResidueTypeColorer
	 * @constructor
	 */

	var ResidueTypeColorer = function (_Colorer) {
	  inherits(ResidueTypeColorer, _Colorer);

	  function ResidueTypeColorer(opts) {
	    classCallCheck(this, ResidueTypeColorer);
	    return possibleConstructorReturn(this, (ResidueTypeColorer.__proto__ || Object.getPrototypeOf(ResidueTypeColorer)).call(this, opts));
	  }

	  createClass(ResidueTypeColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, complex) {
	      return this.getResidueColor(atom._residue, complex);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      return this.palette.getResidueColor(residue._type._name);
	    }
	  }]);
	  return ResidueTypeColorer;
	}(Colorer);

	ResidueTypeColorer.id = 'RT';


	ResidueTypeColorer.prototype.id = 'RT';
	ResidueTypeColorer.prototype.name = 'Residue Type';
	ResidueTypeColorer.prototype.shortName = 'Residue';

	var SequenceColorer = function (_Colorer) {
	  inherits(SequenceColorer, _Colorer);

	  // 'RI' is @deprecated backward compatibility after renaming [R]esidue [I]d -> [S]e[Q]uence

	  function SequenceColorer(opts) {
	    classCallCheck(this, SequenceColorer);
	    return possibleConstructorReturn(this, (SequenceColorer.__proto__ || Object.getPrototypeOf(SequenceColorer)).call(this, opts));
	  }

	  createClass(SequenceColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, complex) {
	      return this.getResidueColor(atom._residue, complex);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      var chain = residue._chain;
	      if (chain.minSequence === Number.POSITIVE_INFINITY && chain.maxSequence === Number.NEGATIVE_INFINITY) {
	        return this.palette.defaultNamedColor;
	      }
	      var min = chain.minSequence;
	      var max = chain.maxSequence > min ? chain.maxSequence : min + 1;
	      return this.palette.getGradientColor((residue._sequence - min) / (max - min), this.opts.gradient);
	    }
	  }]);
	  return SequenceColorer;
	}(Colorer);

	SequenceColorer.id = ['SQ', 'RI'];


	SequenceColorer.prototype.id = 'SQ';
	SequenceColorer.prototype.aliases = ['RI']; // @deprecated;
	SequenceColorer.prototype.name = 'Sequence';
	SequenceColorer.prototype.shortName = 'Sequence';

	var ChainColorer = function (_Colorer) {
	  inherits(ChainColorer, _Colorer);

	  function ChainColorer(opts) {
	    classCallCheck(this, ChainColorer);
	    return possibleConstructorReturn(this, (ChainColorer.__proto__ || Object.getPrototypeOf(ChainColorer)).call(this, opts));
	  }

	  createClass(ChainColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, complex) {
	      return this.getResidueColor(atom._residue, complex);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      return this.palette.getChainColor(residue.getChain()._name);
	    }
	  }]);
	  return ChainColorer;
	}(Colorer);

	ChainColorer.id = 'CH';


	ChainColorer.prototype.id = 'CH';
	ChainColorer.prototype.name = 'Chain';
	ChainColorer.prototype.shortName = 'Chain';

	var SecondaryStructureColorer = function (_Colorer) {
	  inherits(SecondaryStructureColorer, _Colorer);

	  function SecondaryStructureColorer(opts) {
	    classCallCheck(this, SecondaryStructureColorer);
	    return possibleConstructorReturn(this, (SecondaryStructureColorer.__proto__ || Object.getPrototypeOf(SecondaryStructureColorer)).call(this, opts));
	  }

	  createClass(SecondaryStructureColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, complex) {
	      return this.getResidueColor(atom._residue, complex);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      if (residue._type.flags & ResidueType.Flags.DNA) {
	        return this.palette.getSecondaryColor('dna');
	      } else if (residue._type.flags & ResidueType.Flags.RNA) {
	        return this.palette.getSecondaryColor('rna');
	      }
	      var secondary = residue.getSecondary();
	      if (secondary) {
	        var color = this.palette.getSecondaryColor(secondary.type, true);
	        if (color === undefined) {
	          color = this.palette.getSecondaryColor(secondary.generic);
	        }
	        return color;
	      }
	      return this.palette.defaultSecondaryColor;
	    }
	  }]);
	  return SecondaryStructureColorer;
	}(Colorer);

	SecondaryStructureColorer.id = 'SS';


	SecondaryStructureColorer.prototype.id = 'SS';
	SecondaryStructureColorer.prototype.name = 'Secondary Structure';
	SecondaryStructureColorer.prototype.shortName = 'Structure';

	var UniformColorer = function (_Colorer) {
	  inherits(UniformColorer, _Colorer);

	  function UniformColorer(opts) {
	    classCallCheck(this, UniformColorer);
	    return possibleConstructorReturn(this, (UniformColorer.__proto__ || Object.getPrototypeOf(UniformColorer)).call(this, opts));
	  }

	  createClass(UniformColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(_atom, _complex) {
	      return this.opts.color;
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(_residue, _complex) {
	      return this.opts.color;
	    }
	  }]);
	  return UniformColorer;
	}(Colorer);

	UniformColorer.id = 'UN';


	UniformColorer.prototype.id = 'UN';
	UniformColorer.prototype.name = 'Uniform';
	UniformColorer.prototype.shortName = 'Uniform';

	/**
	 * Create new colorer.
	 *
	 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
	 *
	 * @exports ConditionalColorer
	 * @augments Colorer
	 * @constructor
	 * @classdesc Bicolor coloring algorithm based on a selector string used as a condition.
	 */

	var ConditionalColorer = function (_Colorer) {
	  inherits(ConditionalColorer, _Colorer);

	  function ConditionalColorer(opts) {
	    classCallCheck(this, ConditionalColorer);

	    var _this = possibleConstructorReturn(this, (ConditionalColorer.__proto__ || Object.getPrototypeOf(ConditionalColorer)).call(this, opts));

	    var parsed = selectors.parse(_this.opts.subset);
	    _this._subsetCached = parsed.error ? selectors.none() : parsed.selector;
	    return _this;
	  }

	  createClass(ConditionalColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, _complex) {
	      return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      var subset = this._subsetCached;
	      var includes = true;
	      var atoms = residue._atoms;
	      for (var i = 0, n = atoms.length; i < n; ++i) {
	        includes = includes && subset.includesAtom(atoms[i]);
	      }
	      return includes ? this.opts.color : this.opts.baseColor;
	    }
	  }]);
	  return ConditionalColorer;
	}(Colorer);

	ConditionalColorer.id = 'CO';


	ConditionalColorer.prototype.id = 'CO';
	ConditionalColorer.prototype.name = 'Conditional';
	ConditionalColorer.prototype.shortName = 'Conditional';

	var ConformationColorer = function (_Colorer) {
	  inherits(ConformationColorer, _Colorer);

	  function ConformationColorer(opts) {
	    classCallCheck(this, ConformationColorer);
	    return possibleConstructorReturn(this, (ConformationColorer.__proto__ || Object.getPrototypeOf(ConformationColorer)).call(this, opts));
	  }

	  createClass(ConformationColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, _complex) {
	      return this.palette.getChainColor(String.fromCharCode(atom._location));
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(_residue, _complex) {
	      return this.palette.defaultResidueColor;
	    }
	  }]);
	  return ConformationColorer;
	}(Colorer);

	ConformationColorer.id = 'CF';


	ConformationColorer.prototype.id = 'CF';
	ConformationColorer.prototype.name = 'Conformation';
	ConformationColorer.prototype.shortName = 'Conformation';

	/**
	 * Create new colorer.
	 *
	 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
	 *
	 * @see Temperature
	 *
	 * @exports TemperatureColorer
	 * @augments Colorer
	 * @constructor
	 * @classdesc Coloring algorithm based on temperature of chemical element.
	 */

	var TemperatureColorer = function (_Colorer) {
	  inherits(TemperatureColorer, _Colorer);

	  function TemperatureColorer(opts) {
	    classCallCheck(this, TemperatureColorer);
	    return possibleConstructorReturn(this, (TemperatureColorer.__proto__ || Object.getPrototypeOf(TemperatureColorer)).call(this, opts));
	  }

	  createClass(TemperatureColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, _complex) {
	      var opts = this.opts;
	      var factor = 1;
	      if (atom._temperature && opts) {
	        if (opts.min === opts.max) {
	          factor = atom._temperature > opts.max ? 1 : 0;
	        } else {
	          factor = (atom._temperature - opts.min) / (opts.max - opts.min);
	        }
	        return this.palette.getGradientColor(factor, opts.gradient);
	      }
	      return this.palette.defaultGradientColor;
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      var opts = this.opts;
	      if (!opts) {
	        return this.palette.defaultGradientColor;
	      }
	      if (residue.temperature) {
	        var factor = 0;
	        if (opts.min === opts.max) {
	          factor = residue.temperature > opts.max ? 1 : 0;
	        } else {
	          factor = (residue.temperature - opts.min) / (opts.max - opts.min);
	        }
	        return this.palette.getGradientColor(factor, opts.gradient);
	      }
	      return this.palette.defaultGradientColor;
	    }
	  }]);
	  return TemperatureColorer;
	}(Colorer);

	TemperatureColorer.id = 'TM';


	TemperatureColorer.prototype.id = 'TM'; // [T]e[M]perature
	TemperatureColorer.prototype.name = 'Temperature';
	TemperatureColorer.prototype.shortName = 'Temperature';

	/**
	 * Create new colorer.
	 *
	 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
	 *
	 * @see Occupancy
	 *
	 * @exports OccupancyColorer
	 * @augments Occupancy
	 * @constructor
	 * @classdesc Coloring algorithm based on occupancy of chemical element.
	 */

	var OccupancyColorer = function (_Colorer) {
	  inherits(OccupancyColorer, _Colorer);

	  function OccupancyColorer(opts) {
	    classCallCheck(this, OccupancyColorer);
	    return possibleConstructorReturn(this, (OccupancyColorer.__proto__ || Object.getPrototypeOf(OccupancyColorer)).call(this, opts));
	  }

	  createClass(OccupancyColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, _complex) {
	      var opts = this.opts;
	      if (atom._occupancy && opts) {
	        var factor = 1 - atom._occupancy;
	        return this.palette.getGradientColor(factor, opts.gradient);
	      }
	      return this.palette.defaultGradientColor;
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      var opts = this.opts;
	      if (!opts) {
	        return this.palette.defaultGradientColor;
	      }
	      if (residue.occupancy > 0) {
	        var factor = 1 - residue.occupancy;
	        return this.palette.getGradientColor(factor, opts.gradient);
	      }
	      return this.palette.defaultGradientColor;
	    }
	  }]);
	  return OccupancyColorer;
	}(Colorer);

	OccupancyColorer.id = 'OC';


	OccupancyColorer.prototype.id = 'OC'; //[OC]cupancy
	OccupancyColorer.prototype.name = 'Occupancy';
	OccupancyColorer.prototype.shortName = 'Occupancy';

	var HydrophobicityColorer = function (_Colorer) {
	  inherits(HydrophobicityColorer, _Colorer);

	  function HydrophobicityColorer(opts) {
	    classCallCheck(this, HydrophobicityColorer);
	    return possibleConstructorReturn(this, (HydrophobicityColorer.__proto__ || Object.getPrototypeOf(HydrophobicityColorer)).call(this, opts));
	  }

	  createClass(HydrophobicityColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, complex) {
	      return this.getResidueColor(atom._residue, complex);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      var color = this.palette.defaultResidueColor;
	      if (residue._type.hydrophobicity) {
	        //Kyte Doolitle hydro [-4.5,4.5]->[0.1]
	        var min = -4.5;
	        var max = 4.5;
	        color = this.palette.getGradientColor((residue._type.hydrophobicity - min) / (max - min), this.opts.gradient);
	      }
	      return color;
	    }
	  }]);
	  return HydrophobicityColorer;
	}(Colorer);

	HydrophobicityColorer.id = 'HY';


	HydrophobicityColorer.prototype.id = 'HY';
	HydrophobicityColorer.prototype.name = 'Hydrophobicity';
	HydrophobicityColorer.prototype.shortName = 'Hydrophobicity';

	var MoleculeColorer = function (_Colorer) {
	  inherits(MoleculeColorer, _Colorer);

	  function MoleculeColorer(opts) {
	    classCallCheck(this, MoleculeColorer);
	    return possibleConstructorReturn(this, (MoleculeColorer.__proto__ || Object.getPrototypeOf(MoleculeColorer)).call(this, opts));
	  }

	  createClass(MoleculeColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, complex) {
	      return this.getResidueColor(atom._residue, complex);
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(residue, _complex) {
	      var molecule = residue._molecule;
	      var count = _complex.getMoleculeCount();
	      if (count > 1) {
	        return this.palette.getGradientColor((molecule._index - 1) / (count - 1), this.opts.gradient);
	      }
	      return this.palette.getGradientColor(0, this.opts.gradient);
	    }
	  }]);
	  return MoleculeColorer;
	}(Colorer);

	MoleculeColorer.id = 'MO';


	MoleculeColorer.prototype.id = 'MO';
	MoleculeColorer.prototype.name = 'Molecule';
	MoleculeColorer.prototype.shortName = 'Molecule';

	function scaleColor(c, factor) {
	  var r1 = c >> 16 & 0xff,
	      g1 = c >> 8 & 0xff,
	      b1 = c & 0xff;
	  var r = factor * r1,
	      g = factor * g1,
	      b = factor * b1;
	  return r << 16 | g << 8 | b;
	}

	/**
	 * Create new colorer.
	 *
	 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
	 *
	 * @exports CarbonColorer
	 * @augments Colorer
	 * @constructor
	 * @classdesc Bicolor coloring algorithm based on selection carbon atoms.
	 */

	var CarbonColorer = function (_Colorer) {
	  inherits(CarbonColorer, _Colorer);

	  function CarbonColorer(opts) {
	    classCallCheck(this, CarbonColorer);
	    return possibleConstructorReturn(this, (CarbonColorer.__proto__ || Object.getPrototypeOf(CarbonColorer)).call(this, opts));
	  }

	  createClass(CarbonColorer, [{
	    key: 'getAtomColor',
	    value: function getAtomColor(atom, _complex) {
	      var colorCarbon = this.opts.color;
	      var colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
	      return atom.flags & Atom.Flags.CARBON ? colorCarbon : colorNotCarbon;
	    }
	  }, {
	    key: 'getResidueColor',
	    value: function getResidueColor(_residue, _complex) {
	      return this.opts.color;
	    }
	  }]);
	  return CarbonColorer;
	}(Colorer);

	CarbonColorer.id = 'CB';


	CarbonColorer.prototype.id = 'CB';
	CarbonColorer.prototype.name = 'Carbon';
	CarbonColorer.prototype.shortName = 'Carbon';

	var colorers = new EntityList([ElementColorer, ResidueTypeColorer, SequenceColorer, ChainColorer, SecondaryStructureColorer, UniformColorer, ConditionalColorer, ConformationColorer, TemperatureColorer, OccupancyColorer, HydrophobicityColorer, MoleculeColorer, CarbonColorer]);

	/** @deprecated */
	Object.defineProperty(colorers, 'list', {
	  get: function get() {
	    return this.all;
	  }
	});

	/** @deprecated */
	Object.defineProperty(colorers, 'any', {
	  get: function get() {
	    return this.first;
	  }
	});

	/** @deprecated */
	Object.defineProperty(colorers, 'descriptions', {
	  get: function get() {
	    return lodash.map(this._list, function (m) {
	      return lodash.pick(m.prototype, ['id', 'name']);
	    });
	  }
	});

	/** @deprecated */
	colorers.create = function (colorer, opts) {
	  if (!opts && colorer instanceof Array) {
	    opts = colorer[1];
	    colorer = colorer[0];
	  }
	  var Colorer = this.get(colorer) || this.first;
	  return new Colorer(opts);
	};

	function neutralColor(intensity) {
	  return new Color(intensity, intensity, intensity);
	}

	var materialList = [{
	  id: 'DF',
	  name: 'Diffuse',
	  shortName: 'Diffuse',
	  uberOptions: {
	    diffuse: neutralColor(1.0),
	    specular: neutralColor(0.0),
	    shininess: 1,
	    opacity: 1.0
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: false,
	    toonShading: false
	  }
	}, {
	  id: 'SF',
	  name: 'Soft Plastic',
	  shortName: 'Soft',
	  uberOptions: {
	    diffuse: neutralColor(1.0),
	    specular: neutralColor(0.1),
	    shininess: 30,
	    opacity: 1.0
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: false,
	    toonShading: false
	  }
	}, {
	  id: 'PL',
	  name: 'Glossy Plastic',
	  shortName: 'Glossy',
	  uberOptions: {
	    diffuse: neutralColor(0.56),
	    specular: neutralColor(0.28),
	    shininess: 100,
	    opacity: 1.0
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: false,
	    toonShading: false
	  }
	}, {
	  id: 'ME',
	  name: 'Metal',
	  shortName: 'Metal',
	  uberOptions: {
	    diffuse: neutralColor(0.56),
	    specular: neutralColor(0.55),
	    shininess: 30,
	    opacity: 1.0
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: false,
	    toonShading: false
	  }
	}, {
	  id: 'TR',
	  name: 'Transparent',
	  shortName: 'Transparent',
	  uberOptions: {
	    diffuse: neutralColor(1.0),
	    specular: neutralColor(0.0),
	    shininess: 1,
	    opacity: 0.5
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: true,
	    toonShading: false
	  }
	}, {
	  id: 'GL',
	  name: 'Glass',
	  shortName: 'Glass',
	  depthWrite: true,
	  uberOptions: {
	    diffuse: neutralColor(0.50),
	    specular: neutralColor(0.65),
	    shininess: 100,
	    opacity: 0.5
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: true,
	    toonShading: false
	  }
	}, {
	  id: 'BA',
	  name: 'Backdrop',
	  shortName: 'Backdrop',
	  uberOptions: {
	    opacity: 1.0
	  },
	  values: {
	    lights: false,
	    fog: false,
	    depthWrite: false,
	    transparent: false,
	    toonShading: false
	  }
	}, {
	  id: 'TN',
	  name: 'Toon',
	  shortName: 'Toon',
	  uberOptions: {
	    diffuse: neutralColor(1.0),
	    specular: neutralColor(0.0),
	    shininess: 1,
	    opacity: 1.0
	  },
	  values: {
	    lights: true,
	    fog: true,
	    depthWrite: true,
	    transparent: false,
	    toonShading: true
	  }
	}, {
	  id: 'FL',
	  name: 'Flat',
	  shortName: 'Flat',
	  uberOptions: {
	    diffuse: neutralColor(1.0),
	    specular: neutralColor(0.0),
	    shininess: 0,
	    opacity: 1.0
	  },
	  values: {
	    lights: false,
	    fog: true,
	    depthWrite: true,
	    transparent: false
	  }
	}];

	var materials = new EntityList(materialList);

	/** @deprecated */
	Object.defineProperty(materials, 'list', {
	  get: function get() {
	    return this.all;
	  }
	});

	/** @deprecated */
	Object.defineProperty(materials, 'any', {
	  get: function get() {
	    return this.first;
	  }
	});

	/** @deprecated */
	Object.defineProperty(materials, 'descriptions', {
	  get: function get() {
	    return lodash.map(this._list, function (m) {
	      return lodash.pick(m, ['id', 'name']);
	    });
	  }
	});

	function Representation(index, mode, colorer, selector) {
	  this.index = index;
	  this.mode = mode;
	  this.colorer = colorer;
	  this.selector = selector;
	  this.selectorString = ''; // FIXME
	  this.count = 0;
	  this.material = new UberMaterial();
	  this.material.setValues({ clipPlane: settings.now.draft.clipPlane, fogTransparent: settings.now.bg.transparent });
	  this.material.setUberOptions({ fogAlpha: settings.now.fogAlpha });
	  this.materialPreset = materials.first;
	  this.needsRebuild = true;
	  this.visible = true;

	  // apply mode params & preset
	  this.setMode(mode);
	}

	Representation.prototype.markAtoms = function (complex) {
	  this.count = complex.markAtoms(this.selector, 1 << this.index);
	  this.needsRebuild = true;
	  return this.count;
	};

	Representation.prototype.unmarkAtoms = function (complex) {
	  complex.clearAtomBits(1 << this.index);
	  this.count = 0;
	};

	Representation.prototype.setMode = function (mode) {
	  this.mode = mode;
	};

	Representation.prototype.setMaterialPreset = function (preset) {
	  this.materialPreset = preset;
	  this.material.setUberOptions(preset.uberOptions);
	  this.material.setValues(preset.values);
	};

	Representation.prototype.reset = function () {
	  this.geo = null;
	  this.selectionGeo = null;
	};

	Representation.prototype.buildGeometry = function (complex) {
	  // console.time('buildGeometry');
	  this.reset();
	  this.needsRebuild = false;

	  if (settings.now.ao) {
	    this.material.setValues({ normalsToGBuffer: settings.now.ao });
	  }

	  this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);

	  if (this.material.uberOptions.opacity < 0.99 && settings.now.transparency === 'prepass') {
	    gfxutils.processTransparentMaterial(this.geo, this.material);
	  }
	  // console.timeEnd('buildGeometry');
	  this.geo.visible = this.visible;

	  return this.geo;
	};

	Representation.prototype.buildSelectionGeometry = function (mask) {
	  var sg = null;

	  if (this.geo && 'getSubset' in this.geo) {
	    var meshes = this.geo.getSubset(mask);
	    if (meshes && meshes.length > 0) {
	      sg = new Group();
	      sg.matrixAutoUpdate = false;
	      sg.matrix = this.geo.matrix;

	      for (var j = 0; j < meshes.length; j++) {
	        var m = meshes[j];
	        sg.add(m);
	      }
	    }
	  }

	  if (sg) {
	    sg.visible = this.visible;
	  }

	  this.selectionGeo = sg;
	  return this.selectionGeo;
	};

	/**
	 * Create object that represents difference between current and another rep
	 * anotherRep could be undefined. In this case everything is reported.
	 */
	Representation.prototype.compare = function (repSettings) {
	  var diff = {};

	  var selStr = String(this.selector);
	  if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
	    diff.selector = selStr;
	  }

	  var modeDiff = this.mode.identify();
	  if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
	    diff.mode = modeDiff;
	  }

	  var colorerDiff = this.colorer.identify();
	  if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
	    diff.colorer = colorerDiff;
	  }

	  if (!repSettings || this.materialPreset.id !== repSettings.material) {
	    diff.material = this.materialPreset.id;
	  }

	  return diff;
	};

	Representation.prototype.show = function (visible) {
	  this.visible = visible;
	  if (this.geo) {
	    this.geo.visible = visible;
	  }
	  if (this.selectionGeo) {
	    this.selectionGeo.visible = visible;
	  }
	};

	function _traverseComponentGroups(root, component, callback) {
	  var children = root.children;
	  if (!children) {
	    return;
	  }

	  for (var i = 0, n = children.length; i < n; ++i) {
	    var child = children[i];
	    if (child._component === component) {
	      callback(child);
	    }
	    if (child instanceof gfxutils.RCGroup) {
	      _traverseComponentGroups(child, component, callback);
	    }
	  }
	}

	function ComplexEditor() {}

	function ComplexComponentEditor(complexVisual) {
	  this._complexVisual = complexVisual;
	  this._inProgress = false;
	}

	utils.deriveClass(ComplexComponentEditor, ComplexEditor);

	ComplexComponentEditor.prototype.begin = function () {
	  var complex = this._complexVisual.getComplex();

	  // init component matrices
	  this._componentTransforms = [];
	  for (var i = 0; i < complex._components.length; ++i) {
	    var component = complex._components[i];
	    this._componentTransforms[component._index] = new Object3D();
	  }

	  this._inProgress = true;

	  return true;
	};

	ComplexComponentEditor.prototype.apply = function () {
	  if (!this._inProgress) {
	    return;
	  }

	  var complex = this._complexVisual.getComplex();

	  for (var i = 0; i < complex._components.length; ++i) {
	    this._bakeComponentTransform(complex._components[i]);
	  }

	  complex.onAtomPositionChanged();

	  this._resetComponentTransform();

	  this._complexVisual.finalizeEdit();

	  // TODO: rebuild in Miew
	  // this.rebuildAll();
	};

	ComplexComponentEditor.prototype.discard = function () {
	  if (!this._inProgress) {
	    return;
	  }

	  this._resetComponentTransform();

	  this._complexVisual.finalizeEdit();

	  // TODO: Make sure this is set in Miew
	  // this._needRender = true;
	};

	ComplexComponentEditor.prototype.getAltObj = function () {
	  var res = {
	    objects: [],
	    pivot: new Vector3(0, 0, 0)
	  };

	  var visual = this._complexVisual;
	  var component = visual.getSelectedComponent();

	  if (component === null) {
	    return res;
	  }

	  var selection = this._complexVisual.getSelectionGeo();
	  var selectionMask = 1 << visual.getSelectionBit();
	  var i, j, reprNode, geo;

	  // find all geo nodes for this component
	  _traverseComponentGroups(visual, component, function (child) {
	    res.objects.push(child);
	  });

	  // find all selection nodes for this component
	  for (i = 0; i < selection.children.length; ++i) {
	    reprNode = selection.children[i];
	    for (j = 0; j < reprNode.children.length; ++j) {
	      geo = reprNode.children[j];
	      if (geo.hasOwnProperty('_component') && geo._component === component) {
	        res.objects.push(geo);
	      }
	    }
	  }

	  // add dummy object that stores component transformation
	  res.objects.push(this._componentTransforms[component._index]);

	  var bbmin = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
	  var bbmax = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

	  component.forEachResidue(function (residue) {
	    var atoms = residue._atoms;
	    for (j = 0; j < atoms.length; ++j) {
	      if (atoms[j]._mask & selectionMask) {
	        bbmin.min(atoms[j]._position);
	        bbmax.max(atoms[j]._position);
	      }
	    }
	  });

	  res.pivot.lerpVectors(bbmin, bbmax, 0.5);
	  return res;
	};

	ComplexComponentEditor.prototype._bakeComponentTransform = function (component) {
	  var t = this._componentTransforms[component._index];
	  if (t && (!(t.position.x === 0 && t.position.y === 0 && t.position.z === 0) || !(t.quaternion.x === 0 && t.quaternion.y === 0 && t.quaternion.z === 0 && t.quaternion.w === 1))) {

	    t.updateMatrix();

	    component.forEachResidue(function (residue) {
	      var atoms = residue._atoms;
	      for (var j = 0; j < atoms.length; ++j) {
	        atoms[j]._position.applyMatrix4(t.matrix);
	      }
	    });
	  }
	};

	ComplexComponentEditor.prototype._resetComponentTransform = function () {
	  var visual = this._complexVisual;
	  var selection = this._complexVisual.getSelectionGeo();
	  var i, j, reprNode, geo;

	  for (i = 0; i < this._componentTransforms.length; ++i) {
	    geo = this._componentTransforms[i];
	    geo.position.set(0, 0, 0);
	    geo.quaternion.set(0, 0, 0, 1);
	  }

	  // reset all geo nodes
	  for (i = 0; i < visual.children.length; ++i) {
	    reprNode = visual.children[i];
	    for (j = 0; j < reprNode.children.length; ++j) {
	      geo = reprNode.children[j];
	      if (geo.hasOwnProperty('_component')) {
	        geo.position.set(0, 0, 0);
	        geo.quaternion.set(0, 0, 0, 1);
	      }
	    }
	  }

	  // reset all selection nodes
	  for (i = 0; i < selection.children.length; ++i) {
	    reprNode = selection.children[i];
	    for (j = 0; j < reprNode.children.length; ++j) {
	      geo = reprNode.children[j];
	      if (geo.hasOwnProperty('_component')) {
	        geo.position.set(0, 0, 0);
	        geo.quaternion.set(0, 0, 0, 1);
	      }
	    }
	  }
	};

	function ComplexFragmentEditor(complexVisual) {
	  this._complexVisual = complexVisual;
	  this._inProgress = false;
	}

	utils.deriveClass(ComplexFragmentEditor, ComplexEditor);

	ComplexFragmentEditor.prototype.begin = function () {
	  var visual = this._complexVisual;
	  var selection = this._complexVisual.getSelectionGeo();

	  var atoms = this._getSelectionBorderAtoms();
	  if (atoms.length < 1 || atoms.length > 2) {
	    logger.error('Can only edit fragments with one or two bound atoms.');
	    return false;
	  }

	  this._fragmentBoundAtoms = atoms;

	  var selectionMask = 1 << visual.getSelectionBit();

	  // hide selected fragment in main model
	  visual.disableSubset(selectionMask, true);

	  // hide selection geo in main model
	  for (var k = 0; k < selection.children.length; ++k) {
	    selection.children[k].visible = false;
	  }

	  // create visible fragment representation to rotate
	  var pivotPos = atoms[0]._position.clone();

	  if (atoms.length === 2) {
	    pivotPos.lerp(atoms[1]._position, 0.5);
	  }

	  this._fragmentGeo = new Group();
	  visual.add(this._fragmentGeo);
	  this._fragmentGeo.position.copy(pivotPos);

	  this._fragmentSelectionGeo = new Group();
	  selection.add(this._fragmentSelectionGeo);
	  this._fragmentSelectionGeo.position.copy(pivotPos);

	  var offset = pivotPos.clone();
	  offset.negate();

	  for (var i = 0; i < visual.children.length; ++i) {
	    var g = visual.children[i];
	    if (!('getSubset' in g)) {
	      continue;
	    }

	    var vg = new Group();
	    this._fragmentGeo.add(vg);

	    var sg = new Group();
	    this._fragmentSelectionGeo.add(sg);

	    var meshes = g.getSubset(selectionMask, true);
	    for (var j = 0; j < meshes.length; j++) {
	      var m = meshes[j];
	      vg.add(m);
	      m.position.copy(offset);
	    }

	    var smeshes = g.getSubset(selectionMask, true);
	    for (var h = 0; h < smeshes.length; h++) {
	      var sm = smeshes[h];
	      sg.add(sm);
	      sm.position.copy(offset);
	    }
	  }

	  gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);

	  // TODO: Make sure this is set in Miew
	  // this._needRender = true;

	  this._inProgress = true;
	  return true;
	};

	ComplexFragmentEditor.prototype.apply = function () {
	  if (!this._inProgress) {
	    return;
	  }

	  var visual = this._complexVisual;
	  var selectionBit = visual.getSelectionBit();

	  var p = this._fragmentGeo.position;
	  var m = this._fragmentGeo.matrix.clone();
	  m.multiply(new Matrix4().makeTranslation(-p.x, -p.y, -p.z));

	  this._bakeAtomTransform(m, 1 << selectionBit);

	  // show selected fragment in main model
	  visual.enableSubset(1 << selectionBit, true);

	  visual.getComplex().onAtomPositionChanged();

	  visual.finalizeEdit();

	  // TODO: rebuild in Miew
	  // this.rebuildAll();
	};

	ComplexFragmentEditor.prototype.discard = function () {
	  if (!this._inProgress) {
	    return;
	  }

	  var visual = this._complexVisual;
	  var selection = this._complexVisual.getSelectionGeo();

	  this._fragmentGeo.parent.remove(this._fragmentGeo);

	  // show selected fragment in main model
	  visual.enableSubset(1 << visual.getSelectionBit(), true);

	  // show selection geo in main model (+ remove fragment selection geo)
	  for (var i = 0; i < selection.children.length; ++i) {
	    var node = selection.children[i];
	    if (node.visible) {
	      selection.remove(node);
	    } else {
	      node.visible = true;
	    }
	  }

	  visual.finalizeEdit();

	  // TODO: Make sure this is set in Miew
	  // this._needRender = true;
	};

	ComplexFragmentEditor.prototype.isFreeRotationAllowed = function () {
	  return this._fragmentBoundAtoms.length < 2;
	};

	ComplexFragmentEditor.prototype.getAltObj = function () {
	  var res = {
	    objects: [],
	    pivot: new Vector3(0, 0, 0)
	  };

	  res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);

	  var boundAtoms = this._fragmentBoundAtoms;
	  if (boundAtoms.length === 1) {
	    if (boundAtoms[0]._bonds.length === 1) {
	      // single external bond allows rotation about bond axis
	      var bond = boundAtoms[0]._bonds[0];
	      res.axis = new Vector3().subVectors(bond._right._position, bond._left._position);
	      res.axis.normalize();
	      res.axis.transformDirection(this._complexVisual.matrixWorld);
	    }
	  } else if (boundAtoms.length === 2) {
	    // two bound atoms allow rotation only about axis running through their centers
	    res.axis = new Vector3().subVectors(boundAtoms[1]._position, boundAtoms[0]._position);
	    res.axis.normalize();
	    res.axis.transformDirection(this._complexVisual.matrixWorld);
	  }

	  return res;
	};

	ComplexFragmentEditor.prototype._getSelectionBorderAtoms = function () {
	  var complex = this._complexVisual.getComplex();

	  var selectionMask = 1 << this._complexVisual.getSelectionBit();
	  var atomHash = {};

	  complex.forEachBond(function (bond) {
	    if (bond._left._mask & selectionMask) {
	      if ((bond._right._mask & selectionMask) === 0) {
	        atomHash[bond._left._index] = 1;
	      }
	    } else if (bond._right._mask & selectionMask) {
	      atomHash[bond._right._index] = 1;
	    }
	  });

	  var atoms = [];
	  var keys = Object.keys(atomHash);
	  for (var i = 0, n = keys.length; i < n; ++i) {
	    var idx = keys[i];
	    atoms.push(complex._atoms[idx]);
	  }

	  return atoms;
	};

	ComplexFragmentEditor.prototype._bakeAtomTransform = function (matrix, mask) {
	  this._complexVisual.getComplex().forEachAtom(function (atom) {
	    if (atom._mask & mask) {
	      atom._position.applyMatrix4(matrix);
	    }
	  });
	};

	var ComplexVisualEdit = {
	  ComponentEditor: ComplexComponentEditor,
	  FragmentEditor: ComplexFragmentEditor
	};

	var selectors$2 = chem.selectors;

	function ComplexVisual(name, dataSource) {
	  Visual.call(this, name, dataSource);

	  this._complex = dataSource;

	  /** @type {Representation[]} */
	  this._reprList = [];
	  /** @type {?Representation} */
	  this._repr = null;
	  this._reprListChanged = true;

	  this._selectionBit = 0;
	  this._reprUsedBits = 0;
	  this._selectionCount = 0;

	  this._selectionGeometry = new Group();
	}

	// 32 bits = 30 bits for reps + 1 for selection + 1 for selection expansion
	ComplexVisual.NUM_REPRESENTATION_BITS = 30;

	utils.deriveClass(ComplexVisual, Visual);

	ComplexVisual.prototype.getBoundaries = function () {
	  return this._complex.getBoundaries();
	};

	ComplexVisual.prototype.release = function () {
	  if (this._selectionGeometry.parent) {
	    this._selectionGeometry.remove(this._selectionGeometry);
	  }

	  Visual.prototype.release.call(this);
	};

	ComplexVisual.prototype.getComplex = function () {
	  return this._complex;
	};

	ComplexVisual.prototype.getSelectionCount = function () {
	  return this._selectionCount;
	};

	ComplexVisual.prototype.getSelectionGeo = function () {
	  return this._selectionGeometry;
	};

	ComplexVisual.prototype.getSelectionBit = function () {
	  return this._selectionBit;
	};

	ComplexVisual.prototype.getEditor = function () {
	  return this._editor;
	};

	function lookupAndCreate(entityList, specs) {
	  if (!Array.isArray(specs)) {
	    specs = [specs];
	  }

	  var _specs = specs,
	      _specs2 = slicedToArray(_specs, 2),
	      id = _specs2[0],
	      opts = _specs2[1];

	  var Entity = entityList.get(id) || entityList.first;
	  return new Entity(opts);
	}

	ComplexVisual.prototype.resetReps = function (reps) {
	  // Create all necessary representations
	  if (this._complex) {
	    this._complex.clearAtomBits(~0);
	  }
	  this._reprListChanged = true;
	  this._reprUsedBits = 0;
	  this._reprList.length = reps.length;
	  for (var i = 0, n = reps.length; i < n; ++i) {
	    var rep = reps[i];

	    var selector, selectorString;
	    if (typeof rep.selector === 'string') {
	      selectorString = rep.selector;
	      selector = selectors$2.parse(selectorString).selector;
	    } else if (typeof rep.selector === 'undefined') {
	      selectorString = settings.now.presets.default[0].selector;
	      selector = selectors$2.parse(selectorString).selector;
	    } else {
	      selector = rep.selector;
	      selectorString = selector.toString();
	    }
	    var mode = lookupAndCreate(modes, rep.mode);
	    var colorer = lookupAndCreate(colorers, rep.colorer);
	    var material = materials.get(rep.material) || materials.first;

	    this._reprList[i] = new Representation(i, mode, colorer, selector);
	    this._reprList[i].setMaterialPreset(material);
	    this._reprList[i].selectorString = selectorString; // FIXME: get rid of a separate selectorString

	    if (this._complex) {
	      this._complex.markAtoms(selector, 1 << i);
	    }

	    this._reprUsedBits |= 1 << i;
	  }
	  this._repr = reps.length > 0 ? this._reprList[0] : null;

	  this._selectionBit = reps.length;
	  this._reprUsedBits |= 1 << this._selectionBit; // selection uses one bit
	  this._selectionCount = 0;

	  if (this._complex) {
	    this._complex.update();
	  }
	};

	/**
	 * Get number of representations created so far.
	 * @returns {number} Number of reps.
	 */
	ComplexVisual.prototype.repCount = function () {
	  return this._reprList.length;
	};

	/**
	 * Get or set the current representation index.
	 * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
	 * @returns {number} The current index.
	 */
	ComplexVisual.prototype.repCurrent = function (index) {
	  if (index >= 0 && index < this._reprList.length) {
	    this._repr = this._reprList[index];
	  } else {
	    index = this._reprList.indexOf(this._repr);
	  }
	  return index;
	};

	/**
	 * Get or set representation by index.
	 * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
	 * @param {object=} rep - Optional representation description.
	 * @param {string=} rep.selector - Selector string.
	 * @param {string=} rep.mode - Mode id.
	 * @param {string=} rep.colorer - Colorer id.
	 * @param {string=} rep.material - Material id.
	 * @returns {?object} Representation description.
	 */
	ComplexVisual.prototype.rep = function (index, rep) {
	  // if index is missing then it is the current
	  if (!rep && (index === undefined || index instanceof Object)) {
	    rep = index;
	    index = this.repCurrent();
	  }

	  // fail if out of bounds
	  if (index < 0 || index > this._reprList.length) {
	    logger.error('Rep ' + index + ' does not exist!');
	    return null;
	  }

	  // a special case of adding just after the end
	  if (index === this._reprList.length) {
	    this.repAdd(rep);
	    rep = undefined;
	    logger.warn('Rep ' + index + ' does not exist! New representation was created.');
	  }

	  // gather description
	  var target = this._reprList[index];
	  var desc = {
	    selector: target.selectorString, // FIXME: Hope it equals String(target.selector)
	    mode: target.mode.identify(),
	    colorer: target.colorer.identify(),
	    material: target.materialPreset.id
	  };

	  // if modification is requested
	  if (rep) {
	    var changed = false;

	    // modify selector
	    if (rep.selector) {
	      var newSelectorObject = selectors$2.parse(rep.selector).selector;
	      var newSelector = String(newSelectorObject);
	      if (desc.selector !== newSelector) {
	        target.selectorString = desc.selector = newSelector;
	        target.selector = newSelectorObject;
	        target.markAtoms(this._complex);
	        changed = true;
	        logger.debug('rep[' + index + '].selector changed to' + newSelector);
	      }
	    }

	    // modify mode
	    if (rep.mode) {
	      var newMode = rep.mode;
	      if (!lodash.isEqual(desc.mode, newMode)) {
	        desc.mode = newMode;
	        target.setMode(lookupAndCreate(modes, rep.mode));
	        changed = true;
	        logger.debug('rep[' + index + '].mode changed to ' + newMode);

	        // safety hack: lower resolution for surface modes
	        if (target.mode.isSurface && (settings.now.resolution === 'ultra' || settings.now.resolution === 'high')) {
	          logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
	          settings.set('resolution', 'medium');
	        }
	      }
	    }

	    // modify colorer
	    if (rep.colorer) {
	      var newColorer = rep.colorer;
	      if (!lodash.isEqual(desc.colorer, newColorer)) {
	        desc.colorer = newColorer;
	        target.colorer = lookupAndCreate(colorers, rep.colorer);
	        changed = true;
	        logger.debug('rep[' + index + '].colorer changed to ' + newColorer);
	      }
	    }

	    // modify material
	    if (rep.material) {
	      var newMaterial = rep.material;
	      if (!lodash.isEqual(desc.material, newMaterial)) {
	        desc.material = newMaterial;
	        target.setMaterialPreset(materials.get(rep.material));
	        changed = true;
	        logger.debug('rep[' + index + '].material changed to' + newMaterial);
	      }
	    }

	    // finalize
	    if (changed) {
	      target.needsRebuild = true;
	    }
	  }

	  return desc;
	};

	/**
	 * Get representation (not just description) by index.
	 * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
	 * @returns {?object} Representation.
	 */
	ComplexVisual.prototype.repGet = function (index) {
	  // if index is missing then it is the current
	  if (index === undefined || index instanceof Object) {
	    index = this.repCurrent();
	  }

	  // fail if out of bounds
	  if (index < 0 || index >= this._reprList.length) {
	    return null;
	  }

	  return this._reprList[index];
	};

	ComplexVisual.prototype._getFreeReprIdx = function () {
	  var bits = this._reprUsedBits;
	  for (var i = 0; i <= ComplexVisual.NUM_REPRESENTATION_BITS; ++i, bits >>= 1) {
	    if ((bits & 1) === 0) {
	      return i;
	    }
	  }
	  return -1;
	};

	/**
	 * Add new representation.
	 * @param {object=} rep - Representation description.
	 * @returns {number} Index of the new representation.
	 */
	ComplexVisual.prototype.repAdd = function (rep) {
	  if (this._reprList.length >= ComplexVisual.NUM_REPRESENTATION_BITS) {
	    return -1;
	  }

	  var newSelectionBit = this._getFreeReprIdx();
	  if (newSelectionBit < 0) {
	    return -1; // no more slots for representations
	  }

	  var originalSelection = this.buildSelectorFromMask(1 << this._selectionBit);

	  // Fill in default values
	  var def = settings.now.presets.default[0];
	  var desc = lodash.merge({
	    selector: def.selector,
	    mode: def.mode,
	    colorer: def.colorer,
	    material: def.material
	  }, rep);

	  var selector = typeof desc.selector === 'string' ? selectors$2.parse(desc.selector).selector : desc.selector;
	  var target = new Representation(this._selectionBit, lookupAndCreate(modes, desc.mode), lookupAndCreate(colorers, desc.colorer), selector);
	  target.selectorString = selector.toString();
	  target.setMaterialPreset(materials.get(desc.material));
	  target.markAtoms(this._complex);
	  this._reprList.push(target);

	  // change selection bit
	  this._selectionBit = newSelectionBit;
	  this._reprUsedBits |= 1 << this._selectionBit;

	  // restore selection using new selection bit
	  this._complex.markAtoms(originalSelection, 1 << this._selectionBit);

	  return this._reprList.length - 1;
	};

	/**
	 * Remove representation.
	 * @param {number=} index - Zero-based representation index.
	 */
	ComplexVisual.prototype.repRemove = function (index) {
	  if (index === undefined) {
	    index = this.repCurrent();
	  }

	  // catch out of bounds case
	  var count = this._reprList.length;
	  if (index < 0 || index >= count || count <= 1) {
	    // do not allow to remove the single rep
	    return;
	  }

	  var target = this._reprList[index];
	  target.unmarkAtoms(this._complex);
	  this._reprUsedBits &= ~(1 << target.index);

	  this._reprList.splice(index, 1);

	  // update current rep
	  if (target === this._repr) {
	    --count;
	    index = index < count ? index : count - 1;
	    this._repr = this._reprList[index];
	  }
	  this._reprListChanged = true;
	};

	/**
	 * Hide representation.
	 * @param {number} index - Zero-based representation index.
	 * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
	 */
	ComplexVisual.prototype.repHide = function (index, hide) {
	  if (hide === undefined) {
	    hide = true;
	  }

	  // fail if out of bounds
	  if (index < 0 || index >= this._reprList.length) {
	    return;
	  }

	  var target = this._reprList[index];
	  target.show(!hide);
	};

	/**
	 * Select atoms with selector
	 * @param {Selector} selector - selector
	 * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
	 */
	ComplexVisual.prototype.select = function (selector, append) {
	  if (append) {
	    this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
	  } else {
	    this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
	  }
	  this._complex.updateStructuresMask();
	  this.rebuildSelectionGeometry();
	};

	ComplexVisual.prototype.resetSelectionMask = function () {
	  if (this._selectionCount !== 0) {
	    this._selectionCount = 0;
	    if (this._complex) {
	      this._complex.clearAtomBits(1 << this._selectionBit);
	    }
	  }
	};

	ComplexVisual.prototype.updateSelectionMask = function (pickedObj) {
	  var self = this;
	  var atom = pickedObj.atom;
	  var residue = pickedObj.residue;
	  var chain = pickedObj.chain;
	  var molecule = pickedObj.molecule;
	  var setMask = 1 << this._selectionBit;
	  var clearMask = ~setMask;

	  if (atom) {
	    residue = atom._residue;
	    chain = residue._chain;
	    molecule = residue._molecule;

	    if (atom._mask & setMask) {
	      atom._mask &= clearMask;
	      residue._mask &= clearMask;
	      chain._mask &= clearMask;
	      if (molecule) {
	        molecule._mask &= clearMask;
	      }
	      this._selectionCount--;
	    } else {
	      atom._mask |= setMask;
	      this._selectionCount++;

	      // select residue if all atoms in it are selected
	      residue.collectMask();
	      // select chain and molecule if all residues in it are selected
	      chain.collectMask();
	      if (molecule) {
	        molecule.collectMask();
	      }
	    }
	  } else if (residue) {
	    chain = residue._chain;
	    molecule = residue._molecule;

	    if (residue._mask & setMask) {
	      residue._mask &= clearMask;
	      chain._mask &= clearMask;
	      residue.forEachAtom(function (a) {
	        if (a._mask & setMask) {
	          a._mask &= clearMask;
	          self._selectionCount--;
	        }
	      });
	    } else {
	      residue._mask |= setMask;
	      residue.forEachAtom(function (a) {
	        if (!(a._mask & setMask)) {
	          a._mask |= setMask;
	          self._selectionCount++;
	        }
	      });

	      // select chain and molecule if all residues in it are selected
	      chain.collectMask();
	      if (molecule) {
	        molecule.collectMask();
	      }
	    }
	  } else if (chain || molecule) {
	    var obj = chain || molecule;
	    if (obj._mask & setMask) {
	      obj._mask &= clearMask;
	      obj.forEachResidue(function (r) {
	        if (r._mask & setMask) {
	          r._mask &= clearMask;
	          r.forEachAtom(function (a) {
	            if (a._mask & setMask) {
	              a._mask &= clearMask;
	              self._selectionCount--;
	            }
	          });
	          r._mask &= clearMask;
	        }
	      });
	    } else {
	      obj._mask |= setMask;
	      obj.forEachResidue(function (r) {
	        if (!(r._mask & setMask)) {
	          r._mask |= setMask;
	          r.forEachAtom(function (a) {
	            if (!(a._mask & setMask)) {
	              a._mask |= setMask;
	              self._selectionCount++;
	            }
	          });
	          var otherObj = chain ? r.getMolecule() : r.getChain();
	          if (otherObj) {
	            otherObj.collectMask();
	          }
	        }
	      });
	    }
	  } else {
	    this.resetSelectionMask();
	  }
	};

	ComplexVisual.prototype.expandSelection = function () {
	  var self = this;
	  var selectionMask = 1 << this._selectionBit;
	  var tmpMask = 1 << 31;

	  // mark atoms to add
	  this._complex.forEachBond(function (bond) {
	    if (bond._left._mask & selectionMask) {
	      if ((bond._right._mask & selectionMask) === 0) {
	        bond._right._mask |= tmpMask;
	      }
	    } else if (bond._right._mask & selectionMask) {
	      bond._left._mask |= tmpMask;
	    }
	  });

	  // select marked atoms
	  var deselectionMask = ~tmpMask;
	  this._complex.forEachAtom(function (atom) {
	    if (atom._mask & tmpMask) {
	      atom._mask = atom._mask & deselectionMask | selectionMask;
	      ++self._selectionCount;
	    }
	  });

	  this._complex.updateStructuresMask();
	};

	ComplexVisual.prototype.shrinkSelection = function () {
	  var self = this;
	  var selectionMask = 1 << this._selectionBit;
	  var tmpMask = 1 << 31;

	  // mark atoms neighbouring to unselected ones
	  this._complex.forEachBond(function (bond) {
	    if (bond._left._mask & selectionMask) {
	      if ((bond._right._mask & selectionMask) === 0) {
	        bond._left._mask |= tmpMask;
	      }
	    } else if (bond._right._mask & selectionMask) {
	      bond._right._mask |= tmpMask;
	    }
	  });

	  // mark hanging atoms
	  this._complex.forEachAtom(function (atom) {
	    if (atom._mask & selectionMask && atom._bonds.length === 1) {
	      atom._mask |= tmpMask;
	    }
	  });

	  // deselect marked atoms
	  var deselectionMask = ~(selectionMask | tmpMask);
	  this._complex.forEachAtom(function (atom) {
	    if (atom._mask & tmpMask) {
	      atom._mask &= deselectionMask;
	      --self._selectionCount;
	    }
	  });

	  this._complex.updateStructuresMask();
	};

	ComplexVisual.prototype.getSelectedComponent = function () {

	  var selectionMask = 1 << this._selectionBit;

	  var component = null;
	  var multiple = false;

	  // find which component is selected (exclusively)
	  this._complex.forEachAtom(function (atom) {
	    if (atom._mask & selectionMask) {
	      if (component === null) {
	        component = atom._residue._component;
	      } else if (component !== atom._residue._component) {
	        multiple = true;
	      }
	    }
	  });

	  return multiple ? null : component;
	};

	ComplexVisual.prototype.needsRebuild = function () {
	  if (this._reprListChanged) {
	    return true;
	  }
	  var reprList = this._reprList;
	  for (var i = 0, n = reprList.length; i < n; ++i) {
	    var repr = reprList[i];
	    if (repr.needsRebuild) {
	      return true;
	    }
	  }
	  return false;
	};

	/**
	 * Rebuild molecule geometry asynchronously.
	 */
	ComplexVisual.prototype.rebuild = function () {
	  var self = this;

	  // Destroy current geometry
	  gfxutils.clearTree(this);

	  return new Promise(function (resolve, _reject) {
	    // TODO: `reject` is not used
	    // Nothing to do?
	    var complex = self._complex;
	    if (!complex) {
	      resolve();
	      return;
	    }

	    var errorOccured = false;
	    setTimeout(function _rebuild() {
	      console.time('build');
	      var reprList = self._reprList;
	      var palette = palettes.get(settings.now.palette) || palettes.first;
	      var hasGeometry = false;
	      for (var i = 0, n = reprList.length; i < n; ++i) {
	        var repr = reprList[i];
	        repr.colorer.palette = palette;

	        if (repr.needsRebuild) {
	          repr.reset();

	          try {
	            repr.buildGeometry(complex);
	          } catch (e) {
	            if (e instanceof utils.OutOfMemoryError) {
	              repr.needsRebuild = false;
	              repr.reset();
	              logger.error('Not enough memory to build geometry for representation ' + (repr.index + 1));
	              errorOccured = true;
	            } else {
	              throw e;
	            }
	          }
	        }

	        hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);

	        if (repr.geo) {
	          self.add(repr.geo);
	        }
	      }

	      self._reprListChanged = false;

	      console.timeEnd('build');
	      resolve();
	    }, 10);
	  });
	};

	ComplexVisual.prototype.setNeedsRebuild = function () {
	  // invalidate all representations
	  var reprList = this._reprList;
	  for (var i = 0, n = reprList.length; i < n; ++i) {
	    reprList[i].needsRebuild = true;
	  }
	};

	ComplexVisual.prototype.rebuildSelectionGeometry = function () {
	  var mask = 1 << this._selectionBit;

	  gfxutils.clearTree(this._selectionGeometry);

	  for (var i = 0, n = this._reprList.length; i < n; ++i) {
	    var repr = this._reprList[i];
	    var sg = repr.buildSelectionGeometry(mask);
	    if (!sg) {
	      continue;
	    }

	    this._selectionGeometry.add(sg);
	    for (var j = 0; j < sg.children.length; j++) {
	      var m = sg.children[j];

	      // copy component transform (that's not applied yet)
	      // TODO make this code obsolete, accessing editor is bad
	      if (this._editor && this._editor._componentTransforms) {
	        var t = this._editor._componentTransforms[m._component._index];
	        if (t) {
	          m.position.copy(t.position);
	          m.quaternion.copy(t.quaternion);
	        }
	      }
	    }

	    gfxutils.applySelectionMaterial(sg);
	  }
	};

	ComplexVisual.prototype._buildSelectorFromSortedLists = function (atoms, residues, chains) {
	  var complex = this._complex;

	  function optimizeList(list) {
	    var result = [],
	        k = 0;
	    var first = NaN,
	        last = NaN;
	    for (var i = 0, n = list.length; i < n; ++i) {
	      var value = list[i];
	      if (value === last + 1) {
	        last = value;
	      } else {
	        if (!Number.isNaN(first)) {
	          result[k++] = new selectors$2.Range(first, last);
	        }
	        first = last = value;
	      }
	    }
	    if (!Number.isNaN(first)) {
	      result[k] = new selectors$2.Range(first, last);
	    }
	    return result;
	  }

	  var expression = null;
	  if (chains.length === complex._chains.length) {
	    expression = selectors$2.all();
	  } else {
	    var selector;
	    if (chains.length > 0) {
	      selector = selectors$2.chain(chains);
	      expression = expression ? selectors$2.or(expression, selector) : selector; // NOSONAR
	    }
	    if (Object.keys(residues).length > 0) {
	      for (var ch in residues) {
	        if (residues.hasOwnProperty(ch)) {
	          selector = selectors$2.and(selectors$2.chain(ch), selectors$2.residx(optimizeList(residues[ch])));
	          expression = expression ? selectors$2.or(expression, selector) : selector;
	        }
	      }
	    }
	    if (atoms.length > 0) {
	      selector = selectors$2.serial(optimizeList(atoms));
	      expression = expression ? selectors$2.or(expression, selector) : selector;
	    }

	    if (!expression) {
	      expression = selectors$2.none();
	    }
	  }

	  return expression;
	};

	ComplexVisual.prototype.buildSelectorFromMask = function (mask) {
	  var complex = this._complex;
	  var chains = [];
	  var residues = {};
	  var atoms = [];

	  complex.forEachChain(function (chain) {
	    if (chain._mask & mask) {
	      chains.push(chain._name);
	    }
	  });

	  complex.forEachResidue(function (residue) {
	    if (residue._mask & mask && !(residue._chain._mask & mask)) {
	      var c = residue._chain._name;
	      if (!(c in residues)) {
	        residues[c] = [residue._index];
	      } else {
	        residues[c].push(residue._index);
	      }
	    }
	  });

	  complex.forEachAtom(function (atom) {
	    if (atom._mask & mask && !(atom._residue._mask & mask)) {
	      atoms.push(atom._serial);
	    }
	  });

	  return this._buildSelectorFromSortedLists(atoms, residues, chains);
	};

	ComplexVisual.prototype.getSelectedComponent = function () {

	  var selectionMask = 1 << this._selectionBit;

	  var component = null;
	  var multiple = false;

	  // find which component is selected (exclusively)
	  this._complex.forEachAtom(function (atom) {
	    if (atom._mask & selectionMask) {
	      if (component === null) {
	        component = atom._residue._component;
	      } else if (component !== atom._residue._component) {
	        multiple = true;
	      }
	    }
	  });

	  return multiple ? null : component;
	};

	ComplexVisual.prototype.beginComponentEdit = function () {
	  if (this._editor) {
	    return null;
	  }

	  var editor = new ComplexVisualEdit.ComponentEditor(this);
	  if (!editor.begin()) {
	    return null;
	  }

	  this._editor = editor;
	  return editor;
	};

	ComplexVisual.prototype.beginFragmentEdit = function () {
	  if (this._editor) {
	    return null;
	  }

	  var editor = new ComplexVisualEdit.FragmentEditor(this);
	  if (!editor.begin()) {
	    return null;
	  }

	  this._editor = editor;
	  return editor;
	};

	// should only be called by editors
	ComplexVisual.prototype.finalizeEdit = function () {
	  this._editor = null;
	};

	ComplexVisual.prototype.setMaterialValues = function (values) {
	  for (var i = 0, n = this._reprList.length; i < n; ++i) {
	    var rep = this._reprList[i];
	    rep.material.setValues(values);
	  }
	};

	ComplexVisual.prototype.setUberOptions = function (values) {
	  for (var i = 0, n = this._reprList.length; i < n; ++i) {
	    var rep = this._reprList[i];
	    rep.material.setUberOptions(values);
	  }
	};

	/**
	 * Build selector that contains all atoms within given distance from group of atoms
	 * @param {Selector} selector - selector describing source group of atoms
	 * @param {number} radius - distance
	 * @returns {Selector} selector describing result group of atoms
	 */
	ComplexVisual.prototype.within = function (selector, radius) {
	  var vw = this._complex.getVoxelWorld();
	  if (vw === null) {
	    return false;
	  }

	  // mark atoms of the group as selected
	  var selectionMask = 1 << this._selectionBit;
	  this._complex.markAtoms(selector, selectionMask);

	  // mark all atoms within distance as selected
	  if (vw) {
	    vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), function (atom) {
	      atom._mask |= selectionMask;
	    });
	  }

	  // update selection count
	  this._selectionCount = this._complex.countAtomsByMask(selectionMask);

	  // update secondary structure mask
	  this._complex.updateStructuresMask();

	  return this.buildSelectorFromMask(selectionMask);
	};

	var volumeFrag = "uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform float _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\nvec4 sample3DTexture(vec3 texCoord)\r\n{\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir)\r\n{\r\n  float d = 1.0 / 128.0;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n  vec3 N;\r\n  N.x = sample3DTexture(iter + dx).r - sample3DTexture(iter - dx).r;\r\n  N.y = sample3DTexture(iter + dy).r - sample3DTexture(iter - dy).r;\r\n  N.z = sample3DTexture(iter + dz).r - sample3DTexture(iter - dz).r;\r\n  N = normalize(N);\r\n  float dif = max(0.0, dot(N,dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold)\r\n{\r\n  for (int i = 0; i < 5; i++)\r\n  {\r\n    vec3 iterator = 0.5*(left + right);\r\n    float vol = sample3DTexture(iterator).r;\r\n    if ((volLeft - threshold)*(vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5*(left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count)\r\n{\r\n  float vol, stepSize = (0.5*float(count) + 1.) / 85.;\r\n  //    \t\tfloat vol, stepSize = (0.5*count + 1.) / 64.;// 128.;\r\n  vec3 step = stepSize*dir, iterator = start, left, right;\r\n  vec4 acc = vec4(0., 0., 0., 0.);\r\n    for (int i=0; i < 200; i++)\r\n    {\r\n      iterator = iterator + step;\r\n      vol = sample3DTexture(iterator).r;\r\n      if (length(iterator - back) < stepSize || vol > tr)\r\n        break;\r\n    }\r\n    if (vol > tr)\r\n    {\r\n      left = iterator - step;\r\n      right = iterator;\r\n      for (int j = 0; j < 5; j++)\r\n      {\r\n        iterator = 0.5*(left + right);\r\n        float vol = sample3DTexture(iterator).r;\r\n        if (vol > tr)\r\n          right = iterator;\r\n        else\r\n          left = iterator;\r\n      }\r\n      acc = vec4(0.5*(left + right), 1.);\r\n    }\r\n\r\n  return acc;\r\n}\r\n\r\nvec3 GetCol(float vol, vec3 ad)\r\n{\r\n  vec3 col;\r\n  float a = 0.36, b = 0.44;\r\n  if (vol < a)\r\n    col = mix(vec3(0., 0., 1.), vec3(0., 1., 0.), max(0., (vol - _isoLevel0)*ad.r));// / (a - IsoLevel0)));\r\n  if (vol > a && vol < b)\r\n    col = mix(vec3(0., 1., 0.), vec3(0.5, 0.5, 0.), (vol - a)*ad.b); // / (b - a));\r\n  if (vol > b)\r\n    col = mix(vec3(0.5, 0.5, 0.), vec3(1., 0., 0.), (vol - b)*ad.g); // / (0.52 - b));\r\n  return col;\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr)\r\n{\r\n  for (int j = 0; j < 5; j++)\r\n  {\r\n    vec3 iterator = 0.5*(left + right);\r\n    float vol = sample3DTexture(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5*(left + right);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir)\r\n{\r\n  vec4 acc = vec4(0., 0., 0., 0.), iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  //\t\t\t\tfloat stepSize = 1. / 110., alpha, sumAlpha = 0, vol, curStepSize = stepSize, molD;\r\n  float stepSize = 1. / 170., alpha, sumAlpha = 0.0, vol, curStepSize = stepSize, molD;\r\n  vec3 step = stepSize*dir, col, colOld, right;\r\n  float tr0 = _isoLevel0;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n  float a = 0.36, b = 0.44;\r\n  vec3 ad = vec3(1. / (a - _isoLevel0), 1. / (b - a), 1. / (0.52 - b));\r\n  kd = 140.*tr0*stepSize;\r\n  r = 1. - kd;\r\n\r\n  for (int k = 0; k < 3; k++)\r\n  {\r\n    stepSize = (0.5*float(k) + 1.) / 85.;\r\n    kd = 140.*tr0*stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize*dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.rgb - start) > molDist)\r\n      break;\r\n    iterator = iso.rgb;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetCol(tr0, ad);\r\n    curStepSize = stepSize;\r\n    for (int i=0; i < 200; i++)\r\n    {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTexture(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetCol(vol, ad);\r\n      vol = sample3DTexture(iterator - 0.5*step).r;\r\n      vec3 colMid = GetCol(vol, ad);\r\n      sumColor += (1. - sumAlpha)*(colOld + 4.*colMid + col)*alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha)*alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n    if (molD > molDist)\r\n    {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist)*dir;\r\n      vol = sample3DTexture(right).r;\r\n    }\r\n    else\r\n    {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n    alpha = (1. - r)*curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetCol(vol, ad);\r\n    vol = sample3DTexture(iterator - 0.5*curStepSize / stepSize*step).r;\r\n    vec3 colMid = GetCol(vol, ad);\r\n    sumColor += (1. - sumAlpha)*(colOld + 4.*colMid + col)*alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha)*alpha;// *(1. - 1.0*dif*dif);\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1.*sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir)\r\n{\r\n  float stepSize = 1.0 / 200.0;\r\n  float len = length(back - start);\r\n  vec3 step = stepSize*dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i=0; i < 200; i++)\r\n  {\r\n    if (float(i) * stepSize > len) break;\r\n    iterator = iterator + step;\r\n    acc += sample3DTexture(iterator).r / 200.0;\r\n  }\r\n\r\n  return vec4(1,1,1, acc);\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir)\r\n{\r\n  vec4 tst = GetIso1(start, back, 2., dir, 0.28, 0);\r\n  vec4 col = vec4(0, 0., 0., 0.);\r\n  if (tst.a > 0.1)\r\n  {\r\n   float dif = CalcColor(tst.rgb, dir);\r\n   col = vec4(dif, 0., 0., 1.);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender3(vec3 start, vec3 back, float molDist, vec3 dir)\r\n{\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main()\r\n{\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0)\r\n  {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  }\r\n  else\r\n  {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001)\r\n  {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  //gl_FragColor = texture2D(_WFFLeft, tc.xy);\r\n  //gl_FragColor = texture2D(tileTex, tc.xy);\r\n  gl_FragColor = VolRender(start, back, molDist, dir);\r\n}\r\n";

	var volumeUniforms = UniformsUtils.merge([{
	  volumeDim: { type: 'v3', value: new Vector3(512, 512, 512) },
	  tileTex: { type: 't', value: null },
	  tileTexSize: { type: 'v2', value: new Vector2(512, 512) },
	  tileStride: { type: 'v2', value: new Vector2(512, 512) },

	  _isoLevel0: { type: 'f', value: 0.28 },
	  _flipV: { type: 'f', value: 0.0 },
	  _BFLeft: { type: 't', value: null },
	  _BFRight: { type: 't', value: null },
	  _FFLeft: { type: 't', value: null },
	  _FFRight: { type: 't', value: null },
	  _WFFLeft: { type: 't', value: null },
	  _WFFRight: { type: 't', value: null }
	}]);

	function overrideUniforms(params, defUniforms) {
	  var uniforms = UniformsUtils.clone(defUniforms);
	  for (var p in params) {
	    if (uniforms.hasOwnProperty(p)) {
	      uniforms[p].value = params[p];
	    }
	  }
	  return uniforms;
	}

	function BackFacePosMaterial(params) {
	  var settings = {
	    uniforms: overrideUniforms(params, {}),
	    vertexShader: 'varying vec3 pos; ' + 'void main() {' +
	    // we're assuming local position is in [-0.5, 0.5]
	    // we need to offset it to be represented in RGB
	    'pos = position.xyz + 0.5;' + 'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);' + '}',
	    fragmentShader: 'varying vec3 pos; ' + 'void main() { gl_FragColor = vec4(pos, 0.5); }',
	    transparent: false,
	    depthTest: false,
	    depthWrite: false,
	    side: BackSide
	  };
	  return new ShaderMaterial(settings);
	}

	function BackFacePosMaterialFarPlane(params) {
	  var matUniforms = UniformsUtils.merge([{
	    aspectRatio: { type: 'f', value: 0.0 },
	    farZ: { type: 'f', value: 0.0 },
	    tanHalfFOV: { type: 'f', value: 0.0 },
	    matWorld2Volume: { type: '4fv', value: new Matrix4() }
	  }]);

	  var settings = {
	    uniforms: overrideUniforms(params, matUniforms),
	    vertexShader: 'varying vec4 volPos;\n' + 'uniform float aspectRatio;\n' + 'uniform float farZ;\n' + 'uniform float tanHalfFOV;\n' + 'uniform mat4  matWorld2Volume\n;' + 'void main() {\n' +
	    // rescale plane to fill in the whole far plane area seen from camera
	    'vec3 pos = position.xyz;\n' + 'pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\n' + 'pos.y = pos.y * tanHalfFOV * farZ;\n' +
	    // common transformation
	    'gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n' +
	    // calc pos in volume CS
	    'volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\n' +
	    // we're assuming local position is in [-0.5, 0.5]
	    // we need to offset it to be represented in RGB
	    'volPos = volPos + 0.5;\n' + 'volPos.w = 0.5;' + '}',
	    fragmentShader: 'varying vec4 volPos; \n' + 'void main() { gl_FragColor = volPos; }',
	    transparent: false,
	    depthTest: false,
	    depthWrite: false,
	    side: FrontSide
	  };
	  return new ShaderMaterial(settings);
	}

	function FrontFacePosMaterial(params) {
	  var settings = {
	    uniforms: overrideUniforms(params, {}),
	    vertexShader: 'varying vec3 pos; ' + 'void main() {' +
	    // we're assuming local position is in [-0.5, 0.5]
	    // we need to offset it to be represented in RGB
	    'pos = position.xyz + 0.5;' + 'gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);' + '}',
	    fragmentShader: 'varying vec3 pos; ' + 'void main() { gl_FragColor = vec4(pos, 0.5); }',
	    transparent: false,
	    depthTest: false,
	    depthWrite: false,
	    side: FrontSide
	  };
	  return new ShaderMaterial(settings);
	}

	function VolumeMaterial(params) {
	  var settings = {
	    uniforms: overrideUniforms(params, volumeUniforms),
	    vertexShader: 'varying vec4 screenSpacePos; ' + 'void main() {' + 'screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);' + 'gl_Position = screenSpacePos;' + '}',
	    fragmentShader: volumeFrag,
	    transparent: true,
	    depthTest: true,
	    depthWrite: false,
	    side: FrontSide
	  };
	  return new ShaderMaterial(settings);
	}

	var VolumeMaterial$1 = {
	  BackFacePosMaterial: BackFacePosMaterial,
	  BackFacePosMaterialFarPlane: BackFacePosMaterialFarPlane,
	  FrontFacePosMaterial: FrontFacePosMaterial,
	  VolumeMaterial: VolumeMaterial
	};

	function VolumeMesh() {
	  this.clipPlane = new Plane();
	  var size = new Vector3(0.5, 0.5, 0.5);
	  this.size = size;

	  this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];

	  this.faces = [{ indices: [], norm: new Vector3(0, 0, -1) }, { indices: [], norm: new Vector3(0, 0, 1) }, { indices: [], norm: new Vector3(0, -1, 0) }, { indices: [], norm: new Vector3(0, 1, 0) }, { indices: [], norm: new Vector3(-1, 0, 0) }, { indices: [], norm: new Vector3(1, 0, 0) }, { indices: [], norm: new Vector3(0, 0, 0) }];

	  this.vertices = [new Vector3(-size.x, -size.y, -size.z), new Vector3(-size.x, size.y, -size.z), new Vector3(size.x, -size.y, -size.z), new Vector3(size.x, size.y, -size.z), new Vector3(-size.x, -size.y, size.z), new Vector3(-size.x, size.y, size.z), new Vector3(size.x, -size.y, size.z), new Vector3(size.x, size.y, size.z), new Vector3(0.0, 0.0, 0.0), // Placeholder for section
	  new Vector3(0.0, 0.0, 0.0), new Vector3(0.0, 0.0, 0.0), new Vector3(0.0, 0.0, 0.0), new Vector3(0.0, 0.0, 0.0), new Vector3(0.0, 0.0, 0.0)];

	  var geo = new BufferGeometry();
	  geo.addAttribute('position', new BufferAttribute(new Float32Array(this.vertices.length * 3), 3));

	  Mesh.call(this, geo);
	  this.name = 'VolumeMesh';
	}

	utils.deriveClass(VolumeMesh, Mesh);

	VolumeMesh.prototype._updateVertices = function () {
	  var corners = [
	  // x, y, z, edge1, edge2, edge3
	  [-1, -1, -1, 0, 4, 8], [1, -1, -1, 0, 5, 9], [1, 1, -1, 1, 5, 10], [-1, 1, -1, 1, 4, 11], [-1, -1, 1, 2, 6, 8], [1, -1, 1, 2, 7, 9], [1, 1, 1, 3, 7, 10], [-1, 1, 1, 3, 6, 11]];

	  var edges = [
	  // corner1, corner2, center_x, center_y, center_z
	  [0, 1, 0, -1, -1], [2, 3, 0, 1, -1], [4, 5, 0, -1, 1], [6, 7, 0, 1, 1], [0, 3, -1, 0, -1], [1, 2, 1, 0, -1], [4, 7, -1, 0, 1], [5, 6, 1, 0, 1], [0, 4, -1, -1, 0], [1, 5, 1, -1, 0], [2, 6, -1, 1, 0], [3, 7, 1, 1, 0]];

	  var edgeIntersections = [];
	  for (var j = 0; j < 12; ++j) {
	    edgeIntersections.push(new Vector3());
	  }

	  return function () {
	    // Algorithm:
	    // 1. Get plane parameters
	    // 2. Compute culling flags for all vertices
	    // 3. If intersection occurs => compute from 3 to 6 intersection points

	    var i;

	    var norm = this.clipPlane.normal;
	    var D = this.clipPlane.constant;

	    var vert = this.vertices;
	    var size = this.size;

	    var cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
	    var edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];

	    var curEdge = new Vector3();
	    var curEdgeInter = null;

	    function CheckX() {
	      if (norm.x === 0) return 0;
	      var x = -(norm.dot(curEdge) + D) / norm.x;
	      if (-size.x <= x && x <= size.x) {
	        curEdgeInter.set(x, curEdge.y, curEdge.z);
	        if (x === size.x) return 2;
	        if (x === -size.x) return -2;
	        return 1;
	      }
	      return 0;
	    }

	    function CheckY() {
	      if (norm.y === 0) return 0;
	      var y = -(norm.dot(curEdge) + D) / norm.y;
	      if (-size.y <= y && y <= size.y) {
	        curEdgeInter.set(curEdge.x, y, curEdge.z);
	        if (y === size.y) return 2;
	        if (y === -size.y) return -2;
	        return 1;
	      }
	      return 0;
	    }

	    function CheckZ() {
	      if (norm.z === 0) return 0;
	      var z = -(norm.dot(curEdge) + D) / norm.z;
	      if (-size.z <= z && z <= size.z) {
	        curEdgeInter.set(curEdge.x, curEdge.y, z);
	        if (z === size.z) return 2;
	        if (z === -size.z) return -2;
	        return 1;
	      }
	      return 0;
	    }

	    // for each edge
	    for (var curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
	      var curEdgeSource = edges[curEdgeIdx];
	      curEdgeInter = edgeIntersections[curEdgeIdx];

	      curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
	      curEdge.multiply(size);

	      // calculate intersection point
	      var flag = 0;
	      if (curEdgeSource[2] === 0) flag = CheckX();
	      if (curEdgeSource[3] === 0) flag = CheckY();
	      if (curEdgeSource[4] === 0) flag = CheckZ();

	      // mark corresponding corner (if plane cuts through one)
	      if (flag === -2) {
	        cornerMark[curEdgeSource[0]] = 1;
	      } else if (flag === 2) {
	        cornerMark[curEdgeSource[1]] = 1;
	      } else if (flag === 0) {
	        // edge is not intersected by the plane (doesn't produce a vertex)
	        edgeMark[curEdgeIdx] = 0;
	      }
	    }

	    var face = {
	      indices: [],
	      norm: norm.clone().negate()
	    };

	    var nextVertex = 8;

	    // for each marked corner
	    for (i = 0; i < 8; ++i) {
	      if (cornerMark[i] === 1) {
	        // add corner as vertex to the face
	        vert[nextVertex].set(corners[i][0], corners[i][1], corners[i][2]).multiply(size);
	        face.indices.push(nextVertex++);
	        // skip adjacent edges
	        edgeMark[corners[i][3]] = 0;
	        edgeMark[corners[i][4]] = 0;
	        edgeMark[corners[i][5]] = 0;
	      }
	    }

	    // for each edge that has internal intersection
	    for (i = 0; i < 12; ++i) {
	      if (edgeMark[i] === 1) {
	        // add intersection point as vertex to the face
	        vert[nextVertex].copy(edgeIntersections[i]);
	        face.indices.push(nextVertex++);
	      }
	    }

	    this.faces[6] = face;

	    var diff = new Vector3();
	    var coplanarPoint = new Vector3();
	    this.clipPlane.coplanarPoint(coplanarPoint);
	    for (i = 0; i < vert.length; ++i) {
	      this.cullFlag[i] = false;
	      if (i < 8) {
	        // corners should be culled by clipping plane
	        diff.subVectors(vert[i], coplanarPoint);
	        this.cullFlag[i] = norm.dot(diff) >= 0.0;
	      } else if (i < 8 + face.indices.length) {
	        // cross section vertices don't get culled
	        this.cullFlag[i] = true;
	      }
	    }

	    // write data to vertex buffer
	    var positions = this.geometry.getAttribute('position');
	    var idx = 0;
	    for (i = 0; i < vert.length; ++i) {
	      positions.array[idx++] = vert[i].x;
	      positions.array[idx++] = vert[i].y;
	      positions.array[idx++] = vert[i].z;
	    }
	    positions.needsUpdate = true;
	  };
	}();

	VolumeMesh.prototype._collectVertices = function (face, filter) {
	  var i;
	  var vert = this.vertices;
	  face.indices = [];
	  for (i = 0; i < vert.length; ++i) {
	    if (this.cullFlag[i] && filter(vert[i])) {
	      face.indices.push(i);
	    }
	  }
	};

	VolumeMesh.prototype._sortIndices = function (face, right) {
	  var i, j;
	  var vert = this.vertices;
	  var angle = [];

	  var dir = new Vector3();
	  for (i = 1; i < face.indices.length; ++i) {
	    dir.subVectors(vert[face.indices[i]], vert[face.indices[0]]);
	    dir.normalize();
	    dir.cross(right);
	    dir.negate();
	    angle[i] = face.norm.dot(dir);
	  }

	  // Exchange sort
	  for (i = 1; i < face.indices.length - 1; ++i) {
	    for (j = i + 1; j < face.indices.length; ++j) {
	      if (angle[j] < angle[i]) {
	        // swap
	        var t = angle[i];
	        angle[i] = angle[j];
	        angle[j] = t;

	        t = face.indices[i];
	        face.indices[i] = face.indices[j];
	        face.indices[j] = t;
	      }
	    }
	  }
	};

	VolumeMesh.prototype._updateIndices = function () {
	  // Algorithm:
	  // 1. Get plane vertices (from 3 to 6 vertices)
	  // 2. Get "right" vector in plane
	  // 3. Sort vertices using Graham-like method
	  // 4. Create indices

	  var i, faceIdx, face;
	  var vert = this.vertices;
	  var size = this.size;

	  this._collectVertices(this.faces[0], function (vertex) {
	    return vertex.z === -size.z;
	  });
	  this._collectVertices(this.faces[1], function (vertex) {
	    return vertex.z === size.z;
	  });
	  this._collectVertices(this.faces[2], function (vertex) {
	    return vertex.y === -size.y;
	  });
	  this._collectVertices(this.faces[3], function (vertex) {
	    return vertex.y === size.y;
	  });
	  this._collectVertices(this.faces[4], function (vertex) {
	    return vertex.x === -size.x;
	  });
	  this._collectVertices(this.faces[5], function (vertex) {
	    return vertex.x === size.x;
	  });

	  var vCenter = new Vector3();
	  var vRight = new Vector3();
	  var vDir = new Vector3();

	  for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
	    face = this.faces[faceIdx];

	    if (face.indices.length === 0) continue;

	    vCenter.set(0, 0, 0);
	    for (i = 0; i < face.indices.length; ++i) {
	      vCenter.add(vert[face.indices[i]]);
	    }
	    vCenter.multiplyScalar(1.0 / face.indices.length);
	    vRight.subVectors(vert[face.indices[0]], vCenter);
	    vRight.normalize();

	    var rightProj = [];
	    for (i = 0; i < face.indices.length; ++i) {
	      vDir.subVectors(vert[face.indices[i]], vCenter);
	      rightProj[i] = vDir.dot(vRight);
	    }
	    for (i = 1; i < face.indices.length; ++i) {
	      if (rightProj[i] < rightProj[0]) {
	        // swap
	        var t = rightProj[0];
	        rightProj[0] = rightProj[i];
	        rightProj[i] = t;

	        t = face.indices[0];
	        face.indices[0] = face.indices[i];
	        face.indices[i] = t;
	      }
	    }

	    this._sortIndices(face, vRight);
	  }

	  var numIndices = 0;
	  for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
	    face = this.faces[faceIdx];
	    if (face.indices.length >= 3) {
	      numIndices += 3 * (face.indices.length - 2);
	    }
	  }
	  var offset = 0;
	  var indices = new Uint16Array(numIndices);
	  for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
	    face = this.faces[faceIdx];
	    for (i = 0; i < face.indices.length - 2; ++i) {
	      indices[offset + 0] = face.indices[0];
	      indices[offset + 1] = face.indices[i + 1];
	      indices[offset + 2] = face.indices[i + 2];
	      offset += 3;
	    }
	  }

	  this.geometry.setIndex(new BufferAttribute(indices, 1));
	};

	VolumeMesh.prototype.setDataSource = function (dataSource) {
	  var vm = new VolumeMaterial$1.VolumeMaterial();
	  var dim = dataSource.getDimensions();
	  var stride = dataSource.getTiledTextureStride();
	  var texture = dataSource.buildTiledTexture();
	  vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
	  vm.uniforms.tileTex.value = texture;
	  vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
	  vm.uniforms.tileStride.value.set(stride[0], stride[1]);
	  this.material = vm;

	  var bbox = dataSource.getBox();
	  bbox.getSize(this.scale);
	  bbox.getCenter(this.position);
	};

	VolumeMesh.prototype.rebuild = function () {

	  var nearClipPlaneOffset = 0.2;
	  var pos = new Vector3();
	  var norm = new Vector3();
	  var norm4D = new Vector4();
	  var matrixWorldToLocal = new Matrix4();
	  var clipPlane = new Plane();

	  return function (camera) {

	    // get clip plane in local space
	    camera.getWorldDirection(norm);
	    camera.getWorldPosition(pos);
	    pos.addScaledVector(norm, camera.near + nearClipPlaneOffset);

	    // transform pos to local CS
	    matrixWorldToLocal.getInverse(this.matrixWorld);
	    pos.applyMatrix4(matrixWorldToLocal);

	    // transform norm to local CS
	    norm4D.set(norm.x, norm.y, norm.z, 0.0); // NOTE: use homogeneous norm for proper transformation
	    norm4D.applyMatrix4(matrixWorldToLocal);
	    norm.copy(norm4D);
	    norm.normalize();

	    clipPlane.setFromNormalAndCoplanarPoint(norm, pos);

	    if (!this.clipPlane.equals(clipPlane)) {
	      this.clipPlane = clipPlane.clone();
	      this._updateVertices();
	      this._updateIndices();
	    }
	  };
	}();

	function VolumeVisual(name, dataSource) {
	  Visual.call(this, name, dataSource);

	  this._mesh = new VolumeMesh();
	  this._mesh.setDataSource(dataSource);
	  this.add(this._mesh);

	  this.buildFarPlane();
	}

	utils.deriveClass(VolumeVisual, Visual);

	// Thes geometric far plane is required for correct filling in the BFTexture in case, when far plane cuts the volume
	// cube. In cut place of cube there is no correct data in BFTexture and volume rendering integral is calculated
	// with errors.
	// Far plane cuts the cube in case of large volume scale (zoom), because farplane doesn't change
	VolumeVisual.prototype.buildFarPlane = function () {
	  // create plane with unit corners coords (for future rescale in vshader according to camera properties)
	  var planeGeo = new PlaneGeometry(2, 2, 1, 1); // FIXME create custom plane geometry (without normals and uvs)
	  var mat = VolumeMaterial$1.BackFacePosMaterialFarPlane();
	  this._plane = new meshes.Mesh(planeGeo, mat);
	  this._plane.frustumCulled = false;
	  this._plane.doubleSided = true;
	  var matWorldToVolume = new Matrix4();

	  this._plane._onBeforeRender = function (_renderer, _scene, camera, _geometry, _material, _group) {
	    var volume = this.parent.getObjectByName('VolumeMesh');
	    var material = this.material;
	    if (!volume || !material) {
	      return;
	    }

	    // count point in world at farplane place
	    var planeCamPos = new Vector4(0, 0, -(camera.far - 0.1), 1);
	    planeCamPos.applyMatrix4(camera.matrixWorld);

	    // recalc matrices to make plane be placed as farplane in the World relative to camera
	    this.matrix.identity();
	    this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
	    this.matrixWorld.copy(this.matrix);
	    this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
	    this.normalMatrix.getNormalMatrix(this.modelViewMatrix);

	    // build worldToVolume matrix to transform plane into volumeCS (volumeCS coords are written to BackFaceTexture)
	    var volumeMatrix = this.parent.getObjectByName('VolumeMesh').matrixWorld;
	    matWorldToVolume.getInverse(volumeMatrix);

	    // update material props
	    material.uniforms.aspectRatio.value = camera.aspect;
	    material.uniforms.farZ.value = camera.far;
	    material.uniforms.tanHalfFOV.value = Math.tan(_Math.DEG2RAD * 0.5 * camera.fov);
	    material.uniforms.matWorld2Volume.value = matWorldToVolume;
	  };
	  this.add(this._plane);

	  // set it to special layer to draw only into BFTexture
	  this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
	};

	VolumeVisual.prototype.getBoundaries = function () {
	  var box = this._dataSource.getBox();

	  return {
	    boundingBox: box,
	    boundingSphere: box.getBoundingSphere()
	  };
	};

	VolumeVisual.prototype.getMesh = function () {
	  return this._mesh;
	};

	function Profiler() {
	  // bind method to get current time
	  this.now = utils.Timer.now;

	  this._startTime = 0;
	  this._times = [];
	}

	Profiler.prototype.start = function () {
	  this._startTime = this.now();
	};

	Profiler.prototype.end = function () {
	  if (this._startTime !== 0) {
	    this._times.push(this.now() - this._startTime);
	  }
	};

	Profiler.prototype.rawMean = function () {
	  var n = this._times.length;
	  var mean = 0;
	  for (var i = 0; i < n; ++i) {
	    mean += this._times[i];
	  }
	  return mean / n;
	};

	Profiler.prototype.mean = function () {
	  return this._robustMean(this._times);
	};

	Profiler.prototype.deviation = function (mean) {
	  return this._robustDeviation(this._times, mean);
	};

	Profiler.prototype.min = function () {
	  return this._robustMin(this._times);
	};

	Profiler.prototype._robustMean = function (values) {
	  var first = Math.round(values.length * 0.1);
	  var n = values.length - Math.round(values.length * 0.2);
	  values.sort(function (a, b) {
	    return a - b;
	  });
	  var mean = 0;
	  for (var i = first; i < n; ++i) {
	    mean += values[i];
	  }
	  return mean / n;
	};

	Profiler.prototype._robustDeviation = function (values, mean) {
	  var n = values.length;
	  var deltas = new Array(n);
	  for (var i = 0; i < n; ++i) {
	    deltas[i] = (values[i] - mean) * (values[i] - mean);
	  }
	  deltas.sort(function (a, b) {
	    return a - b;
	  });
	  return Math.sqrt(this._robustMean(deltas));
	};

	Profiler.prototype._robustMin = function (values) {
	  var first = Math.round(values.length * 0.05);
	  var n = Math.round(values.length * 0.1);
	  values.sort(function (a, b) {
	    return a - b;
	  });
	  var mean = 0;
	  for (var i = 0; i < n; ++i) {
	    mean += values[first + i];
	  }
	  return mean / n;
	};

	function GfxProfiler(renderer) {
	  this._renderer = renderer;
	  this._prepareTest();
	}

	GfxProfiler.prototype._prepareTest = function () {

	  this._scene = new Scene();

	  var geo = new PlaneGeometry(10, 10, 128, 128);
	  var mat = new MeshBasicMaterial({ color: this._renderer.getClearColor() });

	  for (var j = 0; j < 300; ++j) {
	    var plane = new Mesh(geo, mat);
	    this._scene.add(plane);
	  }

	  this._camera = new PerspectiveCamera(45, 1, 1, 2000);
	  this._camera.position.z = 30;

	  this._prof = new Profiler();
	};

	GfxProfiler.prototype.run = function () {

	  for (var i = 0; i < 100; ++i) {
	    this._prof.start();
	    this._renderer.render(this._scene, this._camera, this._target);
	    this._prof.end();
	  }
	};

	GfxProfiler.prototype.runOnTicks = function (maxResults, skipMs, timeLimitMs) {

	  var self = this;

	  if (typeof maxResults === 'undefined') {
	    maxResults = 50;
	  }

	  if (typeof skipMs === 'undefined') {
	    skipMs = 1000.0;
	  }

	  if (typeof timeLimitMs === 'undefined') {
	    timeLimitMs = 10000.0;
	  }

	  var count = -1;
	  var startTime = this._prof.now();

	  return new Promise(function (resolve) {

	    function onTick() {

	      self._renderer.render(self._scene, self._camera);

	      var elapsedMs = self._prof.now() - startTime;

	      // we're skipping some frames to get more stable FPS
	      if (elapsedMs > skipMs) {
	        self._prof.end();
	        self._prof.start();
	        ++count;
	      }

	      if (elapsedMs > timeLimitMs || count === maxResults) {
	        resolve(Math.max(count, 0));
	      } else {
	        requestAnimationFrame(onTick);
	      }
	    }

	    requestAnimationFrame(onTick);
	  });
	};

	GfxProfiler.prototype.mean = function () {
	  return this._prof ? this._prof.rawMean() : 0.0;
	};

	GfxProfiler.prototype.min = function () {
	  return this._prof ? this._prof.min() : 0.0;
	};

	/**
	 * A list of available loaders.
	 * @extends EntityList
	 */

	var LoaderList = function (_EntityList) {
	  inherits(LoaderList, _EntityList);

	  /**
	   * Create a list of loaders.
	   * The loaders are indexed by supported source types (`.types` property of a Loader
	   * subclass).
	   * The loaders can be retrieved later by matching against specs (see {@link LoaderList#find}).
	   *
	   * @param {!Array<function(new:Loader)>=} someLoaders A list of {@link Loader} subclasses to
	   *   automatically register at creation time.
	   * @see LoaderList#register
	   */
	  function LoaderList() {
	    var someLoaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    classCallCheck(this, LoaderList);
	    return possibleConstructorReturn(this, (LoaderList.__proto__ || Object.getPrototypeOf(LoaderList)).call(this, someLoaders, ['types']));
	  }

	  /**
	   * Find a suitable loader for a source type.
	   *
	   * @param {Object} specs Loader specifications.
	   * @param {string=} specs.type Supported source type.
	   * @param {*=} specs.source Source to load from.
	   */


	  createClass(LoaderList, [{
	    key: 'find',
	    value: function find(specs) {
	      var list = [];
	      if (specs.type) {
	        list = this._dict.types[specs.type.toLowerCase()] || [];
	      } else if (specs.source) {
	        return this._list.filter(function (SomeLoader) {
	          return SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source);
	        });
	      }
	      return [].concat(toConsumableArray(list));
	    }
	  }]);
	  return LoaderList;
	}(EntityList);

	var Loader$1 = function (_EventDispatcher) {
	  inherits(Loader, _EventDispatcher);

	  function Loader(source, options) {
	    classCallCheck(this, Loader);

	    var _this = possibleConstructorReturn(this, (Loader.__proto__ || Object.getPrototypeOf(Loader)).call(this));

	    _this._source = source;
	    _this._options = options || {};
	    _this._abort = false;
	    _this._agent = null;
	    return _this;
	  }

	  createClass(Loader, [{
	    key: 'load',
	    value: function load( /** @deprecated */callbacks) {
	      if (callbacks) {
	        return this._loadOLD(callbacks);
	      }
	      if (this._abort) {
	        return Promise.reject(new Error('Loading aborted'));
	      }
	      return this.loadAsync();
	    }

	    /** @deprecated Rename to `load` when transition from callbacks to promises is done */

	  }, {
	    key: 'loadAsync',
	    value: function loadAsync() {
	      return Promise.reject(new Error('Loading from this source is not implemented'));
	    }

	    /** @deprecated */

	  }, {
	    key: '_loadOLD',
	    value: function _loadOLD(callbacks) {
	      if (callbacks.progress) {
	        this.addEventListener('progress', function (event) {
	          if (event.lengthComputable && event.total > 0) {
	            callbacks.progress(event.loaded / event.total);
	          } else {
	            callbacks.progress();
	          }
	        });
	      }
	      return this.load().then(function (result) {
	        callbacks.ready(result);
	      }).catch(function (error) {
	        callbacks.error(error);
	      });
	    }
	  }, {
	    key: 'abort',
	    value: function abort() {
	      this._abort = true;
	      if (this._agent) {
	        this._agent.abort();
	      }
	    }
	  }], [{
	    key: 'extractName',
	    value: function extractName(_source) {
	      return undefined;
	    }
	  }]);
	  return Loader;
	}(EventDispatcher$1);


	makeContextDependent(Loader$1.prototype);

	var FileLoader$1 = function (_Loader) {
	  inherits(FileLoader, _Loader);

	  function FileLoader(source, options) {
	    classCallCheck(this, FileLoader);

	    var _this = possibleConstructorReturn(this, (FileLoader.__proto__ || Object.getPrototypeOf(FileLoader)).call(this, source, options));

	    options = _this._options;
	    _this._binary = options.binary === true;
	    return _this;
	  }

	  createClass(FileLoader, [{
	    key: 'loadAsync',
	    value: function loadAsync() {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        var blob = _this2._source;
	        var reader = _this2._agent = new FileReader();

	        reader.addEventListener('load', function () {
	          resolve(reader.result);
	        });
	        reader.addEventListener('error', function () {
	          reject(reader.error);
	        });
	        reader.addEventListener('abort', function () {
	          reject(new Error('Loading aborted'));
	        });
	        reader.addEventListener('progress', function (event) {
	          _this2.dispatchEvent(event);
	        });

	        if (_this2._binary) {
	          reader.readAsArrayBuffer(blob);
	        } else {
	          reader.readAsText(blob);
	        }
	      });
	    }

	    /** @deprecated */

	  }], [{
	    key: 'canLoad',
	    value: function canLoad(source, options) {
	      var sourceType = options.sourceType;
	      return source instanceof File && (!sourceType || sourceType === 'file');
	    }
	  }, {
	    key: 'canProbablyLoad',
	    value: function canProbablyLoad(source) {
	      return File && source instanceof File || Blob && source instanceof Blob;
	    }
	  }, {
	    key: 'extractName',
	    value: function extractName(source) {
	      return source && source.name;
	    }
	  }]);
	  return FileLoader;
	}(Loader$1);


	FileLoader$1.types = ['file', 'blob'];

	// we don't need to detect all kinds of URLs, just the evident ones
	var urlStartRegexp = /^(https?|ftp):\/\//i;

	var XHRLoader$1 = function (_Loader) {
	  inherits(XHRLoader, _Loader);

	  function XHRLoader(source, options) {
	    classCallCheck(this, XHRLoader);

	    var _this = possibleConstructorReturn(this, (XHRLoader.__proto__ || Object.getPrototypeOf(XHRLoader)).call(this, source, options));

	    options = _this._options;
	    _this._binary = options.binary === true;
	    return _this;
	  }

	  createClass(XHRLoader, [{
	    key: 'loadAsync',
	    value: function loadAsync() {
	      var _this2 = this;

	      return new Promise(function (resolve, reject) {
	        var url = _this2._source;
	        var request = _this2._agent = new XMLHttpRequest();

	        request.addEventListener('load', function () {
	          if (request.status === 200) {
	            resolve(request.response);
	          } else {
	            reject(new Error('HTTP ' + request.status + ' while fetching ' + url));
	          }
	        });
	        request.addEventListener('error', function () {
	          reject(new Error('HTTP request failed'));
	        });
	        request.addEventListener('abort', function () {
	          reject(new Error('Loading aborted'));
	        });
	        request.addEventListener('progress', function (event) {
	          _this2.dispatchEvent(event);
	        });

	        request.open('GET', url);
	        if (_this2._binary) {
	          request.responseType = 'arraybuffer';
	        } else {
	          request.responseType = 'text';
	        }
	        request.send();
	      });
	    }

	    /** @deprecated */

	  }], [{
	    key: 'canLoad',
	    value: function canLoad(source, options) {
	      var sourceType = options.sourceType;
	      return typeof source === 'string' && (!sourceType || sourceType === 'url');
	    }
	  }, {
	    key: 'canProbablyLoad',
	    value: function canProbablyLoad(source) {
	      return lodash.isString(source) && urlStartRegexp.test(source);
	    }
	  }, {
	    key: 'extractName',
	    value: function extractName(source) {
	      if (source) {
	        var last = (source.indexOf('?') + 1 || source.lastIndexOf('#') + 1 || source.length + 1) - 1;
	        return source.slice(source.lastIndexOf('/', last) + 1, last);
	      }
	      return undefined;
	    }
	  }]);
	  return XHRLoader;
	}(Loader$1);


	XHRLoader$1.types = ['url'];

	var ImmediateLoader = function (_Loader) {
	  inherits(ImmediateLoader, _Loader);

	  function ImmediateLoader(source, options) {
	    classCallCheck(this, ImmediateLoader);
	    return possibleConstructorReturn(this, (ImmediateLoader.__proto__ || Object.getPrototypeOf(ImmediateLoader)).call(this, source, options));
	  }

	  createClass(ImmediateLoader, [{
	    key: 'loadAsync',
	    value: function loadAsync() {
	      return Promise.resolve(this._source);
	    }

	    /** @deprecated */

	  }], [{
	    key: 'canLoad',
	    value: function canLoad(source, options) {
	      return typeof source !== 'undefined' && typeof options !== 'undefined' && options.sourceType === 'immediate';
	    }
	  }, {
	    key: 'canProbablyLoad',
	    value: function canProbablyLoad(_source) {
	      return false;
	    }
	  }]);
	  return ImmediateLoader;
	}(Loader$1);


	ImmediateLoader.types = ['immediate'];

	var loaders = new LoaderList([
	// note: order might be important
	FileLoader$1, XHRLoader$1, ImmediateLoader]);

	/**
	 * A list of available parsers.
	 * @extends EntityList
	 */

	var ParserList = function (_EntityList) {
	  inherits(ParserList, _EntityList);

	  /**
	   * Create a list of parsers.
	   * The parsers are indexed by supported data formats and file extensions (`.formats` and
	   * `.extensions` properties of a Parser subclass).
	   * The parsers can be retrieved later by matching against specs (see {@link ParsrerList#find}).
	   *
	   * @param {!Array<function(new:Parser)>=} someParsers A list of {@link Parser} subclasses to
	   *   automatically register at creation time.
	   * @see ParserList#register
	   */
	  function ParserList() {
	    var someParsers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    classCallCheck(this, ParserList);
	    return possibleConstructorReturn(this, (ParserList.__proto__ || Object.getPrototypeOf(ParserList)).call(this, someParsers, ['formats', 'extensions']));
	  }

	  /**
	   * Find a suitable parser for data.
	   *
	   * @param {Object} specs Parser specifications.
	   * @param {string=} specs.format Supported data format.
	   * @param {string=} specs.ext Supported filename extension.
	   * @param {*=} specs.data Data to parse.
	   */


	  createClass(ParserList, [{
	    key: 'find',
	    value: function find(specs) {
	      var list = [];
	      if (specs.format) {
	        list = this._dict.formats[specs.format.toLowerCase()] || [];
	      } else if (specs.ext) {
	        list = this._dict.extensions[specs.ext.toLowerCase()] || [];
	      }
	      // autodetect only if no format is forced
	      if (list.length === 0 && !specs.format && specs.data) {
	        return this._list.filter(function (SomeParser) {
	          return SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data);
	        });
	      }
	      return [].concat(toConsumableArray(list));
	    }
	  }]);
	  return ParserList;
	}(EntityList);

	var Parser = function () {
	  function Parser(data, options) {
	    classCallCheck(this, Parser);

	    this._data = data;
	    this._options = options || {};
	    this._abort = false;
	  }

	  createClass(Parser, [{
	    key: 'parseSync',
	    value: function parseSync() {
	      throw new Error('Parsing this type of data is not implemented');
	    }
	  }, {
	    key: 'parse',
	    value: function parse( /** @deprecated */callbacks) {
	      var _this = this;

	      if (callbacks) {
	        return this._parseOLD(callbacks);
	      }

	      return new Promise(function (resolve, reject) {
	        setTimeout(function () {
	          try {
	            if (_this._abort) {
	              return reject(new Error('Parsing aborted'));
	            }
	            return resolve(_this.parseSync());
	          } catch (error) {
	            return reject(error);
	          }
	        });
	      });
	    }

	    /** @deprecated */

	  }, {
	    key: '_parseOLD',
	    value: function _parseOLD(callbacks) {
	      return this.parse().then(function (result) {
	        callbacks.ready(result);
	      }).catch(function (error) {
	        callbacks.error(error);
	      });
	    }
	  }, {
	    key: 'abort',
	    value: function abort() {
	      this._abort = true;
	    }

	    /** @deprecated */

	  }], [{
	    key: 'checkDataTypeOptions',
	    value: function checkDataTypeOptions(options, type, extension) {
	      var fileType = options.fileType;
	      var fileName = options.fileName;
	      extension = (extension || '.' + type).toLowerCase();
	      return Boolean(fileType && fileType.toLowerCase() === type.toLowerCase() || !fileType && fileName && fileName.toLowerCase().endsWith(extension));
	    }
	  }]);
	  return Parser;
	}();


	makeContextDependent(Parser.prototype);

	/**
	 * Parser helper for PDB tag "REMARK 290".
	 *
	 * @exports Remark290
	 * @constructor
	 */
	function Remark290() {
	  /** @type {THREE.Matrix4[]} */
	  this.matrices = [];

	  /** @type {?THREE.Matrix4} */
	  this._matrix = null;
	  /** @type {number} */
	  this._matrixIndex = -1;
	}

	Remark290.prototype.id = 290;

	/**
	 * Parse a single line of a stream.
	 * @param {PDBStream} stream - stream to parse
	 */
	Remark290.prototype.parse = function (stream) {
	  /** @type {?THREE.Matrix4} */
	  var matrix = this._matrix;

	  if (stream.readString(12, 18) === '  SMTRY') {
	    var matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2
	    var matrixData = stream.readString(20, 80).trim().split(/\s+/);
	    var matrixIndex = parseInt(matrixData[0], 10);
	    if (this._matrix === null || matrixIndex !== this._matrixIndex) {
	      // TODO: assert(matrixIndex === this.matrices.length + 1);
	      this._matrixIndex = matrixIndex;
	      this._matrix = matrix = new Matrix4();
	      this.matrices[this.matrices.length] = matrix;
	    }

	    var elements = matrix.elements;
	    elements[matrixRow] = parseFloat(matrixData[1]);
	    elements[matrixRow + 4] = parseFloat(matrixData[2]);
	    elements[matrixRow + 8] = parseFloat(matrixData[3]);
	    elements[matrixRow + 12] = parseFloat(matrixData[4]);
	  }
	};

	var Assembly$1 = chem.Assembly;

	/**
	 * Parser helper for PDB tag "REMARK 350".
	 *
	 * @exports Remark350
	 * @constructor
	 */
	function Remark350(complex) {

	  /** @type {Complex} */
	  this._complex = complex;
	  /** @type {Assembly[]} */
	  this.assemblies = [];

	  /** @type {?Assembly} */
	  this._assembly = null;
	  /** @type {?THREE.Matrix4} */
	  this._matrix = null;
	  /** @type {number} */
	  this._matrixIndex = -1;
	}

	Remark350.prototype.id = 350;

	/**
	 * Parse a single line of a stream.
	 * @param {PDBStream} stream - stream to parse
	 */
	Remark350.prototype.parse = function (stream) {
	  /** @type {?Assembly} */
	  var assembly = this._assembly;
	  /** @type {?THREE.Matrix4} */
	  var matrix = this._matrix;

	  if (assembly && stream.readString(12, 18) === '  BIOMT') {
	    var matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2
	    var matrixData = stream.readString(20, 80).trim().split(/\s+/);
	    var matrixIndex = parseInt(matrixData[0], 10);
	    if (this._matrix === null || matrixIndex !== this._matrixIndex) {
	      // TODO: assert(matrixIndex === assembly.matrices.length + 1);
	      this._matrixIndex = matrixIndex;
	      this._matrix = matrix = new Matrix4();
	      assembly.addMatrix(matrix);
	    }

	    var elements = matrix.elements;
	    elements[matrixRow] = parseFloat(matrixData[1]);
	    elements[matrixRow + 4] = parseFloat(matrixData[2]);
	    elements[matrixRow + 8] = parseFloat(matrixData[3]);
	    elements[matrixRow + 12] = parseFloat(matrixData[4]);
	  } else if (assembly && stream.readString(35, 41) === 'CHAINS:') {
	    var entries = stream.readString(42, 80).split(',');
	    for (var i = 0, n = entries.length; i < n; ++i) {
	      var chain = entries[i].trim();
	      if (chain.length > 0) {
	        assembly.addChain(chain);
	      }
	    }
	  } else if (stream.readString(12, 23) === 'BIOMOLECULE:') {
	    // var molIndex = stream.readInt(24, 80);
	    // TODO: assert(molIndex === this.assemblies.length + 1);
	    this._matrix = null;
	    this._matrixIndex = -1;
	    this._assembly = assembly = new Assembly$1(this._complex);
	    this.assemblies.push(assembly);
	  }
	};

	var PDBStream = function () {
	  function PDBStream(data) {
	    classCallCheck(this, PDBStream);

	    this._data = data;
	    this._start = 0;
	    this._nextCR = -1;
	    this._nextLF = -1;
	    this._next = -1;
	    this._end = data.length;

	    this.next();
	  }

	  createClass(PDBStream, [{
	    key: 'readLine',
	    value: function readLine() {
	      return this._data.slice(this._start, this._next);
	    }
	  }, {
	    key: 'readChar',
	    value: function readChar(pos) {
	      pos = this._start + pos - 1;
	      return pos < this._next ? this._data[pos] : ' ';
	    }
	  }, {
	    key: 'readCharCode',
	    value: function readCharCode(pos) {
	      pos = this._start + pos - 1;
	      return pos < this._next ? this._data.charCodeAt(pos) : 32;
	    }
	  }, {
	    key: 'readString',
	    value: function readString(begin, end) {
	      var from = this._start + begin - 1;
	      var to = this._start + end;
	      return this._data.slice(from, to < this._next ? to : this._next);
	    }
	  }, {
	    key: 'readInt',
	    value: function readInt(begin, end) {
	      return parseInt(this.readString(begin, end), 10);
	    }
	  }, {
	    key: 'readFloat',
	    value: function readFloat(begin, end) {
	      return parseFloat(this.readString(begin, end));
	    }
	  }, {
	    key: 'end',
	    value: function end() {
	      return this._start >= this._end;
	    }
	  }, {
	    key: 'next',
	    value: function next() {
	      var start = this._next + 1;
	      this._start = start < this._end ? start : this._end;

	      // support CR, LF, CR+LF line endings
	      // do not support LF+CR, CR+CR+LF, and other strange combinations

	      if (this._start > this._nextCR) {
	        this._nextCR = (this._data.indexOf('\r', this._start) + 1 || this._end + 1) - 1;
	      }
	      if (this._start > this._nextLF) {
	        this._nextLF = (this._data.indexOf('\n', this._start) + 1 || this._end + 1) - 1;
	      }
	      this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
	    }
	  }]);
	  return PDBStream;
	}();

	var Complex$1 = chem.Complex,
	    Element$2 = chem.Element,
	    Helix$1 = chem.Helix,
	    Sheet$1 = chem.Sheet,
	    Strand$1 = chem.Strand,
	    Bond$1 = chem.Bond,
	    Molecule$1 = chem.Molecule;

	var TAG_LENGTH = 6;

	function nameToElement(name) {
	  // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
	  //
	  // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
	  //
	  // Atom names start with element symbols right-justified in columns 13-14
	  // as permitted by the length of the name. For example, the symbol FE for
	  // iron appears in columns 13-14, whereas the symbol C for carbon appears
	  // in column 14 (see Misaligned Atom Names). If an atom name has four
	  // characters, however, it must start in column 13 even if the element
	  // symbol is a single character (for example, see Hydrogen Atoms).

	  var veryLong = name.trim().length === 4;
	  return name.slice(0, veryLong ? 1 : 2).trim();
	}

	function PDBParser(data, options) {
	  Parser.call(this, data, options);

	  this._complex = null;
	  this._chain = null;
	  this._residue = null;
	  this._sheet = null;
	  this._serialAtomMap = null;
	  this._modelId = 1;
	  this._compaundFound = false;
	  this._biomoleculeFound = false;
	  this._allowedChainsIDs = null;
	  this._lastMolId = -1;

	  this._remarks = {};
	  this._remark = null;

	  this._molecules = [];
	  this._molecule = null;
	  this._compndCurrToken = '';

	  this._options.fileType = 'pdb';
	}

	////////////////////////////////////////////////////////////////////////////
	// Inheritance

	PDBParser.prototype = Object.create(Parser.prototype);
	PDBParser.prototype.constructor = PDBParser;

	////////////////////////////////////////////////////////////////////////////
	// Class methods

	/** @deprecated */
	PDBParser.canParse = function (data, options) {
	  if (!data) {
	    return false;
	  }
	  return typeof data === 'string' && (Parser.checkDataTypeOptions(options, 'pdb') || Parser.checkDataTypeOptions(options, 'pdb', '.ent'));
	};

	// the most frequently used beginnings; although HEADER is mandatory, it is often missing in handmade files
	var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;

	PDBParser.canProbablyParse = function (data) {
	  return lodash.isString(data) && pdbStartRegexp.test(data);
	};

	////////////////////////////////////////////////////////////////////////////
	// Instance methods

	PDBParser.prototype._finalize = function () {
	  // console.time('PDBParser._finalize');
	  this._fixBondsArray();
	  this._fixChains();

	  // keep crystallographic symmetry transformations
	  var remark290 = this._remarks[290];
	  this._complex.symmetry = lodash.isUndefined(remark290) ? [] : remark290.matrices;

	  // add loaded biological assemblies
	  var remark350 = this._remarks[350];
	  this._complex.units = this._complex.units.concat(lodash.isUndefined(remark350) ? [] : remark350.assemblies);

	  // add loaded macromolecules
	  this._finalizeMolecules();

	  // create secondary structure etc.
	  this._complex.finalize({
	    needAutoBonding: true,
	    detectAromaticLoops: this.settings.now.aromatic,
	    enableEditing: this.settings.now.editing,
	    serialAtomMap: this._serialAtomMap
	  });
	};

	PDBParser.prototype._finalizeMolecules = function () {
	  // get chains from complex
	  var chainDict = {};
	  var i;
	  var chains = this._complex._chains;
	  for (i = 0; i < chains.length; ++i) {
	    var chainObj = chains[i];
	    var chainName = chainObj._name;
	    chainDict[chainName] = chainObj;
	  }

	  // aggregate residues from chains
	  for (i = 0; i < this._molecules.length; i++) {
	    var m = this._molecules[i];
	    var residues = [];
	    for (var j = 0; j < m._chains.length; j++) {
	      var name = m._chains[j];
	      var chain = chainDict[name];
	      residues = residues.concat(chain._residues.slice());
	    }
	    var molecule = new Molecule$1(this._complex, m._name, i + 1);
	    molecule._residues = residues;
	    this._complex._molecules[i] = molecule;
	  }
	};

	PDBParser.prototype._fixChains = function () {
	  var idChainMap = {};
	  var complex = this._complex;

	  //prepare
	  for (var i = 0; i < complex._chains.length; i++) {
	    var chain = complex._chains[i];
	    idChainMap[chain._name.charCodeAt(0)] = chain;
	  }
	};

	/* NOTE: Slow and clumsy. And only for badly formatted files.
	  PDBParser.prototype._atomNameScan = function(str) {
	    var i = 0;
	    var code = null;
	    var codeA = 'A'.charCodeAt(0);
	    var codeZ = 'Z'.charCodeAt(0);
	    var s = str.toUpperCase();
	    for (i = s.length - 1; i >= 0; i--) { // FIXME: What for?
	      code = s.charCodeAt(i);
	      if (codeA <= code && code <= codeZ) {
	        continue;
	      } else {
	        s = s.slice(0, i) + s.slice(i + 1, s.length);
	      }
	    }
	    return s;
	  };
	  */

	// FIXME: This function is redundant, CONECT records always follow ATOM and HETATM. Build the map online.
	PDBParser.prototype._fixBondsArray = function () {
	  var serialAtomMap = this._serialAtomMap = {};
	  var complex = this._complex;

	  var atoms = complex._atoms;
	  var i = 0,
	      ni = atoms.length;
	  for (; i < ni; ++i) {
	    var atom = atoms[i];
	    serialAtomMap[atom._serial] = atom;
	  }

	  var bonds = complex._bonds;
	  var j = 0,
	      nj = bonds.length;
	  var logger = this.logger;
	  for (; j < nj; ++j) {
	    var bond = bonds[j];
	    if (bond._right < bond._left) {
	      logger.debug('_fixBondsArray: Logic error.');
	    }
	    bond._left = serialAtomMap[bond._left] || null;
	    bond._right = serialAtomMap[bond._right] || null;
	  }
	};

	PDBParser.prototype._parseATOM = function (stream) {
	  if (this._modelId !== 1) {
	    return;
	  }

	  /* eslint-disable no-magic-numbers */
	  var het = stream.readCharCode(1) === 0x48;

	  // field names according to wwPDB Format
	  // NOTE: Chimera allows (nonstandard) use of columns 6-11 for the integer atom serial number in ATOM records.
	  var serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
	  var name = stream.readString(13, 16);
	  var altLoc = stream.readChar(17);
	  var resName = stream.readString(18, 20).trim();
	  var chainID = stream.readChar(22);
	  var resSeq = stream.readInt(23, 26);
	  var iCode = stream.readChar(27);
	  var x = stream.readFloat(31, 38);
	  var y = stream.readFloat(39, 46);
	  var z = stream.readFloat(47, 54);
	  var occupancy = stream.readFloat(55, 60);
	  var tempFactor = stream.readFloat(61, 66);
	  var element = stream.readString(77, 78).trim() || nameToElement(name);
	  var charge = stream.readInt(79, 80) || 0;
	  /* eslint-enable no-magic-numbers */
	  // skip waters (there may be lots of them)
	  if (this.settings.now.nowater) {
	    if (resName === 'HOH' || resName === 'WAT') {
	      return;
	    }
	  }

	  // PDB uses positional system for atom names. It helps derive element type from the name
	  // but names may include extra spaces. From this point on we don't need those spaces anymore.
	  name = name.trim();

	  var type = Element$2.getByName(element);
	  var role = Element$2.Role[name]; // FIXME: Maybe should use type as additional index (" CA " vs. "CA  ")

	  // NOTE: Residues of a particular chain are not required to be listed next to each other.
	  // https://github.com/biasmv/pv/commit/7319b898b7473ba380c26699e3b028b2b1a7e1a1
	  var chain = this._chain;
	  if (!chain || chain.getName() !== chainID) {
	    this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
	    this._residue = null;
	  }

	  var residue = this._residue;
	  if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
	    this._residue = residue = chain.addResidue(resName, resSeq, iCode);
	  }

	  // TODO: optimize atom positions storage? what for? (and occupancy? tempFactor?)
	  var xyz = new Vector3(x, y, z);
	  residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
	};

	PDBParser.prototype._parseENDMDL = function () {
	  this._modelId += 1;
	};

	PDBParser.prototype._parseCONECT = function (stream) {
	  /* eslint-disable no-magic-numbers */
	  var serial0 = stream.readInt(7, 11);
	  var serial1 = stream.readInt(12, 16);
	  var serial2 = stream.readInt(17, 21);
	  var serial3 = stream.readInt(22, 26);
	  var serial4 = stream.readInt(27, 31);
	  /* eslint-enable no-magic-numbers */

	  var complex = this._complex;

	  // Keep bonds ordered by atom serial
	  if (serial1 && serial1 > serial0) {
	    complex.addBond(serial0, serial1, 0, Bond$1.BondType.UNKNOWN, true);
	  }
	  if (serial2 && serial2 > serial0) {
	    complex.addBond(serial0, serial2, 0, Bond$1.BondType.UNKNOWN, true);
	  }
	  if (serial3 && serial3 > serial0) {
	    complex.addBond(serial0, serial3, 0, Bond$1.BondType.UNKNOWN, true);
	  }
	  if (serial4 && serial4 > serial0) {
	    complex.addBond(serial0, serial4, 0, Bond$1.BondType.UNKNOWN, true);
	  }
	};

	PDBParser.prototype._parseCOMPND = function (stream) {
	  /* eslint-disable no-magic-numbers */
	  var str = stream.readString(11, 80);
	  var tokenIdx = str.indexOf(':');
	  this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;
	  /* eslint-enable no-magic-numbers */

	  // start reading new molecule
	  if (this._compndCurrToken === 'MOL_ID') {
	    this._molecule = { _index: '', _chains: [] };
	    this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(';')), 10);
	    this._molecules.push(this._molecule);
	    // parse molecule name
	  } else if (this._compndCurrToken === 'MOLECULE' && this._molecule != null) {
	    this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(';')).trim();
	    // parse molecule chains
	  } else if (this._compndCurrToken === 'CHAIN' && this._molecule != null) {
	    var chainStr = str.substring(tokenIdx + 1, 80).trim();
	    var lastChar = chainStr[chainStr.length - 1];
	    if (lastChar === ';' || lastChar === ',') {
	      chainStr = chainStr.slice(0, -1);
	    }
	    chainStr = chainStr.replace(/\s+/g, '');
	    var chains = chainStr.split(',');
	    this._molecule._chains = this._molecule._chains.concat(chains);
	  }
	};

	var remarkParsers = {
	  // NOTE: please forget the idea to build the method name in runtime, it can be obfuscated.
	  290: Remark290,
	  350: Remark350
	};

	PDBParser.prototype._parseREMARK = function (stream) {
	  /* eslint-disable no-magic-numbers */
	  var remarkNum = stream.readInt(8, 10);
	  /* eslint-enable no-magic-numbers */

	  // create remark parser if needed
	  var remark = this._remarks[remarkNum];
	  if (lodash.isUndefined(remark)) {
	    var RemarkParser = remarkParsers[remarkNum];
	    if (lodash.isFunction(RemarkParser)) {
	      this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
	    }
	  }

	  // delegate parsing
	  if (!lodash.isUndefined(remark)) {
	    remark.parse(stream);
	  }
	};

	PDBParser.prototype._parseHELIX = function (stream) {
	  /* eslint-disable no-magic-numbers */
	  var fields = [20, 22, 32, 34];
	  /* eslint-enable no-magic-numbers */
	  this._parseSTRUCTURE(stream, fields, function (obj) {
	    this._complex.addHelix(obj);
	    this._complex.structures.push(obj);
	  }.bind(this));
	};

	PDBParser.prototype._parseSHEET = function (stream) {
	  /* eslint-disable no-magic-numbers */
	  var fields = [22, 23, 33, 34];
	  /* eslint-enable no-magic-numbers */
	  this._parseSTRUCTURE(stream, fields, function (obj) {
	    this._complex.addSheet(obj);
	  }.bind(this));
	};

	PDBParser.prototype._parseSTRUCTURE = function (stream, pars, adder) {
	  // FIXME: HELIX and SHEET have nothing in common

	  var startId = 0;
	  var startIndex = 1;
	  var endId = 2;
	  var endIndex = 3;

	  //identify fields: debugging and stuff
	  /* eslint-disable no-magic-numbers */
	  var codeOfS = 0x53;
	  //var twoLinesMaxLen = 2 * 80;
	  var serialNumber = stream.readInt(8, 10);
	  var structureName = stream.readString(12, 14).trim(); // FIXME: LString(3) forbids trim()
	  var comment = stream.readString(41, 70).trim();
	  var helLength = stream.readInt(72, 76);
	  var helixClass = stream.readInt(39, 40);
	  var shWidth = stream.readInt(15, 16);
	  var shCur = stream.readInt(42, 45);
	  var shPrev = stream.readInt(57, 60);
	  /* eslint-enable no-magic-numbers */
	  //file fields
	  var startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0); // FIXME: no need in these
	  var endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
	  var startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
	  var iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
	  var startICode = 0;

	  if (iCodeStr.length > 0) {
	    startICode = iCodeStr.charCodeAt(0);
	  }
	  var endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
	  iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
	  var endICode = 0;
	  if (iCodeStr.length > 0) {
	    endICode = iCodeStr.charCodeAt(0);
	  }

	  var obj;
	  var cs = this._sheet;
	  if (stream.readCharCode(1) === codeOfS) {
	    if (cs !== null && cs.getName() !== structureName) {
	      cs = null;
	      this._sheet = null;
	    }
	    if (cs === null) {
	      this._sheet = obj = new Sheet$1(structureName, shWidth);
	      adder(obj);
	    } else {
	      obj = cs;
	    }
	    var strand = new Strand$1(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
	    obj.addStrand(strand);
	    this._complex.structures.push(strand);
	  } else {
	    obj = new Helix$1(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
	    adder(obj);
	  }
	};

	PDBParser.prototype._parseHEADER = function (stream) {
	  var metadata = this._complex.metadata;
	  metadata.classification = stream.readString(11, 50).trim();
	  metadata.date = stream.readString(51, 59).trim();

	  var id = stream.readString(63, 66).trim();
	  metadata.id = id;
	  if (id) {
	    this._complex.name = id;
	  }
	  metadata.format = 'pdb';
	};

	PDBParser.prototype._parseTITLE = function (stream) {
	  var metadata = this._complex.metadata;
	  metadata.title = metadata.title || [];

	  var line = stream.readInt(9, 10) || 1;
	  metadata.title[line - 1] = stream.readString(11, 80).trim();
	};

	var tagParsers = {
	  'HEADER': PDBParser.prototype._parseHEADER,
	  'TITLE ': PDBParser.prototype._parseTITLE,
	  'ATOM  ': PDBParser.prototype._parseATOM,
	  'HETATM': PDBParser.prototype._parseATOM,
	  'ENDMDL': PDBParser.prototype._parseENDMDL,
	  'CONECT': PDBParser.prototype._parseCONECT,
	  'COMPND': PDBParser.prototype._parseCOMPND,
	  'REMARK': PDBParser.prototype._parseREMARK,
	  // 'SOURCE': PDBParser.prototype._parseSOURCE,
	  'HELIX ': PDBParser.prototype._parseHELIX,
	  'SHEET ': PDBParser.prototype._parseSHEET,

	  // FIXME: HACK: nonstandard extension to allow range 100,000 - 999,999
	  'ATOM 1': PDBParser.prototype._parseATOM,
	  'ATOM 2': PDBParser.prototype._parseATOM,
	  'ATOM 3': PDBParser.prototype._parseATOM,
	  'ATOM 4': PDBParser.prototype._parseATOM,
	  'ATOM 5': PDBParser.prototype._parseATOM,
	  'ATOM 6': PDBParser.prototype._parseATOM,
	  'ATOM 7': PDBParser.prototype._parseATOM,
	  'ATOM 8': PDBParser.prototype._parseATOM,
	  'ATOM 9': PDBParser.prototype._parseATOM
	};

	PDBParser.prototype.parseSync = function () {
	  var stream = new PDBStream(this._data);
	  var result = this._complex = new Complex$1();

	  // parse PDB line by line
	  while (!stream.end()) {
	    var tag = stream.readString(1, TAG_LENGTH);
	    var func = tagParsers[tag];
	    if (lodash.isFunction(func)) {
	      func.call(this, stream);
	    }
	    stream.next();
	  }

	  // Resolve indices and serials to objects
	  this._finalize();

	  // cleanup
	  this._serialAtomMap = null;
	  this._sheet = null;
	  this._residue = null;
	  this._chain = null;
	  this._complex = null;

	  if (result.getAtomCount() === 0) {
	    throw new Error('The data does not contain valid atoms');
	  }

	  return result;
	};

	PDBParser.formats = ['pdb'];
	PDBParser.extensions = ['.pdb', '.ent'];

	var Complex$2 = chem.Complex,
	    Element$3 = chem.Element,
	    AtomName$1 = chem.AtomName,
	    SGroup$1 = chem.SGroup,
	    Bond$2 = chem.Bond;

	var cOrderCharCodes = {
	  A: 0,
	  S: 1,
	  D: 2,
	  T: 3
	};

	function CMLParser(data, options) {
	  Parser.call(this, data, options);

	  this._complex = null;
	  this._residue = null;
	  this._serialAtomMap = null;
	  this._modelId = 1;
	  this._lastMolId = -1;
	  this._readOnlyOneMolecule = false;

	  this._options.fileType = 'cml';
	}

	////////////////////////////////////////////////////////////////////////////
	// Inheritance

	CMLParser.prototype = Object.create(Parser.prototype);
	CMLParser.prototype.constructor = CMLParser;

	////////////////////////////////////////////////////////////////////////////
	// Class methods

	/** @deprecated */
	CMLParser.canParse = function (data, options) {
	  if (!data) {
	    return false;
	  }
	  var re = new RegExp('^\\s*?\\<\\?xml');
	  var re1 = new RegExp('^\\s*?\\<cml');
	  var dataHasXML = (typeof data === 'string' || data instanceof String) && (data.match(re) || data.match(re1));
	  return dataHasXML && Parser.checkDataTypeOptions(options, 'cml');
	};

	var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;

	CMLParser.canProbablyParse = function (data) {
	  return lodash.isString(data) && cmlStartRegexp.test(data);
	};

	////////////////////////////////////////////////////////////////////////////
	// Instance methods

	CMLParser.prototype._rebuidBondIndexes = function (atoms, bonds) {
	  var count = atoms.length;
	  for (var i = 0; i < count; i++) {
	    var atomId = atoms[i].id;

	    var countBonds = bonds.length;
	    for (var j = 0; j < countBonds; j++) {
	      var idxs = bonds[j].atomRefs2.split(' ');
	      if (idxs[0] === atomId) {
	        bonds[j].start = i;
	      }

	      if (idxs[1] === atomId) {
	        bonds[j].end = i;
	      }
	    }
	  }
	};

	CMLParser.prototype._createSGroup = function (molecule, moleculeArr) {
	  var newGroup = new SGroup$1(molecule.id, molecule.fieldData, new Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);
	  if (molecule.placement === 'Relative') {
	    newGroup._center = new Vector3(0, 0, 0);
	  }
	  if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
	    newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
	  }
	  if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
	    newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
	  }
	  moleculeArr.push(newGroup);
	};

	CMLParser.prototype._extractSGroup = function (molecule, moleculeArr) {
	  if (!Array.isArray(moleculeArr)) {
	    moleculeArr = [];
	  }

	  if (molecule) {
	    if (Array.isArray(molecule)) {
	      var count = molecule.length;
	      for (var i = 0; i < count; i++) {
	        if (molecule[i].molecule) {
	          moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i].molecule));
	        }
	        this._createSGroup(molecule[i], moleculeArr);
	      }
	    } else {
	      if (molecule.molecule) {
	        if (molecule.molecule) {
	          moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
	        }
	      }
	      this._createSGroup(molecule, moleculeArr);
	    }
	  }

	  return moleculeArr;
	};

	CMLParser.prototype._extractSGroups = function (molecule, atoms) {
	  var moleculeArr = this._extractSGroup(molecule);

	  var count = atoms.length;
	  var i;
	  var j;

	  for (i = 0; i < count; i++) {
	    var atomId = atoms[i].id;
	    for (j = 0; j < moleculeArr.length; j++) {
	      var firstAtomRef = moleculeArr[j]._atoms.split(' ')[0];
	      if (firstAtomRef === atomId) {
	        if (!atoms[i].sgroupRef) {
	          atoms[i].sgroupRef = [];
	        }
	        atoms[i].sgroupRef.push(moleculeArr[j]);
	      }
	    }
	  }
	  //build sGroups centers
	  var atomMap = {}; //sgrpmap cache
	  var mapEntry = null;
	  var nLimon = 100000000;
	  var bLow = new Vector3(nLimon, nLimon, nLimon);
	  var bHight = new Vector3(-nLimon, -nLimon, -nLimon);

	  function cycleFuncInner(e) {
	    mapEntry = atomMap[e];
	    if (mapEntry) {
	      moleculeArr[j]._atoms.push(mapEntry.a);
	    }
	  }

	  function cycleFunc(e) {
	    mapEntry = atomMap[e];
	    if (mapEntry) {
	      bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
	      bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
	      cycleFuncInner(e);
	    }
	  }

	  for (i = 0; i < atoms.length; i++) {
	    atomMap[atoms[i].id] = {};
	    atomMap[atoms[i].id].x = atoms[i].x2;
	    if (atoms[i].x3) {
	      atomMap[atoms[i].id].x = atoms[i].x3;
	    }
	    atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x);
	    atomMap[atoms[i].id].y = atoms[i].y2;
	    if (atoms[i].y3) {
	      atomMap[atoms[i].id].y = atoms[i].y3;
	    }
	    atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y);
	    atomMap[atoms[i].id].z = '0.0';
	    if (atoms[i].z3) {
	      atomMap[atoms[i].id].z = atoms[i].z3;
	    }
	    atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z);
	    atomMap[atoms[i].id].a = atoms[i];
	  }

	  var atomsRef;
	  for (j = 0; j < moleculeArr.length; j++) {
	    if (moleculeArr[j]._center !== null) {
	      bLow.set(nLimon, nLimon, nLimon);
	      bHight.set(-nLimon, -nLimon, -nLimon);
	      atomsRef = moleculeArr[j]._atoms.split(' ');
	      moleculeArr[j]._atoms = [];
	      atomsRef.forEach(cycleFunc);

	      moleculeArr[j]._center.addVectors(bLow, bHight);
	      moleculeArr[j]._center.multiplyScalar(0.5);
	    } else {
	      atomsRef = moleculeArr[j]._atoms.split(' ');
	      moleculeArr[j]._atoms = [];
	      atomsRef.forEach(cycleFuncInner);
	    }
	  }
	  atomMap = null;
	};

	CMLParser.prototype._traverseData = function (dom) {
	  function isArray(o) {
	    return Object.prototype.toString.apply(o) === '[object Array]';
	  }

	  function parseNode(xmlNode, result) {
	    if (xmlNode.nodeName === '#text' && xmlNode.nodeValue.trim() === '') {
	      return;
	    }

	    var jsonNode = {};
	    jsonNode.xmlNode = xmlNode;
	    var existing = result[xmlNode.nodeName];
	    if (existing) {
	      if (!isArray(existing)) {
	        result[xmlNode.nodeName] = [existing, jsonNode];
	      } else {
	        result[xmlNode.nodeName].push(jsonNode);
	      }
	    } else {
	      result[xmlNode.nodeName] = jsonNode;
	    }

	    var length;
	    var i;
	    if (xmlNode.attributes) {
	      length = xmlNode.attributes.length;
	      for (i = 0; i < length; i++) {
	        var attribute = xmlNode.attributes[i];
	        jsonNode[attribute.nodeName] = attribute.nodeValue;
	      }
	    }

	    length = xmlNode.childNodes.length;
	    for (i = 0; i < length; i++) {
	      parseNode(xmlNode.childNodes[i], jsonNode);
	    }
	  }

	  var result = {};
	  if (dom.childNodes.length) {
	    parseNode(dom.childNodes[0], result);
	  }

	  return result;
	};

	CMLParser.prototype._findSuitableMolecule = function (data, molSet) {
	  for (var key in data) {
	    if (key === 'xmlNode') {
	      continue;
	    } else if (key === 'molecule') {
	      if (data.molecule) {
	        if (data.molecule.atomArray && data.molecule.atomArray.atom) {
	          molSet.push(data);
	        }
	        if (Array.isArray(data.molecule)) {
	          for (var i = 0; i < data.molecule.length; i++) {
	            if (data.molecule[i].atomArray && data.molecule[i].atomArray.atom) {
	              molSet.push({ molecule: data.molecule[i] });
	            }
	          }
	        }
	      }
	    } else if (data[key] && data[key] !== null && _typeof(data[key]) === 'object') {
	      this._findSuitableMolecule(data[key], molSet);
	    }
	  }
	};

	CMLParser.prototype._selectComponents = function (text) {
	  var parser = new DOMParser();
	  var doc = parser.parseFromString(text, 'application/xml');
	  var traversedData = this._traverseData(doc);
	  var rawData;
	  var self = this;

	  function prepareComponentCompound(data) {
	    var atoms = [];
	    if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
	      if (!Array.isArray(data.molecule.atomArray.atom)) {
	        atoms.push(data.molecule.atomArray.atom);
	      } else {
	        atoms = data.molecule.atomArray.atom;
	      }
	    } else if (!data.molecule) {
	      var ret = {};
	      ret.atomLabels = null;
	      ret.labelsCount = 1;
	      return ret;
	    }

	    if (data.molecule.molecule) {
	      self._extractSGroups(data.molecule.molecule, atoms);
	    }

	    var atom;
	    var count = atoms.length;
	    for (var i = 0; i < count; i++) {
	      atom = atoms[i];
	      atom.edges = [];
	    }

	    var localBond = [];
	    if (data.molecule.bondArray && data.molecule.bondArray.bond) {
	      if (!Array.isArray(data.molecule.bondArray.bond)) {
	        localBond.push(data.molecule.bondArray.bond);
	      } else {
	        localBond = data.molecule.bondArray.bond;
	      }
	    }
	    var bond;
	    count = localBond.length;
	    self._rebuidBondIndexes(atoms, localBond);

	    function addCurrBond(index) {
	      bond = localBond[index];
	      atom = atoms[bond.start];
	      if (!atom) {
	        return false;
	      }
	      atom.edges.push(bond.end);
	      atom = atoms[bond.end];
	      if (!atom) {
	        return false;
	      }
	      atom.edges.push(bond.start);
	      return true;
	    }

	    for (var _i = 0; _i < count; _i++) {
	      if (!addCurrBond(_i)) {
	        //ignore invalid bond
	        continue;
	      }
	      var orderAttr = bond.xmlNode.getAttribute('order');
	      var tc = parseInt(orderAttr, 10);
	      // the default bond order is unknown
	      localBond[_i].order = 0;
	      localBond[_i].type = Bond$2.BondType.UNKNOWN;
	      if (tc > 1) {
	        localBond[_i].order = tc;
	      } else {
	        // another option - bond order is a string
	        var order = cOrderCharCodes[orderAttr];
	        if (order !== undefined) {
	          localBond[_i].order = order;
	          if (orderAttr === 'A') {
	            localBond[_i].type = Bond$2.BondType.AROMATIC;
	          }
	        }
	      }
	    }

	    count = atoms.length;
	    for (var _i2 = 0; _i2 < count; _i2++) {
	      atom = atoms[_i2];
	      atom.edges.sort();
	    }

	    var labels = self._breadWidthSearch(atoms, 0); //for now

	    var retStruct = {};
	    retStruct.atoms = atoms;
	    retStruct.bonds = localBond;
	    retStruct.labels = labels.atomLabels;
	    retStruct.count = Math.min(1, labels.labelsCount); //for now
	    retStruct.curr = -1;
	    retStruct.originalCML = doc;

	    return retStruct;
	  }

	  if (traversedData.cml) {
	    rawData = traversedData.cml;
	  } else {
	    rawData = traversedData;
	  }
	  var retData = [];
	  var filteredData = [];
	  this._findSuitableMolecule(rawData, filteredData);
	  if (this._readOnlyOneMolecule && filteredData.length > 1) {
	    filteredData.splice(1, filteredData.length - 1);
	  }
	  filteredData.forEach(function (d) {
	    var rd = prepareComponentCompound(d);
	    if (rd.atoms.length > 0) {
	      retData.push(rd);
	    }
	  });
	  return retData;
	};

	CMLParser.prototype._packLabel = function (compId, molId) {
	  var shift = 16;
	  return (molId << shift) + compId;
	};

	CMLParser.prototype._unpackLabel = function (l) {
	  var shift = 16;
	  var mask = (1 << shift) - 1;
	  return { molId: l >>> shift, compId: l & mask };
	};

	CMLParser.prototype._breadWidthSearch = function (atoms, molID) {
	  var atomLabels = new Array(atoms.length);

	  var id;
	  for (id = 0; id < atomLabels.length; id++) {
	    atomLabels[id] = this._packLabel(0, molID);
	  }

	  var breadthQueue = [];
	  var componentID = 0;
	  var labeledAtoms = atoms.length;

	  while (labeledAtoms > 0) {
	    componentID++;

	    var startID = -1;
	    for (id = 0; id < atomLabels.length; id++) {
	      if (this._unpackLabel(atomLabels[id]).compId === 0) {
	        startID = id;
	        break;
	      }
	    }

	    if (startID < 0) {
	      break;
	    }

	    //Bread first search
	    breadthQueue.push(atoms[startID]);
	    atomLabels[startID] = this._packLabel(componentID, molID);
	    labeledAtoms--;

	    while (breadthQueue.length > 0) {
	      var curr = breadthQueue.shift();
	      if (!curr) {
	        continue;
	      }

	      for (var i = 0; i < curr.edges.length; i++) {
	        if (atomLabels[curr.edges[i]] !== componentID) {
	          breadthQueue.push(atoms[curr.edges[i]]);
	          atomLabels[curr.edges[i]] = componentID;
	          labeledAtoms--;
	        }
	      }
	    }
	  }
	  var ret = {};
	  ret.atomLabels = atomLabels;
	  ret.labelsCount = componentID;
	  return ret;
	};

	CMLParser.prototype._parseBond = function (eAtom, mainAtom, order, type) {
	  if (eAtom >= 0) {
	    var h = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];
	    this._complex.addBond(h[0], h[1], order, type, true);
	  }
	};

	CMLParser.prototype._fixBondsArray = function () {
	  var serialAtomMap = this._serialAtomMap = {};
	  var complex = this._complex;

	  var atoms = complex._atoms;
	  var i = 0,
	      ni = atoms.length;
	  for (; i < ni; ++i) {
	    var atom = atoms[i];
	    serialAtomMap[atom._serial] = atom;
	  }

	  var bonds = complex._bonds;
	  var j = 0,
	      nj = bonds.length;
	  var logger = this.logger;
	  for (; j < nj; ++j) {
	    var bond = bonds[j];
	    if (bond._right < bond._left) {
	      logger.debug('_fixBondsArray: Logic error.');
	    }
	    bond._left = serialAtomMap[bond._left] || null;
	    bond._right = serialAtomMap[bond._right] || null;
	  }
	};

	CMLParser.prototype._parseSet = function (varData) {
	  var complex = this._complex = new Complex$2();
	  var data = varData;
	  var currentLabel = data.curr;
	  var atoms = data.atoms;
	  var labels = data.labels;
	  var atom = null;
	  var i;
	  var j;
	  var count = atoms.length;

	  function addFunc(a) {
	    a.xmlNodeRef = atom;
	    if (atom.x2) {
	      atom.x3 = atom.x2;
	      delete atom.x2;
	    }
	    if (atom.y2) {
	      atom.y3 = atom.y2;
	      delete atom.y2;
	    }
	    if (!atom.z3) {
	      atom.z3 = '0.0';
	    }
	    atom.complexAtom = a;
	  }

	  //    var nodeHText;

	  var chains = {};
	  //parse atoms in label order
	  var reorder = [];
	  for (i = 0; i < count; i++) {
	    reorder.push(i);
	  }
	  reorder.sort(function (a, b) {
	    return labels[a] - labels[b];
	  });
	  for (i = 0; i < count; i++) {
	    var atomCharge = 0;
	    var lLabel = labels[reorder[i]];
	    if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {

	      atom = atoms[reorder[i]];
	      var atomHtmlNode = null;

	      var atomFullNameStruct = new AtomName$1(atom.elementType, atomHtmlNode);

	      if (atom.sgroupRef) {
	        var countRef = atom.sgroupRef.length;
	        for (var k = 0; k < countRef; ++k) {
	          complex._sgroups.push(atom.sgroupRef[k]);
	        }
	      }

	      if (atom.x3 || atom.x2) {
	        var currAtomComp = this._unpackLabel(lLabel).compId;
	        // use ' ' by default instead of synthetic creation of chain names
	        var chainID = ' '; //= String.fromCharCode('A'.charCodeAt(0) + currAtomComp);
	        var resSeq = currAtomComp;
	        var iCode = ' ';
	        var strLabel = currAtomComp.toString();
	        if (strLabel.length === 1) {
	          strLabel = '0' + strLabel;
	        }
	        var resName = 'N' + strLabel;
	        var chain = chains[chainID];
	        if (!chain || chain.getName() !== chainID) {
	          chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
	          this._residue = null;
	        }

	        var residue = this._residue;
	        if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
	          this._residue = residue = chain.addResidue(resName, resSeq, iCode);
	        }

	        //_x, _y, _z, mname, mindex, atomNameFull, atomName, chainID, serial, isHet, atlLocInd, atomNameToTypeF
	        var xyz = null;
	        if (atom.x3) {
	          xyz = new Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
	        } else if (atom.x2) {
	          xyz = new Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
	        }
	        var element = Element$3.ByName[atom.elementType.toUpperCase()];
	        if (!element) {
	          element = JSON.parse(JSON.stringify(Element$3.ByName[Object.keys(Element$3.ByName)[Object.keys(Element$3.ByName).length - 1]]));
	          element.number += 1;
	          element.name = atom.elementType.toUpperCase();
	          element.fullName = 'Unknown';
	          Element$3.ByName[atom.elementType.toUpperCase()] = element;
	        }
	        var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10);
	        var added = residue.addAtom(atomFullNameStruct, element, xyz, Element$3.Role.SG, true, atomSerial, ' ', 1.0, 0.0, atomCharge);
	        if (atom.hydrogenCount) {
	          added._hydrogenCount = parseInt(atom.hydrogenCount, 10);
	        }
	        if (atom.mrvValence) {
	          added._valence = parseInt(atom.mrvValence, 10);
	        }
	        addFunc(added);
	      }
	    }
	  }
	  chains = null; //NOSONAR
	  for (i = 0; i < data.bonds.length; i++) {
	    var cb = data.bonds[i];
	    if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
	      atom = atoms[cb.start];
	      if (!atom || !atoms[cb.end]) {
	        continue; //skip invalid
	      }
	      this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ''), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10), cb.order, cb.type);
	    }
	  }

	  for (i = 0; i < this._complex.getSGroupCount(); i++) {
	    var sGrp = this._complex.getSGroups()[i];
	    for (j = 0; j < sGrp._atoms.length; j++) {
	      sGrp._atoms[j] = sGrp._atoms[j].complexAtom;
	    }
	  }
	  for (i = 0; i < count; i++) {
	    if (this._unpackLabel(labels[i]).molId === this._unpackLabel(currentLabel).molId) {
	      atom = atoms[i];
	      atom.complexAtom = null;
	      delete atom.complexAtom;
	    }
	  }
	  this._complex.originalCML = data.originalCML;
	  this._fixBondsArray();
	  complex.finalize({
	    needAutoBonding: false,
	    detectAromaticLoops: this.settings.now.aromatic,
	    enableEditing: this.settings.now.editing,
	    serialAtomMap: this._serialAtomMap
	  });
	  this._serialAtomMap = null;
	  this._complex = null;
	  return complex;
	};

	CMLParser.prototype.parseSync = function () {
	  // console.time('CML parse');

	  var complexes = [];
	  var self = this;
	  var moleculaSet = this._selectComponents(this._data);
	  moleculaSet.forEach(function (molSet) {
	    molSet.curr = 2;
	    if (molSet.count === 0) {
	      molSet.count = 1;
	    }
	    for (var i = 0; i < molSet.count; i++) {
	      molSet.curr = i + 1;
	      complexes.push(self._parseSet(molSet, false));
	    }
	  });
	  // console.timeEnd('CML parse');

	  var totalAtomsParsed = 0;
	  complexes.forEach(function (c) {
	    totalAtomsParsed += c.getAtomCount();
	  });
	  if (totalAtomsParsed <= 0) {
	    throw new Error('The data does not contain valid atoms');
	  }

	  if (complexes.length > 1) {
	    var joinedComplex = new Complex$2();
	    joinedComplex.joinComplexes(complexes);
	    joinedComplex.originalCML = complexes[0].originalCML;
	    return joinedComplex;
	  } else if (complexes.length === 1) {
	    return complexes[0];
	  } else {
	    return new Complex$2();
	  }
	};

	CMLParser.formats = ['cml'];
	CMLParser.extensions = ['.cml'];

	var mmtf = createCommonjsModule(function (module, exports) {
	!function(r,t){t(exports);}(commonjsGlobal,function(r){function t(r,t,n){for(var e=(r.byteLength,0),i=n.length;i>e;e++){var o=n.charCodeAt(e);if(128>o)r.setUint8(t++,o>>>0&127|0);else if(2048>o)r.setUint8(t++,o>>>6&31|192),r.setUint8(t++,o>>>0&63|128);else if(65536>o)r.setUint8(t++,o>>>12&15|224),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);else{if(!(1114112>o))throw new Error("bad codepoint "+o);r.setUint8(t++,o>>>18&7|240),r.setUint8(t++,o>>>12&63|128),r.setUint8(t++,o>>>6&63|128),r.setUint8(t++,o>>>0&63|128);}}}function n(r){for(var t=0,n=0,e=r.length;e>n;n++){var i=r.charCodeAt(n);if(128>i)t+=1;else if(2048>i)t+=2;else if(65536>i)t+=3;else{if(!(1114112>i))throw new Error("bad codepoint "+i);t+=4;}}return t}function e(r,i,o){var a=typeof r;if("string"===a){var u=n(r);if(32>u)return i.setUint8(o,160|u),t(i,o+1,r),1+u;if(256>u)return i.setUint8(o,217),i.setUint8(o+1,u),t(i,o+2,r),2+u;if(65536>u)return i.setUint8(o,218),i.setUint16(o+1,u),t(i,o+3,r),3+u;if(4294967296>u)return i.setUint8(o,219),i.setUint32(o+1,u),t(i,o+5,r),5+u}if(r instanceof Uint8Array){var u=r.byteLength,s=new Uint8Array(i.buffer);if(256>u)return i.setUint8(o,196),i.setUint8(o+1,u),s.set(r,o+2),2+u;if(65536>u)return i.setUint8(o,197),i.setUint16(o+1,u),s.set(r,o+3),3+u;if(4294967296>u)return i.setUint8(o,198),i.setUint32(o+1,u),s.set(r,o+5),5+u}if("number"===a){if(!isFinite(r))throw new Error("Number not finite: "+r);if(Math.floor(r)!==r)return i.setUint8(o,203),i.setFloat64(o+1,r),9;if(r>=0){if(128>r)return i.setUint8(o,r),1;if(256>r)return i.setUint8(o,204),i.setUint8(o+1,r),2;if(65536>r)return i.setUint8(o,205),i.setUint16(o+1,r),3;if(4294967296>r)return i.setUint8(o,206),i.setUint32(o+1,r),5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return i.setInt8(o,r),1;if(r>=-128)return i.setUint8(o,208),i.setInt8(o+1,r),2;if(r>=-32768)return i.setUint8(o,209),i.setInt16(o+1,r),3;if(r>=-2147483648)return i.setUint8(o,210),i.setInt32(o+1,r),5;throw new Error("Number too small -0x"+(-r).toString(16).substr(1))}if(null===r)return i.setUint8(o,192),1;if("boolean"===a)return i.setUint8(o,r?195:194),1;if("object"===a){var u,f=0,c=Array.isArray(r);if(c)u=r.length;else{var d=Object.keys(r);u=d.length;}var f;if(16>u?(i.setUint8(o,u|(c?144:128)),f=1):65536>u?(i.setUint8(o,c?220:222),i.setUint16(o+1,u),f=3):4294967296>u&&(i.setUint8(o,c?221:223),i.setUint32(o+1,u),f=5),c)for(var l=0;u>l;l++)f+=e(r[l],i,o+f);else for(var l=0;u>l;l++){var v=d[l];f+=e(v,i,o+f),f+=e(r[v],i,o+f);}return f}throw new Error("Unknown type "+a)}function i(r){var t=typeof r;if("string"===t){var e=n(r);if(32>e)return 1+e;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if(r instanceof Uint8Array){var e=r.byteLength;if(256>e)return 2+e;if(65536>e)return 3+e;if(4294967296>e)return 5+e}if("number"===t){if(Math.floor(r)!==r)return 9;if(r>=0){if(128>r)return 1;if(256>r)return 2;if(65536>r)return 3;if(4294967296>r)return 5;throw new Error("Number too big 0x"+r.toString(16))}if(r>=-32)return 1;if(r>=-128)return 2;if(r>=-32768)return 3;if(r>=-2147483648)return 5;throw new Error("Number too small -0x"+r.toString(16).substr(1))}if("boolean"===t||null===r)return 1;if("object"===t){var e,o=0;if(Array.isArray(r)){e=r.length;for(var a=0;e>a;a++)o+=i(r[a]);}else{var u=Object.keys(r);e=u.length;for(var a=0;e>a;a++){var s=u[a];o+=i(s)+i(r[s]);}}if(16>e)return 1+o;if(65536>e)return 3+o;if(4294967296>e)return 5+o;throw new Error("Array or object too long 0x"+e.toString(16))}throw new Error("Unknown type "+t)}function o(r){var t=new ArrayBuffer(i(r)),n=new DataView(t);return e(r,n,0),new Uint8Array(t)}function a(r,t,n){return t?new r(t.buffer,t.byteOffset,t.byteLength/(n||1)):void 0}function u(r){return a(DataView,r)}function s(r){return a(Uint8Array,r)}function f(r){return a(Int8Array,r)}function c(r){return a(Int32Array,r,4)}function d(r){return a(Float32Array,r,4)}function l(r,t){var n=r.length/2;t||(t=new Int16Array(n));for(var e=0,i=0;n>e;++e,i+=2)t[e]=r[i]<<8^r[i+1]<<0;return t}function v(r,t){var n=r.length;t||(t=new Uint8Array(2*n));for(var e=u(t),i=0;n>i;++i)e.setInt16(2*i,r[i]);return s(t)}function g(r,t){var n=r.length/4;t||(t=new Int32Array(n));for(var e=0,i=0;n>e;++e,i+=4)t[e]=r[i]<<24^r[i+1]<<16^r[i+2]<<8^r[i+3]<<0;return t}function L(r,t){var n=r.length;t||(t=new Uint8Array(4*n));for(var e=u(t),i=0;n>i;++i)e.setInt32(4*i,r[i]);return s(t)}function h(r,t){var n=r.length;t||(t=new Float32Array(n/4));for(var e=u(t),i=u(r),o=0,a=0,s=n/4;s>o;++o,a+=4)e.setFloat32(a,i.getFloat32(a),!0);return t}function y(r,t,n){var e=r.length,i=1/t;n||(n=new Float32Array(e));for(var o=0;e>o;++o)n[o]=r[o]*i;return n}function m(r,t,n){var e=r.length;n||(n=new Int32Array(e));for(var i=0;e>i;++i)n[i]=Math.round(r[i]*t);return n}function p(r,t){var n,e;if(!t){var i=0;for(n=0,e=r.length;e>n;n+=2)i+=r[n+1];t=new r.constructor(i);}var o=0;for(n=0,e=r.length;e>n;n+=2)for(var a=r[n],u=r[n+1],s=0;u>s;++s)t[o]=a,++o;return t}function U(r){if(0===r.length)return new Int32Array;var t,n,e=2;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]&&(e+=2);var i=new Int32Array(e),o=0,a=1;for(t=1,n=r.length;n>t;++t)r[t-1]!==r[t]?(i[o]=r[t-1],i[o+1]=a,a=1,o+=2):++a;return i[o]=r[r.length-1],i[o+1]=a,i}function b(r,t){var n=r.length;t||(t=new r.constructor(n)),n&&(t[0]=r[0]);for(var e=1;n>e;++e)t[e]=r[e]+t[e-1];return t}function I(r,t){var n=r.length;t||(t=new r.constructor(n)),t[0]=r[0];for(var e=1;n>e;++e)t[e]=r[e]-r[e-1];return t}function w(r,t){var n,e,i=r instanceof Int8Array?127:32767,o=-i-1,a=r.length;if(!t){var u=0;for(n=0;a>n;++n)r[n]<i&&r[n]>o&&++u;t=new Int32Array(u);}for(n=0,e=0;a>n;){for(var s=0;r[n]===i||r[n]===o;)s+=r[n],++n;s+=r[n],++n,t[e]=s,++e;}return t}function C(r,t){var n,e=t?127:32767,i=-e-1,o=r.length,a=0;for(n=0;o>n;++n){var u=r[n];0===u?++a:a+=u===e||u===i?2:u>0?Math.ceil(u/e):Math.ceil(u/i);}var s=t?new Int8Array(a):new Int16Array(a),f=0;for(n=0;o>n;++n){var u=r[n];if(u>=0)for(;u>=e;)s[f]=e,++f,u-=e;else for(;i>=u;)s[f]=i,++f,u-=i;s[f]=u,++f;}return s}function A(r,t){return b(p(r),t)}function x(r){return U(I(r))}function M(r,t,n){return y(p(r,c(n)),t,n)}function F(r,t){return U(m(r,t))}function S(r,t,n){return y(b(r,c(n)),t,n)}function E(r,t,n){return I(m(r,t),n)}function N(r,t,n){return y(w(r,c(n)),t,n)}function O(r,t,n){var e=w(r,c(n));return S(e,t,d(e))}function T(r,t,n){return C(E(r,t),n)}function k(r){var t=u(r),n=t.getInt32(0),e=t.getInt32(4),i=r.subarray(8,12),r=r.subarray(12);return [n,r,e,i]}function j(r,t,n,e){var i=new ArrayBuffer(12+e.byteLength),o=new Uint8Array(i),a=new DataView(i);return a.setInt32(0,r),a.setInt32(4,t),n&&o.set(n,8),o.set(e,12),o}function q(r){var t=r.length,n=s(r);return j(2,t,void 0,n)}function D(r){var t=r.length,n=L(r);return j(4,t,void 0,n)}function P(r,t){var n=r.length/t,e=L([t]),i=s(r);return j(5,n,e,i)}function z(r){var t=r.length,n=L(U(r));return j(6,t,void 0,n)}function B(r){var t=r.length,n=L(x(r));return j(8,t,void 0,n)}function V(r,t){var n=r.length,e=L([t]),i=L(F(r,t));return j(9,n,e,i)}function G(r,t){var n=r.length,e=L([t]),i=v(T(r,t));return j(10,n,e,i)}function R(r){var t={};return rr.forEach(function(n){void 0!==r[n]&&(t[n]=r[n]);}),r.bondAtomList&&(t.bondAtomList=D(r.bondAtomList)),r.bondOrderList&&(t.bondOrderList=q(r.bondOrderList)),t.xCoordList=G(r.xCoordList,1e3),t.yCoordList=G(r.yCoordList,1e3),t.zCoordList=G(r.zCoordList,1e3),r.bFactorList&&(t.bFactorList=G(r.bFactorList,100)),r.atomIdList&&(t.atomIdList=B(r.atomIdList)),r.altLocList&&(t.altLocList=z(r.altLocList)),r.occupancyList&&(t.occupancyList=V(r.occupancyList,100)),t.groupIdList=B(r.groupIdList),t.groupTypeList=D(r.groupTypeList),r.secStructList&&(t.secStructList=q(r.secStructList,1)),r.insCodeList&&(t.insCodeList=z(r.insCodeList)),r.sequenceIndexList&&(t.sequenceIndexList=B(r.sequenceIndexList)),t.chainIdList=P(r.chainIdList,4),r.chainNameList&&(t.chainNameList=P(r.chainNameList,4)),t}function H(r){function t(r){for(var t={},n=0;r>n;n++){var e=o();t[e]=o();}return t}function n(t){var n=r.subarray(a,a+t);return a+=t,n}function e(t){var n=r.subarray(a,a+t);a+=t;var e=65535;if(t>e){for(var i=[],o=0;o<n.length;o+=e)i.push(String.fromCharCode.apply(null,n.subarray(o,o+e)));return i.join("")}return String.fromCharCode.apply(null,n)}function i(r){for(var t=new Array(r),n=0;r>n;n++)t[n]=o();return t}function o(){var o,s,f=r[a];if(0===(128&f))return a++,f;if(128===(240&f))return s=15&f,a++,t(s);if(144===(240&f))return s=15&f,a++,i(s);if(160===(224&f))return s=31&f,a++,e(s);if(224===(224&f))return o=u.getInt8(a),a++,o;switch(f){case 192:return a++,null;case 194:return a++,!1;case 195:return a++,!0;case 196:return s=u.getUint8(a+1),a+=2,n(s);case 197:return s=u.getUint16(a+1),a+=3,n(s);case 198:return s=u.getUint32(a+1),a+=5,n(s);case 202:return o=u.getFloat32(a+1),a+=5,o;case 203:return o=u.getFloat64(a+1),a+=9,o;case 204:return o=r[a+1],a+=2,o;case 205:return o=u.getUint16(a+1),a+=3,o;case 206:return o=u.getUint32(a+1),a+=5,o;case 208:return o=u.getInt8(a+1),a+=2,o;case 209:return o=u.getInt16(a+1),a+=3,o;case 210:return o=u.getInt32(a+1),a+=5,o;case 217:return s=u.getUint8(a+1),a+=2,e(s);case 218:return s=u.getUint16(a+1),a+=3,e(s);case 219:return s=u.getUint32(a+1),a+=5,e(s);case 220:return s=u.getUint16(a+1),a+=3,i(s);case 221:return s=u.getUint32(a+1),a+=5,i(s);case 222:return s=u.getUint16(a+1),a+=3,t(s);case 223:return s=u.getUint32(a+1),a+=5,t(s)}throw new Error("Unknown type 0x"+f.toString(16))}var a=0,u=new DataView(r.buffer);return o()}function W(r,t,n,e){switch(r){case 1:return h(t);case 2:return f(t);case 3:return l(t);case 4:return g(t);case 5:return s(t);case 6:return p(g(t),new Uint8Array(n));case 7:return p(g(t));case 8:return A(g(t));case 9:return M(g(t),g(e)[0]);case 10:return O(l(t),g(e)[0]);case 11:return y(l(t),g(e)[0]);case 12:return N(l(t),g(e)[0]);case 13:return N(f(t),g(e)[0]);case 14:return w(l(t));case 15:return w(f(t))}}function X(r,t){t=t||{};var n=t.ignoreFields,e={};return nr.forEach(function(t){var i=n?-1!==n.indexOf(t):!1,o=r[t];i||void 0===o||(o instanceof Uint8Array?e[t]=W.apply(null,k(o)):e[t]=o);}),e}function J(r){return String.fromCharCode.apply(null,r).replace(/\0/g,"")}function K(r,t,n){n=n||{};var e,i,o,a,u,s,f=n.firstModelOnly,c=t.onModel,d=t.onChain,l=t.onGroup,v=t.onAtom,g=t.onBond,L=0,h=0,y=0,m=0,p=0,U=-1,b=r.chainNameList,I=r.secStructList,w=r.insCodeList,C=r.sequenceIndexList,A=r.atomIdList,x=r.bFactorList,M=r.altLocList,F=r.occupancyList,S=r.bondAtomList,E=r.bondOrderList;for(e=0,i=r.chainsPerModel.length;i>e&&!(f&&L>0);++e){var N=r.chainsPerModel[L];for(c&&c({chainCount:N,modelIndex:L}),o=0;N>o;++o){var O=r.groupsPerChain[h];if(d){var T=J(r.chainIdList.subarray(4*h,4*h+4)),k=null;b&&(k=J(b.subarray(4*h,4*h+4))),d({groupCount:O,chainIndex:h,modelIndex:L,chainId:T,chainName:k});}for(a=0;O>a;++a){var j=r.groupList[r.groupTypeList[y]],q=j.atomNameList.length;if(l){var D=null;I&&(D=I[y]);var P=null;r.insCodeList&&(P=String.fromCharCode(w[y]));var z=null;C&&(z=C[y]),l({atomCount:q,groupIndex:y,chainIndex:h,modelIndex:L,groupId:r.groupIdList[y],groupType:r.groupTypeList[y],groupName:j.groupName,singleLetterCode:j.singleLetterCode,chemCompType:j.chemCompType,secStruct:D,insCode:P,sequenceIndex:z});}for(u=0;q>u;++u){if(v){var B=null;A&&(B=A[m]);var V=null;x&&(V=x[m]);var G=null;M&&(G=String.fromCharCode(M[m]));var R=null;F&&(R=F[m]),v({atomIndex:m,groupIndex:y,chainIndex:h,modelIndex:L,atomId:B,element:j.elementList[u],atomName:j.atomNameList[u],formalCharge:j.formalChargeList[u],xCoord:r.xCoordList[m],yCoord:r.yCoordList[m],zCoord:r.zCoordList[m],bFactor:V,altLoc:G,occupancy:R});}m+=1;}if(g){var H=j.bondAtomList;for(u=0,s=j.bondOrderList.length;s>u;++u)g({atomIndex1:m-q+H[2*u],atomIndex2:m-q+H[2*u+1],bondOrder:j.bondOrderList[u]});}y+=1;}h+=1;}if(p=U+1,U=m-1,g&&S)for(u=0,s=S.length;s>u;u+=2){var W=S[u],X=S[u+1];(W>=p&&U>=W||X>=p&&U>=X)&&g({atomIndex1:W,atomIndex2:X,bondOrder:E?E[u/2]:null});}L+=1;}}function Q(r){return o(R(r))}function Y(r,t){r instanceof ArrayBuffer&&(r=new Uint8Array(r));var n;return n=r instanceof Uint8Array?H(r):r,X(n,t)}function Z(r,t,n,e){function i(){try{var r=Y(o.response);n(r);}catch(t){e(t);}}var o=new XMLHttpRequest;o.addEventListener("load",i,!0),o.addEventListener("error",e,!0),o.responseType="arraybuffer",o.open("GET",t+r.toUpperCase()),o.send();}function $(r,t,n){Z(r,or,t,n);}function _(r,t,n){Z(r,ar,t,n);}var rr=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],tr=["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"],nr=rr.concat(tr),er="v1.1.0dev",ir="//mmtf.rcsb.org/v1.0/",or=ir+"full/",ar=ir+"reduced/";r.encode=Q,r.decode=Y,r.traverse=K,r.fetch=$,r.fetchReduced=_,r.version=er,r.fetchUrl=or,r.fetchReducedUrl=ar,r.encodeMsgpack=o,r.encodeMmtf=R,r.decodeMsgpack=H,r.decodeMmtf=X;});
	});

	var Complex$3 = chem.Complex,
	    Chain$1 = chem.Chain,
	    Atom$1 = chem.Atom,
	    AtomName$2 = chem.AtomName,
	    Element$4 = chem.Element,
	    Helix$2 = chem.Helix,
	    Sheet$2 = chem.Sheet,
	    Strand$2 = chem.Strand,
	    Bond$3 = chem.Bond,
	    Assembly$2 = chem.Assembly,
	    Molecule$2 = chem.Molecule;

	function ArrayComparator(original) {
	  this._original = Array.from(original);
	  this._original.sort();

	  this._sum = 0;
	  for (var i = 0; i < this._original.length; ++i) {
	    this._sum += this._original[i];
	  }
	}

	ArrayComparator.prototype.constructor = ArrayComparator;

	ArrayComparator.prototype.compare = function (candidate) {
	  var len = candidate.length;
	  if (len !== this._original.length) {
	    return false;
	  }

	  var sum = 0,
	      i;
	  for (i = 0; i < len; ++i) {
	    sum += candidate[i];
	  }

	  if (sum !== this._sum) {
	    return false;
	  }

	  var sorted = Array.from(candidate);
	  sorted.sort();

	  for (i = 0; i < len; ++i) {
	    if (sorted[i] !== this._original[i]) {
	      return false;
	    }
	  }

	  return true;
	};

	function MMTFParser(data, options) {
	  Parser.call(this, data, options);

	  this._options.fileType = 'mmtf';
	}

	////////////////////////////////////////////////////////////////////////////
	// Inheritance

	MMTFParser.prototype = Object.create(Parser.prototype);
	MMTFParser.prototype.constructor = MMTFParser;

	////////////////////////////////////////////////////////////////////////////
	// Class methods

	/** @deprecated */
	MMTFParser.canParse = function (data, options) {
	  if (!data) {
	    return false;
	  }

	  return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options, 'mmtf');
	};

	function getFirstByte(buf) {
	  var bytes = new Uint8Array(buf, 0, 1);
	  return bytes[0];
	}

	MMTFParser.canProbablyParse = function (data) {
	  // check if it's binary MessagePack format containing a map (dictionary)
	  // see https://github.com/msgpack/msgpack/blob/master/spec.md
	  return lodash.isArrayBuffer(data) && (getFirstByte(data) | 1) === 0xDF;
	};

	MMTFParser.prototype._onModel = function (_modelData) {};

	MMTFParser.prototype._onChain = function (chainData) {
	  if (chainData.modelIndex !== 0) {
	    return;
	  }

	  var chain = new Chain$1(this._complex, chainData.chainName);
	  this._complex._chains[chainData.chainIndex] = chain;
	  chain._index = chainData.chainIndex;
	};

	MMTFParser.prototype._onGroup = function (groupData) {
	  if (groupData.modelIndex !== 0) {
	    return;
	  }

	  if (this.settings.now.nowater) {
	    // skip water
	    if (groupData.groupName === 'HOH' || groupData.groupName === 'WAT') {
	      return;
	    }
	  }

	  var chain = this._complex._chains[groupData.chainIndex];
	  var icode = !groupData.insCode.charCodeAt(0) ? '' : groupData.insCode;
	  var residue = chain.addResidue(groupData.groupName, groupData.groupId, icode);
	  residue._index = groupData.groupIndex;

	  this._updateSecStructure(this._complex, residue, groupData);
	};

	MMTFParser.prototype._onAtom = function (atomData) {
	  if (atomData.modelIndex !== 0) {
	    return;
	  }

	  var altLoc = !atomData.altLoc.charCodeAt(0) ? '' : atomData.altLoc;
	  var atom = new Atom$1(atomData.groupIndex, // we store residue index here to replace it later with actual reference
	  new AtomName$2(atomData.atomName), Element$4.getByName(atomData.element.toUpperCase()), new Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord), Element$4.Role[atomData.atomName], false, // hetero atoms will be marked later
	  atomData.atomId, altLoc, atomData.occupancy, atomData.bFactor, atomData.formalCharge);

	  this._complex._atoms[atomData.atomIndex] = atom;
	  atom._index = atomData.atomIndex;

	  this._serialAtomMap[atomData.atomId] = atom;
	};

	MMTFParser.prototype._onBond = function (bondData) {
	  var right = Math.max(bondData.atomIndex1, bondData.atomIndex2);
	  if (right >= this._complex._atoms.length) {
	    return;
	  }
	  var left = Math.min(bondData.atomIndex1, bondData.atomIndex2);
	  this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, Bond$3.BondType.UNKNOWN, true);
	};

	var StructuralElementType$5 = StructuralElement.Type;

	// see https://github.com/rcsb/mmtf-javascript/blob/master/src/mmtf-traverse.js
	var secStructToType = [StructuralElementType$5.HELIX_PI, // 0
	StructuralElementType$5.BEND, // 1
	StructuralElementType$5.HELIX_ALPHA, // 2
	StructuralElementType$5.STRAND, // 3
	StructuralElementType$5.HELIX_310, // 4
	StructuralElementType$5.BRIDGE, // 5
	StructuralElementType$5.TURN, // 6
	StructuralElementType$5.COIL];

	MMTFParser.prototype._updateSecStructure = function (complex, residue, groupData) {
	  var helixClasses = [3, -1, 1, -1, 5];

	  if (!lodash.isUndefined(groupData) && groupData.secStruct === this._ssType) {
	    residue._secondary = this._ssStruct;
	    if (this._ssStruct) {
	      this._ssStruct.term = residue;
	    }
	    return;
	  }

	  if (!lodash.isUndefined(groupData)) {
	    // start new secondary structure
	    var type = secStructToType[groupData.secStruct];
	    this._ssType = groupData.secStruct;
	    this._ssStart = residue;

	    var struct = null;
	    switch (this._ssType) {
	      case -1: // undefined
	      case 7:
	        // coil
	        break;
	      case 0: // pi helix
	      case 2: // alpha helix
	      case 4:
	        // 3-10 helix
	        struct = new Helix$2(helixClasses[this._ssType], residue, residue, 0, '', '', 0);
	        complex._helices.push(struct);
	        break;
	      case 3:
	        // extended
	        var sheet = new Sheet$2('', 0);
	        complex._sheets.push(sheet);
	        struct = new Strand$2(sheet, residue, residue, 0, null, null);
	        break;
	      default:
	        if (type !== undefined) {
	          struct = new StructuralElement(type, residue, residue);
	        }
	        break;
	    }

	    this._ssStruct = struct;
	    residue._secondary = struct;
	    if (struct) {
	      complex.structures.push(struct);
	    }
	  }
	};

	MMTFParser.prototype._updateMolecules = function (mmtfData) {
	  var entities = mmtfData.entityList;
	  if (!entities) {
	    return;
	  }

	  var chainsInModel0 = mmtfData.chainsPerModel[0];
	  for (var i = 0; i < entities.length; i++) {
	    var entity = entities[i];
	    var chains = entity.chainIndexList;
	    var residues = [];
	    for (var j = 0; j < chains.length; j++) {
	      var chainIndex = chains[j];
	      // skip chains in models other than the first one
	      if (chainIndex >= chainsInModel0) {
	        continue;
	      }
	      var chain = this._complex._chains[chainIndex];
	      residues = residues.concat(chain._residues.slice());
	    }
	    var molecule = new Molecule$2(this._complex, entity.description, i + 1);
	    molecule._residues = residues;
	    this._complex._molecules[i] = molecule;
	  }
	};

	// populate complex with chains, residues and atoms
	MMTFParser.prototype._traverse = function (mmtfData) {
	  var self = this;

	  // get metadata
	  var metadata = this._complex.metadata;
	  metadata.id = mmtfData.structureId;
	  metadata.title = [];
	  metadata.title[0] = mmtfData.title;
	  metadata.date = mmtfData.releaseDate;
	  metadata.format = 'mmtf';

	  // create event callback functions
	  var eventCallbacks = {
	    onModel: function onModel(modelData) {
	      self._onModel(modelData);
	    },
	    onChain: function onChain(chainData) {
	      self._onChain(chainData);
	    },
	    onGroup: function onGroup(groupData) {
	      self._onGroup(groupData);
	    },
	    onAtom: function onAtom(atomData) {
	      self._onAtom(atomData);
	    },
	    onBond: function onBond(bondData) {
	      self._onBond(bondData);
	    }
	  };

	  // temporary variables used during traversal to track secondary structures
	  this._ssType = -1;
	  this._ssStruct = null;
	  this._ssStart = null;

	  // traverse the structure and listen to the events
	  mmtf.traverse(mmtfData, eventCallbacks);

	  this._updateSecStructure(this._complex);
	  this._updateMolecules(mmtfData);
	};

	// During traversal atoms and residues don't come sequentially
	// so a residue for certain atom can be unavailable. Thus we
	// store residue index in atom.
	// This function being called after traversal replaces the index
	// with actual reference, and also populates atom lists in residues.
	MMTFParser.prototype._linkAtomsToResidues = function () {
	  for (var i = 0; i < this._complex._atoms.length; ++i) {
	    var atom = this._complex._atoms[i];
	    var residue = this._complex._residues[atom._residue];
	    atom._residue = residue;
	    residue._atoms.push(atom);
	  }
	};

	MMTFParser.prototype._findSynonymousChains = function () {
	  var named = {};
	  for (var i = 0; i < this._complex._chains.length; ++i) {
	    var chain = this._complex._chains[i];
	    var name = chain.getName();
	    if (!named.hasOwnProperty(name)) {
	      named[name] = [];
	    }

	    named[name].push(chain._index);
	  }

	  return named;
	};

	// NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.
	MMTFParser.prototype._parseAssemblyInfo = function (mmtfData) {
	  var i, j, k;
	  var assemblies = [];
	  var logger = this.logger;

	  for (i = 0; i < mmtfData.bioAssemblyList.length; ++i) {
	    var baInfo = mmtfData.bioAssemblyList[i];
	    if (baInfo.transformList.length === 0) {
	      continue;
	    }

	    var chains = baInfo.transformList[0].chainIndexList;
	    var chainListCheck = new ArrayComparator(chains);

	    // build list of chain names
	    var chainNames = {};
	    for (j = 0; j < chains.length; ++j) {
	      chainNames[this._complex._chains[chains[j]].getName()] = 1;
	    }

	    // all chains with the same name should belong to assembly if one of them belongs
	    var allChains = [];
	    var name;
	    for (name in chainNames) {
	      if (chainNames.hasOwnProperty(name)) {
	        // just concat arrays -- there should be no duplicates
	        Array.prototype.push.apply(allChains, this._chainsByName[name]);
	      }
	    }
	    if (!chainListCheck.compare(allChains)) {
	      // assembly is missing some of the chains
	      logger.debug('MMTF: Assembly is missing some of the synonymous chains. Skipping...');
	    }

	    var a = new Assembly$2(this._complex);

	    // add chains to assembly
	    for (name in chainNames) {
	      if (chainNames.hasOwnProperty(name)) {
	        a.addChain(name);
	      }
	    }

	    // add unique matrices to assembly
	    a.addMatrix(new Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());
	    for (j = 1; j < baInfo.transformList.length; ++j) {
	      var transform = baInfo.transformList[j];

	      if (!chainListCheck.compare(transform.chainIndexList)) {
	        // list of chains for this transform doesn't match that for other transforms
	        // this is illegal in our structure
	        logger.debug('MMTF: Chain lists differ for different transforms in one assembly. Skipping...');
	        continue;
	      }

	      var m = new Matrix4().fromArray(transform.matrix).transpose();

	      // check if matrix is already in the list
	      for (k = 0; k < a.matrices.length; ++k) {
	        if (a.matrices[k].equals(m)) {
	          break;
	        }
	      }

	      if (k === a.matrices.length) {
	        a.addMatrix(m);
	      }
	    }

	    a.finalize();
	    assemblies.push(a);
	  }

	  return assemblies;
	};

	// NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.
	MMTFParser.prototype._markHeteroAtoms = function (mmtfData) {
	  var chainsInModel0 = mmtfData.chainsPerModel[0];
	  for (var i = 0; i < mmtfData.entityList.length; ++i) {
	    var entity = mmtfData.entityList[i];
	    if (entity.type !== 'polymer') {
	      for (var j = 0; j < entity.chainIndexList.length; ++j) {
	        var chainIndex = entity.chainIndexList[j];
	        // skip chains in models other than the first one
	        if (chainIndex >= chainsInModel0) {
	          continue;
	        }
	        var chain = this._complex._chains[chainIndex];
	        for (var k = 0; k < chain._residues.length; ++k) {
	          var res = chain._residues[k];
	          for (var m = 0; m < res._atoms.length; ++m) {
	            res._atoms[m]._het = true;
	          }
	        }
	      }
	    }
	  }
	};

	// joins chains with the same name into single chain
	MMTFParser.prototype._joinSynonymousChains = function () {
	  var i, j;

	  var primaryChainsArray = [];
	  var primaryChainsHash = {};

	  // join chains
	  for (i = 0; i < this._complex._chains.length; ++i) {
	    var chain = this._complex._chains[i];
	    var name = chain.getName();
	    if (!primaryChainsHash.hasOwnProperty(name)) {
	      // new name -- this is a primary chain
	      primaryChainsHash[name] = chain;
	      chain._index = primaryChainsArray.length; // update index as this array will later replace original chain list
	      primaryChainsArray.push(chain);
	      continue;
	    }

	    // this chain should be joined with the primary chain of the same name
	    var primary = primaryChainsHash[name];
	    for (j = 0; j < chain._residues.length; ++j) {
	      var residue = chain._residues[j];
	      primary._residues.push(residue);
	      residue._chain = primary;
	    }
	  }

	  // replace chains list with one containing only primary chains
	  // dropping references to all chains but primary
	  this._complex._chains = primaryChainsArray;
	};

	MMTFParser.prototype.parseSync = function () {
	  var mmtfData = mmtf.decode(this._data);

	  this._complex = new Complex$3();
	  this._serialAtomMap = {}; // filled during traversal

	  this._traverse(mmtfData);
	  this._linkAtomsToResidues();
	  this._markHeteroAtoms(mmtfData);
	  this._chainsByName = this._findSynonymousChains();
	  Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));
	  this._joinSynonymousChains();

	  this._complex.finalize({
	    needAutoBonding: false,
	    detectAromaticLoops: this.settings.now.aromatic,
	    enableEditing: this.settings.now.editing,
	    serialAtomMap: this._serialAtomMap
	  });

	  return this._complex;
	};

	MMTFParser.formats = ['mmtf'];
	MMTFParser.extensions = ['.mmtf'];
	MMTFParser.binary = true;

	var Complex$4 = chem.Complex,
	    Element$5 = chem.Element,
	    Helix$3 = chem.Helix,
	    Sheet$3 = chem.Sheet,
	    Strand$3 = chem.Strand,
	    Assembly$3 = chem.Assembly,
	    Molecule$3 = chem.Molecule;

	var cRequiredAtomFields = ['auth_seq_id', 'Cartn_x', 'Cartn_y', 'Cartn_z', 'label_atom_id'];

	var cSecondaryCoding = {
	  helx: 'helix',
	  turn: 'turn',
	  strn: 'strand'
	};

	function getTypeFromId(string) {
	  var typeId = /[A-Za-z]+/.exec(string);
	  if (!typeId) {
	    return null;
	  }

	  return cSecondaryCoding[typeId[0].toLowerCase()];
	}

	/**
	 * Make valid object an array
	 * @param arrayLikeObject
	 * @return {array, object} array or object
	 */
	function arrize(arrayLikeObject) {
	  if (arrayLikeObject === null || arrayLikeObject === undefined || lodash.isArray(arrayLikeObject)) {
	    return arrayLikeObject;
	  }
	  return [arrayLikeObject];
	}

	function nameToElement$1(name) {
	  // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
	  //
	  // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
	  //
	  // Atom names start with element symbols right-justified in columns 13-14
	  // as permitted by the length of the name. For example, the symbol FE for
	  // iron appears in columns 13-14, whereas the symbol C for carbon appears
	  // in column 14 (see Misaligned Atom Names). If an atom name has four
	  // characters, however, it must start in column 13 even if the element
	  // symbol is a single character (for example, see Hydrogen Atoms).

	  var veryLong = name.trim().length === 4;
	  return name.slice(0, veryLong ? 1 : 2).trim();
	}

	function CIFParser(data, options) {
	  Parser.call(this, data, options);
	  this.asymDict = {};
	  this.molecules = [];
	  this._options.fileType = 'cif';
	}

	////////////////////////////////////////////////////////////////////////////
	// Inheritance

	CIFParser.prototype = Object.create(Parser.prototype);
	CIFParser.prototype.constructor = CIFParser;

	////////////////////////////////////////////////////////////////////////////
	// Class methods

	/** @deprecated */
	CIFParser.canParse = function (data, options) {
	  if (!data) {
	    return false;
	  }
	  return typeof data === 'string' && Parser.checkDataTypeOptions(options, 'cif');
	};

	CIFParser.canProbablyParse = function (data) {
	  return lodash.isString(data) && /^\s*data_/i.test(data);
	};

	CIFParser.prototype.parseSync = function () {
	  this.logger.info('Parsing CIF file..');
	  var ret = CIFParser._parseToObject(this._data);
	  if (ret.error) {
	    throw new Error(ret.error.message);
	  }
	  return this._toComplex(ret.data);
	};

	/**
	 * Convert intermediate structure into our valid Complex object
	 * @param cifData intermediate CIF object
	 * @returns {Complex} complex
	 * @private
	 */
	CIFParser.prototype._toComplex = function (cifData) {
	  var complex = new Complex$4();
	  var complexData = cifData[Object.keys(cifData)[0]];
	  this._extractAtoms(complex, complexData);
	  this._extractSecondary(complex, complexData);
	  this._extractAssemblies(complex, complexData);
	  this._extractMolecules(complex, complexData);
	  this._extractMetadata(complex, complexData);
	  complex.finalize({
	    needAutoBonding: true,
	    detectAromaticLoops: this.settings.now.aromatic,
	    enableEditing: this.settings.now.editing
	  });

	  return complex;
	};

	function AtomDataError(message) {
	  Error.call(this);
	  this.name = 'AtomDataError';
	  this.message = message;
	}

	AtomDataError.prototype = Object.create(Error.prototype);

	/**
	 * Extract metadata
	 * @param complex structure to fill
	 * @param complexData complex data from CIF file
	 * @private
	 */
	CIFParser.prototype._extractMetadata = function (complex, complexData) {
	  var metadata = complex.metadata;
	  metadata.id = complexData.entry.id;
	  metadata.classification = complexData.struct_keywords.pdbx_keywords;
	  var databaserev = complexData.database_PDB_rev;
	  metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : '';
	  metadata.format = 'cif';
	  metadata.title = [];
	  metadata.title[0] = complexData.struct.title;
	};

	/**
	 * Extract molecules information from CIF structure (should be called strictly after _extractAtoms)
	 * @param complexData complex data from CIF file
	 * @private
	 */
	CIFParser.prototype._extractMolecules = function (complex, complexData) {
	  var molData = complexData.entity;
	  var names = arrize(molData.pdbx_description);
	  var count = names.length;
	  var i;

	  // molecules names from cif
	  for (i = 0; i < count; i++) {
	    this.molecules[i].name = names[i];
	  }

	  // reorganize molecules for complex and check chains
	  var molecules = complex.getMolecules();
	  for (i = 0; i < count; i++) {
	    var molecule = this.molecules[i];
	    molecules[i] = new Molecule$3(complex, molecule.name, i + 1);
	    molecules[i]._residues = molecule.residues;
	  }
	};

	/**
	 * Extract atom information from CIF structure and fill complex
	 * @param {Complex} complex
	 * @param complexData complex data from CIF file
	 * @private
	 */
	CIFParser.prototype._extractAtoms = function (complex, complexData) {
	  var atomData = complexData.atom_site;
	  if (!atomData) {
	    throw new AtomDataError('CIF parsing error: atom_site is not specified!');
	  }

	  // TODO also add length chacks?
	  for (var f = 0, n = cRequiredAtomFields.length; f < n; ++f) {
	    if (!atomData[cRequiredAtomFields[f]]) {
	      throw new AtomDataError('CIF parsing error: requires field ' + cRequiredAtomFields[f] + ' not found!');
	    }
	  }

	  var asymDict = this.asymDict;
	  // required fields
	  var resIdc = arrize(atomData.auth_seq_id);
	  var x = arrize(atomData.Cartn_x);
	  var y = arrize(atomData.Cartn_y);
	  var z = arrize(atomData.Cartn_z);
	  var names = arrize(atomData.label_atom_id);
	  var count = names.length;
	  // optional fields
	  var group = arrize(atomData.group_PDB) || [];
	  var chainIdc = arrize(atomData.auth_asym_id) || [];
	  var chainLabelIdc = arrize(atomData.label_asym_id) || [];
	  var serials = arrize(atomData.id) || [];
	  var iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
	  var resNames = arrize(atomData.label_comp_id) || [];
	  var elements = arrize(atomData.type_symbol) || [];
	  var tempFactors = arrize(atomData.B_iso_or_equiv) || [];
	  var occupancies = arrize(atomData.occupancy) || [];
	  var charges = arrize(atomData.pdbx_formal_charge) || [];
	  var altLocs = arrize(atomData.label_alt_id) || [];
	  var models = arrize(atomData.pdbx_PDB_model_num) || [];
	  var molecules = arrize(atomData.label_entity_id) || [];

	  var chain = null;
	  var residue = null;
	  for (var i = 0; i < count; ++i) {
	    var model = models[i] || 1;
	    if (model !== 1) {
	      continue;
	    }
	    var chainID = String(chainIdc[i] || ' ');

	    if (!chain || chain.getName() !== chainID) {
	      chain = complex.getChain(chainID) || complex.addChain(chainID);
	    }
	    asymDict[String(chainLabelIdc[i] || ' ')] = chainID;
	    var resSeq = resIdc[i];
	    var iCode = String(iCodes[i] || ' ');
	    var resName = String(resNames[i] || '');
	    if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
	      residue = chain.addResidue(resName, resSeq, iCode);

	      // store molecule (entity)
	      var moleculeIdx = molecules[i] - 1;
	      var entity = this.molecules[moleculeIdx];
	      if (!entity) {
	        this.molecules[moleculeIdx] = { name: '', residues: [] };
	        entity = this.molecules[moleculeIdx];
	      }
	      entity.residues.push(residue);
	    }

	    var name = names[i];
	    var element = elements[i] || nameToElement$1(name);
	    var type = Element$5.getByName(element);
	    var role = Element$5.Role[name.trim()];
	    var xyz = new Vector3(x[i], y[i], z[i]);
	    var het = group[i] === 'HETATM' || false;
	    var serial = serials[i] || i;
	    var tempFactor = tempFactors[i] || 0.0;
	    var occupancy = occupancies[i] || 0.0;
	    var altLoc = String(altLocs[i] || '');
	    var charge = charges[i] || 0;

	    residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
	  }
	};

	/**
	 * Extracts secondary structure information from CIF intermediate data
	 * and adds it into complex
	 * @param {Complex} complex - complex to fill
	 * @param complexData - CIF complex data
	 * @private
	 */
	CIFParser.prototype._extractSecondary = function (complex, complexData) {
	  if (complexData.struct_conf) {
	    this._extractConfs(complex, complexData.struct_conf);
	  }
	  if (complexData.struct_sheet_range) {
	    this._extractSheets(complex, complexData.struct_sheet_range);
	  }
	};

	/**
	 * Extracts sheets information from CIF intermediate data
	 * and adds it into complex
	 * @param {Complex} complex
	 * @param sheetData
	 * @private
	 */
	CIFParser.prototype._extractSheets = function (complex, sheetData) {
	  var asymDict = this.asymDict;
	  if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
	    return;
	  }
	  //Strand(sheet, start, end, sense, cur, prev)
	  var sheets = complex._sheets;
	  function getSheet(name) {
	    var i = 0,
	        n = sheets.length;
	    for (; i < n; ++i) {
	      if (sheets[i]._name === name) {
	        return sheets[i];
	      }
	    }
	    sheets[n] = new Sheet$3(name, 0);
	    return sheets[n];
	  }

	  var sheetNames = arrize(sheetData.sheet_id);
	  var strandNames = arrize(sheetData.id);
	  var starts = arrize(sheetData.beg_auth_seq_id);
	  var ends = arrize(sheetData.end_auth_seq_id);
	  var chains = arrize(sheetData.beg_label_asym_id);
	  var stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
	  var endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];

	  for (var i = 0, n = strandNames.length; i < n; ++i) {
	    var chain = complex.getChain(asymDict[chains[i]]);
	    var sheet = getSheet(sheetNames[i]);
	    var startIdx = starts[i];
	    var endIdx = ends[i];
	    var startICode = stICodes[i] || ' ';
	    var endICode = endICodes[i] || ' ';

	    var start = chain.findResidue(startIdx, startICode);
	    var end = chain.findResidue(endIdx, endICode);

	    // TODO think about last condition
	    if (!start || !end) {
	      continue;
	    }

	    var strand = new Strand$3(sheet, start[0], end[0], 0, null, null);
	    var residues = chain.getResidues();
	    for (var r = start[1]; r <= end[1]; ++r) {
	      residues[r]._secondary = strand;
	    }
	    sheet.addStrand(strand);
	    complex.structures.push(strand);
	  }
	};

	/**
	 * Extracts helix/turn/strand(?) information from CIF intermediate data
	 * and adds it into complex
	 * @param {Complex} complex
	 * @param helicesData
	 * @private
	 */
	CIFParser.prototype._extractConfs = function (complex, helicesData) {
	  var asymDict = this.asymDict;
	  if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
	    return;
	  }

	  var types = arrize(helicesData.conf_type_id);
	  var starts = arrize(helicesData.beg_auth_seq_id);
	  var stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
	  var ends = arrize(helicesData.end_auth_seq_id);
	  var endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
	  var comments = arrize(helicesData.details) || [];
	  var lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
	  var helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
	  var names = arrize(helicesData.id) || [];
	  var chains = arrize(helicesData.beg_label_asym_id);

	  for (var i = 0, n = types.length; i < n; ++i) {
	    var type = getTypeFromId(types[i]);
	    if (!type) {
	      continue;
	    }
	    var name = names[i] || types[i];
	    var chain = complex.getChain(asymDict[chains[i]]);

	    var startIdx = starts[i];
	    var endIdx = ends[i];
	    var startICode = stICodes[i] || ' ';
	    var endICode = endICodes[i] || ' ';

	    var start = chain.findResidue(startIdx, startICode);
	    var end = chain.findResidue(endIdx, endICode);

	    // TODO think about last condition
	    if (!start || !end) {
	      continue;
	    }
	    var comment = comments[i] || '';
	    var length = lengths[i] || 0;
	    var helixClass = helixClasses[i] || ' ';
	    var struct;
	    // TODO Add turns and strands(!)?
	    if (type === 'helix') {
	      var idx = complex._helices.length;
	      struct = new Helix$3(helixClass, start[0], end[0], idx, name, comment, length);
	      complex.addHelix(struct);
	      complex.structures.push(struct);
	    } else if (type === 'turn') {
	      struct = new StructuralElement(StructuralElement.Type.TURN, start[0], end[0]);
	      complex.structures.push(struct);
	    } else {
	      struct = null;
	    }
	    if (!struct) {
	      continue;
	    }
	    var residues = chain.getResidues();
	    for (var r = start[1]; r <= end[1]; ++r) {
	      residues[r]._secondary = struct;
	    }
	  }
	};

	function _getOperations(operList) {
	  if (!operList) {
	    return null;
	  }
	  var idc = arrize(operList.id);
	  var matrix = operList.matrix;
	  var vector = operList.vector;
	  if (!idc || !matrix || !vector) {
	    return null;
	  }

	  var ops = [];
	  for (var i = 0, n = idc.length; i < n; ++i) {
	    var mtx = new Matrix4();
	    var elements = mtx.elements;

	    for (var row = 0; row < 3; ++row) {
	      var matrixData = matrix[row + 1];
	      elements[row] = arrize(matrixData[1])[i];
	      elements[row + 4] = arrize(matrixData[2])[i];
	      elements[row + 8] = arrize(matrixData[3])[i];
	      elements[row + 12] = arrize(vector[row + 1])[i];
	    }
	    ops[idc[i]] = mtx;
	  }

	  return ops;
	}

	function _extractOperations(assemblyGen, opsDict) {
	  assemblyGen = lodash.isString(assemblyGen) ? assemblyGen : '' + assemblyGen;
	  var l = assemblyGen.replace(/\)\s*\(/g, '!').replace(/[()']/g, '');
	  var groupStr = l.split('!');
	  var gps = [];

	  for (var grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
	    var gr = groupStr[grIdx].split(',');
	    var gp = [];
	    var idx = 0;
	    for (var i = 0, n = gr.length; i < n; ++i) {
	      var s = gr[i];
	      if (s.includes('-')) {
	        var es = s.split('-');
	        var j = parseInt(es[0], 10);
	        var m = parseInt(es[1], 10);
	        for (; j <= m; ++j) {
	          gp[idx++] = opsDict[j];
	        }
	      } else {
	        gp[idx++] = opsDict[s];
	      }
	    }
	    gps.push(gp);
	  }

	  // traverse all groups from the end of array and make all mults
	  var matrices = [];
	  var cnt = 0;
	  function traverse(level, mtx) {
	    for (var ii = 0, nn = gps[level].length; ii < nn; ++ii) {
	      var newMtx = mtx ? mtx.clone() : new Matrix4();
	      newMtx.multiplyMatrices(gps[level][ii], newMtx);
	      if (level === 0) {
	        matrices[cnt++] = newMtx;
	      } else {
	        traverse(level - 1, newMtx);
	      }
	    }
	  }

	  traverse(gps.length - 1);
	  return matrices;
	}

	/**
	 * Extract biological assemblies information from CIF structure and fill complex
	 * @param {Complex} complex
	 * @param complexData complex data from CIF file
	 * @private
	 */
	CIFParser.prototype._extractAssemblies = function (complex, complexData) {
	  var asymDict = this.asymDict;
	  var asmGen = complexData.pdbx_struct_assembly_gen;
	  if (!asmGen) {
	    return;
	  }

	  var asmIdx = arrize(asmGen.assembly_id);
	  var asmOper = arrize(asmGen.oper_expression);
	  var asmList = arrize(asmGen.asym_id_list);
	  if (!asmIdx || !asmOper || !asmList) {
	    return;
	  }

	  var operList = _getOperations(complexData.pdbx_struct_oper_list);
	  if (!operList) {
	    return;
	  }

	  for (var i = 0, n = asmIdx.length; i < n; ++i) {
	    var asm = new Assembly$3(complex);
	    var assemblyOps = _extractOperations(asmOper[i], operList);
	    var entries = asmList[i].split(',');
	    for (var ii = 0, nn = entries.length; ii < nn; ++ii) {
	      var chain = entries[ii].trim();
	      if (chain.length > 0) {
	        asm.addChain(asymDict[chain]);
	      }
	    }
	    asm.matrices = assemblyOps;
	    complex.units.push(asm);
	  }
	};

	CIFParser._parseToObject = function (source) {
	  var i = 0,
	      j = 0,
	      n = source.length;
	  var code = NaN,
	      newline = true,
	      line = 1,
	      column = 1,
	      begin;
	  var state = 0; // -1 - stop, 0 - start, 1 - block, 2 - item, 3 - loop, 4 - values, 5 - value, 666 - error
	  var err = 'unexpected character';
	  var result = {},
	      block = {};
	  var keys = [],
	      keysCount = 0,
	      key = '';
	  var values = [],
	      valuesCount = 0,
	      value;

	  function _isWhitespace(ch) {
	    return ch === 32 || ch === 10 || ch === 13 || ch === 9;
	  }

	  function _inlineIndexOf(ch0, str, idx) {
	    var len = str.length;
	    var ch = -1;
	    while (idx < len) {
	      ch = str.charCodeAt(idx);
	      if (ch === ch0 || ch === 10) {
	        break;
	      }
	      ++idx;
	    }
	    return ch === ch0 ? idx : -1;
	  }

	  function _parseValue() {
	    var val;
	    if ((code === 46 || code === 63) && (i + 1 >= n || _isWhitespace(source.charCodeAt(i + 1)))) {
	      // '.' or '?' .....
	      // it's a missing value
	      ++column;
	      ++i;
	      return undefined;
	    } else if (newline && code === 59) {
	      // ';' ......................................................................
	      // parse multi-line string
	      j = i;
	      var lines = 0;
	      do {
	        j = _inlineIndexOf(10, source, j + 1); // '\n'
	        if (j === -1) {
	          err = 'unterminated text block found';
	          return null;
	        }
	        ++lines;
	      } while (j + 1 < n && source.charCodeAt(j + 1) !== code || j + 1 >= n);
	      val = source.substring(i + 1, j).replace(/\r/g, '');
	      i = j + 2;
	      line += lines;
	      column = 1;
	      newline = false;
	      return val;
	    } else if (code === 39 || code === 34) {
	      // ''' or '"' ...........................................................
	      // parse quoted string
	      j = i;
	      do {
	        j = _inlineIndexOf(code, source, j + 1);
	        if (j === -1) {
	          err = 'unterminated quoted string found';
	          return null;
	        }
	      } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)));
	      val = source.substring(i + 1, j);
	      column += j - i + 1;
	      i = j + 1;
	      return val;
	    } else {
	      // ......................................................................................................
	      // parse until the first whitespace
	      j = i;
	      while (j < n && !_isWhitespace(source.charCodeAt(j))) {
	        ++j;
	      }
	      val = source.substring(i, j);
	      column += j - i;
	      i = j;
	      // try to convert to a number
	      var num = Number(val);
	      if (!Number.isNaN(num)) {
	        return num;
	      }
	      // or leave as an unquoted string
	      return val;
	    }
	  }

	  function _storeKey(tag) {
	    keys[keysCount++] = tag;
	  }

	  function _storeValue(val) {
	    var keyIndex;
	    keyIndex = valuesCount % keysCount;
	    values[keyIndex].push(val);
	    ++valuesCount;
	    return val;
	  }

	  while (i <= n) {
	    code = source.charCodeAt(i); // 'NaN' in place of '<eof>'
	    if (code === 13) ; else if (code === 10) {
	      // '\n' ................................................................................
	      // take note of new lines
	      newline = true;
	      ++line;
	      column = 1;
	    } else {
	      // process inline characters
	      if (code === 32 || code === 9) ; else if (code === 35) {
	        // '#' ...............................................................................
	        // skip the comment until before the end of the line
	        i = _inlineIndexOf(10, source, i + 1); // '\n'
	        if (i === -1) {
	          break;
	        } else {
	          continue; // don't forget to process the new line
	        }
	      } else if (state === 0) {
	        // start =============================================================================
	        if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
	          // 'data_' ..........
	          j = i + 5;
	          begin = j;
	          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
	            ++j;
	          }
	          column += j - i;
	          i = j;
	          if (begin < i) {
	            // add new data block
	            result[source.substring(begin, i)] = block = {};
	            state = 1; // block
	            continue; // don't forget to process the whitespace
	          } else {
	            err = 'data block name missing';
	            state = 666; // error
	            break;
	          }
	        } else if (Number.isNaN(code)) {
	          // <eof> ....................................................................
	          break;
	        } else {
	          // ..................................................................................................
	          err += ' in state ' + state;
	          state = 666; // error
	          break;
	        }
	      } else if (state === 1) {
	        // block =============================================================================
	        if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
	          // 'data_' ..........
	          state = 0; // start
	          continue; // parse again in a different state
	        } else if (code === 95) {
	          // '_' .............................................................................
	          j = i + 1;
	          begin = j;
	          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
	            ++j;
	          }
	          column += j - i;
	          i = j;
	          if (begin < i) {
	            // start new item
	            key = source.substring(begin, i);
	            state = 2; // item
	            continue; // don't forget to process the whitespace
	          } else {
	            err = 'tag name missing';
	            state = 666; // error
	            break;
	          }
	        } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
	          // 'loop_' ...
	          i += 5;
	          column += 5;
	          if (i < n && !_isWhitespace(source.charCodeAt(i))) {
	            err += ' in state ' + state;
	            state = 666; // error
	            break;
	          } else {
	            // start new loop
	            keys = [];
	            keysCount = 0;
	            values = [];
	            valuesCount = 0;
	            state = 3; // loop
	            continue; // don't forget to process the whitespace
	          }
	        } else if (Number.isNaN(code)) {
	          // <eof> ....................................................................
	          break;
	        } else {
	          // ..................................................................................................
	          err += ' in state ' + state;
	          state = 666; // error
	          break;
	        }
	      } else if (state === 2) {
	        // item ==============================================================================
	        if (Number.isNaN(code)) {
	          break;
	        } else if ((value = _parseValue()) !== null) {
	          lodash.set(block, key, value);
	          state = 1; // block
	          continue;
	        }
	        state = 666;
	        break;
	      } else if (state === 3) {
	        // loop ==============================================================================
	        if (code === 95) {
	          // '_' ....................................................................................
	          j = i + 1;
	          begin = j;
	          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
	            ++j;
	          }
	          column += j - i;
	          i = j;
	          if (begin < i) {
	            // add new key
	            _storeKey(source.substring(begin, i));
	            continue; // don't forget to process the whitespace
	          } else {
	            err = 'tag name missing';
	            state = 666; // error
	            break;
	          }
	        } else {
	          // ..................................................................................................
	          if (keysCount > 0) {
	            for (var keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
	              value = [];
	              values[keyIndex] = value;
	              lodash.set(block, keys[keyIndex], value);
	            }
	            state = 4;
	            continue; // parse again in a different state
	          }
	          err = 'data tags are missing inside a loop';
	          state = 666; // error
	          break;
	        }
	      } else if (state === 4) {
	        // values ============================================================================
	        if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
	          // 'data_' ..........
	          state = 0; // start
	        } else if (code === 95) {
	          // '_' .............................................................................
	          state = 1; // block
	        } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
	          // 'loop_' ...
	          state = 1; // block
	        } else if (Number.isNaN(code)) {
	          // <eof> ....................................................................
	          state = 0;
	        } else {
	          // ..................................................................................................
	          if (_storeValue(_parseValue()) !== null) {
	            continue;
	          }
	          state = 666;
	          break;
	        }
	        continue; // parse again in a different state
	      } else {
	        // ====================================================================================================
	        err = 'unexpected internal state ' + state;
	        state = 666; // error
	        break;
	      }

	      newline = false;
	      ++column;
	    }
	    ++i;
	  }

	  if (state === 2) {
	    // item
	    err = 'unexpected end of file in state ' + state;
	    state = 666; // error
	  }

	  var ret = {
	    data: result
	  };

	  if (state === 666) {
	    // error
	    ret.error = {
	      line: line,
	      column: column,
	      message: err
	    };
	  }

	  return ret;
	};

	CIFParser.formats = ['cif', 'mmcif'];
	CIFParser.extensions = ['.cif', '.mmcif'];

	var Volume$3 = chem.Volume;

	function Ccp4Model() {}

	Ccp4Model.prototype.load = function (buffer) {
	  if (lodash.isTypedArray(buffer)) {
	    buffer = buffer.buffer;
	  } else if (!lodash.isArrayBuffer(buffer)) {
	    throw new TypeError('Expected ArrayBuffer or TypedArray');
	  }

	  var u32 = new Uint32Array(buffer);
	  var i32 = new Int32Array(buffer);
	  var f32 = new Float32Array(buffer);

	  var header = this._header = {};
	  header.extent = [];
	  header.nstart = [];
	  header.crs2xyz = [];
	  header.cellDims = new Vector3();
	  header.angles = new Vector3();
	  header.origin = new Vector3();

	  // read header (http://www.ccp4.ac.uk/html/maplib.html)
	  var idx = 0;
	  header.extent.push(u32[idx++]);
	  header.extent.push(u32[idx++]);
	  header.extent.push(u32[idx++]);
	  header.type = u32[idx++];
	  header.nstart.push(i32[idx++]);
	  header.nstart.push(i32[idx++]);
	  header.nstart.push(i32[idx++]);
	  header.gridX = u32[idx++];
	  header.gridY = u32[idx++];
	  header.gridZ = u32[idx++];
	  header.cellDims.x = f32[idx++];
	  header.cellDims.y = f32[idx++];
	  header.cellDims.z = f32[idx++];
	  header.angles.x = f32[idx++];
	  header.angles.y = f32[idx++];
	  header.angles.z = f32[idx++];
	  header.crs2xyz.push(i32[idx++]);
	  header.crs2xyz.push(i32[idx++]);
	  header.crs2xyz.push(i32[idx++]);
	  header.dmin = f32[idx++];
	  header.dmax = f32[idx++];
	  header.dmean = f32[idx++];
	  header.ispg = u32[idx++];
	  header.nsymbt = u32[idx++];
	  header.lksflg = u32[idx++];
	  header.customData = new Uint8Array(buffer, idx * 4, 96);
	  idx += 24;
	  header.origin.x = f32[idx++];
	  header.origin.y = f32[idx++];
	  header.origin.z = f32[idx++];
	  header.map = new Uint8Array(buffer, idx * 4, 4);
	  idx++;
	  header.machine = u32[idx++];
	  header.arms = f32[idx++];
	  header.nlabel = u32[idx++];
	  header.label = new Uint8Array(buffer, idx * 4, 800);

	  // Apply header conversion
	  // Mapping between CCP4 column, row, section and VMD x, y, z.
	  var crs2xyz = header.crs2xyz;
	  if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
	    crs2xyz[0] = 1;
	    crs2xyz[1] = 2;
	    crs2xyz[2] = 3;
	  }

	  var xyz2crs = this._xyz2crs = [];
	  xyz2crs[crs2xyz[0] - 1] = 0; // column
	  xyz2crs[crs2xyz[1] - 1] = 1; // row
	  xyz2crs[crs2xyz[2] - 1] = 2; // section

	  var xIndex = xyz2crs[0];
	  var yIndex = xyz2crs[1];
	  var zIndex = xyz2crs[2];

	  // calculate non-orthogonal unit cell coordinates
	  header.angles.multiplyScalar(Math.PI / 180.0);

	  if (header.cellDims.x === 0.0 && header.cellDims.y === 0.0 && header.cellDims.z === 0.0) {
	    header.cellDims.set(1.0, 1.0, 1.0);
	  }

	  var xScale = header.cellDims.x / header.gridX;
	  var yScale = header.cellDims.y / header.gridY;
	  var zScale = header.cellDims.z / header.gridZ;

	  var z1 = Math.cos(header.angles.y);
	  var z2 = (Math.cos(header.angles.x) - Math.cos(header.angles.y) * Math.cos(header.angles.z)) / Math.sin(header.angles.z);
	  var z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);
	  var xaxis = new Vector3(xScale, 0, 0);
	  var yaxis = new Vector3(Math.cos(header.angles.y) * yScale, Math.sin(header.angles.y) * yScale, 0);
	  var zaxis = new Vector3(z1 * zScale, z2 * zScale, z3 * zScale);

	  // Handle both MRC-2000 and older format maps
	  if (header.origin.x === 0.0 && header.origin.y === 0.0 && header.origin.z === 0.0) {
	    this._origin = new Vector3(0, 0, 0);
	    this._origin.addScaledVector(xaxis, header.nstart[xIndex]);
	    this._origin.addScaledVector(yaxis, header.nstart[yIndex]);
	    this._origin.addScaledVector(zaxis, header.nstart[zIndex]);
	  } else {
	    this._origin = header.origin;
	    // Use ORIGIN records rather than old n[xyz]start records
	    //   http://www2.mrc-lmb.cam.ac.uk/image2000.html
	    // XXX the ORIGIN field is only used by the EM community, and
	    //     has undefined meaning for non-orthogonal maps and/or
	    //     non-cubic voxels, etc.
	  }

	  xaxis.multiplyScalar(header.extent[xIndex] - 1);
	  yaxis.multiplyScalar(header.extent[yIndex] - 1);
	  zaxis.multiplyScalar(header.extent[zIndex] - 1);

	  if (header.type === 2) {
	    this._data = new Float32Array(buffer, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
	  } else {
	    throw new Error('CCP4: Unsupported format ' + header.type);
	  }

	  this._bboxSize = new Vector3(xaxis.length(), yaxis.length(), zaxis.length());
	};

	Ccp4Model.prototype.getXYZdim = function () {
	  return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
	};

	Ccp4Model.prototype.getXYZbox = function () {
	  return new Box3(this._origin.clone(), this._origin.clone().add(this._bboxSize));
	};

	Ccp4Model.prototype.getXYZcellSize = function () {
	  var dim = this.getXYZdim();
	  var res = this._bboxSize.clone();
	  res.x /= dim[0];
	  res.y /= dim[1];
	  res.z /= dim[2];
	  return res;
	};

	Ccp4Model.prototype.toXYZData = function () {
	  var header = this._header;
	  var data = this._data;
	  var xyz2crs = this._xyz2crs;
	  var xyzData = new Float32Array(data.length);

	  var dim = this.getXYZdim();
	  var xSize = dim[0];
	  var ySize = dim[1];

	  var crsIdx = 0;
	  var coord = [];
	  var x, y, z;
	  for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
	    // Site
	    for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
	      // Row
	      for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
	        // Column
	        x = coord[xyz2crs[0]];
	        y = coord[xyz2crs[1]];
	        z = coord[xyz2crs[2]];
	        xyzData[x + xSize * (y + ySize * z)] = data[crsIdx];
	      }
	    }
	  }

	  return xyzData;
	};

	function CCP4Parser(data, options) {
	  Parser.call(this, data, options);

	  this._options.fileType = 'ccp4';
	}

	////////////////////////////////////////////////////////////////////////////
	// Inheritance

	utils.deriveClass(CCP4Parser, Parser);

	////////////////////////////////////////////////////////////////////////////
	// Class methods

	/** @deprecated */
	CCP4Parser.canParse = function (data, options) {
	  if (!data) {
	    return false;
	  }
	  return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options, 'ccp4');
	};

	CCP4Parser.canProbablyParse = function (_data) {
	  return false; // Autodetection is not implemented yet
	};

	CCP4Parser.prototype.parseSync = function () {
	  var ccp4 = new Ccp4Model();
	  ccp4.load(this._data);
	  return new Volume$3(Float32Array, ccp4.getXYZdim(), ccp4.getXYZbox(), 1, ccp4.toXYZData());
	};

	CCP4Parser.formats = ['ccp4'];
	CCP4Parser.extensions = ['.ccp4'];
	CCP4Parser.binary = true;

	var Complex$5 = chem.Complex,
	    Element$6 = chem.Element;

	function PubChemParser(data, options) {
	  Parser.call(this, data, options);
	  this._options.fileType = 'pubchem+json';
	}

	////////////////////////////////////////////////////////////////////////////
	// Inheritance

	PubChemParser.prototype = Object.create(Parser.prototype);
	PubChemParser.prototype.constructor = PubChemParser;

	////////////////////////////////////////////////////////////////////////////
	// Class methods

	/** @deprecated */
	PubChemParser.canParse = function (data, options) {
	  if (!data) {
	    return false;
	  }
	  var type = options.fileType;
	  return lodash.isString(data) && (type === 'pubchem+json' || !type && data[0] === '{');
	};

	PubChemParser.canProbablyParse = function (data) {
	  return lodash.isString(data) && data[0] === '{';
	};

	PubChemParser.prototype.parseSync = function () {
	  this.logger.info('Parsing PubChem JSON file...');
	  return this._toComplex(JSON.parse(this._data));
	};

	PubChemParser.prototype._toComplex = function (jsonData) {
	  var complex = new Complex$5();
	  var complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];
	  if (complexData) {
	    this._extractAtoms(complex, complexData);
	    complex.finalize({
	      needAutoBonding: false,
	      detectAromaticLoops: this.settings.now.aromatic,
	      enableEditing: this.settings.now.editing
	    });
	  }
	  return complex;
	};

	PubChemParser.prototype._extractAtoms = function (complex, complexData) {
	  var aids = complexData.atoms && complexData.atoms.aid;
	  var elements = aids && complexData.atoms.element;
	  if (!elements || aids.length !== elements.length) {
	    throw new Error('Unable to parse atom elements');
	  }
	  elements = lodash.fromPairs(lodash.zip(aids, elements));
	  var atoms = {};

	  var coords = complexData.coords && complexData.coords[0];
	  var model = coords && coords.conformers && coords.conformers[0];
	  var xs = model && model.x;
	  var ys = model && model.y;
	  var zs = model && model.z || [];
	  aids = coords && coords.aid;
	  if (!aids || !xs || !ys) {
	    throw new Error('Coordinates are not found in the file');
	  }

	  var chain = complex.addChain(' ');
	  var residue = chain.addResidue('UNK', 1, ' ');

	  for (var i = 0, n = aids.length; i < n; ++i) {
	    var aid = aids[i];
	    var element = Element$6.ByAtomicNumber[elements[aid]];
	    var xyz = new Vector3(xs[i], ys[i], zs[i] || 0.0);
	    atoms[aid] = residue.addAtom(element.name, element, xyz, undefined, true, aid, ' ', 1.0, 0.0, 0);
	  }

	  var aids1 = complexData.bonds && complexData.bonds.aid1;
	  var aids2 = complexData.bonds && complexData.bonds.aid2;
	  var orders = complexData.bonds && complexData.bonds.order || [];
	  if (!aids1 || !aids2 || aids1.length !== aids2.length) {
	    return;
	  }

	  for (var j = 0, m = aids1.length; j < m; ++j) {
	    complex.addBond(atoms[aids1[j]], atoms[aids2[j]], orders[j] || 1, 0, true);
	  }
	};

	PubChemParser.formats = ['pubchem', 'pubchem+json', 'pc'];
	PubChemParser.extensions = ['.json'];

	var parsers = new ParserList([
	// note: order might be important
	PDBParser, CIFParser, MMTFParser, CMLParser, PubChemParser, CCP4Parser]);

	var io = {
	  loaders: loaders,
	  parsers: parsers
	};

	var tempColor = new Color();

	function CSS2DRenderer() {

	  this._width = 0;
	  this._height = 0;
	  this._widthHalf = 0;
	  this._heightHalf = 0;

	  this._vector = new Vector3();
	  this._viewMatrix = new Matrix4();
	  this._projectionMatrix = new Matrix4();

	  this._domElement = document.createElement('div');
	  this._domElement.style.overflow = 'hidden';
	  this._domElement.style.position = 'absolute';
	  this._domElement.style.top = '0';
	  this._domElement.style.zIndex = '0'; // start a new Stacking Context to enclose all z-ordered children
	  this._domElement.style.pointerEvents = 'none';
	}

	CSS2DRenderer.prototype.getElement = function () {
	  return this._domElement;
	};

	CSS2DRenderer.prototype.reset = function () {
	  var myNode = this.getElement();
	  while (myNode.firstChild) {
	    myNode.removeChild(myNode.firstChild);
	  }
	};

	CSS2DRenderer.prototype.setSize = function (width, height) {
	  this._width = width;
	  this._height = height;

	  this._widthHalf = this._width / 2;
	  this._heightHalf = this._height / 2;

	  this._domElement.style.width = width + 'px';
	  this._domElement.style.height = height + 'px';
	};

	CSS2DRenderer.prototype._renderObject = function (object, camera, scene) {

	  function lerpColorAsHex(a, b, t) {
	    tempColor.setHex(a);
	    tempColor.lerp(b, t);
	    return '#' + tempColor.getHexString();
	  }

	  function colorAsHex(a) {
	    tempColor.setHex(a);
	    return '#' + tempColor.getHexString();
	  }

	  if (object instanceof CSS2DObject) {
	    this._vector.setFromMatrixPosition(object.matrixWorld);

	    if (object.userData !== undefined && object.userData.offset !== undefined) {
	      var localOffset = new Vector3(object.userData.offset.x, object.userData.offset.y, 0);
	      this._vector.add(localOffset.multiplyScalar(object.matrixWorld.getMaxScaleOnAxis()));
	    }

	    this._vector.applyMatrix4(this._viewMatrix);

	    var visibility = this._vector.z > -camera.near ? 'hidden' : 'visible';
	    var zIndex = 10000 * (camera.far - -this._vector.z) / (camera.far - camera.near);

	    var element = object.getElement();
	    if (typeof scene.fog === 'undefined') {
	      element.style.color = colorAsHex(object.userData.color);
	      if (object.userData.background !== 'transparent') {
	        element.style.background = colorAsHex(object.userData.background);
	      }
	    } else {
	      var fogFactor = _Math.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
	      element.style.color = lerpColorAsHex(object.userData.color, scene.fog.color, fogFactor);
	      if (object.userData.background !== 'transparent') {
	        element.style.background = lerpColorAsHex(object.userData.background, scene.fog.color, fogFactor);
	      }
	    }

	    this._vector.applyMatrix4(this._projectionMatrix);

	    var style = (object.userData !== {} ? object.userData.translation : 'translate(-50%, -50%) ') + 'translate(' + (this._vector.x * this._widthHalf + this._widthHalf) + 'px,' + (-this._vector.y * this._heightHalf + this._heightHalf) + 'px)';
	    element.style.visibility = visibility;
	    element.style.WebkitTransform = style;
	    element.style.MozTransform = style;
	    element.style.oTransform = style;
	    element.style.transform = style;
	    element.style.zIndex = Number(zIndex).toFixed(0);

	    if (element.parentNode !== this._domElement) {
	      this._domElement.appendChild(element);
	    }
	  }

	  for (var i = 0, l = object.children.length; i < l; i++) {
	    this._renderObject(object.children[i], camera, scene);
	  }
	};

	CSS2DRenderer.prototype._hideObject = function (object) {
	  if (object instanceof CSS2DObject) {
	    var element = object.element;
	    element.style.visibility = 'hidden';
	  }

	  for (var i = 0, l = object.children.length; i < l; i++) {
	    this._hideObject(object.children[i]);
	  }
	};

	CSS2DRenderer.prototype.render = function (scene, camera) {
	  scene.updateMatrixWorld();

	  if (camera.parent === null) {
	    camera.updateMatrixWorld();
	  }

	  camera.matrixWorldInverse.getInverse(camera.matrixWorld);

	  this._viewMatrix.copy(camera.matrixWorldInverse.getInverse(camera.matrixWorld));
	  this._projectionMatrix.copy(camera.projectionMatrix);

	  this._renderObject(scene, camera, scene);
	};

	var VK_LEFT = 37;
	var VK_UP = 38;
	var VK_RIGHT = 39;
	var VK_DOWN = 40;

	var STATE = {
	  NONE: -1, ROTATE: 0, TRANSLATE: 1, SCALE_PAN: 2, TRANSLATE_PIVOT: 3
	};

	// pausing for this amount of time before releasing mouse button prevents inertial rotation (seconds)
	var FULL_STOP_THRESHOLD = 0.1;

	var PAN_SPEED = 10.0;
	var PINCH_PAN_COEF = 0.1;

	// pivot -- local offset of the rotation pivot point
	function ObjectHandler(objects, camera, pivot, options) {

	  this.objects = objects;
	  this.object = objects[0];
	  this.camera = camera;
	  this.pivot = pivot;
	  this.axis = new Vector3(0, 0, 1);
	  this.options = options;

	  this.lastRotation = {
	    axis: new Vector3(),
	    angle: 0.0
	  };
	}

	ObjectHandler.prototype._rotate = function (quaternion) {

	  var zeroPivot = this.pivot.x === 0.0 && this.pivot.y === 0.0 && this.pivot.z === 0.0;

	  var m = this.object.matrix.clone();

	  if (zeroPivot) {
	    m.multiply(new Matrix4().makeRotationFromQuaternion(quaternion));
	  } else {
	    m.multiply(new Matrix4().makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
	    m.multiply(new Matrix4().makeRotationFromQuaternion(quaternion));
	    m.multiply(new Matrix4().makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
	  }

	  var p = new Vector3();
	  var q = new Quaternion();
	  var s = new Vector3();
	  m.decompose(p, q, s);

	  // update objects
	  if (!zeroPivot) {
	    for (var i = 0; i < this.objects.length; ++i) {
	      this.objects[i].position.copy(p);
	    }
	  }

	  for (var j = 0; j < this.objects.length; ++j) {
	    this.objects[j].quaternion.copy(q);
	    this.objects[j].updateMatrix();
	  }
	};

	ObjectHandler.prototype.setObjects = function (objects) {
	  this.objects = objects;
	  this.object = objects[0];
	};

	ObjectHandler.prototype.rotate = function (mousePrevPos, mouseCurPos, aboutAxis) {

	  var rot = this.mouse2rotation(mousePrevPos, mouseCurPos, aboutAxis);

	  if (rot.angle) {
	    this._rotate(new Quaternion().setFromAxisAngle(rot.axis, rot.angle));
	  }

	  this.lastRotation = rot;
	};

	ObjectHandler.prototype.translate = function (delta) {
	  // reverse-project viewport movement to view coords (compensate for screen aspect ratio)
	  var d = new Vector3(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
	  var dist = d.length();
	  d.normalize();

	  // transform movement direction to object local coords
	  var invWorldMat = new Matrix4().getInverse(this.object.matrixWorld);
	  d.transformDirection(invWorldMat);

	  // visible translate distance shouldn't depend on camera-to-object distance
	  var pivot = this.pivot.clone();
	  this.object.localToWorld(pivot);
	  dist *= Math.abs(pivot.z - this.camera.position.z);

	  // visible translate distance shouldn't depend on object scale
	  dist /= this.object.matrixWorld.getMaxScaleOnAxis();

	  // all objects are translated similar to principal object
	  // (we assume they all have identical pivot and scale)
	  for (var i = 0; i < this.objects.length; ++i) {
	    this.objects[i].translateOnAxis(d, dist);
	  }
	};

	ObjectHandler.prototype.update = function (timeSinceLastUpdate, timeSinceMove) {

	  if (settings.now.autoRotation !== 0.0) {
	    // auto-rotation with constant speed
	    var axis;

	    // if rotation axis is fixed or hasn't been defined yet
	    if (settings.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0.0) {
	      // use Y-axis (transformed to local object coords)
	      var invM = new Matrix4().getInverse(this.object.matrixWorld);
	      axis = new Vector3(0, 1, 0).transformDirection(invM);
	    } else {
	      // use axis defined by last user rotation
	      axis = this.lastRotation.axis;
	    }

	    this._rotate(new Quaternion().setFromAxisAngle(axis, settings.now.autoRotation * timeSinceLastUpdate));
	    return true;
	  }

	  if (this.options.intertia && this.lastRotation.angle) {

	    // inertial object rotation
	    var angle = this.lastRotation.angle * Math.pow(1.0 - this.options.dynamicDampingFactor, 40.0 * timeSinceMove);

	    if (Math.abs(angle) <= this.options.intertiaThreshold) {
	      this.lastRotation.angle = 0.0;
	    } else {
	      this._rotate(new Quaternion().setFromAxisAngle(this.lastRotation.axis, angle));
	      return true;
	    }
	  }

	  return false;
	};

	ObjectHandler.prototype.stop = function () {
	  this.lastRotation.angle = 0.0;
	};

	// calculate (axis, angle) pair from mouse/touch movement
	ObjectHandler.prototype.mouse2rotation = function (mousePrev, mouseCur, aboutAxis) {

	  var res = {
	    axis: new Vector3(),
	    angle: 0.0
	  };

	  if (aboutAxis) {
	    res.axis.copy(this.axis);
	    res.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);

	    /* cool method that allows rotation around Z axis to be "tied" to mouse cursor
	        res.axis.copy(this.axis);
	        var pivot = this.pivot.clone();
	      this.object.localToWorld(pivot);
	      pivot.project(this.camera);
	        var v1 = new THREE.Vector3(mousePrev.x, mousePrev.y, this.camera.position.z);
	      v1.sub(pivot);
	      var v2 = new THREE.Vector3(mouseCur.x, mouseCur.y, this.camera.position.z);
	      v2.sub(pivot);
	        v1.sub(res.axis.clone().multiplyScalar(v1.dot(res.axis)));
	      v2.sub(res.axis.clone().multiplyScalar(v2.dot(res.axis)));
	        var abs = v1.length() * v2.length();
	      if (abs > 0) {
	        res.angle = res.axis.dot(v1.cross(v2)) / abs;
	      }
	    */
	  } else {
	    var mouseDelta = mouseCur.clone().sub(mousePrev);
	    var angle = mouseDelta.length();
	    if (angle === 0.0) {
	      return res;
	    }

	    var center = this.pivot.clone();
	    this.object.localToWorld(center);
	    var eye = new Vector3().subVectors(this.camera.position, center);
	    var eyeDirection = eye.clone().normalize();

	    var cameraUpDirection = this.camera.up.clone().normalize();
	    var cameraSidewaysDirection = new Vector3().crossVectors(cameraUpDirection, eyeDirection).normalize();

	    cameraUpDirection.setLength(mouseDelta.y);
	    cameraSidewaysDirection.setLength(mouseDelta.x);

	    var moveDirection = new Vector3().copy(cameraUpDirection.add(cameraSidewaysDirection));

	    res.axis.crossVectors(moveDirection, eye);

	    res.angle = -angle * this.options.rotateFactor;
	  }

	  var invWorldMat = new Matrix4().getInverse(this.object.matrixWorld);
	  res.axis.transformDirection(invWorldMat);

	  // make sure angle is always positive (thus 'axis' defines both axis and direction of rotation)
	  if (res.angle < 0.0) {
	    res.axis.negate();
	    res.angle = -res.angle;
	  }

	  return res;
	};

	function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
	  EventDispatcher$1.call(this);
	  var self = this;

	  this.object = object;
	  this.objectPivot = objectPivot;
	  this.camera = camera;
	  this.domElement = typeof domElement !== 'undefined' ? domElement : document;
	  this.getAltObj = getAltObj;

	  // API

	  this.enabled = true;
	  this.hotkeysEnabled = true;

	  this.screen = {
	    left: 0, top: 0, width: 0, height: 0
	  };

	  this.options = {
	    rotateFactor: Math.PI, // full screen slide (along short side) would roughly mean 180 deg. rotation
	    axisRotateFactor: 4 * Math.PI, // full screen slide (along short side) would roughly mean 720 deg. rotation
	    intertia: true,
	    dynamicDampingFactor: 0.1,
	    intertiaThreshold: 1e-3
	  };

	  // internals

	  this._state = STATE.NONE;

	  this._mousePrevPos = new Vector2();
	  this._mouseCurPos = new Vector2();

	  this._originalCameraPos = new Vector3();

	  this._mainObj = new ObjectHandler([this.object], this.camera, new Vector3(0, 0, 0), this.options);
	  this._altObj = new ObjectHandler([this.object], this.camera, new Vector3(0, 0, 0), this.options);
	  this._affectedObj = this._mainObj;
	  this._isAltObjFreeRotationAllowed = true;
	  this._isTranslationAllowed = true;
	  this._isKeysTranslatingObj = false;

	  this._pressedKeys = [];

	  this._clock = new utils.Timer();
	  this._clock.start();
	  this._lastUpdateTime = this._clock.getElapsedTime();

	  // events
	  this._listeners = [{
	    obj: self.domElement,
	    type: 'mousedown',
	    handler: function handler(e) {
	      self.mousedown(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'mouseup',
	    handler: function handler(e) {
	      self.mouseup(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'mousemove',
	    handler: function handler(e) {
	      self.mousemove(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'mousewheel',
	    handler: function handler(e) {
	      self.mousewheel(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'DOMMouseScroll',
	    handler: function handler(e) {
	      self.mousewheel(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'mouseout',
	    handler: function handler(e) {
	      self.mouseup(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'touchstart',
	    handler: function handler(e) {
	      self.touchstartend(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'touchend',
	    handler: function handler(e) {
	      self.touchstartend(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'touchmove',
	    handler: function handler(e) {
	      self.touchmove(e);
	    }
	  }, {
	    obj: self.getKeyBindObject(),
	    type: 'keydown',
	    handler: function handler(e) {
	      self.keydownup(e);
	    }
	  }, {
	    obj: self.getKeyBindObject(),
	    type: 'keyup',
	    handler: function handler(e) {
	      self.keydownup(e);
	    }
	  }, {
	    obj: window,
	    type: 'resize',
	    handler: function handler() {
	      self.handleResize();
	    }
	  }, {
	    obj: window,
	    type: 'blur',
	    handler: function handler() {
	      self.resetKeys();
	    }
	  }, {
	    obj: self.domElement,
	    type: 'contextmenu',
	    handler: function handler(e) {
	      self.contextmenu(e);
	    }
	  }];

	  for (var i = 0; i < this._listeners.length; i++) {
	    var l = this._listeners[i];
	    l.obj.addEventListener(l.type, l.handler);
	  }

	  this.handleResize();

	  this.resetKeys();

	  // force an update at start
	  this.update();
	}

	// methods

	ObjectControls.prototype = Object.create(EventDispatcher$1.prototype);
	ObjectControls.prototype.constructor = ObjectControls;

	ObjectControls.prototype.resetKeys = function () {
	  this._pressedKeys[VK_LEFT] = false;
	  this._pressedKeys[VK_UP] = false;
	  this._pressedKeys[VK_RIGHT] = false;
	  this._pressedKeys[VK_DOWN] = false;
	};

	ObjectControls.prototype.contextmenu = function (e) {
	  e.stopPropagation();
	  e.preventDefault();
	};

	ObjectControls.prototype.handleResize = function () {

	  if (this.domElement === document) {

	    this.screen.left = 0;
	    this.screen.top = 0;
	    this.screen.width = window.innerWidth;
	    this.screen.height = window.innerHeight;
	  } else {

	    var box = this.domElement.getBoundingClientRect();
	    // adjustments come from similar code in the jquery offset() function
	    var d = this.domElement.ownerDocument.documentElement;
	    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
	    this.screen.top = box.top + window.pageYOffset - d.clientTop;
	    this.screen.width = box.width;
	    this.screen.height = box.height;
	  }
	};

	ObjectControls.prototype.enable = function (enable) {
	  this.enabled = enable;
	};

	ObjectControls.prototype.enableHotkeys = function (enable) {
	  this.hotkeysEnabled = enable;
	};

	ObjectControls.prototype.allowTranslation = function (allow) {
	  this._isTranslationAllowed = allow;
	};

	ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
	  this._isAltObjFreeRotationAllowed = allow;
	};

	ObjectControls.prototype.keysTranslateObj = function (on) {
	  this._isKeysTranslatingObj = on;
	};

	ObjectControls.prototype.isEditingAltObj = function () {
	  return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
	};

	// convert page coords of mouse/touch to uniform coords with smaller side being [-0.5, 0.5]
	// (uniform coords keep direct proportion with screen distance travelled by mouse regardless of screen aspect ratio)
	ObjectControls.prototype.getMouseOnCircle = function (pageX, pageY) {

	  var screenSize = Math.min(this.screen.width, this.screen.height);

	  if (screenSize === 0) {
	    return new Vector2(0, 0);
	  }

	  return new Vector2((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
	};

	// convert page coords of mouse/touch to viewport coords with both sides being [-1, 1]
	// (those are non-uniform coords affected by screen aspect ratio)
	ObjectControls.prototype.getMouseViewport = function (pageX, pageY) {

	  if (this.screen.width === 0 || this.screen.height === 0) {
	    return new Vector2(0, 0);
	  }

	  return new Vector2(2.0 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2.0 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
	};

	ObjectControls.prototype.stop = function () {
	  this._mainObj.stop();
	  this._altObj.stop();
	};

	// rotate object based on latest mouse/touch movement
	ObjectControls.prototype.rotateByMouse = function (aboutZAxis) {

	  this._affectedObj.rotate(this._mousePrevPos, this._mouseCurPos, aboutZAxis);
	  this.dispatchEvent({ type: 'change', action: 'rotate', angle: this._affectedObj.lastRotation.angle });
	};

	// rotate object by specified quaternion
	ObjectControls.prototype.rotate = function (quat) {

	  this.object.quaternion.multiply(quat);
	};

	// get object's orientation
	ObjectControls.prototype.getOrientation = function () {

	  return this.object.quaternion;
	};

	// set object's orientation
	ObjectControls.prototype.setOrientation = function (quat) {

	  this.object.quaternion.copy(quat);
	};

	// translate object based on latest mouse/touch movement
	ObjectControls.prototype.translate = function () {

	  var delta = this._mouseCurPos.clone();
	  delta.sub(this._mousePrevPos);
	  this._affectedObj.translate(delta);
	  this.dispatchEvent({ type: 'change', action: 'translate' });
	};

	// get object scale
	ObjectControls.prototype.getScale = function () {
	  return this.object.scale.x;
	};

	// set uniform object scale
	ObjectControls.prototype.setScale = function (scale) {
	  this.object.scale.set(scale, scale, scale);
	};

	// scale object by factor (factor should be greater than zero)
	ObjectControls.prototype.scale = function (factor) {
	  if (factor <= 0) {
	    return;
	  }
	  this.setScale(this.object.scale.x * factor);
	};

	ObjectControls.prototype.update = function () {

	  var curTime = this._clock.getElapsedTime();
	  var timeSinceLastUpdate = curTime - this._lastUpdateTime;

	  // update object handler
	  if (this._state === STATE.NONE) {
	    var timeSinceMove = curTime - this._lastMouseMoveTime;
	    if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
	      this.dispatchEvent({ type: 'change', action: 'auto' });
	    }
	  }

	  // apply arrow keys
	  if (settings.now.panning || this._isKeysTranslatingObj) {
	    var speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
	    var speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);
	    if (speedX !== 0.0 || speedY !== 0.0) {
	      var delta = timeSinceLastUpdate;

	      if (this._isKeysTranslatingObj) {
	        // update object translation
	        var altObj = this.getAltObj();
	        if (altObj.objects.length > 0) {
	          this._altObj.setObjects(altObj.objects);
	          this._altObj.pivot = altObj.pivot;

	          if ('axis' in altObj) {
	            this._altObj.axis = altObj.axis.clone();
	          } else {
	            this._altObj.axis.set(0, 0, 1);
	          }

	          this._altObj.translate(new Vector2(delta * speedX, delta * speedY));
	          this.dispatchEvent({ type: 'change', action: 'translate' });
	        }
	      } else {
	        // update camera panning
	        // @deprecated
	        delta *= PAN_SPEED * (settings.now.inversePanning ? -1 : 1);
	        this.camera.translateX(delta * speedX);
	        this.camera.translateY(delta * speedY);
	        this.dispatchEvent({ type: 'change', action: 'pan' });
	      }
	    }
	  }

	  this._lastUpdateTime = curTime;
	};

	ObjectControls.prototype.reset = function () {

	  this._state = STATE.NONE;

	  this.object.quaternion.copy(new Quaternion(0, 0, 0, 1));
	};

	// listeners

	ObjectControls.prototype.mousedown = function (event) {

	  if (this.enabled === false || this._state !== STATE.NONE) {
	    return;
	  }

	  event.preventDefault();
	  event.stopPropagation();

	  if (this._state === STATE.NONE) {
	    if (event.button === 0) {
	      this._affectedObj.stop(); // can edit only one object at a time

	      var workWithAltObj = false;

	      if (event.altKey) {
	        var altObj = this.getAltObj();
	        workWithAltObj = altObj.objects.length > 0;
	        if (workWithAltObj) {
	          this._altObj.setObjects(altObj.objects);
	          this._altObj.pivot = altObj.pivot;

	          if ('axis' in altObj) {
	            this._altObj.axis = altObj.axis.clone();
	          } else {
	            this._altObj.axis.set(0, 0, 1);
	          }
	        }
	      }

	      this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;

	      this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
	    } else if (event.button === 2) {
	      this._state = STATE.TRANSLATE_PIVOT;
	    }
	  }

	  if (this._state === STATE.ROTATE) {
	    this._mouseCurPos.copy(this.getMouseOnCircle(event.pageX, event.pageY));
	    this._mousePrevPos.copy(this._mouseCurPos);
	  }

	  if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
	    this._mouseCurPos.copy(this.getMouseViewport(event.pageX, event.pageY));
	    this._mousePrevPos.copy(this._mouseCurPos);
	  }
	};

	ObjectControls.prototype.mousemove = function (event) {

	  if (this.enabled === false || this._state === STATE.NONE) {
	    return;
	  }

	  event.preventDefault();
	  event.stopPropagation();

	  switch (this._state) {
	    case STATE.ROTATE:
	      this._mousePrevPos.copy(this._mouseCurPos);
	      this._mouseCurPos.copy(this.getMouseOnCircle(event.pageX, event.pageY));
	      this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
	      this._lastMouseMoveTime = this._clock.getElapsedTime();
	      break;

	    case STATE.TRANSLATE:
	      this._mousePrevPos.copy(this._mouseCurPos);
	      this._mouseCurPos.copy(this.getMouseViewport(event.pageX, event.pageY));
	      this.translate();
	      break;

	    case STATE.TRANSLATE_PIVOT:
	      this._mousePrevPos.copy(this._mouseCurPos);
	      this._mouseCurPos.copy(this.getMouseViewport(event.pageX, event.pageY));
	      this.translatePivotByMouse();
	      break;

	    default:
	      break;
	  }
	};

	ObjectControls.prototype.mousewheel = function (event) {

	  if (this.enabled === false || !settings.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
	    return;
	  }

	  event.preventDefault();

	  var delta = 0;

	  if (event.wheelDelta) {
	    // WebKit / Opera / Explorer 9
	    delta = event.wheelDelta / 40;
	  } else if (event.detail) {
	    // Firefox
	    delta = -event.detail / 3;
	  }

	  var factor = 1.0 + delta * 0.05;
	  factor = Math.max(factor, 0.01);
	  this.scale(factor);

	  this.dispatchEvent({ type: 'change', action: 'zoom', factor: factor });
	};

	ObjectControls.prototype.mouseup = function (event) {

	  if (this.enabled === false || this._state === STATE.NONE) {
	    return;
	  }

	  event.preventDefault();
	  event.stopPropagation();

	  this._state = STATE.NONE;

	  if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
	    this._affectedObj.stop();
	  }
	};

	ObjectControls.prototype.touchstartend = function (event) {

	  if (this.enabled === false) {
	    return;
	  }

	  event.preventDefault();
	  event.stopPropagation();

	  switch (event.touches.length) {
	    case 1:
	      this._state = STATE.ROTATE;
	      this._mouseCurPos.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
	      this._mousePrevPos.copy(this._mouseCurPos);
	      break;

	    case 2:
	      // prevent inertial rotation
	      this._mainObj.stop();
	      this._altObj.stop();

	      this._state = STATE.SCALE_PAN;
	      var dx = event.touches[0].pageX - event.touches[1].pageX;
	      var dy = event.touches[0].pageY - event.touches[1].pageY;
	      this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
	      this._scaleStart = this.object.scale.x;
	      this._originalPinchCenter = new Vector2(0.5 * (event.touches[0].pageX + event.touches[1].pageX), 0.5 * (event.touches[0].pageY + event.touches[1].pageY));
	      this._originalCameraPos.copy(this.camera.position);
	      break;

	    default:
	      this._state = STATE.NONE;
	  }
	};

	ObjectControls.prototype.touchmove = function (event) {

	  if (this.enabled === false || this._state === STATE.NONE) {
	    return;
	  }

	  event.preventDefault();
	  event.stopPropagation();

	  switch (this._state) {
	    case STATE.ROTATE:
	      this._mousePrevPos.copy(this._mouseCurPos);
	      this._mouseCurPos.copy(this.getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));
	      this.rotateByMouse(false);

	      this._lastMouseMoveTime = this._clock.getElapsedTime();
	      break;

	    case STATE.SCALE_PAN:
	      if (settings.now.zooming) {
	        // update scale
	        var dx = event.touches[0].pageX - event.touches[1].pageX;
	        var dy = event.touches[0].pageY - event.touches[1].pageY;
	        this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
	        var oldScale = this.object.scale.x;
	        var newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
	        this.setScale(newScale);
	        this.dispatchEvent({ type: 'change', action: 'zoom', factor: oldScale === 0.0 ? 1.0 : newScale / oldScale });
	      }

	      // @deprecated: Move object instead of panning the camera
	      if (settings.now.panning) {
	        // update camera panning
	        var delta = new Vector2(0.5 * (event.touches[0].pageX + event.touches[1].pageX), 0.5 * (event.touches[0].pageY + event.touches[1].pageY));
	        delta.sub(this._originalPinchCenter);
	        this.camera.position.x = this._originalCameraPos.x - PINCH_PAN_COEF * delta.x;
	        this.camera.position.y = this._originalCameraPos.y + PINCH_PAN_COEF * delta.y;
	        this.dispatchEvent({ type: 'change', action: 'pan' });
	      }
	      break;

	    default:
	  }
	};

	ObjectControls.prototype.keydownup = function (event) {

	  if (this.enabled === false || this.hotkeysEnabled === false) {
	    return;
	  }

	  switch (event.keyCode) {
	    case VK_LEFT:
	    case VK_UP:
	    case VK_RIGHT:
	    case VK_DOWN:
	      this._pressedKeys[event.keyCode] = event.type === 'keydown';
	      event.preventDefault();
	      event.stopPropagation();
	      break;
	    default:
	  }
	};

	ObjectControls.prototype.getKeyBindObject = function () {
	  return window.top;
	};

	ObjectControls.prototype.dispose = function () {

	  for (var i = 0; i < this._listeners.length; i++) {
	    var l = this._listeners[i];
	    l.obj.removeEventListener(l.type, l.handler);
	  }
	};

	ObjectControls.prototype.translatePivotByMouse = function () {

	  var delta = this._mouseCurPos.clone();
	  delta.sub(this._mousePrevPos);
	  this.translatePivotInWorld(settings.now.translationSpeed * delta.x, settings.now.translationSpeed * delta.y, 0);
	};

	// Translate in WorldCS, translation is scaled with root scale matrix
	ObjectControls.prototype.translatePivotInWorld = function (x, y, z) {

	  var pos = this.objectPivot.position;
	  pos.applyMatrix4(this.object.matrixWorld);
	  pos.setX(pos.x + x);
	  pos.setY(pos.y + y);
	  pos.setZ(pos.z + z);
	  var invWorldMat = new Matrix4().getInverse(this.object.matrixWorld);
	  pos.applyMatrix4(invWorldMat);

	  this.dispatchEvent({ type: 'change' });
	};

	// Translate in ModelCS, x, y, z are Ang
	ObjectControls.prototype.translatePivot = function (x, y, z) {

	  var pos = this.objectPivot.position;
	  pos.setX(pos.x + x);
	  pos.setY(pos.y + y);
	  pos.setZ(pos.z + z);

	  this.dispatchEvent({ type: 'change' });
	};

	function Picker(gfxObj, camera, domElement) {
	  EventDispatcher$1.call(this);
	  var self = this;

	  this.gfxObj = gfxObj;
	  this.camera = camera;
	  this.domElement = typeof domElement !== 'undefined' ? domElement : document;
	  this.screen = {
	    left: 0, top: 0, width: 0, height: 0
	  };
	  this._lastMousePos = new Vector2(0, 0);
	  this._mouseTotalDist = 0.0;
	  this._lastClickBeginTime = -1000.0;
	  this._lastClickPos = new Vector2(0, 0);
	  this._clickBeginTime = 0.0;

	  this._clock = new utils.Timer();
	  this._clock.start();

	  this._listeners = [{
	    obj: self.domElement,
	    type: 'mousedown',
	    handler: function handler(e) {
	      self.mousedown(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'mouseup',
	    handler: function handler(e) {
	      self.mouseup(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'mousemove',
	    handler: function handler(e) {
	      self.mousemove(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'touchstart',
	    handler: function handler(e) {
	      self.touchstart(e);
	    }
	  }, {
	    obj: self.domElement,
	    type: 'touchend',
	    handler: function handler(e) {
	      self.touchend(e);
	    }
	  }, {
	    obj: window,
	    type: 'resize',
	    handler: function handler() {
	      self.handleResize();
	    }
	  }];

	  for (var i = 0; i < this._listeners.length; i++) {
	    var l = this._listeners[i];
	    l.obj.addEventListener(l.type, l.handler);
	  }

	  this.handleResize();
	}

	Picker.prototype = Object.create(EventDispatcher$1.prototype);
	Picker.prototype.constructor = Picker;

	Picker.prototype.reset = function () {
	  this.picked = {};
	  this.dispatchEvent({ type: 'newpick', obj: {} });
	};

	Picker.prototype.handleResize = function () {

	  if (this.domElement === document) {

	    this.screen.left = 0;
	    this.screen.top = 0;
	    this.screen.width = window.innerWidth;
	    this.screen.height = window.innerHeight;
	  } else {

	    var box = this.domElement.getBoundingClientRect();
	    // adjustments come from similar code in the jquery offset() function
	    var d = this.domElement.ownerDocument.documentElement;
	    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
	    this.screen.top = box.top + window.pageYOffset - d.clientTop;
	    this.screen.width = box.width;
	    this.screen.height = box.height;
	  }
	};

	Picker.prototype.pickObject = function (screenPos) {

	  var picked = {};
	  var gfxObj = this.gfxObj;
	  var intersects;
	  if (gfxObj) {
	    var rayCaster = new Raycaster();
	    rayCaster.setFromCamera(screenPos, this.camera);
	    intersects = rayCaster.intersectObject(gfxObj, false);
	    if (intersects.length > 0) {
	      var p = intersects[0];
	      var v = new Vector3();

	      if (settings.now.draft.clipPlane && this.hasOwnProperty('clipPlaneValue')) {
	        // find point closest to camera that doesn't get clipped
	        var i;
	        for (i = 0; i < intersects.length; ++i) {
	          p = intersects[i];
	          v.copy(p.point);
	          v.applyMatrix4(this.camera.matrixWorldInverse);
	          if (v.z <= -this.clipPlaneValue) {
	            break;
	          }
	        }

	        if (i === intersects.length) {
	          p = null;
	        }
	      }

	      if (p != null && settings.now.fog && this.hasOwnProperty('fogFarValue')) {
	        // check that selected intersection point is not occluded by fog
	        v.copy(p.point);
	        v.applyMatrix4(this.camera.matrixWorldInverse);
	        if (v.z <= -this.fogFarValue) {
	          p = null;
	        }
	      }

	      if (p != null && (p.residue || p.atom)) {
	        var residue = p.residue || p.atom.getResidue();
	        if (settings.now.pick === 'chain') {
	          picked = { chain: residue.getChain() };
	        } else if (settings.now.pick === 'molecule') {
	          picked = { molecule: residue.getMolecule() };
	        } else if (p.residue || settings.now.pick === 'residue') {
	          picked = { residue: residue };
	        } else if (p.atom) {
	          picked = { atom: p.atom };
	        }
	      }
	    }
	  }
	  this.picked = picked;

	  this.dispatchEvent({ type: 'newpick', obj: picked });
	};

	Picker.prototype.getMouseInViewport = function (pageX, pageY) {
	  return new Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
	};

	Picker.prototype.mousedown = function (event) {

	  event.preventDefault();
	  event.stopPropagation();

	  if (event.button === 0) {
	    this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
	    this._mouseTotalDist = 0.0;
	    this._clickBeginTime = this._clock.getElapsedTime();
	  }
	};

	Picker.prototype.mousemove = function (event) {

	  event.preventDefault();
	  event.stopPropagation();

	  var pos = this.getMouseInViewport(event.pageX, event.pageY);
	  this._mouseTotalDist += pos.sub(this._lastMousePos).length();
	};

	Picker.prototype.mouseup = function (event) {

	  var self = this;

	  event.preventDefault();
	  event.stopPropagation();

	  if (event.button === 0) {
	    if (this._mouseTotalDist < 0.01) {
	      var curTime = this._clock.getElapsedTime();
	      var curPos = this.getMouseInViewport(event.pageX, event.pageY);

	      var timeSinceLastClickBegin = curTime - this._lastClickBeginTime;
	      if (timeSinceLastClickBegin < 0.7) {

	        var clickDist = new Vector2().subVectors(curPos, this._lastClickPos);
	        if (clickDist.length() < 0.01) {
	          // it's a double click
	          this.dispatchEvent({ type: 'dblclick', obj: this.picked });

	          this._lastClickPos = curPos;
	          this._lastClickBeginTime = -1000; // this click cannot serve as first click in double-click
	          return;
	        }
	      }

	      setTimeout(function () {
	        self.pickObject(curPos);
	      }, 0);

	      this._lastClickPos = curPos;
	      this._lastClickBeginTime = this._clickBeginTime;
	    }
	  }
	};

	Picker.prototype.touchstart = function (event) {

	  event.preventDefault();
	  event.stopPropagation();

	  if (event.touches.length === 1) {
	    this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
	  }
	};

	Picker.prototype.touchend = function (event) {

	  var self = this;

	  event.preventDefault();
	  event.stopPropagation();

	  if (event.touches.length === 0 && event.changedTouches.length === 1) {
	    var pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
	    var dist = pos.sub(this._lastTouchdownPos).length();
	    if (dist < 0.01) {
	      setTimeout(function () {
	        self.pickObject(self._lastTouchdownPos);
	      }, 0);
	    }
	  }
	};

	Picker.prototype.dispose = function () {

	  for (var i = 0; i < this._listeners.length; i++) {
	    var l = this._listeners[i];
	    l.obj.removeEventListener(l.type, l.handler);
	  }
	};

	function Axes(target, targetCamera) {
	  this._target = target;
	  this._targetCamera = targetCamera;
	  this._camera = new PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
	  this._object = new AxesHelper(1);
	  this._scene = new Scene();
	  this._scene.add(this._object);

	  this._update();
	}

	Axes.prototype._update = function () {
	  var fov = this._targetCamera.fov;
	  var camera = this._camera;
	  camera.aspect = this._targetCamera.aspect;
	  camera.setMinimalFov(fov);
	  camera.setDistanceToFit(1.0, fov);
	  camera.updateProjectionMatrix();

	  this._object.quaternion.copy(this._target.quaternion);
	};

	Axes.prototype.render = function (renderer) {
	  this._update();

	  var full = renderer.getSize();
	  var width = full.width * 0.25;
	  var height = full.height * 0.25;

	  var autoClear = renderer.autoClear;
	  renderer.autoClear = false;
	  renderer.setViewport(0.0, full.height - height, width, height); // use left bottom corner
	  renderer.clear(false, true, false);
	  renderer.render(this._scene, this._camera);
	  renderer.setViewport(0, 0, full.width, full.height);
	  renderer.autoClear = autoClear;
	};

	var cDataOffset = 12;
	var cFirstMask = 0x0FFFFF00;
	var cFirstShift = 8;
	var cSecMask1 = 0x000000FF;
	var cSecShift1 = 12;
	var cSecMask2 = 0xFFF00000;
	var cSecShift2 = 20;
	var cThirdMask = 0x000FFFFF;
	var cStrMask = 0xF0000000;
	var cStrShift = 28;
	var c219 = 1 << 19;
	var c220 = 1 << 20;

	var cHelixIdx = 1;
	var cSheetIdx = 2;
	var secTypes = ['helix', 'strand'];
	var cSecNames = ['fs', 'ps', 'ns', 'us'];

	function _createSecondary(strArray, complex) {
	  var residues = complex._residues;
	  var nRes = residues.length;
	  var resid = new Uint8Array(nRes);

	  var atoms = complex._atoms;
	  for (var i = 0, n = strArray.length; i < n; ++i) {
	    var atom = atoms[i];
	    resid[atom._residue._index] = strArray[i];
	  }

	  var secondary = [];
	  var rIdx = 0;
	  while (rIdx < nRes) {
	    if (resid[rIdx] !== 0) {
	      var start = rIdx;
	      var val = resid[rIdx];
	      while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
	        ++rIdx;
	      }
	      secondary.push({ start: start, end: rIdx, type: secTypes[val - 1] });
	    }
	    ++rIdx;
	  }
	  return secondary;
	}

	function fromUInt20ToInt20(uint20) {
	  return uint20 >= c219 ? uint20 - c220 : uint20;
	}

	function FrameInfo(complex, payload, callbacks) {
	  this._complex = complex;
	  this._secondary = null;
	  this.isLoading = false;
	  this._framesRange = {
	    start: 0,
	    end: -1
	  };
	  this.frameIsReady = false;
	  this._buffer = null;
	  this._frameRequest = null;
	  this._callbacks = callbacks;
	  if (typeof payload === 'function') {
	    this._framesRequestLength = 1;
	    this._downloadDataFn = payload;
	  } else {
	    this.parseBinaryData(payload, true);
	  }
	  this.reset();
	  this.setFrame(0);
	}

	FrameInfo.prototype._prepareBuffer = function (framesStart, framesEnd) {
	  if (framesStart === undefined || framesStart === null) {
	    framesStart = 0;
	  }
	  if (framesEnd === undefined || framesEnd === null) {
	    framesEnd = framesStart + this._framesRequestLength;
	  }
	  if (this._framesCount !== undefined) {
	    framesEnd = Math.min(this._framesCount - 1, framesEnd);
	  }
	  if (this._downloadDataFn) {
	    var self = this;
	    var onDone = function onDone(data) {
	      self.isLoading = false;
	      if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
	        self._callbacks.onLoadStatusChanged();
	      }
	      self._buffer = {
	        data: data,
	        state: 'ready',
	        start: framesStart,
	        end: framesEnd
	      };
	      if (self._frameRequest !== null) {
	        var idx = self._frameRequest;
	        self._frameRequest = null;
	        self.setFrame(idx);
	      }
	    };
	    var onFail = function onFail() {
	      self.isLoading = false;
	      if (self._callbacks && typeof self._callbacks.onError === 'function') {
	        self._callbacks.onError('Streaming failed');
	      }
	    };
	    if (!this._buffer) {
	      this._buffer = {};
	    }
	    this._buffer.state = 'downloading';
	    this.isLoading = true;
	    if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
	      self._callbacks.onLoadStatusChanged();
	    }
	    this._downloadDataFn({ start: framesStart, end: framesEnd + 1 }, onDone, onFail);
	  }
	};

	FrameInfo.prototype._parseBuffer = function () {
	  if (this._buffer && this._buffer.state === 'ready') {
	    this._framesRange = {
	      start: this._buffer.start,
	      end: this._buffer.end
	    };
	    this.parseBinaryData(this._buffer.data, false);
	    var _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;
	    if (_bufferRequestStart >= this._framesCount) {
	      _bufferRequestStart = 0;
	    }
	    this._buffer = {
	      state: 'none'
	    };
	    this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);
	    if (this._frameRequest !== null) {
	      var idx = this._frameRequest;
	      this._frameRequest = null;
	      this.setFrame(idx);
	    }
	  }
	};

	FrameInfo.prototype.parseBinaryData = function (arrayBuffer) {
	  var dataView = new DataView(arrayBuffer);
	  var offset = 0;
	  var atomsCount = dataView.getUint32(offset, true);
	  offset += 4;
	  var framesCount = dataView.getUint32(offset, true);
	  this._framesCount = framesCount;
	  this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
	  offset += 4;
	  this._atomsCount = atomsCount;
	  var maxSize = 1024 * 1024; // 1 MB
	  this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
	  var chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;
	  if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
	    throw new Error();
	  }
	  var complex = this._complex;
	  var timeStep = dataView.getUint32(offset, true);
	  var iName = 0;
	  while (timeStep > 1000 && iName < cSecNames.length - 1) {
	    timeStep /= 1000;
	    ++iName;
	  }

	  this._timeStep = timeStep.toString() + ' ' + cSecNames[iName];
	  offset += 4;
	  var secondary = [];
	  var posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
	  var coordIdx = 0;
	  var secondaryArr = new Int8Array(atomsCount);
	  for (var j = 0; j < chunkedFramesCount; ++j) {
	    for (var i = 0; i < atomsCount; ++i) {
	      var hiWord = dataView.getUint32(offset, true);
	      offset += 4;
	      var loWord = dataView.getUint32(offset, true);
	      offset += 4;
	      var str = (loWord & cStrMask) >>> cStrShift;
	      var x = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
	      var y = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
	      var z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
	      secondaryArr[i] = 0;
	      if (str > 0 && str < 4) {
	        secondaryArr[i] = cHelixIdx;
	      } else if (str === 4) {
	        secondaryArr[i] = cSheetIdx;
	      }
	      posData[coordIdx++] = x / 100;
	      posData[coordIdx++] = y / 100;
	      posData[coordIdx++] = z / 100;
	    }
	    secondary.push(_createSecondary(secondaryArr, complex));
	  }
	  this._secondaryData = secondary;
	  this._data = posData;
	};

	FrameInfo.prototype.nextFrame = function () {
	  this.setFrame((this._currFrame + 1) % this._framesCount);
	};

	FrameInfo.prototype.needsColorUpdate = function (colorer) {
	  return colorer instanceof SecondaryStructureColorer;
	};

	FrameInfo.prototype.getAtomColor = function (colorer, atom) {
	  return colorer.getResidueColor(this._residues[atom._residue._index], this._complex);
	};

	FrameInfo.prototype.getResidueColor = function (colorer, residue) {
	  return colorer.getResidueColor(this._residues[residue._index], this._complex);
	};

	FrameInfo.prototype._updateSecondary = function () {
	  var i;
	  var myResidues = this._residues;
	  var n = myResidues.length;
	  for (i = 0; i < n; ++i) {
	    myResidues[i]._secondary = null;
	  }
	  var sec = this._secondaryData[this._currFrame - this._framesRange.start];
	  for (i = 0, n = sec.length; i < n; ++i) {
	    var oldSec = sec[i];
	    var start = oldSec.start;
	    var end = oldSec.end;
	    var nSec = {
	      _start: myResidues[start],
	      _end: myResidues[end],
	      type: oldSec.type,
	      generic: oldSec.generic
	    };
	    for (var j = start; j <= end; ++j) {
	      myResidues[j]._secondary = nSec;
	    }
	  }
	};

	FrameInfo.prototype.reset = function () {
	  var compRes = this._complex._residues;
	  var n = compRes.length;
	  this._residues = new Array(n);
	  var myResidues = this._residues;
	  var getSec = function getSec() {
	    return this._secondary;
	  };
	  for (var i = 0; i < n; ++i) {
	    myResidues[i] = {
	      _type: compRes[i]._type,
	      _isValid: compRes[i]._isValid,
	      _controlPoint: null,
	      _wingVector: null,
	      _secondary: null,
	      getSecondary: getSec
	    };
	  }
	};

	FrameInfo.prototype.setFrame = function (frameIdx) {
	  this.frameIsReady = false;
	  if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
	    this._currFrame = frameIdx;
	    this._cachedResidues = false;
	    this._updateSecondary();
	    this.frameIsReady = true;
	  } else {
	    this._frameRequest = frameIdx;
	    if (!this._buffer) {
	      this._prepareBuffer(frameIdx);
	    } else {
	      var self = this;
	      switch (this._buffer.state) {
	        case 'none':
	          this._prepareBuffer(frameIdx);
	          break;
	        case 'ready':
	          self._parseBuffer();
	          break;
	        default:
	          break;
	      }
	    }
	  }
	};

	FrameInfo.prototype.disableEvents = function () {
	  this._callbacks = null;
	};

	/**
	 * Returns link to atom pos vector, clone it if needed
	 */
	FrameInfo.prototype.getAtomPos = function () {
	  var vec = new Vector3();

	  return function (atomIdx) {
	    var self = this;
	    var data = self._data;
	    var idx = (self._atomsCount * (self._currFrame - self._framesRange.start) + atomIdx) * 3;
	    vec.set(data[idx], data[idx + 1], data[idx + 2]);
	    return vec;
	  };
	}();

	FrameInfo.prototype.getResidues = function () {
	  if (this._cachedResidues) {
	    return this._residues;
	  }
	  this._complex.updateToFrame(this);
	  return this._residues;
	};

	/**
	 * Create new scene object.
	 *
	 * @param {array=} params - Object required params.
	 * @param {object=} opts - Options to override defaults with.
	 *
	 *   These options are copied locally and not kept by reference, so the created instance will not reflect further
	 *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
	 *
	 * @exports SceneObject
	 * @this SceneObject
	 * @abstract
	 * @constructor
	 * @classdesc Basic class for all scene objects that are not reps.
	 */
	function SceneObject(params, opts) {
	  if (this.constructor === SceneObject) {
	    throw new Error('Can not instantiate abstract class!');
	  }
	  /**
	   * Object's options inherited (prototyped) from defaults.
	   * @type {object}
	   */
	  this.params = params;
	  this.opts = lodash.merge(utils.deriveDeep(settings.now.objects[this.type], true), opts);
	  this.needsRebuild = false;
	}

	/**
	 * Scene object identifier.
	 * @type {string}
	 */
	SceneObject.prototype.type = '__';

	/**
	 * Get object identification, probably with options.
	 * @returns {Object} field type contains type information, params - object's formal parameters,
	 * opts - changed options
	 * Options are returned if they were changed during or after object creation.
	 */
	SceneObject.prototype.identify = function () {
	  var result = {
	    type: this.type,
	    params: this.params
	  };
	  var diff = utils.objectsDiff(this.opts, settings.now.modes[this.id]);
	  if (!lodash.isEmpty(diff)) {
	    result.opts = diff;
	  }
	  return result;
	};

	SceneObject.prototype.toString = function () {
	  var paramsStr = 'o=' + this.type + ',' + this.params.join(',');
	  var optsStr = utils.compareOptionsWithDefaults(this.opts, settings.defaults.objects[this.type]);
	  return paramsStr + optsStr;
	};

	SceneObject.prototype.getGeometry = function () {
	  return this._mesh;
	};

	SceneObject.prototype.destroy = function () {
	  if (this._mesh) {
	    gfxutils.destroyObject(this._mesh);
	  }
	};

	function LinesObj(params, opts) {
	  SceneObject.call(this, params, opts);
	  if (params.length < 2) {
	    throw new Error('Wrong number of argumets on line object creation!');
	  }
	  this._id1 = params[0];
	  this._id2 = params[1];
	}

	utils.deriveClass(LinesObj, SceneObject, {
	  type: 'line'
	});

	LinesObj.prototype.constructor = LinesObj;

	LinesObj.prototype._getAtomFromName = function (complex, atomId) {
	  var err = ' - Wrong atom format it must be \'#CHAIN_NAME.#NUMBER.#ATOM_NAME\' (e.g. \'A.38.CO1\')';
	  var atom1 = complex.getAtomByFullname(atomId);
	  if (!atom1) {
	    throw new Error(atomId + err);
	  }
	  return atom1;
	};

	LinesObj.prototype.build = function (complex) {
	  var geom = new Geometry();
	  this._atom1 = this._getAtomFromName(complex, this._id1);
	  this._atom2 = this._getAtomFromName(complex, this._id2);

	  geom.vertices[0] = this._atom1._position.clone();
	  geom.vertices[1] = this._atom2._position.clone();
	  geom.dynamic = true;
	  geom.computeBoundingBox();

	  this._line = new meshes.Line(geom, new UberMaterial({
	    lights: false,
	    overrideColor: true,
	    dashedLine: true,
	    fogTransparent: settings.now.bg.transparent
	  }));
	  this._line.computeLineDistances();
	  this._line.material.setUberOptions({
	    fixedColor: new Color(this.opts.color),
	    dashedLineSize: this.opts.dashSize,
	    dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
	  });
	  this._line.material.updateUniforms();

	  this._line.raycast = function (_raycaster, _intersects) {};
	  this._mesh = this._line;
	  var transforms = complex.getTransforms();
	  if (transforms.length > 0) {
	    this._mesh = new Group();
	    this._mesh.add(this._line);
	    gfxutils.applyTransformsToMeshes(this._mesh, transforms);
	  }
	};

	LinesObj.prototype.updateToFrame = function (frameData) {
	  if (!this._atom1 || !this._atom2 || !this._line) {
	    return;
	  }
	  var geo = this._line.geometry;
	  geo.vertices[0].copy(frameData.getAtomPos(this._atom1._index));
	  geo.vertices[1].copy(frameData.getAtomPos(this._atom2._index));
	  this._line.computeLineDistances();
	  //geo.computeBoundingBox();
	  geo.computeBoundingSphere();

	  geo.verticesNeedUpdate = true;
	};

	var vertexShader$1 = "varying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n";

	var fragmentShader$1 = "uniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = vec2(1, 1) / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n";

	/* eslint-disable no-magic-numbers */

	var defaultUniforms$1 = UniformsUtils.merge([{
	  srcTex: { type: 't', value: null },
	  srcDepthTex: { type: 't', value: null },
	  srcTexSize: { type: 'v2', value: new Vector2(512, 512) },
	  color: { type: 'v3', value: null },
	  threshold: { type: 'f', value: null },
	  opacity: { type: 'f', value: 1.0 }
	}]);

	function overrideUniforms$1(params) {
	  var uniforms = UniformsUtils.clone(defaultUniforms$1);
	  for (var p in params) {
	    if (uniforms.hasOwnProperty(p)) {
	      uniforms[p].value = params[p];
	    }
	  }
	  return uniforms;
	}

	function OutlineMaterial(params) {
	  ShaderMaterial.call(this);

	  //add depth outline
	  this.depth = false;

	  var settings = {
	    uniforms: overrideUniforms$1(params),
	    vertexShader: vertexShader$1,
	    fragmentShader: fragmentShader$1,
	    transparent: true,
	    depthTest: false,
	    depthWrite: false
	  };

	  ShaderMaterial.prototype.setValues.call(this, settings);
	  this.setValues(params);
	}

	OutlineMaterial.prototype = Object.create(ShaderMaterial.prototype);
	OutlineMaterial.prototype.constructor = OutlineMaterial;

	OutlineMaterial.prototype.copy = function (source) {
	  ShaderMaterial.prototype.copy.call(this, source);
	  this.depth = source.depth;
	  return this;
	};

	OutlineMaterial.prototype.setValues = function (values) {
	  if (typeof values === 'undefined') {
	    return;
	  }

	  // set direct values
	  ShaderMaterial.prototype.setValues.call(this, values);
	  var defines = {};

	  if (this.depth) {
	    defines.DEPTH_OUTLINE = 1;
	  }

	  // set dependent values
	  this.defines = defines;
	};

	var fragmentShader$2 = "// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n";

	var defaultUniforms$2 = UniformsUtils.merge([{
	  srcTex: { type: 't', value: null },
	  srcTexelSize: { type: 'v2', value: new Vector2(1.0 / 512.0, 1.0 / 512.0) },
	  bgColor: { type: 'c', value: new Color(0xffffff) }
	}]);

	function FXAAMaterial(params) {

	  ShaderMaterial.call(this);
	  this.bgTransparent = false;

	  //TODO RawShaderMaterial? Why we use ShaderMaterial now ?
	  // set default values
	  ShaderMaterial.prototype.setValues.call(this, {
	    uniforms: UniformsUtils.clone(defaultUniforms$2),
	    vertexShader: vertexShader$1, // TODO make texccord fo samples calculated in VS to reduce PS
	    fragmentShader: fragmentShader$2,
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  });

	  this.setValues(params);
	}

	FXAAMaterial.prototype = Object.create(ShaderMaterial.prototype);
	FXAAMaterial.prototype.constructor = FXAAMaterial;

	FXAAMaterial.prototype.setValues = function (values) {
	  if (typeof values === 'undefined') {
	    return;
	  }

	  // set direct values
	  ShaderMaterial.prototype.setValues.call(this, values);

	  var defines = {};

	  if (this.bgTransparent) {
	    defines.BG_TRANSPARENT = 1;
	  }
	  // set dependent values
	  this.defines = defines;
	};

	var fragmentSSAOShader = "#define MAX_SAMPLES_COUNT 32\r\n\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nuniform vec2 fogNearFar;\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (texture2D(normalTexture, vUv).rgb * 2.0 - 1.0);\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // add fog to the AO value\r\n  AO *= 1.0 - smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z);\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / 32.0 * factor); // TODO use MAX_SAMPLES_COUNT\r\n  // check if the fragment doesn't belong to background(?)\r\n  if (abs(- viewPos.z - camNearFar.y) < 0.1) { // FIXME remove temporal fix for background darkening\r\n    gl_FragColor = vec4(1.0);\r\n    return;\r\n  }\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n";

	var fragmentHorBilateralBlur5Shader = "#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )) * weight;\r\n    weightSum += weight;\r\n  }\r\n  gl_FragColor = res / weightSum;\r\n}\r\n";

	var fragmentVertBilateralBlur5Shader = "#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)) * weight;\r\n    weightSum += weight;\r\n  }\r\n  res /= weightSum;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  gl_FragColor = vec4(color.rgb * res.rgb, color.a);\r\n}";

	var SSAOUniforms = UniformsUtils.merge([{
	  noiseTexture: { type: 't', value: null },
	  noiseTexelSize: { type: 'v2', value: new Vector2(1.0 / 512.0, 1.0 / 512.0) }, // FIXME calc uvs in vshader
	  diffuseTexture: { type: 't', value: null },
	  normalTexture: { type: 't', value: null },
	  depthTexture: { type: 't', value: null },
	  srcTexelSize: { type: 'v2', value: new Vector2(1.0 / 512.0, 1.0 / 512.0) },
	  camNearFar: { type: 'v2', value: new Vector2(1.0, 10.0) },
	  projMatrix: { type: 'mat4', value: new Matrix4() },
	  aspectRatio: { type: 'f', value: 0.0 },
	  tanHalfFOV: { type: 'f', value: 0.0 },
	  samplesKernel: { type: 'v3v', value: null },
	  kernelRadius: { type: 'f', value: 1.0 },
	  depthThreshold: { type: 'f', value: 1.0 },
	  factor: { type: 'f', value: 1.0 },
	  fogNearFar: { type: 'v2', value: new Vector2(100.0, 100.0) }
	}]);

	var blurUniforms5 = UniformsUtils.merge([{
	  diffuseTexture: { type: 't', value: null },
	  depthTexture: { type: 't', value: null },
	  srcTexelSize: { type: 'v2', value: new Vector2(1.0 / 512.0, 1.0 / 512.0) },
	  aoMap: { type: 't', value: null },
	  samplesOffsets: { type: 'fv1', value: null },
	  camNearFar: { type: 'v2', value: new Vector2(1.0, 10.0) },
	  projMatrix: { type: 'mat4', value: new Matrix4() },
	  aspectRatio: { type: 'f', value: 0.0 },
	  tanHalfFOV: { type: 'f', value: 0.0 }
	}]);

	function overrideUniforms$2(params, defUniforms) {
	  var uniforms = UniformsUtils.clone(defUniforms);
	  for (var p in params) {
	    if (uniforms.hasOwnProperty(p)) {
	      uniforms[p].value = params[p];
	    }
	  }
	  return uniforms;
	}

	function AOMaterial(params) {
	  var settings = {
	    uniforms: overrideUniforms$2(params, SSAOUniforms),
	    vertexShader: vertexShader$1,
	    fragmentShader: fragmentSSAOShader,
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  };
	  return new ShaderMaterial(settings);
	}

	function HorBilateralBlurMaterial5(params) {
	  var settings = {
	    uniforms: overrideUniforms$2(params, blurUniforms5),
	    vertexShader: vertexShader$1,
	    fragmentShader: fragmentHorBilateralBlur5Shader,
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  };
	  return new ShaderMaterial(settings);
	}

	function VertBilateralBlurMaterial5(params) {
	  var settings = {
	    uniforms: overrideUniforms$2(params, blurUniforms5),
	    vertexShader: vertexShader$1,
	    fragmentShader: fragmentVertBilateralBlur5Shader,
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  };
	  return new ShaderMaterial(settings);
	}

	var ao = {
	  AOMaterial: AOMaterial,
	  HorBilateralBlurMaterial: HorBilateralBlurMaterial5,
	  VertBilateralBlurMaterial: VertBilateralBlurMaterial5
	};

	var fragmentShader$3 = "uniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n";

	var defaultUniforms$3 = UniformsUtils.merge([{
	  srcL: { type: 't', value: null },
	  srcR: { type: 't', value: null }
	}]);

	function overrideUniforms$3(params) {
	  var uniforms = UniformsUtils.clone(defaultUniforms$3);
	  for (var p in params) {
	    if (uniforms.hasOwnProperty(p)) {
	      uniforms[p].value = params[p];
	    }
	  }
	  return uniforms;
	}

	function AnaglyphMaterial(params) {
	  var settings = {
	    uniforms: overrideUniforms$3(params),
	    vertexShader: vertexShader$1,
	    fragmentShader: fragmentShader$3,
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  };
	  return new ShaderMaterial(settings);
	}

	function View() {
	  this.position = new Vector3(0, 0, 0);
	  this.scale = 1;
	  this.orientation = new Quaternion(0, 0, 0, 1);
	}

	View.prototype.set = function (position, scale, orientation) {
	  this.position = position;
	  this.scale = scale;
	  this.orientation = orientation;
	};

	var _transitionTime = 1.5; // in seconds

	function ViewInterpolator() {}

	ViewInterpolator.prototype.setup = function (startView, endView) {

	  this._startTime = undefined;
	  this._endTime = undefined;

	  this._srcView = startView;
	  this._dstView = endView;
	  this._isMoving = false;
	};

	ViewInterpolator.prototype.isMoving = function () {
	  return this._isMoving;
	};

	ViewInterpolator.prototype.wasStarted = function () {
	  return typeof this._startTime !== 'undefined' && typeof this._endTime !== 'undefined';
	};

	ViewInterpolator.prototype.start = function () {
	  this._startTime = Date.now();
	  var transTime = settings.now.interpolateViews ? _transitionTime * 1000 : 0;
	  this._endTime = this._startTime + transTime;
	  this._isMoving = true;
	};

	ViewInterpolator.prototype.getCurrentView = function () {

	  if (typeof this._srcView === 'undefined' || typeof this._dstView === 'undefined' || !this._isMoving || !this.wasStarted()) {
	    return { success: false };
	  }

	  var view = this.createView();
	  var time = Date.now();
	  if (time > this._endTime) {
	    view = this._dstView;
	    this._reset();
	    return { success: true, view: view };
	  }

	  var factor = (time - this._startTime) / (this._endTime - this._startTime);
	  view.position.copy(this._srcView.position);
	  view.position.lerp(this._dstView.position, factor);
	  view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
	  view.orientation.copy(this._srcView.orientation);
	  view.orientation.slerp(this._dstView.orientation, factor);
	  return { success: true, view: view };
	};

	ViewInterpolator.prototype._reset = function () {
	  this._startTime = this._endTime = 0;
	  this._isMoving = false;
	};

	ViewInterpolator.prototype.createView = function () {
	  return new View();
	};

	var viewInterpolator = new ViewInterpolator();

	var prec = settings.now.fbxprec;
	var heading = ';  FBX 6.1.0 project file\n' + '; Copyright (C) 1997-2007 Autodesk Inc. and/or its licensors.\n' + '; All rights reserved.\n' + '; ----------------------------------------------------\n' + '\n' + '  FBXHeaderExtension:  {\n' + '  FBXHeaderVersion: 1003\n' + '  FBXVersion: 6100\n' + '  CreationTimeStamp:  {\n' + '    Version: 1000\n' + '    Year: 2015\n' + '    Month: 12\n' + '    Day: 7\n' + '    Hour: 17\n' + '    Minute: 34\n' + '    Second: 53\n' + '    Millisecond: 369\n' + '  }\n' + ' Creator: "FBX SDK/FBX Plugins build 20080212"\n' + '  OtherFlags:  {\n' + '    FlagPLE: 0\n' + '  }\n' + '}\n' + 'reationTime: "2015-12-07 17:34:53:369"\n' + 'reator: "FBX SDK/FBX Plugins build 20080212"\n' + '\n' + '; Document Description\n' + ';------------------------------------------------------------------\n' + '\n' + '  Document:  {\n' + ' Name: ""\n' + '}\n' + '\n' + '; Document References\n' + ';------------------------------------------------------------------\n' + '\n' + '  References:  {\n' + '}\n' + '\n' + '; Object definitions\n' + ';------------------------------------------------------------------\n' + '\n' + '  Definitions:  {\n' + '  Version: 100\n' + '  Count: 3\n' + '  ObjectType: "Model" {\n' + '    Count: 1\n' + '  }\n' + '  ObjectType: "SceneInfo" {\n' + '    Count: 1\n' + '  }\n' + '  ObjectType: "GlobalSettings" {\n' + '    Count: 1\n' + '  }\n' + '}\n' + '\n' + '; Object properties\n' + ';------------------------------------------------------------------\n' + '\n' + '  Objects:  {\n' + '  Model: "Model::Sphere01", "Mesh" {\n' + '    Version: 232\n' + '    Properties60:  {\n' + '      Property: "QuaternionInterpolate", "bool", "",0\n' + '      Property: "RotationOffset", "Vector3D", "",0,0,0\n' + '      Property: "RotationPivot", "Vector3D", "",0,0,0\n' + '      Property: "ScalingOffset", "Vector3D", "",0,0,0\n' + '      Property: "ScalingPivot", "Vector3D", "",0,0,0\n' + '      Property: "TranslationActive", "bool", "",0\n' + '      Property: "TranslationMin", "Vector3D", "",0,0,0\n' + '      Property: "TranslationMax", "Vector3D", "",0,0,0\n' + '      Property: "TranslationMinX", "bool", "",0\n' + '      Property: "TranslationMinY", "bool", "",0\n' + '      Property: "TranslationMinZ", "bool", "",0\n' + '      Property: "TranslationMaxX", "bool", "",0\n' + '      Property: "TranslationMaxY", "bool", "",0\n' + '      Property: "TranslationMaxZ", "bool", "",0\n' + '      Property: "RotationOrder", "enum", "",0\n' + '      Property: "RotationSpaceForLimitOnly", "bool", "",0\n' + '      Property: "RotationStiffnessX", "double", "",0\n' + '      Property: "RotationStiffnessY", "double", "",0\n' + '      Property: "RotationStiffnessZ", "double", "",0\n' + '      Property: "AxisLen", "double", "",10\n' + '      Property: "PreRotation", "Vector3D", "",0,0,0\n' + '      Property: "PostRotation", "Vector3D", "",0,0,0\n' + '      Property: "RotationActive", "bool", "",0\n' + '      Property: "RotationMin", "Vector3D", "",0,0,0\n' + '      Property: "RotationMax", "Vector3D", "",0,0,0\n' + '      Property: "RotationMinX", "bool", "",0\n' + '      Property: "RotationMinY", "bool", "",0\n' + '      Property: "RotationMinZ", "bool", "",0\n' + '      Property: "RotationMaxX", "bool", "",0\n' + '      Property: "RotationMaxY", "bool", "",0\n' + '      Property: "RotationMaxZ", "bool", "",0\n' + '      Property: "InheritType", "enum", "",1\n' + '      Property: "ScalingActive", "bool", "",0\n' + '      Property: "ScalingMin", "Vector3D", "",1,1,1\n' + '      Property: "ScalingMax", "Vector3D", "",1,1,1\n' + '      Property: "ScalingMinX", "bool", "",0\n' + '      Property: "ScalingMinY", "bool", "",0\n' + '      Property: "ScalingMinZ", "bool", "",0\n' + '      Property: "ScalingMaxX", "bool", "",0\n' + '      Property: "ScalingMaxY", "bool", "",0\n' + '      Property: "ScalingMaxZ", "bool", "",0\n' + '      Property: "GeometricTranslation", "Vector3D", "",0,0,0\n' + '      Property: "GeometricRotation", "Vector3D", "",0,0,0\n' + '      Property: "GeometricScaling", "Vector3D", "",1,1,1\n' + '      Property: "MinDampRangeX", "double", "",0\n' + '      Property: "MinDampRangeY", "double", "",0\n' + '      Property: "MinDampRangeZ", "double", "",0\n' + '      Property: "MaxDampRangeX", "double", "",0\n' + '      Property: "MaxDampRangeY", "double", "",0\n' + '      Property: "MaxDampRangeZ", "double", "",0\n' + '      Property: "MinDampStrengthX", "double", "",0\n' + '      Property: "MinDampStrengthY", "double", "",0\n' + '      Property: "MinDampStrengthZ", "double", "",0\n' + '      Property: "MaxDampStrengthX", "double", "",0\n' + '      Property: "MaxDampStrengthY", "double", "",0\n' + '      Property: "MaxDampStrengthZ", "double", "",0\n' + '      Property: "PreferedAngleX", "double", "",0\n' + '      Property: "PreferedAngleY", "double", "",0\n' + '      Property: "PreferedAngleZ", "double", "",0\n' + '      Property: "LookAtProperty", "object", ""\n' + '      Property: "UpVectorProperty", "object", ""\n' + '      Property: "Show", "bool", "",1\n' + '      Property: "NegativePercentShapeSupport", "bool", "",1\n' + '      Property: "DefaultAttributeIndex", "int", "",0\n' + '      Property: "Lcl Translation", "Lcl Translation", "A+",-0.169204741716385,-0.507614195346832,0\n' + '      Property: "Lcl Rotation", "Lcl Rotation", "A+",0,0,0\n' + '      Property: "Lcl Scaling", "Lcl Scaling", "A+",1,1,1\n' + '      Property: "Visibility", "Visibility", "A+",1\n' + '      Property: "BBoxMin", "Vector3D", "N",0,0,0\n' + '      Property: "BBoxMax", "Vector3D", "N",0,0,0\n' + '    }\n' + '    MultiLayer: 0\n' + '    MultiTake: 1\n' + '    Shading: T\n' + '   Culling: "CullingOff"\n';

	var ending = 'NodeAttributeName: "Geometry::Sphere01"\n' + '}\n' + 'ceneInfo: "SceneInfo::GlobalInfo", "UserData" {\n' + ' Type: "UserData"\n' + '  Version: 100\n' + '  MetaData:  {\n' + '    Version: 100\n' + '   Title: ""\n' + '   Subject: ""\n' + '   Author: ""\n' + '   Keywords: ""\n' + '   Revision: ""\n' + '   Comment: ""\n' + '  }\n' + '  Properties60:  {\n' + '    Property: "DocumentUrl", "KString", "", "D:\\depot\\MolViewer\\Assets\\models\\test1.FBX"\n' + '    Property: "SrcDocumentUrl", "KString", "", "D:\\depot\\MolViewer\\Assets\\models\\test1.FBX"\n' + '   Property: "Original", "Compound", ""\n' + '   Property: "Original|ApplicationVendor", "KString", "", "Autodesk"\n' + '   Property: "Original|ApplicationName", "KString", "", "3ds Max"\n' + '   Property: "Original|ApplicationVersion", "KString", "", "2009.0"\n' + '   Property: "Original|DateTime_GMT", "DateTime", "", "07/12/2015 14:34:53.369"\n' + '    Property: "Original|FileName", "KString", "", "D:\\depot\\MolViewer\\Assets\\models\\test1.FBX"\n' + '   Property: "LastSaved", "Compound", ""\n' + '   Property: "LastSaved|ApplicationVendor", "KString", "", "Autodesk"\n' + '   Property: "LastSaved|ApplicationName", "KString", "", "3ds Max"\n' + '   Property: "LastSaved|ApplicationVersion", "KString", "", "2009.0"\n' + '   Property: "LastSaved|DateTime_GMT", "DateTime", "", "07/12/2015 14:34:53.369"\n' + '  }\n' + '}\n' + 'lobalSettings:  {\n' + '  Version: 1000\n' + '  Properties60:  {\n' + '    Property: "UpAxis", "int", "",2\n' + '    Property: "UpAxisSign", "int", "",1\n' + '    Property: "FrontAxis", "int", "",1\n' + '    Property: "FrontAxisSign", "int", "",-1\n' + '    Property: "CoordAxis", "int", "",0\n' + '    Property: "CoordAxisSign", "int", "",1\n' + '    Property: "UnitScaleFactor", "double", "",2.54\n' + '  }\n' + '}\n' + '}\n' + '\n' + '; Object relations\n' + ';------------------------------------------------------------------\n' + '\n' + '  Relations:  {\n' + '  Model: "Model::Sphere01", "Mesh" {\n' + '  }\n' + '  SceneInfo: "SceneInfo::GlobalInfo", "UserData" {\n' + '  }\n' + '}\n' + '\n' + '; Object connections\n' + ';------------------------------------------------------------------\n' + '\n' + '  Connections:  {\n' + ' Connect: "OO", "Model::Sphere01", "Model::Scene"\n' + '}\n' + '\n' + ';Object data\n' + ';------------------------------------------------------------------\n' + '\n' + '  ObjectData:  {\n' + '}\n' + ';Takes and animation section\n' + ';----------------------------------------------------\n' + '\n' + '  Takes:  {\n' + ' Current: "Take 001"\n' + '}\n' + ';Version 5 settings\n' + ';------------------------------------------------------------------\n' + '\n' + '  Version5:  {\n' + '  AmbientRenderSettings:  {\n' + '    Version: 101\n' + '    AmbientLightColor: 0.533333003520966,0.533333003520966,0.533333003520966,1\n' + '  }\n' + '  FogOptions:  {\n' + '    FlogEnable: 0\n' + '    FogMode: 0\n' + '    FogDensity: 0.002\n' + '    FogStart: 0.3\n' + '    FogEnd: 1000\n' + '    FogColor: 1,1,1,1\n' + '  }\n' + '  Settings:  {\n' + '   FrameRate: "30"\n' + '    TimeFormat: 1\n' + '    SnapOnFrames: 0\n' + '    ReferenceTimeIndex: -1\n' + '    TimeLineStartTime: 0\n' + '    TimeLineStopTime: 153953860000\n' + '  }\n' + '  RendererSetting:  {\n' + '   DefaultCamera: ""\n' + '    DefaultViewingMode: 0\n' + '  }\n' + '}\n' + '\n';

	function _errorHandler(e) {
	  var msg;

	  switch (e.code) {
	    case FileError.QUOTA_EXCEEDED_ERR:
	      msg = 'QUOTA_EXCEEDED_ERR';
	      break;
	    case FileError.NOT_FOUND_ERR:
	      msg = 'NOT_FOUND_ERR';
	      break;
	    case FileError.SECURITY_ERR:
	      msg = 'SECURITY_ERR';
	      break;
	    case FileError.INVALID_MODIFICATION_ERR:
	      msg = 'INVALID_MODIFICATION_ERR';
	      break;
	    case FileError.INVALID_STATE_ERR:
	      msg = 'INVALID_STATE_ERR';
	      break;
	    default:
	      msg = 'Unknown Error';
	      break;
	  }
	  throw new Error(msg);
	}

	var fileSystem = null;

	function _writeToFile(filename, data, isBinary, append, callback) {
	  fileSystem.root.getFile(filename, { create: !append }, function (fileEntry) {

	    // Create a FileWriter object for our FileEntry (log.txt).
	    fileEntry.createWriter(function (fileWriter) {
	      //

	      // Create a new Blob and write it to log.txt.
	      var blob = new Blob([data], { type: isBinary ? 'octet/stream' : 'text/plain' });
	      //fileWriter.write(blob);
	      if (append) {
	        fileWriter.onwriteend = function () {
	          callback();
	        };
	        fileWriter.seek(fileWriter.length); // Start write position at EOF.
	        fileWriter.write(blob);
	      } else {
	        fileWriter.onwriteend = function () {
	          if (fileWriter.length === 0 && data.length > 0) {
	            //fileWriter has been reset, write file
	            fileWriter.write(blob);
	          } else {
	            //file has been overwritten with blob
	            //use callback or resolve promise
	            callback();
	          }
	        };
	        fileWriter.truncate(0);
	      }
	    }, _errorHandler);
	  }, _errorHandler);
	}

	function Queue() {}

	Queue.prototype.queue = [];
	Queue.prototype.busy = false;

	Queue.prototype.add = function (filename, data, isBinary, append) {
	  this.queue.push([filename, data, isBinary, append]);
	  if (!this.busy) {
	    this.next();
	  }
	};

	Queue.prototype.next = function () {
	  var params = this.queue.shift();
	  var self = this;

	  if (params && !self.busy) {
	    this.busy = true;
	    _writeToFile(params[0], params[1], params[2], params[3], function () {
	      self.busy = false;
	      self.next();
	    });
	  }
	};

	function _stringifyArray(arr) {
	  var str = [];
	  for (var i = 0, n = arr.length; i < n; ++i) {
	    str[i] = arr[i].toFixed(prec);
	  }
	  str = str.join(',');
	  return str;
	}

	function _wrapValuesVector(queue, fname, layerName, vectorName, vectorData, layerData) {

	  queue.add(fname, layerName + ': 0 {\n' + 'Version: 101\n' + 'Name: ""\n' + 'MappingInformationType: "ByVertice"\n' + 'ReferenceInformationType: "Direct"\n' + vectorName + ': ' + vectorData + '\n' + '}\n', false, true);
	  return layerData + 'LayerElement:  {\n' + 'Type: "' + layerName + '"\n' + 'TypedIndex: 0\n' + '}\n';
	}

	function _exportData(queue, indices, positions, normals, colors, uvs) {
	  var fname = 'totals.txt';
	  queue.add(fname, heading, false, false);
	  queue.add(fname, 'Vertices: ', false, true);
	  queue.add(fname, _stringifyArray(positions), false, true);
	  queue.add(fname, '\nPolygonVertexIndex: ', false, true);
	  queue.add(fname, _stringifyArray(indices), false, true);
	  queue.add(fname, '\nGeometryVersion: 124\n', false, true);

	  var layersData = 'Layer: 0 {\nVersion: 100\n';
	  if (normals !== null) {
	    layersData = _wrapValuesVector(queue, fname, 'LayerElementNormal', 'Normals', _stringifyArray(normals), layersData);
	  }

	  if (colors !== null) {
	    layersData = _wrapValuesVector(queue, fname, 'LayerElementColor', 'Colors', _stringifyArray(colors), layersData);
	  }

	  if (uvs !== null) {
	    layersData = _wrapValuesVector(queue, fname, 'LayerElementUV', 'UV', _stringifyArray(uvs), layersData);
	  }

	  layersData += '}\n';
	  queue.add(fname, layersData, false, true);

	  queue.add(fname, ending, false, true);
	}

	function _concatArrays(arr1, arr2) {
	  var arr = utils.allocateTyped(Float32Array, arr1.length + arr2.length);
	  arr.set(arr1);
	  arr.set(arr2, arr1.length);
	  return arr;
	}

	function _concatIndices(arr1, arr2, startIndex) {
	  var len1 = arr1.length;
	  var lenTotal = len1 + arr2.length;
	  var arr = utils.allocateTyped(Int32Array, lenTotal);
	  arr.set(arr1);
	  arr.set(arr2, len1);
	  for (var i = len1; i < lenTotal; ++i) {
	    arr[i] += startIndex;
	  }
	  return arr;
	}

	function _appendGeometry(structure, geom) {
	  var idc = utils.allocateTyped(Int32Array, geom.index.array);
	  if (structure.indices === null) {
	    structure.indices = idc;
	    structure.positions = utils.allocateTyped(Float32Array, geom.attributes.position.array);
	    structure.normals = utils.allocateTyped(Float32Array, geom.attributes.normal.array);
	    structure.colors = utils.allocateTyped(Float32Array, geom.attributes.color.array);
	    return;
	  }
	  structure.indices = _concatIndices(structure.indices, idc, structure.positions.length / 3);
	  structure.positions = _concatArrays(structure.positions, geom.attributes.position.array);
	  structure.normals = _concatArrays(structure.normals, geom.attributes.normal.array);
	  structure.colors = _concatArrays(structure.colors, geom.attributes.color.array);
	}

	function _prepareIndexArray(arr) {
	  for (var i = 0, n = arr.length; i < n; ++i) {
	    if (i % 3 === 2) {
	      arr[i] = ~arr[i];
	    }
	  }
	}

	function _prepareColorArray(arr) {
	  var newLen = arr.length / 3 * 4;
	  var newArr = utils.allocateTyped(Float32Array, newLen);
	  var newIdx = 0;
	  for (var i = 0, n = arr.length / 3; i < n; ++i) {
	    newArr[newIdx++] = arr[i * 3];
	    newArr[newIdx++] = arr[i * 3 + 1];
	    newArr[newIdx++] = arr[i * 3 + 2];
	    newArr[newIdx++] = 1.0;
	  }
	  return newArr;
	}

	function _dumpStructure(queue, structure) {
	  _prepareIndexArray(structure.indices);
	  structure.colors = _prepareColorArray(structure.colors);
	  _exportData(queue, structure.indices, structure.positions, structure.normals, structure.colors, null);
	}

	function exportModel(queue, complex, reprList) {
	  var structure = { indices: null };

	  function addGeoms(object) {
	    if (object instanceof Mesh) {
	      _appendGeometry(structure, object.geometry);
	    }
	    for (var i = 0, l = object.children.length; i < l; i++) {
	      addGeoms(object.children[i]);
	    }
	  }

	  for (var i = 0, n = reprList.length; i < n; ++i) {
	    var repr = reprList[i];
	    var objects = repr.buildGeometry(complex);
	    addGeoms(objects);
	  }
	  _dumpStructure(queue, structure);
	}

	function exportAtoms(queue, complex, atomsFileName, mode, colorer) {
	  queue.add(atomsFileName, '', false, false);
	  complex.forEachAtom(function (atom) {
	    var pos = atom.getPosition();
	    var col = new Color(colorer.getAtomColor(atom, complex));
	    var string = 'ATOM ' + atom._index + ' ' + pos.x + ' ' + pos.y + ' ' + pos.z + ' ' + mode.calcAtomRadius(atom) + ' ' + col.r + ' ' + col.g + ' ' + col.b + '\n';
	    queue.add(atomsFileName, string, false, true);
	  });
	}

	function exportBonds(queue, complex, bondsFileName) {
	  queue.add(bondsFileName, '', false, false);
	  complex.forEachBond(function (bond) {
	    var string = 'BIND ' + bond._left._index + ' ' + bond._right._index + '\n';
	    queue.add(bondsFileName, string, false, true);
	  });
	  queue.add(bondsFileName, 'TED', false, true);
	}

	function fbxExport(complex, reprList, fullReport) {
	  prec = settings.now.fbxprec;
	  window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
	  function onInitFS(fs) {
	    var queue = new Queue();
	    fileSystem = fs;
	    if (fullReport) {
	      exportAtoms(queue, complex, 'atoms.txt', reprList);
	      exportBonds(queue, complex, 'bonds.txt');
	    }
	    exportModel(queue, complex, reprList);
	  }
	  window.requestFileSystem(window.TEMPORARY, 1024 * 1024 * 1024, onInitFS, _errorHandler);
	}

	var MAX_COOKIE_LEN = 4000;
	var COUNT_SUFFIX = 'Cnt';

	function _chunkSrting(string, chunkLen) {
	  var l = string.length,
	      chunks = [];
	  for (var lc = 0, c = 0; lc < l; c++) {
	    chunks[c] = string.slice(lc, lc += chunkLen);
	  }
	  return chunks;
	}

	/**
	 * Create new context dependent Cookie holder object.
	 * @param context
	 * @param {Object} opts - options
	 * @param {string} opts.path - cookie path
	 * @constructor
	 */
	function Cookies(context, opts) {
	  this.context = context;
	  this._opts = lodash.merge({
	    path: '/'
	  }, opts);
	}

	makeContextDependent(Cookies.prototype);

	/**
	 * Remove cookie by the name.
	 * @param key
	 */
	Cookies.prototype.removeCookie = function (key) {
	  var cntKey = this._toCount(key);
	  var cntVal = this._getSimpleCookie(cntKey);
	  if (!cntVal) {
	    this._removeSimpleCookie(key);
	    return;
	  }
	  this._removeSimpleCookie(cntKey);
	  cntVal = parseInt(cntVal, 10);
	  for (var i = 0; i < cntVal; ++i) {
	    this._removeSimpleCookie(key + i);
	  }
	};

	/**
	 * Set new cookie value. Automatically splits
	 * values that are too large into multiple cookies.
	 * @param key
	 * @param value
	 */
	Cookies.prototype.setCookie = function (key, value) {
	  this.removeCookie(key);
	  value = encodeURIComponent(value);
	  var values = _chunkSrting(value, MAX_COOKIE_LEN - key.length - 1);
	  var cntVal = values.length;
	  if (cntVal === 1) {
	    this._setSimpleCookie(key, value);
	    return;
	  }
	  var cntKey = this._toCount(key);
	  this._setSimpleCookie(cntKey, cntVal.toString());
	  for (var i = 0; i < cntVal; ++i) {
	    this._setSimpleCookie(key + i, values[i]);
	  }
	};

	/**
	 * Obtain the value of a compound cookie.
	 * @param key
	 */
	Cookies.prototype.getCookie = function (key) {
	  var cntKey = this._toCount(key);
	  var cntVal = this._getSimpleCookie(cntKey);
	  if (!cntVal) {
	    return this._getSimpleCookie(key);
	  }
	  cntVal = parseInt(cntVal, 10);
	  var value = [];
	  for (var i = 0; i < cntVal; ++i) {
	    value[i] = this._getSimpleCookie(key + i);
	  }
	  return value.join('');
	};

	Cookies.prototype._toCount = function (key) {
	  return key + COUNT_SUFFIX;
	};

	Cookies.prototype._removeSimpleCookie = function (key) {
	  document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;';
	};

	Cookies.prototype._getExpirationDate = function () {
	  var today = new Date();
	  var EXP_PERIOD_YEARS = 10;
	  today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
	  return today;
	};

	Cookies.prototype._setSimpleCookie = function (key, value) {
	  document.cookie = key + '=' + value + ';expires=' + this._getExpirationDate().toUTCString() + ';path=' + this._opts.path;
	};

	Cookies.prototype._getSimpleCookie = function (key) {
	  var matches = document.cookie.match(new RegExp('(?:^|; )' + key + '=([^;]*)'));
	  return matches ? decodeURIComponent(matches[1]) : '';
	};

	Cookies.prototype._exists = function (key) {
	  return document.cookie.match(new RegExp('(?:^|; )' + key + '=([^;]*)'));
	};

	/**
	 * @author mrdoob / http://mrdoob.com
	 * @author stewdio / http://stewd.io
	 */

	var ViveController = function (_THREE$Object3D) {
	  inherits(ViveController, _THREE$Object3D);

	  function ViveController(id) {
	    classCallCheck(this, ViveController);

	    var _this = possibleConstructorReturn(this, (ViveController.__proto__ || Object.getPrototypeOf(ViveController)).call(this));

	    _this.gamepad = null;

	    _this.axes = [0, 0];
	    _this.thumbpadIsPressed = false;
	    _this.triggerIsPressed = false;
	    _this.gripsArePressed = false;
	    _this.menuIsPressed = false;

	    _this.matrixAutoUpdate = false;
	    _this.contrId = id;
	    _this.standingMatrix = new Matrix4();
	    return _this;
	  }

	  createClass(ViveController, [{
	    key: 'getGamepad',
	    value: function getGamepad() {
	      return this.gamepad;
	    }
	  }, {
	    key: 'getButtonState',
	    value: function getButtonState(button) {

	      if (button === 'thumbpad') return this.thumbpadIsPressed;
	      if (button === 'trigger') return this.triggerIsPressed;
	      if (button === 'grips') return this.gripsArePressed;
	      if (button === 'menu') return this.menuIsPressed;

	      return null;
	    }
	  }, {
	    key: 'findGamepad',
	    value: function findGamepad(id) {
	      // Iterate across gamepads as Vive Controllers may not be
	      // in position 0 and 1.
	      var gamepads = navigator.getGamepads && navigator.getGamepads();
	      for (var i = 0, j = 0; i < gamepads.length; i++) {
	        var gpad = gamepads[i];
	        if (gpad && (gpad.id === 'OpenVR Gamepad' || gpad.id.startsWith('Oculus Touch') || gpad.id.startsWith('Spatial Controller'))) {
	          if (j === id) {
	            return gpad;
	          }
	          j++;
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'update',
	    value: function update() {

	      this.gamepad = this.findGamepad(this.contrId);
	      if (this.gamepad && this.gamepad.pose) {
	        if (this.gamepad.pose === null) {
	          return; // No user action yet
	        }

	        //  Position and orientation.
	        var pose = this.gamepad.pose;
	        if (pose.position !== null) this.position.fromArray(pose.position);
	        if (pose.orientation !== null) this.quaternion.fromArray(pose.orientation);
	        this.matrix.compose(this.position, this.quaternion, this.scale);
	        this.matrix.premultiply(this.standingMatrix);
	        this.matrix.decompose(this.position, this.quaternion, this.scale); // someone may want to use on the frame
	        this.matrixWorldNeedsUpdate = true;
	        this.visible = true;

	        //  Thumbpad and Buttons.
	        if (this.axes[0] !== this.gamepad.axes[0] || this.axes[1] !== this.gamepad.axes[1]) {
	          this.axes[0] = this.gamepad.axes[0]; //  X axis: -1 = Left, +1 = Right.
	          this.axes[1] = this.gamepad.axes[1]; //  Y axis: -1 = Bottom, +1 = Top.
	          this.dispatchEvent({ type: 'axischanged', axes: this.axes });
	        }

	        if (this.thumbpadIsPressed !== this.gamepad.buttons[0].pressed) {
	          this.thumbpadIsPressed = this.gamepad.buttons[0].pressed;
	          this.dispatchEvent({ type: this.thumbpadIsPressed ? 'thumbpaddown' : 'thumbpadup', axes: this.axes });
	        }

	        if (this.triggerIsPressed !== this.gamepad.buttons[1].pressed) {
	          this.triggerIsPressed = this.gamepad.buttons[1].pressed;
	          this.dispatchEvent({ type: this.triggerIsPressed ? 'triggerdown' : 'triggerup' });
	        }

	        if (this.gripsArePressed !== this.gamepad.buttons[2].pressed) {
	          this.gripsArePressed = this.gamepad.buttons[2].pressed;
	          this.dispatchEvent({ type: this.gripsArePressed ? 'gripsdown' : 'gripsup' });
	        }

	        if (this.menuIsPressed !== this.gamepad.buttons[3].pressed) {
	          this.menuIsPressed = this.gamepad.buttons[3].pressed;
	          this.dispatchEvent({ type: this.menuIsPressed ? 'menudown' : 'menuup' });
	        }
	      } else {
	        this.visible = false;
	      }
	    }
	  }]);
	  return ViveController;
	}(Object3D);

	var GeoViveController = function (_ViveController) {
	  inherits(GeoViveController, _ViveController);

	  function GeoViveController(id) {
	    classCallCheck(this, GeoViveController);

	    // visualize controllers with cylinders
	    var _this = possibleConstructorReturn(this, (GeoViveController.__proto__ || Object.getPrototypeOf(GeoViveController)).call(this, id));

	    var geometry = new CylinderGeometry(0.04, 0.04, 0.3);
	    var material = new UberMaterial({ lights: false, overrideColor: true });
	    material.setUberOptions({ fixedColor: new Color(0x4444ff) });
	    material.updateUniforms();
	    var cylinder = new Mesh(geometry, material);
	    cylinder.quaternion.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2);
	    _this.add(cylinder);
	    return _this;
	  }

	  return GeoViveController;
	}(ViveController);

	/*******
	 * Toggling WebVR is done through button.click because of limitations on calling requestPresent in webVR:
	 * VRDisplay::requestPresent should be called from user gesture:
	 * https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestPresent
	 */
	function createWebVRButton (webVRPoC) {
	  function showEnterVR(display, button) {

	    button.style.display = '';
	    button.style.cursor = 'pointer';
	    button.style.left = 'calc(50% - 50px)';
	    button.style.width = '100px';

	    button.textContent = 'ENTER VR';

	    button.onmouseenter = function () {
	      button.style.opacity = '1.0';
	    };
	    button.onmouseleave = function () {
	      button.style.opacity = '0.5';
	    };

	    button.onclick = function () {
	      if (display.isPresenting) {
	        display.exitPresent();
	      } else {
	        display.requestPresent([{ source: webVRPoC.getCanvas() }]);
	        webVRPoC.translateMolecule();
	      }
	    };
	    webVRPoC.setDevice(display);
	  }

	  function showVRNotFound(button) {

	    button.style.display = '';
	    button.style.cursor = 'auto';
	    button.style.left = 'calc(50% - 75px)';
	    button.style.width = '150px';
	    button.textContent = 'VR NOT FOUND';
	    button.onmouseenter = null;
	    button.onmouseleave = null;
	    button.onclick = null;

	    webVRPoC.setDevice(null);
	  }

	  function stylizeElement(element) {
	    element.style.position = 'absolute';
	    element.style.bottom = '20px';
	    element.style.padding = '12px 6px';
	    element.style.border = '1px solid #fff';
	    element.style.borderRadius = '4px';
	    element.style.background = 'transparent';
	    element.style.color = '#fff';
	    element.style.font = 'normal 13px sans-serif';
	    element.style.textAlign = 'center';
	    element.style.opacity = '0.5';
	    element.style.outline = 'none';
	    element.style.zIndex = '999';
	  }

	  if ('getVRDisplays' in navigator) {
	    var button = document.createElement('button');
	    button.style.display = 'none';
	    stylizeElement(button);
	    window.addEventListener('vrdisplayconnect', function (event) {
	      showEnterVR(event.display, button);
	    }, false);
	    window.addEventListener('vrdisplaydisconnect', function (_event) {
	      showVRNotFound(button);
	    }, false);
	    window.addEventListener('vrdisplaypresentchange', function (event) {
	      button.textContent = event.display.isPresenting ? 'EXIT VR' : 'ENTER VR';
	    }, false);
	    navigator.getVRDisplays().then(function (displays) {
	      if (displays.length > 0) {
	        showEnterVR(displays[0], button);
	      } else {
	        showVRNotFound(button);
	      }
	    });
	    return button;
	  } else {
	    var message = document.createElement('a');
	    message.href = 'https://webvr.info';
	    message.innerHTML = 'WEBVR NOT SUPPORTED';
	    message.style.left = 'calc(50% - 90px)';
	    message.style.width = '180px';
	    message.style.textDecoration = 'none';
	    stylizeElement(message);
	    return message;
	  }
	}

	var WebVRPoC = function () {
	  function WebVRPoC(onToggle) {
	    classCallCheck(this, WebVRPoC);

	    this._mainCamera = new PerspectiveCamera();
	    this._cameraWasStored = false;
	    this._button = null;
	    this._onToggle = onToggle;

	    this._molContainer = new gfxutils.RCGroup();
	    this._user = new gfxutils.RCGroup();
	    this._scalingPivot = new Object3D();
	    this._user.add(this._scalingPivot);

	    this._controller1 = new GeoViveController(0);
	    this._controller2 = new GeoViveController(1);
	    this._user.add(this._controller1);
	    this._user.add(this._controller2);
	    this._pressedGripsCounter = 0;
	    this._distance = 0;

	    this._gfx = null;

	    var self = this;
	    function startScalingByControllers() {
	      // reset scale
	      self._distance = self._controller1.position.distanceTo(self._controller2.position);
	      gfxutils.getMiddlePoint(self._controller1.position, self._controller2.position, self._scalingPivot.position);
	      self._scalingPivot.scale.set(1, 1, 1);
	      self._scalingPivot.updateMatrix();
	      self._scalingPivot.updateMatrixWorld();
	      // link molecule to pivot
	      self._scalingPivot.addSavingWorldTransform(self._molContainer);
	    }

	    function stopScalingByControllers() {
	      self._gfx.scene.addSavingWorldTransform(self._molContainer);
	    }

	    function handleGripsDown(event) {
	      self._pressedGripsCounter++;
	      if (self._pressedGripsCounter === 2) {
	        startScalingByControllers();
	      } else if (self._pressedGripsCounter === 1) {
	        event.target.addSavingWorldTransform(self._molContainer);
	      }
	    }

	    function handleGripsUp(event) {
	      self._pressedGripsCounter--;
	      if (self._pressedGripsCounter === 1) {
	        stopScalingByControllers();
	        // reattach molecule to other controller
	        var anotherController = event.target === self._controller1 ? self._controller2 : self._controller1;
	        anotherController.addSavingWorldTransform(self._molContainer);
	      } else if (self._pressedGripsCounter === 0) {
	        self._gfx.scene.addSavingWorldTransform(self._molContainer);
	      }
	    }

	    self._controller1.addEventListener('gripsdown', handleGripsDown);
	    self._controller1.addEventListener('gripsup', handleGripsUp);
	    self._controller2.addEventListener('gripsdown', handleGripsDown);
	    self._controller2.addEventListener('gripsup', handleGripsUp);
	  }

	  /**
	   * Turn the WebVR when it is supported
	   * NOTE: we toggle using button.click, because VRDisplay.requestPresent should be called from user gesture
	   */


	  createClass(WebVRPoC, [{
	    key: 'toggle',
	    value: function toggle(enable, gfx) {
	      if (typeof gfx === 'undefined') {
	        logger.warn('WebVR couldn\'t be enabled, because gfx is not defined');
	      }
	      var self = this;
	      this._gfx = gfx;
	      var renderer = gfx ? gfx.renderer : null;
	      if (!renderer) {
	        throw new Error('No renderer is available to toggle WebVR');
	      } else if (!gfx.camera) {
	        throw new Error('No camera is available to toggle WebVR');
	      }

	      if (enable && !renderer.vr.enabled) {
	        // store common camera
	        self._mainCamera.copy(gfx.camera);
	        self._cameraWasStored = true;
	        // enable vr in renderer
	        renderer.vr.enabled = true;
	        if (!this._button) {
	          self._button = createWebVRButton(this);
	          document.body.appendChild(self._button);
	        } else {
	          self._button.style.display = 'block';
	        }
	        // add hierarchical structure for webVR into scene
	        if (self._user) {
	          gfx.scene.add(self._user);
	        }

	        settings.set('fog', false);
	        //turn on webvr transformation
	        gfx.scene.add(self._molContainer);
	        self._molContainer.add(gfx.root);

	        this._controller1.standingMatrix = renderer.vr.getStandingMatrix();
	        this._controller2.standingMatrix = renderer.vr.getStandingMatrix();
	      } else if (!enable && renderer.vr.enabled) {
	        //disable vr
	        var display = self.getDevice();
	        if (display && display.isPresenting) {
	          display.exitPresent();
	        }
	        renderer.vr.enabled = false;
	        if (self._button) {
	          self._button.style.display = 'none';
	        }
	        // restore common camera
	        if (self._cameraWasStored) {
	          gfx.camera.copy(self._mainCamera);
	        }
	        settings.set('fog', true);
	        //turn off webvr transformation
	        var root = self._molContainer.children[0];
	        if (root) gfx.scene.add(root);
	        self._molContainer.parent.remove(self._molContainer);
	        if (self._user) {
	          gfx.scene.remove(self._user);
	        }
	      }
	      if (self._onToggle) {
	        self._onToggle(enable);
	      }
	    }
	  }, {
	    key: 'updateMoleculeScale',
	    value: function updateMoleculeScale() {
	      if (!this._controller1 || !this._controller2) {
	        return;
	      }
	      this._controller1.update();
	      this._controller2.update();

	      var self = this;

	      // update molecule scaling by controllers
	      if (self._pressedGripsCounter === 2) {
	        // recalc scaling pivot
	        gfxutils.getMiddlePoint(self._controller1.position, self._controller2.position, self._scalingPivot.position);
	        // recalc scaler
	        var dist = self._controller1.position.distanceTo(self._controller2.position);
	        var scaler = dist / self._distance;
	        self._scalingPivot.scale.multiplyScalar(scaler);
	        // save cur distance for next frame
	        self._distance = dist;
	      }
	    }

	    // reposition molecule right before the camera

	  }, {
	    key: 'translateMolecule',
	    value: function translateMolecule() {
	      var device = this.getDevice();
	      if (!device) {
	        return;
	      }
	      var gfx = this._gfx;
	      var camera = gfx.camera;

	      // set container position in camera space
	      var container = this._molContainer;
	      container.matrix.identity();
	      container.position.set(0, 0, -1.3);
	      container.updateMatrix();

	      // update container world matrix
	      container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix);
	      // readd to scene
	      gfx.scene.addSavingWorldTransform(container);
	    }
	  }, {
	    key: 'getDevice',
	    value: function getDevice() {
	      var vr = this._gfx && this._gfx.renderer ? this._gfx.renderer.vr : null;
	      return vr && vr.enabled ? vr.getDevice() : null;
	    }
	  }, {
	    key: 'setDevice',
	    value: function setDevice(display) {
	      var vr = this._gfx && this._gfx.renderer ? this._gfx.renderer.vr : null;
	      if (vr) {
	        vr.setDevice(display);
	      }
	    }
	  }, {
	    key: 'getCanvas',
	    value: function getCanvas() {
	      var gfx = this._gfx;
	      return gfx && gfx.renderer ? gfx.renderer.domElement : null;
	    }
	  }]);
	  return WebVRPoC;
	}();

	/* global "0.7.20":false */

	//////////////////////////////////////////////////////////////////////////////

	var selectors$3 = chem.selectors,
	    Atom$2 = chem.Atom,
	    Residue$1 = chem.Residue,
	    Chain$2 = chem.Chain,
	    Molecule$4 = chem.Molecule;

	var EDIT_MODE = { COMPLEX: 0, COMPONENT: 1, FRAGMENT: 2 };

	var createElement$2 = utils.createElement;

	function updateFogRange(fog, center, radius) {
	  fog.near = center - radius * settings.now.fogNearFactor;
	  fog.far = center + radius * settings.now.fogFarFactor;
	}

	function removeExtension(fileName) {
	  var dot = fileName.lastIndexOf('.');
	  if (dot >= 0) {
	    fileName = fileName.substr(0, dot);
	  }
	  return fileName;
	}

	function hasValidResidues(complex) {
	  var hasValidRes = false;
	  complex.forEachComponent(function (component) {
	    component.forEachResidue(function (residue) {
	      if (residue._isValid) {
	        hasValidRes = true;
	      }
	    });
	  });
	  return hasValidRes;
	}

	function reportProgress(log, action, percent) {
	  var TOTAL_PERCENT = 100;
	  if (percent !== undefined) {
	    log.debug(action + '... ' + Math.floor(percent * TOTAL_PERCENT) + '%');
	  } else {
	    log.debug(action + '...');
	  }
	}

	function chooseFogColor() {
	  return settings.now.fogColorEnable ? settings.now.fogColor : settings.now.bg.color;
	}

	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Main 3D Molecular Viewer class.
	 *
	 * @param {object} opts - Viewer options.
	 * @param {HTMLElement=} opts.container - DOM element that serves as a viewer container.
	 * @param {object=} opts.settings - An object with properties to override default settings.
	 * @param {string=} opts.settingsCookie='settings' - The name of the cookie to save current settings to.
	 * @param {string=} opts.cookiePath='/' - The path option for cookies. Defaults to root.
	 *
	 * @exports Miew
	 * @constructor
	 */
	function Miew(opts) {
	  EventDispatcher$1.call(this);
	  this._opts = lodash.merge({
	    settingsCookie: 'settings',
	    cookiePath: '/'
	  }, opts);
	  /** @type {?object} */
	  this._gfx = null;
	  /** @type {HTMLElement} */
	  this._container = opts && opts.container || document.getElementById('miew-container') || lodash.head(document.getElementsByClassName('miew-container')) || document.body;
	  /** @type {HTMLElement} */
	  this._containerRoot = this._container;

	  /** @type {boolean} */
	  this._running = false;
	  /** @type {boolean} */
	  this._halting = false;
	  /** @type {boolean} */
	  this._building = false;
	  /** @type {boolean} */
	  this._needRender = true;
	  /** @type {boolean} */
	  this._hotKeysEnabled = true;

	  /** @type {Settings} */
	  this.settings = settings;
	  var log = logger; // TODO: add .instantiate() when migration to the "context" paradigm is finished
	  log.console = false;
	  log.level = 'info';
	  /**
	   * @type {Logger}
	   * @example
	   * miew.logger.addEventListener('message', function _onLogMessage(evt) {
	   *   console.log(evt.message);
	   * });
	   */
	  this.logger = log;

	  this._cookies = new Cookies(this);
	  this.restoreSettings();
	  if (opts && opts.settings) {
	    this.settings.set(opts.settings);
	  }

	  /** @type {?Spinner} */
	  this._spinner = null;
	  /** @type {JobHandle[]} */
	  this._loading = [];
	  /** @type {?number} */
	  this._animInterval = null;

	  /** @type {object} */
	  this._visuals = {};
	  /** @type {?string} */
	  this._curVisualName = null;

	  /** @type {array} */
	  this._objects = [];

	  /** @type {object} */
	  this._sourceWindow = null;

	  // TODO make this being not so ugly

	  this._srvTopoSource = null;
	  this._srvAnimSource = null;

	  this.reset();

	  if (this._repr) {
	    log.debug('Selected ' + this._repr.mode.name + ' mode with ' + this._repr.colorer.name + ' colorer.');
	  }

	  var self = this;
	  Miew.registeredPlugins.forEach(function (plugin) {
	    plugin.call(self);
	  });

	  this._initOnSettingsChanged();
	}

	Miew.prototype = Object.create(EventDispatcher$1.prototype);
	Miew.prototype.constructor = Miew;

	Miew.prototype.getMaxRepresentationCount = function () {
	  return ComplexVisual.NUM_REPRESENTATION_BITS;
	};

	/**
	 * Initialize the viewer.
	 * @returns {boolean} true on success.
	 * @throws Forwards exception raised during initialization.
	 * @see Miew#term
	 */
	Miew.prototype.init = function () {
	  var container = this._container;
	  var elem = utils.createElement('div', { 'class': 'miew-canvas' });
	  _setContainerContents(container, elem);
	  this._container = elem;

	  var frag = document.createDocumentFragment();
	  frag.appendChild(this._msgMode = createElement$2('div', { 'class': 'mode-message overlay' }, createElement$2('p', {}, 'COMPONENT EDIT MODE')));
	  frag.appendChild(this._msgAtomInfo = createElement$2('div', { 'class': 'atom-info overlay' }, createElement$2('p', {}, '')));
	  container.appendChild(frag);

	  if (this._gfx !== null) {
	    //block double init
	    return true;
	  }

	  var self = this;
	  this._showMessage('Viewer is being initialized...');
	  try {

	    this._initGfx();

	    this._initListeners();
	    this._spinner = new Spinner({
	      lines: 13,
	      length: 28,
	      width: 14,
	      radius: 42,
	      color: '#fff',
	      zIndex: 700
	    });

	    window.top.addEventListener('keydown', function (event) {
	      self._onKeyDown(event);
	    });

	    window.top.addEventListener('keyup', function (event) {
	      self._onKeyUp(event);
	    });

	    this._objectControls = new ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, function () {
	      return self._getAltObj();
	    });
	    this._objectControls.addEventListener('change', function (e) {
	      // route rotate and zoom events to the external API
	      switch (e.action) {
	        case 'rotate':
	          self.dispatchEvent({ type: 'rotate', angle: e.angle });
	          break;
	        case 'zoom':
	          self.dispatchEvent({ type: 'zoom', factor: e.factor });
	          break;
	        default:
	      }
	      self.dispatchEvent({ type: 'transform' });
	      self._needRender = true;
	    });

	    var gfx = this._gfx;
	    this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement);
	    this._picker.addEventListener('newpick', function (event) {
	      self._onPick(event);
	    });
	    this._picker.addEventListener('dblclick', function (event) {
	      self._onDblClick(event);
	    });

	    if (!settings._changed['bg.color']) {
	      settings.set('bg.color', settings.now.themes[settings.now.theme]);
	    }
	  } catch (error) {
	    // FIXME: THREE.WebGLRenderer throws error AND catches it, so we receive different one. Some random crash.
	    if (error.name === 'TypeError' && error.message === 'Cannot read property \'getExtension\' of null') {
	      this._showMessage('Could not create WebGL context.');
	    } else {
	      this._showMessage('Viewer initialization failed.');
	      throw error;
	    }
	    return false;
	  }

	  // automatically load default file
	  var file = this._opts && this._opts.load;
	  if (file) {
	    var type = this._opts && this._opts.type;
	    this.load(file, { fileType: type, keepRepsInfo: true });
	  }

	  return true;
	};

	/**
	 * Terminate the viewer completely.
	 * @see Miew#init
	 */
	Miew.prototype.term = function () {
	  this._showMessage('Viewer has been terminated.');
	  this._loading.forEach(function (job) {
	    job.cancel();
	  });
	  this._loading.length = 0;
	  this.halt();
	  this._gfx = null;
	};

	/**
	 * Replace viewer container contents with a DOM element.
	 * @param {HTMLElement} container - parent container.
	 * @param {HTMLElement} element - DOM element to show.
	 * @private
	 */
	function _setContainerContents(container, element) {
	  var parent = container;
	  while (parent.firstChild) {
	    parent.removeChild(parent.firstChild);
	  }
	  parent.appendChild(element);
	}

	/**
	 * Display message inside the viewer container, hiding WebGL canvas.
	 * @param {string} msg - Message to show.
	 * @private
	 */
	Miew.prototype._showMessage = function (msg) {
	  var element = document.createElement('div');
	  element.setAttribute('class', 'miew-message');
	  element.appendChild(document.createElement('p')).appendChild(document.createTextNode(msg));
	  _setContainerContents(this._container, element);
	};

	/**
	 * Display WebGL canvas inside the viewer container, hiding any message shown.
	 * @private
	 */
	Miew.prototype._showCanvas = function () {
	  _setContainerContents(this._container, this._gfx.renderer.domElement);
	};

	/**
	 * Initialize WebGL and set 3D scene up.
	 * @private
	 */
	Miew.prototype._initGfx = function () {
	  var _this = this;

	  var gfx = {
	    width: this._container.clientWidth,
	    height: this._container.clientHeight
	  };

	  var webGLOptions = { preserveDrawingBuffer: true, alpha: true, premultipliedAlpha: false };
	  if (settings.now.antialias) {
	    webGLOptions.antialias = true;
	  }

	  gfx.renderer2d = new CSS2DRenderer();

	  gfx.renderer = new WebGLRenderer(webGLOptions);
	  capabilities.init(gfx.renderer);

	  // z-sprites and ambient occlusion possibility
	  if (!gfx.renderer.getContext().getExtension('EXT_frag_depth')) {
	    settings.set('zSprites', false);
	  }
	  if (!gfx.renderer.getContext().getExtension('WEBGL_depth_texture') || !gfx.renderer.getContext().getExtension('WEBGL_draw_buffers')) {
	    settings.set('ao', false);
	  }

	  gfx.renderer.autoClear = false;
	  gfx.renderer.setPixelRatio(window.devicePixelRatio);
	  gfx.renderer.setSize(gfx.width, gfx.height);
	  gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
	  gfx.renderer.clearColor();

	  gfx.renderer2d.setSize(gfx.width, gfx.height);

	  gfx.camera = new PerspectiveCamera(settings.now.camFov, gfx.width / gfx.height, settings.now.camNear, settings.now.camFar);
	  gfx.camera.setMinimalFov(settings.now.camFov);
	  gfx.camera.position.z = settings.now.camDistance;
	  gfx.camera.updateProjectionMatrix();
	  gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
	  gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
	  gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);

	  gfx.stereoCam = new StereoCamera();

	  gfx.scene = new Scene();

	  var color = chooseFogColor();
	  gfx.scene.fog = new Fog(color, settings.now.camNear, settings.now.camFar);

	  gfx.root = new gfxutils.RCGroup();
	  gfx.scene.add(gfx.root);

	  gfx.pivot = new gfxutils.RCGroup();
	  gfx.root.add(gfx.pivot);

	  gfx.selectionScene = new Scene();
	  gfx.selectionRoot = new Group();
	  gfx.selectionRoot.matrixAutoUpdate = false;
	  gfx.selectionScene.add(gfx.selectionRoot);

	  gfx.selectionPivot = new Group();
	  gfx.selectionPivot.matrixAutoUpdate = false;
	  gfx.selectionRoot.add(gfx.selectionPivot);

	  // TODO: Either stay with a single light or revert this commit
	  var light12 = new DirectionalLight(0xffffff, 0.45);
	  light12.position.set(0, 0.414, 1);
	  light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
	  gfx.scene.add(light12);

	  var light3 = new AmbientLight(0x666666);
	  light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
	  gfx.scene.add(light3);

	  // add axes
	  gfx.axes = new Axes(gfx.root, gfx.camera);

	  gfx.offscreenBuf = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	    minFilter: LinearFilter, magFilter: NearestFilter, format: RGBAFormat, depthBuffer: true
	  });

	  if (gfx.renderer.getContext().getExtension('WEBGL_depth_texture')) {
	    gfx.offscreenBuf.depthTexture = new DepthTexture();
	    gfx.offscreenBuf.depthTexture.type = UnsignedShortType;
	  }

	  gfx.offscreenBuf2 = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	    minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, depthBuffer: false
	  });

	  gfx.offscreenBuf3 = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	    minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, depthBuffer: false
	  });

	  gfx.offscreenBuf4 = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	    minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, depthBuffer: false
	  });

	  gfx.volBFTex = gfx.offscreenBuf3;
	  gfx.volFFTex = gfx.offscreenBuf4;
	  gfx.volWFFTex = gfx.offscreenBuf;

	  // use float textures for volume rendering if possible
	  if (gfx.renderer.getContext().getExtension('OES_texture_float')) {
	    gfx.offscreenBuf5 = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	      minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, type: FloatType,
	      depthBuffer: false
	    });

	    gfx.offscreenBuf6 = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	      minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, type: FloatType,
	      depthBuffer: false
	    });

	    gfx.offscreenBuf7 = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	      minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, type: FloatType,
	      depthBuffer: true
	    });

	    gfx.volBFTex = gfx.offscreenBuf5;
	    gfx.volFFTex = gfx.offscreenBuf6;
	    gfx.volWFFTex = gfx.offscreenBuf7;
	  } else {
	    this.logger.warn('Device doesn\'t support OES_texture_float extension');
	  }

	  gfx.stereoBufL = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	    minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, depthBuffer: false
	  });

	  gfx.stereoBufR = new WebGLRenderTarget(gfx.width * window.devicePixelRatio, gfx.height * window.devicePixelRatio, {
	    minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat, depthBuffer: false
	  });

	  this._gfx = gfx;
	  this._showCanvas();

	  if (settings.now.stereo === 'WEBVR') {
	    this.webVR = new WebVRPoC(function () {
	      _this._needRender = true;
	      _this._onResize();
	    });
	    this.webVR.toggle(true, gfx);
	  }

	  this._container.appendChild(gfx.renderer2d.getElement());

	  // add FPS counter
	  var stats = new Stats();
	  stats.domElement.style.position = 'absolute';
	  stats.domElement.style.right = '0';
	  stats.domElement.style.bottom = '0';
	  this._container.appendChild(stats.domElement);
	  this._fps = stats;
	  this._fps.show(settings.now.fps);
	};

	/**
	 * Setup event listeners.
	 * @private
	 */
	Miew.prototype._initListeners = function () {
	  var self = this;
	  window.addEventListener('resize', function _onResize() {
	    self._onResize();
	  });
	};

	/**
	 * Try to add numbers to the base name to make it unique among visuals
	 * @private
	 */
	Miew.prototype._makeUniqueVisualName = function (baseName) {
	  if (!baseName) {
	    return Math.random().toString();
	  }

	  var name = baseName;
	  var suffix = 1;
	  while (this._visuals.hasOwnProperty(name)) {
	    name = baseName + ' (' + suffix.toString() + ')';
	    suffix++;
	  }

	  return name;
	};

	/**
	 * Add visual to the viewer
	 * @private
	 */
	Miew.prototype._addVisual = function (visual) {
	  if (!visual) {
	    return null;
	  }

	  // change visual name in order to make it unique
	  var name = this._makeUniqueVisualName(visual.name);
	  visual.name = name;

	  this._visuals[name] = visual;
	  this._gfx.pivot.add(visual);
	  if (visual.getSelectionGeo) {
	    this._gfx.selectionPivot.add(visual.getSelectionGeo());
	  }

	  return name;
	};

	/**
	 * Remove visual from the viewer
	 * @private
	 */
	Miew.prototype._removeVisual = function (visual) {
	  var name = '';
	  var obj = null;
	  if (visual instanceof Visual) {
	    name = visual.name;
	    obj = visual;
	  } else if (typeof visual === 'string') {
	    name = visual;
	    obj = this._visuals[name];
	  }

	  if (!obj || !this._visuals.hasOwnProperty(name) || this._visuals[name] !== obj) {
	    return;
	  }

	  if (name === this._curVisualName) {
	    this._curVisualName = undefined; // TODO: implement a proper way of handling visuals
	  }

	  delete this._visuals[name];
	  obj.release(); // removes nodes from scene

	  this._needRender = true;
	};

	/**
	 * Call specified function for each Visual
	 * @private
	 */
	Miew.prototype._forEachVisual = function (callback) {
	  for (var name in this._visuals) {
	    if (this._visuals.hasOwnProperty(name)) {
	      callback(this._visuals[name]);
	    }
	  }
	};

	/**
	 * Release (destroy) all visuals in the scene
	 * @private
	 */
	Miew.prototype._releaseAllVisuals = function () {
	  if (!this._gfx || !this._gfx.pivot) {
	    return;
	  }

	  for (var name in this._visuals) {
	    if (this._visuals.hasOwnProperty(name)) {
	      this._visuals[name].release();
	    }
	  }

	  this._visuals = {};
	};

	/**
	 * Call specified function for each ComplexVisual
	 * @private
	 */
	Miew.prototype._forEachComplexVisual = function (callback) {
	  if (!this._gfx || !this._gfx.pivot) {
	    return;
	  }

	  for (var name in this._visuals) {
	    if (this._visuals.hasOwnProperty(name) && this._visuals[name] instanceof ComplexVisual) {
	      callback(this._visuals[name]);
	    }
	  }
	};

	/**
	 * Returns ComplexVisual with specified name, or current (if not found), or any, or null
	 * @private
	 */
	Miew.prototype._getComplexVisual = function (name) {
	  name = name || this._curVisualName;
	  var any = null;
	  var named = null;
	  this._forEachComplexVisual(function (visual) {
	    any = visual;
	    if (visual.name === name) {
	      named = visual;
	    }
	  });
	  return named || any;
	};

	/**
	 * Returns first found VolumeVisual (no more than one should be present actually)
	 * @private
	 */
	Miew.prototype._getVolumeVisual = function () {
	  var any = null;
	  this._forEachVisual(function (visual) {
	    if (visual instanceof VolumeVisual) {
	      any = visual;
	    }
	  });
	  return any;
	};

	/**
	 * Returns ComplexVisual corresponding to specified complex
	 * @private
	 */
	Miew.prototype._getVisualForComplex = function (complex) {
	  if (!complex) {
	    return null;
	  }

	  var found = null;
	  this._forEachComplexVisual(function (visual) {
	    if (visual.getComplex() === complex) {
	      found = visual;
	    }
	  });
	  return found;
	};

	/*
	   * Get a list of names of visuals currently shown by the viewer
	   */
	Miew.prototype.getVisuals = function () {
	  return Object.keys(this._visuals);
	};

	/*
	   * Get current visual
	   */
	Miew.prototype.getCurrentVisual = function () {
	  return this._curVisualName;
	};

	/*
	   * Set current visual.
	   * All further operations will be performed on this visual (complex) if not stated otherwise.
	   */
	Miew.prototype.setCurrentVisual = function (name) {
	  if (!this._visuals[name]) {
	    return;
	  }

	  this._curVisualName = name;
	};

	/**
	 * Run the viewer, start processing update/render frames periodically.
	 * Has no effect if already running.
	 * @see Miew#halt
	 */
	Miew.prototype.run = function () {
	  var _this2 = this;

	  if (!this._running) {
	    this._running = true;
	    if (this._halting) {
	      this._halting = false;
	      return;
	    }

	    this._objectControls.enable(true);

	    var device = this.webVR ? this.webVR.getDevice() : null;
	    (device || window).requestAnimationFrame(function () {
	      return _this2._onTick();
	    });
	  }
	};

	/**
	 * Request the viewer to stop.
	 * Will be processed during the next frame.
	 * @see Miew#run
	 */
	Miew.prototype.halt = function () {
	  if (this._running) {
	    this._discardComponentEdit();
	    this._discardFragmentEdit();
	    this._objectControls.enable(false);
	    this._halting = true;
	  }
	};

	/**
	 * Request the viewer to start / stop responsing
	 * on hot keys.
	 * @param enabled - start (true) or stop (false) response on hot keys.
	 */
	Miew.prototype.enableHotKeys = function (enabled) {
	  this._hotKeysEnabled = enabled;
	  this._objectControls.enableHotkeys(enabled);
	};

	/**
	 * Callback which processes window resize.
	 * @private
	 */
	Miew.prototype._onResize = function () {
	  this._needRender = true;

	  var gfx = this._gfx;
	  gfx.width = this._container.clientWidth;
	  gfx.height = this._container.clientHeight;

	  gfx.camera.aspect = gfx.width / gfx.height;
	  gfx.camera.setMinimalFov(settings.now.camFov);
	  gfx.camera.updateProjectionMatrix();

	  gfx.renderer.setSize(gfx.width, gfx.height);
	  gfx.renderer2d.setSize(gfx.width, gfx.height);

	  this.dispatchEvent({ type: 'resize' });
	};

	Miew.prototype._resizeOffscreenBuffers = function (width, height, stereo) {
	  var gfx = this._gfx;
	  stereo = stereo || 'NONE';
	  var isAnaglyph = stereo === 'NONE' || stereo === 'ANAGLYPH';
	  var multi = isAnaglyph ? 1 : 0.5;
	  gfx.offscreenBuf.setSize(multi * width, height);
	  gfx.offscreenBuf2.setSize(multi * width, height);
	  gfx.offscreenBuf3.setSize(multi * width, height);
	  gfx.offscreenBuf4.setSize(multi * width, height);
	  if (gfx.offscreenBuf5) {
	    gfx.offscreenBuf5.setSize(multi * width, height);
	  }
	  if (gfx.offscreenBuf6) {
	    gfx.offscreenBuf6.setSize(multi * width, height);
	  }
	  if (gfx.offscreenBuf7) {
	    gfx.offscreenBuf7.setSize(multi * width, height);
	  }
	  if (isAnaglyph) {
	    gfx.stereoBufL.setSize(width, height);
	    gfx.stereoBufR.setSize(width, height);
	  }
	};

	/**
	 * Callback which processes update/render frames.
	 * @private
	 */
	Miew.prototype._onTick = function () {
	  var _this3 = this;

	  if (this._halting) {
	    this._running = false;
	    this._halting = false;
	    return;
	  }

	  this._fps.update();

	  var device = this.webVR ? this.webVR.getDevice() : null;
	  (device || window).requestAnimationFrame(function () {
	    return _this3._onTick();
	  });

	  this._onUpdate();
	  if (this._needRender) {
	    this._onRender();
	    this._needRender = !settings.now.suspendRender || settings.now.stereo === 'WEBVR' || !!device;
	  }
	};

	Miew.prototype._getBSphereRadius = function () {
	  // calculate radius that would include all visuals
	  var radius = 0;
	  this._forEachVisual(function (visual) {
	    radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
	  });
	  return radius * this._objectControls.getScale();
	};

	Miew.prototype._updateFog = function () {
	  var gfx = this._gfx;

	  if (settings.now.fog) {
	    if (typeof gfx.scene.fog === 'undefined' || gfx.scene.fog === null) {
	      var color = chooseFogColor();
	      gfx.scene.fog = new Fog(color);
	      this._setUberMaterialValues({ fog: settings.now.fog });
	    }
	    updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
	  } else if (gfx.scene.fog) {
	    gfx.scene.fog = undefined;
	    this._setUberMaterialValues({ fog: settings.now.fog });
	  }
	  this._needRender = true;
	};

	Miew.prototype._onUpdate = function () {

	  if (this.isScriptingCommandAvailable !== undefined && this.isScriptingCommandAvailable() && !this._building) {
	    this.callNextCmd();
	  }

	  this._objectControls.update();

	  this._forEachComplexVisual(function (visual) {
	    visual.getComplex().update();
	  });

	  if (settings.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
	    this.rebuild();
	  }

	  if (!this._loading.length && !this._building && !this._needRebuild()) {
	    this._updateView();
	  }

	  this._updateFog();

	  if (this._gfx.renderer.vr.enabled) {
	    this.webVR.updateMoleculeScale();
	  }
	};

	Miew.prototype._onRender = function () {
	  var gfx = this._gfx;

	  // update all matrices
	  gfx.scene.updateMatrixWorld();
	  gfx.camera.updateMatrixWorld();

	  this._clipPlaneUpdateValue(this._getBSphereRadius());
	  this._fogFarUpdateValue();

	  gfx.renderer.clearTarget(null);

	  this._renderFrame(settings.now.stereo);
	};

	Miew.prototype._renderFrame = function () {

	  var _anaglyphMat = new AnaglyphMaterial();

	  return function (stereo) {
	    var gfx = this._gfx;
	    var renderer = gfx.renderer;

	    if (stereo !== 'NONE') {
	      // in anaglyph mode we render full-size image for each eye
	      // while in other stereo modes only half-size (two images on the screen)
	      gfx.stereoCam.aspect = stereo === 'ANAGLYPH' ? 1.0 : 0.5;

	      gfx.camera.focus = gfx.camera.position.z; // set focus to the center of the object
	      gfx.stereoCam.update(gfx.camera);
	    }

	    var size = renderer.getSize();

	    // resize offscreen buffers to match the target
	    this._resizeOffscreenBuffers(size.width * window.devicePixelRatio, size.height * window.devicePixelRatio, stereo);

	    switch (stereo) {
	      case 'WEBVR':
	      case 'NONE':
	        this._renderScene(gfx.camera, false);
	        break;
	      case 'SIMPLE':
	      case 'DISTORTED':
	        renderer.setScissorTest(true);

	        renderer.setScissor(0, 0, size.width / 2, size.height);
	        renderer.setViewport(0, 0, size.width / 2, size.height);
	        this._renderScene(this._gfx.stereoCam.cameraL, stereo === 'DISTORTED');

	        renderer.setScissor(size.width / 2, 0, size.width / 2, size.height);
	        renderer.setViewport(size.width / 2, 0, size.width / 2, size.height);
	        this._renderScene(this._gfx.stereoCam.cameraR, stereo === 'DISTORTED');

	        renderer.setScissorTest(false);
	        break;
	      case 'ANAGLYPH':
	        this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);
	        this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);
	        _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL;
	        _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR;
	        gfx.renderer.renderScreenQuad(_anaglyphMat);
	        break;
	      default:
	    }

	    gfx.renderer2d.render(gfx.scene, gfx.camera);

	    if (settings.now.axes && gfx.axes && !gfx.renderer.vr.enabled) {
	      gfx.axes.render(renderer);
	    }
	  };
	}();
	/** @deprecated - use _onBgColorChanged */
	Miew.prototype._onThemeChanged = function () {
	  var themeRE = /\s*theme-\w+\b/g;
	  return function () {
	    var theme = settings.now.theme;
	    var div = this._containerRoot;
	    div.className = div.className.replace(themeRE, '') + ' theme-' + theme;

	    settings.set('bg.color', settings.now.themes[theme]);
	    this._needRender = true;
	  };
	}();

	Miew.prototype._onBgColorChanged = function () {
	  var gfx = this._gfx;
	  var color = chooseFogColor();
	  if (gfx) {
	    if (gfx.scene.fog) {
	      gfx.scene.fog.color.set(color);
	    }
	    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
	  }
	  this._needRender = true;
	};

	Miew.prototype._onFogColorChanged = function () {
	  var gfx = this._gfx;
	  var color = chooseFogColor();
	  if (gfx && gfx.scene.fog) {
	    gfx.scene.fog.color.set(color);
	  }
	  this._needRender = true;
	};

	Miew.prototype._setUberMaterialValues = function (values) {
	  this._gfx.root.traverse(function (obj) {
	    if ((obj instanceof Mesh || obj instanceof LineSegments || obj instanceof Line) && obj.material instanceof UberMaterial) {
	      obj.material.setValues(values);
	      obj.material.needsUpdate = true;
	    }
	  });
	};

	Miew.prototype._setMRT = function (renderBuffer, textureBuffer) {
	  var gfx = this._gfx;
	  var gl = gfx.renderer.getContext();
	  var ext = gl.getExtension('WEBGL_draw_buffers');
	  var properties = gfx.renderer.properties;

	  //take extra texture from Texture Buffer
	  gfx.renderer.setRenderTarget(textureBuffer);
	  var tx8 = properties.get(textureBuffer.texture).__webglTexture;
	  gl.bindTexture(gl.TEXTURE_2D, tx8);

	  //take texture and farmebuffer from renderbuffer
	  gfx.renderer.setRenderTarget(renderBuffer);
	  var fb = properties.get(renderBuffer).__webglFramebuffer;
	  var tx = properties.get(renderBuffer.texture).__webglTexture;

	  //set framebuffer
	  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	  fb.width = renderBuffer.width;
	  fb.height = renderBuffer.height;
	  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
	  gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0);

	  //mapping textures
	  ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
	};

	Miew.prototype._renderScene = function () {
	  return function (camera, distortion, target) {
	    distortion = distortion || false;
	    target = target || null;

	    var gfx = this._gfx;

	    // render to offscreen buffer
	    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
	    gfx.renderer.clearTarget(target);
	    if (gfx.renderer.vr.enabled) {
	      gfx.renderer.render(gfx.scene, camera);
	      return;
	    }
	    gfx.renderer.clearTarget(gfx.offscreenBuf); // FIXME clean up targets in render selection

	    var bHaveComplexes = this._getComplexVisual() !== null;
	    var volumeVisual = this._getVolumeVisual();

	    if (bHaveComplexes && settings.now.ao) {
	      this._setMRT(gfx.offscreenBuf, gfx.offscreenBuf4);
	    }

	    if (settings.now.transparency === 'prepass') {
	      this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
	    } else if (settings.now.transparency === 'standard') {
	      gfx.renderer.render(gfx.scene, camera, gfx.offscreenBuf);
	    }

	    // when fxaa we should get resulting image in temp off-screen buff2 for further postprocessing with fxaa filter
	    // otherwise we render to canvas
	    var outline = bHaveComplexes && settings.now.outline.on;
	    var fxaa = bHaveComplexes && settings.now.fxaa;
	    var volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
	    var dstBuffer = outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
	    var srcBuffer = gfx.offscreenBuf;

	    if (bHaveComplexes && settings.now.ao) {
	      this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);
	    } else {
	      // just copy color buffer to dst buffer
	      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0, dstBuffer);
	    }

	    //outline
	    if (outline) {
	      srcBuffer = dstBuffer;
	      dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;
	      if (srcBuffer != null) {
	        this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
	      }
	    }

	    // render selected part with outline material
	    this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);

	    if (volume) {
	      // copy current picture to the buffer that retains depth-data of the original molecule render
	      // so that volume renderer could use depth-test
	      gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0, gfx.offscreenBuf);
	      dstBuffer = gfx.offscreenBuf;
	      this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex);

	      // if this is the last stage -- copy image to target
	      if (!fxaa && !distortion) {
	        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0, target);
	      }
	    }

	    srcBuffer = dstBuffer;

	    if (fxaa) {
	      dstBuffer = distortion ? gfx.offscreenBuf2 : target;
	      this._performFXAA(srcBuffer, dstBuffer);
	      srcBuffer = dstBuffer;
	    }

	    if (distortion) {
	      dstBuffer = target;
	      this._performDistortion(srcBuffer, dstBuffer, true);
	    }
	  };
	}();

	Miew.prototype._performDistortion = function () {

	  var _scene = new Scene();
	  var _camera = new OrthographicCamera(-1.0, 1.0, 1.0, -1.0, -500, 1000);

	  var _material = new ShaderMaterial({
	    uniforms: {
	      srcTex: { type: 't', value: null },
	      aberration: { type: 'fv3', value: new Vector3(1.0) }
	    },
	    vertexShader: 'varying vec2 vUv; ' + 'void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }',
	    fragmentShader: 'varying vec2 vUv; uniform sampler2D srcTex; uniform vec3 aberration;' + 'void main() {' + 'vec2 uv = vUv * 2.0 - 1.0;' + 'gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;' + 'gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;' + 'gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;' + 'gl_FragColor.a = 1.0;' + '}',
	    transparent: false,
	    depthTest: false,
	    depthWrite: false
	  });

	  var _geo = gfxutils.buildDistorionMesh(10, 10, settings.now.debug.stereoBarrel);
	  _scene.add(new meshes.Mesh(_geo, _material));

	  return function (srcBuffer, targetBuffer, mesh) {

	    this._gfx.renderer.clearTarget(targetBuffer);

	    if (mesh) {
	      _material.uniforms.srcTex.value = srcBuffer.texture;
	      _material.uniforms.aberration.value.set(0.995, 1.0, 1.01);
	      this._gfx.renderer.render(_scene, _camera, targetBuffer);
	    } else {
	      this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings.now.debug.stereoBarrel, targetBuffer);
	    }
	  };
	}();

	Miew.prototype._renderOutline = function () {

	  var _outlineMaterial = new OutlineMaterial({ depth: true });

	  return function (camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {

	    var self = this;
	    var gfx = self._gfx;

	    // apply Sobel filter -- draw outline
	    _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
	    _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;
	    _outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);
	    _outlineMaterial.uniforms.color.value = new Color(settings.now.outline.color);
	    _outlineMaterial.uniforms.threshold.value = settings.now.outline.threshold;

	    gfx.renderer.renderScreenQuad(_outlineMaterial, targetBuffer);
	  };
	}();

	Miew.prototype._renderSelection = function () {

	  var _outlineMaterial = new OutlineMaterial();

	  return function (camera, srcBuffer, targetBuffer) {

	    var self = this;
	    var gfx = self._gfx;

	    // clear offscreen buffer (leave z-buffer intact)
	    gfx.renderer.setClearColor('black', 0);
	    gfx.renderer.clearTarget(srcBuffer, true, false, false);

	    // render selection to offscreen buffer
	    if (gfx.selectionPivot.children.length > 0) {
	      gfx.selectionRoot.matrix = gfx.root.matrix;
	      gfx.selectionPivot.matrix = gfx.pivot.matrix;
	      gfx.renderer.render(gfx.selectionScene, camera, srcBuffer);
	    } else {
	      // just render something to force "target clear" operation to finish
	      gfx.renderer.renderDummyQuad(srcBuffer);
	    }

	    // overlay to screen
	    gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6, targetBuffer);

	    // apply Sobel filter -- draw outline
	    _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;
	    _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);
	    gfx.renderer.renderScreenQuad(_outlineMaterial, targetBuffer);
	  };
	}();

	Miew.prototype._checkVolumeRenderingSupport = function (renderTarget) {
	  if (!renderTarget) {
	    return false;
	  }
	  var gfx = this._gfx;
	  var oldRT = gfx.renderer.getRenderTarget();

	  gfx.renderer.setRenderTarget(renderTarget);
	  var context = gfx.renderer.getContext();
	  var result = context.checkFramebufferStatus(context.FRAMEBUFFER);
	  gfx.renderer.setRenderTarget(oldRT);
	  if (result !== context.FRAMEBUFFER_COMPLETE) {
	    //floatFrameBufferWarning = ;
	    this.logger.warn('Device doesn\'t support electron density rendering');
	    return false;
	  } else {
	    return true;
	  }
	};

	Miew.prototype._renderVolume = function () {

	  var volumeBFMat = new VolumeMaterial$1.BackFacePosMaterial();
	  var volumeFFMat = new VolumeMaterial$1.FrontFacePosMaterial();
	  var cubeOffsetMat = new Matrix4().makeTranslation(0.5, 0.5, 0.5);
	  var world2colorMat = new Matrix4();

	  var volumeRenderingSupported;

	  return function (volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
	    var gfx = this._gfx;

	    if (typeof volumeRenderingSupported === 'undefined') {
	      volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
	    }

	    if (!volumeRenderingSupported) {
	      return;
	    }

	    var mesh = volumeVisual.getMesh();

	    mesh.rebuild(camera);

	    // use main camera to prepare special textures to be used by volumetric rendering
	    // these textures have the size of the window and are stored in offscreen buffers
	    gfx.renderer.setClearColor('black', 0);
	    gfx.renderer.clearTarget(tmpBuf1);
	    gfx.renderer.clearTarget(tmpBuf2);
	    gfx.renderer.clearTarget(tmpBuf3);

	    // draw plane with its own material, because it differs slightly from volumeBFMat
	    camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
	    gfx.renderer.render(gfx.scene, camera, tmpBuf1);

	    camera.layers.set(gfxutils.LAYERS.VOLUME);
	    gfx.scene.overrideMaterial = volumeBFMat;
	    gfx.renderer.render(gfx.scene, camera, tmpBuf1);

	    camera.layers.set(gfxutils.LAYERS.VOLUME);
	    gfx.scene.overrideMaterial = volumeFFMat;
	    gfx.renderer.render(gfx.scene, camera, tmpBuf2);

	    gfx.scene.overrideMaterial = null;
	    camera.layers.set(gfxutils.LAYERS.DEFAULT);

	    // prepare texture that contains molecule positions
	    world2colorMat.getInverse(mesh.matrixWorld);
	    UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
	    this._setUberMaterialValues({ colorFromPos: true });
	    gfx.renderer.render(gfx.scene, camera, tmpBuf3);
	    this._setUberMaterialValues({ colorFromPos: false });

	    // render volume
	    var vm = mesh.material;
	    vm.uniforms._BFRight.value = tmpBuf1.texture;
	    vm.uniforms._FFRight.value = tmpBuf2.texture;
	    vm.uniforms._WFFRight.value = tmpBuf3.texture;
	    camera.layers.set(gfxutils.LAYERS.VOLUME);
	    gfx.renderer.render(gfx.scene, camera, dstBuf);
	    camera.layers.set(gfxutils.LAYERS.DEFAULT);
	  };
	}();

	/*  Render scene with 'ZPrepass transparency Effect'
	   * Idea: transparent objects are rendered in two passes. The first one writes result only into depth buffer.
	   * The second pass reads depth buffer and writes only to color buffer. The method results in
	   * correct image of front part of the semi-transparent objects, but we can see only front transparent objects
	   * and opaque objects inside, there is no transparent objects inside.
	   * Notes: 1. Opaque objects should be rendered strictly before semi-transparent ones.
	   * 2. Realization doesn't use camera layers because scene traversing is used for material changes and
	   * we can use it to select needed meshes and don't complicate meshes builders with layers
	  */
	Miew.prototype._renderWithPrepassTransparency = function () {

	  return function (camera, targetBuffer) {
	    var gfx = this._gfx;

	    // opaque objects
	    camera.layers.set(gfxutils.LAYERS.DEFAULT);
	    gfx.renderer.render(gfx.scene, camera, targetBuffer);

	    // transparent objects z prepass
	    camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
	    gfx.renderer.context.colorMask(false, false, false, false); // don't update color buffer
	    gfx.renderer.render(gfx.scene, camera, targetBuffer);
	    gfx.renderer.context.colorMask(true, true, true, true); // update color buffer

	    // transparent objects color pass
	    camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
	    gfx.renderer.render(gfx.scene, camera, targetBuffer);

	    // restore default layer
	    camera.layers.set(gfxutils.LAYERS.DEFAULT);
	  };
	}();

	Miew.prototype._performFXAA = function () {

	  var _fxaaMaterial = new FXAAMaterial();

	  return function (srcBuffer, targetBuffer) {

	    if (typeof srcBuffer === 'undefined' || typeof targetBuffer === 'undefined') {
	      return;
	    }

	    var gfx = this._gfx;

	    // clear canvas
	    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
	    gfx.renderer.clearTarget(targetBuffer);

	    // do fxaa processing of offscreen buff2
	    _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;
	    _fxaaMaterial.uniforms.srcTexelSize.value.set(1.0 / srcBuffer.width, 1.0 / srcBuffer.height);
	    _fxaaMaterial.uniforms.bgColor.value.set(settings.now.bg.color);

	    if (_fxaaMaterial.bgTransparent !== settings.now.bg.transparent) {
	      _fxaaMaterial.setValues({ bgTransparent: settings.now.bg.transparent });
	      _fxaaMaterial.needsUpdate = true;
	    }
	    gfx.renderer.renderScreenQuad(_fxaaMaterial, targetBuffer);
	  };
	}();

	Miew.prototype._performAO = function () {

	  var _aoMaterial = new ao.AOMaterial();
	  var _horBlurMaterial = new ao.HorBilateralBlurMaterial();
	  var _vertBlurMaterial = new ao.VertBilateralBlurMaterial();

	  var _noiseWidth = 4,
	      _noiseHeight = 4;
	  var _noiseData = new Uint8Array([0, 0, 0, 66, 0, 0, 77, 0, 0, 155, 62, 0, 0, 247, 0, 33, 0, 0, 0, 0, 0, 235, 0, 0, 0, 0, 0, 176, 44, 0, 232, 46, 0, 0, 29, 0, 0, 0, 0, 78, 197, 0, 93, 0, 0, 0, 0, 0]);
	  var _noiseWrapS = RepeatWrapping;
	  var _noiseWrapT = RepeatWrapping;
	  var _noiseMinFilter = NearestFilter;
	  var _noiseMagFilter = NearestFilter;
	  var _noiseMapping = UVMapping;
	  var _noiseTexture = new DataTexture(_noiseData, _noiseWidth, _noiseHeight, RGBFormat, UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
	  _noiseTexture.needsUpdate = true;

	  var _samplesKernel = [
	  // hemisphere samples adopted to sphere (FIXME remove minus from Z)
	  new Vector3(0.295184, 0.077723, 0.068429), new Vector3(-0.271976, -0.365221, 0.838363), new Vector3(0.547713, 0.467576, 0.488515), new Vector3(0.662808, -0.031733, 0.584758), new Vector3(-0.025717, 0.218955, 0.657094), new Vector3(-0.310153, -0.365223, 0.370701), new Vector3(-0.101407, -0.006313, 0.747665), new Vector3(-0.769138, 0.360399, 0.086847), new Vector3(-0.271988, -0.275140, 0.905353), new Vector3(0.096740, -0.566901, 0.700151), new Vector3(0.562872, -0.735136, 0.094647), new Vector3(0.379877, 0.359278, 0.190061), new Vector3(0.519064, -0.023055, 0.405068), new Vector3(-0.301036, 0.114696, 0.088885), new Vector3(-0.282922, 0.598305, 0.487214), new Vector3(-0.181859, 0.251670, 0.679702), new Vector3(-0.191463, -0.635818, 0.512919), new Vector3(-0.293655, 0.427423, 0.078921), new Vector3(-0.267983, 0.680534, 0.132880), new Vector3(0.139611, 0.319637, 0.477439), new Vector3(-0.352086, 0.311040, 0.653913), new Vector3(0.321032, 0.805279, 0.487345), new Vector3(0.073516, 0.820734, 0.414183), new Vector3(-0.155324, 0.589983, 0.411460), new Vector3(0.335976, 0.170782, 0.527627), new Vector3(0.463460, -0.355658, 0.167689), new Vector3(0.222654, 0.596550, 0.769406), new Vector3(0.922138, -0.042070, 0.147555), new Vector3(-0.727050, -0.329192, 0.369826), new Vector3(-0.090731, 0.533820, 0.463767), new Vector3(-0.323457, -0.876559, 0.238524), new Vector3(-0.663277, -0.372384, 0.342856)];
	  // var _kernelOffsets = [-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0];
	  var _kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0];

	  return function (srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {

	    if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
	      return;
	    }

	    var self = this;
	    var gfx = self._gfx;

	    // clear canvasFMatrix4
	    //gfx.renderer.setClearColor(THREE.aliceblue, 1);
	    //gfx.renderer.clearTarget(targetBuffer, true, false);

	    // do fxaa processing of offscreen buff2
	    _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
	    _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
	    _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;
	    _aoMaterial.uniforms.srcTexelSize.value.set(1.0 / srcColorBuffer.width, 1.0 / srcColorBuffer.height);
	    _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);
	    _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
	    _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
	    _aoMaterial.uniforms.tanHalfFOV.value = Math.tan(_Math.DEG2RAD * 0.5 * gfx.camera.fov);
	    _aoMaterial.uniforms.samplesKernel.value = _samplesKernel;
	    var translation = new Vector3(),
	        quaternion = new Quaternion(),
	        scale = new Vector3();
	    gfx.root.matrix.decompose(translation, quaternion, scale);
	    _aoMaterial.uniforms.kernelRadius.value = settings.now.debug.ssaoKernelRadius * scale.x;
	    _aoMaterial.uniforms.depthThreshold.value = 2.0 * this._getBSphereRadius(); // diameter
	    _aoMaterial.uniforms.factor.value = settings.now.debug.ssaoFactor;
	    _aoMaterial.uniforms.noiseTexture.value = _noiseTexture;
	    _aoMaterial.uniforms.noiseTexelSize.value.set(1.0 / _noiseWidth, 1.0 / _noiseHeight);
	    var fog = gfx.scene.fog;
	    if (fog) {
	      _aoMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);
	    }
	    _aoMaterial.transparent = false;
	    // N: should be tempBuffer1 for proper use of buffers (see buffers using outside the function)
	    gfx.renderer.renderScreenQuad(_aoMaterial, tempBuffer1);

	    _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;
	    _horBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer1.width, 1.0 / tempBuffer1.height);
	    _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
	    _horBlurMaterial.uniforms.samplesOffsets.value = _kernelOffsets;
	    gfx.renderer.renderScreenQuad(_horBlurMaterial, tempBuffer);

	    _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
	    _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
	    _vertBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer.width, 1.0 / tempBuffer.height);
	    _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
	    _vertBlurMaterial.uniforms.samplesOffsets.value = _kernelOffsets;
	    gfx.renderer.renderScreenQuad(_vertBlurMaterial, targetBuffer);
	  };
	}();

	/**
	 * Reset the viewer, unload molecules.
	 * @param {boolean=} keepReps - Keep representations while resetting viewer state.
	 */
	Miew.prototype.reset = function () /* keepReps */{
	  if (this._picker) {
	    this._picker.reset();
	  }
	  this._lastPick = null;

	  this._releaseAllVisuals();

	  this._setEditMode(EDIT_MODE.COMPLEX);

	  this._resetObjects();

	  if (this._gfx) {
	    gfxutils.clearTree(this._gfx.pivot);
	    this._gfx.renderer2d.reset();
	  }

	  this.setNeedRender();
	};

	Miew.prototype._resetScene = function () {
	  this._objectControls.reset();
	  this._objectControls.allowTranslation(true);
	  this._objectControls.allowAltObjFreeRotation(true);
	  this.resetReps();
	  this.resetPivot();
	  this.rebuildAll();
	};

	Miew.prototype.resetView = function () {
	  // reset controls
	  if (this._picker) {
	    this._picker.reset();
	  }
	  this._setEditMode(EDIT_MODE.COMPLEX);
	  this._resetScene();

	  // reset selection
	  this._forEachComplexVisual(function (visual) {
	    visual.updateSelectionMask({});
	    visual.rebuildSelectionGeometry();
	  });
	};

	/**
	 * Load molecule asynchronously.
	 * @param {string|File} source - Molecule source to load (e.g. PDB ID, URL or File object).
	 * @param {object=} opts - Options.
	 * @param {string=} opts.sourceType - Data source type (e.g. 'url', 'file').
	 * @param {string=} opts.fileType - Data contents type (e.g. 'pdb', 'cml').
	 * @param {string=} opts.mdFile - .nc file path.
	 * @param {boolean=} opts.keepRepsInfo - prevent reset of object and reps information.
	 * @returns {Promise} name of the visual that was added to the viewer
	 */
	Miew.prototype.load = function (source, opts) {
	  var _this4 = this;

	  opts = lodash.merge({}, opts, {
	    context: this
	  });

	  // for a single-file scenario
	  if (!this.settings.now.use.multiFile) {

	    // abort all loaders in progress
	    if (this._loading.length) {
	      this._loading.forEach(function (job) {
	        job.cancel();
	      });
	      this._loading.length = 0;
	    }

	    // reset
	    if (!opts.animation) {
	      // FIXME: sometimes it is set AFTERWARDS!
	      this.reset(true);
	    }
	  }

	  this.dispatchEvent({ type: 'load', options: opts, source: source });

	  var job = new JobHandle();
	  this._loading.push(job);
	  job.addEventListener('notification', function (e) {
	    _this4.dispatchEvent(e.slaveEvent);
	  });

	  this._spinner.spin(this._container);

	  var onLoadEnd = function onLoadEnd(anything) {
	    var jobIndex = _this4._loading.indexOf(job);
	    if (jobIndex !== -1) {
	      _this4._loading.splice(jobIndex, 1);
	    }
	    _this4._spinner.stop();
	    _this4._refreshTitle();
	    return anything;
	  };

	  return _fetchData(source, opts, job).then(function (data) {
	    return _convertData(data, opts, job);
	  }).then(function (data) {
	    return _parseData(data, opts, job);
	  }).then(function (object) {
	    var name = _this4._onLoad(object, opts);
	    return onLoadEnd(name);
	  }).catch(function (err) {
	    _this4.logger.error('Could not load data');
	    _this4.logger.debug(err);
	    throw onLoadEnd(err);
	  });
	};

	/**
	 * Unload molecule (delete corresponding visual).
	 * @param {string=} name - name of the visual
	 */
	Miew.prototype.unload = function (name) {
	  this._removeVisual(name || this.getCurrentVisual());
	  this.resetPivot();
	};

	Miew.prototype._startAnimation = function (fileData) {
	  this._stopAnimation();
	  var self = this;
	  var visual = this._getComplexVisual();
	  if (visual === null) {
	    this.logger.error('Unable to start animation - no molecule is loaded.');
	    return;
	  }
	  try {
	    this._frameInfo = new FrameInfo(visual.getComplex(), fileData, {
	      onLoadStatusChanged: function onLoadStatusChanged() {
	        self.dispatchEvent({
	          type: 'mdPlayerStateChanged',
	          state: {
	            isPlaying: self._isAnimating,
	            isLoading: self._frameInfo ? self._frameInfo.isLoading : true
	          }
	        });
	      },
	      onError: function onError(message) {
	        self._stopAnimation();
	        self.logger.error(message);
	      }
	    });
	  } catch (e) {
	    this.logger.error('Animation file does not fit to current complex!');
	    return;
	  }
	  this._continueAnimation();
	};

	Miew.prototype._startMdAnimation = function (mdFile, pdbFile) {
	  this._stopAnimation();
	  var self = this;
	  var visual = this._getComplexVisual();
	  if (visual === null) {
	    this.logger.error('Unable to start animation - no molecule is loaded.');
	    return;
	  }
	  try {
	    this._frameInfo = new FrameInfo(visual.getComplex(), this.srvStreamMdFn(mdFile, pdbFile), {
	      onLoadStatusChanged: function onLoadStatusChanged() {
	        self.dispatchEvent({
	          type: 'mdPlayerStateChanged',
	          state: {
	            isPlaying: self._isAnimating,
	            isLoading: self._frameInfo ? self._frameInfo.isLoading : true
	          }
	        });
	      },
	      onError: function onError(message) {
	        self._stopAnimation();
	        self.logger.error(message);
	      }
	    });
	  } catch (e) {
	    this.logger.error('Animation file does not fit to current complex!');
	    return;
	  }
	  this._continueAnimation();
	};

	Miew.prototype._pauseAnimation = function () {
	  if (this._animInterval === null) {
	    return;
	  }
	  this._isAnimating = false;
	  clearInterval(this._animInterval);
	  this._animInterval = null;
	  if (this._frameInfo) {
	    this.dispatchEvent({
	      type: 'mdPlayerStateChanged',
	      state: {
	        isPlaying: this._isAnimating,
	        isLoading: this._frameInfo.isLoading
	      }
	    });
	  }
	};

	Miew.prototype._continueAnimation = function () {
	  this._isAnimating = true;
	  var minFrameTime = 1000 / settings.now.maxfps;
	  minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
	  var self = this;
	  var pivot = self._gfx.pivot;
	  // TODO take care of all complex visuals ?
	  var visual = this._getComplexVisual();
	  if (visual) {
	    visual.resetSelectionMask();
	    visual.rebuildSelectionGeometry();
	    this._msgAtomInfo.style.opacity = 0.0;
	  }
	  this._animInterval = setInterval(function () {
	    self.dispatchEvent({
	      type: 'mdPlayerStateChanged',
	      state: {
	        isPlaying: self._isAnimating,
	        isLoading: self._frameInfo.isLoading
	      }
	    });
	    if (self._frameInfo.frameIsReady) {
	      pivot.updateToFrame(self._frameInfo);
	      self._updateObjsToFrame(self._frameInfo);
	      self._refreshTitle(' Frame ' + self._frameInfo._currFrame + ' of ' + self._frameInfo._framesCount + ' time interval - ' + self._frameInfo._timeStep);
	      try {
	        self._frameInfo.nextFrame();
	      } catch (e) {
	        self.logger.error('Error during animation');
	        self._stopAnimation();
	        return;
	      }
	      self._needRender = true;
	    }
	  }, minFrameTime);
	};

	Miew.prototype._stopAnimation = function () {
	  if (this._animInterval === null) {
	    return;
	  }
	  clearInterval(this._animInterval);
	  this._frameInfo.disableEvents();
	  this._frameInfo = null;
	  this._animInterval = null;
	  this._srvAnimSource = null;
	  this.dispatchEvent({
	    type: 'mdPlayerStateChanged',
	    state: null
	  });
	};

	/**
	 * Invoked upon successful loading of some data source
	 * @param {DataSource} dataSource - Data source for visualization (molecular complex or other)
	 * @param {object} opts - TODO: Options.
	 * @private
	 */
	Miew.prototype._onLoad = function (dataSource, opts) {
	  var gfx = this._gfx;
	  var visualName = null;

	  if (opts.animation) {
	    this._refreshTitle();
	    this._startAnimation(dataSource);
	    return null;
	  } else {
	    this._stopAnimation();
	    if (!opts || !opts.keepRepsInfo) {
	      this._opts.reps = null;
	      this._opts._objects = null;
	    }
	  }

	  if (dataSource.id === 'Complex') {
	    var complex = dataSource;

	    // update title
	    if (opts.fileName) {
	      complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
	    } else if (opts.amberFileName) {
	      complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
	    } else {
	      complex.name = 'Dynamic ' + opts.fileType + ' molecule';
	    }

	    visualName = this._addVisual(new ComplexVisual(complex.name, complex));
	    this._curVisualName = visualName;

	    var desc = this.info();
	    this.logger.info('Parsed ' + opts.fileName + ' (' + desc.atoms + ' atoms, ' + desc.bonds + ' bonds, ' + desc.residues + ' residues, ' + desc.chains + ' chains).');

	    if (lodash.isNumber(this._opts.unit)) {
	      complex.setCurrentUnit(this._opts.unit);
	    }

	    if (opts.preset) {
	      this.srvPresetApply(opts.preset);
	    } else if (settings.now.autoPreset) {
	      switch (opts.fileType) {
	        case 'cml':
	          this.resetReps('small');
	          break;
	        case 'pdb':
	        case 'mmtf':
	        case 'cif':
	          if (hasValidResidues(complex)) {
	            this.resetReps('macro');
	          } else {
	            this.resetReps('small');
	          }
	          break;
	        default:
	          this.resetReps('default');
	          break;
	      }
	    } else {
	      this.resetReps('default');
	    }
	  } else if (dataSource.id === 'Volume') {
	    this.resetEd();
	    visualName = this._onLoadEd(dataSource);
	  }

	  gfx.camera.updateProjectionMatrix();
	  this._updateFog();

	  // reset global transform & camera pan
	  gfx.root.resetTransform();
	  this.resetPivot();
	  this.resetPan();

	  // set scale to fit everything on the screen
	  this._objectControls.setScale(settings.now.radiusToFit / this._getBSphereRadius());

	  this._resetObjects();

	  if (settings.now.autoResolution) {
	    this._tweakResolution();
	  }

	  if (this._opts.view) {
	    this.view(this._opts.view);
	    delete this._opts.view;
	  }

	  if (opts.error) {
	    this.dispatchEvent({ type: 'onParseError', error: opts.error });
	  } else {
	    this.dispatchEvent({ type: 'onParseDone' });
	  }

	  this._refreshTitle();

	  if (opts.convertedFile && opts.mdFile) {
	    this._startMdAnimation(opts.mdFile, opts.convertedFile);
	  }

	  return visualName;
	};

	Miew.prototype.resetEd = function () {
	  if (this._edLoader) {
	    this._edLoader.abort();
	    this._edLoader = null;
	  }

	  // free all resources
	  this._removeVisual(this._getVolumeVisual());

	  this._needRender = true;
	};

	Miew.prototype.loadEd = function (source) {
	  var _this5 = this;

	  this.resetEd();

	  var TheLoader = lodash.head(io.loaders.find({ source: source }));
	  if (!TheLoader) {
	    this.logger.error('Could not find suitable loader for this source');
	    return Promise.reject(new Error('Could not find suitable loader for this source'));
	  }

	  var loader = this._edLoader = new TheLoader(source, { binary: true });
	  loader.context = this;
	  return loader.load().then(function (data) {
	    var TheParser = lodash.head(io.parsers.find({ format: 'ccp4' }));
	    if (!TheParser) {
	      throw new Error('Could not find suitable parser for this source');
	    }
	    var parser = new TheParser(data);
	    parser.context = _this5;
	    return parser.parse().then(function (dataSource) {
	      _this5._onLoadEd(dataSource);
	    });
	  }).catch(function (error) {
	    _this5.logger.error('Could not load ED data');
	    _this5.logger.debug(error);
	  });
	};

	Miew.prototype._onLoadEd = function (dataSource) {
	  dataSource.normalize();

	  var volumeVisual = new VolumeVisual('volume', dataSource);
	  volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME); // volume mesh is not visible to common render
	  var visualName = this._addVisual(volumeVisual);

	  this._needRender = true;
	  return visualName;
	};

	Miew.prototype._needRebuild = function () {
	  var needsRebuild = false;
	  this._forEachComplexVisual(function (visual) {
	    needsRebuild = needsRebuild || visual.needsRebuild();
	  });
	  return needsRebuild;
	};

	Miew.prototype._rebuildObjects = function () {
	  var self = this;
	  var gfx = this._gfx;
	  var i, n;

	  // remove old object geometry
	  var toRemove = [];
	  for (i = 0; i < gfx.pivot.children.length; ++i) {
	    var child = gfx.pivot.children[i];
	    if (!(child instanceof Visual)) {
	      toRemove.push(child);
	    }
	  }
	  for (i = 0; i < toRemove.length; ++i) {
	    toRemove[i].parent.remove(toRemove[i]);
	  }

	  setTimeout(function _rebuild() {
	    var objList = self._objects;
	    for (i = 0, n = objList.length; i < n; ++i) {
	      var obj = objList[i];
	      if (obj.needsRebuild) {
	        obj.build();
	      }
	      if (obj.getGeometry()) {
	        gfx.pivot.add(obj.getGeometry());
	      }
	    }
	  }, 10);
	};

	Miew.prototype.changeUnit = function (unitIdx, name) {
	  var visual = this._getComplexVisual(name);
	  if (!visual) {
	    throw new Error('There is no complex to change!');
	  }

	  function currentUnitInfo() {
	    var unit = visual ? visual.getComplex().getCurrentUnit() : 0;
	    var type = unit > 0 ? 'Bio molecule ' + unit : 'Asymmetric unit';
	    return 'Current unit: ' + unit + ' (' + type + ')';
	  }

	  if (unitIdx === undefined) {
	    return currentUnitInfo();
	  }
	  if (lodash.isString(unitIdx)) {
	    unitIdx = Math.max(parseInt(unitIdx, 10), 0);
	  }
	  if (visual.getComplex().setCurrentUnit(unitIdx)) {
	    this._resetScene();
	  }
	  return currentUnitInfo();
	};

	/**
	 * Start to rebuild geometry asynchronously.
	 */
	Miew.prototype.rebuild = function () {
	  if (this._building) {
	    this.logger.warn('Miew.rebuild(): already building!');
	    return;
	  }
	  this._building = true;

	  this.dispatchEvent({ type: 'rebuild' });

	  this._rebuildObjects();

	  this._gfx.renderer2d.reset();

	  var rebuildActions = [];
	  this._forEachComplexVisual(function (visual) {
	    if (visual.needsRebuild()) {
	      rebuildActions.push(visual.rebuild().then(function () {
	        return new Promise(function (resolve) {
	          visual.rebuildSelectionGeometry();
	          resolve();
	        });
	      }));
	    }
	  });

	  // Start asynchronous rebuild
	  var self = this;
	  this._spinner.spin(this._container);
	  Promise.all(rebuildActions).then(function () {
	    self._spinner.stop();

	    self._needRender = true;

	    // TODO: Gather geometry stats?
	    self._refreshTitle();
	    self._building = false;
	  });
	};

	/** Mark all representations for rebuilding */
	Miew.prototype.rebuildAll = function () {
	  this._forEachComplexVisual(function (visual) {
	    visual.setNeedsRebuild();
	  });
	  // this.rebuild(); // TODO: isn't implicit rebuild enough?
	};

	Miew.prototype._refreshTitle = function (appendix) {
	  var title;
	  appendix = appendix === undefined ? '' : appendix;
	  var visual = this._getComplexVisual();
	  if (visual) {
	    title = visual.getComplex().name;
	    var rep = visual.repGet(visual.repCurrent());
	    title += rep ? ' – ' + rep.mode.name + ' Mode' : '';
	  } else {
	    title = Object.keys(this._visuals).length > 0 ? 'Unknown' : 'No Data';
	  }
	  title += appendix;

	  this.dispatchEvent({ type: 'titleChanged', data: title });
	};

	Miew.prototype.setNeedRender = function () {
	  this._needRender = true;
	};

	Miew.prototype._extractRepresentation = function () {
	  var _this6 = this;

	  var changed = [];

	  this._forEachComplexVisual(function (visual) {
	    if (visual.getSelectionCount() === 0) {
	      return;
	    }

	    var selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
	    var defPreset = settings.now.presets.default;
	    var idx = visual.repAdd({
	      selector: selector, mode: defPreset[0].mode.id,
	      colorer: defPreset[0].colorer.id,
	      material: defPreset[0].material.id
	    });
	    if (idx < 0) {
	      if (visual.repCount() === ComplexVisual.NUM_REPRESENTATION_BITS) {
	        _this6.logger.warn('Number of representations is limited to ' + ComplexVisual.NUM_REPRESENTATION_BITS);
	      }
	      return;
	    }

	    visual.repCurrent(idx);

	    changed.push(visual.name);
	  });

	  if (changed.length > 0) {
	    this.logger.report('New representation from selection for complexes: ' + changed.join(', '));
	    this.dispatchEvent({ type: 'repAdd' });
	  }
	};

	/**
	 * Change current representation list.
	 * @param {array} reps - Representation list.
	 */
	Miew.prototype._setReps = function (reps) {
	  reps = reps || this._opts && this._opts.reps || [];
	  this._forEachComplexVisual(function (visual) {
	    return visual.resetReps(reps);
	  });
	};

	/**
	 * Apply existing preset to current scene.
	 * @param preset
	 */
	Miew.prototype.applyPreset = function (preset) {
	  var presets = settings.now.presets;
	  var presList = [preset || settings.defaults.preset, settings.defaults.preset, Object.keys(presets)[0]];
	  var reps = null;
	  for (var i = 0; !reps && i < presList.length; ++i) {
	    settings.set('preset', presList[i]);
	    reps = presets[settings.now.preset];
	    if (!reps) {
	      this.logger.warn('Unknown preset "' + settings.now.preset + '"');
	    }
	  }
	  this._setReps(reps);
	};

	/**
	 * Reset current representation list to initial values.
	 * @param {string} [preset] - The source preset in case of uninitialized representation list.
	 */
	Miew.prototype.resetReps = function (preset) {
	  var reps = this._opts && this._opts.reps;
	  if (reps) {
	    this._setReps(reps);
	  } else {
	    this.applyPreset(preset);
	  }
	};

	/**
	 * Get number of representations created so far.
	 * @returns {number} Number of reps.
	 */
	Miew.prototype.repCount = function (name) {
	  var visual = this._getComplexVisual(name);
	  return visual ? visual.repCount() : 0;
	};

	/**
	 * Get or set the current representation index.
	 * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
	 * @param {string=} [name] - Complex name. Defaults to the current one.
	 * @returns {number} The current index.
	 */
	Miew.prototype.repCurrent = function (index, name) {
	  var visual = this._getComplexVisual(name);
	  var newIdx = visual ? visual.repCurrent(index) : -1;
	  if (index && newIdx !== index) {
	    this.logger.warn('Representation ' + index + ' was not found. Current rep remains unchanged.');
	  }
	  return newIdx;
	};

	/**
	 * Get or set representation by index.
	 * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
	 * @param {object=} rep - Optional representation description.
	 * @param {string=} rep.selector - Selector string.
	 * @param {string=} rep.mode - Mode id.
	 * @param {string=} rep.colorer - Colorer id.
	 * @param {string=} rep.material - Material id.
	 * @returns {?object} Representation description.
	 */
	Miew.prototype.rep = function (index, rep) {
	  // FIXME support targeting visual by name
	  var visual = this._getComplexVisual('');
	  return visual ? visual.rep(index, rep) : null;
	};

	/**
	 * Get representation (not just description) by index.
	 * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
	 * @returns {?object} Representation.
	 */
	Miew.prototype.repGet = function (index, name) {
	  var visual = this._getComplexVisual(name);
	  return visual ? visual.repGet(index) : null;
	};

	/**
	 * Add new representation.
	 * @param {object=} rep - Representation description.
	 * @returns {number} Index of the new representation.
	 */
	Miew.prototype.repAdd = function (rep, name) {
	  var visual = this._getComplexVisual(name);
	  return visual ? visual.repAdd(rep) : -1;
	};

	/**
	 * Remove representation.
	 * @param {number=} index - Zero-based representation index.
	 */
	Miew.prototype.repRemove = function (index, name) {
	  var visual = this._getComplexVisual(name);
	  return visual ? visual.repRemove(index) : null;
	};

	/**
	 * Hide representation.
	 * @param {number} index - Zero-based representation index.
	 * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
	 */
	Miew.prototype.repHide = function (index, hide, name) {
	  this._needRender = true;
	  var visual = this._getComplexVisual(name);
	  return visual ? visual.repHide(index, hide) : null;
	};

	Miew.prototype._setEditMode = function (mode) {

	  this._editMode = mode;

	  var elem = this._msgMode;
	  if (elem) {
	    elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0.0 : 1.0;

	    if (mode !== EDIT_MODE.COMPLEX) {
	      var t = elem.getElementsByTagName('p')[0];
	      t.innerHTML = mode === EDIT_MODE.COMPONENT ? 'COMPONENT EDIT MODE' : 'FRAGMENT EDIT MODE';
	    }
	  }

	  this.dispatchEvent({ type: 'editModeChanged', data: mode === EDIT_MODE.COMPLEX });
	};

	Miew.prototype._enterComponentEditMode = function () {

	  if (this._editMode !== EDIT_MODE.COMPLEX) {
	    return;
	  }

	  var editors = [];
	  this._forEachComplexVisual(function (visual) {
	    var editor = visual.beginComponentEdit();
	    if (editor) {
	      editors.push(editor);
	    }
	  });

	  if (editors === []) {
	    return;
	  }

	  this._editors = editors;

	  this.logger.info('COMPONENT EDIT MODE -- ON');
	  this._setEditMode(EDIT_MODE.COMPONENT);
	  this._objectControls.keysTranslateObj(true);
	};

	Miew.prototype._applyComponentEdit = function () {
	  if (this._editMode !== EDIT_MODE.COMPONENT) {
	    return;
	  }

	  this._objectControls.stop();
	  this._objectControls.keysTranslateObj(false);

	  for (var i = 0; i < this._editors.length; ++i) {
	    this._editors[i].apply();
	  }
	  this._editors = [];

	  this.logger.info('COMPONENT EDIT MODE -- OFF (applied)');
	  this._setEditMode(EDIT_MODE.COMPLEX);

	  this.rebuildAll();
	};

	Miew.prototype._discardComponentEdit = function () {
	  if (this._editMode !== EDIT_MODE.COMPONENT) {
	    return;
	  }

	  this._objectControls.stop();
	  this._objectControls.keysTranslateObj(false);

	  for (var i = 0; i < this._editors.length; ++i) {
	    this._editors[i].discard();
	  }
	  this._editors = [];

	  this.logger.info('COMPONENT EDIT MODE -- OFF (discarded)');
	  this._setEditMode(EDIT_MODE.COMPLEX);

	  this._needRender = true;
	};

	Miew.prototype._enterFragmentEditMode = function () {

	  if (this._editMode !== EDIT_MODE.COMPLEX) {
	    return;
	  }

	  var selectedVisuals = [];
	  this._forEachComplexVisual(function (visual) {
	    if (visual instanceof ComplexVisual && visual.getSelectionCount() > 0) {
	      selectedVisuals.push(visual);
	    }
	  });

	  if (selectedVisuals.length !== 1) {
	    // either we have no selection or
	    // we have selected atoms in two or more visuals -- not supported
	    return;
	  }

	  var editor = selectedVisuals[0].beginFragmentEdit();
	  if (!editor) {
	    return;
	  }
	  this._editors = [editor];

	  this.logger.info('FRAGMENT EDIT MODE -- ON (single bond)');
	  this._setEditMode(EDIT_MODE.FRAGMENT);
	  this._objectControls.allowTranslation(false);
	  this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());

	  this._needRender = true;
	};

	Miew.prototype._applyFragmentEdit = function () {
	  if (this._editMode !== EDIT_MODE.FRAGMENT) {
	    return;
	  }

	  this._objectControls.stop();

	  for (var i = 0; i < this._editors.length; ++i) {
	    this._editors[i].apply();
	  }
	  this._editors = [];

	  this.logger.info('FRAGMENT EDIT MODE -- OFF (applied)');
	  this._setEditMode(EDIT_MODE.COMPLEX);
	  this._objectControls.allowTranslation(true);
	  this._objectControls.allowAltObjFreeRotation(true);

	  this.rebuildAll();
	};

	Miew.prototype._discardFragmentEdit = function () {
	  if (this._editMode !== EDIT_MODE.FRAGMENT) {
	    return;
	  }

	  this._objectControls.stop();

	  for (var i = 0; i < this._editors.length; ++i) {
	    this._editors[i].discard();
	  }
	  this._editors = [];

	  this.logger.info('FRAGMENT EDIT MODE -- OFF (discarded)');
	  this._setEditMode(EDIT_MODE.COMPLEX);
	  this._objectControls.allowTranslation(true);
	  this._objectControls.allowAltObjFreeRotation(true);

	  this._needRender = true;
	};

	/** @deprecated  Move object instead of panning the camera */
	Miew.prototype.resetPan = function () {
	  this._gfx.camera.position.x = 0.0;
	  this._gfx.camera.position.y = 0.0;
	  this.dispatchEvent({ type: 'transform' });
	};

	Miew.prototype._onPick = function (event) {
	  if (!settings.now.picking) {
	    // picking is disabled
	    return;
	  }

	  if (this._animInterval !== null) {
	    // animation playback is on
	    return;
	  }

	  if (this._editMode === EDIT_MODE.FRAGMENT) {
	    // prevent picking in fragment edit mode
	    return;
	  }

	  if (this._objectControls.isEditingAltObj()) {
	    // prevent picking during component rotation
	    return;
	  }

	  // update last pick & find complex
	  var complex = null;
	  if (event.obj.atom) {
	    complex = event.obj.atom.getResidue().getChain().getComplex();
	    this._lastPick = event.obj.atom;
	  } else if (event.obj.residue) {
	    complex = event.obj.residue.getChain().getComplex();
	    this._lastPick = event.obj.residue;
	  } else if (event.obj.chain) {
	    complex = event.obj.chain.getComplex();
	    this._lastPick = event.obj.chain;
	  } else if (event.obj.molecule) {
	    complex = event.obj.molecule.getComplex();
	    this._lastPick = event.obj.molecule;
	  } else {
	    this._lastPick = null;
	  }

	  function _updateSelection(visual) {
	    visual.updateSelectionMask(event.obj);
	    visual.rebuildSelectionGeometry();
	  }

	  // update visual
	  if (complex) {
	    var visual = this._getVisualForComplex(complex);
	    if (visual) {
	      _updateSelection(visual);
	      this._needRender = true;
	    }
	  } else {
	    this._forEachComplexVisual(_updateSelection);
	    this._needRender = true;
	  }

	  this._updateInfoPanel();
	};

	Miew.prototype._onDblClick = function (event) {
	  if ('atom' in event.obj) {
	    this.setPivotAtom(event.obj.atom);
	  } else if ('residue' in event.obj) {
	    this.setPivotResidue(event.obj.residue);
	  } else {
	    this.resetPivot();
	  }

	  this.resetPan();
	  this._needRender = true;
	};

	Miew.prototype._onKeyDown = function (event) {
	  if (!this._running || !this._hotKeysEnabled) {
	    return;
	  }

	  switch (event.keyCode) {
	    case 'C'.charCodeAt(0):
	      if (settings.now.editing) {
	        this._enterComponentEditMode();
	      }
	      break;
	    case 'F'.charCodeAt(0):
	      if (settings.now.editing) {
	        this._enterFragmentEditMode();
	      }
	      break;
	    case 'A'.charCodeAt(0):
	      switch (this._editMode) {
	        case EDIT_MODE.COMPONENT:
	          this._applyComponentEdit();break;
	        case EDIT_MODE.FRAGMENT:
	          this._applyFragmentEdit();break;
	        default:
	          break;
	      }
	      break;
	    case 'D'.charCodeAt(0):
	      switch (this._editMode) {
	        case EDIT_MODE.COMPONENT:
	          this._discardComponentEdit();break;
	        case EDIT_MODE.FRAGMENT:
	          this._discardFragmentEdit();break;
	        default:
	          break;
	      }
	      break;
	    case 'S'.charCodeAt(0):
	      event.preventDefault();
	      event.stopPropagation();
	      settings.set('ao', !settings.now.ao);
	      this._needRender = true;
	      break;
	    case 107:
	      event.preventDefault();
	      event.stopPropagation();
	      this._forEachComplexVisual(function (visual) {
	        visual.expandSelection();
	        visual.rebuildSelectionGeometry();
	      });
	      this._updateInfoPanel();
	      this._needRender = true;
	      break;
	    case 109:
	      event.preventDefault();
	      event.stopPropagation();
	      this._forEachComplexVisual(function (visual) {
	        visual.shrinkSelection();
	        visual.rebuildSelectionGeometry();
	      });
	      this._updateInfoPanel();
	      this._needRender = true;
	      break;
	    default:
	  }
	};

	Miew.prototype._onKeyUp = function (event) {
	  if (!this._running || !this._hotKeysEnabled) {
	    return;
	  }

	  if (event.keyCode === 'X'.charCodeAt(0)) {
	    this._extractRepresentation();
	  }
	};

	Miew.prototype._updateInfoPanel = function () {
	  var info = this._msgAtomInfo.getElementsByTagName('p')[0];
	  var atom, residue;

	  var count = 0;
	  this._forEachComplexVisual(function (visual) {
	    count += visual.getSelectionCount();
	  });

	  while (info.firstChild) {
	    info.removeChild(info.firstChild);
	  }

	  if (count === 0) {
	    this._msgAtomInfo.style.opacity = 0.0;
	    return;
	  }

	  var firstLine = String(count) + ' atom' + (count !== 1 ? 's' : '') + ' selected';
	  if (this._lastPick !== null) {
	    firstLine += ', the last pick:';
	  }
	  var secondLine = '';
	  var aName = '';
	  var coordLine = '';

	  if (this._lastPick instanceof Atom$2) {
	    atom = this._lastPick;
	    residue = atom._residue;

	    var an = atom.getName();
	    if (an.getNode() !== null) {
	      aName = an.getNode();
	    } else {
	      aName = an.getString();
	    }
	    var location = atom._location !== 32 ? String.fromCharCode(atom._location) : ''; // 32 is code of white-space
	    secondLine = atom.element.fullName + ' #' + atom._serial + location + ':       ' + residue._chain._name + '.' + residue._type._name + residue._sequence + residue._icode.trim() + '.';
	    if (typeof aName === 'string') {
	      // add atom name to second line in plain text form
	      secondLine += aName;
	    }

	    coordLine = 'Coord: (' + atom._position.x.toFixed(2).toString() + ',     ' + atom._position.y.toFixed(2).toString() + ',     ' + atom._position.z.toFixed(2).toString() + ')';
	  } else if (this._lastPick instanceof Residue$1) {
	    residue = this._lastPick;

	    secondLine = residue._type._fullName + ':       ' + residue._chain._name + '.' + residue._type._name + residue._sequence + residue._icode.trim();
	  } else if (this._lastPick instanceof Chain$2) {
	    secondLine = 'chain ' + this._lastPick._name;
	  } else if (this._lastPick instanceof Molecule$4) {
	    secondLine = 'molecule ' + this._lastPick._name;
	  }

	  info.appendChild(document.createTextNode(firstLine));

	  if (secondLine !== '') {
	    info.appendChild(document.createElement('br'));
	    info.appendChild(document.createTextNode(secondLine));
	  }

	  if (typeof aName !== 'string') {
	    // add atom name to second line in HTML form
	    var newNode = aName.cloneNode(true);
	    newNode.style.fontSize = '85%';
	    info.appendChild(newNode);
	  }

	  if (coordLine !== '') {
	    info.appendChild(document.createElement('br'));
	    info.appendChild(document.createTextNode(coordLine));
	  }

	  this._msgAtomInfo.style.opacity = 1.0;
	};

	Miew.prototype._getAltObj = function () {
	  if (this._editors) {
	    var altObj = null;
	    for (var i = 0; i < this._editors.length; ++i) {
	      var nextAltObj = this._editors[i].getAltObj();
	      if (nextAltObj.objects.length > 0) {
	        if (altObj) {
	          // we have selected atoms in two or more visuals -- not supported
	          altObj = null;
	          break;
	        }
	        altObj = nextAltObj;
	      }
	    }
	    if (altObj) {
	      return altObj;
	    }
	  }

	  return {
	    objects: [],
	    pivot: new Vector3(0, 0, 0)
	  };
	};

	Miew.prototype.resetPivot = function () {
	  var boundingBox = new Box3();
	  this._forEachVisual(function (visual) {
	    boundingBox.union(visual.getBoundaries().boundingBox);
	  });

	  boundingBox.getCenter(this._gfx.pivot.position);
	  this._gfx.pivot.position.negate();
	  this.dispatchEvent({ type: 'transform' });
	};

	Miew.prototype.setPivotResidue = function (residue) {
	  var visual = this._getVisualForComplex(residue.getChain().getComplex());
	  if (!visual) {
	    return;
	  }

	  var pos = this._gfx.pivot.position;
	  if (residue._controlPoint) {
	    pos.copy(residue._controlPoint);
	  } else {
	    var x = 0,
	        y = 0,
	        z = 0;
	    var amount = residue._atoms.length;
	    for (var i = 0; i < amount; ++i) {
	      var p = residue._atoms[i]._position;
	      x += p.x / amount;
	      y += p.y / amount;
	      z += p.z / amount;
	    }
	    pos.set(x, y, z);
	  }
	  pos.applyMatrix4(visual.matrix);
	  pos.negate();
	  this.dispatchEvent({ type: 'transform' });
	};

	Miew.prototype.setPivotAtom = function (atom) {
	  var visual = this._getVisualForComplex(atom.getResidue().getChain().getComplex());
	  if (!visual) {
	    return;
	  }

	  var pos = this._gfx.pivot.position;
	  pos.copy(atom._position);
	  pos.applyMatrix4(visual.matrix);
	  pos.negate();
	  this.dispatchEvent({ type: 'transform' });
	};

	Miew.prototype.benchmarkGfx = function (force) {
	  var self = this;
	  var prof = new GfxProfiler(this._gfx.renderer);

	  return new Promise(function (resolve) {
	    if (!force && !settings.now.autoResolution) {
	      resolve();
	      return;
	    }

	    self.dispatchEvent({ type: 'profile' });

	    self._spinner.spin(self._container);
	    prof.runOnTicks(50, 1000, 2000).then(function (numResults) {
	      self._gfxScore = 0.0;
	      if (numResults >= 5) {
	        self._gfxScore = 1000.0 / prof.mean();
	      }
	      if (numResults > 0) {
	        self._gfxScore = 0.5 * numResults;
	      }
	      // document.getElementById('atom-info').innerHTML = 'GFX score: ' + self._gfxScore.toPrecision(2);

	      self._spinner.stop();
	      resolve();
	    });
	  });
	};

	/**
	 * Makes a screenshot.
	 * @param {number} [width] - Width of an image. Defaults to the canvas width.
	 * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
	 *        if width is omitted too.
	 * @returns {string} Data URL representing the image contents.
	 */
	Miew.prototype.screenshot = function (width, height) {
	  var gfx = this._gfx;

	  function fov2Tan(fov) {
	    return Math.tan(_Math.degToRad(0.5 * fov));
	  }

	  function tan2Fov(tan) {
	    return _Math.radToDeg(Math.atan(tan)) * 2.0;
	  }

	  height = height || width || gfx.height;
	  width = width || gfx.width;

	  var screenshotURI = void 0;

	  if (width === gfx.width && height === gfx.height) {
	    // copy current canvas to screenshot
	    screenshotURI = gfx.renderer.domElement.toDataURL('image/png');
	  } else {

	    var originalAspect = gfx.camera.aspect;
	    var originalFov = gfx.camera.fov;
	    var originalTanFov2 = fov2Tan(gfx.camera.fov);

	    // screenshot should contain the principal area of interest (a centered square touching screen sides)
	    var areaOfInterestSize = Math.min(gfx.width, gfx.height);
	    var areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height;

	    // set appropriate camera aspect & FOV
	    var shotAspect = width / height;
	    gfx.camera.aspect = shotAspect;
	    gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1.0));
	    gfx.camera.updateProjectionMatrix();

	    // resize canvas to the required size of screenshot
	    gfx.renderer.setDrawingBufferSize(width, height, 1);

	    // make screenshot
	    this._renderFrame(settings.now.stereo);
	    screenshotURI = gfx.renderer.domElement.toDataURL('image/png');

	    // restore original camera & canvas proportions
	    gfx.camera.aspect = originalAspect;
	    gfx.camera.fov = originalFov;
	    gfx.camera.updateProjectionMatrix();
	    gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
	    this._needRender = true;
	  }

	  return screenshotURI;
	};

	/**
	 * Makes screenshot and initiates a download.
	 * @param {string} [filename] - Name of a file. Default to a 'screenshot-XXXXX.png', where XXXXX is a current
	 *        date/time in seconds.
	 * @param {number} [width] - Width of an image. Defaults to the canvas width.
	 * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
	 *        if width is omitted too.
	 */
	Miew.prototype.screenshotSave = function (filename, width, height) {
	  var uri = this.screenshot(width, height);
	  utils.shotDownload(uri, filename);
	};

	Miew.prototype._tweakResolution = function () {
	  var maxPerf = [['poor', 100], ['low', 500], ['medium', 1000], ['high', 5000], ['ultra', Number.MAX_VALUE]];

	  var atomCount = 0;
	  this._forEachComplexVisual(function (visual) {
	    atomCount += visual.getComplex().getAtomCount();
	  });

	  if (atomCount > 0) {
	    var performance = this._gfxScore * 10e5 / atomCount;
	    // set resolution based on estimated performance
	    for (var i = 0; i < maxPerf.length; ++i) {
	      if (performance < maxPerf[i][1]) {
	        this._autoChangeResolution(maxPerf[i][0]);
	        break;
	      }
	    }
	  }
	};

	Miew.prototype._autoChangeResolution = function (resolution) {
	  if (resolution !== settings.now.resolution) {
	    this.logger.report('Your rendering resolution was changed to "' + resolution + '" for best performance.');
	  }
	  settings.now.resolution = resolution;
	};

	/**
	 * Save current settings to cookies.
	 */
	Miew.prototype.saveSettings = function () {
	  this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
	};

	/**
	 * Load settings from cookies.
	 */
	Miew.prototype.restoreSettings = function () {
	  try {
	    var cookie = this._cookies.getCookie(this._opts.settingsCookie);
	    var diffs = cookie ? JSON.parse(cookie) : {};
	    this.settings.applyDiffs(diffs, true);
	  } catch (e) {
	    this.logger.error('Cookies parse error: ' + e.message);
	  }
	};

	/**
	 * Reset current settings to the defaults.
	 */
	Miew.prototype.resetSettings = function () {
	  this.settings.reset();
	};

	/*
	   * DANGEROUS and TEMPORARY. The method should change or disappear in future versions.
	   * @param {string|object} opts - See {@link Miew} constructor.
	   * @see {@link Miew#set}, {@link Miew#repAdd}, {@link Miew#rep}.
	   */
	Miew.prototype.setOptions = function (opts) {
	  if (typeof opts === 'string') {
	    opts = Miew.options.fromAttr(opts);
	  }
	  if (opts.reps) {
	    this._opts.reps = null;
	  }
	  lodash.merge(this._opts, opts);
	  if (opts.settings) {
	    this.set(opts.settings);
	  }

	  this._opts._objects = opts._objects;
	  this._resetObjects();

	  if (opts.load) {
	    this.load(opts.load, { fileType: opts.type });
	  }

	  if (opts.preset) {
	    settings.now.preset = opts.preset;
	  }

	  if (opts.reps) {
	    this.resetReps(opts.preset);
	  }

	  if (this._opts.view) {
	    this.view(this._opts.view);
	    delete this._opts.view;
	  }

	  // FIXME we need a way to associate "unit" option with particular complex
	  var visual = this._getComplexVisual();
	  if (visual) {
	    visual.getComplex().resetCurrentUnit();
	    if (lodash.isNumber(opts.unit)) {
	      visual.getComplex().setCurrentUnit(opts.unit);
	    }
	    this.resetView();
	    this.rebuildAll();
	  }
	};

	Miew.prototype.info = function (name) {
	  var visual = this._getComplexVisual(name);
	  if (!visual) {
	    return {};
	  }
	  var complex = visual.getComplex();
	  var metadata = complex.metadata;
	  return {
	    id: metadata.id || complex.name || 'UNKNOWN',
	    title: metadata.title && metadata.title.join(' ') || 'UNKNOWN DATA',
	    atoms: complex.getAtomCount(),
	    bonds: complex.getBondCount(),
	    residues: complex.getResidueCount(),
	    chains: complex.getChainCount()
	  };
	};

	/*
	   * OBJECTS SEGMENT
	   */

	Miew.prototype.addObject = function (objData, bThrow) {
	  var Ctor = null;

	  // TODO change this to factory when better times come.
	  if (objData.type === LinesObj.prototype.type) {
	    Ctor = LinesObj;
	  }

	  if (Ctor === null) {
	    throw new Error('Unknown scene object type - ' + objData.type);
	  }

	  try {
	    var newObj = new Ctor(objData.params, objData.opts);
	    this._addSceneObject(newObj);
	  } catch (error) {
	    if (!bThrow) {
	      this.logger.debug('Error during scene object creation: ' + error.message);
	    } else {
	      throw error;
	    }
	  }
	  this._needRender = true;
	};

	Miew.prototype._addSceneObject = function (sceneObject) {
	  var visual = this._getComplexVisual();
	  if (sceneObject.build && visual) {
	    sceneObject.build(visual.getComplex());
	    this._gfx.pivot.add(sceneObject.getGeometry());
	  }
	  var objects = this._objects;
	  objects[objects.length] = sceneObject;
	};

	Miew.prototype._updateObjsToFrame = function (frameData) {
	  var objs = this._objects;
	  for (var i = 0, n = objs.length; i < n; ++i) {
	    if (objs[i].updateToFrame) {
	      objs[i].updateToFrame(frameData);
	    }
	  }
	};

	Miew.prototype._resetObjects = function () {
	  var objs = this._opts._objects;

	  this._objects = [];
	  if (objs) {
	    for (var i = 0, n = objs.length; i < n; ++i) {
	      this.addObject(objs[i], false);
	    }
	  }
	};

	Miew.prototype.removeObject = function (index) {
	  var obj = this._objects[index];
	  if (!obj) {
	    throw new Error('Scene object with index ' + index + ' does not exist');
	  }
	  obj.destroy();
	  this._objects.splice(index, 1);
	  this._needRender = true;
	};

	/**
	 * Get a string with a URL to reproduce the current scene.
	 *
	 * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
	 * preset information regardless of the differences with settings
	 * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
	 * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
	 * @returns {string} URL
	 */
	Miew.prototype.getURL = function (opts) {
	  return options.toURL(this.getState(lodash.defaults(opts, {
	    compact: true,
	    settings: false,
	    view: false
	  })));
	};

	/**
	 * Get a string with a script to reproduce the current scene.
	 *
	 * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
	 * preset information regardless of the differences with settings
	 * @param {boolean} [opts.settings=true] - when this flag is true, changes in settings are included
	 * @param {boolean} [opts.view=true] - when this flag is true, a view information is included
	 * @returns {string} script
	 */
	Miew.prototype.getScript = function (opts) {
	  return options.toScript(this.getState(lodash.defaults(opts, {
	    compact: true,
	    settings: true,
	    view: true
	  })));
	};

	/*
	   * Generates object that represents the current state of representations list
	   * @param {boolean} compareWithDefaults - when this flag is true, reps list is compared (if possible)
	   * to preset's defaults and only diffs are generated
	   */
	Miew.prototype._compareReps = function (complexVisual, compareWithDefaults) {
	  var ans = {};
	  var repCount = 0;

	  if (complexVisual) {
	    repCount = complexVisual.repCount();
	  }

	  var currPreset = settings.defaults.presets[settings.now.preset];
	  var compare = compareWithDefaults;
	  if (currPreset === undefined || currPreset.length > repCount) {
	    compare = false;
	    ans.preset = 'empty';
	  } else if (settings.now.preset !== settings.defaults.preset) {
	    ans.preset = settings.now.preset;
	  }

	  var repsDiff = [];
	  var emptyReps = true;
	  for (var i = 0, n = repCount; i < n; ++i) {
	    repsDiff[i] = complexVisual.repGet(i).compare(compare ? currPreset[i] : null);
	    if (!lodash.isEmpty(repsDiff[i])) {
	      emptyReps = false;
	    }
	  }
	  if (!emptyReps) {
	    ans.reps = repsDiff;
	  }
	  return ans;
	};

	/*
	   * Obtain object that represents current state of miew (might be used as options in constructor).
	   * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
	   * preset information regardless of the differences with settings
	   * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
	   * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
	   * @returns {Object} State object.
	   */
	Miew.prototype.getState = function (opts) {
	  var state = {};

	  opts = lodash.defaults(opts, {
	    compact: true,
	    settings: false,
	    view: false
	  });

	  // FIXME state should include all complexes (not only current)

	  // load
	  var visual = this._getComplexVisual();
	  if (visual !== null) {
	    // TODO type?
	    var complex = visual.getComplex();
	    var metadata = complex.metadata;
	    if (metadata.id) {
	      var format = metadata.format ? metadata.format + ':' : '';
	      state.load = format + metadata.id;
	    }
	    var unit = complex.getCurrentUnit();
	    if (unit !== 1) {
	      state.unit = unit;
	    }
	  }

	  // representations
	  var repsInfo = this._compareReps(visual, opts.compact);
	  if (repsInfo.preset) {
	    state.preset = repsInfo.preset;
	  }

	  if (repsInfo.reps) {
	    state.reps = repsInfo.reps;
	  }

	  // objects
	  var objects = this._objects;
	  var objectsState = [];
	  for (var i = 0, n = objects.length; i < n; ++i) {
	    objectsState[i] = objects[i].identify();
	  }
	  if (objects.length > 0) {
	    state._objects = objectsState;
	  }

	  // view
	  if (opts.view) {
	    state.view = this.view();
	  }

	  // settings
	  if (opts.settings) {
	    var diff = this.settings.getDiffs(false);
	    if (!lodash.isEmpty(diff)) {
	      state.settings = diff;
	    }
	  }

	  return state;
	};

	/**
	 * Get parameter value.
	 * @param {string} param - Parameter name or path (e.g. 'modes.BS.atom').
	 * @param {*=} value - Default value.
	 * @returns {*} Parameter value.
	 */
	Miew.prototype.get = function (param, value) {
	  return settings.get(param, value);
	};

	Miew.prototype._clipPlaneUpdateValue = function (radius) {
	  var clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings.now.draft.clipPlaneFactor, settings.now.camNear);

	  var opts = { clipPlaneValue: clipPlaneValue };
	  this._forEachComplexVisual(function (visual) {
	    visual.setUberOptions(opts);
	  });
	  for (var i = 0, n = this._objects.length; i < n; ++i) {
	    var obj = this._objects[i];
	    if (obj._line) {
	      obj._line.material.setUberOptions(opts);
	    }
	  }
	  if (this._picker !== null) {
	    this._picker.clipPlaneValue = clipPlaneValue;
	  }
	};

	Miew.prototype._fogFarUpdateValue = function () {
	  if (this._picker !== null) {
	    if (this._gfx.scene.fog) {
	      this._picker.fogFarValue = this._gfx.scene.fog.far;
	    } else {
	      this._picker.fogFarValue = undefined;
	    }
	  }
	};

	Miew.prototype._fogAlphaChanged = function () {
	  this._forEachComplexVisual(function (visual) {
	    visual.setUberOptions({
	      fogAlpha: settings.now.fogAlpha
	    });
	  });
	};

	Miew.prototype._initOnSettingsChanged = function () {
	  var _this7 = this;

	  var on = function on(props, func) {
	    props = lodash.isArray(props) ? props : [props];
	    props.forEach(function (prop) {
	      _this7.settings.addEventListener('change:' + prop, func);
	    });
	  };

	  on('theme', function () {
	    // TODO add warning
	    _this7._onThemeChanged();
	  });

	  on('bg.color', function () {
	    _this7._onBgColorChanged();
	  });

	  on('ao', function () {
	    _this7._setUberMaterialValues({ normalsToGBuffer: settings.now.ao });
	  });

	  on('fogColor', function () {
	    _this7._onFogColorChanged();
	  });

	  on('fogColorEnable', function () {
	    _this7._onFogColorChanged();
	  });

	  on('bg.transparent', function (evt) {
	    var gfx = _this7._gfx;
	    if (gfx) {
	      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
	    }
	    // TODO: update materials
	    var values = { fogTransparent: evt.value };
	    _this7._forEachComplexVisual(function (visual) {
	      return visual.setMaterialValues(values);
	    });
	    for (var i = 0, n = _this7._objects.length; i < n; ++i) {
	      var obj = _this7._objects[i];
	      if (obj._line) {
	        obj._line.material.setValues(values);
	        obj._line.material.needsUpdate = true;
	      }
	    }
	    _this7.rebuildAll();
	  });

	  on('draft.clipPlane', function (evt) {
	    // TODO: update materials
	    var values = { clipPlane: evt.value };
	    _this7._forEachComplexVisual(function (visual) {
	      return visual.setMaterialValues(values);
	    });
	    for (var i = 0, n = _this7._objects.length; i < n; ++i) {
	      var obj = _this7._objects[i];
	      if (obj._line) {
	        obj._line.material.setValues(values);
	        obj._line.material.needsUpdate = true;
	      }
	    }
	    _this7.rebuildAll();
	  });

	  on('fps', function () {
	    _this7._fps.show(settings.now.fps);
	  });

	  on(['fog', 'fogNearFactor', 'fogFarFactor'], function () {
	    _this7._updateFog();
	  });

	  on('fogAlpha', function () {
	    _this7._fogAlphaChanged();
	  });

	  on('autoResolution', function (evt) {
	    if (evt.value && !_this7._gfxScore) {
	      _this7.logger.warn('Benchmarks are missed, autoresolution will not work! ' + 'Autoresolution should be set during miew startup.');
	    }
	  });

	  on('stereo', function () {
	    if (settings.now.stereo === 'WEBVR' && typeof _this7.webVR === 'undefined') {
	      _this7.webVR = new WebVRPoC(function () {
	        _this7._needRender = true;
	        _this7._onResize();
	      });
	    }
	    if (_this7.webVR) {
	      _this7.webVR.toggle(settings.now.stereo === 'WEBVR', _this7._gfx);
	    }
	  });

	  on(['transparency', 'resolution', 'palette'], function () {
	    _this7.rebuildAll();
	  });

	  on(['axes', 'fxaa', 'ao'], function () {
	    _this7._needRender = true;
	  });
	};

	/**
	 * Set parameter value.
	 * @param {string|object} params - Parameter name or path (e.g. 'modes.BS.atom') or even settings object.
	 * @param {*=} value - Value.
	 */
	Miew.prototype.set = function (params, value) {
	  settings.set(params, value);
	};

	/**
	 * Select atoms with selection string.
	 * @param {string} expression - string expression of selection
	 * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
	 */
	Miew.prototype.select = function (expression, append) {
	  var visual = this._getComplexVisual();
	  if (!visual) {
	    return;
	  }

	  var sel = expression;
	  if (lodash.isString(expression)) {
	    sel = selectors$3.parse(expression).selector;
	  }

	  visual.select(sel, append);
	  this._updateInfoPanel();
	  this._needRender = true;
	};

	var VIEW_VERSION = '1';

	/**
	 * Get or set view info packed into string.
	 *
	 * **Note:** view is stored for *left-handed* cs, euler angles are stored in radians and *ZXY-order*,
	 *
	 * @param {string=} expression - Optional string encoded the view
	 */
	Miew.prototype.view = function (expression) {
	  var self = this;
	  var pivot = this._gfx.pivot;
	  var transform = [];
	  var eulerOrder = 'ZXY';

	  function encode() {
	    var pos = pivot.position;
	    var scale = self._objectControls.getScale() / settings.now.radiusToFit;
	    var euler = new Euler();
	    euler.setFromQuaternion(self._objectControls.getOrientation(), eulerOrder);
	    transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
	    return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
	  }

	  function decode() {
	    // HACK: old non-versioned view is the 0th version
	    if (expression.length === 40) {
	      // TODO: remove when db migration is finished
	      expression = '0' + expression;
	    }

	    var version = expression[0];
	    transform = utils.arrayFromBase64(expression.substr(1), Float32Array);

	    // apply adapter for old versions
	    if (version !== VIEW_VERSION) {
	      if (version === '0') {
	        // cancel radiusToFit included in old views
	        transform[3] /= 8.0;
	      } else {
	        // do nothing
	        self.logger.warn('Encoded view version mismatch, stored as ' + version + ' vs ' + VIEW_VERSION + ' expected');
	        return;
	      }
	    }

	    var srcView = viewInterpolator.createView();
	    srcView.position.copy(pivot.position);
	    srcView.scale = self._objectControls.getScale();
	    srcView.orientation.copy(self._objectControls.getOrientation());

	    var dstView = viewInterpolator.createView();
	    dstView.position.set(transform[0], transform[1], transform[2]);

	    // hack to make preset views work after we moved centering offset to visual nodes
	    // FIXME should only store main pivot offset in preset
	    if (self._getComplexVisual()) {
	      dstView.position.sub(self._getComplexVisual().position);
	    }

	    dstView.scale = transform[3];
	    dstView.orientation.setFromEuler(new Euler(transform[4], transform[5], transform[6], eulerOrder));

	    viewInterpolator.setup(srcView, dstView);
	  }

	  if (typeof expression === 'undefined') {
	    return encode();
	  } else {
	    decode();
	  }
	  return expression;
	};

	/*
	   * Update current view due to viewinterpolator state
	   */
	Miew.prototype._updateView = function () {
	  var self = this;
	  var pivot = this._gfx.pivot;

	  if (!viewInterpolator.wasStarted()) {
	    viewInterpolator.start();
	  }

	  if (!viewInterpolator.isMoving()) {
	    return;
	  }

	  //var curr = viewInterpolator.createView();
	  var res = viewInterpolator.getCurrentView();
	  if (res.success) {
	    var curr = res.view;
	    pivot.position.copy(curr.position);
	    self._objectControls.setScale(curr.scale * settings.now.radiusToFit);
	    self._objectControls.setOrientation(curr.orientation);
	    this.dispatchEvent({ type: 'transform' });
	    self._needRender = true;
	  }
	};

	/**
	 * Translate object by vector
	 * @param {number} x - translation value (Ang) along model's X axis
	 * @param {number} y - translation value (Ang) along model's Y axis
	 * @param {number} z - translation value (Ang) along model's Z axis
	 */
	Miew.prototype.translate = function (x, y, z) {
	  this._objectControls.translatePivot(x, y, z);
	  this.dispatchEvent({ type: 'transform' });
	  this._needRender = true;
	};

	/**
	 * Rotate object by Euler angles
	 * @param {number} x - rotation angle around X axis in radians
	 * @param {number} y - rotation angle around Y axis in radians
	 * @param {number} z - rotation angle around Z axis in radians
	 */
	Miew.prototype.rotate = function (x, y, z) {
	  this._objectControls.rotate(new Quaternion().setFromEuler(new Euler(x, y, z, 'XYZ')));
	  this.dispatchEvent({ type: 'transform' });
	  this._needRender = true;
	};

	/**
	 * Scale object by factor
	 * @param {number} factor - scale multiplier, should greater than zero
	 */
	Miew.prototype.scale = function (factor) {
	  if (factor <= 0) {
	    throw new RangeError('Scale should be greater than zero');
	  }
	  this._objectControls.scale(factor);
	  this.dispatchEvent({ type: 'transform' });
	  this._needRender = true;
	};

	/*
	   * Pan camera
	   * @param {number} x - horizontal panning
	   * @param {number} y - vertical panning
	   * @deprecated  Move object instead of panning the camera
	   */
	Miew.prototype.pan = function (x, y) {
	  this._gfx.camera.translateX(x);
	  this._gfx.camera.translateY(y);
	  this._needRender = true;
	};

	/**
	 * Build selector that contains all atoms within given distance from group of atoms
	 * @param {Selector} selector - selector describing source group of atoms
	 * @param {number} radius - distance
	 * @returns {Selector} selector describing result group of atoms
	 */
	Miew.prototype.within = function (selector, radius) {
	  var visual = this._getComplexVisual();
	  if (!visual) {
	    return selectors$3.None();
	  }

	  if (selector instanceof String) {
	    selector = selectors$3.parse(selector);
	  }

	  var res = visual.within(selector, radius);
	  if (res) {
	    visual.rebuildSelectionGeometry();
	    this._needRender = true;
	  }
	  return res;
	};

	/**
	 * Get atom position in 2D canvas coords
	 * @param {string} fullAtomName - full atom name, like A.38.CG
	 * @returns {Object} {x, y} or false if atom not found
	 */
	Miew.prototype.projected = function (fullAtomName, complexName) {
	  var visual = this._getComplexVisual(complexName);
	  if (!visual) {
	    return false;
	  }

	  var atom = visual.getComplex().getAtomByFullname(fullAtomName);
	  if (atom === null) {
	    return false;
	  }

	  var pos = atom._position.clone();
	  // we consider atom position to be affected only by common complex transform
	  // ignoring any transformations that may add during editing
	  this._gfx.pivot.updateMatrixWorldRecursive();
	  this._gfx.camera.updateMatrixWorldRecursive();
	  this._gfx.pivot.localToWorld(pos);
	  pos.project(this._gfx.camera);

	  return {
	    x: (pos.x + 1.0) * 0.5 * this._gfx.width,
	    y: (1.0 - pos.y) * 0.5 * this._gfx.height
	  };
	};

	/**
	 * Replace secondary structure with calculated one.
	 *
	 * DSSP algorithm implementation is used.
	 *
	 * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
	 * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
	 *
	 * @param {string=} complexName - complex name
	 */
	Miew.prototype.dssp = function (complexName) {
	  var visual = this._getComplexVisual(complexName);
	  if (!visual) {
	    return;
	  }
	  visual.getComplex().dssp();

	  // rebuild dependent representations (cartoon or ss-colored)
	  visual._reprList.forEach(function (rep) {
	    if (rep.mode.id === 'CA' || rep.colorer.id === 'SS') {
	      rep.needsRebuild = true;
	    }
	  });
	};

	var rePdbId = /^(?:(pdb|cif|mmtf|ccp4):\s*)?(\d[a-z\d]{3})$/i;
	var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
	var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;

	function resolveSourceShortcut(source, opts) {
	  if (!lodash.isString(source)) {
	    return source;
	  }

	  // e.g. "mmtf:1CRN"
	  var matchesPdbId = rePdbId.exec(source);
	  if (matchesPdbId) {
	    var _matchesPdbId = slicedToArray(matchesPdbId, 3),
	        _matchesPdbId$ = _matchesPdbId[1],
	        format = _matchesPdbId$ === undefined ? 'pdb' : _matchesPdbId$,
	        id = _matchesPdbId[2];

	    format = format.toLowerCase();
	    id = id.toUpperCase();

	    switch (format) {
	      case 'pdb':
	        source = 'http://files.rcsb.org/download/' + id + '.pdb';
	        break;
	      case 'cif':
	        source = 'http://files.rcsb.org/download/' + id + '.cif';
	        break;
	      case 'mmtf':
	        source = 'http://mmtf.rcsb.org/v1.0/full/' + id;
	        break;
	      case 'ccp4':
	        source = 'https://www.ebi.ac.uk/pdbe/coordinates/files/' + id.toLowerCase() + '.ccp4';
	        break;
	      default:
	        throw new Error('Unexpected data format shortcut');
	    }

	    opts.fileType = format;
	    opts.fileName = id + '.' + format;
	    opts.sourceType = 'url';
	    return source;
	  }

	  // e.g. "pc:aspirin"
	  var matchesPubchem = rePubchem.exec(source);
	  if (matchesPubchem) {
	    var compound = matchesPubchem[1].toLowerCase();
	    source = 'https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/' + compound + '/JSON?record_type=3d';
	    opts.fileType = 'pubchem';
	    opts.fileName = compound + '.json';
	    opts.sourceType = 'url';
	    return source;
	  }

	  // otherwise is should be an URL
	  if (opts.sourceType === 'url' || opts.sourceType === undefined) {
	    opts.sourceType = 'url';

	    // e.g. "./data/1CRN.pdb"
	    if (!reUrlScheme.test(source)) {
	      source = utils.resolveURL(source);
	    }
	  }

	  return source;
	}

	function updateBinaryMode(opts) {
	  var binary = opts.binary;

	  // detect by format
	  if (opts.fileType !== undefined) {
	    var TheParser = lodash.head(io.parsers.find({ format: opts.fileType }));
	    if (TheParser) {
	      binary = TheParser.binary || false;
	    } else {
	      throw new Error('Could not find suitable parser for this format');
	    }
	  }

	  // detect by file extension
	  if (binary === undefined && opts.fileExt !== undefined) {
	    var _TheParser = lodash.head(io.parsers.find({ ext: opts.fileExt }));
	    if (_TheParser) {
	      binary = _TheParser.binary || false;
	    }
	  }

	  // temporary workaround for animation
	  if (opts.fileExt !== undefined && opts.fileExt.toLowerCase() === '.man') {
	    opts.binary = true;
	    opts.animation = true; // who cares?
	  }

	  // update if detected
	  if (binary !== undefined) {
	    if (opts.binary !== undefined && opts.binary !== binary) {
	      opts.context.logger.warn('Overriding incorrect binary mode');
	    }
	  }

	  opts.binary = binary || false;
	}

	function _fetchData(source, opts, job) {
	  return new Promise(function (resolve) {
	    if (job.shouldCancel()) {
	      throw new Error('Operation cancelled');
	    }

	    // allow for source shortcuts
	    source = resolveSourceShortcut(source, opts);

	    // detect a proper loader
	    var TheLoader = lodash.head(io.loaders.find({ type: opts.sourceType, source: source }));
	    if (!TheLoader) {
	      throw new Error('Could not find suitable loader for this source');
	    }

	    // split file name
	    var fileName = opts.fileName || TheLoader.extractName(source);
	    if (fileName) {
	      var _utils$splitFileName = utils.splitFileName(fileName),
	          _utils$splitFileName2 = slicedToArray(_utils$splitFileName, 2),
	          name = _utils$splitFileName2[0],
	          fileExt = _utils$splitFileName2[1];

	      lodash.defaults(opts, { name: name, fileExt: fileExt, fileName: fileName });
	    }

	    // should it be text or binary?
	    updateBinaryMode(opts);

	    // FIXME: All new settings retrieved from server are applied after the loading is complete. However, we need some
	    // flags to alter the loading process itself. Here we apply them in advance. Dirty hack. Kill the server, remove
	    // all hacks and everybody's happy.
	    var newOptions = lodash.get(opts, 'preset.expression');
	    if (!lodash.isUndefined(newOptions)) {
	      newOptions = JSON.parse(newOptions);
	      if (newOptions && newOptions.settings) {
	        var keys = ['singleUnit', 'draft.waterBondingHack'];
	        for (var keyIndex = 0, keyCount = keys.length; keyIndex < keyCount; ++keyIndex) {
	          var key = keys[keyIndex];
	          var value = lodash.get(newOptions.settings, key);
	          if (!lodash.isUndefined(value)) {
	            settings.set(key, value);
	          }
	        }
	      }
	    }

	    // create a loader
	    var loader = new TheLoader(source, opts);
	    loader.context = opts.context;
	    job.addEventListener('cancel', function () {
	      return loader.abort();
	    });

	    loader.addEventListener('progress', function (event) {
	      if (event.lengthComputable && event.total > 0) {
	        reportProgress(loader.logger, 'Fetching', event.loaded / event.total);
	      } else {
	        reportProgress(loader.logger, 'Fetching');
	      }
	    });

	    console.time('fetch');
	    var promise = loader.load().then(function (data) {
	      console.timeEnd('fetch');
	      opts.context.logger.info('Fetching finished');
	      job.notify({ type: 'fetchingFinished', data: data });
	      return data;
	    }).catch(function (error) {
	      console.timeEnd('fetch');
	      opts.context.logger.debug(error.message);
	      if (error.stack) {
	        opts.context.logger.debug(error.stack);
	      }
	      opts.context.logger.error('Fetching failed');
	      job.notify({ type: 'fetchingFinished', error: error });
	      throw error;
	    });
	    resolve(promise);
	  });
	}

	function _convertData(data, opts, job) {
	  return new Promise(function (resolve, reject) {
	    if (job.shouldCancel()) {
	      throw new Error('Operation cancelled');
	    }
	    job.notify({ type: 'convert' });

	    if (opts.mdFile) {
	      var byteNumbers = new Array(data.length);
	      for (var i = 0; i < data.length; i++) {
	        byteNumbers[i] = data.charCodeAt(i);
	      }
	      var bytes = new Uint8Array(byteNumbers);
	      var blob = new File([bytes], opts.fileName);
	      console.time('convert');
	      Miew.prototype.srvTopologyConvert(blob, opts.mdFile, function (success, newData, message) {
	        console.timeEnd('convert');
	        if (success) {
	          opts.converted = true;
	          opts.amberFileName = opts.fileName;
	          opts.convertedFile = new File([bytes], opts.fileName);
	          opts.fileName = null;
	          opts.fileType = 'pdb';
	          job.notify({ type: 'convertingFinished' });
	          resolve(newData);
	        } else {
	          opts.converted = false;
	          logger.error(message);
	          opts.error = message;
	          job.notify({ type: 'convertingFinished', error: message });
	          reject(new Error(message));
	        }
	      });
	    } else {
	      opts.converted = true;
	      resolve(data);
	    }
	  });
	}

	function _parseData(data, opts, job) {
	  if (job.shouldCancel()) {
	    return Promise.reject(new Error('Operation cancelled'));
	  }
	  job.notify({ type: 'parse' });

	  var TheParser = lodash.head(io.parsers.find({ format: opts.fileType, ext: opts.fileExt, data: data }));
	  if (!TheParser) {
	    return Promise.reject(new Error('Could not find suitable parser'));
	  }

	  var parser = new TheParser(data, opts);
	  parser.context = opts.context;
	  job.addEventListener('cancel', function () {
	    return parser.abort();
	  });

	  console.time('parse');
	  return parser.parse().then(function (dataSet) {
	    console.timeEnd('parse');
	    job.notify({ type: 'parsingFinished', data: dataSet });
	    return dataSet;
	  }).catch(function (error) {
	    console.timeEnd('parse');
	    opts.error = error;
	    opts.context.logger.debug(error.message);
	    if (error.stack) {
	      opts.context.logger.debug(error.stack);
	    }
	    opts.context.logger.error('Parsing failed');
	    job.notify({ type: 'parsingFinished', error: error });
	    throw error;
	  });
	}

	Miew.prototype.exportCML = function () {
	  var self = this;

	  function extractRotation(m) {
	    var xAxis = new Vector3();
	    var yAxis = new Vector3();
	    var zAxis = new Vector3();
	    m.extractBasis(xAxis, yAxis, zAxis);
	    xAxis.normalize();
	    yAxis.normalize();
	    zAxis.normalize();
	    var retMat = new Matrix4();
	    retMat.identity();
	    retMat.makeBasis(xAxis, yAxis, zAxis);
	    return retMat;
	  }

	  function updateCMLData(complex) {
	    var root = self._gfx.root;
	    var mat = extractRotation(root.matrixWorld);
	    var v4 = new Vector4(0, 0, 0, 0);
	    var vCenter = new Vector4(0, 0, 0, 0);
	    var xml = null;
	    var ap = null;

	    // update atoms in cml
	    complex.forEachAtom(function (atom) {
	      if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
	        xml = atom.xmlNodeRef.xmlNode;
	        ap = atom.getPosition();
	        v4.set(ap.x, ap.y, ap.z, 1.0);
	        v4.applyMatrix4(mat);
	        xml.setAttribute('x3', v4.x.toString());
	        xml.setAttribute('y3', v4.y.toString());
	        xml.setAttribute('z3', v4.z.toString());
	        xml.removeAttribute('x2');
	        xml.removeAttribute('y2');
	      }
	    });
	    // update stereo groups in cml
	    complex.forEachSGroup(function (sGroup) {
	      if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
	        xml = sGroup.xmlNodeRef.xmlNode;
	        ap = sGroup.getPosition();
	        v4.set(ap.x, ap.y, ap.z, 1.0);
	        var cp = sGroup.getCentralPoint();
	        if (cp === null) {
	          v4.applyMatrix4(mat);
	        } else {
	          vCenter.set(cp.x, cp.y, cp.z, 0.0);
	          v4.add(vCenter);
	          v4.applyMatrix4(mat); // pos in global space
	          vCenter.set(cp.x, cp.y, cp.z, 1.0);
	          vCenter.applyMatrix4(mat);
	          v4.sub(vCenter);
	        }
	        xml.setAttribute('x', v4.x.toString());
	        xml.setAttribute('y', v4.y.toString());
	        xml.setAttribute('z', v4.z.toString());
	      }
	    });
	  }

	  // FIXME save data for all complexes (not only current)
	  var visual = self._getComplexVisual();
	  var complex = visual ? visual.getComplex() : null;
	  if (complex && complex.originalCML) {
	    updateCMLData(complex);

	    // serialize xml structure to string
	    var oSerializer = new XMLSerializer();
	    return oSerializer.serializeToString(complex.originalCML);
	  }

	  return null;
	};

	/**
	 * Reproduce the RCSB PDB Molecule of the Month style by David S. Goodsell
	 *
	 * @see http://pdb101.rcsb.org/motm/motm-about
	 */
	Miew.prototype.motm = function () {
	  settings.set('theme', 'light');
	  settings.set({
	    fogColorEnable: true,
	    fogColor: 0x000000,
	    outline: { on: true, threshold: 0.01 },
	    bg: { color: 0xffffff }
	  });

	  this._forEachComplexVisual(function (visual) {
	    var rep = [];
	    var complex = visual.getComplex();
	    var palette = palettes.get(settings.now.palette);
	    for (var i = 0; i < complex.getChainCount(); i++) {
	      var curChainName = complex._chains[i]._name;
	      var curChainColor = palette.getChainColor(curChainName);
	      rep[i] = {
	        selector: 'chain ' + curChainName,
	        mode: 'VW',
	        colorer: ['CB', { color: curChainColor, factor: 0.9 }],
	        material: 'FL'
	      };
	    }
	    visual.resetReps(rep);
	  });
	};

	////////////////////////////////////////////////////////////////////////////
	// Additional exports

	Miew.prototype.VERSION = "0.7.20";
	// Miew.prototype.debugTracer = new utils.DebugTracer(Miew.prototype);

	lodash.assign(Miew, /** @lends Miew */{
	  VERSION: Miew.prototype.VERSION,

	  registeredPlugins: [],

	  // export namespaces // TODO: WIP: refactoring external interface
	  chem: chem,
	  io: io,
	  modes: modes,
	  colorers: colorers,
	  materials: materials,
	  palettes: palettes,
	  options: options,
	  settings: settings,
	  utils: utils,
	  gfx: {
	    Representation: Representation,
	    fbxExport: fbxExport
	  },

	  /**
	   * Third-party libraries packaged together with Miew.
	   *
	   * @property {object} lodash - [Lodash](https://lodash.com/), a modern JavaScript utility library delivering
	   *   modularity, performance & extras.
	   * @property {object} three - [three.js](https://threejs.org/), JavaScript 3D library.
	   *
	   * @example
	   * var _ = Miew.thirdParty.lodash;
	   * var opts = _.merge({ ... }, Miew.options.fromURL(window.location.search));
	   * var miew = new Miew(opts);
	   */
	  thirdParty: {
	    lodash: lodash,
	    three: THREE$1
	  }
	});

	/* eslint-disable */
	// DO NOT EDIT! Automatically generated from .jison
	/* parser generated by jison 0.4.18 */
	/*
	  Returns a Parser object of the following structure:

	  Parser: {
	    yy: {}
	  }

	  Parser.prototype: {
	    yy: {},
	    trace: function(),
	    symbols_: {associative list: name ==> number},
	    terminals_: {associative list: number ==> name},
	    productions_: [...],
	    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
	    table: [...],
	    defaultActions: {...},
	    parseError: function(str, hash),
	    parse: function(input),

	    lexer: {
	        EOF: 1,
	        parseError: function(str, hash),
	        setInput: function(input),
	        input: function(),
	        unput: function(str),
	        more: function(),
	        less: function(n),
	        pastInput: function(),
	        upcomingInput: function(),
	        showPosition: function(),
	        test_match: function(regex_match_array, rule_index),
	        next: function(),
	        lex: function(),
	        begin: function(condition),
	        popState: function(),
	        _currentRules: function(),
	        topState: function(),
	        pushState: function(condition),

	        options: {
	            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
	            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
	            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
	        },

	        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
	        rules: [...],
	        conditions: {associative list: name ==> set},
	    }
	  }


	  token location info (@$, _$, etc.): {
	    first_line: n,
	    last_line: n,
	    first_column: n,
	    last_column: n,
	    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
	  }


	  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
	    text:        (matched text)
	    token:       (the produced terminal token, if any)
	    line:        (yylineno)
	  }
	  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
	    loc:         (yylloc)
	    expected:    (string describing the set of expected tokens)
	    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
	  }
	*/
	var parser$1 = (function(){
	var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,75],$V1=[1,77],$V2=[1,78],$V3=[1,81],$V4=[1,82],$V5=[1,83],$V6=[1,84],$V7=[1,85],$V8=[1,96],$V9=[1,88],$Va=[1,89],$Vb=[1,90],$Vc=[1,91],$Vd=[1,114],$Ve=[1,92],$Vf=[1,115],$Vg=[1,95],$Vh=[1,66],$Vi=[1,97],$Vj=[1,98],$Vk=[1,100],$Vl=[1,99],$Vm=[1,111],$Vn=[1,112],$Vo=[1,113],$Vp=[1,101],$Vq=[1,102],$Vr=[1,103],$Vs=[1,104],$Vt=[1,105],$Vu=[1,106],$Vv=[1,107],$Vw=[1,108],$Vx=[1,109],$Vy=[1,110],$Vz=[1,116],$VA=[1,117],$VB=[1,118],$VC=[1,120],$VD=[1,119],$VE=[1,72],$VF=[1,74],$VG=[1,71],$VH=[1,73],$VI=[1,79],$VJ=[1,80],$VK=[1,86],$VL=[1,87],$VM=[1,93],$VN=[1,94],$VO=[1,68],$VP=[1,69],$VQ=[1,70],$VR=[1,76],$VS=[1,130],$VT=[1,126],$VU=[1,129],$VV=[1,127],$VW=[1,128],$VX=[1,133],$VY=[1,132],$VZ=[1,149],$V_=[1,157],$V$=[1,164],$V01=[1,165],$V11=[1,202],$V21=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,53,55,56,57,59,60,61,63,64,65,67,68,69,70,71,72,73,74,75,76,78,79,80,81,83,84,86,87,88,92,93,95,98,99,102,104,105],$V31=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,53,55,56,57,59,60,61,63,64,65,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,83,84,86,87,88,92,93,95,98,99,102,104,105],$V41=[5,6,7,9,13,15,17,18,19,20,23,25,26,27,30,33,34,37,38,41,43,45,46,53,55,56,57,59,60,63,64,65,67,68,69,70,71,72,73,74,75,81,83,84,86,87,88,92,93,102],$V51=[5,92,93],$V61=[5,95],$V71=[1,228],$V81=[5,14,61,76,105],$V91=[77,104];
	var parser = {trace: function trace() { },
	yy: {},
	symbols_: {"error":2,"Program":3,"Command":4,"EOF":5,"RESET":6,"BUILD":7,"ALL":8,"HELP":9,"Path":10,"MOTM":11,"OneArgCommand":12,"GET":13,"STRING":14,"SET":15,"Value":16,"SET_SAVE":17,"SET_RESTORE":18,"SET_RESET":19,"PRESET":20,"AddRepresentation":21,"EditRepresentation":22,"REMOVE":23,"RepresentationReference":24,"HIDE":25,"SHOW":26,"LIST":27,"EXPAND_KEY":28,"SELECTOR_KEY":29,"SELECT":30,"AS":31,"WordAll":32,"SELECTOR":33,"WITHIN":34,"NUMBER":35,"OF":36,"MATERIAL":37,"IDENTIFIER":38,"ModeCMD":39,"ColorCMD":40,"VIEW":41,"BASE_64":42,"UNIT":43,"DSSP":44,"SCALE":45,"ROTATE":46,"AxesList":47,"TRANSLATE":48,"GetURLBranch":49,"Screenshot":50,"SrvCMD":51,"SrvScenarioCMD":52,"LINE":53,"ArgList":54,"LISTOBJ":55,"REMOVEOBJ":56,"URL":57,"VIEW_KEY":58,"SCREENSHOT":59,"FILE_LIST":60,"FILE_KEY":61,"PresetPath":62,"FILE_REGISTER":63,"FILE_DELETE":64,"PRESET_ADD":65,"Word":66,"PRESET_DELETE":67,"PRESET_UPDATE":68,"PRESET_RENAME":69,"PRESET_OPEN":70,"CREATE_SCENARIO":71,"RESET_SCENARIO":72,"DELETE_SCENARIO":73,"LIST_SCENARIO":74,"ADD_SCENARIO_ITEM":75,"DELAY_KEY":76,"=":77,"DESCRIPTION_KEY":78,"PDB_KEY":79,"PRST_KEY":80,"LOAD":81,"Url":82,"SCRIPT":83,"ADD":84,"Description":85,"REP":86,"MODE":87,"COLOR":88,"Descriptor":89,"RepresentationOwnProperty":90,"RepresentationOwnPropertyOpts":91,"DESC_KEY":92,"DESC_KEY_OPTS":93,"AxesArg":94,"DESC_KEY_AXES":95,"Arg":96,"PathWoDescKey":97,"HEX":98,"BOOL":99,"CommandSetWoDESC_KEY":100,"DescKeys":101,"CLEAR":102,"CommandSet":103,".":104,"/":105,"HexOrNumber":106,"$accept":0,"$end":1},
	terminals_: {2:"error",5:"EOF",6:"RESET",7:"BUILD",8:"ALL",9:"HELP",11:"MOTM",13:"GET",14:"STRING",15:"SET",17:"SET_SAVE",18:"SET_RESTORE",19:"SET_RESET",20:"PRESET",23:"REMOVE",25:"HIDE",26:"SHOW",27:"LIST",28:"EXPAND_KEY",29:"SELECTOR_KEY",30:"SELECT",31:"AS",33:"SELECTOR",34:"WITHIN",35:"NUMBER",36:"OF",37:"MATERIAL",38:"IDENTIFIER",41:"VIEW",42:"BASE_64",43:"UNIT",44:"DSSP",45:"SCALE",46:"ROTATE",48:"TRANSLATE",53:"LINE",55:"LISTOBJ",56:"REMOVEOBJ",57:"URL",58:"VIEW_KEY",59:"SCREENSHOT",60:"FILE_LIST",61:"FILE_KEY",63:"FILE_REGISTER",64:"FILE_DELETE",65:"PRESET_ADD",67:"PRESET_DELETE",68:"PRESET_UPDATE",69:"PRESET_RENAME",70:"PRESET_OPEN",71:"CREATE_SCENARIO",72:"RESET_SCENARIO",73:"DELETE_SCENARIO",74:"LIST_SCENARIO",75:"ADD_SCENARIO_ITEM",76:"DELAY_KEY",77:"=",78:"DESCRIPTION_KEY",79:"PDB_KEY",80:"PRST_KEY",81:"LOAD",83:"SCRIPT",84:"ADD",86:"REP",87:"MODE",88:"COLOR",92:"DESC_KEY",93:"DESC_KEY_OPTS",95:"DESC_KEY_AXES",98:"HEX",99:"BOOL",102:"CLEAR",104:".",105:"/"},
	productions_: [0,[3,2],[3,1],[4,1],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,3],[4,3],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,2],[4,2],[4,1],[4,2],[4,2],[4,2],[4,4],[4,2],[4,6],[4,2],[4,1],[4,1],[4,1],[4,2],[4,2],[4,1],[4,2],[4,1],[4,2],[4,2],[4,2],[4,1],[4,1],[4,1],[4,1],[4,3],[4,3],[4,4],[4,4],[4,1],[4,2],[49,1],[49,2],[49,2],[49,3],[49,3],[50,1],[50,2],[50,3],[51,1],[51,3],[51,2],[51,4],[51,2],[51,4],[51,2],[51,4],[51,1],[51,2],[51,2],[51,2],[51,3],[51,3],[51,3],[51,2],[51,2],[51,2],[51,2],[51,2],[51,2],[51,2],[51,2],[51,3],[51,3],[51,3],[51,2],[51,2],[51,2],[52,2],[52,2],[52,1],[52,2],[52,2],[52,2],[52,1],[52,2],[52,3],[52,3],[52,3],[52,7],[52,13],[52,13],[52,13],[52,13],[12,2],[12,2],[12,2],[12,2],[21,1],[21,2],[21,2],[21,3],[22,2],[22,3],[39,2],[39,3],[40,2],[40,3],[24,1],[24,1],[85,1],[85,2],[85,3],[85,4],[89,1],[89,1],[89,2],[90,3],[91,3],[47,1],[47,2],[94,2],[54,1],[54,2],[96,3],[16,1],[16,1],[16,1],[16,1],[16,1],[66,1],[66,1],[32,1],[32,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[100,1],[101,1],[101,1],[101,1],[101,1],[101,1],[101,1],[101,1],[103,1],[103,1],[97,1],[97,3],[97,3],[10,1],[10,1],[10,3],[10,3],[10,3],[82,1],[62,1],[62,3],[106,1],[106,1]],
	performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
	/* this == yyval */

	var $0 = $$.length - 1;
	switch (yystate) {
	case 1:
	 return $$[$0-1]; 
	break;
	case 3:
	this.$ = yy.miew.reset(false); yy.ClearContext(); yy.miew.resetReps("empty");
	break;
	case 4:
	this.$ = yy.miew.rebuild();
	break;
	case 5:
	this.$ = yy.miew.rebuildAll(); yy.miew.rebuild();
	break;
	case 6:
	this.$ = yy.echo(yy.utils.help().toString());
	break;
	case 7:
	this.$ = yy.echo(yy.utils.help($$[$0]).toString());
	break;
	case 8:
	this.$ = yy.miew.motm();
	break;
	case 10: case 11:
	this.$ = yy.utils.propagateProp($$[$0]); yy.echo(yy.miew.get($$[$0]).toString());
	break;
	case 12: case 13:
	this.$ = yy.miew.set($$[$0-1], yy.utils.propagateProp($$[$0-1], $$[$0]));break;
	case 14:
	this.$ = yy.miew.saveSettings();break;
	case 15:
	this.$ = yy.miew.restoreSettings();break;
	case 16:
	this.$ = yy.miew.resetSettings();break;
	case 17:
	this.$ = yy.miew.resetReps();
	break;
	case 18:
	this.$ = yy.miew.applyPreset($$[$0]);
	break;
	case 21:
	this.$ = yy.miew.repRemove($$[$0]); yy.representations.remove($$[$0]);
	break;
	case 22:
	this.$ = yy.miew.repHide($$[$0]);
	break;
	case 23:
	this.$ = yy.miew.repHide($$[$0], false);
	break;
	case 24:
	this.$ = yy.echo(yy.utils.listRep(yy.miew, yy.representations, $$[$0], '-e'));
	break;
	case 25:
	this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
	break;
	case 26:
	this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
	break;
	case 27:
	this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
	break;
	case 28:
	this.$ = yy.miew.select(yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0], true));
	break;
	case 29:
	this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg($$[$0-3].toLowerCase(), $$[$0-2], true); yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
	break;
	case 30:
	this.$ = yy.miew.rep(yy.miew.repCurrent(), {selector : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0])});
	break;
	case 31:
	this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(yy.utils.checkArg("select", $$[$0-2], true), Number($$[$0-4]));
	break;
	case 32:
	this.$ = yy.miew.rep(yy.miew.repCurrent(), {material : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
	break;
	case 35:
	this.$ = yy.echo(yy.miew.view());
	break;
	case 36: case 37:
	this.$ = yy.miew.view($$[$0]);
	break;
	case 38:
	this.$ = yy.echo(yy.miew.changeUnit());
	break;
	case 39:
	this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
	break;
	case 40:
	this.$ = yy.miew.dssp();
	break;
	case 41:
	this.$ = yy.miew.scale($$[$0]);
	break;
	case 42:
	 for (var i = 0, n = $$[$0].length; i < n; i++) {yy.miew.rotate($$[$0][i]['x'] * Math.PI / 180.0, $$[$0][i]['y'] * Math.PI / 180.0, $$[$0][i]['z'] * Math.PI / 180.0);} 
	break;
	case 43:
	 for (var i = 0, n = $$[$0].length; i < n; i++) {yy.miew.translate($$[$0][i]['x'] || 0, $$[$0][i]['y'] || 0, $$[$0][i]['z'] || 0);} 
	break;
	case 48: case 49:
	this.$ = yy.miew.addObject({type: 'line', params: [$$[$0-1], $$[$0]]}, true);
	break;
	case 50: case 51:
	this.$ = yy.miew.addObject({type: 'line', params: [$$[$0-2], $$[$0-1]], opts:$$[$0].toJSO(yy.utils, 'objects', 'line')}, true);
	break;
	case 52:
	this.$ = yy.echo(yy.utils.listObjs(yy.miew));
	break;
	case 53:
	this.$ = yy.miew.removeObject($$[$0]);
	break;
	case 54:
	this.$ = yy.echo(yy.miew.getURL({view: false, settings: false}));
	break;
	case 55:
	this.$ = yy.echo(yy.miew.getURL({view: false, settings: true}));
	break;
	case 56:
	this.$ = yy.echo(yy.miew.getURL({view: true,  settings: false}));
	break;
	case 57: case 58:
	this.$ = yy.echo(yy.miew.getURL({view: true,  settings: true}));
	break;
	case 59:
	this.$ = yy.miew.screenshotSave();
	break;
	case 60:
	this.$ = yy.miew.screenshotSave('', Number($$[$0]));
	break;
	case 61:
	this.$ = yy.miew.screenshotSave('', Number($$[$0-1]), Number($$[$0]));
	break;
	case 62:
	this.$ = yy.srv.fileList(yy.miew, yy.echo, yy.error);
	break;
	case 63:
	this.$ = yy.srv.fileList(yy.miew, yy.echo, yy.error, "", $$[$0]);
	break;
	case 64:
	this.$ = yy.srv.fileList(yy.miew, yy.echo, yy.error, $$[$0]);
	break;
	case 65:
	this.$ = yy.srv.fileList(yy.miew, yy.echo, yy.error, $$[$0-2], $$[$0]);
	break;
	case 66: case 68:
	this.$ = yy.srv.coroutineWithFileName(yy.miew, yy.echo, yy.error, $$[$0], yy.srv.fileList, yy.srv, yy.miew, yy.echo, yy.error);
	break;
	case 67: case 69:
	this.$ = yy.srv.coroutineWithFileName(yy.miew, yy.echo, yy.error, $$[$0-2], yy.srv.fileList, yy.srv, yy.miew, yy.echo, yy.error, $$[$0]);
	break;
	case 70:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvTopologyRegister");
	break;
	case 71:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvTopologyDelete", $$[$0], false);
	break;
	case 72: case 73:
	this.$ = yy.srv.coroutineWithFileName(yy.miew, yy.echo, yy.error, $$[$0], yy.miew.srvTopologyDelete, false);
	break;
	case 74:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvTopologyDelete", $$[$0-1], true);
	break;
	case 75: case 76:
	this.$ = yy.srv.coroutineWithFileName(yy.miew, yy.echo, yy.error, $$[$0-1], yy.miew.srvTopologyDelete, true);
	break;
	case 77: case 78:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvPresetCreate", $$[$0]);
	break;
	case 79:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvPresetDelete", $$[$0]);
	break;
	case 80: case 81:
	this.$ = yy.srv.coroutineWithPresetPath(yy.miew, yy.echo, yy.error, $$[$0], yy.miew.srvPresetDelete);
	break;
	case 82:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvPresetUpdate", $$[$0]);
	break;
	case 83: case 84:
	this.$ = yy.srv.coroutineWithPresetPath(yy.miew, yy.echo, yy.error, $$[$0], yy.miew.srvPresetUpdate);
	break;
	case 85:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvPresetRename", $$[$0-1], $$[$0]);
	break;
	case 86: case 87:
	this.$ = yy.srv.coroutineWithPresetPath(yy.miew, yy.echo, yy.error, $$[$0-1], yy.miew.srvPresetRename, $$[$0]);
	break;
	case 88:
	this.$ = yy.srv.callSrvFunc(yy.miew, yy.echo, yy.error, "srvPresetApply", $$[$0]); yy.representations.clear();
	break;
	case 89: case 90:
	this.$ = yy.srv.coroutineWithPresetPath(yy.miew, yy.echo, yy.error, $$[$0], yy.miew.srvPresetApply); yy.representations.clear();
	break;
	case 91: case 92:
	this.$ = yy.srv.createScenario($$[$0]);
	break;
	case 93:
	this.$ = yy.srv.resetScenario();
	break;
	case 94: case 95:
	this.$ = yy.srv.deleteScenario(yy.miew, yy.echo, yy.error, $$[$0]);
	break;
	case 96:
	this.$ = yy.srv.deleteScenario(yy.miew, yy.echo, yy.error, Number($$[$0]));
	break;
	case 97:
	this.$ = yy.srv.listScenario(yy.miew, yy.echo, yy.error);
	break;
	case 98: case 99: case 100: case 101:
	this.$ = yy.srv.listScenario(yy.miew, yy.echo, yy.error, $$[$0]);
	break;
	case 102:
	this.$ =yy.srv.addScenarioItem(yy.miew, yy.echo, yy.error, Number($$[$0-3]), $$[$0]);
	break;
	case 103:
	this.$ =yy.srv.addScenarioItem(yy.miew, yy.echo, yy.error, Number($$[$0-9]), Number($$[$0-6]), Number($$[$0-3]), $$[$0]);
	break;
	case 104:
	this.$ =yy.srv.addScenarioItem(yy.miew, yy.echo, yy.error, $$[$0-9], Number($$[$0-6]), Number($$[$0-3]), $$[$0]);
	break;
	case 105:
	this.$ =yy.srv.addScenarioItem(yy.miew, yy.echo, yy.error, Number($$[$0-9]), $$[$0-6], Number($$[$0-3]), $$[$0]);
	break;
	case 106:
	this.$ =yy.srv.addScenarioItem(yy.miew, yy.echo, yy.error, $$[$0-9], $$[$0-6], Number($$[$0-3]), $$[$0]);
	break;
	case 107: case 108: case 109:
	this.$ = yy.utils.load(yy.miew, $$[$0]); yy.representations.clear();
	break;
	case 110:
	this.$ = yy.notimplemented();
	break;
	case 111:
	this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
	break;
	case 112:
	this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
	break;
	case 113:
	this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
	break;
	case 114:
	this.$ = yy.echo(yy.representations.add($$[$0-1], yy.miew.repAdd($$[$0])));
	break;
	case 115:
	this.$ = yy.miew.rep($$[$0]); yy.miew.repCurrent($$[$0]);
	break;
	case 116:
	this.$ = yy.miew.rep($$[$0-1], $$[$0]); yy.miew.repCurrent($$[$0-1]);
	break;
	case 117:
	this.$ = yy.miew.rep(yy.miew.repCurrent(), {mode : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
	break;
	case 118:
	this.$ = yy.miew.rep(yy.miew.repCurrent(), {mode : new Array(yy.utils.checkArg($$[$0-2].toLowerCase(), $$[$0-1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0-2], $$[$0-1].toUpperCase()))});
	break;
	case 119:
	this.$ = yy.miew.rep(yy.miew.repCurrent(), {colorer : yy.utils.checkArg($$[$0-1].toLowerCase(), $$[$0].toUpperCase())});
	break;
	case 120:
	this.$ = yy.miew.rep(yy.miew.repCurrent(), {colorer : new Array(yy.utils.checkArg($$[$0-2].toLowerCase(), $$[$0-1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0-2], $$[$0-1].toUpperCase()))});
	break;
	case 121:
	this.$ = Number(yy.representations.get($$[$0]));
	break;
	case 122: case 138:
	this.$ = Number($$[$0]);
	break;
	case 123:
	this.$ = $$[$0];
	break;
	case 124:
	this.$ = yy._.assign($$[$0-1], $$[$0]);
	break;
	case 125:
	this.$ = yy._.assign($$[$0-2], $$[$0-1], $$[$0]);
	break;
	case 126:
	this.$ = yy._.assign($$[$0-3], $$[$0-2], $$[$0-1], $$[$0]);
	break;
	case 127: case 128:
	this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
	break;
	case 129:
	this.$ = yy.CreateObjectPair($$[$0-1].key, new Array($$[$0-1].val, $$[$0].toJSO(yy.utils, $$[$0-1].key, $$[$0-1].val)));
	break;
	case 130: case 131:
	this.$ = Object.create({'key': yy.keyRemap($$[$0-2]), 'val': yy.utils.checkArg($$[$0-2], $$[$0])});
	break;
	case 132:
	this.$ = [$$[$0]];
	break;
	case 133:
	this.$ = $$[$0-1].concat($$[$0]);
	break;
	case 134:
	this.$ = yy.CreateObjectPair($$[$0-1].toLowerCase(), Number($$[$0]));
	break;
	case 135:
	this.$ = new yy.ArgList($$[$0]);
	break;
	case 136:
	this.$ = $$[$0-1].append($$[$0]);
	break;
	case 137:
	this.$ = new yy.Arg($$[$0-2], $$[$0]);
	break;
	case 139:
	this.$ = parseInt($$[$0]);
	break;
	case 140:
	this.$ = JSON.parse($$[$0]);
	break;
	case 141: case 142:
	this.$ = String($$[$0]);
	break;
	case 203: case 204: case 207: case 208: case 209:
	this.$ = $$[$0-2] + $$[$0-1] + $$[$0]; //cause of could be color word in path;
	break;
	case 212:
	this.$ = $$[$0-2] = $$[$0-2] + $$[$0-1] + $$[$0];
	break;
	}
	},
	table: [{3:1,4:2,5:[1,3],6:[1,4],7:[1,5],9:[1,6],11:[1,7],12:8,13:[1,9],15:[1,10],17:[1,11],18:[1,12],19:[1,13],20:[1,14],21:15,22:16,23:[1,17],25:[1,18],26:[1,19],27:[1,20],30:[1,21],33:[1,22],34:[1,23],37:[1,24],39:25,40:26,41:[1,27],43:[1,28],44:[1,29],45:[1,30],46:[1,31],48:[1,32],49:33,50:34,51:35,52:36,53:[1,37],55:[1,38],56:[1,39],57:[1,46],59:[1,47],60:[1,48],63:[1,49],64:[1,50],65:[1,51],67:[1,52],68:[1,53],69:[1,54],70:[1,55],71:[1,56],72:[1,57],73:[1,58],74:[1,59],75:[1,60],81:[1,40],83:[1,41],84:[1,42],86:[1,43],87:[1,44],88:[1,45]},{1:[3]},{5:[1,61]},{1:[2,2]},{5:[2,3]},{5:[2,4],8:[1,62]},{5:[2,6],6:$V0,7:$V1,9:$V2,10:63,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{5:[2,8]},{5:[2,9]},{6:$V0,7:$V1,9:$V2,10:121,13:$V3,14:[1,122],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,10:123,13:$V3,14:[1,124],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{5:[2,14]},{5:[2,15]},{5:[2,16]},{5:[2,17],14:$VS,16:125,35:$VT,38:$VU,98:$VV,99:$VW},{5:[2,19]},{5:[2,20]},{24:131,35:$VX,38:$VY},{24:134,35:$VX,38:$VY},{24:135,35:$VX,38:$VY},{5:[2,25],24:136,28:[1,137],29:[1,138],35:$VX,38:$VY},{14:[1,139]},{14:[1,140]},{35:[1,141]},{38:[1,142]},{5:[2,33]},{5:[2,34]},{5:[2,35],14:[1,143],42:[1,144]},{5:[2,38],35:[1,145]},{5:[2,40]},{35:[1,146]},{47:147,94:148,95:$VZ},{47:150,94:148,95:$VZ},{5:[2,44]},{5:[2,45]},{5:[2,46]},{5:[2,47]},{6:$V0,7:$V1,9:$V2,10:152,13:$V3,14:[1,151],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{5:[2,52]},{35:[1,153]},{14:$V_,38:[1,155],61:[1,156],82:154},{14:$V_,82:158},{5:[2,111],38:[1,159],85:160,89:161,90:162,91:163,92:$V$,93:$V01},{24:166,35:$VX,38:$VY},{38:[1,167]},{38:[1,168]},{5:[2,54],29:[1,169],58:[1,170]},{5:[2,59],35:[1,171]},{5:[2,62],6:$V0,7:$V1,9:$V2,10:176,13:$V3,14:[1,175],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,173],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,61:[1,172],62:174,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{5:[2,70]},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,14:[1,178],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,177],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:179,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,13:$V3,14:[1,180],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:181,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,100:67,102:$VR},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,14:[1,183],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,182],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:184,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,14:[1,186],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,185],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:187,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,14:[1,189],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,188],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:190,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,14:[1,192],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,191],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:193,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,13:$V3,14:[1,194],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:195,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,100:67,102:$VR},{5:[2,93]},{6:$V0,7:$V1,9:$V2,13:$V3,14:[1,196],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,198],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:197,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,100:67,102:$VR},{5:[2,97],28:[1,199]},{76:[1,200],79:[1,201]},{1:[2,1]},{5:[2,5]},{5:[2,7],104:$V11},o($V21,[2,205]),o($V21,[2,206]),o($V31,[2,143]),o($V31,[2,144]),o($V21,[2,193]),o($V21,[2,194]),o($V21,[2,195]),o($V21,[2,196]),o($V21,[2,197]),o($V21,[2,198]),o($V21,[2,199]),o($V31,[2,147]),o($V31,[2,148]),o($V31,[2,149]),o($V31,[2,150]),o($V31,[2,151]),o($V31,[2,152]),o($V31,[2,153]),o($V31,[2,154]),o($V31,[2,155]),o($V31,[2,156]),o($V31,[2,157]),o($V31,[2,158]),o($V31,[2,159]),o($V31,[2,160]),o($V31,[2,161]),o($V31,[2,162]),o($V31,[2,163]),o($V31,[2,164]),o($V31,[2,165]),o($V31,[2,166]),o($V31,[2,167]),o($V31,[2,168]),o($V31,[2,169]),o($V31,[2,170]),o($V31,[2,171]),o($V31,[2,172]),o($V31,[2,173]),o($V31,[2,174]),o($V31,[2,175]),o($V31,[2,176]),o($V31,[2,177]),o($V31,[2,178]),o($V31,[2,179]),o($V31,[2,180]),o($V31,[2,181]),o($V31,[2,182]),o($V31,[2,183]),o($V31,[2,184]),o($V31,[2,185]),o($V31,[2,186]),o($V31,[2,187]),o($V31,[2,188]),o($V31,[2,189]),o($V31,[2,190]),o($V31,[2,191]),o($V31,[2,192]),{5:[2,10],104:$V11},{5:[2,11]},{14:$VS,16:203,35:$VT,38:$VU,98:$VV,99:$VW,104:$V11},{14:$VS,16:204,35:$VT,38:$VU,98:$VV,99:$VW},{5:[2,18]},o($V41,[2,138]),o($V41,[2,139]),o($V41,[2,140]),o($V41,[2,141]),o($V41,[2,142]),{5:[2,21]},o($V51,[2,121]),o($V51,[2,122]),{5:[2,22]},{5:[2,23]},{5:[2,24]},{5:[2,26]},{5:[2,27]},{5:[2,28],31:[1,205]},{5:[2,30]},{36:[1,206]},{5:[2,32]},{5:[2,36]},{5:[2,37]},{5:[2,39]},{5:[2,41]},{5:[2,42],94:207,95:$VZ},o($V61,[2,132]),{35:[1,208]},{5:[2,43],94:207,95:$VZ},{14:[1,209]},{6:$V0,7:$V1,9:$V2,10:210,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR,104:$V11},{5:[2,53]},{5:[2,107]},{5:[2,108]},{5:[2,109]},{5:[2,210]},{5:[2,110]},{5:[2,112],85:211,89:161,90:162,91:163,92:$V$,93:$V01},{5:[2,113]},{5:[2,123],89:212,90:162,91:163,92:$V$,93:$V01},o($V51,[2,127]),o($V51,[2,128],{100:67,54:213,96:214,97:215,66:216,6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,102:$VR}),{77:[1,217]},{77:[1,218]},{5:[2,115],85:219,89:161,90:162,91:163,92:$V$,93:$V01},{5:[2,117],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,54:220,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:214,97:215,100:67,102:$VR},{5:[2,119],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,54:221,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:214,97:215,100:67,102:$VR},{5:[2,55],58:[1,222]},{5:[2,56],29:[1,223]},{5:[2,60],35:[1,224]},{14:[1,225]},{5:[2,64],61:[1,226]},{5:[2,66],61:[1,227],105:$V71},{5:[2,68],61:[1,229]},o($V81,[2,211],{104:$V11}),{5:[2,71],61:[1,230]},{5:[2,72],61:[1,231]},{5:[2,73],61:[1,232],105:$V71},{5:[2,77]},{5:[2,78]},{5:[2,79]},{5:[2,80]},{5:[2,81],105:$V71},{5:[2,82]},{5:[2,83]},{5:[2,84],105:$V71},{14:[1,233]},{14:[1,234]},{14:[1,235],105:$V71},{5:[2,88]},{5:[2,89]},{5:[2,90],105:$V71},{5:[2,91]},{5:[2,92]},{5:[2,94]},{5:[2,95]},{5:[2,96]},{5:[2,98],6:$V0,7:$V1,9:$V2,13:$V3,14:[1,238],15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,236],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:237,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,100:67,102:$VR},{77:[1,239]},{77:[1,240]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,242],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:241,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:243,102:$VR},{5:[2,12]},{5:[2,13]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,32:244,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:245,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:246,102:$VR},{14:[1,247]},o($V61,[2,133]),o($V61,[2,134]),{5:[2,48],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,54:248,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:214,97:215,100:67,102:$VR},{5:[2,49],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,54:249,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:214,97:215,100:67,102:$VR,104:$V11},{5:[2,114]},{5:[2,124],89:250,90:162,91:163,92:$V$,93:$V01},o($V51,[2,129],{100:67,97:215,66:216,96:251,6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,102:$VR}),o($V41,[2,135]),{77:[1,252],104:[1,253]},o($V91,[2,202]),{14:$VS,16:254,35:$VT,38:$VU,98:$VV,99:$VW},{14:$VS,16:255,35:$VT,38:$VU,98:$VV,99:$VW},{5:[2,116]},{5:[2,118],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:251,97:215,100:67,102:$VR},{5:[2,120],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:251,97:215,100:67,102:$VR},{5:[2,57]},{5:[2,58]},{5:[2,61]},{5:[2,63]},{14:[1,256]},{14:[1,257]},{6:$V0,7:$V1,9:$V2,10:258,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{14:[1,259]},{5:[2,74]},{5:[2,75]},{5:[2,76]},{5:[2,85]},{5:[2,86]},{5:[2,87]},{5:[2,99]},{5:[2,100]},{5:[2,101]},{35:[1,260]},{35:[1,261],38:[1,262]},o($V21,[2,207]),o($V21,[2,208]),o($V21,[2,209]),{5:[2,29]},{5:[2,145]},{5:[2,146]},{31:[1,263]},{5:[2,50],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:251,97:215,100:67,102:$VR},{5:[2,51],6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:216,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,96:251,97:215,100:67,102:$VR},{5:[2,125],89:264,90:162,91:163,92:$V$,93:$V01},o($V41,[2,136]),{14:$VS,16:265,35:$VT,38:$VU,98:$VV,99:$VW},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,267],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:266,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,100:67,102:$VR},o($V51,[2,130]),o($V41,[2,131]),{5:[2,65]},{5:[2,67]},o($V81,[2,212],{104:$V11}),{5:[2,69]},{78:[1,268]},{80:[1,269]},{80:[1,270]},{6:$V0,7:$V1,9:$V2,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,32:271,33:$Ve,34:$Vf,37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,63:$Vs,64:$Vt,65:$Vu,66:245,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:246,102:$VR},{5:[2,126]},o($V41,[2,137]),o($V91,[2,203]),o($V91,[2,204]),{77:[1,272]},{77:[1,273]},{77:[1,274]},{5:[2,31]},{14:[1,275]},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,276],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:277,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{6:$V0,7:$V1,9:$V2,10:176,13:$V3,15:$V4,17:$V5,18:$V6,19:$V7,20:$V8,23:$V9,25:$Va,26:$Vb,27:$Vc,30:$Vd,33:$Ve,34:$Vf,35:[1,278],37:$Vg,38:$Vh,41:$Vi,43:$Vj,45:$Vk,46:$Vl,53:$Vm,55:$Vn,56:$Vo,57:$Vp,59:$Vq,60:$Vr,62:279,63:$Vs,64:$Vt,65:$Vu,66:64,67:$Vv,68:$Vw,69:$Vx,70:$Vy,71:$Vz,72:$VA,73:$VB,74:$VC,75:$VD,76:$VE,78:$VF,79:$VG,80:$VH,81:$VI,83:$VJ,84:$VK,86:$VL,87:$VM,88:$VN,92:$VO,93:$VP,95:$VQ,100:67,101:65,102:$VR},{5:[2,102]},{76:[1,280]},{76:[1,281],105:$V71},{76:[1,282]},{76:[1,283],105:$V71},{77:[1,284]},{77:[1,285]},{77:[1,286]},{77:[1,287]},{35:[1,288]},{35:[1,289]},{35:[1,290]},{35:[1,291]},{78:[1,292]},{78:[1,293]},{78:[1,294]},{78:[1,295]},{77:[1,296]},{77:[1,297]},{77:[1,298]},{77:[1,299]},{14:[1,300]},{14:[1,301]},{14:[1,302]},{14:[1,303]},{5:[2,103]},{5:[2,105]},{5:[2,104]},{5:[2,106]}],
	defaultActions: {3:[2,2],4:[2,3],7:[2,8],8:[2,9],11:[2,14],12:[2,15],13:[2,16],15:[2,19],16:[2,20],25:[2,33],26:[2,34],29:[2,40],33:[2,44],34:[2,45],35:[2,46],36:[2,47],38:[2,52],49:[2,70],57:[2,93],61:[2,1],62:[2,5],122:[2,11],125:[2,18],131:[2,21],134:[2,22],135:[2,23],136:[2,24],137:[2,26],138:[2,27],140:[2,30],142:[2,32],143:[2,36],144:[2,37],145:[2,39],146:[2,41],153:[2,53],154:[2,107],155:[2,108],156:[2,109],157:[2,210],158:[2,110],160:[2,113],180:[2,77],181:[2,78],182:[2,79],183:[2,80],185:[2,82],186:[2,83],191:[2,88],192:[2,89],194:[2,91],195:[2,92],196:[2,94],197:[2,95],198:[2,96],203:[2,12],204:[2,13],211:[2,114],219:[2,116],222:[2,57],223:[2,58],224:[2,61],225:[2,63],230:[2,74],231:[2,75],232:[2,76],233:[2,85],234:[2,86],235:[2,87],236:[2,99],237:[2,100],238:[2,101],244:[2,29],245:[2,145],246:[2,146],256:[2,65],257:[2,67],259:[2,69],264:[2,126],271:[2,31],275:[2,102],300:[2,103],301:[2,105],302:[2,104],303:[2,106]},
	parseError: function parseError(str, hash) {
	    if (hash.recoverable) {
	        this.trace(str);
	    } else {
	        var error = new Error(str);
	        error.hash = hash;
	        throw error;
	    }
	},
	parse: function parse(input) {
	    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, TERROR = 2, EOF = 1;
	    var args = lstack.slice.call(arguments, 1);
	    var lexer = Object.create(this.lexer);
	    var sharedState = { yy: {} };
	    for (var k in this.yy) {
	        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
	            sharedState.yy[k] = this.yy[k];
	        }
	    }
	    lexer.setInput(input, sharedState.yy);
	    sharedState.yy.lexer = lexer;
	    sharedState.yy.parser = this;
	    if (typeof lexer.yylloc == 'undefined') {
	        lexer.yylloc = {};
	    }
	    var yyloc = lexer.yylloc;
	    lstack.push(yyloc);
	    var ranges = lexer.options && lexer.options.ranges;
	    if (typeof sharedState.yy.parseError === 'function') {
	        this.parseError = sharedState.yy.parseError;
	    } else {
	        this.parseError = Object.getPrototypeOf(this).parseError;
	    }
	            function lex() {
	            var token;
	            token = tstack.pop() || lexer.lex() || EOF;
	            if (typeof token !== 'number') {
	                if (token instanceof Array) {
	                    tstack = token;
	                    token = tstack.pop();
	                }
	                token = self.symbols_[token] || token;
	            }
	            return token;
	        }
	    var symbol, preErrorSymbol, state, action, r, yyval = {}, p, len, newState, expected;
	    while (true) {
	        state = stack[stack.length - 1];
	        if (this.defaultActions[state]) {
	            action = this.defaultActions[state];
	        } else {
	            if (symbol === null || typeof symbol == 'undefined') {
	                symbol = lex();
	            }
	            action = table[state] && table[state][symbol];
	        }
	        if (typeof action === 'undefined' || !action.length || !action[0]) {
	            var errStr = '';
	            expected = [];
	            for (p in table[state]) {
	                if (this.terminals_[p] && p > TERROR) {
	                    expected.push('\'' + this.terminals_[p] + '\'');
	                }
	            }
	            if (lexer.showPosition) {
	                errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
	            } else {
	                errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
	            }
	            this.parseError(errStr, {
	                text: lexer.match,
	                token: this.terminals_[symbol] || symbol,
	                line: lexer.yylineno,
	                loc: yyloc,
	                expected: expected
	            });
	        }
	        if (action[0] instanceof Array && action.length > 1) {
	            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
	        }
	        switch (action[0]) {
	        case 1:
	            stack.push(symbol);
	            vstack.push(lexer.yytext);
	            lstack.push(lexer.yylloc);
	            stack.push(action[1]);
	            symbol = null;
	            if (!preErrorSymbol) {
	                yyleng = lexer.yyleng;
	                yytext = lexer.yytext;
	                yylineno = lexer.yylineno;
	                yyloc = lexer.yylloc;
	            } else {
	                symbol = preErrorSymbol;
	                preErrorSymbol = null;
	            }
	            break;
	        case 2:
	            len = this.productions_[action[1]][1];
	            yyval.$ = vstack[vstack.length - len];
	            yyval._$ = {
	                first_line: lstack[lstack.length - (len || 1)].first_line,
	                last_line: lstack[lstack.length - 1].last_line,
	                first_column: lstack[lstack.length - (len || 1)].first_column,
	                last_column: lstack[lstack.length - 1].last_column
	            };
	            if (ranges) {
	                yyval._$.range = [
	                    lstack[lstack.length - (len || 1)].range[0],
	                    lstack[lstack.length - 1].range[1]
	                ];
	            }
	            r = this.performAction.apply(yyval, [
	                yytext,
	                yyleng,
	                yylineno,
	                sharedState.yy,
	                action[1],
	                vstack,
	                lstack
	            ].concat(args));
	            if (typeof r !== 'undefined') {
	                return r;
	            }
	            if (len) {
	                stack = stack.slice(0, -1 * len * 2);
	                vstack = vstack.slice(0, -1 * len);
	                lstack = lstack.slice(0, -1 * len);
	            }
	            stack.push(this.productions_[action[1]][0]);
	            vstack.push(yyval.$);
	            lstack.push(yyval._$);
	            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
	            stack.push(newState);
	            break;
	        case 3:
	            return true;
	        }
	    }
	    return true;
	}};


	/* generated by jison-lex 0.3.4 */
	var lexer = (function(){
	var lexer = ({

	EOF:1,

	parseError:function parseError(str, hash) {
	        if (this.yy.parser) {
	            this.yy.parser.parseError(str, hash);
	        } else {
	            throw new Error(str);
	        }
	    },

	// resets the lexer, sets new input
	setInput:function (input, yy) {
	        this.yy = yy || this.yy || {};
	        this._input = input;
	        this._more = this._backtrack = this.done = false;
	        this.yylineno = this.yyleng = 0;
	        this.yytext = this.matched = this.match = '';
	        this.conditionStack = ['INITIAL'];
	        this.yylloc = {
	            first_line: 1,
	            first_column: 0,
	            last_line: 1,
	            last_column: 0
	        };
	        if (this.options.ranges) {
	            this.yylloc.range = [0,0];
	        }
	        this.offset = 0;
	        return this;
	    },

	// consumes and returns one char from the input
	input:function () {
	        var ch = this._input[0];
	        this.yytext += ch;
	        this.yyleng++;
	        this.offset++;
	        this.match += ch;
	        this.matched += ch;
	        var lines = ch.match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno++;
	            this.yylloc.last_line++;
	        } else {
	            this.yylloc.last_column++;
	        }
	        if (this.options.ranges) {
	            this.yylloc.range[1]++;
	        }

	        this._input = this._input.slice(1);
	        return ch;
	    },

	// unshifts one char (or a string) into the input
	unput:function (ch) {
	        var len = ch.length;
	        var lines = ch.split(/(?:\r\n?|\n)/g);

	        this._input = ch + this._input;
	        this.yytext = this.yytext.substr(0, this.yytext.length - len);
	        //this.yyleng -= len;
	        this.offset -= len;
	        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
	        this.match = this.match.substr(0, this.match.length - 1);
	        this.matched = this.matched.substr(0, this.matched.length - 1);

	        if (lines.length - 1) {
	            this.yylineno -= lines.length - 1;
	        }
	        var r = this.yylloc.range;

	        this.yylloc = {
	            first_line: this.yylloc.first_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.first_column,
	            last_column: lines ?
	                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
	                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
	              this.yylloc.first_column - len
	        };

	        if (this.options.ranges) {
	            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
	        }
	        this.yyleng = this.yytext.length;
	        return this;
	    },

	// When called from action, caches matched text and appends it on next action
	more:function () {
	        this._more = true;
	        return this;
	    },

	// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
	reject:function () {
	        if (this.options.backtrack_lexer) {
	            this._backtrack = true;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });

	        }
	        return this;
	    },

	// retain first n characters of the match
	less:function (n) {
	        this.unput(this.match.slice(n));
	    },

	// displays already matched input, i.e. for error messages
	pastInput:function () {
	        var past = this.matched.substr(0, this.matched.length - this.match.length);
	        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
	    },

	// displays upcoming input, i.e. for error messages
	upcomingInput:function () {
	        var next = this.match;
	        if (next.length < 20) {
	            next += this._input.substr(0, 20-next.length);
	        }
	        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
	    },

	// displays the character position where the lexing error occurred, i.e. for error messages
	showPosition:function () {
	        var pre = this.pastInput();
	        var c = new Array(pre.length + 1).join("-");
	        return pre + this.upcomingInput() + "\n" + c + "^";
	    },

	// test the lexed token: return FALSE when not a match, otherwise return token
	test_match:function (match, indexed_rule) {
	        var token,
	            lines,
	            backup;

	        if (this.options.backtrack_lexer) {
	            // save context
	            backup = {
	                yylineno: this.yylineno,
	                yylloc: {
	                    first_line: this.yylloc.first_line,
	                    last_line: this.last_line,
	                    first_column: this.yylloc.first_column,
	                    last_column: this.yylloc.last_column
	                },
	                yytext: this.yytext,
	                match: this.match,
	                matches: this.matches,
	                matched: this.matched,
	                yyleng: this.yyleng,
	                offset: this.offset,
	                _more: this._more,
	                _input: this._input,
	                yy: this.yy,
	                conditionStack: this.conditionStack.slice(0),
	                done: this.done
	            };
	            if (this.options.ranges) {
	                backup.yylloc.range = this.yylloc.range.slice(0);
	            }
	        }

	        lines = match[0].match(/(?:\r\n?|\n).*/g);
	        if (lines) {
	            this.yylineno += lines.length;
	        }
	        this.yylloc = {
	            first_line: this.yylloc.last_line,
	            last_line: this.yylineno + 1,
	            first_column: this.yylloc.last_column,
	            last_column: lines ?
	                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
	                         this.yylloc.last_column + match[0].length
	        };
	        this.yytext += match[0];
	        this.match += match[0];
	        this.matches = match;
	        this.yyleng = this.yytext.length;
	        if (this.options.ranges) {
	            this.yylloc.range = [this.offset, this.offset += this.yyleng];
	        }
	        this._more = false;
	        this._backtrack = false;
	        this._input = this._input.slice(match[0].length);
	        this.matched += match[0];
	        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
	        if (this.done && this._input) {
	            this.done = false;
	        }
	        if (token) {
	            return token;
	        } else if (this._backtrack) {
	            // recover context
	            for (var k in backup) {
	                this[k] = backup[k];
	            }
	            return false; // rule action called reject() implying the next rule should be tested instead.
	        }
	        return false;
	    },

	// return next match in input
	next:function () {
	        if (this.done) {
	            return this.EOF;
	        }
	        if (!this._input) {
	            this.done = true;
	        }

	        var token,
	            match,
	            tempMatch,
	            index;
	        if (!this._more) {
	            this.yytext = '';
	            this.match = '';
	        }
	        var rules = this._currentRules();
	        for (var i = 0; i < rules.length; i++) {
	            tempMatch = this._input.match(this.rules[rules[i]]);
	            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
	                match = tempMatch;
	                index = i;
	                if (this.options.backtrack_lexer) {
	                    token = this.test_match(tempMatch, rules[i]);
	                    if (token !== false) {
	                        return token;
	                    } else if (this._backtrack) {
	                        match = false;
	                        continue; // rule action called reject() implying a rule MISmatch.
	                    } else {
	                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	                        return false;
	                    }
	                } else if (!this.options.flex) {
	                    break;
	                }
	            }
	        }
	        if (match) {
	            token = this.test_match(match, rules[index]);
	            if (token !== false) {
	                return token;
	            }
	            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
	            return false;
	        }
	        if (this._input === "") {
	            return this.EOF;
	        } else {
	            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
	                text: "",
	                token: null,
	                line: this.yylineno
	            });
	        }
	    },

	// return next match that has a token
	lex:function lex() {
	        var r = this.next();
	        if (r) {
	            return r;
	        } else {
	            return this.lex();
	        }
	    },

	// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
	begin:function begin(condition) {
	        this.conditionStack.push(condition);
	    },

	// pop the previously active lexer condition state off the condition stack
	popState:function popState() {
	        var n = this.conditionStack.length - 1;
	        if (n > 0) {
	            return this.conditionStack.pop();
	        } else {
	            return this.conditionStack[0];
	        }
	    },

	// produce the lexer rule set which is active for the currently active lexer condition state
	_currentRules:function _currentRules() {
	        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
	            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
	        } else {
	            return this.conditions["INITIAL"].rules;
	        }
	    },

	// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
	topState:function topState(n) {
	        n = this.conditionStack.length - 1 - Math.abs(n || 0);
	        if (n >= 0) {
	            return this.conditionStack[n];
	        } else {
	            return "INITIAL";
	        }
	    },

	// alias for begin(condition)
	pushState:function pushState(condition) {
	        this.begin(condition);
	    },

	// return the number of states currently on the stack
	stateStackSize:function stateStackSize() {
	        return this.conditionStack.length;
	    },
	options: {"case-insensitive":true},
	performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
	switch($avoiding_name_collisions) {
	case 0:/* ignore whitespace */
	break;
	case 1:return '';
	break;
	case 2:return '';
	break;
	case 3:return 42;
	break;
	case 4:return 35;
	break;
	case 5:return 98;
	break;
	case 6:return 99;
	break;
	case 7:return 99;
	break;
	case 8:return 8;
	break;
	case 9:return 6;
	break;
	case 10:return 102;
	break;
	case 11:return 7;
	break;
	case 12:return 9;
	break;
	case 13:return 81;
	break;
	case 14:return 83;
	break;
	case 15:return 13
	break;
	case 16:return 15
	break;
	case 17:return 17
	break;
	case 18:return 18
	break;
	case 19:return 19
	break;
	case 20:return 20
	break;
	case 21:return 11
	break;
	case 22:return 84
	break;
	case 23:return 86
	break;
	case 24:return 23
	break;
	case 25:return 25
	break;
	case 26:return 26
	break;
	case 27:return 27
	break;
	case 28:return 30
	break;
	case 29:return 34
	break;
	case 30:return 33
	break;
	case 31:return 87
	break;
	case 32:return 88
	break;
	case 33:return 37
	break;
	case 34:return 41
	break;
	case 35:return 43
	break;
	case 36:return 53
	break;
	case 37:return 55
	break;
	case 38:return 56
	break;
	case 39:return 46
	break;
	case 40:return 48
	break;
	case 41:return 45
	break;
	case 42:return 57
	break;
	case 43:return 59;
	break;
	case 44:return 44
	break;
	case 45:return 60
	break;
	case 46:return 63
	break;
	case 47:return 64
	break;
	case 48:return 65
	break;
	case 49:return 67
	break;
	case 50:return 68
	break;
	case 51:return 69
	break;
	case 52:return 70
	break;
	case 53:return 71
	break;
	case 54:return 72
	break;
	case 55:return 73
	break;
	case 56:return 75
	break;
	case 57:return 74
	break;
	case 58:return 92
	break;
	case 59:return 92
	break;
	case 60:return 93
	break;
	case 61:return 93
	break;
	case 62:return 95
	break;
	case 63:return 95
	break;
	case 64:return 95
	break;
	case 65:return 31
	break;
	case 66:return 36
	break;
	case 67:return 79
	break;
	case 68:return 76
	break;
	case 69:return 80
	break;
	case 70:return 78
	break;
	case 71:yy_.yytext = yy.utils.unquoteString(yy_.yytext); return 14;
	break;
	case 72:return 38;
	break;
	case 73:return 5;
	break;
	case 74:return 104;
	break;
	case 75:return 105;
	break;
	case 76:return '\\';
	break;
	case 77:return 28
	break;
	case 78:return 61
	break;
	case 79:return 29
	break;
	case 80:return 58
	break;
	case 81:return 77
	break;
	}
	},
	rules: [/^(?:\s+)/i,/^(?:[#].*)/i,/^(?:\/\/.*)/i,/^(?:([_A-Z0-9\/\+]+==))/i,/^(?:-?[0-9]+(\.[0-9]+)?\b)/i,/^(?:0[xX][0-9A-F]+\b)/i,/^(?:false\b)/i,/^(?:true\b)/i,/^(?:all\b)/i,/^(?:reset\b)/i,/^(?:clear\b)/i,/^(?:build\b)/i,/^(?:help\b)/i,/^(?:load\b)/i,/^(?:script\b)/i,/^(?:get\b)/i,/^(?:set\b)/i,/^(?:set_save\b)/i,/^(?:set_restore\b)/i,/^(?:set_reset\b)/i,/^(?:preset\b)/i,/^(?:motm\b)/i,/^(?:add\b)/i,/^(?:rep\b)/i,/^(?:remove\b)/i,/^(?:hide\b)/i,/^(?:show\b)/i,/^(?:list\b)/i,/^(?:select\b)/i,/^(?:within\b)/i,/^(?:selector\b)/i,/^(?:mode\b)/i,/^(?:color\b)/i,/^(?:material\b)/i,/^(?:view\b)/i,/^(?:unit\b)/i,/^(?:line\b)/i,/^(?:listobj\b)/i,/^(?:removeobj\b)/i,/^(?:rotate\b)/i,/^(?:translate\b)/i,/^(?:scale\b)/i,/^(?:url\b)/i,/^(?:screenshot\b)/i,/^(?:dssp\b)/i,/^(?:file_list\b)/i,/^(?:file_register\b)/i,/^(?:file_delete\b)/i,/^(?:preset_add\b)/i,/^(?:preset_delete\b)/i,/^(?:preset_update\b)/i,/^(?:preset_rename\b)/i,/^(?:preset_open\b)/i,/^(?:create_scenario\b)/i,/^(?:reset_scenario\b)/i,/^(?:delete_scenario\b)/i,/^(?:add_scenario_item\b)/i,/^(?:list_scenario\b)/i,/^(?:s\b)/i,/^(?:mt\b)/i,/^(?:m\b)/i,/^(?:c\b)/i,/^(?:x\b)/i,/^(?:y\b)/i,/^(?:z\b)/i,/^(?:as\b)/i,/^(?:of\b)/i,/^(?:pdb\b)/i,/^(?:delay\b)/i,/^(?:prst\b)/i,/^(?:desc\b)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:\.)/i,/^(?:\/)/i,/^(?:\\)/i,/^(?:-e\b)/i,/^(?:-f\b)/i,/^(?:-s\b)/i,/^(?:-v\b)/i,/^(?:=)/i],
	conditions: {"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],"inclusive":true}}
	});
	return lexer;
	})();
	parser.lexer = lexer;
	function Parser () {
	  this.yy = {};
	}
	Parser.prototype = parser;parser.Parser = Parser;
	return new Parser;
	})();

	var MiewCLIParser = {parser: parser$1};
	var MiewCLIParser_1 = MiewCLIParser.parser;

	var modeIdDesc = {
	  $help: ['Rendering mode shortcut', '    BS - balls and sticks mode', '    LN - lines mode', '    LC - licorice mode', '    VW - van der waals mode', '    TR - trace mode', '    TU - tube mode', '    CA - cartoon mode', '    SA - isosurface mode', '    QS - quick surface mode', '    SE - solvent excluded mode', '    TX - text mode'],
	  BS: {
	    $help: ['   Balls and sticks', '      aromrad = <number> #aromatic radius', '      atom = <number>    #atom radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
	  },
	  CA: {
	    $help: ['   Cartoon', '      arrow = <number>   #arrow size', '      depth = <number>   #depth of surface', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> #', '      width = <number>  #secondary width\n']
	  },
	  LN: {
	    $help: ['   Lines', '      atom = <number>    #atom radius', '      chunkarom = <number>', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      offsarom = <number>\n']
	  },
	  LC: {
	    $help: ['   Licorice', '      aromrad = <number> #aromatic radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
	  },
	  VW: {
	    $help: ['   Van der Waals', '      nothing\n']
	  },
	  TR: {
	    $help: ['   Trace', '      radius = <number>  #tube radius\n']
	  },
	  TU: {
	    $help: ['   Tube', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> \n']
	  },
	  SA: {
	    $help: ['   Surface', '      zClip = <bool> #clip z plane\n']
	  },
	  QS: {
	    $help: ['   Quick surface', '      isoValue = <number>', '      scale = <number>', '      wireframe = <bool>', '      zClip = <bool> #clip z plane\n']
	  },
	  SE: {
	    $help: ['   Solvent excluded surface', '      zClip = <bool> #clip z plane\n']
	  },
	  TX: {
	    $help: ['   Text mode', '      template = <format string> string that can include "{{ id }}"', '          it will be replaced by value, id can be one of next:', '          serial, name, type, sequence, residue, chain, hetatm, water\n', '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', '      dx = <number> #offset along x', '      dy = <number> #offset along y', '      dz = <number> #offset along z', '      fg = <string> #text color modificator', '           could be keyword, named color or hex', '      fg = <string> #back color modificator', '           could be keyword, named color or hex', '      showBg = <bool> #if set show background', '           plate under text']
	  }
	};

	var colorDesc = {
	  $help: ['Coloring mode shortcut', '    EL - color by element', '    CH - color by chain', '    SQ - color by sequence', '    RT - color by residue type', '    SS - color by secondary structure', '    UN - uniform'],
	  UN: {
	    $help: ['Parameters of coloring modes customization', '   Uniform', '      color = <number|color> #RGB->HEX->dec\n'],
	    color: {
	      $help: Object.keys(palettes.get(settings.now.palette).namedColors).sort().join('\n')
	    }
	  }
	};

	var materialDesc = {
	  $help: ['Material shortcut', '    DF - diffuse', '    TR - transparent', '    SF - soft plastic', '    PL - glossy plastic', '    ME - metal', '    GL - glass']
	};

	var addRepDesc = {
	  $help: ['Short (packed) representation description as a set of variables', '    s=<EXPRESSION>', '        selector property', '    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]', '        render mode property', '    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]', '        color mode property', '    mt=<MATERIAL_ID>', '        material property'],
	  s: {
	    $help: 'Selection expression string as it is in menu->representations->selection'
	  },
	  m: modeIdDesc,
	  c: colorDesc,
	  mt: materialDesc
	};

	var setGetParameterDesc = {
	  $help: ['Parameters of rendering modes customization: modes', 'Parameters of colorer customization: colorers', 'Autobuild: autobuild = (<number>|<bool>)'],
	  modes: modeIdDesc,
	  colorers: colorDesc
	};

	var help = {
	  $help: ['help (<cmd name>| <path to property>)', 'You can get detailed information about command options', '   using "help cmd.opt.opt.[...]"\n', '   you can use one line comments', '   everything started from (#|//) will be skipped', '   Example: >build //some comment\n', 'List of available commands:'],
	  reset: {
	    $help: ['Reload current object, delete all representations', '    Nothing will work until load new object']
	  },
	  load: {
	    $help: ['load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])', '    Load new pdb object from selected source'],
	    PDBID: {
	      $help: 'pdb id in remote molecule database'
	    },
	    URL: {
	      $help: 'url to source file'
	    },
	    'f': {
	      $help: ['open file system dialog to fetch local file', 'optionally you can determine trajectory file', 'via URL for *.top model']
	    }
	  },
	  clear: {
	    $help: 'No args. Clear terminal'
	  },
	  add: {
	    $help: ['add [<REP_NAME>] [<DESCRIPTION>]', '    Add new item to representation set with', '    default or <DESCRIPTION> params'],
	    REP_NAME: {
	      $help: 'Identifier string [_,a-z,A-Z,0-9] can not start from digit'
	    },
	    DESCRIPTION: addRepDesc
	  },
	  rep: {
	    $help: ['rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]', '    set current representation by name or index', '    edit current representation by <DESCRIPTION>'],
	    REP_NAME: {
	      $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
	    },
	    REP_INDEX: {
	      $help: 'Index of available representation'
	    },
	    DESCRIPTION: addRepDesc
	  },
	  remove: {
	    $help: ['remove (<REP_NAME>|<REP_INDEX>)', 'Remove representation by name or index'],
	    REP_NAME: {
	      $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
	    },
	    REP_INDEX: {
	      $help: 'Index of available representation'
	    }
	  },
	  selector: {
	    $help: ['selector <EXPRESSION>', '   set selector from EXPRESSION to current representation'],
	    EXPRESSION: {
	      $help: 'Selection expression string as it is in menu->representations->selection'
	    }
	  },
	  mode: {
	    $help: ['mode <MODE_ID> [<PARAMETER>=<VALUE>...]', '   set rendering mode and apply parameters to current representation'],
	    MODE_ID: modeIdDesc
	  },
	  color: {
	    $help: ['color <COLORER_ID> [<PARAMETER>=<VALUE>...]', '   set colorer and apply parameters to current representation'],
	    COLORER_ID: colorDesc
	  },
	  material: {
	    $help: ['material <MATERIAL_ID>', '   set material to current representation'],
	    MATERIAL_ID: materialDesc
	  },
	  build: {
	    $help: 'build help str',
	    add: {
	      $help: 'build.add',
	      new: {
	        $help: ['add.new', 'add.new new line 1', 'add.new new line 2', 'add.new new line 3']
	      }
	    },
	    del: {
	      $help: 'build.del'
	    }
	  },
	  list: {
	    $help: ['list [-e|-s|<REP_NAME>|<REP_INDEX>]', 'Print representations if no args print list of representations', '    -e expand list and show all representations', '    -s show all user-registered selectors', '    <REP_NAME>|<REP_INDEX> show only current representation']
	  },
	  hide: {
	    $help: ['hide (<REP_NAME>|<REP_INDEX>)', 'Hide representation referenced in args']
	  },
	  show: {
	    $help: ['show (<REP_NAME>|<REP_INDEX>)', 'Show representation referenced in args']
	  },
	  get: {
	    $help: ['get <PARAMETER>', 'Print <PARAMETER> value', '    <PARAMETER> - path to option use get.PARAMETER to get more info'],
	    PARAMETER: setGetParameterDesc
	  },
	  set: {
	    $help: ['set <PARAMETER> <VALUE>', 'Set <PARAMETER> with <VALUE>', '    <PARAMETER> - path to option use set.PARAMETER to get more info'],
	    PARAMETER: setGetParameterDesc
	  },
	  set_save: {
	    $help: ['set_save', 'Save current settings to cookie']
	  },
	  set_restore: {
	    $help: ['set_restore', 'Load and apply settings from cookie']
	  },
	  set_reset: {
	    $help: ['set_reset', 'Reset current settings to the defaults']
	  },
	  preset: {
	    $help: ['preset [<PRESET>]', 'Reset current representation or set preset to <PRESET>'],
	    PRESET: {
	      $help: ['default', 'wire', 'small', 'macro']
	    }
	  },
	  unit: {
	    $help: ['unit [<unit_id>]', 'Change current biological structure view. Zero <unit_id> value means asymmetric unit,', 'positive values set an assembly with corresponding number.', 'Being called with no parameters command prints current unit information.']
	  },
	  view: {
	    $help: ['view [<ENCODED_VIEW>]', 'Get current encoded view or set if ENCODED_VIEW placed as argument'],
	    ENCODED_VIEW: {
	      $help: ['encoded view matrix string (binary code)']
	    }
	  },
	  rotate: {
	    $help: ['rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...', 'Rotate scene']
	  },
	  scale: {
	    $help: ['scale <SCALE>', 'Scale scene']
	  },
	  select: {
	    $help: ['select <SELECTOR_STRING> [as <SELECTOR_NAME>]', 'Select atoms using selector defined in SELECTOR_STRING', '    and if SELECTOR_NAME is defined register it in viewer', '    you can use it later as a complex selector']
	  },
	  within: {
	    $help: ['within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>', 'Build within named selector', '    DISTANCE        <number>', '    SELECTOR_STRING <string(selection language)>', '    SELECTOR_NAME   <identifier>']
	  },
	  url: {
	    $help: ['url [-s] [-v]', 'Report URL encoded scene', '    if -s set that include settings in the URL', '    if -v set that include view in the URL']
	  },
	  screenshot: {
	    $help: ['screenshot [<WIDTH> [<HEIGHT>]]', 'Make a screenshot of the scene', '    WIDTH  <number> in pixels', '    HEIGHT <number> in pixels, equal to WIDTH by default']
	  },
	  line: {
	    $help: ['line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]', 'Draw dashed line between two specified atoms']
	  },
	  removeobj: {
	    $help: ['removeobj <id>', 'Remove scene object by its index. Indices could be obtained by <listobj> command']
	  },
	  listobj: {
	    $help: ['listobj', 'Display the list of all existing scene objects']
	  },
	  file_list: {
	    $help: ['file_list [(<FILE_ID>|FILE_NAME)] [-f=<STARTS_FROM>]', 'Report registered files on server or presets in file if defined FILE_ID or FILE_NAME', '    also you can use -f flag for fast search', '    entity by starting part of name']
	  },
	  file_register: {
	    $help: ['file_register ', 'Try register current opened file to server']
	  },
	  file_delete: {
	    $help: ['file_delete (<FILE_ID>|FILE_NAME) [-f]', 'Delete file from server', '    if -f not set then file will be deleted', '        only when it has not got any presets in it', '    if -f set then file will be deleted anyway']
	  },
	  preset_add: {
	    $help: ['preset_add <PRESET_NAME> ', 'Create new preset from current viewer state', '    to current opened file on server']
	  },
	  preset_delete: {
	    $help: ['preset_delete (<PRESET_ID>|<PATH_TO_PRESET>)', 'Delete preset from server']
	  },
	  preset_update: {
	    $help: ['preset_update <(<PRESET_ID>|<PATH_TO_PRESET>)', 'Update due the current viewer state']
	  },
	  preset_rename: {
	    $help: ['preset_rename (<PRESET_ID>|<PATH_TO_PRESET>) <PRESET_NAME>', 'Rename preset']
	  },
	  preset_open: {
	    $help: ['preset_open (<PRESET_ID>|<PATH_TO_PRESET>)', 'Load preset']
	  },
	  create_scenario: {
	    $help: ['create_scenario <SCENARIO_NAME>', '    Creates scenario context for future work with them']
	  },
	  reset_scenario: {
	    $help: ['reset_scenario', '    Clear current scenario context']
	  },
	  add_scenario_item: {
	    $help: ['add_scenario_item', '    pdb=(<pdbid> | <file_id>)', '    prst=(<preset_name in pdbid>|<preset_id>)', '    delay=<number>', '    desc=<string>\n', '    Add item to context and update scenario on server', '    Pay attention that order of arguments is important']
	  },
	  delete_scenario: {
	    $help: ['delete_scenario (<SCENARIO_ID>|<SCENARIO_NAME>)', '    Deletes scenario from server']
	  },
	  list_scenario: {
	    $help: ['list_scenario [-e [<SCENARIO_ID>|<SCENARIO_NAME>]]', '    Report scenario list, when -e is set reports expanded', '    If set -e <id> then reports only requested scenario']
	  }
	};

	function parseRange(node) {
	  if (node instanceof Array) {
	    return new selectors.Range(node[0], node[1]);
	  } else {
	    return new selectors.Range(node, node);
	  }
	}

	function parseRangeList(node) {
	  var args = [];
	  for (var i = 0; i < node.length; ++i) {
	    args.push(parseRange(node[i]));
	  }
	  return new selectors.RangeList(args);
	}

	function parseValueList(node) {
	  var args = [];
	  for (var i = 0; i < node.length; ++i) {
	    args.push(node[i]);
	  }
	  return new selectors.ValueList(args);
	}

	function _createSelectorFromNode(node) {
	  var factory = selectors.keyword(node[0]);
	  if (!factory || !factory.SelectorClass) {
	    return null;
	  }

	  var selector = null;
	  var proto = factory.SelectorClass.prototype;
	  if (proto instanceof selectors.PrefixOperator && node.length === 2) {
	    selector = factory(_createSelectorFromNode(node[1]));
	  } else if (proto instanceof selectors.InfixOperator && node.length === 3) {
	    selector = factory(_createSelectorFromNode(node[1]), _createSelectorFromNode(node[2]));
	  } else if (proto instanceof selectors.RangeListSelector && node.length === 2) {
	    selector = factory(parseRangeList(node[1]));
	  } else if (proto instanceof selectors.ValueListSelector && node.length === 2) {
	    selector = factory(parseValueList(node[1]));
	  } else if (proto instanceof selectors.Selector && node.length === 1) {
	    selector = factory();
	  }

	  return selector;
	}

	var JSONtoSelectorConverter = function () {
	  function JSONtoSelectorConverter() {
	    classCallCheck(this, JSONtoSelectorConverter);
	  }

	  createClass(JSONtoSelectorConverter, [{
	    key: 'createSelectorFromNode',
	    value: function createSelectorFromNode(node) {
	      return _createSelectorFromNode(node);
	    }
	  }]);
	  return JSONtoSelectorConverter;
	}();

	var selectors$4 = Miew.chem.selectors,
	    modes$1 = Miew.modes,
	    colorers$1 = Miew.colorers,
	    materials$1 = Miew.materials,
	    palettes$1 = Miew.palettes,
	    options$1 = Miew.options,
	    settings$1 = Miew.settings;

	function None() {}

	var NULL = function () {
	  var obj = new None();
	  return function () {
	    return obj;
	  };
	}();

	function RepresentationMap() {
	  this.representationMap = {};
	  this.representationID = {};
	}
	RepresentationMap.prototype.get = function (strId) {
	  return this.representationMap[strId] || this.representationID[strId] || '<no name>';
	};

	RepresentationMap.prototype.add = function (strId, index) {
	  if (index !== undefined) {
	    if (!this.representationMap.hasOwnProperty(strId)) {
	      this.representationMap[strId.toString()] = index;
	      this.representationID[index] = strId.toString();
	    } else {
	      return 'This name has already existed, registered without name';
	    }
	  }
	  return 'Representation ' + strId + ' successfully added';
	};

	RepresentationMap.prototype.remove = function (index) {
	  if (index && this.representationID.hasOwnProperty(index)) {
	    delete this.representationMap[this.representationID[index]];
	    delete this.representationID[index];
	  }

	  var sortedKeys = Object.keys(this.representationID).sort();
	  for (var i in sortedKeys) {
	    if (sortedKeys.hasOwnProperty(i)) {
	      var id = sortedKeys[i];
	      if (id > index) {
	        this.representationID[id - 1] = this.representationID[id];
	        this.representationMap[this.representationID[id]] -= 1;
	        delete this.representationID[id];
	      }
	    }
	  }
	};

	RepresentationMap.prototype.clear = function () {
	  this.representationMap = {};
	  this.representationID = {};
	};
	var representationsStorage = new RepresentationMap();

	function CLIUtils() {}
	//repIndexOrRepMap could be RepresentationMap or index
	CLIUtils.prototype.list = function (miew, repMap, key) {
	  var ret = '';
	  if (miew && repMap !== undefined) {
	    if (key === undefined || key === '-e') {
	      var count = miew.repCount();

	      for (var i = 0; i < count; i++) {
	        ret += this.listRep(miew, repMap, i, key);
	      }
	    }
	  }
	  return ret;
	};

	CLIUtils.prototype.listRep = function (miew, repMap, repIndex, key) {
	  var ret = '';
	  var rep = miew.repGet(repIndex);
	  if (!rep) {
	    logger.warn('Rep ' + repIndex + ' does not exist!');
	    return ret;
	  }
	  var index = repIndex;
	  var repName = repMap.get(index);

	  var mode = rep.mode;
	  var selectionStr = rep.selectorString;
	  var colorer = rep.colorer;
	  var material = rep.materialPreset;

	  ret += '#' + index + ' : ' + mode.name + (repName === '<no name>' ? '' : ', ' + repName) + '\n';

	  if (key !== undefined) {
	    ret += '    selection : "' + selectionStr + '"\n';
	    ret += '    mode      : (' + mode.id + '), ' + mode.name + '\n';
	    ret += '    colorer   : (' + colorer.id + '), ' + colorer.name + '\n';
	    ret += '    material  : (' + material.id + '), ' + material.name + '\n';
	  }

	  return ret;
	};

	CLIUtils.prototype.listSelector = function (miew, context) {
	  var ret = '';

	  for (var k in context) {
	    if (context.hasOwnProperty(k)) {
	      ret += k + ' : "' + context[k] + '"\n';
	    }
	  }

	  return ret;
	};

	CLIUtils.prototype.listObjs = function (miew) {
	  var objs = miew._objects;

	  if (!objs || !Array.isArray(objs) || objs.length === 0) {
	    return 'There are no objects on the scene';
	  }

	  var strList = [];
	  for (var i = 0, n = objs.length; i < n; ++i) {
	    strList[i] = '' + i + ': ' + objs[i].toString();
	  }

	  return strList.join('\n');
	};

	CLIUtils.prototype.joinHelpStr = function (helpData) {
	  if (helpData instanceof Array) {
	    return helpData.join('\n');
	  }
	  return helpData;
	};

	CLIUtils.prototype.help = function (path) {
	  if (lodash.isUndefined(path)) {
	    return this.joinHelpStr(help.$help) + '\n' + lodash.slice(lodash.sortBy(lodash.keys(help)), 1).join(', ') + '\n';
	  }

	  var helpItem = lodash.get(help, path);
	  return lodash.isUndefined(helpItem) ? this.help() : this.joinHelpStr(helpItem.$help) + '\n';
	};

	CLIUtils.prototype.load = function (miew, arg) {
	  if (miew === undefined || arg === undefined || arg === '-f') {
	    return;
	  }
	  miew.awaitWhileCMDisInProcess();
	  var finish = function finish() {
	    return miew.finishAwaitingCMDInProcess();
	  };
	  miew.load(arg).then(finish, finish);
	};

	CLIUtils.prototype.checkArg = function (key, arg, modificate) {
	  if (key !== undefined && arg !== undefined) {
	    if (keyRemap(key) === 'selector') {
	      var res = selectors$4.parse(arg);

	      if (res.error !== undefined) {
	        var selExc = { message: res.error };
	        throw selExc;
	      }

	      if (modificate !== undefined && modificate) {
	        return res.selector;
	      }
	      return arg;
	    }

	    var modificators = {
	      'colorers': colorers$1,
	      'modes': modes$1,
	      'materials': materials$1
	    };

	    var modificator = key,
	        temp = void 0;
	    while (modificator !== temp) {
	      temp = modificator;
	      modificator = keyRemap(temp);
	    }

	    if (modificators[modificator].get(arg) === undefined) {
	      var exc = { message: arg + ' is not existed in ' + modificator };
	      throw exc;
	    }
	    return arg;
	  }
	  return NULL;
	};

	CLIUtils.prototype.propagateProp = function (path, arg) {
	  if (path !== undefined) {
	    var argExc = {};
	    var adapter = options$1.adapters[_typeof(lodash.get(settings$1.defaults, path))];
	    if (adapter === undefined) {
	      var pathExc = { message: path + ' is not existed' };
	      throw pathExc;
	    }

	    if ((path.endsWith('.color') || path.endsWith('.baseColor') || path.endsWith('.EL.carbon')) && typeof arg !== 'number') {
	      arg = palettes$1.get(settings$1.now.palette).getNamedColor(arg);
	    }

	    if (path.endsWith('.fg') || path.endsWith('.bg')) {
	      if (typeof arg !== 'number') {
	        var val = palettes$1.get(settings$1.now.palette).getNamedColor(arg, true);
	        if (val !== undefined) {
	          arg = '0x' + val.toString(16);
	        }
	      } else {
	        arg = '0x' + arg.toString(16);
	      }
	    }

	    if (path.endsWith('.template')) {
	      arg = arg.replace(/\\n/g, '\n'); //NOSONAR
	    }

	    if (arg !== undefined && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
	      argExc = { message: path + ' must be a "' + _typeof(lodash.get(settings$1.defaults, path)) + '"' };
	      throw argExc;
	    }

	    if (path === 'theme') {
	      var possibleThemes = Object.keys(settings$1.defaults.themes);
	      var isValid = false;
	      for (var i = 0; i < possibleThemes.length; i++) {
	        if (arg === possibleThemes[i]) {
	          isValid = true;
	          break;
	        }
	      }
	      if (!isValid) {
	        argExc = { message: path + ' must be one of [' + possibleThemes + ']' };
	        throw argExc;
	      }
	    }
	  }
	  return arg;
	};

	CLIUtils.prototype.unquoteString = function (value) {
	  return utils.unquoteString(value);
	};

	var utilFunctions = new CLIUtils();

	function SRVScenarioItem(_pdbID, _presetId, _delay, _description) {
	  this.pdbId = -1;
	  this.presetId = -1;
	  this.delay = -1;
	  this.description = '';

	  if (_pdbID !== undefined) {
	    this.pdbId = _pdbID;
	  }

	  if (_presetId !== undefined) {
	    this.presetId = _presetId;
	  }

	  if (_delay !== undefined) {
	    this.delay = _delay;
	  }

	  if (_description !== undefined) {
	    this.description = _description;
	  }

	  return this;
	}

	function SRVScenarioScript() {
	  this.scenarioId = -1;
	  this.data = [];

	  return this;
	}

	SRVScenarioScript.prototype.addItem = function (id, item) {
	  this.scenarioId = id;
	  this.data.push(item);
	};

	function SRVScenarioContext(_name) {
	  this.id = -1;
	  this.name = _name;
	  this.script = new SRVScenarioScript();

	  return this;
	}

	function SRVProxy() {
	  this.isOnApllyPresetEventInitialized = false;
	  this.scenarioContext = new SRVScenarioContext();
	}

	SRVProxy.prototype.requestScenarioID = function (miew, name, done, fail) {
	  var self = this;

	  function doneFindScenario(scenarioList) {
	    if (scenarioList instanceof Array) {
	      var availableItems = lodash.filter(scenarioList, function (item) {
	        return item.name !== undefined && item.name.toLowerCase() === name.toLowerCase() || item.id === Number(name);
	      });
	      if (availableItems.length < 1) {
	        if (fail !== undefined) {
	          fail('File not found');
	        }
	        self.finish(miew);
	      } else if (availableItems.length > 1) {
	        if (fail !== undefined) {
	          fail('There are two or more files, please specify one by file_id');
	        }
	        self.finish(miew);
	      } else if (done !== undefined) {
	        done(availableItems[0].id);
	      } else {
	        self.finish(miew);
	      }
	    } else {
	      self.finish(miew);
	    }
	  }

	  miew.awaitWhileCMDisInProcess();

	  function failFindScenario(message) {
	    if (message !== undefined) {
	      if (fail !== undefined) {
	        fail(message);
	      }
	    }
	    self.finish(miew);
	  }

	  if (name !== undefined) {
	    miew.srvScenarioList(doneFindScenario, failFindScenario);
	  }
	};

	SRVProxy.prototype.requestPdbID = function (miew, path, done, fail) {
	  var self = this;

	  function doneFindTopology(topologyList) {
	    if (topologyList instanceof Array) {
	      if (topologyList.length < 1) {
	        if (fail !== undefined) {
	          fail('File not found');
	        }
	        self.finish(miew);
	      } else if (topologyList.length > 1) {
	        if (fail !== undefined) {
	          fail('There are two or more files, please specify one by file_id');
	        }
	        self.finish(miew);
	      } else if (done !== undefined) {
	        done(topologyList[0].id);
	      } else {
	        self.finish(miew);
	      }
	    } else {
	      self.finish(miew);
	    }
	  }

	  function failFindTopology(message) {
	    if (message !== undefined) {
	      if (fail !== undefined) {
	        fail(message);
	      }
	    }
	    self.finish(miew);
	  }

	  var pathParts = path.split('/');
	  miew.awaitWhileCMDisInProcess();

	  if (pathParts.length !== 1) {
	    if (fail !== undefined) {
	      fail('Path can contain only file name or id');
	    }
	    self.finish(miew);
	  } else {
	    var pdbID = Number(pathParts[0]);
	    if (!Number.isNaN(pdbID)) {
	      done(pdbID);
	    } else {
	      miew.srvTopologyFind(pathParts[0], doneFindTopology, failFindTopology);
	    }
	  }
	};

	SRVProxy.prototype.requestPresetId = function (miew, path, done, fail) {
	  var self = this;
	  var pathParts = path.split('/');
	  miew.awaitWhileCMDisInProcess();

	  function failPdb(message) {
	    if (message !== undefined) {
	      if (fail !== undefined) {
	        fail(message);
	      }
	    }
	    self.finish(miew);
	  }

	  function donePdb(id) {
	    miew.srvPresetList(id, donePresetList, failPdb);
	  }

	  function donePresetList(presetList) {
	    if (presetList instanceof Array) {
	      var availableItems = lodash.filter(presetList, function (item) {
	        return item.name.toLowerCase() === pathParts[1].toLowerCase() || item.id === Number(pathParts[1]);
	      });

	      if (availableItems.length < 1) {
	        if (fail !== undefined) {
	          fail('Preset not found');
	        }
	        self.finish(miew);
	      } else if (availableItems.length > 1) {
	        if (fail !== undefined) {
	          fail('There are two or more presets, please specify one by preset_id');
	        }
	        self.finish(miew);
	      } else if (done !== undefined) {
	        done(availableItems[0].id);
	      } else {
	        self.finish(miew);
	      }
	    } else {
	      self.finish(miew);
	    }
	  }

	  if (pathParts.length !== 2) {
	    if (fail !== undefined) {
	      fail('Path can has 2 levels only (pdb/preset)');
	    }
	    self.finish(miew);
	  } else {
	    this.requestPdbID(miew, pathParts[0], donePdb, failPdb);
	  }
	};

	SRVProxy.prototype.createScenario = function (name) {
	  this.scenarioContext = new SRVScenarioContext(name);
	};

	SRVProxy.prototype.resetScenario = function () {
	  this.scenarioContext = new SRVScenarioContext();
	};

	SRVProxy.prototype.deleteScenario = function (miew, echo, error, name) {
	  var self = this;

	  this.init(miew, echo);
	  miew.awaitWhileCMDisInProcess();

	  function done(message) {
	    if (message !== undefined) {
	      echo(message);
	    }
	    self.finish(miew);
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      error(message);
	    }
	    self.finish(miew);
	  }

	  function doWithID(id) {
	    miew.srvScenarioDelete(id, done, fail);
	    self.finish(miew);
	  }

	  if (typeof name === 'number') {
	    doWithID(name);
	  } else {
	    this.requestScenarioID(miew, name, doWithID, fail);
	  }
	};

	SRVProxy.prototype.listScenario = function (miew, echo, error, name) {
	  var self = this;

	  this.init(miew, echo);
	  miew.awaitWhileCMDisInProcess();

	  function done(scenarioList) {
	    if (scenarioList instanceof Array) {
	      var res = '';

	      for (var i = 0, n = scenarioList.length; i < n; ++i) {
	        var draw = name === undefined;
	        var drawExpand = name === '-e' || scenarioList[i].id === Number(name) || scenarioList[i].name === name;

	        if (draw || drawExpand) {
	          res += 'id : ' + scenarioList[i].id + ', name : ' + scenarioList[i].name + '\n';
	          if (drawExpand) {
	            var data = JSON.parse(scenarioList[i].script).data;
	            res += 'scenario : \n';
	            for (var j = 0, m = data.length; j < m; ++j) {
	              res += '    index : ' + j + '\n';
	              res += '        pdbId       : ' + data[j].pdbId + '\n';
	              res += '        presetId    : ' + data[j].presetId + '\n';
	              res += '        delay       : ' + data[j].delay + '\n';
	              res += '        description : ' + data[j].description + '\n';
	            }
	          }
	        }
	      }
	      echo(res);
	    }
	    self.finish(miew);
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      error(message);
	    }
	    self.finish(miew);
	  }

	  miew.srvScenarioList(done, fail);
	};

	SRVProxy.prototype.addScenarioItem = function (miew, echo, error) {
	  var self = this;

	  var selfArguments = arguments;

	  this.init(miew, echo);
	  miew.awaitWhileCMDisInProcess();

	  function doneFindPdb(id) {
	    if (id >= 0) {
	      selfArguments[3] = id;
	      self.addScenarioItem.apply(self, selfArguments);
	    }
	  }

	  function doneFindPreset(id) {
	    if (id >= 0) {
	      selfArguments[4] = id;
	      self.addScenarioItem.apply(self, selfArguments);
	    }
	  }

	  function done(id, message) {
	    self.scenarioContext.id = id;
	    if (message !== undefined) {
	      echo(message);
	    }
	    self.finish(miew);
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      error(message);
	    }
	    self.finish(miew);
	  }

	  function doAddItem(pdbId, presetId, delay, desc) {
	    self.scenarioContext.script.addItem(self.scenarioContext.id, new SRVScenarioItem(pdbId, presetId, delay, desc));
	    miew.srvScenarioAdd(self.scenarioContext.id, self.scenarioContext.name, JSON.stringify(self.scenarioContext.script), done, fail);
	  }

	  if (self.scenarioContext.name === undefined) {
	    fail('No scenario context created yet: use create_scenario <name>');
	    self.finish(miew);
	    return undefined;
	  }

	  if (arguments.length === 7) {
	    var _pdb = arguments[3];
	    var _preset = arguments[4];
	    var _delay = arguments[5];
	    var _desc = arguments[6];

	    if (lodash.isString(_pdb)) {
	      this.requestPdbID(miew, _pdb, doneFindPdb, fail);
	    } else if (lodash.isString(_preset)) {
	      this.requestPresetId(miew, _pdb + '/' + _preset, doneFindPreset, fail);
	    } else if (typeof _pdb === 'number' && typeof _preset === 'number') {
	      doAddItem(_pdb, _preset, _delay, _desc);
	    } else {
	      fail('Internal error');
	      self.finish(miew);
	      return undefined;
	    }
	  } else if (arguments.length === 5) {
	    //proceed with pdb and preset id's
	    error('not supported now');
	    self.finish(miew);
	    return undefined;
	  } else {
	    error('internal interpreter error');
	    self.finish(miew);
	    return undefined;
	  }
	  return undefined;
	};

	SRVProxy.prototype.init = function (miew, echo) {
	  var self = this;

	  if (!this.isOnApllyPresetEventInitialized) {
	    miew.addEventListener('presetApplyFinished', function () {
	      self.finish(miew);
	      if (echo !== undefined) {
	        echo('Preset applied');
	      }
	    });
	    this.isOnApllyPresetEventInitialized = true;
	  }
	};

	SRVProxy.prototype.finish = function (miew) {
	  miew.finishAwaitingCMDInProcess();
	};

	//repIndexOrRepMap could be RepresentationMap or index
	SRVProxy.prototype.fileList = function (miew, echo, error, fileId, idStarts) {
	  var self = this;

	  this.init(miew, echo);

	  function done(list) {
	    if (list !== undefined) {
	      for (var i = 0; i < list.length; i++) {
	        if (idStarts === undefined || list[i].name.toLowerCase().startsWith(idStarts.toLowerCase())) {
	          echo(list[i].name + ', id= ' + list[i].id);
	        }
	      }
	    }
	    self.finish(miew);
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      echo(message + '\n');
	    }
	    self.finish(miew);
	  }

	  miew.awaitWhileCMDisInProcess();

	  if (fileId === undefined || fileId === '') {
	    miew.srvTopologyAll(done, fail);
	  } else {
	    miew.srvPresetList(fileId, done, fail);
	  }
	};

	SRVProxy.prototype.callSrvFunc = function (miew, echo, error, func) {
	  var self = this;

	  this.init(miew, echo);

	  function done(message) {
	    if (message !== undefined) {
	      echo(message);
	    }
	    self.finish(miew);
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      error(message);
	    }
	    self.finish(miew);
	  }

	  miew.awaitWhileCMDisInProcess();
	  func = miew[func];
	  if (func !== undefined) {
	    switch (arguments.length) {
	      case 4:
	        func.call(miew, done, fail);
	        break;
	      case 5:
	        func.call(miew, arguments[4], done, fail);
	        break;
	      case 6:
	        func.call(miew, arguments[4], arguments[5], done, fail);
	        break;
	      case 7:
	        func.call(miew, arguments[4], arguments[5], arguments[6], done, fail);
	        break;
	      default:
	        this.finish(miew);
	    }
	  } else {
	    this.finish(miew);
	  }
	};

	SRVProxy.prototype.coroutineWithPresetPath = function (miew, echo, error, path, callBack, arg) {
	  var self = this;

	  this.init(miew, echo);

	  miew.awaitWhileCMDisInProcess();
	  var pathParts = path.split('/');

	  function done(message) {
	    if (message !== undefined) {
	      echo(message);
	    }
	    self.finish(miew);
	  }

	  function donePresetList(presetList) {
	    if (presetList instanceof Array) {
	      var availableItems = lodash.filter(presetList, function (item) {
	        return item.name.toLowerCase() === pathParts[1].toLowerCase() || item.id === Number(pathParts[1]);
	      });

	      if (availableItems.length < 1) {
	        error('Preset not found');
	        self.finish(miew);
	      } else if (availableItems.length > 1) {
	        error('There are two or more presets, please specify one by preset_id');
	        self.finish(miew);
	      } else if (arg === undefined) {
	        callBack.call(miew, availableItems[0].id, done, fail);
	      } else {
	        callBack.call(miew, availableItems[0].id, arg, done, fail);
	      }
	    } else {
	      self.finish(miew);
	    }
	  }

	  function doneFindTopology(topologyList) {
	    if (topologyList instanceof Array) {
	      if (topologyList.length < 1) {
	        error('File not found');
	        self.finish(miew);
	      } else if (topologyList.length > 1) {
	        error('There are two or more files, please specify one by file_id');
	        self.finish(miew);
	      } else {
	        miew.srvPresetList(topologyList[0].id, donePresetList, fail);
	      }
	    } else {
	      self.finish(miew);
	    }
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      error(message);
	    }
	    self.finish(miew);
	  }

	  if (pathParts.length !== 2) {
	    error('Path can has 2 levels only (pdb/preset)');
	    self.finish(miew);
	  } else {
	    miew.srvTopologyFind(pathParts[0], doneFindTopology, fail);
	  }
	};

	SRVProxy.prototype.coroutineWithFileName = function (miew, echo, error, name, callBack) {
	  var self = this;
	  var selfArguments = arguments;

	  this.init(miew);

	  miew.awaitWhileCMDisInProcess();
	  var pathParts = name.split('/');

	  function done(message) {
	    if (message !== undefined) {
	      echo(message);
	    }
	    self.finish(miew);
	  }

	  function doneFindTopology(topologyList) {
	    if (topologyList instanceof Array) {
	      if (topologyList.length < 1) {
	        error('File not found');
	      } else if (topologyList.length > 1) {
	        error('There are two or more files, please specify one by file_id');
	      } else {
	        switch (selfArguments.length) {
	          case 5:
	            callBack.call(miew, topologyList[0].id, done, fail);
	            break;
	          case 6:
	            callBack.call(miew, topologyList[0].id, selfArguments[5], done, fail);
	            break;
	          case 9:
	            callBack.call(selfArguments[5], selfArguments[6], selfArguments[7], selfArguments[8], topologyList[0].id);
	            break;
	          case 10:
	            callBack.call(selfArguments[5], selfArguments[6], selfArguments[7], selfArguments[8], topologyList[0].id, selfArguments[9]);
	            break;
	          default:
	            self.finish(miew);
	        }
	      }
	    }

	    self.finish(miew);
	  }

	  function fail(message) {
	    if (message !== undefined) {
	      error(message);
	    }
	    self.finish(miew);
	  }

	  if (pathParts.length !== 1) {
	    error('Path can contain only file name or id');
	    self.finish(miew);
	  } else {
	    miew.srvTopologyFind(pathParts[0], doneFindTopology, fail);
	  }
	};

	var srvFunctions = new SRVProxy();

	function CreateObjectPair(a, b) {
	  var obj = {};
	  obj[a] = b;
	  return obj;
	}

	function keyRemap(key) {
	  var keys = {
	    s: 'selector',
	    m: 'mode',
	    c: 'colorer',
	    mt: 'material',
	    mode: 'modes',
	    color: 'colorers',
	    colorer: 'colorers',
	    select: 'selector',
	    material: 'materials',
	    selector: 'selector'
	  };
	  var ans = keys[key];
	  return ans === undefined ? key : ans;
	}

	function ArgList(arg) {
	  if (arg instanceof this.constructor) {
	    return arg;
	  } else if (arg instanceof Array) {
	    this._values = arg.slice(0);
	  } else if (arg) {
	    this._values = [arg];
	  } else {
	    this._values = [];
	  }
	}

	ArgList.prototype.append = function (value) {
	  var values = this._values;
	  values[values.length] = value;
	  return this;
	};

	ArgList.prototype.remove = function (value) {
	  var values = this._values;
	  var index = values.indexOf(value);
	  if (index >= 0) {
	    values.splice(index, 1);
	  }
	  return this;
	};

	ArgList.prototype.toJSO = function (cliUtils, cmd, arg) {
	  var res = {};

	  var list = this._values;
	  for (var i = 0, n = list.length; i < n; ++i) {
	    lodash.set(res, list[i].id, cliUtils.propagateProp(keyRemap(cmd) + '.' + arg + '.' + list[i].id, list[i].val));
	  }

	  return res;
	};

	function Arg(_id, _val) {
	  this.id = _id;
	  this.val = _val;
	}

	var cliutils = Object.create({});

	cliutils.Arg = Arg;
	cliutils.ArgList = ArgList;

	cliutils.miew = null;
	cliutils.echo = null;
	cliutils.representations = representationsStorage;
	cliutils.utils = utilFunctions;
	cliutils.srv = srvFunctions;

	cliutils._ = lodash;
	cliutils.CreateObjectPair = CreateObjectPair;
	cliutils.keyRemap = keyRemap;
	cliutils.Context = selectors$4.Context;
	cliutils.ClearContext = selectors$4.ClearContext;

	cliutils.NULL = NULL;

	cliutils.notimplemented = function () {
	  return this.NULL;
	};

	Miew.prototype.script = function (script, _printCallback, _errorCallback) {
	  MiewCLIParser_1.yy.miew = this;
	  MiewCLIParser_1.yy.echo = _printCallback;
	  MiewCLIParser_1.yy.error = _errorCallback;
	  if (this.cmdQueue === undefined) {
	    this.cmdQueue = [];
	  }

	  if (this.commandInAction === undefined) {
	    this.commandInAction = false;
	  }

	  this.cmdQueue = this.cmdQueue.concat(script.split('\n'));
	};

	Miew.prototype.awaitWhileCMDisInProcess = function () {
	  this.commandInAction = true;
	};

	Miew.prototype.finishAwaitingCMDInProcess = function () {
	  this.commandInAction = false;
	};

	Miew.prototype.isScriptingCommandAvailable = function () {
	  return this.commandInAction !== undefined && !this.commandInAction && this.cmdQueue !== undefined && this.cmdQueue.length > 0;
	};

	Miew.prototype.callNextCmd = function () {
	  if (this.isScriptingCommandAvailable()) {
	    var cmd = this.cmdQueue.shift();

	    var res = {};
	    res.success = false;
	    try {
	      MiewCLIParser_1.parse(cmd);
	      res.success = true;
	    } catch (e) {
	      res.error = e.message;
	      MiewCLIParser_1.yy.error(res.error);
	      this.finishAwaitingCMDInProcess();
	    }
	    return res;
	  }
	  return '';
	};

	Miew.JSONConverter = JSONtoSelectorConverter;

	MiewCLIParser_1.yy = cliutils;
	// FIXME: workaround for incorrect JISON parser generator for AMD module
	MiewCLIParser_1.yy.parseError = MiewCLIParser_1.parseError;

	return Miew;

})));
//# sourceMappingURL=Miew.js.map
