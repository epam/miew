/** Miew - 3D Molecular Viewer v0.9.0+20211216.160330.c86743d-mod Copyright (c) 2015-2021 EPAM Systems, Inc. */

;(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? (module.exports = factory(require('lodash'), require('three')))
    : typeof define === 'function' && define.amd
    ? define(['lodash', 'three'], factory)
    : ((global =
        typeof globalThis !== 'undefined' ? globalThis : global || self),
      (global.Miew = factory(global._, global.THREE)))
})(this, function (_, THREE) {
  'use strict'

  function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : { default: e }
  }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e
    var n = Object.create(null)
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k)
          Object.defineProperty(
            n,
            k,
            d.get
              ? d
              : {
                  enumerable: true,
                  get: function () {
                    return e[k]
                  }
                }
          )
        }
      })
    }
    n['default'] = e
    return Object.freeze(n)
  }

  var ___default = /*#__PURE__*/ _interopDefaultLegacy(_)
  var THREE__namespace = /*#__PURE__*/ _interopNamespace(THREE)

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr
  }

  function _iterableToArrayLimit(arr, i) {
    var _i =
      arr == null
        ? null
        : (typeof Symbol !== 'undefined' && arr[Symbol.iterator]) ||
          arr['@@iterator']

    if (_i == null) return
    var _arr = []
    var _n = true
    var _d = false

    var _s, _e

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value)

        if (i && _arr.length === i) break
      }
    } catch (err) {
      _d = true
      _e = err
    } finally {
      try {
        if (!_n && _i['return'] != null) _i['return']()
      } finally {
        if (_d) throw _e
      }
    }

    return _arr
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i]
    }

    return arr2
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return
    if (typeof o === 'string') return _arrayLikeToArray$1(o, minLen)
    var n = Object.prototype.toString.call(o).slice(8, -1)
    if (n === 'Object' && o.constructor) n = o.constructor.name
    if (n === 'Map' || n === 'Set') return Array.from(o)
    if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray$1(o, minLen)
  }

  function _nonIterableRest() {
    throw new TypeError(
      'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }

  function _slicedToArray(arr, i) {
    return (
      _arrayWithHoles(arr) ||
      _iterableToArrayLimit(arr, i) ||
      _unsupportedIterableToArray$1(arr, i) ||
      _nonIterableRest()
    )
  }

  var __assign =
    (undefined && undefined.__assign) ||
    function () {
      __assign =
        Object.assign ||
        function (t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i]
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p]
          }
          return t
        }
      return __assign.apply(this, arguments)
    }
  var defaults$1 = {
    lines: 12,
    length: 7,
    width: 5,
    radius: 10,
    scale: 1.0,
    corners: 1,
    color: '#000',
    fadeColor: 'transparent',
    animation: 'spinner-line-fade-default',
    rotate: 0,
    direction: 1,
    speed: 1,
    zIndex: 2e9,
    className: 'spinner',
    top: '50%',
    left: '50%',
    shadow: '0 0 1px transparent',
    position: 'absolute'
  }
  var Spinner = /** @class */ (function () {
    function Spinner(opts) {
      if (opts === void 0) {
        opts = {}
      }
      this.opts = __assign(__assign({}, defaults$1), opts)
    }
    /**
     * Adds the spinner to the given target element. If this instance is already
     * spinning, it is automatically removed from its previous target by calling
     * stop() internally.
     */
    Spinner.prototype.spin = function (target) {
      this.stop()
      this.el = document.createElement('div')
      this.el.className = this.opts.className
      this.el.setAttribute('role', 'progressbar')
      css(this.el, {
        position: this.opts.position,
        width: 0,
        zIndex: this.opts.zIndex,
        left: this.opts.left,
        top: this.opts.top,
        transform: 'scale(' + this.opts.scale + ')'
      })
      if (target) {
        target.insertBefore(this.el, target.firstChild || null)
      }
      drawLines(this.el, this.opts)
      return this
    }
    /**
     * Stops and removes the Spinner.
     * Stopped spinners may be reused by calling spin() again.
     */
    Spinner.prototype.stop = function () {
      if (this.el) {
        if (typeof requestAnimationFrame !== 'undefined') {
          cancelAnimationFrame(this.animateId)
        } else {
          clearTimeout(this.animateId)
        }
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el)
        }
        this.el = undefined
      }
      return this
    }
    return Spinner
  })()
  /**
   * Sets multiple style properties at once.
   */
  function css(el, props) {
    for (var prop in props) {
      el.style[prop] = props[prop]
    }
    return el
  }
  /**
   * Returns the line color from the given string or array.
   */
  function getColor(color, idx) {
    return typeof color == 'string' ? color : color[idx % color.length]
  }
  /**
   * Internal method that draws the individual lines.
   */
  function drawLines(el, opts) {
    var borderRadius = Math.round(opts.corners * opts.width * 500) / 1000 + 'px'
    var shadow = 'none'
    if (opts.shadow === true) {
      shadow = '0 2px 4px #000' // default shadow
    } else if (typeof opts.shadow === 'string') {
      shadow = opts.shadow
    }
    var shadows = parseBoxShadow(shadow)
    for (var i = 0; i < opts.lines; i++) {
      var degrees = ~~((360 / opts.lines) * i + opts.rotate)
      var backgroundLine = css(document.createElement('div'), {
        position: 'absolute',
        top: -opts.width / 2 + 'px',
        width: opts.length + opts.width + 'px',
        height: opts.width + 'px',
        background: getColor(opts.fadeColor, i),
        borderRadius: borderRadius,
        transformOrigin: 'left',
        transform:
          'rotate(' + degrees + 'deg) translateX(' + opts.radius + 'px)'
      })
      var delay = (i * opts.direction) / opts.lines / opts.speed
      delay -= 1 / opts.speed // so initial animation state will include trail
      var line = css(document.createElement('div'), {
        width: '100%',
        height: '100%',
        background: getColor(opts.color, i),
        borderRadius: borderRadius,
        boxShadow: normalizeShadow(shadows, degrees),
        animation:
          1 / opts.speed + 's linear ' + delay + 's infinite ' + opts.animation
      })
      backgroundLine.appendChild(line)
      el.appendChild(backgroundLine)
    }
  }
  function parseBoxShadow(boxShadow) {
    var regex =
      /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/
    var shadows = []
    for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
      var shadow = _a[_i]
      var matches = shadow.match(regex)
      if (matches === null) {
        continue // invalid syntax
      }
      var x = +matches[2]
      var y = +matches[5]
      var xUnits = matches[4]
      var yUnits = matches[7]
      if (x === 0 && !xUnits) {
        xUnits = yUnits
      }
      if (y === 0 && !yUnits) {
        yUnits = xUnits
      }
      if (xUnits !== yUnits) {
        continue // units must match to use as coordinates
      }
      shadows.push({
        prefix: matches[1] || '',
        x: x,
        y: y,
        xUnits: xUnits,
        yUnits: yUnits,
        end: matches[8]
      })
    }
    return shadows
  }
  /**
   * Modify box-shadow x/y offsets to counteract rotation
   */
  function normalizeShadow(shadows, degrees) {
    var normalized = []
    for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
      var shadow = shadows_1[_i]
      var xy = convertOffset(shadow.x, shadow.y, degrees)
      normalized.push(
        shadow.prefix +
          xy[0] +
          shadow.xUnits +
          ' ' +
          xy[1] +
          shadow.yUnits +
          shadow.end
      )
    }
    return normalized.join(', ')
  }
  function convertOffset(x, y, degrees) {
    var radians = (degrees * Math.PI) / 180
    var sin = Math.sin(radians)
    var cos = Math.cos(radians)
    return [
      Math.round((x * cos + y * sin) * 1000) / 1000,
      Math.round((-x * sin + y * cos) * 1000) / 1000
    ]
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function')
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i]
      descriptor.enumerable = descriptor.enumerable || false
      descriptor.configurable = true
      if ('value' in descriptor) descriptor.writable = true
      Object.defineProperty(target, descriptor.key, descriptor)
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps)
    if (staticProps) _defineProperties(Constructor, staticProps)
    Object.defineProperty(Constructor, 'prototype', {
      writable: false
    })
    return Constructor
  }

  var Timer = /*#__PURE__*/ (function () {
    function Timer() {
      _classCallCheck(this, Timer)

      this.startTime = 0
      this.oldTime = 0
      this.elapsedTime = 0
      this.running = false
    }

    _createClass(Timer, [
      {
        key: 'start',
        value: function start() {
          this.startTime = Timer.now()
          this.oldTime = this.startTime
          this.running = true
        }
      },
      {
        key: 'stop',
        value: function stop() {
          this.getElapsedTime()
          this.running = false
        }
      },
      {
        key: 'getElapsedTime',
        value: function getElapsedTime() {
          this.update()
          return this.elapsedTime
        }
      },
      {
        key: 'update',
        value: function update() {
          var delta = 0

          if (this.running) {
            var newTime = Timer.now()
            delta = 0.001 * (newTime - this.oldTime)
            this.oldTime = newTime
            this.elapsedTime += delta
          }

          return delta
        }
      }
    ])

    return Timer
  })()

  Timer.now = (function () {
    var p = typeof window !== 'undefined' && window.performance
    return p && p.now ? p.now.bind(p) : Date.now
  })()

  var now = Timer.now

  function createElement$2(tag, id, css) {
    var element = document.createElement(tag)
    element.id = id
    element.style.cssText = css
    return element
  }

  var Stats = /*#__PURE__*/ (function () {
    function Stats() {
      _classCallCheck(this, Stats)

      this.domElement = createElement$2('div', 'stats', 'padding:8px')
      this._text = createElement$2(
        'p',
        'fps',
        'margin:0;color:silver;font-size:large'
      )
      this.domElement.appendChild(this._text)
      this._startTime = now()
      this._prevTime = this._startTime
      this._deltas = new Array(20)
      this._index = 0
      this._total = 0.0
      this._count = 0
    }

    _createClass(Stats, [
      {
        key: 'end',
        value: function end() {
          var time = now()
          var delta = time - this._startTime

          if (this._count < this._deltas.length) {
            this._count++
          } else {
            this._total -= this._deltas[this._index]
          }

          this._total += delta
          this._deltas[this._index] = delta
          this._index = (this._index + 1) % this._deltas.length
          this.ms = this._total / this._count
          this.fps = 1000 / this.ms

          if (time > this._prevTime + 1000) {
            this._text.textContent = this.fps.toPrecision(2)
            this._prevTime = time
          }

          return time
        }
      },
      {
        key: 'update',
        value: function update() {
          this._startTime = this.end()
        }
      },
      {
        key: 'show',
        value: function show(on) {
          if (on === undefined) {
            on = true
          }

          this.domElement.style.display = on ? 'block' : 'none'
        }
      }
    ])

    return Stats
  })()

  function _setPrototypeOf(o, p) {
    _setPrototypeOf =
      Object.setPrototypeOf ||
      function _setPrototypeOf(o, p) {
        o.__proto__ = p
        return o
      }

    return _setPrototypeOf(o, p)
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function')
    }

    Object.defineProperty(subClass, 'prototype', {
      value: Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      }),
      writable: false
    })
    if (superClass) _setPrototypeOf(subClass, superClass)
  }

  function _typeof(obj) {
    '@babel/helpers - typeof'

    return (
      (_typeof =
        'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
          ? function (obj) {
              return typeof obj
            }
          : function (obj) {
              return obj &&
                'function' == typeof Symbol &&
                obj.constructor === Symbol &&
                obj !== Symbol.prototype
                ? 'symbol'
                : typeof obj
            }),
      _typeof(obj)
    )
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      )
    }

    return self
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === 'object' || typeof call === 'function')) {
      return call
    } else if (call !== void 0) {
      throw new TypeError(
        'Derived constructors may only return object or undefined'
      )
    }

    return _assertThisInitialized(self)
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o)
        }
    return _getPrototypeOf(o)
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf('[native code]') !== -1
  }

  function _isNativeReflectConstruct$22() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true

    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$22()) {
      _construct = Reflect.construct
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null]
        a.push.apply(a, args)
        var Constructor = Function.bind.apply(Parent, a)
        var instance = new Constructor()
        if (Class) _setPrototypeOf(instance, Class.prototype)
        return instance
      }
    }

    return _construct.apply(null, arguments)
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === 'function' ? new Map() : undefined

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class

      if (typeof Class !== 'function') {
        throw new TypeError(
          'Super expression must either be null or a function'
        )
      }

      if (typeof _cache !== 'undefined') {
        if (_cache.has(Class)) return _cache.get(Class)

        _cache.set(Class, Wrapper)
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor)
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
      return _setPrototypeOf(Wrapper, Class)
    }

    return _wrapNativeSuper(Class)
  }

  function isUndefOrEqual(param, value) {
    return !param || param === value
  }

  function EventDispatcher() {
    this._handlers = {}
  }

  EventDispatcher.prototype.addEventListener = function (
    type,
    callback,
    context
  ) {
    var handlers = this._handlers[type]

    if (!handlers) {
      this._handlers[type] = []
      handlers = this._handlers[type]
    }

    var params = [callback, context]

    function _checkPar(par) {
      return par[0] === params[0] && par[1] === params[1]
    }

    if (___default['default'].find(handlers, _checkPar) === undefined) {
      handlers.push(params)
    }
  }

  EventDispatcher.prototype.removeEventListener = function (
    type,
    callback,
    context
  ) {
    var self = this

    ___default['default'].forEach(self._handlers, function (handler, ev) {
      ___default['default'].remove(handler, function (values) {
        return (
          isUndefOrEqual(type, ev) &&
          isUndefOrEqual(callback, values[0]) &&
          isUndefOrEqual(context, values[1] || self)
        )
      })
    })

    this._handlers = ___default['default'].omitBy(
      self._handlers,
      function (handler) {
        return handler.length === 0
      }
    )
  }

  EventDispatcher.prototype.dispatchEvent = function (event) {
    var self = this

    ___default['default'].forEach(
      this._handlers[event.type],
      function (callback) {
        var context = callback[1] || self
        callback[0].apply(context, [event])
      }
    )
  }

  var priorities = {
    debug: 0,
    info: 1,
    report: 2,
    warn: 3,
    error: 4
  }

  function Logger() {
    EventDispatcher.call(this)
    this.console = false
    this._priority = priorities.warn
  }

  Logger.prototype = Object.create(EventDispatcher.prototype)
  Logger.prototype.constructor = Logger

  Logger.prototype.instantiate = function () {
    return new Logger()
  }

  function verify(number) {
    if (!___default['default'].isNumber(number)) {
      throw new Error('Wrong log level specified!')
    }

    return number
  }

  Object.defineProperty(Logger.prototype, 'level', {
    get: function get() {
      var _this = this

      return ___default['default'].findKey(priorities, function (value) {
        return value === _this._priority
      })
    },
    set: function set(level) {
      this._priority = verify(priorities[level])
    }
  })

  Logger.prototype.levels = function () {
    return Object.keys(priorities)
  }

  Logger.prototype.message = function (level, message) {
    var priority = verify(priorities[level])

    this._message(priority, message)
  }

  Logger.prototype.debug = function (message) {
    this._message(priorities.debug, message)
  }

  Logger.prototype.info = function (message) {
    this._message(priorities.info, message)
  }

  Logger.prototype.report = function (message) {
    this._message(priorities.report, message)
  }

  Logger.prototype.warn = function (message) {
    this._message(priorities.warn, message)
  }

  Logger.prototype.error = function (message) {
    this._message(priorities.error, message)
  }

  Logger.prototype._message = function (priority, message) {
    if (priority < this._priority) {
      return
    }

    var level = ___default['default'].findKey(priorities, function (value) {
      return value === priority
    })

    message = String(message)

    if (this.console) {
      var output = 'miew:'.concat(level, ': ').concat(message)

      if (level === 'error') {
        console.error(output)
      } else if (level === 'warn') {
        console.warn(output)
      } else {
        console.log(output)
      }
    }

    this.dispatchEvent({
      type: 'message',
      level: level,
      message: message
    })
  }

  var logger = new Logger()

  function _createSuper$21(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$21()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$21() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var browserType = {
    DEFAULT: 0,
    SAFARI: 1
  }

  function encodeQueryComponent(text, excludeExp) {
    var encode = function encode(code) {
      return String.fromCharCode(parseInt(code.substr(1), 16))
    }

    return encodeURIComponent(text)
      .replace(excludeExp, encode)
      .replace(/%20/g, '+')
  }

  function decodeQueryComponent(text) {
    return decodeURIComponent(text.replace(/\+/g, ' '))
  }

  function getUrlParameters(url) {
    url = url || window.location.search
    var query = url.substring(url.indexOf('?') + 1)
    var search = /([^&=]+)=?([^&]*)/g
    var result = []
    var match

    while ((match = search.exec(query)) !== null) {
      result.push([
        decodeQueryComponent(match[1]),
        decodeQueryComponent(match[2])
      ])
    }

    return result
  }

  function getUrlParametersAsDict(url) {
    var result = {}
    var a = getUrlParameters(url)

    for (var i = 0; i < a.length; ++i) {
      var _a$i = _slicedToArray(a[i], 2),
        key = _a$i[0],
        value = _a$i[1]

      result[key] = value
    }

    return result
  }

  function resolveURL(str) {
    if (typeof URL !== 'undefined') {
      try {
        if (typeof window !== 'undefined') {
          return new URL(str, window.location).href
        }

        return new URL(str).href
      } catch (error) {}
    }

    if (typeof document !== 'undefined') {
      var anchor = document.createElement('a')
      anchor.href = str
      return anchor.href
    }

    return str
  }

  function generateRegExp(symbolStr) {
    var symbolList = []

    for (var i = 0, n = symbolStr.length; i < n; ++i) {
      symbolList[symbolList.length] = symbolStr[i].charCodeAt(0).toString(16)
    }

    var listStr = symbolList.join('|')
    return new RegExp('%(?:'.concat(listStr, ')'), 'gi')
  }

  function createElement$1(tag, attrs, content) {
    var element = document.createElement(tag)
    var i
    var n

    if (attrs) {
      var keys = Object.keys(attrs)

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i]
        element.setAttribute(key, attrs[key])
      }
    }

    if (content) {
      if (!(content instanceof Array)) {
        content = [content]
      }

      for (i = 0, n = content.length; i < n; ++i) {
        var child = content[i]

        if (typeof child === 'string') {
          element.appendChild(document.createTextNode(child))
        } else if (child instanceof HTMLElement) {
          element.appendChild(child)
        }
      }
    }

    return element
  }

  function deriveClass(cls, base, members, statics) {
    cls.prototype = ___default['default'].assign(
      Object.create(base.prototype),
      {
        constructor: cls
      },
      members
    )

    if (statics) {
      ___default['default'].assign(cls, statics)
    }

    return cls
  }

  function deriveDeep(obj, needZeroOwnProperties) {
    var res = obj
    var i
    var n

    if (obj instanceof Array) {
      res = new Array(obj.length)

      for (i = 0, n = obj.length; i < n; ++i) {
        res[i] = deriveDeep(obj[i])
      }
    } else if (obj instanceof Object) {
      res = Object.create(obj)
      var keys = Object.keys(obj)

      for (i = 0, n = keys.length; i < n; ++i) {
        var key = keys[i]
        var value = obj[key]
        var copy = deriveDeep(value)

        if (copy !== value) {
          res[key] = copy
        }
      }

      if (needZeroOwnProperties && Object.keys(res).length > 0) {
        res = Object.create(res)
      }
    }

    return res
  }

  function hexColor(color) {
    var hex = '0000000'.concat(color.toString(16)).substr(-6)
    return '#'.concat(hex)
  }

  function DebugTracer(namespace) {
    var enabled = false

    this.enable = function (on) {
      enabled = on
    }

    var indent = 0
    var methods = Object.keys(namespace)

    function wrap(method_, name_) {
      return function () {
        var spaces = DebugTracer.spaces.substr(0, indent * 2)

        if (enabled) {
          logger.debug(''.concat(spaces + name_, ' {'))
        }

        indent++

        for (
          var _len = arguments.length, args = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          args[_key] = arguments[_key]
        }

        var result = method_.apply(this, args)
        indent--

        if (enabled) {
          logger.debug(''.concat(spaces, '} // ').concat(name_))
        }

        return result
      }
    }

    for (var i = 0, n = methods.length; i < n; ++i) {
      var name = methods[i]
      var method = namespace[name]

      if (method instanceof Function && name !== 'constructor') {
        namespace[name] = wrap(method, name)
      }
    }
  }

  DebugTracer.spaces =
    '                                                                                          '

  var OutOfMemoryError = /*#__PURE__*/ (function (_Error) {
    _inherits(OutOfMemoryError, _Error)

    var _super = _createSuper$21(OutOfMemoryError)

    function OutOfMemoryError(message) {
      var _this

      _classCallCheck(this, OutOfMemoryError)

      _this = _super.call(this)
      _this.name = 'OutOfMemoryError'
      _this.message = message
      return _this
    }

    return _createClass(OutOfMemoryError)
  })(/*#__PURE__*/ _wrapNativeSuper(Error))

  function allocateTyped(TypedArrayName, size) {
    var result = null

    try {
      result = new TypedArrayName(size)
    } catch (e) {
      if (e instanceof RangeError) {
        throw new OutOfMemoryError(e.message)
      } else {
        throw e
      }
    }

    return result
  }

  function bytesToBase64(buffer) {
    var bytes = new Uint8Array(buffer)
    var binary = ''

    for (var i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i])
    }

    return window.btoa(binary)
  }

  function bytesFromBase64(str) {
    var binary = window.atob(str)
    var bytes = new Uint8Array(binary.length)

    for (var i = 0; i < bytes.length; ++i) {
      bytes[i] = binary[i].charCodeAt(0)
    }

    return bytes.buffer
  }

  function arrayToBase64(array, TypedArrayClass) {
    return bytesToBase64(new TypedArrayClass(array).buffer)
  }

  function arrayFromBase64(str, TypedArrayClass) {
    return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)))
  }

  function compareOptionsWithDefaults(opts, defOpts) {
    var optsStr = []

    if (defOpts && opts) {
      var keys = Object.keys(opts)

      for (var p = 0; p < keys.length; ++p) {
        var key = keys[p]
        var value = opts[key]

        if (
          !(value instanceof Object) &&
          typeof defOpts[key] !== 'undefined' &&
          defOpts[key] !== value
        ) {
          optsStr.push(''.concat(key, ':').concat(value))
        }
      }

      if (optsStr.length > 0) {
        return '!'.concat(optsStr.join())
      }
    }

    return ''
  }

  function isAlmostPlainObject(o) {
    if (___default['default'].isPlainObject(o)) {
      return true
    }

    var proto = o && Object.getPrototypeOf(o)
    return (
      !!proto &&
      !proto.hasOwnProperty('constructor') &&
      isAlmostPlainObject(proto)
    )
  }

  function objectsDiff(src, dst) {
    var diff = {}

    ___default['default'].forIn(src, function (srcValue, key) {
      var dstValue = dst[key]

      if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
        var deepDiff = objectsDiff(srcValue, dstValue)

        if (!___default['default'].isEmpty(deepDiff)) {
          diff[key] = deepDiff
        }
      } else if (!___default['default'].isEqual(srcValue, dstValue)) {
        diff[key] = srcValue
      }
    })

    return diff
  }

  function forInRecursive(object, callback) {
    function iterateThrough(obj, prefix) {
      ___default['default'].forIn(obj, function (value, key) {
        var newPref = prefix + (prefix.length > 0 ? '.' : '')

        if (value instanceof Object) {
          iterateThrough(value, newPref + key)
        } else if (value !== undefined) {
          callback(value, newPref + key)
        }
      })
    }

    iterateThrough(object, '')
  }

  function enquoteString(value) {
    if (___default['default'].isString(value)) {
      return '"'.concat(value.replace(/"/g, '\\"'), '"')
    }

    return value
  }

  function unquoteString(value) {
    if (!___default['default'].isString(value)) {
      return value
    }

    if (value[0] === '"' && value[value.length - 1] === '"') {
      value = value.slice(1, value.length - 1)
      return value.replace(/\\"/g, '"')
    }

    if (value[0] === "'" && value[value.length - 1] === "'") {
      value = value.slice(1, value.length - 1)
      return value.replace(/\\'/g, "'")
    }

    throw new SyntaxError("Incorrect string format, can't unqute it")
  }

  function getFileExtension(fileName) {
    return fileName.slice(Math.max(0, fileName.lastIndexOf('.')) || Infinity)
  }

  function splitFileName(fileName) {
    var ext = getFileExtension(fileName)
    var name = fileName.slice(0, fileName.length - ext.length)
    return [name, ext]
  }

  function dataUrlToBlob(url) {
    var parts = url.split(/[:;,]/)
    var partsCount = parts.length

    if (partsCount >= 3 && parts[partsCount - 2] === 'base64') {
      return new Blob([bytesFromBase64(parts[partsCount - 1])])
    }

    return null
  }

  function getBrowser() {
    if (
      navigator.vendor &&
      navigator.vendor.indexOf('Apple') > -1 &&
      navigator.userAgent &&
      navigator.userAgent.indexOf('CriOS') === -1 &&
      navigator.userAgent.indexOf('FxiOS') === -1
    ) {
      return browserType.SAFARI
    }

    return browserType.DEFAULT
  }

  function shotOpen(url) {
    if (typeof window !== 'undefined') {
      window
        .open()
        .document.write(
          '<body style="margin:0"><img src="'.concat(url, '" /></body>')
        )
    }
  }

  function shotDownload(dataUrl, filename) {
    if (!dataUrl || dataUrl.substr(0, 5) !== 'data:') {
      return
    }

    if (!filename) {
      filename = ['screenshot-', +new Date(), '.png'].join('')
    }

    if (
      typeof window !== 'undefined' &&
      window.navigator &&
      window.navigator.msSaveBlob
    ) {
      window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename)
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a')
      link.download = filename
      link.innerHTML = 'download'
      link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl))
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }
  }

  function download(data, filename, type) {
    var blobData = new Blob([data])

    if (!filename) {
      filename = ['data', +new Date()].join('')
    }

    if (!type) {
      filename += blobData.type || '.bin'
    } else {
      filename += '.'.concat(type)
    }

    if (
      typeof window !== 'undefined' &&
      window.navigator &&
      window.navigator.msSaveBlob
    ) {
      window.navigator.msSaveBlob(blobData, filename)
    } else if (typeof document !== 'undefined') {
      var link = document.createElement('a')
      link.download = filename
      link.innerHTML = 'download'
      link.href = window.URL.createObjectURL(blobData)
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
    }
  }

  function copySubArrays$2(src, dst, indices, itemSize) {
    for (var i = 0, n = indices.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        dst[i * itemSize + j] = src[indices[i] * itemSize + j]
      }
    }
  }

  function shallowCloneNode(node) {
    var newNode = node.cloneNode(true)
    newNode.worldPos = node.worldPos
    return newNode
  }

  var unquotedStringRE = /^[a-zA-Z0-9_]*$/
  var enquoteHelper = ['"', '', '"']

  function correctSelectorIdentifier(value) {
    if (unquotedStringRE.test(value)) {
      return value
    }

    enquoteHelper[1] = value
    return enquoteHelper.join('')
  }

  function concatTypedArraysUnsafe(first, second) {
    var result = new first.constructor(first.length + second.length)
    result.set(first)
    result.set(second, first.length)
    return result
  }

  function mergeTypedArraysUnsafe(array) {
    if (array.length <= 0) {
      return null
    }

    var size = array.reduce(function (acc, cur) {
      return acc + cur.length
    }, 0)
    var result = new array[0].constructor(size)

    for (var i = 0, start = 0; i < array.length; i++) {
      var count = array[i].length
      result.set(array[i], start)
      start += count
    }

    return result
  }

  var utils = {
    browserType: browserType,
    encodeQueryComponent: encodeQueryComponent,
    decodeQueryComponent: decodeQueryComponent,
    getUrlParameters: getUrlParameters,
    getUrlParametersAsDict: getUrlParametersAsDict,
    resolveURL: resolveURL,
    generateRegExp: generateRegExp,
    createElement: createElement$1,
    deriveClass: deriveClass,
    deriveDeep: deriveDeep,
    hexColor: hexColor,
    DebugTracer: DebugTracer,
    OutOfMemoryError: OutOfMemoryError,
    allocateTyped: allocateTyped,
    bytesFromBase64: bytesFromBase64,
    bytesToBase64: bytesToBase64,
    arrayFromBase64: arrayFromBase64,
    arrayToBase64: arrayToBase64,
    compareOptionsWithDefaults: compareOptionsWithDefaults,
    objectsDiff: objectsDiff,
    forInRecursive: forInRecursive,
    enquoteString: enquoteString,
    unquoteString: unquoteString,
    getBrowser: getBrowser,
    shotOpen: shotOpen,
    shotDownload: shotDownload,
    copySubArrays: copySubArrays$2,
    shallowCloneNode: shallowCloneNode,
    correctSelectorIdentifier: correctSelectorIdentifier,
    getFileExtension: getFileExtension,
    splitFileName: splitFileName,
    download: download,
    concatTypedArraysUnsafe: concatTypedArraysUnsafe,
    mergeTypedArraysUnsafe: mergeTypedArraysUnsafe
  }

  function _createSuper$20(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$20()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$20() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var JobHandle = /*#__PURE__*/ (function (_EventDispatcher) {
    _inherits(JobHandle, _EventDispatcher)

    var _super = _createSuper$20(JobHandle)

    function JobHandle() {
      var _this

      _classCallCheck(this, JobHandle)

      _this = _super.call(this)
      _this._shouldCancel = false
      return _this
    }

    _createClass(JobHandle, [
      {
        key: 'cancel',
        value: function cancel() {
          this._shouldCancel = true
          this.dispatchEvent({
            type: 'cancel'
          })
        }
      },
      {
        key: 'shouldCancel',
        value: function shouldCancel() {
          return this._shouldCancel
        }
      },
      {
        key: 'notify',
        value: function notify(event) {
          this.dispatchEvent({
            type: 'notification',
            slaveEvent: event
          })
        }
      }
    ])

    return JobHandle
  })(EventDispatcher)

  var VERSION = 0
  var defaults = {
    modes: {
      BS: {
        atom: 0.23,
        bond: 0.15,
        space: 0.5,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      VW: {
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 8,
          high: 16,
          ultra: 32
        }
      },
      LN: {
        multibond: true,
        showarom: true,
        offsarom: 0.2,
        chunkarom: 10,
        atom: 0.23,
        lineWidth: 2
      },
      LC: {
        bond: 0.2,
        space: 0.0,
        multibond: true,
        aromrad: 0.1,
        showarom: true,
        polyComplexity: {
          poor: 3,
          low: 4,
          medium: 6,
          high: 12,
          ultra: 32
        }
      },
      SA: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      SE: {
        zClip: false,
        probeRadius: 1.5,
        subset: '',
        wireframe: false,
        polyComplexity: {
          poor: 6,
          low: 8,
          medium: 16,
          high: 30,
          ultra: 60
        }
      },
      QS: {
        isoValue: 0.5,
        gaussLim: {
          poor: 1.5,
          low: 2.0,
          medium: 2.5,
          high: 3.0,
          ultra: 4.0
        },
        scale: 1.0,
        wireframe: false,
        gridSpacing: {
          poor: 2,
          low: 1.5,
          medium: 1,
          high: 0.5,
          ultra: 0.25
        },
        subset: '',
        zClip: false
      },
      CS: {
        probeRadius: 1.4,
        isoValue: 1.5,
        wireframe: false,
        probePositions: 30,
        polyComplexity: {
          poor: 0.5,
          low: 1.0,
          medium: 1.5,
          high: 1.75,
          ultra: 2.0
        },
        subset: '',
        zClip: false
      },
      TR: {
        radius: 0.3,
        polyComplexity: {
          poor: 12,
          low: 16,
          medium: 32,
          high: 64,
          ultra: 64
        }
      },
      TU: {
        radius: 0.3,
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      CA: {
        radius: 0.3,
        depth: 0.25,
        ss: {
          helix: {
            width: 1.0,
            arrow: 2.0
          },
          strand: {
            width: 1.0,
            arrow: 2.0
          }
        },
        heightSegmentsRatio: 1.5,
        tension: -0.7,
        polyComplexity: {
          poor: 4,
          low: 6,
          medium: 10,
          high: 18,
          ultra: 34
        }
      },
      TX: {
        template: '{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}',
        horizontalAlign: 'center',
        verticalAlign: 'middle',
        dx: 0,
        dy: 0,
        dz: 1,
        fg: 'none',
        bg: '0x202020',
        showBg: true
      },
      VD: {
        kSigma: 1.0,
        kSigmaMed: 2.0,
        kSigmaMax: 4.0,
        frame: true,
        isoMode: false,
        polyComplexity: {
          poor: 2,
          low: 3,
          medium: 4,
          high: 8,
          ultra: 10
        }
      }
    },
    colorers: {
      EL: {
        carbon: -1
      },
      UN: {
        color: 0xffffff
      },
      CO: {
        subset: 'charged',
        color: 0xff0000,
        baseColor: 0xffffff
      },
      CB: {
        color: 0x909090,
        factor: 0.6
      },
      SQ: {
        gradient: 'rainbow'
      },
      TM: {
        gradient: 'temp',
        min: 5,
        max: 40
      },
      OC: {
        gradient: 'reds'
      },
      HY: {
        gradient: 'blue-red'
      },
      MO: {
        gradient: 'rainbow'
      }
    },
    antialias: true,
    camFov: 45.0,
    camNear: 0.5,
    camFar: 100.0,
    camDistance: 2.5,
    radiusToFit: 1.0,
    fogNearFactor: 0.5,
    fogFarFactor: 1,
    fogAlpha: 1.0,
    fogColor: 0x000000,
    fogColorEnable: false,
    palette: 'JM',
    resolution: 'medium',
    autoResolution: false,
    autoPreset: true,
    preset: 'default',
    presets: {
      default: [
        {
          mode: 'BS',
          colorer: 'EL',
          selector: 'all',
          material: 'SF'
        }
      ],
      empty: [],
      wire: [
        {
          mode: 'LN',
          colorer: 'EL',
          selector: 'all',
          material: 'SF'
        }
      ],
      small: [
        {
          mode: 'BS',
          colorer: 'EL',
          selector: 'all',
          material: 'SF'
        }
      ],
      macro: [
        {
          mode: 'CA',
          colorer: 'SS',
          selector: 'not hetatm',
          material: 'SF'
        },
        {
          mode: 'BS',
          colorer: 'EL',
          selector: 'hetatm and not water',
          material: 'SF'
        }
      ]
    },
    objects: {
      line: {
        color: 0xffffffff,
        dashSize: 0.3,
        gapSize: 0.05
      }
    },
    bg: {
      color: 0x202020,
      transparent: false
    },
    draft: {
      clipPlane: false,
      clipPlaneFactor: 0.5,
      clipPlaneSpeed: 0.00003
    },
    plugins: {},
    axes: true,
    fog: true,
    fps: true,
    zSprites: true,
    isoSurfaceFakeOpacity: true,
    suspendRender: true,
    nowater: false,
    autobuild: true,
    fxaa: true,
    outline: {
      on: false,
      color: 0x000000,
      threshold: 0.1,
      thickness: 1
    },
    ao: false,
    shadow: {
      on: false,
      type: 'random',
      radius: 1.0
    },
    autoRotation: 0.0,
    maxfps: 30,
    fbxprec: 4,
    autoRotationAxisFixed: true,
    zooming: true,
    picking: true,
    pick: 'atom',
    editing: false,
    aromatic: false,
    singleUnit: true,
    stereo: 'NONE',
    interpolateViews: true,
    transparency: 'prepass',
    translationSpeed: 2,
    debug: {
      example: 3.5,
      text: 'hello!',
      good: true,
      ssaoKernelRadius: 0.7,
      ssaoFactor: 0.7,
      stereoBarrel: 0.25
    },
    use: {
      multiFile: false
    }
  }

  function Settings() {
    EventDispatcher.call(this)
    this.old = null
    this.now = {}
    this._changed = {}
    this.reset()
  }

  utils.deriveClass(Settings, EventDispatcher, {
    defaults: defaults,
    set: function set(path, value) {
      if (___default['default'].isString(path)) {
        var oldValue = ___default['default'].get(this.now, path)

        if (oldValue !== value) {
          ___default['default'].set(this.now, path, value)

          this._notifyChange(path, value)
        }
      } else {
        var diff = utils.objectsDiff(path, this.now)

        if (!___default['default'].isEmpty(diff)) {
          ___default['default'].merge(this.now, diff)

          this._notifyChanges(diff)
        }
      }
    },
    get: function get(path, defaultValue) {
      return ___default['default'].get(this.now, path, defaultValue)
    },
    reset: function reset() {
      var diff = utils.objectsDiff(defaults, this.now)
      this.now = ___default['default'].cloneDeep(defaults)
      this.old = null

      this._notifyChanges(diff)

      this._changed = {}
    },
    checkpoint: function checkpoint() {
      this.old = ___default['default'].cloneDeep(this.now)
      this._changed = {}
    },
    _notifyChange: function _notifyChange(path, value) {
      this._changed[path] = true
      this.dispatchEvent({
        type: 'change:'.concat(path),
        value: value
      })
    },
    _notifyChanges: function _notifyChanges(diff) {
      var _this = this

      utils.forInRecursive(diff, function (deepValue, deepPath) {
        _this._notifyChange(deepPath, deepValue)
      })
    },
    changed: function changed() {
      if (!this.old) {
        return []
      }

      var old = this.old,
        now = this.now

      var keys = ___default['default'].filter(
        Object.keys(this._changed),
        function (key) {
          return (
            ___default['default'].get(old, key) !==
            ___default['default'].get(now, key)
          )
        }
      )

      return keys
    },
    applyDiffs: function applyDiffs(diffs) {
      if (diffs.hasOwnProperty('VERSION') && diffs.VERSION !== VERSION) {
        throw new Error('Settings version does not match!')
      }

      delete diffs.VERSION
      this.reset()
      this.set(diffs)
    },
    getDiffs: function getDiffs(versioned) {
      var diffs = utils.objectsDiff(this.now, defaults)

      if (versioned) {
        diffs.VERSION = VERSION
      }

      return diffs
    },
    setPluginOpts: function setPluginOpts(plugin, opts) {
      defaults.plugins[plugin] = ___default['default'].cloneDeep(opts)
      this.now.plugins[plugin] = ___default['default'].cloneDeep(opts)
    }
  })
  var settings$1 = new Settings()

  var repIndex = 0

  function asBoolean(value) {
    return !(
      !value ||
      value === '0' ||
      (___default['default'].isString(value) && value.toLowerCase() === 'false')
    )
  }

  var adapters = {
    string: String,
    number: Number,
    boolean: asBoolean
  }
  var cL1Ass = '='
  var cOptsSep = '!'
  var cL2Ass = ':'
  var cLSep = ','
  var cCommonIgnoreSymbols = '$;@/?'

  function getLevel1ExcludedExpr() {
    var cLevel1Ignores = ':,'
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores)
  }

  function getLevel2ExcludedExpr() {
    var cLevel2Ignores = ' '
    return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores)
  }

  var cL1ExclExpr = getLevel1ExcludedExpr()

  function encodeQueryComponentL1(value) {
    return utils.encodeQueryComponent(value, cL1ExclExpr)
  }

  var cL2ExclExpr = getLevel2ExcludedExpr()

  function encodeQueryComponentL2(value) {
    return utils.encodeQueryComponent(value, cL2ExclExpr)
  }

  function ensureRepList(opts) {
    var reps = opts.reps

    if (!reps) {
      var presets = settings$1.now.presets
      var preset = opts.preset || settings$1.now.preset
      reps = presets[preset]

      if (!reps) {
        logger.warn('Unknown preset "'.concat(preset, '"'))

        var _Object$keys = Object.keys(presets)

        var _Object$keys2 = _slicedToArray(_Object$keys, 1)

        preset = _Object$keys2[0]
        reps = presets[preset]
      }

      opts.preset = preset
      opts.reps = utils.deriveDeep(reps, true)
    }
  }

  function ensureRepAssign(opts, prop, value) {
    ensureRepList(opts)
    var rep = opts.reps[repIndex]

    if (rep.hasOwnProperty(prop)) {
      repIndex = opts.reps.length
      opts.reps[repIndex] = utils.deriveDeep(rep, true)
    }

    if (value !== undefined) {
      opts.reps[repIndex][prop] = value
    }
  }

  function addObject(opts, params, options) {
    if (opts._objects === undefined) {
      opts._objects = []
    }

    var _options = _slicedToArray(options, 2),
      type = _options[0],
      newOpts = _options[1]

    var newObj = {
      type: type,
      params: params
    }

    if (newOpts !== undefined) {
      newObj.opts = newOpts
    }

    opts._objects[opts._objects.length] = newObj
  }

  function parseParams(str, params) {
    var sep = str.indexOf(',')

    if (sep >= 0) {
      params.push(str.substr(sep + 1).split(','))
      return str.substr(0, sep)
    }

    return str
  }

  function extractArgs(input, defaultsDict, params) {
    if (input) {
      var bang = input.indexOf(cOptsSep)
      var inputVal = parseParams(
        input.substr(0, bang >= 0 ? bang : undefined),
        params
      )

      if (bang >= 0) {
        var args = input.substr(bang + 1).split(cLSep)
        input = inputVal

        if (defaultsDict) {
          var defaults = defaultsDict[input]
          var opts = utils.deriveDeep(defaults, true)
          args.forEach(function (arg) {
            var pair = arg.split(cL2Ass, 2)
            var key = decodeURIComponent(pair[0])
            var value = decodeURIComponent(pair[1])

            var adapter =
              adapters[_typeof(___default['default'].get(defaults, key))]

            if (adapter) {
              ___default['default'].set(opts, key, adapter(value))
            } else {
              logger.warn(
                'Unknown argument "'
                  .concat(key, '" for option "')
                  .concat(input, '"')
              )
            }
          })

          if (Object.keys(opts).length > 0) {
            input = [input, opts]
          }
        }
      } else {
        input = inputVal
      }
    }

    return input
  }

  var actions = {
    l: 'load',
    load: String,
    t: 'type',
    type: String,
    v: 'view',
    view: String,
    u: 'unit',
    unit: Number,
    menu: asBoolean,
    o: 'object',
    object: function object(value, opts) {
      var params = []
      var options = extractArgs(value, settings$1.defaults.objects, params)

      if (!Array.isArray(options)) {
        options = [options]
      }

      addObject(opts, params[0], options)
    },
    p: 'preset',
    preset: function preset(value, opts) {
      opts.preset = value
      opts.reps = null
      ensureRepList(opts)
    },
    r: 'rep',
    rep: function rep(value, opts) {
      ensureRepList(opts)
      repIndex = Number(value)
      repIndex =
        repIndex <= opts.reps.length
          ? repIndex < 0
            ? 0
            : repIndex
          : opts.reps.length

      if (repIndex === opts.reps.length) {
        opts.reps[repIndex] =
          repIndex > 0
            ? utils.deriveDeep(opts.reps[repIndex - 1], true)
            : utils.deriveDeep(settings$1.defaults.presets.default[0], true)
      }
    },
    s: 'select',
    select: function select(value, opts) {
      ensureRepAssign(opts, 'selector', value)
    },
    m: 'mode',
    mode: function mode(value, opts) {
      ensureRepAssign(
        opts,
        'mode',
        extractArgs(value, settings$1.defaults.modes)
      )
    },
    c: 'color',
    color: function color(value, opts) {
      ensureRepAssign(
        opts,
        'colorer',
        extractArgs(value, settings$1.defaults.colorers)
      )
    },
    mt: 'material',
    material: function material(value, opts) {
      ensureRepAssign(
        opts,
        'material',
        extractArgs(value, settings$1.defaults.materials)
      )
    },
    dup: function dup(value, opts) {
      ensureRepList(opts)
      var reps = opts.reps
      var rep = reps[repIndex]
      repIndex = reps.length
      reps[repIndex] = utils.deriveDeep(rep, true)
    },
    ar: 'autoResolution'
  }

  function _fromArray(entries) {
    repIndex = 0
    var opts = {}

    for (var i = 0, n = entries.length; i < n; ++i) {
      var entry = entries[i]
      var key = entry[0]
      var value = entry[1]
      var splitedString = key.split('.')

      if (
        actions.hasOwnProperty(key) ||
        settings$1.defaults.hasOwnProperty(splitedString[0])
      ) {
        var action = actions[key]

        while (___default['default'].isString(action)) {
          key = action
          action = actions[key]
        }

        if (!action) {
          var adapter =
            adapters[
              _typeof(___default['default'].get(settings$1.defaults, key))
            ]

          if (adapter) {
            ___default['default'].set(
              opts,
              'settings.'.concat(key),
              adapter(value)
            )
          } else {
            logger.warn('Unknown option "'.concat(key, '"'))
          }
        } else if (typeof action === 'function') {
          var result = action(value, opts)

          if (result !== undefined) {
            opts[key] = result
          }
        }
      }
    }

    return opts
  }

  function fromAttr(attr) {
    return _fromArray(utils.getUrlParameters('?'.concat(attr || '')))
  }

  function fromURL(url) {
    return _fromArray(utils.getUrlParameters(url))
  }

  function _processOptsForURL(opts) {
    var str = []
    var i = 0
    utils.forInRecursive(opts, function (value, key) {
      str[i++] =
        encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value)
    })
    return str.join(cLSep)
  }

  function _processArgsForURL(args) {
    if (!___default['default'].isArray(args)) {
      return args
    }

    if (args.length < 2) {
      return args[0]
    }

    return ''
      .concat(args[0])
      .concat(cOptsSep)
      .concat(_processOptsForURL(args[1]))
  }

  function _processObjForURL(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined
    }

    var res = objOpts.type

    if (
      ___default['default'].isArray(objOpts.params) &&
      objOpts.params.length > 0
    ) {
      res += ','.concat(objOpts.params.join(','))
    }

    if (objOpts.opts) {
      res += cOptsSep + _processOptsForURL(objOpts.opts)
    }

    return res
  }

  function toURL(opts) {
    var stringList = []
    var idx = 0

    function checkAndAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        stringList[idx++] =
          encodeQueryComponentL1(prefix) +
          cL1Ass +
          encodeQueryComponentL1(value)
      }
    }

    function addReps(repList) {
      if (!repList) {
        return
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        if (___default['default'].isEmpty(repList[i])) {
          continue
        }

        checkAndAdd('r', i)
        checkAndAdd('s', repList[i].selector)
        checkAndAdd('m', _processArgsForURL(repList[i].mode))
        checkAndAdd('c', _processArgsForURL(repList[i].colorer))
        checkAndAdd('mt', _processArgsForURL(repList[i].material))
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('o', _processObjForURL(objList[i]))
      }
    }

    checkAndAdd('l', opts.load)
    checkAndAdd('u', opts.unit)
    checkAndAdd('p', opts.preset)
    addReps(opts.reps)
    addObjects(opts._objects)
    checkAndAdd('v', opts.view)
    utils.forInRecursive(opts.settings, function (value, key) {
      if (key === 'preset') {
        return
      }

      checkAndAdd(key, value)
    })
    var url = ''

    if (typeof window !== 'undefined') {
      var _window = window,
        location = _window.location
      url = ''
        .concat(location.protocol, '//')
        .concat(location.host)
        .concat(location.pathname)
    }

    if (stringList.length > 0) {
      url += '?'.concat(stringList.join('&'))
    }

    return url
  }

  function _processOptsForScript(opts) {
    var str = []
    var i = 0
    utils.forInRecursive(opts, function (value, key) {
      str[i++] = ''.concat(key, '=').concat(utils.enquoteString(value))
    })
    return str.join(' ')
  }

  function _processArgsForScript(args) {
    if (!___default['default'].isArray(args)) {
      return args
    }

    if (args.length < 2) {
      return args[0]
    }

    return ''.concat(args[0], ' ').concat(_processOptsForScript(args[1]))
  }

  function _processObjForScript(objOpts) {
    if (!objOpts || !objOpts.type) {
      return undefined
    }

    var res = objOpts.type

    if (
      ___default['default'].isArray(objOpts.params) &&
      objOpts.params.length > 0
    ) {
      res += ' '.concat(objOpts.params.map(utils.enquoteString).join(' '))
    }

    if (objOpts.opts) {
      res += ' '.concat(_processOptsForScript(objOpts.opts))
    }

    return res
  }

  function _processRepsForScript(rep, index) {
    var repString = []
    var strIdx = 0

    function localAdd(prefix, value) {
      if (value !== null && value !== undefined) {
        repString[strIdx++] = prefix + value
      }
    }

    if (___default['default'].isEmpty(rep)) {
      return null
    }

    localAdd('', index)
    localAdd('s=', utils.enquoteString(rep.selector))
    localAdd('m=', _processArgsForScript(rep.mode))
    localAdd('c=', _processArgsForScript(rep.colorer))
    localAdd('mt=', _processArgsForScript(rep.material))
    return repString.join(' ')
  }

  function toScript(opts) {
    var commandsList = []
    var idx = 0

    function checkAndAdd(command, value, saveQuotes) {
      if (value !== null && value !== undefined) {
        var quote = typeof value === 'string' && saveQuotes ? '"' : ''
        commandsList[idx++] = ''
          .concat(command, ' ')
          .concat(quote)
          .concat(value)
          .concat(quote)
          .trim()
      }
    }

    function addReps(repList) {
      if (!repList) {
        return
      }

      for (var i = 0, n = repList.length; i < n; ++i) {
        checkAndAdd('rep', _processRepsForScript(repList[i], i))
      }
    }

    function addObjects(objList) {
      if (!objList) {
        return
      }

      for (var i = 0, n = objList.length; i < n; ++i) {
        checkAndAdd('', _processObjForScript(objList[i]))
      }
    }

    checkAndAdd('set', 'autobuild false')
    checkAndAdd('load', opts.load, true)
    checkAndAdd('unit', opts.unit)
    checkAndAdd('preset', opts.preset)
    addReps(opts.reps)
    addObjects(opts._objects)
    utils.forInRecursive(opts.settings, function (value, key) {
      if (key === 'preset') {
        return
      }

      checkAndAdd('set '.concat(key), value, true)
    })
    checkAndAdd('view', opts.view)
    checkAndAdd('set', 'autobuild true')
    return commandsList.join('\n')
  }

  var options$1 = {
    fromURL: fromURL,
    fromAttr: fromAttr,
    adapters: adapters,
    toURL: toURL,
    toScript: toScript
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      })
    } else {
      obj[key] = value
    }

    return obj
  }

  var Atom$2 = /*#__PURE__*/ (function () {
    function Atom(
      residue,
      name,
      type,
      position,
      role,
      het,
      serial,
      location,
      occupancy,
      temperature,
      charge
    ) {
      _classCallCheck(this, Atom)

      this.index = -1
      this.residue = residue
      this.name = name
      this.element = type
      this.position = position
      this.role = role
      this.mask = 1 | 0
      this.het = het
      this.serial = serial
      this.location = (location || ' ').charCodeAt(0)
      this.occupancy = occupancy || 1
      this.temperature = temperature
      this.charge = charge
      this.hydrogenCount = -1
      this.radicalCount = 0
      this.valence = -1
      this.bonds = []
      this.flags = 0x0000

      if (type.name === 'H') {
        this.flags |= Atom.Flags.HYDROGEN
      } else if (type.name === 'C') {
        this.flags |= Atom.Flags.CARBON
      }
    }

    _createClass(Atom, [
      {
        key: 'isHet',
        value: function isHet() {
          return this.het
        }
      },
      {
        key: 'isHydrogen',
        value: function isHydrogen() {
          return this.element.number === 1
        }
      },
      {
        key: 'getVisualName',
        value: function getVisualName() {
          var name = this.name

          if (name.length > 0) {
            return name
          }

          return this.element.name.trim()
        }
      },
      {
        key: 'forEachBond',
        value: function forEachBond(process) {
          var bonds = this.bonds

          for (var i = 0, n = bonds.length; i < n; ++i) {
            process(bonds[i])
          }
        }
      },
      {
        key: 'getFullName',
        value: function getFullName() {
          var name = ''

          if (this.residue !== null) {
            if (this.residue._chain !== null) {
              name += ''.concat(this.residue._chain.getName(), '.')
            }

            name += ''.concat(this.residue._sequence, '.')
          }

          name += this.name
          return name
        }
      }
    ])

    return Atom
  })()

  _defineProperty(Atom$2, 'Flags', {
    CARBON: 0x0001,
    HYDROGEN: 0x0008,
    NONPOLARH: 0x1008
  })

  var Element$a = /*#__PURE__*/ _createClass(function Element(
    number,
    name,
    fullName,
    weight,
    radius,
    radiusBonding,
    hValency
  ) {
    _classCallCheck(this, Element)

    this.number = number
    this.name = name
    this.fullName = fullName
    this.weight = weight
    this.radius = radius
    this.radiusBonding = radiusBonding
    this.hydrogenValency = hValency
  })

  _defineProperty(Element$a, 'Constants', {
    U1: 1,
    Lead: 2,
    U2: 3,
    Wing: 4,
    U18: 18
  })

  _defineProperty(Element$a, 'Role', {
    N: Element$a.Constants.U1,
    CA: Element$a.Constants.Lead,
    C: Element$a.Constants.U2,
    O: Element$a.Constants.Wing,
    SG: Element$a.Constants.U18
  })

  _defineProperty(Element$a, 'ByAtomicNumber', [
    null,
    new Element$a(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]),
    new Element$a(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]),
    new Element$a(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]),
    new Element$a(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]),
    new Element$a(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]),
    new Element$a(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]),
    new Element$a(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [3, 5]),
    new Element$a(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [2, 4]),
    new Element$a(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]),
    new Element$a(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]),
    new Element$a(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]),
    new Element$a(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]),
    new Element$a(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]),
    new Element$a(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]),
    new Element$a(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [3, 5]),
    new Element$a(16, 'S', 'Sulfur', 32.07, 2, 1.02, [2, 4, 6]),
    new Element$a(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [1, 3, 5, 7]),
    new Element$a(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]),
    new Element$a(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]),
    new Element$a(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]),
    new Element$a(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]),
    new Element$a(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]),
    new Element$a(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]),
    new Element$a(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]),
    new Element$a(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]),
    new Element$a(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]),
    new Element$a(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]),
    new Element$a(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]),
    new Element$a(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]),
    new Element$a(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]),
    new Element$a(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]),
    new Element$a(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]),
    new Element$a(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [3, 5]),
    new Element$a(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [2, 4, 6]),
    new Element$a(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [1, 3, 5, 7]),
    new Element$a(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]),
    new Element$a(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]),
    new Element$a(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]),
    new Element$a(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]),
    new Element$a(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]),
    new Element$a(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]),
    new Element$a(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]),
    new Element$a(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]),
    new Element$a(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]),
    new Element$a(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]),
    new Element$a(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]),
    new Element$a(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]),
    new Element$a(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]),
    new Element$a(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]),
    new Element$a(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [2, 4]),
    new Element$a(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [3, 5]),
    new Element$a(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [2, 4, 6]),
    new Element$a(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [1, 3, 5, 7]),
    new Element$a(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]),
    new Element$a(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]),
    new Element$a(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]),
    new Element$a(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]),
    new Element$a(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]),
    new Element$a(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]),
    new Element$a(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]),
    new Element$a(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]),
    new Element$a(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]),
    new Element$a(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]),
    new Element$a(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]),
    new Element$a(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]),
    new Element$a(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]),
    new Element$a(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]),
    new Element$a(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]),
    new Element$a(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]),
    new Element$a(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]),
    new Element$a(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]),
    new Element$a(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]),
    new Element$a(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]),
    new Element$a(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]),
    new Element$a(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]),
    new Element$a(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]),
    new Element$a(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]),
    new Element$a(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]),
    new Element$a(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]),
    new Element$a(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]),
    new Element$a(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [1, 3]),
    new Element$a(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [2, 4]),
    new Element$a(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [3, 5]),
    new Element$a(84, 'PO', 'Polonium', 210, 1.7, 1.68, [2, 4, 6]),
    new Element$a(85, 'AT', 'Astatine', 210, 1.7, 1.7, [1, 3, 5, 7]),
    new Element$a(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]),
    new Element$a(87, 'FR', 'Francium', 223, 1.7, 2, [1]),
    new Element$a(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]),
    new Element$a(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]),
    new Element$a(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]),
    new Element$a(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]),
    new Element$a(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]),
    new Element$a(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]),
    new Element$a(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]),
    new Element$a(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]),
    new Element$a(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]),
    new Element$a(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]),
    new Element$a(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]),
    new Element$a(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]),
    new Element$a(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]),
    new Element$a(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]),
    new Element$a(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]),
    new Element$a(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]),
    new Element$a(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]),
    new Element$a(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]),
    new Element$a(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]),
    new Element$a(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]),
    new Element$a(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]),
    new Element$a(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])
  ])

  _defineProperty(Element$a, 'ByName', {
    D: new Element$a(1, 'D', 'Deuterium', 2.014, 1.2, 0.23, [1]),
    T: new Element$a(1, 'T', 'Tritium', 3.016, 1.2, 0.23, [1])
  })

  ;(function () {
    var byAtomicNumber = Element$a.ByAtomicNumber
    var byName = Element$a.ByName

    for (var i = 0, n = byAtomicNumber.length; i < n; ++i) {
      var element = byAtomicNumber[i]

      if (element) {
        byName[element.name] = element
      }
    }
  })()

  Element$a.getByName = function (element) {
    var type = Element$a.ByName[element]

    if (!type) {
      type = Element$a.ByName[element] = new Element$a(
        0,
        element,
        'Unknown',
        0,
        1.0,
        0.01,
        [0]
      )
    }

    return type
  }

  var cBondTypes = {
    UNKNOWN: 0,
    COVALENT: 1,
    AROMATIC: 2
  }

  function getAtomPos(atom) {
    return atom.position
  }

  var Bond$5 = /*#__PURE__*/ (function () {
    function Bond(left, right, order, type, fixed) {
      _classCallCheck(this, Bond)

      this._left = left
      this._right = right
      this._fixed = fixed
      this._index = -1

      if (left > right) {
        throw new Error('In a bond atom indices must be in increasing order')
      }

      this._order = order
      this._type = type
    }

    _createClass(Bond, [
      {
        key: 'getLeft',
        value: function getLeft() {
          return this._left
        }
      },
      {
        key: 'getRight',
        value: function getRight() {
          return this._right
        }
      },
      {
        key: 'getOrder',
        value: function getOrder() {
          return this._order
        }
      },
      {
        key: 'calcLength',
        value: function calcLength() {
          return this._left.position.distanceTo(this._right.position)
        }
      },
      {
        key: '_forEachNeighbour',
        value: function _forEachNeighbour(currAtom, process) {
          var bonds = currAtom.bonds

          for (var i = 0, n = bonds.length; i < n; ++i) {
            process(
              bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right
            )
          }
        }
      },
      {
        key: 'forEachLevelOne',
        value: function forEachLevelOne(process) {
          var left = this._left
          var right = this._right

          this._forEachNeighbour(left, function (atom) {
            if (atom === right) {
              return
            }

            process(atom)
          })

          this._forEachNeighbour(right, function (atom) {
            if (atom === left) {
              return
            }

            process(atom)
          })
        }
      },
      {
        key: 'forEachLevelTwo',
        value: function forEachLevelTwo(process) {
          var left = this._left
          var right = this._right
          var self = this

          self._forEachNeighbour(left, function (atom) {
            if (atom === right) {
              return
            }

            self._forEachNeighbour(atom, function (l2Atom) {
              if (l2Atom === left) {
                return
              }

              process(l2Atom)
            })
          })

          self._forEachNeighbour(right, function (atom) {
            if (atom === left) {
              return
            }

            self._forEachNeighbour(atom, function (l2Atom) {
              if (l2Atom === right) {
                return
              }

              process(l2Atom)
            })
          })
        }
      },
      {
        key: '_fixDir',
        value: function _fixDir(refPoint, currDir, posGetter) {
          var rightCount = 0
          var leftCount = 0
          var tmpVec = refPoint.clone()

          function checkDir(atom) {
            tmpVec.copy(posGetter(atom))
            tmpVec.sub(refPoint)
            var dotProd = currDir.dot(tmpVec)

            if (dotProd > 0) {
              ++rightCount
            } else {
              ++leftCount
            }
          }

          function checkCarbon(atom) {
            if (atom.element.name === 'C') {
              checkDir(atom)
            }
          }

          var stages = [
            [this.forEachLevelOne, checkCarbon],
            [this.forEachLevelOne, checkDir],
            [this.forEachLevelTwo, checkCarbon],
            [this.forEachLevelTwo, checkDir]
          ]

          for (var stageId = 0; stageId < stages.length; ++stageId) {
            stages[stageId][0].call(this, stages[stageId][1])

            if (leftCount > rightCount) {
              return currDir.multiplyScalar(-1)
            }

            if (leftCount < rightCount) {
              return currDir
            }
          }

          return currDir
        }
      },
      {
        key: 'calcNormalDir',
        value: function calcNormalDir(posGetter) {
          var left = this._left
          var right = this._right
          var first = left
          var second = right
          posGetter = posGetter === undefined ? getAtomPos : posGetter

          if (left.bonds.length > right.bonds.length) {
            first = right
            second = left
          }

          var third = first
          var maxNeibs = 0
          var _second = second,
            bonds = _second.bonds

          for (var i = 0, n = bonds.length; i < n; ++i) {
            var another = bonds[i]._left

            if (bonds[i]._left === second) {
              another = bonds[i]._right
            }

            if (another.bonds.length > maxNeibs && another !== first) {
              third = another
              maxNeibs = another.bonds.length
            }
          }

          var secondPos = posGetter(second)
          var firstV = posGetter(first).clone().sub(secondPos)
          var secondV = posGetter(third).clone().sub(secondPos)
          secondV.crossVectors(firstV, secondV)

          if (secondV.lengthSq() < 0.0001) {
            secondV.set(0, 1, 0)
          }

          firstV.normalize()
          secondV.normalize()
          firstV.crossVectors(secondV, firstV)

          if (firstV.lengthSq() < 0.0001) {
            firstV.set(0, 1, 0)
          }

          firstV.normalize()
          return this._fixDir(secondPos, firstV, posGetter)
        }
      }
    ])

    return Bond
  })()

  _defineProperty(Bond$5, 'BondType', cBondTypes)

  Bond$5.prototype.BondType = cBondTypes

  var cNucleicControlNames = ["C3'", 'C3*', 'P', 'H5T', 'H3T']
  var cNucleicWing1Names = ['OP1', 'O1P']
  var cNucleicWing2Names = ['OP2', 'O2P']
  var cCylinderSource = ["C3'", 'C3*', 'C1', "C1'", 'C1*', 'P']
  var cCylinderTarget = [
    {
      types: ['A', 'DA', 'G', 'DG'],
      atoms: ['N1']
    },
    {
      types: ['C', 'DC'],
      atoms: ['N3']
    },
    {
      types: ['T', 'DT', 'U', 'DU'],
      atoms: ['O4']
    }
  ]

  var Residue$1 = /*#__PURE__*/ (function () {
    function Residue(chain, type, sequence, icode) {
      _classCallCheck(this, Residue)

      this._chain = chain
      this._component = null
      this._type = type
      this._sequence = sequence
      this._icode = icode
      this._mask = 1 | 0
      this._index = -1
      this._atoms = []
      this._secondary = null
      this._firstAtom = null
      this._leadAtom = null
      this._wingAtom = null
      this._lastAtom = null
      this._controlPoint = null
      this._midPoint = null
      this._wingVector = null
      this._cylinders = null
      this._isValid = true
      this._het = false
      this._molecule = null
      this.temperature = null
      this.occupancy = null
    }

    _createClass(Residue, [
      {
        key: 'getChain',
        value: function getChain() {
          return this._chain
        }
      },
      {
        key: 'getMolecule',
        value: function getMolecule() {
          return this._molecule
        }
      },
      {
        key: 'getType',
        value: function getType() {
          return this._type
        }
      },
      {
        key: 'getSequence',
        value: function getSequence() {
          return this._sequence
        }
      },
      {
        key: 'getSecondary',
        value: function getSecondary() {
          return this._secondary
        }
      },
      {
        key: 'getICode',
        value: function getICode() {
          return this._icode
        }
      },
      {
        key: 'addAtom',
        value: function addAtom(
          name,
          type,
          xyz,
          role,
          het,
          serial,
          altLoc,
          occupancy,
          tempFactor,
          charge
        ) {
          var atom = new Atom$2(
            this,
            name,
            type,
            xyz,
            role,
            het,
            serial,
            altLoc,
            occupancy,
            tempFactor,
            charge
          )

          var complex = this._chain.getComplex()

          complex.addAtom(atom)

          this._atoms.push(atom)

          this._het = this._het || het
          return atom
        }
      },
      {
        key: 'getAtomCount',
        value: function getAtomCount() {
          return this._atoms.length
        }
      },
      {
        key: 'forEachAtom',
        value: function forEachAtom(process) {
          var atoms = this._atoms

          for (var i = 0, n = atoms.length; i < n; ++i) {
            if (process(atoms[i])) {
              break
            }
          }
        }
      },
      {
        key: '_findAtomByName',
        value: function _findAtomByName(name) {
          var res = null
          this.forEachAtom(function (atom) {
            if (atom.name === name) {
              res = atom
              return true
            }

            return false
          })
          return res
        }
      },
      {
        key: '_findFirstAtomInList',
        value: function _findFirstAtomInList(names) {
          var res = null

          for (var i = 0; i < names.length; ++i) {
            res = this._findAtomByName(names[i])

            if (res !== null) {
              return res
            }
          }

          return res
        }
      },
      {
        key: 'collectMask',
        value: function collectMask() {
          var mask = 0xffffffff
          var atoms = this._atoms

          for (var i = 0, n = atoms.length; i < n; ++i) {
            mask &= atoms[i].mask
          }

          this._mask = mask
        }
      },
      {
        key: 'getCylinderTargetList',
        value: function getCylinderTargetList() {
          var type = this._type._name

          for (var i = 0, n = cCylinderTarget.length; i < n; ++i) {
            for (var j = 0, m = cCylinderTarget[i].types.length; j < m; ++j) {
              if (type === cCylinderTarget[i].types[j]) {
                return cCylinderTarget[i].atoms
              }
            }
          }

          return null
        }
      },
      {
        key: '_detectLeadWing',
        value: function _detectLeadWing(dst, next, getAtomPosition) {
          var leadAtom = this._findFirstAtomInList(cNucleicControlNames)

          var wingStart = this._findFirstAtomInList(cNucleicWing1Names)

          var wingEnd = this._findFirstAtomInList(cNucleicWing2Names)

          if (wingStart === null && next !== null) {
            wingStart = next._findFirstAtomInList(cNucleicWing1Names)
          }

          if (wingEnd === null && next !== null) {
            wingEnd = next._findFirstAtomInList(cNucleicWing2Names)
          }

          if (leadAtom === null || wingStart === null || wingEnd === null) {
            return
          }

          dst._leadAtom = leadAtom
          dst._controlPoint = getAtomPosition(leadAtom)
          dst._wingVector = getAtomPosition(wingEnd)
            .clone()
            .sub(getAtomPosition(wingStart))
          dst._isValid = true

          var cylSource = this._findFirstAtomInList(cCylinderSource)

          var targetList = this.getCylinderTargetList()
          var cylTarget =
            targetList !== null ? this._findFirstAtomInList(targetList) : null

          if (cylSource === null || cylTarget === null) {
            return
          }

          dst._cylinders = [
            getAtomPosition(cylSource),
            getAtomPosition(cylTarget)
          ]
        }
      },
      {
        key: 'calcWing',
        value: function calcWing(
          prevLeadPos,
          currLeadPos,
          prevWingPos,
          prevWing
        ) {
          var vectorA = currLeadPos.clone().sub(prevLeadPos)
          var vectorB = prevLeadPos.clone().sub(prevWingPos)
          vectorB.crossVectors(vectorA, vectorB)
          vectorB.crossVectors(vectorA, vectorB).normalize()

          if (prevWing !== null && prevWing.length() > 0.0001) {
            var needToNegate =
              vectorB.length() > 0.0001 &&
              Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2

            if (needToNegate) {
              vectorB.negate()
            }
          }

          return vectorB
        }
      },
      {
        key: '_innerFinalize',
        value: function _innerFinalize(
          prevRes,
          prev,
          nextRes,
          dst,
          chainAsNucleic,
          getAtomPosition
        ) {
          var bFirstInChain = prev === null
          var lp = getAtomPosition(this._leadAtom)
          var currLeadPos = new THREE__namespace.Vector3(lp.x, lp.y, lp.z)

          if (chainAsNucleic) {
            this._detectLeadWing(dst, nextRes, getAtomPosition)

            return
          }

          if (bFirstInChain) {
            dst._midPoint = getAtomPosition(this._firstAtom).clone()
          } else {
            var prevLeadPos = prev._controlPoint
            dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5)
            dst._wingVector = this.calcWing(
              prevLeadPos,
              currLeadPos,
              getAtomPosition(prevRes._wingAtom),
              prev._wingVector
            )
          }

          dst._controlPoint = currLeadPos
        }
      },
      {
        key: '_finalize2',
        value: function _finalize2(prev, next, asNucleic) {
          this._innerFinalize(
            prev,
            prev,
            next,
            this,
            asNucleic,
            function (atom) {
              return atom.position
            }
          )
        }
      },
      {
        key: 'isConnected',
        value: function isConnected(anotherResidue) {
          if (this._chain !== anotherResidue._chain) {
            return false
          }

          if (this === anotherResidue) {
            return true
          }

          var res = false
          this.forEachAtom(function (atom) {
            var bonds = atom.bonds

            for (var i = 0, n = bonds.length; i < n; ++i) {
              var bond = bonds[i]

              if (
                bond._left.residue === anotherResidue ||
                bond._right.residue === anotherResidue
              ) {
                res = true
                return true
              }
            }

            return false
          })
          return res
        }
      },
      {
        key: '_finalize',
        value: function _finalize() {
          var self = this

          var _this$_atoms = _slicedToArray(this._atoms, 1)

          this._firstAtom = _this$_atoms[0]
          this._lastAtom = this._atoms[this._atoms.length - 1]
          this._leadAtom = null
          this._wingAtom = null
          var tempCount = 0
          var temperature = 0
          var occupCount = 0
          var occupancy = 0
          this.forEachAtom(function (a) {
            if (self._leadAtom === null) {
              if (a.role === Element$a.Constants.Lead) {
                self._leadAtom = a
              }
            }

            if (self._wingAtom === null) {
              if (a.role === Element$a.Constants.Wing) {
                self._wingAtom = a
              }
            }

            if (a.temperature) {
              temperature += a.temperature
              tempCount++
            }

            if (a.occupancy) {
              occupancy += a.occupancy
              occupCount++
            }

            return self._leadAtom !== null && self._wingAtom !== null
          })

          if (tempCount > 0) {
            this.temperature = temperature / tempCount
          }

          if (occupCount > 0) {
            this.occupancy = occupancy / occupCount
          }

          if (this._leadAtom === null || this._wingAtom === null) {
            this._isValid = false
          }

          if (this._leadAtom === null) {
            this._leadAtom = this._firstAtom
          }

          if (this._wingAtom === null) {
            this._wingAtom = this._lastAtom
          }
        }
      }
    ])

    return Residue
  })()

  var ResidueType$1 = /*#__PURE__*/ (function () {
    function ResidueType(name, fullName, letterCode) {
      _classCallCheck(this, ResidueType)

      this._name = name
      this._fullName = fullName
      this.letterCode = letterCode
      this.flags = 0x0000
    }

    _createClass(ResidueType, [
      {
        key: 'getName',
        value: function getName() {
          return this._name
        }
      }
    ])

    return ResidueType
  })()

  _defineProperty(ResidueType$1, 'StandardTypes', {
    ALA: new ResidueType$1('ALA', 'Alanine', 'A'),
    ARG: new ResidueType$1('ARG', 'Arginine', 'R'),
    ASN: new ResidueType$1('ASN', 'Asparagine', 'N'),
    ASP: new ResidueType$1('ASP', 'Aspartic Acid', 'D'),
    CYS: new ResidueType$1('CYS', 'Cysteine', 'C'),
    GLN: new ResidueType$1('GLN', 'Glutamine', 'Q'),
    GLU: new ResidueType$1('GLU', 'Glutamic Acid', 'E'),
    GLY: new ResidueType$1('GLY', 'Glycine', 'G'),
    HIS: new ResidueType$1('HIS', 'Histidine', 'H'),
    ILE: new ResidueType$1('ILE', 'Isoleucine', 'I'),
    LEU: new ResidueType$1('LEU', 'Leucine', 'L'),
    LYS: new ResidueType$1('LYS', 'Lysine', 'K'),
    MET: new ResidueType$1('MET', 'Methionine', 'M'),
    PHE: new ResidueType$1('PHE', 'Phenylalanine', 'F'),
    PRO: new ResidueType$1('PRO', 'Proline', 'P'),
    PYL: new ResidueType$1('PYL', 'Pyrrolysine', 'O'),
    SEC: new ResidueType$1('SEC', 'Selenocysteine', 'U'),
    SER: new ResidueType$1('SER', 'Serine', 'S'),
    THR: new ResidueType$1('THR', 'Threonine', 'T'),
    TRP: new ResidueType$1('TRP', 'Tryptophan', 'W'),
    TYR: new ResidueType$1('TYR', 'Tyrosine', 'Y'),
    VAL: new ResidueType$1('VAL', 'Valine', 'V'),
    A: new ResidueType$1('A', 'Adenine', 'A'),
    C: new ResidueType$1('C', 'Cytosine', 'C'),
    G: new ResidueType$1('G', 'Guanine', 'G'),
    I: new ResidueType$1('I', 'Inosine', 'I'),
    T: new ResidueType$1('T', 'Thymine', 'T'),
    U: new ResidueType$1('U', 'Uracil', 'U'),
    DA: new ResidueType$1('DA', 'Adenine', 'A'),
    DC: new ResidueType$1('DC', 'Cytosine', 'C'),
    DG: new ResidueType$1('DG', 'Guanine', 'G'),
    DI: new ResidueType$1('DI', 'Inosine', 'I'),
    DT: new ResidueType$1('DT', 'Thymine', 'T'),
    DU: new ResidueType$1('DU', 'Uracil', 'U'),
    '+A': new ResidueType$1('+A', 'Adenine', 'A'),
    '+C': new ResidueType$1('+C', 'Cytosine', 'C'),
    '+G': new ResidueType$1('+G', 'Guanine', 'G'),
    '+I': new ResidueType$1('+I', 'Inosine', 'I'),
    '+T': new ResidueType$1('+T', 'Thymine', 'T'),
    '+U': new ResidueType$1('+U', 'Uracil', 'U'),
    WAT: new ResidueType$1('WAT', 'Water', ''),
    H2O: new ResidueType$1('H2O', 'Water', ''),
    HOH: new ResidueType$1('HOH', 'Water', ''),
    DOD: new ResidueType$1('DOD', 'Water', ''),
    UNK: new ResidueType$1('UNK', 'Unknown', ''),
    UNL: new ResidueType$1('UNL', 'Unknown Ligand', '')
  })

  _defineProperty(ResidueType$1, 'Flags', {
    PROTEIN: 0x0001,
    BASIC: 0x0002,
    ACIDIC: 0x0004,
    POLAR: 0x0008,
    NONPOLAR: 0x0010,
    AROMATIC: 0x0020,
    NUCLEIC: 0x0100,
    PURINE: 0x0200,
    PYRIMIDINE: 0x0400,
    DNA: 0x0800,
    RNA: 0x1000,
    WATER: 0x10000
  })

  function _addFlag(flag, list) {
    for (var i = 0, n = list.length; i < n; ++i) {
      var res = ResidueType$1.StandardTypes[list[i]]

      if (res) {
        res.flags |= flag
      }
    }
  }

  var Flags = ResidueType$1.Flags

  _addFlag(Flags.WATER, ['WAT', 'H2O', 'HOH', 'DOD'])

  _addFlag(Flags.PROTEIN, [
    'ALA',
    'ARG',
    'ASN',
    'ASP',
    'CYS',
    'GLY',
    'GLU',
    'GLN',
    'HIS',
    'ILE',
    'LEU',
    'LYS',
    'MET',
    'PHE',
    'PRO',
    'PYL',
    'SEC',
    'SER',
    'THR',
    'TRP',
    'TYR',
    'VAL'
  ])

  _addFlag(Flags.BASIC, ['ARG', 'HIS', 'LYS'])

  _addFlag(Flags.ACIDIC, ['ASP', 'GLU'])

  _addFlag(Flags.POLAR, ['ASN', 'CYS', 'GLN', 'SER', 'THR', 'TYR'])

  _addFlag(Flags.NONPOLAR, [
    'ALA',
    'ILE',
    'LEU',
    'MET',
    'PHE',
    'PRO',
    'TRP',
    'VAL',
    'GLY'
  ])

  _addFlag(Flags.AROMATIC, ['PHE', 'TRP', 'TYR'])

  _addFlag(Flags.NUCLEIC, [
    'A',
    'G',
    'I',
    'DA',
    'DG',
    'DI',
    '+A',
    '+G',
    '+I',
    'C',
    'T',
    'U',
    'DC',
    'DT',
    'DU',
    '+C',
    '+T',
    '+U'
  ])

  _addFlag(Flags.PURINE, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I'])

  _addFlag(Flags.PYRIMIDINE, [
    'C',
    'T',
    'U',
    'DC',
    'DT',
    'DU',
    '+C',
    '+T',
    '+U'
  ])

  _addFlag(Flags.DNA, ['DA', 'DG', 'DI', 'DC', 'DT', 'DU'])

  _addFlag(Flags.RNA, ['A', 'G', 'I', 'C', 'T', 'U'])

  var hydro = {
    ILE: 4.5,
    VAL: 4.2,
    LEU: 3.8,
    PHE: 2.8,
    CYS: 2.5,
    MET: 1.9,
    ALA: 1.8,
    GLY: -0.4,
    THR: -0.7,
    SER: -0.8,
    TRP: -0.9,
    TYR: -1.3,
    PRO: -1.6,
    HIS: -3.2,
    GLU: -3.5,
    GLN: -3.5,
    ASP: -3.5,
    ASN: -3.5,
    LYS: -3.9,
    ARG: -4.5
  }

  function _addParam(param, list) {
    var keys = Object.keys(list)

    for (var i = 0, n = keys.length; i < n; ++i) {
      var key = keys[i]
      var value = list[key]
      ResidueType$1.StandardTypes[key][param] = value
    }
  }

  _addParam('hydrophobicity', hydro)

  var ChainType = {
    UNKNOWN: 0,
    PROTEIN: 1,
    NUCLEIC: 2
  }

  var Chain$2 = /*#__PURE__*/ (function () {
    function Chain(complex, name) {
      _classCallCheck(this, Chain)

      this._complex = complex
      this._name = name
      this._mask = 1 | 0
      this._index = -1
      this._residues = []
      this.minSequence = Number.POSITIVE_INFINITY
      this.maxSequence = Number.NEGATIVE_INFINITY
    }

    _createClass(Chain, [
      {
        key: 'getComplex',
        value: function getComplex() {
          return this._complex
        }
      },
      {
        key: 'getName',
        value: function getName() {
          return this._name
        }
      },
      {
        key: 'getResidues',
        value: function getResidues() {
          return this._residues
        }
      },
      {
        key: '_determineType',
        value: function _determineType() {
          var residues = this._residues
          var _ResidueType$Flags = ResidueType$1.Flags,
            PROTEIN = _ResidueType$Flags.PROTEIN,
            NUCLEIC = _ResidueType$Flags.NUCLEIC
          this.type = ChainType.UNKNOWN

          for (var i = 0, n = residues.length; i < n; ++i) {
            var flags = residues[i]._type.flags

            if ((flags & NUCLEIC) !== 0) {
              this.type = ChainType.NUCLEIC
              break
            } else if ((flags & PROTEIN) !== 0) {
              this.type = ChainType.PROTEIN
              break
            }
          }
        }
      },
      {
        key: 'findResidue',
        value: function findResidue(seqNum, iCode) {
          var residues = this._residues

          for (var i = 0, n = residues.length; i < n; ++i) {
            var res = residues[i]

            if (res._sequence === seqNum && res._icode === iCode) {
              return [res, i]
            }
          }

          return null
        }
      },
      {
        key: '_finalize',
        value: function _finalize() {
          this._determineType()

          var residues = this._residues
          var prev = null

          for (var i = 0, n = residues.length; i < n; ++i) {
            var next = i + 1 < n ? residues[i + 1] : null
            var curr = residues[i]

            {
              curr._finalize2(prev, next, this.type === ChainType.NUCLEIC)

              prev = curr
            }
          }

          if (residues.length > 1 && residues[1]._wingVector) {
            var p = residues[1]._wingVector
            residues[0]._wingVector = new THREE__namespace.Vector3(
              p.x,
              p.y,
              p.z
            )
          } else if (residues.length > 0) {
            residues[0]._wingVector = new THREE__namespace.Vector3(1, 0, 0)
          }
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var residues = this._residues
          var prev = null
          var prevData = null
          var frameRes = frameData._residues
          var n = residues.length

          function getAtomPos(atom) {
            return frameData.getAtomPos(atom.index)
          }

          for (var i = 0; i < n; ++i) {
            var curr = residues[i]
            var currData = frameRes[curr._index]
            var nextRes = i + 1 < n ? residues[i + 1] : null

            curr._innerFinalize(
              prev,
              prevData,
              nextRes,
              currData,
              this.type === ChainType.NUCLEIC,
              getAtomPos
            )

            prev = curr
            prevData = currData
          }

          frameRes[residues[0]._index]._wingVector =
            n > 1
              ? frameRes[residues[1]._index]._wingVector
              : new THREE__namespace.Vector3(1, 0, 0)
        }
      },
      {
        key: 'addResidue',
        value: function addResidue(name, sequence, iCode) {
          var type = this._complex.getResidueType(name)

          if (type === null) {
            type = this._complex.addResidueType(name)
          }

          var residue = new Residue$1(this, type, sequence, iCode)

          this._complex.addResidue(residue)

          this._residues.push(residue)

          if (
            type.flags &
            (ResidueType$1.Flags.NUCLEIC | ResidueType$1.Flags.PROTEIN)
          ) {
            if (this.maxSequence < sequence) {
              this.maxSequence = sequence
            }

            if (this.minSequence > sequence) {
              this.minSequence = sequence
            }
          }

          return residue
        }
      },
      {
        key: 'getResidueCount',
        value: function getResidueCount() {
          return this._residues.length
        }
      },
      {
        key: 'forEachResidue',
        value: function forEachResidue(process) {
          var residues = this._residues

          for (var i = 0, n = residues.length; i < n; ++i) {
            process(residues[i])
          }
        }
      },
      {
        key: 'collectMask',
        value: function collectMask() {
          var mask = 0xffffffff
          var residues = this._residues

          for (var i = 0, n = residues.length; i < n; ++i) {
            mask &= residues[i]._mask
          }

          this._mask = mask
        }
      }
    ])

    return Chain
  })()

  var _StructuralElement$ge

  var StructuralElement = /*#__PURE__*/ (function () {
    function StructuralElement(type, init, term) {
      _classCallCheck(this, StructuralElement)

      this.type = type
      this.generic = StructuralElement.genericByType[this.type] || 'loop'
      this.init = init
      this.term = term
    }

    _createClass(StructuralElement, [
      {
        key: '_finalize',
        value: function _finalize(serialAtomMap, residueHash, complex) {
          if (
            this.init instanceof Residue$1 &&
            this.term instanceof Residue$1
          ) {
            return
          }

          var start = complex.splitUnifiedSerial(this.init)
          var end = complex.splitUnifiedSerial(this.term)

          for (var chainId = start.chain; chainId <= end.chain; chainId++) {
            for (
              var serialId = start.serial;
              serialId <= end.serial;
              serialId++
            ) {
              for (var iCode = start.iCode; iCode <= end.iCode; iCode++) {
                var hashCode = complex.getUnifiedSerial(
                  chainId,
                  serialId,
                  iCode
                )

                if (residueHash[hashCode]) {
                  residueHash[hashCode]._secondary = this
                }
              }
            }
          }

          this.init = residueHash[this.init]
          this.term = residueHash[this.term]
        }
      }
    ])

    return StructuralElement
  })()

  StructuralElement.Type = {
    STRAND: 'E',
    BRIDGE: 'B',
    HELIX_310: 'G',
    HELIX_ALPHA: 'H',
    HELIX_PI: 'I',
    HELIX: 'X',
    TURN_310: '3',
    TURN_ALPHA: '4',
    TURN_PI: '5',
    TURN: 'T',
    BEND: 'S',
    COIL: 'C'
  }
  StructuralElement.Generic = {
    STRAND: 'strand',
    HELIX: 'helix',
    LOOP: 'loop'
  }
  var StructuralElementType$5 = StructuralElement.Type
  var StructuralElementGeneric = StructuralElement.Generic
  StructuralElement.genericByType =
    ((_StructuralElement$ge = {}),
    _defineProperty(
      _StructuralElement$ge,
      StructuralElementType$5.STRAND,
      StructuralElementGeneric.STRAND
    ),
    _defineProperty(
      _StructuralElement$ge,
      StructuralElementType$5.HELIX_310,
      StructuralElementGeneric.HELIX
    ),
    _defineProperty(
      _StructuralElement$ge,
      StructuralElementType$5.HELIX_ALPHA,
      StructuralElementGeneric.HELIX
    ),
    _defineProperty(
      _StructuralElement$ge,
      StructuralElementType$5.HELIX_PI,
      StructuralElementGeneric.HELIX
    ),
    _defineProperty(
      _StructuralElement$ge,
      StructuralElementType$5.HELIX,
      StructuralElementGeneric.HELIX
    ),
    _StructuralElement$ge)

  function _createSuper$1$(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1$()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1$() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var StructuralElementType$4 = StructuralElement.Type
  var typeByPDBHelixClass = {
    1: StructuralElementType$4.HELIX_ALPHA,
    3: StructuralElementType$4.HELIX_PI,
    5: StructuralElementType$4.HELIX_310
  }

  var Helix$3 = /*#__PURE__*/ (function (_StructuralElement) {
    _inherits(Helix, _StructuralElement)

    var _super = _createSuper$1$(Helix)

    function Helix(helixClass, init, term, serial, name, comment, length) {
      var _this

      _classCallCheck(this, Helix)

      _this = _super.call(
        this,
        typeByPDBHelixClass[helixClass] || StructuralElement.Type.HELIX,
        init,
        term
      )
      _this.serial = serial
      _this.name = name
      _this.comment = comment
      _this.length = length
      return _this
    }

    return _createClass(Helix)
  })(StructuralElement)

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object)
      if (object === null) break
    }

    return object
  }

  function _get() {
    if (typeof Reflect !== 'undefined' && Reflect.get) {
      _get = Reflect.get
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property)
        if (!base) return
        var desc = Object.getOwnPropertyDescriptor(base, property)

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver)
        }

        return desc.value
      }
    }

    return _get.apply(this, arguments)
  }

  function _createSuper$1_(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1_()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1_() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var Strand$3 = /*#__PURE__*/ (function (_StructuralElement) {
    _inherits(Strand, _StructuralElement)

    var _super = _createSuper$1_(Strand)

    function Strand(sheet, init, term, sense, atomCur, atomPrev) {
      var _this

      _classCallCheck(this, Strand)

      _this = _super.call(this, StructuralElement.Type.STRAND, init, term)
      _this.sheet = sheet
      _this.sense = sense
      _this.atomCur = atomCur
      _this.atomPrev = atomPrev
      return _this
    }

    _createClass(Strand, [
      {
        key: '_finalize',
        value: function _finalize(serialAtomMap, residueHash, complex) {
          _get(_getPrototypeOf(Strand.prototype), '_finalize', this).call(
            this,
            serialAtomMap,
            residueHash,
            complex
          )

          var as = this.atomCur

          if (as !== null && !Number.isNaN(as)) {
            this.atomCur = serialAtomMap[as]
          }

          as = this.atomPrev

          if (as !== null && !Number.isNaN(as)) {
            this.atomPrev = serialAtomMap[as]
          }
        }
      }
    ])

    return Strand
  })(StructuralElement)

  var Sheet$3 = /*#__PURE__*/ (function () {
    function Sheet(name, width) {
      _classCallCheck(this, Sheet)

      this._name = name
      this._width = width
      this._strands = []
    }

    _createClass(Sheet, [
      {
        key: 'getName',
        value: function getName() {
          return this._name
        }
      },
      {
        key: 'getWidth',
        value: function getWidth() {
          return this._width
        }
      },
      {
        key: 'addStrand',
        value: function addStrand(strand) {
          this._strands.push(strand)

          this._width = this._strands.length
        }
      },
      {
        key: 'addEmptyStrand',
        value: function addEmptyStrand() {
          this._strands.push(new Strand$3(null, null, null, null, null, null))
        }
      },
      {
        key: '_finalize',
        value: function _finalize(serialAtomMap, residueHash, complex) {
          var s = this._strands

          for (var i = 0, n = s.length; i < n; ++i) {
            s[i]._finalize(serialAtomMap, residueHash, complex)
          }

          if (!this._width) {
            this._width = s.length
          }

          if (s.length !== this._width) {
            throw new Error('Sheet '.concat(this._name, ' is inconsistent.'))
          }
        }
      }
    ])

    return Sheet
  })()

  var SGroup$1 = /*#__PURE__*/ (function () {
    function SGroup(id, name, position, atoms, saveNode) {
      _classCallCheck(this, SGroup)

      this._id = id
      this._name = name
      this._position = position || new THREE__namespace.Vector3()
      this._atoms = atoms || []
      this._charge = 0
      this._repeat = 1
      this._center = null
      this.xmlNodeRef = saveNode || null
    }

    _createClass(SGroup, [
      {
        key: 'getName',
        value: function getName() {
          return this._name
        }
      },
      {
        key: 'getPosition',
        value: function getPosition() {
          return this._position
        }
      },
      {
        key: 'getCentralPoint',
        value: function getCentralPoint() {
          return this._center
        }
      },
      {
        key: '_rebuildSGroupOnAtomChange',
        value: function _rebuildSGroupOnAtomChange() {
          var nLimon = 100000000

          if (this._center === null) {
            return
          }

          var bLow = new THREE__namespace.Vector3(nLimon, nLimon, nLimon)
          var bHight = new THREE__namespace.Vector3(-nLimon, -nLimon, -nLimon)

          for (var j = 0, n = this._atoms.length; j < n; j++) {
            var aPos = this._atoms[j].position
            bLow.set(
              Math.min(bLow.x, aPos.x),
              Math.min(bLow.y, aPos.y),
              Math.min(bLow.z, aPos.z)
            )
            bHight.set(
              Math.max(bHight.x, aPos.x),
              Math.max(bHight.y, aPos.y),
              Math.max(bHight.z, aPos.z)
            )
          }

          this._center.addVectors(bLow, bHight)

          this._center.multiplyScalar(0.5)
        }
      }
    ])

    return SGroup
  })()

  var commonjsGlobal =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
      ? self
      : {}

  var parser$1 = (function () {
    var o = function o(k, v, _o, l) {
        for (_o = _o || {}, l = k.length; l--; _o[k[l]] = v) {}

        return _o
      },
      $V0 = [1, 4],
      $V1 = [1, 5],
      $V2 = [1, 6],
      $V3 = [1, 7],
      $V4 = [1, 8],
      $V5 = [1, 9],
      $V6 = [1, 11],
      $V7 = [1, 12],
      $V8 = [5, 7, 8, 11],
      $V9 = [1, 17],
      $Va = [1, 22],
      $Vb = [1, 20],
      $Vc = [1, 21],
      $Vd = [5, 7, 8, 11, 19]

    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        error: 2,
        Program: 3,
        Expression: 4,
        EOF: 5,
        Selector: 6,
        OR: 7,
        AND: 8,
        NOT: 9,
        '(': 10,
        ')': 11,
        SELECTOR: 12,
        NAMED_SELECTOR: 13,
        SELECTOR_RANGED: 14,
        RangeList: 15,
        SELECTOR_NAMED: 16,
        NameList: 17,
        Range: 18,
        ',': 19,
        NUMBER: 20,
        ':': 21,
        Name: 22,
        IDENTIFIER: 23,
        STRING: 24,
        $accept: 0,
        $end: 1
      },
      terminals_: {
        2: 'error',
        5: 'EOF',
        7: 'OR',
        8: 'AND',
        9: 'NOT',
        10: '(',
        11: ')',
        12: 'SELECTOR',
        13: 'NAMED_SELECTOR',
        14: 'SELECTOR_RANGED',
        16: 'SELECTOR_NAMED',
        19: ',',
        20: 'NUMBER',
        21: ':',
        23: 'IDENTIFIER',
        24: 'STRING'
      },
      productions_: [
        0,
        [3, 2],
        [4, 1],
        [4, 3],
        [4, 3],
        [4, 2],
        [4, 3],
        [6, 1],
        [6, 1],
        [6, 2],
        [6, 2],
        [15, 1],
        [15, 3],
        [18, 1],
        [18, 3],
        [17, 1],
        [17, 3],
        [22, 1],
        [22, 1],
        [22, 1]
      ],
      performAction: function anonymous(
        yytext,
        yyleng,
        yylineno,
        yy,
        yystate,
        $$,
        _$
      ) {
        var $0 = $$.length - 1

        switch (yystate) {
          case 1:
            return $$[$0 - 1]

          case 3:
            this.$ = yy.keyword('or')($$[$0 - 2], $$[$0])
            break

          case 4:
            this.$ = yy.keyword('and')($$[$0 - 2], $$[$0])
            break

          case 5:
            this.$ = yy.keyword('not')($$[$0])
            break

          case 6:
            this.$ = $$[$0 - 1]
            break

          case 7:
            this.$ = yy.keyword($$[$0])()
            break

          case 8:
            this.$ = yy.GetSelector(
              $$[$0].toLowerCase().slice(1, $$[$0].length)
            )
            break

          case 9:
          case 10:
            this.$ = yy.keyword($$[$0 - 1])($$[$0])
            break

          case 11:
            this.$ = new yy.RangeList($$[$0])
            break

          case 12:
          case 16:
            this.$ = $$[$0 - 2].append($$[$0])
            break

          case 13:
            this.$ = new yy.Range(Number($$[$0]))
            break

          case 14:
            this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]))
            break

          case 15:
            this.$ = new yy.ValueList($$[$0])
            break
        }
      },
      table: [
        {
          3: 1,
          4: 2,
          6: 3,
          9: $V0,
          10: $V1,
          12: $V2,
          13: $V3,
          14: $V4,
          16: $V5
        },
        {
          1: [3]
        },
        {
          5: [1, 10],
          7: $V6,
          8: $V7
        },
        o($V8, [2, 2]),
        {
          4: 13,
          6: 3,
          9: $V0,
          10: $V1,
          12: $V2,
          13: $V3,
          14: $V4,
          16: $V5
        },
        {
          4: 14,
          6: 3,
          9: $V0,
          10: $V1,
          12: $V2,
          13: $V3,
          14: $V4,
          16: $V5
        },
        o($V8, [2, 7]),
        o($V8, [2, 8]),
        {
          15: 15,
          18: 16,
          20: $V9
        },
        {
          17: 18,
          20: $Va,
          22: 19,
          23: $Vb,
          24: $Vc
        },
        {
          1: [2, 1]
        },
        {
          4: 23,
          6: 3,
          9: $V0,
          10: $V1,
          12: $V2,
          13: $V3,
          14: $V4,
          16: $V5
        },
        {
          4: 24,
          6: 3,
          9: $V0,
          10: $V1,
          12: $V2,
          13: $V3,
          14: $V4,
          16: $V5
        },
        o($V8, [2, 5]),
        {
          7: $V6,
          8: $V7,
          11: [1, 25]
        },
        o($V8, [2, 9], {
          19: [1, 26]
        }),
        o($Vd, [2, 11]),
        o($Vd, [2, 13], {
          21: [1, 27]
        }),
        o($V8, [2, 10], {
          19: [1, 28]
        }),
        o($Vd, [2, 15]),
        o($Vd, [2, 17]),
        o($Vd, [2, 18]),
        o($Vd, [2, 19]),
        o([5, 7, 11], [2, 3], {
          8: $V7
        }),
        o($V8, [2, 4]),
        o($V8, [2, 6]),
        {
          18: 29,
          20: $V9
        },
        {
          20: [1, 30]
        },
        {
          20: $Va,
          22: 31,
          23: $Vb,
          24: $Vc
        },
        o($Vd, [2, 12]),
        o($Vd, [2, 14]),
        o($Vd, [2, 16])
      ],
      defaultActions: {
        10: [2, 1]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str)
        } else {
          var error = new Error(str)
          error.hash = hash
          throw error
        }
      },
      parse: function parse(input) {
        var self = this,
          stack = [0],
          tstack = [],
          vstack = [null],
          lstack = [],
          table = this.table,
          yytext = '',
          yylineno = 0,
          yyleng = 0,
          TERROR = 2,
          EOF = 1
        var args = lstack.slice.call(arguments, 1)
        var lexer = Object.create(this.lexer)
        var sharedState = {
          yy: {}
        }

        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k]
          }
        }

        lexer.setInput(input, sharedState.yy)
        sharedState.yy.lexer = lexer
        sharedState.yy.parser = this

        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {}
        }

        var yyloc = lexer.yylloc
        lstack.push(yyloc)
        var ranges = lexer.options && lexer.options.ranges

        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError
        }

        function lex() {
          var token
          token = tstack.pop() || lexer.lex() || EOF

          if (typeof token !== 'number') {
            if (token instanceof Array) {
              tstack = token
              token = tstack.pop()
            }

            token = self.symbols_[token] || token
          }

          return token
        }

        var symbol,
          state,
          action,
          r,
          yyval = {},
          p,
          len,
          newState,
          expected

        while (true) {
          state = stack[stack.length - 1]

          if (this.defaultActions[state]) {
            action = this.defaultActions[state]
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex()
            }

            action = table[state] && table[state][symbol]
          }

          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = ''
            expected = []

            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'")
              }
            }

            if (lexer.showPosition) {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ':\n' +
                lexer.showPosition() +
                '\nExpecting ' +
                expected.join(', ') +
                ", got '" +
                (this.terminals_[symbol] || symbol) +
                "'"
            } else {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ': Unexpected ' +
                (symbol == EOF
                  ? 'end of input'
                  : "'" + (this.terminals_[symbol] || symbol) + "'")
            }

            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            })
          }

          if (action[0] instanceof Array && action.length > 1) {
            throw new Error(
              'Parse Error: multiple actions possible at state: ' +
                state +
                ', token: ' +
                symbol
            )
          }

          switch (action[0]) {
            case 1:
              stack.push(symbol)
              vstack.push(lexer.yytext)
              lstack.push(lexer.yylloc)
              stack.push(action[1])
              symbol = null

              {
                yyleng = lexer.yyleng
                yytext = lexer.yytext
                yylineno = lexer.yylineno
                yyloc = lexer.yylloc
              }

              break

            case 2:
              len = this.productions_[action[1]][1]
              yyval.$ = vstack[vstack.length - len]
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              }

              if (ranges) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ]
              }

              r = this.performAction.apply(
                yyval,
                [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
                ].concat(args)
              )

              if (typeof r !== 'undefined') {
                return r
              }

              if (len) {
                stack = stack.slice(0, -1 * len * 2)
                vstack = vstack.slice(0, -1 * len)
                lstack = lstack.slice(0, -1 * len)
              }

              stack.push(this.productions_[action[1]][0])
              vstack.push(yyval.$)
              lstack.push(yyval._$)
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]]
              stack.push(newState)
              break

            case 3:
              return true
          }
        }

        return true
      }
    }

    var lexer = (function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash)
          } else {
            throw new Error(str)
          }
        },
        setInput: function setInput(input, yy) {
          this.yy = yy || this.yy || {}
          this._input = input
          this._more = this._backtrack = this.done = false
          this.yylineno = this.yyleng = 0
          this.yytext = this.matched = this.match = ''
          this.conditionStack = ['INITIAL']
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }

          if (this.options.ranges) {
            this.yylloc.range = [0, 0]
          }

          this.offset = 0
          return this
        },
        input: function input() {
          var ch = this._input[0]
          this.yytext += ch
          this.yyleng++
          this.offset++
          this.match += ch
          this.matched += ch
          var lines = ch.match(/(?:\r\n?|\n).*/g)

          if (lines) {
            this.yylineno++
            this.yylloc.last_line++
          } else {
            this.yylloc.last_column++
          }

          if (this.options.ranges) {
            this.yylloc.range[1]++
          }

          this._input = this._input.slice(1)
          return ch
        },
        unput: function unput(ch) {
          var len = ch.length
          var lines = ch.split(/(?:\r\n?|\n)/g)
          this._input = ch + this._input
          this.yytext = this.yytext.substr(0, this.yytext.length - len)
          this.offset -= len
          var oldLines = this.match.split(/(?:\r\n?|\n)/g)
          this.match = this.match.substr(0, this.match.length - 1)
          this.matched = this.matched.substr(0, this.matched.length - 1)

          if (lines.length - 1) {
            this.yylineno -= lines.length - 1
          }

          var r = this.yylloc.range
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines
              ? (lines.length === oldLines.length
                  ? this.yylloc.first_column
                  : 0) +
                oldLines[oldLines.length - lines.length].length -
                lines[0].length
              : this.yylloc.first_column - len
          }

          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len]
          }

          this.yyleng = this.yytext.length
          return this
        },
        more: function more() {
          this._more = true
          return this
        },
        reject: function reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno
              }
            )
          }

          return this
        },
        less: function less(n) {
          this.unput(this.match.slice(n))
        },
        pastInput: function pastInput() {
          var past = this.matched.substr(
            0,
            this.matched.length - this.match.length
          )
          return (
            (past.length > 20 ? '...' : '') +
            past.substr(-20).replace(/\n/g, '')
          )
        },
        upcomingInput: function upcomingInput() {
          var next = this.match

          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length)
          }

          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(
            /\n/g,
            ''
          )
        },
        showPosition: function showPosition() {
          var pre = this.pastInput()
          var c = new Array(pre.length + 1).join('-')
          return pre + this.upcomingInput() + '\n' + c + '^'
        },
        test_match: function test_match(match, indexed_rule) {
          var token, lines, backup

          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            }

            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0)
            }
          }

          lines = match[0].match(/(?:\r\n?|\n).*/g)

          if (lines) {
            this.yylineno += lines.length
          }

          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines
              ? lines[lines.length - 1].length -
                lines[lines.length - 1].match(/\r?\n?/)[0].length
              : this.yylloc.last_column + match[0].length
          }
          this.yytext += match[0]
          this.match += match[0]
          this.matches = match
          this.yyleng = this.yytext.length

          if (this.options.ranges) {
            this.yylloc.range = [this.offset, (this.offset += this.yyleng)]
          }

          this._more = false
          this._backtrack = false
          this._input = this._input.slice(match[0].length)
          this.matched += match[0]
          token = this.performAction.call(
            this,
            this.yy,
            this,
            indexed_rule,
            this.conditionStack[this.conditionStack.length - 1]
          )

          if (this.done && this._input) {
            this.done = false
          }

          if (token) {
            return token
          } else if (this._backtrack) {
            for (var k in backup) {
              this[k] = backup[k]
            }

            return false
          }

          return false
        },
        next: function next() {
          if (this.done) {
            return this.EOF
          }

          if (!this._input) {
            this.done = true
          }

          var token, match, tempMatch, index

          if (!this._more) {
            this.yytext = ''
            this.match = ''
          }

          var rules = this._currentRules()

          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]])

            if (
              tempMatch &&
              (!match || tempMatch[0].length > match[0].length)
            ) {
              match = tempMatch
              index = i

              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i])

                if (token !== false) {
                  return token
                } else if (this._backtrack) {
                  match = false
                  continue
                } else {
                  return false
                }
              } else if (!this.options.flex) {
                break
              }
            }
          }

          if (match) {
            token = this.test_match(match, rules[index])

            if (token !== false) {
              return token
            }

            return false
          }

          if (this._input === '') {
            return this.EOF
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. Unrecognized text.\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno
              }
            )
          }
        },
        lex: function lex() {
          var r = this.next()

          if (r) {
            return r
          } else {
            return this.lex()
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition)
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1

          if (n > 0) {
            return this.conditionStack.pop()
          } else {
            return this.conditionStack[0]
          }
        },
        _currentRules: function _currentRules() {
          if (
            this.conditionStack.length &&
            this.conditionStack[this.conditionStack.length - 1]
          ) {
            return this.conditions[
              this.conditionStack[this.conditionStack.length - 1]
            ].rules
          } else {
            return this.conditions['INITIAL'].rules
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0)

          if (n >= 0) {
            return this.conditionStack[n]
          } else {
            return 'INITIAL'
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition)
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length
        },
        options: {
          'case-insensitive': true
        },
        performAction: function anonymous(
          yy,
          yy_,
          $avoiding_name_collisions,
          YY_START
        ) {
          switch ($avoiding_name_collisions) {
            case 0:
              break

            case 1:
              return 20

            case 2:
              return 7

            case 3:
              return 8

            case 4:
              return 9

            case 5:
              return 12

            case 6:
              return 16

            case 7:
              return 14

            case 8:
              return 10

            case 9:
              return 11

            case 10:
              return 19

            case 11:
              return 21

            case 12:
              return '<='

            case 13:
              return '>='

            case 14:
              return '<'

            case 15:
              return '>'

            case 16:
              yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2)
              return 24

            case 17:
              return 13

            case 18:
              return 23

            case 19:
              return 5

            case 20:
              return 'INVALID'
          }
        },
        rules: [
          /^(?:\s+)/i,
          /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i,
          /^(?:OR\b)/i,
          /^(?:AND\b)/i,
          /^(?:NOT\b)/i,
          /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i,
          /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i,
          /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i,
          /^(?:\()/i,
          /^(?:\))/i,
          /^(?:,)/i,
          /^(?::)/i,
          /^(?:<=)/i,
          /^(?:>=)/i,
          /^(?:<)/i,
          /^(?:>)/i,
          /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,
          /^(?:(@[_A-Z0-9]+))/i,
          /^(?:([_A-Z0-9]+))/i,
          /^(?:$)/i,
          /^(?:.)/i
        ],
        conditions: {
          INITIAL: {
            rules: [
              0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
              19, 20
            ],
            inclusive: true
          }
        }
      }
      return lexer
    })()

    parser.lexer = lexer

    function Parser() {
      this.yy = {}
    }

    Parser.prototype = parser
    parser.Parser = Parser
    return new Parser()
  })()

  var SelectionParser = {
    parser: parser$1
  }

  function _createSuper$1Z(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1Z()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1Z() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var Range = /*#__PURE__*/ (function () {
    function Range(min, max) {
      _classCallCheck(this, Range)

      this.min = min
      this.max = typeof max === 'undefined' ? min : max
    }

    _createClass(Range, [
      {
        key: 'includes',
        value: function includes(value) {
          return this.min <= value && value <= this.max
        }
      },
      {
        key: 'toString',
        value: function toString() {
          var min = this.min,
            max = this.max
          return min === max ? String(min) : [min, max].join(':')
        }
      },
      {
        key: 'toJSON',
        value: function toJSON() {
          return [this.min, this.max]
        }
      }
    ])

    return Range
  })()

  var List = /*#__PURE__*/ (function () {
    function List(arg) {
      _classCallCheck(this, List)

      if (arg instanceof this.constructor) {
        return arg
      }

      if (arg instanceof Array) {
        this._values = arg.slice(0)
      } else if (arg) {
        this._values = [arg]
      } else {
        this._values = []
      }
    }

    _createClass(List, [
      {
        key: 'append',
        value: function append(value) {
          var values = this._values
          values[values.length] = value
          return this
        }
      },
      {
        key: 'remove',
        value: function remove(value) {
          var values = this._values
          var index = values.indexOf(value)

          if (index >= 0) {
            values.splice(index, 1)
          }

          return this
        }
      },
      {
        key: 'toString',
        value: function toString() {
          return this._values.join(',')
        }
      },
      {
        key: 'toJSON',
        value: function toJSON() {
          var values = this._values
          var result = []

          for (var i = 0, n = values.length; i < n; ++i) {
            var value = values[i]
            result[i] = value.toJSON ? value.toJSON() : value
          }

          return result
        }
      }
    ])

    return List
  })()

  var RangeList = /*#__PURE__*/ (function (_List) {
    _inherits(RangeList, _List)

    var _super = _createSuper$1Z(RangeList)

    function RangeList() {
      _classCallCheck(this, RangeList)

      return _super.apply(this, arguments)
    }

    _createClass(RangeList, [
      {
        key: 'includes',
        value: function includes(value) {
          var list = this._values

          for (var i = 0, n = list.length; i < n; ++i) {
            if (list[i].includes(value)) {
              return true
            }
          }

          return false
        }
      }
    ])

    return RangeList
  })(List)

  var valuesArray = []

  var ValueList = /*#__PURE__*/ (function (_List2) {
    _inherits(ValueList, _List2)

    var _super2 = _createSuper$1Z(ValueList)

    function ValueList(arg, upperOnly) {
      var _this

      _classCallCheck(this, ValueList)

      var list = (_this = _super2.call(this, arg))

      if (upperOnly) {
        _this.upperOnly = true
        var values = list._values

        for (var i = 0, n = values.length; i < n; ++i) {
          var value = values[i]

          if (typeof value === 'string') {
            values[i] = value.toUpperCase()
          }
        }
      } else {
        _this.upperOnly = false
      }

      return _possibleConstructorReturn(_this, list)
    }

    _createClass(ValueList, [
      {
        key: 'includes',
        value: function includes(value) {
          return this._values.indexOf(value) !== -1
        }
      },
      {
        key: 'toString',
        value: function toString() {
          var values = this._values
          valuesArray.length = 0

          for (var i = 0, n = values.length; i < n; ++i) {
            valuesArray[i] = utils.correctSelectorIdentifier(String(values[i]))
          }

          return valuesArray.join(',')
        }
      },
      {
        key: '_validate',
        value: function _validate(value) {
          return this.upperOnly && typeof value === 'string'
            ? value.toUpperCase()
            : value
        }
      },
      {
        key: 'append',
        value: function append(value) {
          _get(_getPrototypeOf(ValueList.prototype), 'append', this).call(
            this,
            this._validate(value)
          )

          return this
        }
      },
      {
        key: 'remove',
        value: function remove(value) {
          _get(_getPrototypeOf(ValueList.prototype), 'remove', this).call(
            this,
            this._validate(value)
          )

          return this
        }
      }
    ])

    return ValueList
  })(List)

  function _createSuper$1Y(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1Y()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1Y() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var Selector = /*#__PURE__*/ (function () {
    function Selector() {
      _classCallCheck(this, Selector)
    }

    _createClass(Selector, [
      {
        key: 'toString',
        value: function toString() {
          return this.keyword
        }
      },
      {
        key: 'toJSON',
        value: function toJSON() {
          return [this.name]
        }
      }
    ])

    return Selector
  })()

  Selector.prototype.name = 'Error'
  Selector.prototype.keyword = 'error'

  var ListSelector = /*#__PURE__*/ (function (_Selector) {
    _inherits(ListSelector, _Selector)

    var _super = _createSuper$1Y(ListSelector)

    function ListSelector(list) {
      var _this

      _classCallCheck(this, ListSelector)

      _this = _super.call(this)
      _this.list = list
      return _this
    }

    _createClass(ListSelector, [
      {
        key: 'toString',
        value: function toString() {
          return ''.concat(this.keyword, ' ').concat(this.list)
        }
      },
      {
        key: 'toJSON',
        value: function toJSON() {
          return [this.name, this.list.toJSON()]
        }
      }
    ])

    return ListSelector
  })(Selector)

  var RangeListSelector = /*#__PURE__*/ (function (_ListSelector) {
    _inherits(RangeListSelector, _ListSelector)

    var _super2 = _createSuper$1Y(RangeListSelector)

    function RangeListSelector(arg) {
      _classCallCheck(this, RangeListSelector)

      return _super2.call(this, new RangeList(arg))
    }

    return _createClass(RangeListSelector)
  })(ListSelector)

  var ValueListSelector = /*#__PURE__*/ (function (_ListSelector2) {
    _inherits(ValueListSelector, _ListSelector2)

    var _super3 = _createSuper$1Y(ValueListSelector)

    function ValueListSelector(arg, caseSensitive) {
      _classCallCheck(this, ValueListSelector)

      return _super3.call(this, new ValueList(arg, !caseSensitive))
    }

    return _createClass(ValueListSelector)
  })(ListSelector)

  var NoneSelector = /*#__PURE__*/ (function (_Selector2) {
    _inherits(NoneSelector, _Selector2)

    var _super4 = _createSuper$1Y(NoneSelector)

    function NoneSelector() {
      _classCallCheck(this, NoneSelector)

      return _super4.apply(this, arguments)
    }

    _createClass(NoneSelector, [
      {
        key: 'includesAtom',
        value: function includesAtom(_atom) {
          return false
        }
      }
    ])

    return NoneSelector
  })(Selector)

  NoneSelector.prototype.name = 'None'
  NoneSelector.prototype.keyword = 'none'

  var AllSelector = /*#__PURE__*/ (function (_Selector3) {
    _inherits(AllSelector, _Selector3)

    var _super5 = _createSuper$1Y(AllSelector)

    function AllSelector() {
      _classCallCheck(this, AllSelector)

      return _super5.apply(this, arguments)
    }

    _createClass(AllSelector, [
      {
        key: 'includesAtom',
        value: function includesAtom(_atom) {
          return true
        }
      }
    ])

    return AllSelector
  })(Selector)

  AllSelector.prototype.name = 'All'
  AllSelector.prototype.keyword = 'all'

  function _createSuper$1X(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1X()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1X() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var none = new NoneSelector()

  var PrefixOperator = /*#__PURE__*/ (function (_Selector) {
    _inherits(PrefixOperator, _Selector)

    var _super = _createSuper$1X(PrefixOperator)

    function PrefixOperator(rhs) {
      var _this

      _classCallCheck(this, PrefixOperator)

      _this = _super.call(this)
      _this.rhs = rhs || none
      return _this
    }

    _createClass(PrefixOperator, [
      {
        key: 'toString',
        value: function toString() {
          var rhs =
            this.rhs.priority && this.rhs.priority > this.priority
              ? '('.concat(this.rhs, ')')
              : this.rhs
          return ''.concat(this.keyword, ' ').concat(rhs)
        }
      },
      {
        key: 'toJSON',
        value: function toJSON() {
          return [this.name, this.rhs.toJSON()]
        }
      }
    ])

    return PrefixOperator
  })(Selector)

  PrefixOperator.prototype.priority = 1

  var InfixOperator = /*#__PURE__*/ (function (_Selector2) {
    _inherits(InfixOperator, _Selector2)

    var _super2 = _createSuper$1X(InfixOperator)

    function InfixOperator(lhs, rhs) {
      var _this2

      _classCallCheck(this, InfixOperator)

      _this2 = _super2.call(this)
      _this2.lhs = lhs || none
      _this2.rhs = rhs || none
      return _this2
    }

    _createClass(InfixOperator, [
      {
        key: 'toString',
        value: function toString() {
          var lhs =
            this.lhs.priority && this.lhs.priority > this.priority
              ? '('.concat(this.lhs, ')')
              : this.lhs
          var rhs =
            this.rhs.priority && this.rhs.priority > this.priority
              ? '('.concat(this.rhs, ')')
              : this.rhs
          return ''.concat(lhs, ' ').concat(this.keyword, ' ').concat(rhs)
        }
      },
      {
        key: 'toJSON',
        value: function toJSON() {
          return [this.name, this.lhs.toJSON(), this.rhs.toJSON()]
        }
      }
    ])

    return InfixOperator
  })(Selector)

  InfixOperator.prototype.priority = 1000

  function _createSuper$1W(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1W()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1W() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var keywords = {}

  function defineSelector(name, SelectorClass) {
    var keyword = name.toLowerCase()
    SelectorClass.prototype.keyword = keyword
    SelectorClass.prototype.name = name

    var factory = function factory() {
      for (
        var _len = arguments.length, args = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        args[_key] = arguments[_key]
      }

      return _construct(SelectorClass, args)
    }

    factory.SelectorClass = SelectorClass
    keywords[keyword] = factory
    return SelectorClass
  }

  defineSelector(
    'Serial',
    /*#__PURE__*/ (function (_RangeListSelector) {
      _inherits(SerialSelector, _RangeListSelector)

      var _super = _createSuper$1W(SerialSelector)

      function SerialSelector() {
        _classCallCheck(this, SerialSelector)

        return _super.apply(this, arguments)
      }

      _createClass(SerialSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.serial)
          }
        }
      ])

      return SerialSelector
    })(RangeListSelector)
  )
  defineSelector(
    'Name',
    /*#__PURE__*/ (function (_ValueListSelector) {
      _inherits(NameSelector, _ValueListSelector)

      var _super2 = _createSuper$1W(NameSelector)

      function NameSelector() {
        _classCallCheck(this, NameSelector)

        return _super2.apply(this, arguments)
      }

      _createClass(NameSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.name)
          }
        }
      ])

      return NameSelector
    })(ValueListSelector)
  )
  defineSelector(
    'AltLoc',
    /*#__PURE__*/ (function (_ValueListSelector2) {
      _inherits(AltLocSelector, _ValueListSelector2)

      var _super3 = _createSuper$1W(AltLocSelector)

      function AltLocSelector() {
        _classCallCheck(this, AltLocSelector)

        return _super3.apply(this, arguments)
      }

      _createClass(AltLocSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(String.fromCharCode(atom.location))
          }
        }
      ])

      return AltLocSelector
    })(ValueListSelector)
  )
  defineSelector(
    'Elem',
    /*#__PURE__*/ (function (_ValueListSelector3) {
      _inherits(ElemSelector, _ValueListSelector3)

      var _super4 = _createSuper$1W(ElemSelector)

      function ElemSelector() {
        _classCallCheck(this, ElemSelector)

        return _super4.apply(this, arguments)
      }

      _createClass(ElemSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.element.name)
          }
        }
      ])

      return ElemSelector
    })(ValueListSelector)
  )
  defineSelector(
    'Residue',
    /*#__PURE__*/ (function (_ValueListSelector4) {
      _inherits(ResidueSelector, _ValueListSelector4)

      var _super5 = _createSuper$1W(ResidueSelector)

      function ResidueSelector() {
        _classCallCheck(this, ResidueSelector)

        return _super5.apply(this, arguments)
      }

      _createClass(ResidueSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.residue._type._name)
          }
        }
      ])

      return ResidueSelector
    })(ValueListSelector)
  )
  defineSelector(
    'Sequence',
    /*#__PURE__*/ (function (_RangeListSelector2) {
      _inherits(SequenceSelector, _RangeListSelector2)

      var _super6 = _createSuper$1W(SequenceSelector)

      function SequenceSelector() {
        _classCallCheck(this, SequenceSelector)

        return _super6.apply(this, arguments)
      }

      _createClass(SequenceSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.residue._sequence)
          }
        }
      ])

      return SequenceSelector
    })(RangeListSelector)
  )
  defineSelector(
    'ICode',
    /*#__PURE__*/ (function (_ValueListSelector5) {
      _inherits(ICodeSelector, _ValueListSelector5)

      var _super7 = _createSuper$1W(ICodeSelector)

      function ICodeSelector(arg) {
        _classCallCheck(this, ICodeSelector)

        return _super7.call(this, arg, true)
      }

      _createClass(ICodeSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.residue._icode)
          }
        }
      ])

      return ICodeSelector
    })(ValueListSelector)
  )
  defineSelector(
    'ResIdx',
    /*#__PURE__*/ (function (_RangeListSelector3) {
      _inherits(ResIdxSelector, _RangeListSelector3)

      var _super8 = _createSuper$1W(ResIdxSelector)

      function ResIdxSelector() {
        _classCallCheck(this, ResIdxSelector)

        return _super8.apply(this, arguments)
      }

      _createClass(ResIdxSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.residue._index)
          }
        }
      ])

      return ResIdxSelector
    })(RangeListSelector)
  )
  defineSelector(
    'Chain',
    /*#__PURE__*/ (function (_ValueListSelector6) {
      _inherits(ChainSelector, _ValueListSelector6)

      var _super9 = _createSuper$1W(ChainSelector)

      function ChainSelector(arg) {
        _classCallCheck(this, ChainSelector)

        return _super9.call(this, arg, true)
      }

      _createClass(ChainSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.list.includes(atom.residue._chain._name)
          }
        }
      ])

      return ChainSelector
    })(ValueListSelector)
  )
  defineSelector(
    'Hetatm',
    /*#__PURE__*/ (function (_Selector) {
      _inherits(HetatmSelector, _Selector)

      var _super10 = _createSuper$1W(HetatmSelector)

      function HetatmSelector() {
        _classCallCheck(this, HetatmSelector)

        return _super10.apply(this, arguments)
      }

      _createClass(HetatmSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return atom.het
          }
        }
      ])

      return HetatmSelector
    })(Selector)
  )
  defineSelector(
    'PolarH',
    /*#__PURE__*/ (function (_Selector2) {
      _inherits(PolarHSelector, _Selector2)

      var _super11 = _createSuper$1W(PolarHSelector)

      function PolarHSelector() {
        _classCallCheck(this, PolarHSelector)

        return _super11.apply(this, arguments)
      }

      _createClass(PolarHSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return (
              (atom.flags & Atom$2.Flags.NONPOLARH) === Atom$2.Flags.HYDROGEN
            )
          }
        }
      ])

      return PolarHSelector
    })(Selector)
  )
  defineSelector(
    'NonPolarH',
    /*#__PURE__*/ (function (_Selector3) {
      _inherits(NonPolarHSelector, _Selector3)

      var _super12 = _createSuper$1W(NonPolarHSelector)

      function NonPolarHSelector() {
        _classCallCheck(this, NonPolarHSelector)

        return _super12.apply(this, arguments)
      }

      _createClass(NonPolarHSelector, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return (
              (atom.flags & Atom$2.Flags.NONPOLARH) === Atom$2.Flags.NONPOLARH
            )
          }
        }
      ])

      return NonPolarHSelector
    })(Selector)
  )
  defineSelector('All', AllSelector)
  defineSelector('None', NoneSelector)
  var NULL_SELECTOR = keywords.none()

  function defineOperator(name, priority, OperatorClass) {
    OperatorClass.prototype.priority = priority
    return defineSelector(name, OperatorClass)
  }

  defineOperator(
    'Not',
    1,
    /*#__PURE__*/ (function (_PrefixOperator) {
      _inherits(NotOperator, _PrefixOperator)

      var _super13 = _createSuper$1W(NotOperator)

      function NotOperator() {
        _classCallCheck(this, NotOperator)

        return _super13.apply(this, arguments)
      }

      _createClass(NotOperator, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return !this.rhs.includesAtom(atom)
          }
        }
      ])

      return NotOperator
    })(PrefixOperator)
  )
  defineOperator(
    'And',
    2,
    /*#__PURE__*/ (function (_InfixOperator) {
      _inherits(AndOperator, _InfixOperator)

      var _super14 = _createSuper$1W(AndOperator)

      function AndOperator() {
        _classCallCheck(this, AndOperator)

        return _super14.apply(this, arguments)
      }

      _createClass(AndOperator, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom)
          }
        }
      ])

      return AndOperator
    })(InfixOperator)
  )
  defineOperator(
    'Or',
    3,
    /*#__PURE__*/ (function (_InfixOperator2) {
      _inherits(OrOperator, _InfixOperator2)

      var _super15 = _createSuper$1W(OrOperator)

      function OrOperator() {
        _classCallCheck(this, OrOperator)

        return _super15.apply(this, arguments)
      }

      _createClass(OrOperator, [
        {
          key: 'includesAtom',
          value: function includesAtom(atom) {
            return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom)
          }
        }
      ])

      return OrOperator
    })(InfixOperator)
  )

  function byResidueTypeFlag(flag, name) {
    return defineSelector(
      name,
      /*#__PURE__*/ (function (_Selector4) {
        _inherits(_class, _Selector4)

        var _super16 = _createSuper$1W(_class)

        function _class() {
          _classCallCheck(this, _class)

          return _super16.apply(this, arguments)
        }

        _createClass(_class, [
          {
            key: 'includesAtom',
            value: function includesAtom(atom) {
              return (atom.residue._type.flags & flag) !== 0
            }
          }
        ])

        return _class
      })(Selector)
    )
  }

  byResidueTypeFlag(ResidueType$1.Flags.PROTEIN, 'Protein')
  byResidueTypeFlag(ResidueType$1.Flags.BASIC, 'Basic')
  byResidueTypeFlag(ResidueType$1.Flags.ACIDIC, 'Acidic')
  byResidueTypeFlag(
    ResidueType$1.Flags.BASIC | ResidueType$1.Flags.ACIDIC,
    'Charged'
  )
  byResidueTypeFlag(ResidueType$1.Flags.POLAR, 'Polar')
  byResidueTypeFlag(ResidueType$1.Flags.NONPOLAR, 'NonPolar')
  byResidueTypeFlag(ResidueType$1.Flags.AROMATIC, 'Aromatic')
  byResidueTypeFlag(ResidueType$1.Flags.NUCLEIC, 'Nucleic')
  byResidueTypeFlag(ResidueType$1.Flags.PURINE, 'Purine')
  byResidueTypeFlag(ResidueType$1.Flags.PYRIMIDINE, 'Pyrimidine')
  byResidueTypeFlag(ResidueType$1.Flags.WATER, 'Water')
  var selectors$5 = Object.create(keywords)
  selectors$5.Selector = Selector
  selectors$5.RangeListSelector = RangeListSelector
  selectors$5.ValueListSelector = ValueListSelector
  selectors$5.Range = Range
  selectors$5.RangeList = RangeList
  selectors$5.ValueList = ValueList
  selectors$5.PrefixOperator = PrefixOperator
  selectors$5.InfixOperator = InfixOperator
  selectors$5.Context = Object.create({})

  selectors$5.GetSelector = function (key) {
    if (!selectors$5.Context.hasOwnProperty(key)) {
      var exc = {
        message: 'selector '.concat(key, ' is not registered')
      }
      throw exc
    }

    return selectors$5.Context[key] || NULL_SELECTOR
  }

  selectors$5.ClearContext = function () {
    Object.keys(selectors$5.Context).forEach(function (k) {
      delete selectors$5.Context[k]
    })
  }

  selectors$5.keyword = function (key) {
    return keywords[key.toLowerCase()] || keywords.none
  }

  selectors$5.parse = function (str) {
    var res = {}

    try {
      res.selector = SelectionParser.parser.parse(str)
    } catch (e) {
      res.selector = NULL_SELECTOR
      res.error = e.message
    }

    return res
  }

  SelectionParser.parser.yy = selectors$5
  SelectionParser.parser.yy.parseError = SelectionParser.parser.parseError

  var BiologicalUnit = /*#__PURE__*/ (function () {
    function BiologicalUnit(complex) {
      _classCallCheck(this, BiologicalUnit)

      this._complex = complex
      this._selector = selectors$5.keyword('All')()
      this._boundaries = {
        boundingBox: new THREE__namespace.Box3(),
        boundingSphere: new THREE__namespace.Sphere()
      }
    }

    _createClass(BiologicalUnit, [
      {
        key: 'computeBoundaries',
        value: function computeBoundaries() {
          var atoms = this._complex._atoms
          var n = atoms.length
          var selector = this._selector
          var boundingBox = this._boundaries.boundingBox
          boundingBox.makeEmpty()

          if (n === 1) {
            boundingBox.expandByPoint(atoms[0].position)
            var bbc = new THREE__namespace.Vector3()
            boundingBox.getCenter(bbc)
            var s = 2 * atoms[0].element.radius
            boundingBox.setFromCenterAndSize(
              bbc,
              new THREE__namespace.Vector3(s, s, s)
            )
          } else {
            for (var i = 0; i < n; ++i) {
              if (selector.includesAtom(atoms[i])) {
                boundingBox.expandByPoint(atoms[i].position)
              }
            }
          }

          var radiusSquared = 0.0
          var center = new THREE__namespace.Vector3()
          boundingBox.getCenter(center)

          if (n === 1) {
            this._boundaries.boundingSphere.set(center, atoms[0].element.radius)
          } else {
            for (var _i = 0; _i < n; ++_i) {
              if (!selector.includesAtom(atoms[_i])) {
                continue
              }

              var pos = atoms[_i].position
              var lengthSquared = center.distanceToSquared(pos)

              if (radiusSquared < lengthSquared) {
                radiusSquared = lengthSquared
              }
            }

            this._boundaries.boundingSphere.set(
              center,
              Math.sqrt(radiusSquared)
            )
          }
        }
      },
      {
        key: 'getTransforms',
        value: function getTransforms() {
          return []
        }
      },
      {
        key: 'getSelector',
        value: function getSelector() {
          return this._selector
        }
      },
      {
        key: 'getBoundaries',
        value: function getBoundaries() {
          return this._boundaries
        }
      },
      {
        key: 'finalize',
        value: function finalize() {}
      }
    ])

    return BiologicalUnit
  })()

  function _createSuper$1V(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1V()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1V() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var Assembly$3 = /*#__PURE__*/ (function (_BiologicalUnit) {
    _inherits(Assembly, _BiologicalUnit)

    var _super = _createSuper$1V(Assembly)

    function Assembly(complex) {
      var _this

      _classCallCheck(this, Assembly)

      _this = _super.call(this, complex)
      _this.chains = []
      _this.matrices = []
      return _this
    }

    _createClass(Assembly, [
      {
        key: 'computeBoundaries',
        value: function computeBoundaries() {
          _get(
            _getPrototypeOf(Assembly.prototype),
            'computeBoundaries',
            this
          ).call(this)

          var matrices = this.matrices
          var oldCenter = this._boundaries.boundingSphere.center
          var oldRad = this._boundaries.boundingSphere.radius
          var boundingBox = (this._boundaries.boundingBox =
            new THREE__namespace.Box3())
          boundingBox.makeEmpty()

          for (var i = 0, n = matrices.length; i < n; ++i) {
            boundingBox.expandByPoint(
              oldCenter.clone().applyMatrix4(matrices[i])
            )
          }

          var newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad
          var center = new THREE__namespace.Vector3()
          boundingBox.getCenter(center)
          this._boundaries.boundingSphere = new THREE__namespace.Sphere().set(
            center,
            newRad
          )
          boundingBox.max.addScalar(oldRad)
          boundingBox.min.subScalar(oldRad)
        }
      },
      {
        key: 'addChain',
        value: function addChain(chain) {
          this.chains[this.chains.length] = chain
        }
      },
      {
        key: 'addMatrix',
        value: function addMatrix(matrix) {
          this.matrices[this.matrices.length] = matrix
        }
      },
      {
        key: 'getTransforms',
        value: function getTransforms() {
          return this.matrices
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          if (this.chains.length > 0) {
            this._selector = selectors$5.keyword('Chain')(this.chains)
          } else {
            this._selector = selectors$5.keyword('None')()
          }
        }
      }
    ])

    return Assembly
  })(BiologicalUnit)

  var Component = /*#__PURE__*/ (function () {
    function Component(complex) {
      _classCallCheck(this, Component)

      this._complex = complex
      this._index = -1
      this._residueIndices = []
      this._cycles = []
      this._subDivs = []
      this._residueCount = 0
    }

    _createClass(Component, [
      {
        key: 'getResidues',
        value: function getResidues() {
          return this._complex._residues
        }
      },
      {
        key: 'getResidueCount',
        value: function getResidueCount() {
          return this._residueCount
        }
      },
      {
        key: 'forEachResidue',
        value: function forEachResidue(process) {
          var residues = this._complex._residues
          var resIdc = this._residueIndices

          for (
            var idIdc = 0, idCount = resIdc.length;
            idIdc < idCount;
            ++idIdc
          ) {
            for (
              var idx = resIdc[idIdc].start, last = resIdc[idIdc].end;
              idx <= last;
              ++idx
            ) {
              process(residues[idx])
            }
          }
        }
      },
      {
        key: 'setSubDivs',
        value: function setSubDivs(subDivs) {
          this._subDivs = subDivs
          var curr = 0
          var resIdc = []
          var resCnt = 0

          for (var i = 0, n = subDivs.length; i < n; ++i) {
            if (i === n - 1 || subDivs[i].end + 1 !== subDivs[i + 1].start) {
              var start = subDivs[curr].start
              var end = subDivs[i].end
              resIdc[resIdc.length] = {
                start: start,
                end: end
              }
              resCnt += end - start + 1
              curr = i + 1
            }
          }

          this._residueIndices = resIdc
          this._residueCount = resCnt
        }
      },
      {
        key: 'getComplex',
        value: function getComplex() {
          return this._complex
        }
      },
      {
        key: 'forEachBond',
        value: function forEachBond(process) {
          var bonds = this._complex._bonds

          for (var i = 0, n = bonds.length; i < n; ++i) {
            var bond = bonds[i]

            if (bond._left.residue._component === this) {
              process(bond)
            }
          }
        }
      },
      {
        key: 'update',
        value: function update() {
          this.forEachCycle(function (cycle) {
            cycle.update()
          })
        }
      },
      {
        key: 'forEachAtom',
        value: function forEachAtom(process) {
          this.forEachResidue(function (residue) {
            residue.forEachAtom(process)
          })
        }
      },
      {
        key: 'addCycle',
        value: function addCycle(cycle) {
          this._cycles.push(cycle)
        }
      },
      {
        key: 'forEachCycle',
        value: function forEachCycle(process) {
          var cycles = this._cycles

          for (var i = 0, n = cycles.length; i < n; ++i) {
            process(cycles[i])
          }
        }
      },
      {
        key: 'markResidues',
        value: function markResidues() {
          var self = this
          self.forEachResidue(function (residue) {
            residue._component = self
          })
        }
      },
      {
        key: '_forEachSubChain',
        value: function _forEachSubChain(mask, process) {
          var residues = this._complex._residues
          var subs = this._subDivs

          for (var i = 0, n = subs.length; i < n; ++i) {
            for (
              var idx = subs[i].start, last = subs[i].end;
              idx <= last;
              ++idx
            ) {
              var currRes = residues[idx]

              if (mask & currRes._mask && currRes._isValid) {
                var end = idx + 1

                for (; end <= last; ++end) {
                  var endRes = residues[end]

                  if (!(mask & endRes._mask && endRes._isValid)) {
                    break
                  }
                }

                process(i, idx, end - 1)
                idx = end
              }
            }
          }
        }
      },
      {
        key: 'getMaskedSequences',
        value: function getMaskedSequences(mask) {
          var subs = []
          var idx = 0

          this._forEachSubChain(mask, function (_subIdx, start, end) {
            subs[idx++] = {
              start: start,
              end: end
            }
          })

          return subs
        }
      },
      {
        key: 'getMaskedSubdivSequences',
        value: function getMaskedSubdivSequences(mask) {
          var subs = []
          var currIdx = -1
          var lastSubIdx = -1
          var subDivs = this._subDivs

          this._forEachSubChain(mask, function (subIdx, start, end) {
            if (lastSubIdx !== subIdx) {
              ++currIdx
              subs[currIdx] = {
                arr: [],
                boundaries: subDivs[subIdx]
              }
              lastSubIdx = subIdx
            }

            subs[currIdx].arr[subs[currIdx].arr.length] = {
              start: start,
              end: end
            }
          })

          return subs
        }
      }
    ])

    return Component
  })()

  var cMaxPairsForHashCode = 32
  var cHashTableSize = 1024 * 1024
  var cNumbersPerPair = 4
  var cMaxNeighbours = 14
  var cInvalidVal = -1
  var cBigPrime = 89237

  var AtomPairs = /*#__PURE__*/ (function () {
    function AtomPairs(maxPairsEstimate) {
      _classCallCheck(this, AtomPairs)

      this.numPairs = 0
      this.numMaxPairs = maxPairsEstimate
      this.intBuffer = utils.allocateTyped(
        Int32Array,
        maxPairsEstimate * cNumbersPerPair
      )

      for (var i = 0; i < maxPairsEstimate * cNumbersPerPair; i++) {
        this.intBuffer[i] = cInvalidVal
      }

      this.hashBuffer = utils.allocateTyped(
        Int32Array,
        cHashTableSize * cMaxPairsForHashCode
      )

      for (var _i = 0; _i < cHashTableSize * cMaxPairsForHashCode; _i++) {
        this.hashBuffer[_i] = cInvalidVal
      }
    }

    _createClass(AtomPairs, [
      {
        key: 'destroy',
        value: function destroy() {
          this.intBuffer = null
          this.hashBuffer = null
        }
      },
      {
        key: 'addPair',
        value: function addPair(indexA, indexB) {
          var ia = indexA < indexB ? indexA : indexB
          var ib = indexA > indexB ? indexA : indexB
          var codeToAdd = ia + (ib << cMaxNeighbours)
          var hashCode = (ia + ib * cBigPrime) & (cHashTableSize - 1)
          var j = hashCode * cMaxPairsForHashCode
          var apI = 0

          for (; apI < cMaxPairsForHashCode; apI++) {
            var code = this.hashBuffer[j + apI]

            if (code === cInvalidVal) {
              break
            }

            if (code === codeToAdd) {
              return false
            }
          }

          if (apI >= cMaxPairsForHashCode) {
            throw new Error('addPair: increase cMaxPairsForHashCode')
          }

          this.hashBuffer[j + apI] = codeToAdd

          if (this.numPairs >= this.numMaxPairs) {
            throw new Error('addPair: increase num pairs')
          }

          j = this.numPairs * cNumbersPerPair
          this.intBuffer[j] = ia
          this.intBuffer[j + 1] = ib
          this.intBuffer[j + 2] = codeToAdd
          this.numPairs++
          return true
        }
      }
    ])

    return AtomPairs
  })()

  var cEstBondsMultiplier = 4
  var cSpaceCode = 32
  var cBondTolerance = 0.45
  var cEpsilon = 0.001

  function _getBondingRadius(atom) {
    var element = atom.element

    if (element) {
      return element.radiusBonding
    }

    throw new Error('_getBondingRadius: Logic error.')
  }

  function _isAtomEligible(atom) {
    return !atom.isHet() || (atom.bonds && atom.bonds.length === 0)
  }

  var AutoBond = /*#__PURE__*/ (function () {
    function AutoBond(complex) {
      _classCallCheck(this, AutoBond)

      this._complex = complex
      this._maxRad = 1.8

      var bBox = this._complex.getDefaultBoundaries().boundingBox

      this._vBoxMin = bBox.min.clone()
      this._vBoxMax = bBox.max.clone()
      this._pairCollection = null
    }

    _createClass(AutoBond, [
      {
        key: '_addExistingPairs',
        value: function _addExistingPairs() {
          var atoms = this._complex.getAtoms()

          var numAtoms = atoms.length
          var aInd = 0
          var collection = this._pairCollection

          for (; aInd < numAtoms; aInd++) {
            var bonds = atoms[aInd].bonds
            var numBondsForAtom = bonds.length

            for (var bInd = 0; bInd < numBondsForAtom; bInd++) {
              var bond = bonds[bInd]
              var indTo = bond._left.index

              if (indTo === aInd) {
                collection.addPair(aInd, bond._right.index)
              }
            }
          }

          return 0
        }
      },
      {
        key: '_findPairs',
        value: function _findPairs() {
          var vw = this._complex.getVoxelWorld()

          if (vw === null) {
            return
          }

          var atoms = this._complex._atoms
          var atomsNum = atoms.length
          var self = this
          var rA
          var isHydrogenA
          var posA
          var locationA
          var atomA

          var processAtom = function processAtom(atomB) {
            if (isHydrogenA && atomB.isHydrogen()) {
              return
            }

            var locationB = atomB.location

            if (
              locationA !== cSpaceCode &&
              locationB !== cSpaceCode &&
              locationA !== locationB
            ) {
              return
            }

            var dist2 = posA.distanceToSquared(atomB.position)
            var rB = atomB.element.radiusBonding
            var maxAcceptable = rA + rB + cBondTolerance

            if (dist2 > maxAcceptable * maxAcceptable) {
              return
            }

            if (dist2 < cEpsilon) {
              return
            }

            self._pairCollection.addPair(atomA.index, atomB.index)
          }

          for (var i = 0; i < atomsNum; ++i) {
            atomA = atoms[i]

            if (!_isAtomEligible(atomA)) {
              continue
            }

            rA = atomA.element.radiusBonding
            isHydrogenA = atomA.isHydrogen()
            posA = atomA.position
            locationA = atomA.location
            vw.forEachAtomWithinRadius(
              posA,
              2 * this._maxRad + cBondTolerance,
              processAtom
            )
          }
        }
      },
      {
        key: '_addPairs',
        value: function _addPairs() {
          var atoms = this._complex._atoms

          for (
            var i = 0, k = 0;
            i < this._pairCollection.numPairs;
            i++, k += 4
          ) {
            var iA = this._pairCollection.intBuffer[k]
            var iB = this._pairCollection.intBuffer[k + 1]

            this._addPair(atoms[iA], atoms[iB])
          }
        }
      },
      {
        key: '_addPair',
        value: function _addPair(atomA, atomB) {
          var bondsA = atomA.bonds
          var indexA = atomA.index
          var indexB = atomB.index

          for (var j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
            var bond = bondsA[j]

            if (bond._left.index === indexB || bond._right.index === indexB) {
              return
            }
          }

          var left = indexA < indexB ? atomA : atomB
          var right = indexA < indexB ? atomB : atomA

          var newBond = this._complex.addBond(
            left,
            right,
            0,
            Bond$5.BondType.UNKNOWN,
            false
          )

          bondsA.push(newBond)
          atomB.bonds.push(newBond)
        }
      },
      {
        key: 'build',
        value: function build() {
          this._buildInner()
        }
      },
      {
        key: '_buildInner',
        value: function _buildInner() {
          var atoms = this._complex._atoms

          if (atoms.length < 2) {
            return
          }

          if (atoms[0].index < 0) {
            throw new Error('AutoBond: Atoms in complex were not indexed.')
          }

          this._calcBoundingBox()

          this._pairCollection = new AtomPairs(
            atoms.length * cEstBondsMultiplier
          )

          this._addExistingPairs()

          this._findPairs()

          this._addPairs()
        }
      },
      {
        key: '_calcBoundingBox',
        value: function _calcBoundingBox() {
          var atoms = this._complex._atoms
          var nAtoms = atoms.length

          var maxRad = _getBondingRadius(atoms[0])

          for (var i = 1; i < nAtoms; ++i) {
            maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]))
          }

          this._vBoxMax.addScalar(maxRad)

          this._vBoxMin.addScalar(-maxRad)

          this._maxRad = maxRad * 1.2
        }
      },
      {
        key: 'destroy',
        value: function destroy() {
          if (this._pairCollection) {
            this._pairCollection.destroy()
          }
        }
      }
    ])

    return AutoBond
  })()

  var cCrossThresh = 0.1
  var cAromaticType = Bond$5.BondType.AROMATIC
  var cAromaticAtoms = [Element$a.ByName.C.number, Element$a.ByName.N.number]

  var _coDirVectors = (function () {
    var v1Tmp = new THREE__namespace.Vector3()
    var v2Tmp = new THREE__namespace.Vector3()
    var cp = new THREE__namespace.Vector3()
    return function (v1, v2) {
      v1Tmp.copy(v1).normalize()
      v2Tmp.copy(v2).normalize()
      cp.crossVectors(v1Tmp, v2Tmp)

      if (cp.length() > cCrossThresh) {
        return false
      }

      return v1Tmp.dot(v2Tmp) >= 0
    }
  })()

  function _insertAscending(arr, val) {
    var idx = 0

    while (idx < arr.length && arr[idx] < val) {
      ++idx
    }

    arr.splice(idx, 0, val)
  }

  function _anotherAtom(bond, currAtom) {
    return bond._left === currAtom ? bond._right : bond._left
  }

  function _cosBetween(v1, v2) {
    var theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq())
    return THREE__namespace.MathUtils.clamp(theta, -1, 1)
  }

  function _markAromatic(bond) {
    bond._type = cAromaticType
  }

  var Cycle = /*#__PURE__*/ (function () {
    function Cycle(atomsList) {
      _classCallCheck(this, Cycle)

      this.atoms = atomsList
      this.update()
    }

    _createClass(Cycle, [
      {
        key: 'update',
        value: function update() {
          var atoms = this.atoms
          var center = new THREE__namespace.Vector3()
          var nA = atoms.length

          for (var j = 0; j < nA; ++j) {
            center.add(atoms[j].position)
          }

          center.multiplyScalar(1.0 / nA)
          this.center = center
          this.radius = center.distanceTo(
            atoms[0].position.clone().lerp(atoms[1].position, 0.5)
          )
        }
      },
      {
        key: 'forEachBond',
        value: function forEachBond(process) {
          var atoms = this.atoms
          var nA = atoms.length
          var currAtom = atoms[0]
          var nextAtom

          function checkBond(bond) {
            if (bond._left === nextAtom || bond._right === nextAtom) {
              process(bond)
            }
          }

          for (var i = 0; i < nA; ++i) {
            nextAtom = atoms[(i + 1) % nA]
            currAtom.forEachBond(checkBond)
            currAtom = nextAtom
          }
        }
      }
    ])

    return Cycle
  })()

  function _isAromatic(bond) {
    return bond._type === cAromaticType
  }

  function _isPossibleAromatic(bond) {
    if (bond.type === cAromaticType) {
      return true
    }

    var rightIdx = cAromaticAtoms.indexOf(bond._right.element.number)
    var leftIdx = cAromaticAtoms.indexOf(bond._left.element.number)
    return rightIdx !== -1 && leftIdx !== -1
  }

  function _checkCycleSimple(cycle) {
    return cycle.length > 3
  }

  function _checkCycleComplex(cycle) {
    console.assert(cycle.length > 2)
    return true
  }

  var AromaticLoopsMarker = /*#__PURE__*/ (function () {
    function AromaticLoopsMarker(complex) {
      _classCallCheck(this, AromaticLoopsMarker)

      this._complex = complex
      var bondsData = new Array(complex._bonds.length)
      var bondMarks = new Array(complex._bonds.length)

      for (var i = 0, n = bondsData.length; i < n; ++i) {
        bondsData[i] = []
        bondMarks[i] = false
      }

      this._bondsData = bondsData
      this._bondMarks = bondMarks

      this._resetCycles()
    }

    _createClass(AromaticLoopsMarker, [
      {
        key: '_resetCycles',
        value: function _resetCycles() {
          this._cycles = []
          this._currIdx = -1
        }
      },
      {
        key: '_haveSameCycle',
        value: function _haveSameCycle(bondsData, bond1, bond2) {
          var arr1 = bondsData[bond1._index]
          var arr2 = bondsData[bond2._index]
          var n1 = arr1.length
          var n2 = arr2.length
          var i1 = 0
          var i2 = 0

          while (i1 < n1 && i2 < n2) {
            if (arr1[i1] === arr2[i2]) {
              return true
            }

            if (arr1[i1] > arr2[i2]) {
              ++i2
            } else {
              ++i1
            }
          }

          return false
        }
      },
      {
        key: '_tryBond',
        value: function _tryBond(prevBond, currRight, currDir) {
          var bondsOrder = []
          var bondsData = this._bondsData

          var currLeft = _anotherAtom(prevBond, currRight)

          var currVec = currRight.position.clone().sub(currLeft.position)
          var startAtomRef = this._currStart
          var self = this
          var bondMarks = this._bondMarks
          var checkAromatic = this._checkBond
          bondMarks[prevBond._index] = true
          checkAromatic =
            checkAromatic === undefined ? _isAromatic : checkAromatic
          currRight.forEachBond(function (newBond) {
            if (
              !checkAromatic(newBond) ||
              newBond === prevBond ||
              bondMarks[newBond._index] ||
              self._haveSameCycle(bondsData, prevBond, newBond)
            ) {
              return
            }

            var anotherAtom = _anotherAtom(newBond, currRight)

            var anotherVec = anotherAtom.position
              .clone()
              .sub(currRight.position)
            var val =
              anotherAtom === startAtomRef
                ? -2.0
                : 1 - _cosBetween(currVec, anotherVec)
            var newDir = anotherVec.cross(currVec)

            if (!_coDirVectors(newDir, currDir)) {
              return
            }

            var idx = 0

            while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
              ++idx
            }

            bondsOrder.splice(idx, 0, {
              bond: newBond,
              val: val,
              dir: newDir
            })
          })

          for (var i = 0, n = bondsOrder.length; i < n; ++i) {
            var bond = bondsOrder[i].bond
            var newRight = bond._left === currRight ? bond._right : bond._left

            if (newRight === startAtomRef) {
              ++this._currIdx

              this._cycles.push([currRight])

              bondMarks[prevBond._index] = false
              return true
            }

            if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
              _insertAscending(bondsData[bond._index], this._currIdx)

              this._cycles[this._currIdx].push(currRight)

              bondMarks[prevBond._index] = false
              return true
            }
          }

          bondMarks[prevBond._index] = false
          return false
        }
      },
      {
        key: '_startCycle',
        value: function _startCycle(bond) {
          this._currStart = bond._left

          if (
            this._tryBond(bond, bond._right, new THREE__namespace.Vector3())
          ) {
            _insertAscending(this._bondsData[bond._index], this._currIdx)

            this._cycles[this._currIdx].push(bond._left)
          }
        }
      },
      {
        key: '_findLoops',
        value: function _findLoops(checkBond, checkCycle) {
          this._checkBond = checkBond
          var complex = this._complex
          var self = this
          complex.forEachComponent(function (component) {
            self._resetCycles()

            component.forEachBond(function (bond) {
              if (checkBond(bond)) {
                self._startCycle(bond)
              }
            })
            var cycles = self._cycles

            for (var i = 0, n = cycles.length; i < n; ++i) {
              var cycle = cycles[i]

              if (!checkCycle(cycle)) {
                continue
              }

              var newCycle = new Cycle(cycle)
              newCycle.forEachBond(_markAromatic)
              component.addCycle(newCycle)
            }
          })
        }
      },
      {
        key: 'markCycles',
        value: function markCycles() {
          this._findLoops(_isAromatic, _checkCycleSimple)
        }
      },
      {
        key: 'detectCycles',
        value: function detectCycles() {
          this._findLoops(_isPossibleAromatic, _checkCycleComplex)
        }
      }
    ])

    return AromaticLoopsMarker
  })()

  function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
    var dzMin = zMin - center.z
    var dzMax = zMax - center.z
    var rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0.0))
    var rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0.0))
    var rMin = Math.min(rzMin, rzMax)
    var rMax

    if (zMin <= center.z && zMax >= center.z) {
      rMax = radius
    } else {
      rMax = Math.max(rzMin, rzMax)
    }

    return [rMin, rMax]
  }

  function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
    var dyMin = yMin - center.y
    var dyMax = yMax - center.y
    var ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0.0))
    var ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0.0))
    var rMin = Math.min(ryMin, ryMax)
    var rMax

    if (yMin <= center.y && yMax >= center.y) {
      rMax = radius
    } else {
      rMax = Math.max(ryMin, ryMax)
    }

    return [rMin, rMax]
  }

  var VoxelWorld = /*#__PURE__*/ (function () {
    function VoxelWorld(box, vCellSizeHint) {
      _classCallCheck(this, VoxelWorld)

      this._box = box.clone()
      var size = new THREE__namespace.Vector3()
      box.getSize(size)
      this._count = size
        .clone()
        .divide(vCellSizeHint)
        .floor()
        .max(new THREE__namespace.Vector3(1, 1, 1))
      this._last = this._count.clone().subScalar(1)
      this._cellSize = size.clone().divide(this._count)
      this._cellInnerR =
        0.5 *
        Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z)
      this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize))
      var numVoxels = this._count.x * this._count.y * this._count.z
      this._voxels = utils.allocateTyped(Int32Array, numVoxels)

      for (var i = 0; i < numVoxels; ++i) {
        this._voxels[i] = -1
      }

      this._atoms = []
    }

    _createClass(VoxelWorld, [
      {
        key: 'addAtoms',
        value: function addAtoms(complex) {
          var self = this
          var idx = this._atoms.length
          this._atoms.length += 2 * complex.getAtomCount()
          complex.forEachAtom(function (atom) {
            var voxelIdx = self._findVoxel(atom.position)

            self._atoms[idx] = atom
            self._atoms[idx + 1] = self._voxels[voxelIdx]
            self._voxels[voxelIdx] = idx
            idx += 2
          })
        }
      },
      {
        key: '_findVoxel',
        value: function _findVoxel(point) {
          var zero = VoxelWorld._zero
          var voxel = VoxelWorld._voxel
          voxel
            .copy(point)
            .sub(this._box.min)
            .divide(this._cellSize)
            .floor()
            .clamp(zero, this._last)
          return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z)
        }
      },
      {
        key: '_forEachAtomInVoxel',
        value: function _forEachAtomInVoxel(voxel, process) {
          for (var i = this._voxels[voxel]; i >= 0; i = this._atoms[i + 1]) {
            process(this._atoms[i])
          }
        }
      },
      {
        key: '_forEachVoxelWithinRadius',
        value: function _forEachVoxelWithinRadius(center, radius, process) {
          var xRange = VoxelWorld._xRange
          var yRange = VoxelWorld._yRange
          var zRange = VoxelWorld._zRange

          if (radius / this._cellInnerR < 10) {
            this._forEachVoxelWithinRadiusSimple(center, radius, process)

            return
          }

          var rRangeXY
          var rRangeX
          var xVal
          var yVal
          var zVal
          var isInsideX
          var isInsideY
          var isInsideZ
          zRange.set(center.z - radius, center.z + radius)
          zRange
            .subScalar(this._box.min.z)
            .divideScalar(this._cellSize.z)
            .floor()
            .clampScalar(0, this._count.z - 1)

          for (var z = zRange.x; z <= zRange.y; ++z) {
            zVal = [
              this._box.min.z + z * this._cellSize.z,
              this._box.min.z + (z + 1) * this._cellSize.z
            ]
            isInsideZ =
              center.z - radius <= zVal[0] && zVal[1] <= center.z + radius
            rRangeXY = _getSphereSliceRadiusRange(
              center,
              radius,
              zVal[0],
              zVal[1]
            )
            yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1])
            yRange
              .subScalar(this._box.min.y)
              .divideScalar(this._cellSize.y)
              .floor()
              .clampScalar(0, this._count.y - 1)

            for (var y = yRange.x; y <= yRange.y; ++y) {
              yVal = [
                this._box.min.y + y * this._cellSize.y,
                this._box.min.y + (y + 1) * this._cellSize.y
              ]
              isInsideY =
                center.y - rRangeXY[0] <= yVal[0] &&
                yVal[1] <= center.y + rRangeXY[0]
              rRangeX = _getCircleSliceRadiusRange(
                center,
                rRangeXY[1],
                yVal[0],
                yVal[1]
              )
              xRange.set(center.x - rRangeX[1], center.x + rRangeX[1])
              xRange
                .subScalar(this._box.min.x)
                .divideScalar(this._cellSize.x)
                .floor()
                .clampScalar(0, this._count.x - 1)

              for (var x = xRange.x; x <= xRange.y; ++x) {
                xVal = [
                  this._box.min.x + x * this._cellSize.x,
                  this._box.min.x + (x + 1) * this._cellSize.x
                ]
                isInsideX =
                  center.x - rRangeX[0] <= xVal[0] &&
                  xVal[1] <= center.x + rRangeX[0]
                process(
                  x + this._count.x * (y + this._count.y * z),
                  isInsideX && isInsideY && isInsideZ
                )
              }
            }
          }
        }
      },
      {
        key: '_forEachVoxelWithinRadiusSimple',
        value: function _forEachVoxelWithinRadiusSimple(
          center,
          radius,
          process
        ) {
          var xRange = VoxelWorld._xRange
          var yRange = VoxelWorld._yRange
          var zRange = VoxelWorld._zRange
          var vCenter = VoxelWorld._vCenter
          var distTouch2 =
            (radius + this._cellOuterR) * (radius + this._cellOuterR)
          var distInside2 = -1.0

          if (radius > this._cellOuterR) {
            distInside2 =
              (radius - this._cellOuterR) * (radius - this._cellOuterR)
          }

          xRange.set(center.x - radius, center.x + radius)
          xRange
            .subScalar(this._box.min.x)
            .divideScalar(this._cellSize.x)
            .floor()
          xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1)
          xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1)
          yRange.set(center.y - radius, center.y + radius)
          yRange
            .subScalar(this._box.min.y)
            .divideScalar(this._cellSize.y)
            .floor()
          yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1)
          yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1)
          zRange.set(center.z - radius, center.z + radius)
          zRange
            .subScalar(this._box.min.z)
            .divideScalar(this._cellSize.z)
            .floor()
          zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1)
          zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1)

          for (var z = zRange.x; z <= zRange.y; ++z) {
            var zVal = [
              this._box.min.z + z * this._cellSize.z,
              this._box.min.z + (z + 1) * this._cellSize.z
            ]
            vCenter.z = 0.5 * (zVal[0] + zVal[1])

            for (var y = yRange.x; y <= yRange.y; ++y) {
              var yVal = [
                this._box.min.y + y * this._cellSize.y,
                this._box.min.y + (y + 1) * this._cellSize.y
              ]
              vCenter.y = 0.5 * (yVal[0] + yVal[1])

              for (var x = xRange.x; x <= xRange.y; ++x) {
                var xVal = [
                  this._box.min.x + x * this._cellSize.x,
                  this._box.min.x + (x + 1) * this._cellSize.x
                ]
                vCenter.x = 0.5 * (xVal[0] + xVal[1])
                var d2 = center.distanceToSquared(vCenter)

                if (d2 <= distTouch2) {
                  process(
                    x + this._count.x * (y + this._count.y * z),
                    d2 <= distInside2
                  )
                }
              }
            }
          }
        }
      },
      {
        key: 'forEachAtomWithinRadius',
        value: function forEachAtomWithinRadius(center, radius, process) {
          var self = this
          var r2 = radius * radius

          self._forEachVoxelWithinRadius(
            center,
            radius,
            function (voxel, isInside) {
              if (isInside) {
                self._forEachAtomInVoxel(voxel, process)
              } else {
                self._forEachAtomInVoxel(voxel, function (atom) {
                  if (center.distanceToSquared(atom.position) <= r2) {
                    process(atom)
                  }
                })
              }
            }
          )
        }
      },
      {
        key: 'forEachAtomWithinDistFromMasked',
        value: function forEachAtomWithinDistFromMasked(
          complex,
          mask,
          dist,
          process
        ) {
          this._forEachAtomWithinDistFromGroup(
            function (atomProc) {
              complex.forEachAtom(function (atom) {
                if ((atom.mask & mask) !== 0) {
                  atomProc(atom)
                }
              })
            },
            dist,
            process
          )
        }
      },
      {
        key: 'forEachAtomWithinDistFromSelected',
        value: function forEachAtomWithinDistFromSelected(
          complex,
          selector,
          dist,
          process
        ) {
          this._forEachAtomWithinDistFromGroup(
            function (atomProc) {
              complex.forEachAtom(function (atom) {
                if (selector.includesAtom(atom)) {
                  atomProc(atom)
                }
              })
            },
            dist,
            process
          )
        }
      },
      {
        key: '_forEachAtomWithinDistFromGroup',
        value: function _forEachAtomWithinDistFromGroup(
          forEachAtom,
          dist,
          process
        ) {
          var self = this
          var r2 = dist * dist
          var voxels = []
          var atoms = []
          var idx = 0
          forEachAtom(function (atom) {
            self._forEachVoxelWithinRadius(
              atom.position,
              dist,
              function (voxel, isInside) {
                if (isInside) {
                  voxels[voxel] = -1
                } else if (typeof voxels[voxel] === 'undefined') {
                  atoms.push(atom)
                  atoms.push(-1)
                  voxels[voxel] = idx
                  idx += 2
                } else if (voxels[voxel] !== -1) {
                  atoms.push(atom)
                  atoms.push(voxels[voxel])
                  voxels[voxel] = idx
                  idx += 2
                }
              }
            )
          })
          var voxel

          var processIfWithin = function processIfWithin(atom) {
            if (typeof voxels[voxel] === 'undefined') {
              return
            }

            idx = voxels[voxel]

            if (idx === -1) {
              process(atom)
              return
            }

            for (; idx >= 0; idx = atoms[idx + 1]) {
              if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
                process(atom)
                break
              }
            }
          }

          for (voxel in voxels) {
            if (voxels.hasOwnProperty(voxel)) {
              self._forEachAtomInVoxel(voxel, processIfWithin)
            }
          }
        }
      }
    ])

    return VoxelWorld
  })()

  _defineProperty(VoxelWorld, '_zero', new THREE__namespace.Vector3(0, 0, 0))

  _defineProperty(VoxelWorld, '_voxel', new THREE__namespace.Vector3())

  _defineProperty(VoxelWorld, '_xRange', new THREE__namespace.Vector2())

  _defineProperty(VoxelWorld, '_yRange', new THREE__namespace.Vector2())

  _defineProperty(VoxelWorld, '_zRange', new THREE__namespace.Vector2())

  _defineProperty(VoxelWorld, '_vCenter', new THREE__namespace.Vector3())

  var MINIMAL_DISTANCE = 0.5
  var MIN_HBOND_ENERGY = -9.9
  var MAX_HBOND_ENERGY = -0.5
  var COUPLING_CONSTANT = -27.888
  var MAX_COUPLING_DISTANCE = 5.0
  var MAX_RESIDUES_THRESHOLD = 1000

  var HBondInfo = /*#__PURE__*/ (function () {
    function HBondInfo(complex) {
      _classCallCheck(this, HBondInfo)

      this._complex = complex
      this._hbonds = []

      if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
        this._buildVW()
      } else {
        this._build()
      }
    }

    _createClass(HBondInfo, [
      {
        key: 'isBond',
        value: function isBond(from, to) {
          if (this._hbonds[from]) {
            var _this$_hbonds$from$ac = _slicedToArray(
                this._hbonds[from].acceptor,
                2
              ),
              acc0 = _this$_hbonds$from$ac[0],
              acc1 = _this$_hbonds$from$ac[1]

            if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
              return true
            }

            if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
              return true
            }
          }

          return false
        }
      },
      {
        key: '_build',
        value: function _build() {
          var self = this

          for (var i = 0; i < this._complex._residues.length - 1; ++i) {
            var ri = this._complex._residues[i]

            if ((ri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
              continue
            }

            var preri = null

            if (
              i > 0 &&
              this._complex._residues[i - 1].getType().flags &
                ResidueType$1.Flags.PROTEIN &&
              ri._sequence === this._complex._residues[i - 1]._sequence + 1
            ) {
              preri = this._complex._residues[i - 1]
            }

            for (var j = i + 1; j < this._complex._residues.length; ++j) {
              var rj = this._complex._residues[j]

              if ((rj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
                continue
              }

              var prerj = null

              if (
                this._complex._residues[j - 1].getType().flags &
                  ResidueType$1.Flags.PROTEIN &&
                rj._sequence === this._complex._residues[j - 1]._sequence + 1
              ) {
                prerj = this._complex._residues[j - 1]
              }

              self._calcHBondEnergy(preri, ri, rj)

              if (j !== i + 1) {
                self._calcHBondEnergy(prerj, rj, ri)
              }
            }
          }
        }
      },
      {
        key: '_buildVW',
        value: function _buildVW() {
          var self = this
          var residues = this._complex._residues
          var ri
          var preri

          var vw = this._complex.getVoxelWorld()

          if (vw === null) {
            return
          }

          var pairs = new AtomPairs(
            (this._complex._residues.length * this._complex._residues.length) /
              2
          )

          function processAtom(atom) {
            var rj = atom.residue

            if (rj._index === ri._index) {
              return
            }

            if ((rj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
              return
            }

            if (!pairs.addPair(ri._index, rj._index)) {
              return
            }

            var prerj = rj._index > 0 ? residues[rj._index - 1] : null

            if (
              prerj &&
              ((prerj.getType().flags & ResidueType$1.Flags.PROTEIN) === 0 ||
                rj._sequence !== prerj._sequence + 1)
            ) {
              prerj = null
            }

            self._calcHBondEnergy(preri, ri, rj)

            if (rj._index !== ri._index + 1) {
              self._calcHBondEnergy(prerj, rj, ri)
            }
          }

          for (var i = 0; i < residues.length - 1; ++i) {
            ri = residues[i]

            if ((ri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0) {
              continue
            }

            preri = i > 0 ? residues[i - 1] : null

            if (
              preri &&
              ((preri.getType().flags & ResidueType$1.Flags.PROTEIN) === 0 ||
                ri._sequence !== preri._sequence + 1)
            ) {
              preri = null
            }

            vw.forEachAtomWithinRadius(
              this._residueGetCAlpha(ri),
              MAX_COUPLING_DISTANCE,
              processAtom
            )
          }
        }
      },
      {
        key: '_residueGetCAlpha',
        value: function _residueGetCAlpha(res) {
          for (var i = 0; i < res._atoms.length; ++i) {
            var name = res._atoms[i].name

            if (name === 'CA' || name === 'C1') {
              return res._atoms[i].position
            }
          }

          return null
        }
      },
      {
        key: '_residueGetCO',
        value: function _residueGetCO(res) {
          var c = null
          var o = null
          res.forEachAtom(function (a) {
            if (a.name === 'C') {
              c = a.position
            } else if (a.name === 'O') {
              o = a.position
            }
          })
          return [c, o]
        }
      },
      {
        key: '_residueGetNH',
        value: function _residueGetNH(prev, res) {
          var _this$_residueGetCO = this._residueGetCO(prev),
            _this$_residueGetCO2 = _slicedToArray(_this$_residueGetCO, 2),
            c = _this$_residueGetCO2[0],
            o = _this$_residueGetCO2[1]

          var n
          res.forEachAtom(function (a) {
            if (a.name === 'N') {
              n = a.position
            }
          })

          if (c && o && n) {
            var h = c.clone()
            h.sub(o)
            h.multiplyScalar(1.0 / h.length())
            h.add(n)
            return [n, h]
          }

          return [null, null]
        }
      },
      {
        key: '_calcHBondEnergy',
        value: function _calcHBondEnergy(predonor, donor, acceptor) {
          var result = 0

          if (predonor === null) {
            return result
          }

          if (donor.getType().getName() !== 'PRO') {
            var _this$_residueGetNH = this._residueGetNH(predonor, donor),
              _this$_residueGetNH2 = _slicedToArray(_this$_residueGetNH, 2),
              n = _this$_residueGetNH2[0],
              h = _this$_residueGetNH2[1]

            var _this$_residueGetCO3 = this._residueGetCO(acceptor),
              _this$_residueGetCO4 = _slicedToArray(_this$_residueGetCO3, 2),
              c = _this$_residueGetCO4[0],
              o = _this$_residueGetCO4[1]

            if (n === null || h === null || c === null || o === null) {
              return result
            }

            var distanceHO = h.distanceTo(o)
            var distanceHC = h.distanceTo(c)
            var distanceNC = n.distanceTo(c)
            var distanceNO = n.distanceTo(o)

            if (
              distanceHO < MINIMAL_DISTANCE ||
              distanceHC < MINIMAL_DISTANCE ||
              distanceNC < MINIMAL_DISTANCE ||
              distanceNO < MINIMAL_DISTANCE
            ) {
              result = MIN_HBOND_ENERGY
            } else {
              result =
                COUPLING_CONSTANT / distanceHO -
                COUPLING_CONSTANT / distanceHC +
                COUPLING_CONSTANT / distanceNC -
                COUPLING_CONSTANT / distanceNO
            }

            result = Math.round(result * 1000) / 1000

            if (result < MIN_HBOND_ENERGY) {
              result = MIN_HBOND_ENERGY
            }
          }

          if (typeof this._hbonds[donor._index] === 'undefined') {
            this._hbonds[donor._index] = {
              donor: [],
              acceptor: []
            }
          }

          var donorInfo = this._hbonds[donor._index]

          if (donorInfo.acceptor.length < 2) {
            donorInfo.acceptor.push({
              residue: acceptor._index,
              energy: result
            })
          }

          if (donorInfo.acceptor.length > 1) {
            if (result < donorInfo.acceptor[0].energy) {
              donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue
              donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy
              donorInfo.acceptor[0].residue = acceptor._index
              donorInfo.acceptor[0].energy = result
            } else if (result < donorInfo.acceptor[1].energy) {
              donorInfo.acceptor[1].residue = acceptor._index
              donorInfo.acceptor[1].energy = result
            }
          }

          if (typeof this._hbonds[acceptor._index] === 'undefined') {
            this._hbonds[acceptor._index] = {
              donor: [],
              acceptor: []
            }
          }

          var accInfo = this._hbonds[acceptor._index]

          if (accInfo.donor.length < 2) {
            accInfo.donor.push({
              residue: donor._index,
              energy: result
            })
          }

          if (accInfo.donor.length > 1) {
            if (result < accInfo.donor[0].energy) {
              accInfo.donor[1].residue = accInfo.donor[0].residue
              accInfo.donor[1].energy = accInfo.donor[0].energy
              accInfo.donor[0].residue = donor._index
              accInfo.donor[0].energy = result
            } else if (result < accInfo.donor[1].energy) {
              accInfo.donor[1].residue = donor._index
              accInfo.donor[1].energy = result
            }
          }

          return result
        }
      }
    ])

    return HBondInfo
  })()

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it =
      (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator']
    if (!it) {
      if (
        Array.isArray(o) ||
        (it = _unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === 'number')
      ) {
        if (it) o = it
        var i = 0
        var F = function F() {}
        return {
          s: F,
          n: function n() {
            if (i >= o.length) return { done: true }
            return { done: false, value: o[i++] }
          },
          e: function e(_e) {
            throw _e
          },
          f: F
        }
      }
      throw new TypeError(
        'Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
      )
    }
    var normalCompletion = true,
      didErr = false,
      err
    return {
      s: function s() {
        it = it.call(o)
      },
      n: function n() {
        var step = it.next()
        normalCompletion = step.done
        return step
      },
      e: function e(_e2) {
        didErr = true
        err = _e2
      },
      f: function f() {
        try {
          if (!normalCompletion && it.return != null) it.return()
        } finally {
          if (didErr) throw err
        }
      }
    }
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return
    if (typeof o === 'string') return _arrayLikeToArray(o, minLen)
    var n = Object.prototype.toString.call(o).slice(8, -1)
    if (n === 'Object' && o.constructor) n = o.constructor.name
    if (n === 'Map' || n === 'Set') return Array.from(o)
    if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen)
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i]
    }
    return arr2
  }
  var BridgeType = Object.freeze({
    NO_BRIDGE: 0,
    PARALLEL: 1,
    ANTI_PARALLEL: 2
  })
  var HelixFlag = Object.freeze({
    START: 1,
    MIDDLE: 2,
    END: 3,
    START_AND_END: 4
  })
  var StructureType$1 = Object.freeze({
    STRAND: 'E',
    BRIDGE: 'B',
    HELIX_310: 'G',
    HELIX_ALPHA: 'H',
    HELIX_PI: 'I',
    TURN: 'T',
    BEND: 'S',
    LOOP: ' '
  })

  var SecondaryStructureMap = /*#__PURE__*/ (function () {
    function SecondaryStructureMap(complex) {
      _classCallCheck(this, SecondaryStructureMap)

      this._complex = complex

      this._build()
    }

    _createClass(SecondaryStructureMap, [
      {
        key: '_build',
        value: function _build() {
          var self = this
          this._hbonds = new HBondInfo(this._complex)
          this._ss = []
          this._sheet = []
          this._betaPartners = []
          this._bend = []

          for (var i = 0; i < this._complex.getResidues().length; ++i) {
            this._betaPartners[i] = []
          }

          this._helixFlags = []
          this._helixFlags[3] = []
          this._helixFlags[4] = []
          this._helixFlags[5] = []
          this._chainLengths = []

          for (var _i = 0; _i < this._complex._chains.length; ++_i) {
            var chain = this._complex._chains[_i].getResidues()

            var len = 0

            for (; len < chain.length; ++len) {
              if (
                (chain[len].getType().flags & ResidueType$1.Flags.PROTEIN) ===
                0
              ) {
                break
              }
            }

            this._chainLengths[_i] = len
          }

          this._buildBetaSheets()

          for (var _i2 = 0; _i2 < this._complex._chains.length; ++_i2) {
            self._buildAlphaHelices(
              this._complex._chains[_i2].getResidues(),
              this._chainLengths[_i2],
              false
            )
          }
        }
      },
      {
        key: '_buildAlphaHelices',
        value: function _buildAlphaHelices(
          inResidues,
          chainLength,
          inPreferPiHelices
        ) {
          for (var stride = 3; stride <= 5; ++stride) {
            if (inResidues.length < stride) {
              break
            }

            for (var i = 0; i + stride < chainLength; ++i) {
              if (
                this._hbonds.isBond(
                  inResidues[i + stride]._index,
                  inResidues[i]._index
                )
              ) {
                this._helixFlags[stride][inResidues[i + stride]._index] =
                  HelixFlag.END

                for (var j = i + 1; j < i + stride; ++j) {
                  if (
                    typeof this._helixFlags[stride][inResidues[j]._index] ===
                    'undefined'
                  ) {
                    this._helixFlags[stride][inResidues[j]._index] =
                      HelixFlag.MIDDLE
                  }
                }

                if (
                  this._helixFlags[stride][inResidues[i]._index] ===
                  HelixFlag.END
                ) {
                  this._helixFlags[stride][inResidues[i]._index] =
                    HelixFlag.START_AND_END
                } else {
                  this._helixFlags[stride][inResidues[i]._index] =
                    HelixFlag.START
                }
              }
            }
          }

          for (var _i3 = 2; _i3 < chainLength - 2; ++_i3) {
            var kappa = this._kappa(
              inResidues[_i3 - 2],
              inResidues[_i3],
              inResidues[_i3 + 2]
            )

            this._bend[inResidues[_i3]._index] = kappa !== 360 && kappa > 70
          }

          for (var _i4 = 1; _i4 + 4 < chainLength; ++_i4) {
            if (
              this._isHelixStart(inResidues[_i4]._index, 4) &&
              this._isHelixStart(inResidues[_i4 - 1]._index, 4)
            ) {
              for (var _j = _i4; _j <= _i4 + 3; ++_j) {
                this._ss[inResidues[_j]._index] = StructureType$1.HELIX_ALPHA
              }
            }
          }

          for (var _i5 = 1; _i5 + 3 < chainLength; ++_i5) {
            if (
              this._isHelixStart(inResidues[_i5]._index, 3) &&
              this._isHelixStart(inResidues[_i5 - 1]._index, 3)
            ) {
              var empty = true

              for (var _j2 = _i5; empty && _j2 <= _i5 + 2; ++_j2) {
                empty =
                  typeof this._ss[inResidues[_j2]._index] === 'undefined' ||
                  this._ss[inResidues[_j2]._index] === StructureType$1.HELIX_310
              }

              if (empty) {
                for (var _j3 = _i5; _j3 <= _i5 + 2; ++_j3) {
                  this._ss[inResidues[_j3]._index] = StructureType$1.HELIX_310
                }
              }
            }
          }

          for (var _i6 = 1; _i6 + 5 < chainLength; ++_i6) {
            if (
              this._isHelixStart(inResidues[_i6]._index, 5) &&
              this._isHelixStart(inResidues[_i6 - 1]._index, 5)
            ) {
              var _empty = true

              for (var _j4 = _i6; _empty && _j4 <= _i6 + 4; ++_j4) {
                _empty =
                  typeof this._ss[inResidues[_j4]._index] === 'undefined' ||
                  this._ss[inResidues[_j4]._index] ===
                    StructureType$1.HELIX_PI ||
                  (inPreferPiHelices &&
                    this._ss[inResidues[_j4]._index] ===
                      StructureType$1.HELIX_ALPHA)
              }

              if (_empty) {
                for (var _j5 = _i6; _j5 <= _i6 + 4; ++_j5) {
                  this._ss[inResidues[_j5]._index] = StructureType$1.HELIX_PI
                }
              }
            }
          }

          for (var _i7 = 1; _i7 + 1 < chainLength; ++_i7) {
            if (typeof this._ss[inResidues[_i7]._index] === 'undefined') {
              var isTurn = false

              for (var _stride = 3; _stride <= 5 && !isTurn; ++_stride) {
                for (var k = 1; k < _stride && !isTurn; ++k) {
                  isTurn =
                    _i7 >= k &&
                    this._isHelixStart(inResidues[_i7 - k]._index, _stride)
                }
              }

              if (isTurn) {
                this._ss[inResidues[_i7]._index] = StructureType$1.TURN
              } else if (this._bend[inResidues[_i7]._index]) {
                this._ss[inResidues[_i7]._index] = StructureType$1.BEND
              }
            }
          }
        }
      },
      {
        key: '_residueGetCAlpha',
        value: function _residueGetCAlpha(res) {
          for (var i = 0; i < res._atoms.length; ++i) {
            var name = res._atoms[i].name

            if (name === 'CA' || name === 'C1') {
              return res._atoms[i].position
            }
          }

          return null
        }
      },
      {
        key: '_cosinusAngle',
        value: function _cosinusAngle(p1, p2, p3, p4) {
          var v12 = p1.clone().sub(p2)
          var v34 = p3.clone().sub(p4)
          var result = 0
          var x = v12.dot(v12) * v34.dot(v34)

          if (x > 0) {
            result = v12.dot(v34) / Math.sqrt(x)
          }

          return result
        }
      },
      {
        key: '_kappa',
        value: function _kappa(prevPrev, res, nextNext) {
          var curCA = this._residueGetCAlpha(res)

          var ppCA = this._residueGetCAlpha(prevPrev)

          var nnCA = this._residueGetCAlpha(nextNext)

          if (curCA === null || ppCA === null || nnCA === null) {
            return 180
          }

          var ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA)

          var skap = Math.sqrt(1 - ckap * ckap)
          return (Math.atan2(skap, ckap) * 180) / Math.PI
        }
      },
      {
        key: '_isHelixStart',
        value: function _isHelixStart(res, stride) {
          return (
            this._helixFlags[stride][res] === HelixFlag.START ||
            this._helixFlags[stride][res] === HelixFlag.START_AND_END
          )
        }
      },
      {
        key: '_buildBetaSheets',
        value: function _buildBetaSheets() {
          var bridges = []

          for (var a = 0; a < this._complex._chains.length; ++a) {
            var lenA = this._chainLengths[a]

            if (lenA <= 4) {
              continue
            }

            var chainA = this._complex._chains[a].getResidues()

            for (var b = a; b < this._complex._chains.length; ++b) {
              var lenB = this._chainLengths[b]

              if (lenB <= 4) {
                continue
              }

              var chainB = this._complex._chains[b].getResidues()

              for (var i = 1; i + 1 < lenA; ++i) {
                var ri = chainA[i]
                var j = 1

                if (b === a) {
                  j = i + 3
                }

                for (; j + 1 < lenB; ++j) {
                  var rj = chainB[j]

                  var type = this._testBridge(chainA, i, chainB, j)

                  if (type === BridgeType.NO_BRIDGE) {
                    continue
                  }

                  var found = false

                  var _iterator = _createForOfIteratorHelper(bridges),
                    _step

                  try {
                    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                      var bridge = _step.value

                      if (
                        type !== bridge.type ||
                        ri._index !== bridge.i[bridge.i.length - 1] + 1
                      ) {
                        continue
                      }

                      if (
                        type === BridgeType.PARALLEL &&
                        bridge.j[bridge.j.length - 1] + 1 === rj._index
                      ) {
                        bridge.i.push(ri._index)
                        bridge.j.push(rj._index)
                        found = true
                        break
                      }

                      if (
                        type === BridgeType.ANTI_PARALLEL &&
                        bridge.j[0] - 1 === rj._index
                      ) {
                        bridge.i.push(ri._index)
                        bridge.j.unshift(rj._index)
                        found = true
                        break
                      }
                    }
                  } catch (err) {
                    _iterator.e(err)
                  } finally {
                    _iterator.f()
                  }

                  if (!found) {
                    bridges.push({
                      type: type,
                      i: [ri._index],
                      chainI: ri.getChain()._index,
                      j: [rj._index],
                      chainJ: rj.getChain()._index
                    })
                  }
                }
              }
            }
          }

          bridges.sort(function (a, b) {
            if (
              a.chainI < b.chainI ||
              (a.chainI === b.chainI && a.i[0] < b.i[0])
            ) {
              return -1
            }

            return 1
          })

          for (var _i8 = 0; _i8 < bridges.length; ++_i8) {
            for (var _j6 = _i8 + 1; _j6 < bridges.length; ++_j6) {
              var ibi = bridges[_i8].i[0]
              var iei = bridges[_i8].i[bridges[_i8].i.length - 1]
              var jbi = bridges[_i8].j[0]
              var jei = bridges[_i8].j[bridges[_i8].j.length - 1]
              var ibj = bridges[_j6].i[0]
              var iej = bridges[_j6].i[bridges[_j6].i.length - 1]
              var jbj = bridges[_j6].j[0]
              var jej = bridges[_j6].j[bridges[_j6].j.length - 1]

              if (
                bridges[_i8].type !== bridges[_j6].type ||
                this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) ||
                this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) ||
                ibj - iei >= 6 ||
                (iei >= ibj && ibi <= iej)
              ) {
                continue
              }

              var bulge = false

              if (bridges[_i8].type === BridgeType.PARALLEL) {
                bulge = (jbj - jei < 6 && ibj - iei < 3) || jbj - jei < 3
              } else {
                bulge = (jbi - jej < 6 && ibj - iei < 3) || jbi - jej < 3
              }

              if (bulge) {
                bridges[_i8].i = bridges[_i8].i.concat(bridges[_j6].i)

                if (bridges[_i8].type === BridgeType.PARALLEL) {
                  bridges[_i8].j = bridges[_i8].j.concat(bridges[_j6].j)
                } else {
                  bridges[_i8].j = bridges[_j6].j.concat(bridges[_i8].j)
                }

                bridges.splice(_j6--, 1)
              }
            }
          }

          var ladderset = new Set()

          for (var _i9 = 0; _i9 < bridges.length; ++_i9) {
            ladderset.add(bridges[_i9])
          }

          var sheet = 1
          var ladder = 0

          while (ladderset.size > 0) {
            var _bridge = ladderset.values().next().value
            ladderset.delete(_bridge)
            var sheetset = new Set()
            sheetset.add(_bridge)
            var toMove = void 0

            do {
              toMove = new Set()

              var _iterator2 = _createForOfIteratorHelper(sheetset.values()),
                _step2

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
                  var _a = _step2.value

                  var _iterator4 = _createForOfIteratorHelper(
                      ladderset.values()
                    ),
                    _step4

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
                      var _b = _step4.value

                      if (this._areBridgesLinked(_a, _b)) {
                        toMove.add(_b)
                      }
                    }
                  } catch (err) {
                    _iterator4.e(err)
                  } finally {
                    _iterator4.f()
                  }
                }
              } catch (err) {
                _iterator2.e(err)
              } finally {
                _iterator2.f()
              }

              var _iterator3 = _createForOfIteratorHelper(toMove.values()),
                _step3

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
                  _bridge = _step3.value
                  sheetset.add(_bridge)
                  ladderset.delete(_bridge)
                }
              } catch (err) {
                _iterator3.e(err)
              } finally {
                _iterator3.f()
              }
            } while (toMove.size > 0)

            var _iterator5 = _createForOfIteratorHelper(sheetset.values()),
              _step5

            try {
              for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
                _bridge = _step5.value
                _bridge.ladder = ladder
                _bridge.sheet = sheet
                _bridge.link = sheetset
                ++ladder
              }
            } catch (err) {
              _iterator5.e(err)
            } finally {
              _iterator5.f()
            }

            ++sheet
          }

          for (var _i10 = 0; _i10 < bridges.length; ++_i10) {
            var _bridge2 = bridges[_i10]
            var betai = 0
            var betaj = 0

            for (var l = 0; l < _bridge2.i.length; ++l) {
              if (this._betaPartners[_bridge2.i[l]][0]) {
                betai = 1
                break
              }
            }

            for (var _l = 0; _l < _bridge2.j.length; ++_l) {
              if (this._betaPartners[_bridge2.j[_l]][0]) {
                betaj = 1
                break
              }
            }

            var ss = StructureType$1.BRIDGE

            if (_bridge2.i.length > 1) {
              ss = StructureType$1.STRAND
            }

            if (_bridge2.type === BridgeType.PARALLEL) {
              var _j7 = 0

              for (var k = 0; k < _bridge2.i.length; ++k) {
                this._betaPartners[_bridge2.i[k]][betai] = {
                  residue: _bridge2.j[_j7++],
                  ladder: _bridge2.ladder,
                  parallel: true
                }
              }

              _j7 = 0

              for (var _k = 0; _k < _bridge2.j.length; ++_k) {
                this._betaPartners[_bridge2.j[_k]][betaj] = {
                  residue: _bridge2.i[_j7++],
                  ladder: _bridge2.ladder,
                  parallel: true
                }
              }
            } else {
              var _j8 = _bridge2.j.length - 1

              for (var _k2 = 0; _k2 < _bridge2.i.length; ++_k2) {
                this._betaPartners[_bridge2.i[_k2]][betai] = {
                  residue: _bridge2.j[_j8--],
                  ladder: _bridge2.ladder,
                  parallel: false
                }
              }

              _j8 = _bridge2.i.length - 1

              for (var _k3 = 0; _k3 < _bridge2.j.length; ++_k3) {
                this._betaPartners[_bridge2.j[_k3]][betaj] = {
                  residue: _bridge2.i[_j8--],
                  ladder: _bridge2.ladder,
                  parallel: false
                }
              }
            }

            for (
              var _k4 = _bridge2.i[0];
              _k4 <= _bridge2.i[_bridge2.i.length - 1];
              ++_k4
            ) {
              if (this._ss[_k4] !== StructureType$1.STRAND) {
                this._ss[_k4] = ss
                this._sheet[_k4] = _bridge2.sheet
              }
            }

            for (
              var _k5 = _bridge2.j[0];
              _k5 <= _bridge2.j[_bridge2.j.length - 1];
              ++_k5
            ) {
              if (this._ss[_k5] !== StructureType$1.STRAND) {
                this._ss[_k5] = ss
                this._sheet[_k5] = _bridge2.sheet
              }
            }
          }
        }
      },
      {
        key: '_testBridge',
        value: function _testBridge(chainA, from, chainB, to) {
          var result = BridgeType.NO_BRIDGE
          var a = chainA[from - 1]._index
          var b = chainA[from]._index
          var c = chainA[from + 1]._index
          var d = chainB[to - 1]._index
          var e = chainB[to]._index
          var f = chainB[to + 1]._index

          var isBond = this._hbonds.isBond.bind(this._hbonds)

          if (
            (isBond(c, e) && isBond(e, a)) ||
            (isBond(f, b) && isBond(b, d))
          ) {
            result = BridgeType.PARALLEL
          } else if (
            (isBond(c, d) && isBond(f, a)) ||
            (isBond(e, b) && isBond(b, e))
          ) {
            result = BridgeType.ANTI_PARALLEL
          }

          return result
        }
      },
      {
        key: '_areBridgesLinked',
        value: function _areBridgesLinked(a, b) {
          var ai = new Set(a.i)
          var aj = new Set(a.j)

          var _iterator6 = _createForOfIteratorHelper(b.i),
            _step6

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done; ) {
              var i = _step6.value

              if (ai.has(i) || aj.has(i)) {
                return true
              }
            }
          } catch (err) {
            _iterator6.e(err)
          } finally {
            _iterator6.f()
          }

          var _iterator7 = _createForOfIteratorHelper(b.j),
            _step7

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done; ) {
              var _i11 = _step7.value

              if (ai.has(_i11) || aj.has(_i11)) {
                return true
              }
            }
          } catch (err) {
            _iterator7.e(err)
          } finally {
            _iterator7.f()
          }

          return false
        }
      },
      {
        key: '_hasChainBreak',
        value: function _hasChainBreak(from, to) {
          for (var i = from + 1; i <= to; ++i) {
            if (
              this._complex._residues[i]._sequence !==
              this._complex._residues[i - 1]._sequence + 1
            ) {
              return true
            }
          }

          return false
        }
      }
    ])

    return SecondaryStructureMap
  })()
  SecondaryStructureMap.StructureType = StructureType$1

  var _helixClassMap, _loopMap
  var VOXEL_SIZE = 5.0
  var StructureType = SecondaryStructureMap.StructureType
  var StructuralElementType$3 = StructuralElement.Type
  var helixClassMap =
    ((_helixClassMap = {}),
    _defineProperty(_helixClassMap, StructureType.HELIX_ALPHA, 1),
    _defineProperty(_helixClassMap, StructureType.HELIX_PI, 3),
    _defineProperty(_helixClassMap, StructureType.HELIX_310, 5),
    _helixClassMap)
  var loopMap =
    ((_loopMap = {}),
    _defineProperty(
      _loopMap,
      StructureType.BRIDGE,
      StructuralElementType$3.BRIDGE
    ),
    _defineProperty(_loopMap, StructureType.TURN, StructuralElementType$3.TURN),
    _defineProperty(_loopMap, StructureType.BEND, StructuralElementType$3.BEND),
    _defineProperty(_loopMap, StructureType.LOOP, StructuralElementType$3.COIL),
    _loopMap)

  var Complex$9 = /*#__PURE__*/ (function () {
    function Complex() {
      _classCallCheck(this, Complex)

      this._chains = []
      this._components = []
      this._helices = []
      this._sheets = []
      this.structures = []
      this._residueTypes = Object.create(ResidueType$1.StandardTypes)
      this._atoms = []
      this._residues = []
      this._bonds = []
      this._sgroups = []
      this._molecules = []
      this._maskNeedsUpdate = false
      this.metadata = {}
      this.symmetry = []
      this.units = [new BiologicalUnit(this)]
      this._currentUnit = 0
    }

    _createClass(Complex, [
      {
        key: 'addAtom',
        value: function addAtom(atom) {
          var index = this._atoms.length

          this._atoms.push(atom)

          return index
        }
      },
      {
        key: 'addSheet',
        value: function addSheet(sheet) {
          var index = this._sheets.length

          this._sheets.push(sheet)

          return index
        }
      },
      {
        key: 'addHelix',
        value: function addHelix(helix) {
          var index = this._helices.length

          this._helices.push(helix)

          return index
        }
      },
      {
        key: 'getAtoms',
        value: function getAtoms() {
          return this._atoms
        }
      },
      {
        key: 'getBonds',
        value: function getBonds() {
          return this._bonds
        }
      },
      {
        key: 'getAtomCount',
        value: function getAtomCount() {
          return this._atoms.length
        }
      },
      {
        key: 'addResidue',
        value: function addResidue(residue) {
          var index = this._residues.length

          this._residues.push(residue)

          return index
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          this.forEachChain(function (chain) {
            chain.updateToFrame(frameData)
          })
        }
      },
      {
        key: 'addResidueType',
        value: function addResidueType(resName) {
          var rt = (this._residueTypes[resName] = new ResidueType$1(
            resName,
            'Unknown',
            ''
          ))
          return rt
        }
      },
      {
        key: 'getResidueCount',
        value: function getResidueCount() {
          return this._residues.length
        }
      },
      {
        key: 'getResidues',
        value: function getResidues() {
          return this._residues
        }
      },
      {
        key: 'getSGroupCount',
        value: function getSGroupCount() {
          return this._sgroups.length
        }
      },
      {
        key: 'getSGroups',
        value: function getSGroups() {
          return this._sgroups
        }
      },
      {
        key: 'getAtomByFullname',
        value: function getAtomByFullname(fullName) {
          var parts = fullName.split('.')

          if (parts.length !== 3) {
            return null
          }

          var chainName = parts[0]
          var resId = parseInt(parts[1], 10)

          if (Number.isNaN(resId)) {
            return null
          }

          var atomName = parts[2].toUpperCase()
          var currAtom = null
          this.forEachChain(function (chain) {
            if (currAtom) {
              return
            }

            if (chain._name.localeCompare(chainName) === 0) {
              chain.forEachResidue(function (residue) {
                if (currAtom) {
                  return
                }

                if (residue._sequence === resId) {
                  residue.forEachAtom(function (atom) {
                    if (currAtom) {
                      return
                    }

                    if (atomName.localeCompare(atom.name) === 0) {
                      currAtom = atom
                    }
                  })
                }
              })
            }
          })
          return currAtom
        }
      },
      {
        key: 'addChain',
        value: function addChain(name) {
          var result = new Chain$2(this, name)

          this._chains.push(result)

          return result
        }
      },
      {
        key: 'getChain',
        value: function getChain(name) {
          for (var i = 0, n = this._chains.length; i < n; ++i) {
            var chain = this._chains[i]

            if (chain.getName() === name) {
              return chain
            }
          }

          return null
        }
      },
      {
        key: 'getChainCount',
        value: function getChainCount() {
          return this._chains.length
        }
      },
      {
        key: 'getMolecules',
        value: function getMolecules() {
          return this._molecules
        }
      },
      {
        key: 'getMoleculeCount',
        value: function getMoleculeCount() {
          return this._molecules.length
        }
      },
      {
        key: 'forEachAtom',
        value: function forEachAtom(process) {
          var atoms = this._atoms

          for (var i = 0, n = atoms.length; i < n; ++i) {
            process(atoms[i])
          }
        }
      },
      {
        key: 'forEachBond',
        value: function forEachBond(process) {
          var bonds = this._bonds

          for (var i = 0, n = bonds.length; i < n; ++i) {
            process(bonds[i])
          }
        }
      },
      {
        key: 'forEachResidue',
        value: function forEachResidue(process) {
          var residues = this._residues

          for (var i = 0, n = residues.length; i < n; ++i) {
            process(residues[i])
          }
        }
      },
      {
        key: 'forEachChain',
        value: function forEachChain(process) {
          var chains = this._chains

          for (var i = 0, n = chains.length; i < n; ++i) {
            process(chains[i])
          }
        }
      },
      {
        key: 'forEachMolecule',
        value: function forEachMolecule(process) {
          var molecules = this._molecules
          var n = molecules.length

          for (var i = 0; i < n; ++i) {
            process(molecules[i])
          }
        }
      },
      {
        key: 'forEachSGroup',
        value: function forEachSGroup(process) {
          var groups = this._sgroups

          for (var i = 0, n = groups.length; i < n; ++i) {
            process(groups[i])
          }
        }
      },
      {
        key: 'forEachComponent',
        value: function forEachComponent(process) {
          var components = this._components

          for (var i = 0, n = components.length; i < n; ++i) {
            process(components[i])
          }
        }
      },
      {
        key: 'forEachVisibleComponent',
        value: function forEachVisibleComponent(process) {
          var components = this._components

          for (var i = 0, n = components.length; i < n; ++i) {
            process(components[i])
          }
        }
      },
      {
        key: 'addBond',
        value: function addBond(left, right, order, type, fixed) {
          var bond = new Bond$5(left, right, order, type, fixed)

          this._bonds.push(bond)

          return bond
        }
      },
      {
        key: 'getBondCount',
        value: function getBondCount() {
          return this._bonds.length
        }
      },
      {
        key: 'getResidueType',
        value: function getResidueType(name) {
          return this._residueTypes[name] || null
        }
      },
      {
        key: 'getUnifiedSerial',
        value: function getUnifiedSerial(chain, serial, iCode) {
          var maxSerial = 65536
          var chainShift = maxSerial * 256
          return serial + iCode * maxSerial + chain * chainShift
        }
      },
      {
        key: 'splitUnifiedSerial',
        value: function splitUnifiedSerial(uniSerial) {
          var maxSerial = 65536
          var chainShift = maxSerial * 256
          var chainId = Math.floor(uniSerial / chainShift)
          var remnant = uniSerial - chainId * chainShift
          var insCode = Math.floor(remnant / maxSerial)
          var ser = remnant - insCode * maxSerial
          return {
            chain: chainId,
            serial: ser,
            iCode: insCode
          }
        }
      },
      {
        key: '_fillCmpEdit',
        value: function _fillCmpEdit() {
          var self = this
          var components = this._components

          function addComp() {
            var comp = new Component(self)
            comp._index = components.length
            components[comp._index] = comp
            return comp
          }

          this.forEachChain(function (chain) {
            var residues = chain._residues
            var resCount = residues.length

            if (resCount < 1) {
              return
            }

            var comp = addComp()
            var currStart = residues[0]._index

            for (var i = 0; i < resCount; ++i) {
              var currRes = residues[i]
              currRes._component = comp
              var nextRes = i === resCount - 1 ? null : residues[i + 1]

              if (
                !nextRes ||
                !currRes.isConnected(nextRes) ||
                currRes._index !== nextRes._index - 1
              ) {
                comp.setSubDivs([
                  {
                    start: currStart,
                    end: currRes._index
                  }
                ])

                if (nextRes) {
                  currStart = nextRes._index
                  comp = addComp()
                }
              }
            }
          })
        }
      },
      {
        key: '_fillCmpNoedit',
        value: function _fillCmpNoedit() {
          var comp = new Component(this)
          comp._index = 0
          var residues = this._residues
          var resCount = residues.length

          if (resCount === 0) {
            return
          }

          var currSubDivs = []
          var currStart = 0

          for (var i = 0; i < resCount; ++i) {
            var currRes = residues[i]
            currRes._component = comp
            var nextRes = i === resCount - 1 ? null : residues[i + 1]

            if (!nextRes || !currRes.isConnected(nextRes)) {
              currSubDivs[currSubDivs.length] = {
                start: currStart,
                end: i
              }

              if (nextRes) {
                currStart = i + 1
              }
            }
          }

          comp.setSubDivs(currSubDivs)
          this._components[comp._index] = comp
        }
      },
      {
        key: '_fillComponents',
        value: function _fillComponents(enableEditing) {
          if (enableEditing) {
            this._fillCmpEdit()
          } else {
            this._fillCmpNoedit()
          }
        }
      },
      {
        key: 'getCurrentUnit',
        value: function getCurrentUnit() {
          return this._currentUnit
        }
      },
      {
        key: 'getDefaultBoundaries',
        value: function getDefaultBoundaries() {
          return this.units[0].getBoundaries()
        }
      },
      {
        key: 'getBoundaries',
        value: function getBoundaries() {
          return this.units[this._currentUnit].getBoundaries()
        }
      },
      {
        key: 'getTransforms',
        value: function getTransforms() {
          return this.units[this._currentUnit].getTransforms()
        }
      },
      {
        key: 'getSelector',
        value: function getSelector() {
          return this.units[this._currentUnit].getSelector()
        }
      },
      {
        key: 'resetCurrentUnit',
        value: function resetCurrentUnit() {
          this._currentUnit = 0
          this.setCurrentUnit(1)
        }
      },
      {
        key: 'setCurrentUnit',
        value: function setCurrentUnit(newUnit) {
          if (
            newUnit !== null &&
            newUnit !== undefined &&
            newUnit !== this._currentUnit &&
            newUnit >= 0 &&
            newUnit < this.units.length
          ) {
            this._currentUnit = newUnit
            return true
          }

          return false
        }
      },
      {
        key: '_computeBounds',
        value: function _computeBounds() {
          var units = this.units

          for (var i = 0, n = units.length; i < n; ++i) {
            units[i].computeBoundaries()
          }
        }
      },
      {
        key: 'onAtomPositionChanged',
        value: function onAtomPositionChanged() {
          this.forEachChain(function (a) {
            a._finalize()
          })
          this.forEachComponent(function (c) {
            c.update()
          })

          this._computeBounds()

          this._finalizeBonds()

          this.forEachSGroup(function (s) {
            s._rebuildSGroupOnAtomChange()
          })
        }
      },
      {
        key: 'update',
        value: function update() {
          if (this._maskNeedsUpdate) {
            this.updateStructuresMask()
            this._maskNeedsUpdate = false
          }
        }
      },
      {
        key: '_finalizeBonds',
        value: function _finalizeBonds() {
          var bonds = this.getBonds()
          var n = bonds.length

          for (var i = 0; i < n; ++i) {
            bonds[i]._index = i
          }
        }
      },
      {
        key: 'finalize',
        value: function finalize(opts) {
          opts = opts || {}
          var bonds = this._bonds
          var i
          var n

          for (i = bonds.length - 1; i >= 0; i--) {
            var bond = bonds[i]

            if (bond._left === null || bond._right === null) {
              bonds.splice(i, 1)
            } else {
              bond._left.bonds.push(bond)

              bond._right.bonds.push(bond)
            }
          }

          var residues = this._residues

          for (i = 0, n = residues.length; i < n; ++i) {
            residues[i]._finalize()
          }

          this.forEachChain(function (a) {
            a._finalize()
          })
          var units = this.units

          for (i = 0, n = units.length; i < n; ++i) {
            units[i].finalize()
          }

          this.setCurrentUnit(1)
          var residueHash = {}

          for (i = 0, n = residues.length; i < n; ++i) {
            var res = residues[i]
            residueHash[
              this.getUnifiedSerial(
                res.getChain().getName().charCodeAt(0),
                res.getSequence(),
                res.getICode().charCodeAt(0)
              )
            ] = res
          }

          var structures = this.structures

          for (i = 0, n = structures.length; i < n; ++i) {
            structures[i]._finalize(opts.serialAtomMap, residueHash, this)
          }

          var helices = this._helices

          for (i = 0, n = helices.length; i < n; ++i) {
            helices[i]._finalize(opts.serialAtomMap, residueHash, this)
          }

          var sheets = this._sheets

          for (i = 0, n = sheets.length; i < n; ++i) {
            sheets[i]._finalize(opts.serialAtomMap, residueHash, this)
          }

          this._computeBounds()

          var atoms = this._atoms

          for (i = 0, n = atoms.length; i < n; ++i) {
            var currAtom = atoms[i]
            currAtom.index = i
          }

          if (opts.needAutoBonding) {
            var autoConnector = new AutoBond(this)
            autoConnector.build()
            autoConnector.destroy()
          }

          var chains = this._chains

          for (i = 0, n = chains.length; i < n; ++i) {
            chains[i]._index = i
          }

          for (i = 0, n = residues.length; i < n; ++i) {
            residues[i]._index = i
          }

          for (i = 0, n = atoms.length; i < n; ++i) {
            var atom = atoms[i]

            if (atom.flags & Atom$2.Flags.HYDROGEN && atom.bonds.length === 1) {
              var _bond = atom.bonds[0]
              var other = (_bond._left !== atom && _bond._left) || _bond._right

              if (other.flags & Atom$2.Flags.CARBON) {
                atom.flags |= Atom$2.Flags.NONPOLARH
              }
            }
          }

          this._finalizeBonds()

          this._fillComponents(opts.enableEditing)

          var marker = new AromaticLoopsMarker(this)
          marker.markCycles()

          if (opts.detectAromaticLoops) {
            marker.detectCycles()
          }

          this._finalizeMolecules()
        }
      },
      {
        key: '_finalizeMolecules',
        value: function _finalizeMolecules() {
          for (var i = 0; i < this._molecules.length; i++) {
            var molecule = this._molecules[i]
            var count = molecule.residues.length

            for (var j = 0; j < count; j++) {
              var residue = molecule.residues[j]
              residue._molecule = molecule
            }
          }
        }
      },
      {
        key: 'updateStructuresMask',
        value: function updateStructuresMask() {
          var updater = function updater(structure) {
            return structure.collectMask()
          }

          this.forEachResidue(updater)
          this.forEachChain(updater)
          this.forEachMolecule(updater)
        }
      },
      {
        key: 'countAtomsByMask',
        value: function countAtomsByMask(mask) {
          var count = 0
          this.forEachAtom(function (atom) {
            if ((atom.mask & mask) !== 0) {
              count++
            }
          })
          return count
        }
      },
      {
        key: 'getNumAtomsBySelector',
        value: function getNumAtomsBySelector(selector) {
          var count = 0
          this.forEachAtom(function (atom) {
            if (selector.includesAtom(atom)) {
              count++
            }
          })
          return count
        }
      },
      {
        key: 'resetAtomMask',
        value: function resetAtomMask(mask) {
          this.forEachAtom(function (atom) {
            atom.mask = mask
          })
        }
      },
      {
        key: 'markAtoms',
        value: function markAtoms(selector, mask) {
          var setMask = mask
          var clearMask = ~setMask
          var count = 0
          var totalSelector = selectors$5.keyword('And')(
            selector,
            this.getSelector()
          )
          this.forEachAtom(function (atom) {
            if (totalSelector.includesAtom(atom)) {
              atom.mask |= setMask
              count++
            } else {
              atom.mask &= clearMask
            }
          })
          this._maskNeedsUpdate = true
          return count
        }
      },
      {
        key: 'markAtomsAdditionally',
        value: function markAtomsAdditionally(selector, mask) {
          var setMask = mask
          var count = 0
          this.forEachAtom(function (atom) {
            if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
              atom.mask |= setMask
              count++
            }
          })
          return count
        }
      },
      {
        key: 'clearAtomBits',
        value: function clearAtomBits(mask) {
          var clearMask = ~mask
          this.forEachAtom(function (atom) {
            atom.mask &= clearMask
          })

          var reseter = function reseter(a) {
            a._mask &= clearMask
          }

          this.forEachAtom(reseter)
          this.forEachResidue(reseter)
          this.forEachChain(reseter)
          this.forEachMolecule(reseter)
        }
      },
      {
        key: 'getAtomNames',
        value: function getAtomNames() {
          if (this.hasOwnProperty('_atomNames')) {
            return this._atomNames
          }

          var dict = {}
          this.forEachAtom(function (atom) {
            dict[atom.name] = 1
          })
          this._atomNames = Object.keys(dict)
          return this._atomNames
        }
      },
      {
        key: 'getElements',
        value: function getElements() {
          if (this.hasOwnProperty('_elements')) {
            return this._elements
          }

          var dict = {}
          this.forEachAtom(function (atom) {
            dict[atom.element.name] = 1
          })
          this._elements = Object.keys(dict)
          return this._elements
        }
      },
      {
        key: 'getResidueNames',
        value: function getResidueNames() {
          if (this.hasOwnProperty('_residueNames')) {
            return this._residueNames
          }

          var dict = {}
          this.forEachResidue(function (res) {
            dict[res._type._name] = 1
          })
          this._residueNames = Object.keys(dict)
          return this._residueNames
        }
      },
      {
        key: 'getChainNames',
        value: function getChainNames() {
          if (this.hasOwnProperty('_chainNames')) {
            return this._chainNames
          }

          var dict = {}
          this.forEachChain(function (chain) {
            dict[chain._name] = 1
          })
          this._chainNames = Object.keys(dict)
          return this._chainNames
        }
      },
      {
        key: 'getAltLocNames',
        value: function getAltLocNames() {
          if (this.hasOwnProperty('_altlocNames')) {
            return this._altlocNames
          }

          var dict = {}
          this.forEachAtom(function (atom) {
            dict[String.fromCharCode(atom.location)] = 1
          })
          this._altlocNames = Object.keys(dict)
          return this._altlocNames
        }
      },
      {
        key: 'getVoxelWorld',
        value: function getVoxelWorld() {
          if (!this.hasOwnProperty('_voxelWorld')) {
            try {
              this._voxelWorld = new VoxelWorld(
                this.getDefaultBoundaries().boundingBox,
                new THREE__namespace.Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE)
              )

              this._voxelWorld.addAtoms(this)
            } catch (e) {
              logger.warn('Unable to create voxel world')
              this._voxelWorld = null
            }
          }

          return this._voxelWorld
        }
      },
      {
        key: 'addElement',
        value: function addElement(srcArray, dstArray, param, functor) {
          var length = srcArray.length

          for (var i = 0; i < length; ++i) {
            var elem = srcArray[i]
            functor(elem, param)
            dstArray.push(elem)
          }
        }
      },
      {
        key: 'joinComplexes',
        value: function joinComplexes(complexes) {
          this._chains = []
          this._components = []
          this._helices = []
          this._sheets = []
          this.structures = []
          this._atoms = []
          this._residues = []
          this._bonds = []
          this._sgroups = []
          var self = this
          var atomBias = 0
          var bondBias = 0
          var residueBias = 0
          var chainBias = 0
          var componentBias = 0

          function processAtom(atom, bias) {
            atom.serial += bias
            atom.index += bias
          }

          function processBond(bond, bias) {
            bond._index += bias
          }

          function processResidue(residue, bias) {
            residue._index += bias
          }

          function processChain(chain, bias) {
            chain._complex = self
            chain._index += bias
          }

          function processComponent(component, bias) {
            component._complex = self
            component._index += bias
          }

          function doNothing() {}

          for (var i = 0; i < complexes.length; ++i) {
            var c = complexes[i]
            this.addElement(c._atoms, this._atoms, atomBias, processAtom)
            this.addElement(c._bonds, this._bonds, bondBias, processBond)
            this.addElement(
              c._residues,
              this._residues,
              residueBias,
              processResidue
            )
            this.addElement(c._chains, this._chains, chainBias, processChain)
            this.addElement(c._sheets, this._sheets, 0, doNothing)
            this.addElement(c._helices, this._helices, 0, doNothing)
            this.addElement(c._sgroups, this._sgroups, 0, doNothing)
            this.addElement(
              c._components,
              this._components,
              componentBias,
              processComponent
            )
            this.addElement(c.structures, this.structures, 0, doNothing)

            for (var rt in c._residueTypes) {
              if (c._residueTypes.hasOwnProperty(rt)) {
                this._residueTypes[rt] = c._residueTypes[rt]
              }
            }

            atomBias += c._atoms.length
            bondBias += c._bonds.length
            residueBias += c._residues.length
            chainBias += c._chains.length
            componentBias += c._components.length
          }

          this._computeBounds()
        }
      },
      {
        key: 'dssp',
        value: function dssp() {
          var ssMap = new SecondaryStructureMap(this)
          var structures = (this.structures = [])
          var helices = (this._helices = [])
          var sheets = (this._sheets = [])

          var getSheet = function getSheet(index) {
            var item = sheets[index]

            if (!item) {
              item = sheets[index] = new Sheet$3(String(index), 0)
            }

            return item
          }

          var lastCode
          var lastSheetIndex
          var lastHelixIndex = 0
          var curStructure = null

          for (var i = 0, n = this._residues.length; i < n; ++i) {
            var curCode = ssMap._ss[i]
            var curResidue = this._residues[i]
            var curSheetIndex = ssMap._sheet[i]

            if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
              curResidue._secondary = curStructure

              if (curStructure) {
                curStructure.term = curResidue
              }

              if (curStructure instanceof Helix$3) {
                curStructure.length++
              }

              continue
            }

            var helixClass = helixClassMap[curCode]
            var loopType = loopMap[curCode]

            if (curCode === StructureType.STRAND) {
              var curSheet = getSheet(curSheetIndex)
              curStructure = new Strand$3(
                curSheet,
                curResidue,
                curResidue,
                0,
                null,
                null
              )
              curSheet.addStrand(curStructure)
            } else if (helixClass !== undefined) {
              lastHelixIndex++
              curStructure = new Helix$3(
                helixClass,
                curResidue,
                curResidue,
                lastHelixIndex,
                String(lastHelixIndex),
                '',
                1
              )
              helices.push(curStructure)
            } else if (loopType !== undefined) {
              curStructure = new StructuralElement(
                loopType,
                curResidue,
                curResidue
              )
            } else {
              curStructure = null
            }

            if (curStructure) {
              structures.push(curStructure)
            }

            curResidue._secondary = curStructure
            lastCode = curCode
            lastSheetIndex = curSheetIndex
          }

          this._sheets = sheets.filter(function (_sheet) {
            return true
          })
        }
      }
    ])

    return Complex
  })()

  Complex$9.prototype.id = 'Complex'
  Complex$9.prototype.name = ''

  function pow2ceil(v) {
    var p = 2
    v = (v - 1) >> 1

    while (v) {
      p <<= 1
      v >>= 1
    }

    return p
  }

  var Volume$2 = /*#__PURE__*/ (function () {
    function Volume(type, dimensions, box, vecSize, data, volumeInfo) {
      _classCallCheck(this, Volume)

      this._box = box.clone()
      this._dimVec = Math.max(Math.floor(vecSize || 1), 1)
      this._volumeInfo = volumeInfo

      if (dimensions instanceof Array) {
        var _dimensions = _slicedToArray(dimensions, 3)

        this._dimX = _dimensions[0]
        this._dimY = _dimensions[1]
        this._dimZ = _dimensions[2]
      } else {
        this._dimX = dimensions.x
        this._dimY = dimensions.y
        this._dimZ = dimensions.z
      }

      this._dimX = Math.max(Math.floor(this._dimX), 1)
      this._dimY = Math.max(Math.floor(this._dimY), 1)
      this._dimZ = Math.max(Math.floor(this._dimZ), 1)
      this._rowElements = this._dimVec * this._dimX
      this._planeElements = this._rowElements * this._dimY
      this._totalElements = this._planeElements * this._dimZ
      this._data = data || utils.allocateTyped(type, this._totalElements)

      switch (this._dimVec) {
        case 1:
          break

        case 2:
          this.getValue = function (x, y, z) {
            var idx =
              x * this._dimVec + y * this._rowElements + z * this._planeElements
            return [this._data[idx], this._data[idx + 1]]
          }

          this.setValue = function (x, y, z, a, b) {
            var idx =
              x * this._dimVec + y * this._rowElements + z * this._planeElements
            this._data[idx] = a
            this._data[idx + 1] = b
          }

          this.addValue = function (x, y, z, a, b) {
            var idx =
              x * this._dimVec + y * this._rowElements + z * this._planeElements
            this._data[idx] += a
            this._data[idx + 1] += b
          }

          break

        case 3:
          this.getValue = function (x, y, z) {
            var idx =
              x * this._dimVec + y * this._rowElements + z * this._planeElements
            return [this._data[idx], this._data[idx + 1], this._data[idx + 2]]
          }

          this.setValue = function (x, y, z, a, b, c) {
            var idx =
              x * this._dimVec + y * this._rowElements + z * this._planeElements
            this._data[idx] = a
            this._data[idx + 1] = b
            this._data[idx + 2] = c
          }

          this.addValue = function (x, y, z, a, b, c) {
            var idx =
              x * this._dimVec + y * this._rowElements + z * this._planeElements
            this._data[idx] += a
            this._data[idx + 1] += b
            this._data[idx + 2] += c
          }

          break

        default:
          throw new Error('Volume: invalid vector dimension')
      }
    }

    _createClass(Volume, [
      {
        key: 'getValue',
        value: function getValue(x, y, z) {
          return this._data[x + y * this._rowElements + z * this._planeElements]
        }
      },
      {
        key: 'setValue',
        value: function setValue(x, y, z, val) {
          this._data[x + y * this._rowElements + z * this._planeElements] = val
        }
      },
      {
        key: 'addValue',
        value: function addValue(x, y, z, val) {
          this._data[x + y * this._rowElements + z * this._planeElements] += val
        }
      },
      {
        key: 'getDimensions',
        value: function getDimensions() {
          return [this._dimX, this._dimY, this._dimZ]
        }
      },
      {
        key: 'getBox',
        value: function getBox() {
          return this._box
        }
      },
      {
        key: 'getVolumeInfo',
        value: function getVolumeInfo() {
          return this._volumeInfo
        }
      },
      {
        key: 'getCellSize',
        value: function getCellSize() {
          var boxSize = new THREE__namespace.Vector3()

          this._box.getSize(boxSize)

          var res = new THREE__namespace.Vector3()
          res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0
          res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0
          res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0
          return res
        }
      },
      {
        key: 'computeGradient',
        value: function computeGradient() {
          if (this._dimVec !== 1) {
            return null
          }

          var gradient = new Volume(
            Float32Array,
            [this._dimX, this._dimY, this._dimZ],
            this._box,
            3
          )
          var vl = this.getCellSize()
          var vs = new THREE__namespace.Vector3(
            -0.5 / vl.x,
            -0.5 / vl.y,
            -0.5 / vl.z
          )

          function clamp(val, min, max) {
            return Math.min(max, Math.max(min, val))
          }

          var xSize = this._dimX
          var ySize = this._dimY
          var zSize = this._dimZ
          var volMap = this._data

          function _voxelValue(x, y, z) {
            return volMap[z * xSize * ySize + y * xSize + x]
          }

          for (var zi = 0; zi < zSize; ++zi) {
            var zm = clamp(zi - 1, 0, zSize - 1)
            var zp = clamp(zi + 1, 0, zSize - 1)

            for (var yi = 0; yi < ySize; ++yi) {
              var ym = clamp(yi - 1, 0, ySize - 1)
              var yp = clamp(yi + 1, 0, ySize - 1)

              for (var xi = 0; xi < xSize; ++xi) {
                var xm = clamp(xi - 1, 0, xSize - 1)
                var xp = clamp(xi + 1, 0, xSize - 1)
                gradient.setValue(
                  xi,
                  yi,
                  zi,
                  (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x,
                  (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y,
                  (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z
                )
              }
            }
          }

          return gradient
        }
      },
      {
        key: 'normalize',
        value: function normalize() {
          var data = this._data
          var min = data[0]
          var max = data[0]

          for (var i = 1; i < data.length; ++i) {
            min = Math.min(min, data[i])
            max = Math.max(max, data[i])
          }

          var d = 1.0 / (max - min)

          if (d === 0) {
            return
          }

          for (var _i = 0; _i < data.length; ++_i) {
            data[_i] = d * (data[_i] - min)
          }
        }
      },
      {
        key: 'getTiledTextureStride',
        value: function getTiledTextureStride() {
          return [this._dimX + 2, this._dimY + 2]
        }
      },
      {
        key: 'buildTiledTexture',
        value: function buildTiledTexture() {
          var tilesX = Math.ceil(
            Math.sqrt((this._dimZ * this._dimY) / this._dimX)
          )
          var width = tilesX * (this._dimX + 2) - 1
          width = pow2ceil(width)
          tilesX = Math.floor(width / (this._dimX + 2))
          var tilesY = Math.ceil(this._dimZ / tilesX)
          var height = tilesY * (this._dimY + 2) - 1
          height = pow2ceil(height)
          var data = new Uint8Array(width * height)
          var src
          var dst

          for (var tileRow = 0; tileRow < tilesY; ++tileRow) {
            for (var row = 0; row < this._dimY; ++row) {
              src =
                tileRow * tilesX * this._planeElements + row * this._rowElements
              dst = width * (tileRow * (this._dimY + 2) + row)

              for (var t = 0; t < tilesX; ++t) {
                for (var x = 0; x < this._dimX; ++x) {
                  data[dst++] = 255.0 * this._data[src++]
                }

                data[dst++] = 255.0 * this._data[src - 1]

                if (t < tilesX - 1) {
                  src += this._planeElements - this._rowElements
                  data[dst++] = 255.0 * this._data[src]
                }
              }
            }
          }

          for (var _tileRow = 0; _tileRow < tilesY; ++_tileRow) {
            src = width * (_tileRow * (this._dimY + 2) + this._dimY - 1)
            dst = src + width

            for (var _x = 0; _x < width; ++_x) {
              data[dst++] = data[src++]
            }

            if (_tileRow < tilesY - 1) {
              src = width * (_tileRow + 1) * (this._dimY + 2)
              dst = src - width

              for (var _x2 = 0; _x2 < width; ++_x2) {
                data[dst++] = data[src++]
              }
            }
          }

          var texture = new THREE__namespace.DataTexture(
            data,
            width,
            height,
            THREE__namespace.LuminanceFormat,
            THREE__namespace.UnsignedByteType,
            THREE__namespace.UVMapping,
            THREE__namespace.ClampToEdgeWrapping,
            THREE__namespace.ClampToEdgeWrapping,
            THREE__namespace.LinearFilter,
            THREE__namespace.LinearFilter
          )
          texture.needsUpdate = true
          return texture
        }
      },
      {
        key: 'getData',
        value: function getData() {
          return this._data
        }
      },
      {
        key: 'getDirectIdx',
        value: function getDirectIdx(x, y, z) {
          return (
            x * this._dimVec + y * this._rowElements + z * this._planeElements
          )
        }
      },
      {
        key: 'getStrideX',
        value: function getStrideX() {
          return this._dimVec
        }
      },
      {
        key: 'getStrideY',
        value: function getStrideY() {
          return this._rowElements
        }
      },
      {
        key: 'getStrideZ',
        value: function getStrideZ() {
          return this._planeElements
        }
      }
    ])

    return Volume
  })()

  Volume$2.prototype.id = 'Volume'

  var Molecule$8 = /*#__PURE__*/ (function () {
    function Molecule(complex, name, index) {
      _classCallCheck(this, Molecule)

      this.complex = complex
      this.name = name || ''
      this.residues = []
      this.mask = 1 | 0
      this.index = index || -1
    }

    _createClass(Molecule, [
      {
        key: 'forEachResidue',
        value: function forEachResidue(process) {
          var residues = this.residues

          for (var i = 0, n = residues.length; i < n; ++i) {
            process(residues[i])
          }
        }
      },
      {
        key: 'collectMask',
        value: function collectMask() {
          var mask = 0xffffffff
          var residues = this.residues

          for (var i = 0, n = residues.length; i < n; ++i) {
            mask &= residues[i]._mask
          }

          this.mask = mask
        }
      }
    ])

    return Molecule
  })()

  var chem = {
    Atom: Atom$2,
    Element: Element$a,
    Bond: Bond$5,
    Residue: Residue$1,
    ResidueType: ResidueType$1,
    Chain: Chain$2,
    Helix: Helix$3,
    Strand: Strand$3,
    Sheet: Sheet$3,
    SGroup: SGroup$1,
    Assembly: Assembly$3,
    Complex: Complex$9,
    Volume: Volume$2,
    VoxelWorld: VoxelWorld,
    selectors: selectors$5,
    Molecule: Molecule$8
  }

  function _createSuper$1U(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1U()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1U() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var CSS2DObject = /*#__PURE__*/ (function (_THREE$Object3D) {
    _inherits(CSS2DObject, _THREE$Object3D)

    var _super = _createSuper$1U(CSS2DObject)

    function CSS2DObject(element) {
      var _this

      _classCallCheck(this, CSS2DObject)

      _this = _super.call(this)

      var self = _assertThisInitialized(_this)

      _this._element = element
      _this._element.style.position = 'absolute'

      _this.addEventListener('removed', function () {
        if (self._element.parentNode !== null) {
          self._element.parentNode.removeChild(self._element)
        }
      })

      return _this
    }

    _createClass(CSS2DObject, [
      {
        key: 'getElement',
        value: function getElement() {
          return this._element
        }
      },
      {
        key: 'setTransparency',
        value: function setTransparency(transp) {
          var el = this.getElement()

          if (el === null) {
            return
          }

          if (transp === 1.0) {
            el.style.display = 'none'
            return
          }

          el.style.display = 'inline'
          var op = 1.0 - transp
          var top = op.toString()
          var op100 = op * 100
          el.style.opacity = top
          el.style.filter = 'alpha(opacity='.concat(op100, ')')
        }
      },
      {
        key: 'clone',
        value: function clone() {
          var obj = new CSS2DObject(this._element)
          obj.copy(this)
          return obj
        }
      }
    ])

    return CSS2DObject
  })(THREE__namespace.Object3D)

  function _createSuper$1T(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1T()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1T() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var RCGroup = /*#__PURE__*/ (function (_THREE$Group) {
    _inherits(RCGroup, _THREE$Group)

    var _super = _createSuper$1T(RCGroup)

    function RCGroup() {
      _classCallCheck(this, RCGroup)

      return _super.apply(this, arguments)
    }

    _createClass(RCGroup, [
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          if (!this.visible) {
            return
          }

          var children = this.children

          for (var i = 0, n = children.length; i < n; ++i) {
            children[i].raycast(raycaster, intersects)
          }
        }
      },
      {
        key: 'enableSubset',
        value: function enableSubset(mask, innerOnly) {
          var children = this.children

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].enableSubset) {
              children[i].enableSubset(mask, innerOnly)
            }
          }
        }
      },
      {
        key: 'disableSubset',
        value: function disableSubset(mask, innerOnly) {
          var children = this.children

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].disableSubset) {
              children[i].disableSubset(mask, innerOnly)
            }
          }
        }
      },
      {
        key: 'isEmpty',
        value: function isEmpty() {
          return this.children.length === 0
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var children = this.children

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].updateToFrame) {
              children[i].updateToFrame(frameData)
            }
          }
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          var totalSubset = []
          var children = this.children

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].getSubset) {
              Array.prototype.push.apply(
                totalSubset,
                children[i].getSubset(mask, innerOnly)
              )
            }
          }

          return totalSubset
        }
      }
    ])

    return RCGroup
  })(THREE__namespace.Group)

  var vertexScreenQuadShader =
    'uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec2 uv;\r\nattribute vec3 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n'

  var fragmentScreenQuadFromTex =
    'precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color = texture2D(srcTex, vUv);\r\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\r\n}\r\n'

  var fragmentScreenQuadFromTexWithDistortion =
    'precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float coef;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  float r2 = dot(uv, uv);\r\n  vec2 tc = uv * (1.0 + coef * r2);\r\n  if (!all(lessThan(abs(tc), vec2(1.0))))\r\n    discard;\r\n  tc = 0.5 * (tc + 1.0);\r\n  gl_FragColor = texture2D(srcTex, tc);\r\n}\r\n'

  function _createSuper$1S(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1S()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1S() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var LAYERS = {
    DEFAULT: 0,
    VOLUME: 1,
    TRANSPARENT: 2,
    PREPASS_TRANSPARENT: 3,
    VOLUME_BFPLANE: 4,
    COLOR_FROM_POSITION: 5,
    SHADOWMAP: 6
  }
  var SELECTION_LAYERS = [LAYERS.DEFAULT, LAYERS.TRANSPARENT]

  THREE__namespace.Object3D.prototype.resetTransform = function () {
    this.position.set(0, 0, 0)
    this.quaternion.set(0, 0, 0, 1)
    this.scale.set(1, 1, 1)
  }

  THREE__namespace.Object3D.prototype.updateMatrixWorldRecursive = function () {
    if (this.parent != null) {
      this.parent.updateMatrixWorldRecursive()
    }

    this.updateMatrixWorld()
  }

  THREE__namespace.Object3D.prototype.addSavingWorldTransform = (function () {
    var _worldMatrixInverse = new THREE__namespace.Matrix4()

    return function (object) {
      if (object instanceof THREE__namespace.Object3D) {
        _worldMatrixInverse.copy(this.matrixWorld).invert()

        _worldMatrixInverse.multiply(object.matrixWorld)

        object.matrix.copy(_worldMatrixInverse)
        object.matrix.decompose(
          object.position,
          object.quaternion,
          object.scale
        )
        this.add(object)
      }
    }
  })()

  THREE__namespace.WebGLRenderer.prototype.renderDummyQuad = (function () {
    var _material = new THREE__namespace.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
      depthWrite: false
    })

    var _scene = new THREE__namespace.Scene()

    var _quad = new THREE__namespace.Mesh(
      new THREE__namespace.PlaneBufferGeometry(0.01, 0.01),
      _material
    )

    _scene.add(_quad)

    var _camera = new THREE__namespace.OrthographicCamera(
      -0.5,
      0.5,
      0.5,
      -0.5,
      -10000,
      10000
    )

    _camera.position.z = 100
    return function () {
      this.render(_scene, _camera)
    }
  })()

  THREE__namespace.WebGLRenderer.prototype.renderScreenQuad = (function () {
    var _scene = new THREE__namespace.Scene()

    var _quad = new THREE__namespace.Mesh(
      new THREE__namespace.PlaneBufferGeometry(1.0, 1.0)
    )

    _scene.add(_quad)

    var _camera = new THREE__namespace.OrthographicCamera(
      -0.5,
      0.5,
      0.5,
      -0.5,
      -10000,
      10000
    )

    _camera.position.z = 100
    return function (material) {
      _quad.material = material
      this.render(_scene, _camera)
    }
  })()

  THREE__namespace.Matrix4.prototype.isIdentity = (function () {
    var identity = new THREE__namespace.Matrix4()
    return function () {
      return identity.equals(this)
    }
  })()

  THREE__namespace.Matrix4.prototype.applyToPointsArray = function (
    array,
    stride,
    w
  ) {
    if (!array || !stride || stride < 3) {
      return array
    }

    w = w || 0
    var e = this.elements

    for (var i = 0; i < array.length; i += stride) {
      var x = array[i]
      var y = array[i + 1]
      var z = array[i + 2]
      var persp = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15])
      array[i] = (e[0] * x + e[4] * y + e[8] * z + e[12] * w) * persp
      array[i + 1] = (e[1] * x + e[5] * y + e[9] * z + e[13] * w) * persp
      array[i + 2] = (e[2] * x + e[6] * y + e[10] * z + e[14] * w) * persp
    }

    return array
  }

  var ScreenQuadMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(ScreenQuadMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$1S(ScreenQuadMaterial)

    function ScreenQuadMaterial(params) {
      _classCallCheck(this, ScreenQuadMaterial)

      if (params.uniforms === undefined) {
        params.uniforms = {}
      }

      params.uniforms.srcTex = {
        type: 't',
        value: null
      }
      params.vertexShader = vertexScreenQuadShader
      params.transparent = false
      params.depthTest = false
      params.depthWrite = false
      return _super.call(this, params)
    }

    return _createClass(ScreenQuadMaterial)
  })(THREE__namespace.RawShaderMaterial)

  THREE__namespace.WebGLRenderer.prototype.renderScreenQuadFromTex =
    (function () {
      var _material = new ScreenQuadMaterial({
        uniforms: {
          opacity: {
            type: 'f',
            value: 1.0
          }
        },
        fragmentShader: fragmentScreenQuadFromTex,
        transparent: true
      })

      return function (srcTex, opacity) {
        _material.uniforms.srcTex.value = srcTex
        _material.transparent = opacity < 1.0
        _material.uniforms.opacity.value = opacity
        this.renderScreenQuad(_material)
      }
    })()

  THREE__namespace.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion =
    (function () {
      var _material = new ScreenQuadMaterial({
        uniforms: {
          coef: {
            type: 'f',
            value: 1.0
          }
        },
        fragmentShader: fragmentScreenQuadFromTexWithDistortion
      })

      return function (srcTex, coef) {
        _material.uniforms.srcTex.value = srcTex
        _material.uniforms.coef.value = coef
        this.renderScreenQuad(_material)
      }
    })()

  THREE__namespace.PerspectiveCamera.prototype.setMinimalFov = function (
    angle
  ) {
    if (this.aspect >= 1.0) {
      this.fov = angle
    } else {
      this.fov = THREE__namespace.MathUtils.radToDeg(
        2 *
          Math.atan(
            Math.tan(THREE__namespace.MathUtils.degToRad(angle) * 0.5) /
              this.aspect
          )
      )
    }
  }

  THREE__namespace.StereoCamera.prototype.updateHalfSized = function (
    camera,
    angle
  ) {
    var originalAspect = camera.aspect
    var originalFov = camera.fov
    camera.aspect = originalAspect / 2.0
    camera.setMinimalFov(angle)
    camera.updateProjectionMatrix()
    this.update(camera)
    camera.aspect = originalAspect
    camera.fov = originalFov
    camera.updateProjectionMatrix()
  }

  THREE__namespace.PerspectiveCamera.prototype.setDistanceToFit = function (
    radius,
    angle
  ) {
    this.position.z =
      radius / Math.sin(0.5 * THREE__namespace.MathUtils.degToRad(angle))
  }

  THREE__namespace.Raycaster.prototype.intersectVisibleObject = function (
    gfxObj,
    camera,
    clipPlane,
    fogFarPlane
  ) {
    var intersects = this.intersectObject(gfxObj, false)

    if (intersects.length === 0) {
      return null
    }

    var nearPlane = Math.min(camera.near, clipPlane)
    var i
    var p = intersects[0]
    var v = new THREE__namespace.Vector3()

    for (i = 0; i < intersects.length; ++i) {
      p = intersects[i]
      v.copy(p.point)
      v.applyMatrix4(camera.matrixWorldInverse)

      if (v.z <= -nearPlane) {
        break
      }
    }

    if (i === intersects.length) {
      return null
    }

    var farPlane = Math.min(camera.far, fogFarPlane)
    v.copy(p.point)
    v.applyMatrix4(camera.matrixWorldInverse)

    if (v.z <= -farPlane) {
      return null
    }

    return p
  }

  THREE__namespace.Matrix4.prototype.extractScale = (function () {
    var _v = new THREE__namespace.Vector3()

    return function (scale) {
      if (scale === undefined) {
        logger.debug(
          'extractScale(): new is too expensive operation to do it on-the-fly'
        )
        scale = _v.clone()
      }

      var te = this.elements
      scale.x = _v.set(te[0], te[1], te[2]).length()
      scale.y = _v.set(te[4], te[5], te[6]).length()
      scale.z = _v.set(te[8], te[9], te[10]).length()
      var det = this.determinant()

      if (det < 0) {
        scale.x = -scale.x
      }

      return scale
    }
  })()

  function _calcCylinderMatrix(posBegin, posEnd, radius) {
    var posCenter = posBegin.clone().lerp(posEnd, 0.5)
    var matScale = new THREE__namespace.Matrix4()
    matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius)
    var matRotHalf = new THREE__namespace.Matrix4()
    matRotHalf.makeRotationX(Math.PI / 2)
    var matRotLook = new THREE__namespace.Matrix4()
    var vUp = new THREE__namespace.Vector3(0, 1, 0)
    matRotLook.lookAt(posCenter, posEnd, vUp)
    matRotLook.multiply(matRotHalf)
    matRotLook.multiply(matScale)
    matRotLook.setPosition(posCenter)
    return matRotLook
  }

  function _calcChunkMatrix(eye, target, up, rad) {
    var matScale = new THREE__namespace.Matrix4()
    matScale.makeScale(rad.x, rad.y, 0)
    var matRotLook = new THREE__namespace.Matrix4()
    matRotLook.lookAt(eye, target, up)
    matRotLook.multiply(matScale)
    matRotLook.setPosition(eye)
    return matRotLook
  }

  function _groupHasGeometryToRender(group) {
    var hasGeoms = false
    group.traverse(function (node) {
      if (node.hasOwnProperty('geometry') || node instanceof CSS2DObject) {
        hasGeoms = true
      }
    })
    return hasGeoms
  }

  function _buildDistorionMesh(widthSegments, heightSegements, coef) {
    function calcInverseBarrel(r2) {
      var epsilon = 1e-5
      var prevR2 = 0.0
      var curR2 = r2
      var dr = 1.0

      while (Math.abs(curR2 - prevR2) > epsilon) {
        dr = 1.0 + coef * curR2
        prevR2 = curR2
        curR2 = r2 / (dr * dr)
      }

      return 1.0 / dr
    }

    var geo = new THREE__namespace.PlaneBufferGeometry(
      2.0,
      2.0,
      widthSegments,
      heightSegements
    )
    var pos = geo.getAttribute('position')

    for (var i = 0; i < pos.count; ++i) {
      var x = pos.array[3 * i]
      var y = pos.array[3 * i + 1]
      var c = calcInverseBarrel(x * x + y * y)
      pos.setXY(i, c * x, c * y)
    }

    return geo
  }

  THREE__namespace.BufferAttribute.prototype.copyAtList = function (
    attribute,
    indexList
  ) {
    console.assert(
      this.itemSize === attribute.itemSize,
      'false: BufferAttribute.copyAtList buffers have different item size.'
    )
    var itemSize = this.itemSize

    for (var i = 0, n = indexList.length; i < n; ++i) {
      for (var j = 0; j < itemSize; ++j) {
        this.array[i * itemSize + j] =
          attribute.array[indexList[i] * itemSize + j]
      }
    }

    return this
  }

  function fillArray(array, value, startIndex, endIndex) {
    startIndex = typeof startIndex !== 'undefined' ? startIndex : 0
    endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length

    for (var i = startIndex; i < endIndex; ++i) {
      array[i] = value
    }
  }

  function removeChildren(object) {
    var children = object.children

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i]
      child.parent = null
      child.dispatchEvent({
        type: 'removed'
      })
    }

    object.children = []
  }

  function clearTree(object) {
    object.traverse(function (obj) {
      if (
        obj instanceof THREE__namespace.Mesh ||
        obj instanceof THREE__namespace.LineSegments ||
        obj instanceof THREE__namespace.Line
      ) {
        obj.geometry.dispose()
      }
    })
    removeChildren(object)
  }

  function destroyObject(object) {
    clearTree(object)

    if (object.parent) {
      object.parent.remove(object)
    } else {
      object.dispatchEvent({
        type: 'removed'
      })
    }
  }

  function belongToSelectLayers(object) {
    for (var i = 0; i < SELECTION_LAYERS.length; i++) {
      if (((object.layers.mask >> SELECTION_LAYERS[i]) & 1) === 1) {
        return true
      }
    }

    return false
  }

  function processObjRenderOrder(root, idMaterial) {
    var renderOrder = +(idMaterial !== 'BA')
    root.traverse(function (object) {
      if (object.isGroup) {
        object.renderOrder = renderOrder
      }
    })
  }

  function applySelectionMaterial(geo) {
    geo.traverse(function (node) {
      if ('material' in node) {
        node.material = node.material.clone(true)
        node.material.setValues({
          depthFunc: THREE__namespace.LessEqualDepth,
          overrideColor: true,
          fog: false,
          lights: false,
          shadowmap: false
        })
        node.material.setUberOptions({
          fixedColor: new THREE__namespace.Color(0xffff00),
          zOffset: -1e-6
        })
      }
    })
  }

  function getMiddlePoint(point1, point2, optionalTarget) {
    var result = optionalTarget || new THREE__namespace.Vector3()
    result.set(0, 0, 0)
    result.addScaledVector(point1, 0.5)
    result.addScaledVector(point2, 0.5)
    return result
  }

  var _oldInstancedBufferGeometryCopy =
    THREE__namespace.InstancedBufferGeometry.prototype.copy

  THREE__namespace.InstancedBufferGeometry.prototype.copy = function (source) {
    _oldInstancedBufferGeometryCopy.call(this, source)

    if (this.instanceCount === undefined) {
      this.instanceCount = Infinity
    }
  }

  var gfxutils = {
    calcCylinderMatrix: _calcCylinderMatrix,
    calcChunkMatrix: _calcChunkMatrix,
    groupHasGeometryToRender: _groupHasGeometryToRender,
    buildDistorionMesh: _buildDistorionMesh,
    RCGroup: RCGroup,
    fillArray: fillArray,
    clearTree: clearTree,
    destroyObject: destroyObject,
    belongToSelectLayers: belongToSelectLayers,
    processObjRenderOrder: processObjRenderOrder,
    applySelectionMaterial: applySelectionMaterial,
    getMiddlePoint: getMiddlePoint,
    LAYERS: LAYERS
  }

  function _createSuper$1R(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1R()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1R() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var _defaultBoundaries = {
    boundingBox: new THREE__namespace.Box3(
      new THREE__namespace.Vector3(-1, -1, -1),
      new THREE__namespace.Vector3(1, 1, 1)
    ),
    boundingSphere: new THREE__namespace.Sphere(
      new THREE__namespace.Vector3(0, 0, 0),
      1
    )
  }

  var Visual = /*#__PURE__*/ (function (_gfxutils$RCGroup) {
    _inherits(Visual, _gfxutils$RCGroup)

    var _super = _createSuper$1R(Visual)

    function Visual(name, dataSource) {
      var _this

      _classCallCheck(this, Visual)

      _this = _super.call(this, name, dataSource)
      _this.name = name
      _this._dataSource = dataSource
      return _this
    }

    _createClass(Visual, [
      {
        key: 'release',
        value: function release() {
          if (this.parent) {
            this.parent.remove(this)
          }
        }
      },
      {
        key: 'getDataSource',
        value: function getDataSource() {
          return this._dataSource
        }
      },
      {
        key: 'getBoundaries',
        value: function getBoundaries() {
          return _defaultBoundaries
        }
      }
    ])

    return Visual
  })(gfxutils.RCGroup)

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr)
  }

  function _iterableToArray(iter) {
    if (
      (typeof Symbol !== 'undefined' && iter[Symbol.iterator] != null) ||
      iter['@@iterator'] != null
    )
      return Array.from(iter)
  }

  function _nonIterableSpread() {
    throw new TypeError(
      'Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'
    )
  }

  function _toConsumableArray(arr) {
    return (
      _arrayWithoutHoles(arr) ||
      _iterableToArray(arr) ||
      _unsupportedIterableToArray$1(arr) ||
      _nonIterableSpread()
    )
  }

  function _ensureArray(x) {
    if (x === null || x === undefined || Array.isArray(x)) {
      return x
    }

    return [x]
  }

  var EntityList = /*#__PURE__*/ (function () {
    function EntityList() {
      var _this = this

      var entities =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []
      var indices =
        arguments.length > 1 && arguments[1] !== undefined
          ? arguments[1]
          : ['id']

      _classCallCheck(this, EntityList)

      this._list = []
      this._dict = {}
      this._indices = _toConsumableArray(indices)

      this._indices.forEach(function (index) {
        _this._dict[index] = {}
      })

      entities.forEach(function (entity) {
        return _this.register(entity)
      })
    }

    _createClass(
      EntityList,
      [
        {
          key: 'register',
          value: function register(entity) {
            var _this2 = this

            EntityList.registerInList(this._list, entity)

            this._indices.forEach(function (index) {
              EntityList.registerInDict(
                _this2._dict[index],
                _ensureArray(entity[index]),
                entity
              )
            })
          }
        },
        {
          key: 'unregister',
          value: function unregister(entity) {
            var _this3 = this

            EntityList.unregisterFromList(this._list, entity)

            this._indices.forEach(function (index) {
              EntityList.unregisterFromDict(
                _this3._dict[index],
                _ensureArray(entity[index]),
                entity
              )
            })
          }
        },
        {
          key: 'all',
          get: function get() {
            return _toConsumableArray(this._list)
          }
        },
        {
          key: 'first',
          get: function get() {
            return this._list[0]
          }
        },
        {
          key: 'keys',
          value: function keys(index) {
            return Object.keys(this._dict[index || this._indices[0]])
          }
        },
        {
          key: 'get',
          value: function get(key, index) {
            var dict = this._dict[index || this._indices[0]]

            if (dict) {
              var values = dict[key && key.toLowerCase()]
              return values && values.length > 0 ? values[0] : undefined
            }

            return undefined
          }
        }
      ],
      [
        {
          key: 'registerInList',
          value: function registerInList(list, value) {
            if (!list.includes(value)) {
              list.push(value)
            }
          }
        },
        {
          key: 'unregisterFromList',
          value: function unregisterFromList(list, value) {
            var pos = list.indexOf(value)

            if (pos !== -1) {
              list.splice(pos, 1)
            }
          }
        },
        {
          key: 'registerInDict',
          value: function registerInDict(dict, keys, value) {
            keys.forEach(function (key) {
              key = key.toLowerCase()
              var list = (dict[key] = dict[key] || [])

              if (!list.includes(value)) {
                list.push(value)
              }
            })
          }
        },
        {
          key: 'unregisterFromDict',
          value: function unregisterFromDict(dict, keys, value) {
            keys.forEach(function (key) {
              key = key.toLowerCase()
              var list = dict[key]

              if (list) {
                var pos = list.indexOf(value)

                if (pos !== -1) {
                  list.splice(pos, 1)
                }

                if (list.length === 0) {
                  delete dict[key]
                }
              }
            })
          }
        }
      ]
    )

    return EntityList
  })()

  function makeContextDependent(prototype) {
    Object.defineProperties(prototype, {
      logger: {
        get: function get() {
          return this.context && this.context.logger
            ? this.context.logger
            : logger
        }
      },
      settings: {
        get: function get() {
          return this.context && this.context.settings
            ? this.context.settings
            : settings$1
        }
      }
    })
  }

  function _createSuper$1Q(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1Q()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1Q() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var CollisionSphere = /*#__PURE__*/ (function () {
    function CollisionSphere(position, radius) {
      _classCallCheck(this, CollisionSphere)

      this._position = position
      this._radius = radius
    }

    _createClass(CollisionSphere, [
      {
        key: 'raycast',
        value: function raycast(raycaster) {
          var sphere = CollisionSphere._sphere
          sphere.set(this._position, this._radius)
          var p = new THREE__namespace.Vector3()

          if (raycaster.ray.intersectSphere(sphere, p)) {
            return {
              distance: raycaster.ray.origin.distanceTo(p),
              point: p
            }
          }

          return null
        }
      }
    ])

    return CollisionSphere
  })()

  _defineProperty(CollisionSphere, '_sphere', new THREE__namespace.Sphere())

  var SphereCollisionGeo = function SphereCollisionGeo(base) {
    return /*#__PURE__*/ (function (_base) {
      _inherits(_class, _base)

      var _super = _createSuper$1Q(_class)

      function _class(count) {
        var _this

        _classCallCheck(this, _class)

        for (
          var _len = arguments.length,
            args = new Array(_len > 1 ? _len - 1 : 0),
            _key = 1;
          _key < _len;
          _key++
        ) {
          args[_key - 1] = arguments[_key]
        }

        _this = _super.call.apply(_super, [this].concat(args))
        _this._objects = new Array(count)
        _this.boundingSphere = null
        _this.boundingBox = null
        return _this
      }

      _createClass(_class, [
        {
          key: 'setSphere',
          value: function setSphere(idx, position, radius) {
            this._objects[idx] = new CollisionSphere(position, radius)
          }
        },
        {
          key: 'raycast',
          value: function raycast(raycaster, intersects) {
            for (var i = 0, n = this._objects.length; i < n; ++i) {
              var inters = this._objects[i].raycast(raycaster)

              if (inters) {
                inters.chunkIdx = i
                intersects.push(inters)
              }
            }
          }
        },
        {
          key: 'computeBoundingBox',
          value: function computeBoundingBox() {
            var objects = this._objects
            var boundingBox = this.boundingBox

            if (boundingBox === null) {
              this.boundingBox = boundingBox = new THREE__namespace.Box3()
            }

            boundingBox.makeEmpty()

            for (var i = 0, n = objects.length; i < n; ++i) {
              boundingBox.expandByPoint(objects[i]._position)
            }
          }
        },
        {
          key: 'computeBoundingSphere',
          value: function computeBoundingSphere() {
            this.computeBoundingBox()
            var objects = this._objects
            var boundingBox = this.boundingBox
            var radiusSquared = 0.0
            var center = new THREE__namespace.Vector3()
            boundingBox.getCenter(center)

            for (var i = 0, n = objects.length; i < n; ++i) {
              var pos = objects[i]._position
              var lengthSquared = center.distanceToSquared(pos)

              if (radiusSquared < lengthSquared) {
                radiusSquared = lengthSquared
              }
            }

            if (this.boundingSphere === null) {
              this.boundingSphere = new THREE__namespace.Sphere()
            }

            this.boundingSphere.set(center, Math.sqrt(radiusSquared))
          }
        }
      ])

      return _class
    })(base)
  }

  function _createSuper$1P(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1P()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1P() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var tmpColor$4 = new THREE__namespace.Color()
  var OFFSET_SIZE$1 = 4
  var COLOR_SIZE$3 = 3
  var copySubArrays$1 = utils.copySubArrays

  function setArrayXYZ$2(arr, idx, x, y, z) {
    arr[idx] = x
    arr[idx + 1] = y
    arr[idx + 2] = z
  }

  function setArrayXYZW$2(arr, idx, x, y, z, w) {
    arr[idx] = x
    arr[idx + 1] = y
    arr[idx + 2] = z
    arr[idx + 3] = w
  }

  var InstancedSpheresGeometry = /*#__PURE__*/ (function (_SphereCollisionGeo) {
    _inherits(InstancedSpheresGeometry, _SphereCollisionGeo)

    var _super = _createSuper$1P(InstancedSpheresGeometry)

    function InstancedSpheresGeometry(
      spheresCount,
      sphereComplexity,
      useZSprites
    ) {
      var _this

      _classCallCheck(this, InstancedSpheresGeometry)

      _this = _super.call(this, spheresCount)
      _this._sphGeometry = useZSprites
        ? new THREE__namespace.PlaneBufferGeometry(2, 2, 1, 1)
        : new THREE__namespace.SphereBufferGeometry(
            1,
            sphereComplexity * 2,
            sphereComplexity,
            0,
            Math.PI * 2,
            0,
            Math.PI
          )

      _this._init(spheresCount, _this._sphGeometry)

      return _this
    }

    _createClass(InstancedSpheresGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, itemPos, itemRad) {
          setArrayXYZW$2(
            this._offsets,
            itemIdx * OFFSET_SIZE$1,
            itemPos.x,
            itemPos.y,
            itemPos.z,
            itemRad
          )
          this.setSphere(itemIdx, itemPos, itemRad)
        }
      },
      {
        key: 'setColor',
        value: function setColor(itemIdx, colorVal) {
          tmpColor$4.set(colorVal)
          setArrayXYZ$2(
            this._colors,
            itemIdx * COLOR_SIZE$3,
            tmpColor$4.r,
            tmpColor$4.g,
            tmpColor$4.b
          )
        }
      },
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'finishUpdate',
        value: function finishUpdate() {
          this.getAttribute('offset').needsUpdate = true
          this.getAttribute('color').needsUpdate = true
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
          this.computeBoundingSphere()
        }
      },
      {
        key: 'setOpacity',
        value: function setOpacity(chunkIndices, value) {
          var alphaArr = this._alpha

          for (var i = 0, n = chunkIndices.length; i < n; ++i) {
            alphaArr[chunkIndices[i]] = value
          }

          this.getAttribute('alphaColor').needsUpdate = true
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(chunkIndices) {
          var instanceCount = chunkIndices.length
          var geom = new THREE__namespace.InstancedBufferGeometry()

          this._init.call(geom, instanceCount, this._sphGeometry)

          copySubArrays$1(
            this._offsets,
            geom._offsets,
            chunkIndices,
            OFFSET_SIZE$1
          )
          copySubArrays$1(
            this._colors,
            geom._colors,
            chunkIndices,
            COLOR_SIZE$3
          )
          geom.boundingSphere = this.boundingSphere
          geom.boundingBox = this.boundingBox
          return [geom]
        }
      },
      {
        key: '_init',
        value: function _init(spheresCount, sphereGeo) {
          this.copy(sphereGeo)
          this._offsets = utils.allocateTyped(
            Float32Array,
            spheresCount * OFFSET_SIZE$1
          )
          this._colors = utils.allocateTyped(
            Float32Array,
            spheresCount * COLOR_SIZE$3
          )
          var alpha = (this._alpha = utils.allocateTyped(
            Float32Array,
            spheresCount
          ))

          ___default['default'].fill(alpha, 1.0)

          this.setAttribute(
            'offset',
            new THREE__namespace.InstancedBufferAttribute(
              this._offsets,
              OFFSET_SIZE$1,
              false,
              1
            )
          )
          this.setAttribute(
            'color',
            new THREE__namespace.InstancedBufferAttribute(
              this._colors,
              COLOR_SIZE$3,
              false,
              1
            )
          )
          this.setAttribute(
            'alphaColor',
            new THREE__namespace.InstancedBufferAttribute(alpha, 1, false, 1)
          )
        }
      }
    ])

    return InstancedSpheresGeometry
  })(SphereCollisionGeo(THREE__namespace.InstancedBufferGeometry))

  function _createSuper$1O(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1O()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1O() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var MAX_IDC_16BIT$1 = 65535
  var VEC_SIZE$4 = 3
  var tmpColor$3 = new THREE__namespace.Color()

  var ChunkedObjectsGeometry = /*#__PURE__*/ (function (_THREE$BufferGeometry) {
    _inherits(ChunkedObjectsGeometry, _THREE$BufferGeometry)

    var _super = _createSuper$1O(ChunkedObjectsGeometry)

    function ChunkedObjectsGeometry(chunkGeo, chunksCount) {
      var _this

      _classCallCheck(this, ChunkedObjectsGeometry)

      _this = _super.call(this)

      if (_this.constructor === ChunkedObjectsGeometry) {
        throw new Error('Can not instantiate abstract class!')
      }

      _this._chunkGeo = chunkGeo

      _this._init(chunkGeo, chunksCount)

      return _this
    }

    _createClass(ChunkedObjectsGeometry, [
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'finishUpdate',
        value: function finishUpdate() {
          this.getAttribute('position').needsUpdate = true
          this.getAttribute('normal').needsUpdate = true
          this.getAttribute('color').needsUpdate = true
        }
      },
      {
        key: 'setColor',
        value: function setColor(chunkIdx, colorVal) {
          tmpColor$3.set(colorVal)
          var colors = this._colors
          var chunkSize = this._chunkSize

          for (
            var i = chunkIdx * chunkSize, end = i + chunkSize;
            i < end;
            ++i
          ) {
            var idx = i * VEC_SIZE$4
            colors[idx] = tmpColor$3.r
            colors[idx + 1] = tmpColor$3.g
            colors[idx + 2] = tmpColor$3.b
          }
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
          this.computeBoundingSphere()
        }
      },
      {
        key: 'setOpacity',
        value: function setOpacity(chunkIndices, value) {
          var alphaArr = this._alpha
          var chunkSize = this._chunkSize

          for (var i = 0, n = chunkIndices.length; i < n; ++i) {
            var left = chunkIndices[i] * chunkSize

            ___default['default'].fill(alphaArr, value, left, left + chunkSize)
          }

          this.getAttribute('alphaColor').needsUpdate = true
        }
      },
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var inters = []
          var mesh = new THREE__namespace.Mesh()
          mesh.geometry = this
          mesh.raycast(raycaster, inters)
          var facesPerChunk = this._chunkGeo.index.count / 3

          for (var i = 0, n = inters.length; i < n; ++i) {
            if (!inters[i].hasOwnProperty('faceIndex')) {
              continue
            }

            inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk)
            intersects.push(inters[i])
          }
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(chunkIndices) {
          var instanceCount = chunkIndices.length
          var geom = new THREE__namespace.BufferGeometry()

          this._init.call(geom, this._chunkGeo, instanceCount)

          var srcPos = this._positions
          var srcNorm = this._normals
          var srcColor = this._colors
          var dstPos = geom._positions
          var dstNorm = geom._normals
          var dstColor = geom._colors
          var chunkSize = this._chunkSize * VEC_SIZE$4

          for (var i = 0, n = chunkIndices.length; i < n; ++i) {
            var dstPtOffset = i * chunkSize
            var ptIdxBegin = chunkIndices[i] * chunkSize
            var ptIdxEnd = ptIdxBegin + chunkSize
            dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset)
            dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset)
            dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset)
          }

          geom.boundingSphere = this.boundingSphere
          geom.boundingBox = this.boundingBox
          return [geom]
        }
      },
      {
        key: '_init',
        value: function _init(chunkGeo, chunksCount) {
          var chunkSize = (this._chunkSize = chunkGeo.attributes.position.count)
          var chunkIndex = chunkGeo.index.array
          var chunkIndexSize = chunkIndex.length
          var pointsCount = this._chunkSize * chunksCount
          var use32bitIndex = pointsCount > MAX_IDC_16BIT$1
          var indexSize = chunkIndexSize * chunksCount
          var index = (this._index = utils.allocateTyped(
            use32bitIndex ? Uint32Array : Uint16Array,
            indexSize
          ))
          this._positions = utils.allocateTyped(
            Float32Array,
            pointsCount * VEC_SIZE$4
          )
          this._normals = utils.allocateTyped(
            Float32Array,
            pointsCount * VEC_SIZE$4
          )
          this._colors = utils.allocateTyped(
            Float32Array,
            pointsCount * VEC_SIZE$4
          )
          var alpha = (this._alpha = utils.allocateTyped(
            Float32Array,
            pointsCount
          ))

          ___default['default'].fill(alpha, 1.0)

          for (var i = 0; i < chunksCount; ++i) {
            var offset = i * chunkIndexSize
            var posOffset = i * chunkSize
            index.set(chunkIndex, offset)

            for (var j = 0; j < chunkIndexSize; ++j) {
              index[offset + j] += posOffset
            }
          }

          this.setIndex(new THREE__namespace.BufferAttribute(this._index, 1))
          this.setAttribute(
            'position',
            new THREE__namespace.BufferAttribute(this._positions, VEC_SIZE$4)
          )
          this.setAttribute(
            'normal',
            new THREE__namespace.BufferAttribute(this._normals, VEC_SIZE$4)
          )
          this.setAttribute(
            'color',
            new THREE__namespace.BufferAttribute(this._colors, VEC_SIZE$4)
          )
          this.setAttribute(
            'alphaColor',
            new THREE__namespace.BufferAttribute(alpha, 1)
          )
        }
      }
    ])

    return ChunkedObjectsGeometry
  })(THREE__namespace.BufferGeometry)

  function _createSuper$1N(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1N()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1N() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var VEC_SIZE$3 = 3

  var SimpleSpheresGeometry = /*#__PURE__*/ (function (_SphereCollisionGeo) {
    _inherits(SimpleSpheresGeometry, _SphereCollisionGeo)

    var _super = _createSuper$1N(SimpleSpheresGeometry)

    function SimpleSpheresGeometry(spheresCount, sphereComplexity) {
      var _this

      _classCallCheck(this, SimpleSpheresGeometry)

      var sphGeometry = new THREE__namespace.SphereBufferGeometry(
        1,
        sphereComplexity * 2,
        sphereComplexity,
        0,
        Math.PI * 2,
        0,
        Math.PI
      )
      _this = _super.call(this, spheresCount, sphGeometry, spheresCount)
      var normals = _this._normals
      var geoNormals = sphGeometry.attributes.normal.array
      var chunkSize = _this._chunkSize
      _this._chunkPos = _this._chunkGeo.attributes.position.array
      _this._tmpPositions = utils.allocateTyped(
        Float32Array,
        chunkSize * VEC_SIZE$3
      )

      for (var i = 0; i < spheresCount; ++i) {
        normals.set(geoNormals, chunkSize * VEC_SIZE$3 * i)
      }

      return _this
    }

    _createClass(SimpleSpheresGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, itemPos, itemRad) {
          var tmpPos = this._tmpPositions
          var chunkSize = this._chunkSize
          var geoPos = this._chunkPos

          for (var i = 0; i < chunkSize; ++i) {
            var idx = i * 3
            tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad
            tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad
            tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad
          }

          this._positions.set(tmpPos, chunkSize * itemIdx * VEC_SIZE$3)

          this.setSphere(itemIdx, itemPos, itemRad)
        }
      }
    ])

    return SimpleSpheresGeometry
  })(SphereCollisionGeo(ChunkedObjectsGeometry))

  function _createSuper$1M(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1M()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1M() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var VEC_SIZE$2 = 3
  var centerPos = new THREE__namespace.Vector3()
  var tmpVector$2 = new THREE__namespace.Vector3()
  var normMtx$1 = new THREE__namespace.Matrix3()

  var Simple2CCylindersGeometry = /*#__PURE__*/ (function (
    _ChunkedObjectsGeomet
  ) {
    _inherits(Simple2CCylindersGeometry, _ChunkedObjectsGeomet)

    var _super = _createSuper$1M(Simple2CCylindersGeometry)

    function Simple2CCylindersGeometry(instanceCount, polyComplexity) {
      var _this

      _classCallCheck(this, Simple2CCylindersGeometry)

      var cylGeometry = new THREE__namespace.CylinderBufferGeometry(
        1,
        1,
        1.0,
        Math.max(3, polyComplexity),
        2,
        true
      )
      _this = _super.call(this, cylGeometry, 2 * instanceCount)
      var chunkSize = _this._chunkSize
      _this._chunkPos = _this._chunkGeo.attributes.position.array
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array
      _this._tmpVector = utils.allocateTyped(
        Float32Array,
        chunkSize * VEC_SIZE$2
      )
      return _this
    }

    _createClass(Simple2CCylindersGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, botPos, topPos, itemRad) {
          var chunkSize = this._chunkSize
          var firstOffset = chunkSize * 2 * itemIdx * VEC_SIZE$2
          var secondOffset = firstOffset + chunkSize * VEC_SIZE$2
          var tmpArray = this._tmpVector
          var geoPos = this._chunkPos
          var geoNorm = this._chunkNorms
          centerPos.lerpVectors(botPos, topPos, 0.5)
          var mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad)
          normMtx$1.getNormalMatrix(mtx1)
          var idx

          for (var i = 0; i < chunkSize; ++i) {
            idx = i * VEC_SIZE$2
            tmpVector$2.fromArray(geoPos, idx)
            tmpVector$2.applyMatrix4(mtx1)
            tmpVector$2.toArray(tmpArray, idx)
          }

          this._positions.set(tmpArray, firstOffset)

          centerPos.sub(botPos)

          for (var _i = 0; _i < chunkSize; ++_i) {
            idx = _i * VEC_SIZE$2
            tmpArray[idx] += centerPos.x
            tmpArray[idx + 1] += centerPos.y
            tmpArray[idx + 2] += centerPos.z
          }

          this._positions.set(tmpArray, secondOffset)

          for (var _i2 = 0; _i2 < chunkSize; ++_i2) {
            idx = _i2 * VEC_SIZE$2
            tmpVector$2.fromArray(geoNorm, idx)
            tmpVector$2.applyMatrix3(normMtx$1)
            tmpVector$2.toArray(tmpArray, idx)
          }

          this._normals.set(tmpArray, firstOffset)

          this._normals.set(tmpArray, secondOffset)
        }
      },
      {
        key: 'setColor',
        value: function setColor(itemIdx, colorVal1, colorVal2) {
          var first = 2 * itemIdx

          _get(
            _getPrototypeOf(Simple2CCylindersGeometry.prototype),
            'setColor',
            this
          ).call(this, first, colorVal1)

          var second = first + 1

          _get(
            _getPrototypeOf(Simple2CCylindersGeometry.prototype),
            'setColor',
            this
          ).call(this, second, colorVal2)
        }
      }
    ])

    return Simple2CCylindersGeometry
  })(ChunkedObjectsGeometry)

  function _createSuper$1L(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1L()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1L() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var MAX_POINTS_COUNT_16BIT = 65536
  var PTS_PER_TRIANGLE = 3

  var CylinderBufferGeometry = /*#__PURE__*/ (function (_THREE$BufferGeometry) {
    _inherits(CylinderBufferGeometry, _THREE$BufferGeometry)

    var _super = _createSuper$1L(CylinderBufferGeometry)

    function CylinderBufferGeometry(
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded
    ) {
      var _this

      _classCallCheck(this, CylinderBufferGeometry)

      _this = _super.call(this)
      var thetaStart = 0
      var thetaLength = 2 * Math.PI
      _this.type = 'CylinderBufferGeometry'
      _this.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded
      }
      var hasTop = openEnded === false && radiusTop > 0
      var hasBottom = openEnded === false && radiusBottom > 0
      var vertexCount =
        (heightSegments + 1) * radialSegments +
        hasTop * (radialSegments + 1) +
        hasBottom * (radialSegments + 1)
      var facesCount =
        (2 * heightSegments + hasTop + hasBottom) * radialSegments
      var heightHalf = height / 2
      var positions = new THREE__namespace.BufferAttribute(
        utils.allocateTyped(Float32Array, vertexCount * 3),
        3
      )
      var normals = new THREE__namespace.BufferAttribute(
        utils.allocateTyped(Float32Array, vertexCount * 3),
        3
      )
      var indices = new THREE__namespace.Uint16BufferAttribute(
        utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE),
        1
      )
      var uvs = new THREE__namespace.BufferAttribute(
        utils.allocateTyped(Float32Array, vertexCount * 2),
        2
      )
      console.assert(
        vertexCount < MAX_POINTS_COUNT_16BIT,
        'false: Cylinder Geometry has too many vertices (65536 max).'
      )
      var currVtxIdx = 0
      var currFaceIdx = 0
      var tanTheta = -(radiusBottom - radiusTop) / height

      for (var y = 0; y <= heightSegments; y++) {
        if (y !== heightSegments) {
          for (var i = 0; i < radialSegments; i++) {
            var v1 = currVtxIdx + i
            var v2 = currVtxIdx + radialSegments + i
            var v3 = currVtxIdx + radialSegments + ((i + 1) % radialSegments)
            var v4 = currVtxIdx + ((i + 1) % radialSegments)
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2)
            currFaceIdx++
            indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3)
            currFaceIdx++
          }
        }

        var v = y / heightSegments
        var radius = v * (radiusBottom - radiusTop) + radiusTop

        for (var x = 0; x < radialSegments; x++) {
          var u = x / radialSegments
          var vx = radius * Math.sin(u * thetaLength + thetaStart)
          var vy = v * height - heightHalf
          var vz = radius * Math.cos(u * thetaLength + thetaStart)
          var normal = new THREE__namespace.Vector3(
            vx,
            Math.sqrt(vx * vx + vz * vz) * tanTheta,
            vz
          ).normalize()
          positions.setXYZ(currVtxIdx, vx, vy, vz)
          normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z)
          uvs.setXY(currVtxIdx, u, v)
          ++currVtxIdx
        }
      }

      if (hasTop) {
        var startTIdx = currVtxIdx
        var lastIdx = currVtxIdx + radialSegments

        for (var fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
          var currSrcIdx = currVtxIdx - radialSegments
          positions.setXYZ(
            currVtxIdx,
            positions.getX(currSrcIdx),
            positions.getY(currSrcIdx),
            positions.getZ(currSrcIdx)
          )
          normals.setXYZ(currVtxIdx, 0, 1, 0)
          uvs.setXY(currVtxIdx, 1, 1)
          var nextTVtx = startTIdx + ((fTIdx + 1) % radialSegments)
          indices.setXYZ(
            currFaceIdx * PTS_PER_TRIANGLE,
            currVtxIdx,
            nextTVtx,
            lastIdx
          )
          currFaceIdx++
          currVtxIdx++
        }

        positions.setXYZ(currVtxIdx, 0, heightHalf, 0)
        normals.setXYZ(currVtxIdx, 0, 1, 0)
        uvs.setXY(currVtxIdx, 1, 1)
        ++currVtxIdx
      }

      if (hasBottom) {
        var startBIdx = currVtxIdx
        var lastBIdx = currVtxIdx + radialSegments

        for (var fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
          var currSrcBIdx = fBIdx
          positions.setXYZ(
            currVtxIdx,
            positions.getX(currSrcBIdx),
            positions.getY(currSrcBIdx),
            positions.getZ(currSrcBIdx)
          )
          normals.setXYZ(currVtxIdx, 0, -1, 0)
          uvs.setXY(currVtxIdx, 0, 0)
          var nextBVtx = startBIdx + ((fBIdx + 1) % radialSegments)
          indices.setXYZ(
            currFaceIdx * PTS_PER_TRIANGLE,
            nextBVtx,
            currVtxIdx,
            lastBIdx
          )
          currFaceIdx++
          currVtxIdx++
        }

        positions.setXYZ(currVtxIdx, 0, -heightHalf, 0)
        normals.setXYZ(currVtxIdx, 0, -1, 0)
        uvs.setXY(currVtxIdx, 0, 0)
      }

      _this.setIndex(indices)

      _this.setAttribute('position', positions)

      _this.setAttribute('normal', normals)

      _this.setAttribute('uv', uvs)

      return _this
    }

    _createClass(CylinderBufferGeometry, [
      {
        key: 'clone',
        value: function clone() {
          var parameters = this.parameters
          return new CylinderBufferGeometry(
            parameters.radiusTop,
            parameters.radiusBottom,
            parameters.height,
            parameters.radialSegments,
            parameters.heightSegments,
            parameters.openEnded
          )
        }
      }
    ])

    return CylinderBufferGeometry
  })(THREE__namespace.BufferGeometry)

  function _createSuper$1K(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1K()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1K() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var tmpColor$2 = new THREE__namespace.Color()
  var invMatrix = new THREE__namespace.Matrix4()
  var OFFSET_SIZE = 4
  var COLOR_SIZE$2 = 3
  var copySubArrays = utils.copySubArrays

  function setArrayXYZ$1(arr, idx, x, y, z) {
    arr[idx] = x
    arr[idx + 1] = y
    arr[idx + 2] = z
  }

  function setArrayXYZW$1(arr, idx, x, y, z, w) {
    arr[idx] = x
    arr[idx + 1] = y
    arr[idx + 2] = z
    arr[idx + 3] = w
  }

  function sortNumber(a, b) {
    return a - b
  }

  function _prepareCylinderInfo(chunkIndices) {
    chunkIndices.sort(sortNumber)
    var chunksIdx = []
    var cylinderInfo = []

    for (var i = 0, n = chunkIndices.length; i < n; ++i) {
      var val = chunkIndices[i]
      var even = (val | 0) % 2 === 0
      var newPar = {
        first: false,
        second: false
      }

      if (even) {
        newPar.first = true
        newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1

        if (newPar.second) {
          ++i
        }
      } else {
        newPar.second = true
      }

      chunksIdx.push(Math.floor(val / 2))
      cylinderInfo.push(newPar)
    }

    return {
      indices: chunksIdx,
      cylinderInfo: cylinderInfo
    }
  }

  function _assignOpacity(cylinderInfo, color1, color2) {
    for (var i = 0, n = cylinderInfo.length; i < n; ++i) {
      var info = cylinderInfo[i]

      if (!info.first) {
        color1[COLOR_SIZE$2 * i] = -0.5
      }

      if (!info.second) {
        color2[COLOR_SIZE$2 * i] = -0.5
      }
    }
  }

  var Instanced2CCylindersGeometry = /*#__PURE__*/ (function (
    _THREE$InstancedBuffe
  ) {
    _inherits(Instanced2CCylindersGeometry, _THREE$InstancedBuffe)

    var _super = _createSuper$1K(Instanced2CCylindersGeometry)

    function Instanced2CCylindersGeometry(
      instanceCount,
      polyComplexity,
      useZSprites,
      openEnded
    ) {
      var _this

      _classCallCheck(this, Instanced2CCylindersGeometry)

      _this = _super.call(this)
      _this._useZSprites = useZSprites
      _this._cylGeometry = useZSprites
        ? new THREE__namespace.PlaneBufferGeometry(2, 2, 1, 1)
        : new CylinderBufferGeometry(
            1,
            1,
            1.0,
            Math.max(3, polyComplexity),
            2,
            openEnded
          )

      _this._init(instanceCount, _this._cylGeometry, _this._useZSprites)

      _this._collisionGeo = new Simple2CCylindersGeometry(instanceCount, 3)
      return _this
    }

    _createClass(Instanced2CCylindersGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, botPos, topPos, itemRad) {
          var matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad)
          var me = matrix.elements
          var mtxOffset = itemIdx * OFFSET_SIZE

          this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad)

          setArrayXYZW$1(
            this._matVector1,
            mtxOffset,
            me[0],
            me[4],
            me[8],
            me[12]
          )
          setArrayXYZW$1(
            this._matVector2,
            mtxOffset,
            me[1],
            me[5],
            me[9],
            me[13]
          )
          setArrayXYZW$1(
            this._matVector3,
            mtxOffset,
            me[2],
            me[6],
            me[10],
            me[14]
          )

          if (this._useZSprites) {
            invMatrix.copy(matrix).invert()
            me = invMatrix.elements
            setArrayXYZW$1(
              this._invmatVector1,
              mtxOffset,
              me[0],
              me[4],
              me[8],
              me[12]
            )
            setArrayXYZW$1(
              this._invmatVector2,
              mtxOffset,
              me[1],
              me[5],
              me[9],
              me[13]
            )
            setArrayXYZW$1(
              this._invmatVector3,
              mtxOffset,
              me[2],
              me[6],
              me[10],
              me[14]
            )
          }
        }
      },
      {
        key: 'setColor',
        value: function setColor(itemIdx, colorVal1, colorVal2) {
          var colorIdx = itemIdx * COLOR_SIZE$2
          tmpColor$2.set(colorVal1)
          setArrayXYZ$1(
            this._color1,
            colorIdx,
            tmpColor$2.r,
            tmpColor$2.g,
            tmpColor$2.b
          )
          tmpColor$2.set(colorVal2)
          setArrayXYZ$1(
            this._color2,
            colorIdx,
            tmpColor$2.r,
            tmpColor$2.g,
            tmpColor$2.b
          )
        }
      },
      {
        key: 'computeBoundingSphere',
        value: function computeBoundingSphere() {
          this._collisionGeo.computeBoundingSphere()

          this.boundingSphere = this._collisionGeo.boundingSphere
        }
      },
      {
        key: 'computeBoundingBox',
        value: function computeBoundingBox() {
          this._collisionGeo.computeBoundingBox()

          this.boundingBox = this._collisionGeo.boundingBox
        }
      },
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          this._collisionGeo.raycast(raycaster, intersects)
        }
      },
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'finishUpdate',
        value: function finishUpdate() {
          this.getAttribute('matVector1').needsUpdate = true
          this.getAttribute('matVector2').needsUpdate = true
          this.getAttribute('matVector3').needsUpdate = true
          this.getAttribute('color').needsUpdate = true
          this.getAttribute('color2').needsUpdate = true
          this.getAttribute('alphaColor').needsUpdate = true

          if (this._useZSprites) {
            this.getAttribute('invmatVector1').needsUpdate = true
            this.getAttribute('invmatVector2').needsUpdate = true
            this.getAttribute('invmatVector3').needsUpdate = true
          }

          this._collisionGeo.finishUpdate()
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
          this.computeBoundingSphere()
        }
      },
      {
        key: 'setOpacity',
        value: function setOpacity(chunkIndices, value) {
          var alphaArr = this._alpha

          for (var i = 0, n = chunkIndices.length; i < n; ++i) {
            alphaArr[Math.floor(chunkIndices[i] / 2)] = value
          }

          this.getAttribute('alphaColor').needsUpdate = true
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(chunkIndices) {
          var info = _prepareCylinderInfo(chunkIndices)

          var cylinderIndices = info.indices
          var instanceCount = cylinderIndices.length
          var geom = new THREE__namespace.InstancedBufferGeometry()

          this._init.call(
            geom,
            instanceCount,
            this._cylGeometry,
            this._useZSprites
          )

          copySubArrays(
            this._matVector1,
            geom._matVector1,
            cylinderIndices,
            OFFSET_SIZE
          )
          copySubArrays(
            this._matVector2,
            geom._matVector2,
            cylinderIndices,
            OFFSET_SIZE
          )
          copySubArrays(
            this._matVector3,
            geom._matVector3,
            cylinderIndices,
            OFFSET_SIZE
          )

          if (this._useZSprites) {
            copySubArrays(
              this._invmatVector1,
              geom._invmatVector1,
              cylinderIndices,
              OFFSET_SIZE
            )
            copySubArrays(
              this._invmatVector2,
              geom._invmatVector2,
              cylinderIndices,
              OFFSET_SIZE
            )
            copySubArrays(
              this._invmatVector3,
              geom._invmatVector3,
              cylinderIndices,
              OFFSET_SIZE
            )
          }

          copySubArrays(
            this._color1,
            geom._color1,
            cylinderIndices,
            COLOR_SIZE$2
          )
          copySubArrays(
            this._color2,
            geom._color2,
            cylinderIndices,
            COLOR_SIZE$2
          )

          _assignOpacity(info.cylinderInfo, geom._color1, geom._color2)

          geom.boundingSphere = this.boundingSphere
          geom.boundingBox = this.boundingBox
          return [geom]
        }
      },
      {
        key: 'getGeoParams',
        value: function getGeoParams() {
          return this._cylGeometry.parameters
        }
      },
      {
        key: '_init',
        value: function _init(instanceCount, cylinderGeo, useZSprites) {
          this.copy(cylinderGeo)
          this._matVector1 = utils.allocateTyped(
            Float32Array,
            instanceCount * OFFSET_SIZE
          )
          this._matVector2 = utils.allocateTyped(
            Float32Array,
            instanceCount * OFFSET_SIZE
          )
          this._matVector3 = utils.allocateTyped(
            Float32Array,
            instanceCount * OFFSET_SIZE
          )
          this._color1 = utils.allocateTyped(
            Float32Array,
            instanceCount * COLOR_SIZE$2
          )
          this._color2 = utils.allocateTyped(
            Float32Array,
            instanceCount * COLOR_SIZE$2
          )
          var alpha = (this._alpha = utils.allocateTyped(
            Float32Array,
            instanceCount
          ))

          ___default['default'].fill(alpha, 1.0)

          this.setAttribute(
            'matVector1',
            new THREE__namespace.InstancedBufferAttribute(
              this._matVector1,
              OFFSET_SIZE,
              false,
              1
            )
          )
          this.setAttribute(
            'matVector2',
            new THREE__namespace.InstancedBufferAttribute(
              this._matVector2,
              OFFSET_SIZE,
              false,
              1
            )
          )
          this.setAttribute(
            'matVector3',
            new THREE__namespace.InstancedBufferAttribute(
              this._matVector3,
              OFFSET_SIZE,
              false,
              1
            )
          )
          this.setAttribute(
            'color',
            new THREE__namespace.InstancedBufferAttribute(
              this._color1,
              COLOR_SIZE$2,
              false,
              1
            )
          )
          this.setAttribute(
            'color2',
            new THREE__namespace.InstancedBufferAttribute(
              this._color2,
              COLOR_SIZE$2,
              false,
              1
            )
          )
          this.setAttribute(
            'alphaColor',
            new THREE__namespace.InstancedBufferAttribute(
              this._alpha,
              1,
              false,
              1
            )
          )

          if (useZSprites) {
            this._invmatVector1 = utils.allocateTyped(
              Float32Array,
              instanceCount * OFFSET_SIZE
            )
            this._invmatVector2 = utils.allocateTyped(
              Float32Array,
              instanceCount * OFFSET_SIZE
            )
            this._invmatVector3 = utils.allocateTyped(
              Float32Array,
              instanceCount * OFFSET_SIZE
            )
            this.setAttribute(
              'invmatVector1',
              new THREE__namespace.InstancedBufferAttribute(
                this._invmatVector1,
                OFFSET_SIZE,
                false,
                1
              )
            )
            this.setAttribute(
              'invmatVector2',
              new THREE__namespace.InstancedBufferAttribute(
                this._invmatVector2,
                OFFSET_SIZE,
                false,
                1
              )
            )
            this.setAttribute(
              'invmatVector3',
              new THREE__namespace.InstancedBufferAttribute(
                this._invmatVector3,
                OFFSET_SIZE,
                false,
                1
              )
            )
          }
        }
      }
    ])

    return Instanced2CCylindersGeometry
  })(THREE__namespace.InstancedBufferGeometry)

  function _createSuper$1J(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1J()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1J() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var VEC_SIZE$1 = 3
  var TRI_SIZE = 3
  var tmpPrev = new THREE__namespace.Vector3()
  var tmpNext = new THREE__namespace.Vector3()
  var tmpRes = new THREE__namespace.Vector3()
  var simpleNormal = new THREE__namespace.Vector3(1.0, 0.0, 0.0)
  var normalOnCut = new THREE__namespace.Vector3()
  var nearRingPt = new THREE__namespace.Vector3()

  function _createExtrudedChunkGeometry(shape, ringsCount) {
    var geo = new THREE__namespace.BufferGeometry()
    var ptsCount = shape.length
    var totalPts = ptsCount * ringsCount
    var type = totalPts <= 65536 ? Uint16Array : Uint32Array
    var facesPerChunk = (ringsCount - 1) * ptsCount * 2
    var indices = new THREE__namespace.BufferAttribute(
      utils.allocateTyped(type, facesPerChunk * TRI_SIZE),
      1
    )
    var currVtxIdx = 0
    var currFaceIdx = 0

    for (var y = 0; y < ringsCount; y++) {
      if (y !== ringsCount - 1) {
        for (var i = 0; i < ptsCount; i++) {
          var v1 = currVtxIdx + i
          var v2 = currVtxIdx + ptsCount + i
          var v3 = currVtxIdx + ptsCount + ((i + 1) % ptsCount)
          var v4 = currVtxIdx + ((i + 1) % ptsCount)
          indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2)
          currFaceIdx++
          indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3)
          currFaceIdx++
        }
      }

      currVtxIdx += ptsCount
    }

    geo.setIndex(indices)
    var pos = utils.allocateTyped(Float32Array, totalPts * VEC_SIZE$1)
    geo.setAttribute(
      'position',
      new THREE__namespace.BufferAttribute(pos, VEC_SIZE$1)
    )
    geo._positions = shape
    return geo
  }

  var ExtrudedObjectsGeometry = /*#__PURE__*/ (function (
    _ChunkedObjectsGeomet
  ) {
    _inherits(ExtrudedObjectsGeometry, _ChunkedObjectsGeomet)

    var _super = _createSuper$1J(ExtrudedObjectsGeometry)

    function ExtrudedObjectsGeometry(shape, ringsCount, chunksCount) {
      var _this

      _classCallCheck(this, ExtrudedObjectsGeometry)

      var chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount)

      _this = _super.call(this, chunkGeo, chunksCount)
      _this._ringsCount = ringsCount
      var tmpShape = (_this._tmpShape = [])

      for (var i = 0; i < shape.length; ++i) {
        tmpShape[i] = new THREE__namespace.Vector3()
      }

      return _this
    }

    _createClass(ExtrudedObjectsGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, matrices) {
          var hasSlope =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : false
          var hasCut =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : false
          var ptsCount = this._chunkGeo._positions.length
          var ringsCount = this._ringsCount
          var chunkStartIdx = ptsCount * this._ringsCount * itemIdx * VEC_SIZE$1

          this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx)

          if (hasSlope) {
            this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx)
          } else {
            this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx)
          }

          if (hasCut) {
            this._addCut(ptsCount, ringsCount, chunkStartIdx)
          }
        }
      },
      {
        key: '_setPoints',
        value: function _setPoints(
          matrices,
          ptsCount,
          ringsCount,
          chunkStartIdx
        ) {
          var tmpShape = this._tmpShape
          var positions = this._positions
          var shape = this._chunkGeo._positions

          for (var i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i) {
            var mtx = matrices[i]

            for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$1) {
              tmpShape[j]
                .copy(shape[j])
                .applyMatrix4(mtx)
                .toArray(positions, vtxIdx)
            }
          }
        }
      },
      {
        key: '_setBaseNormals',
        value: function _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
          var nPtsInRing = ptsCount * VEC_SIZE$1

          for (
            var i = 0, vtxIdx = chunkStartIdx;
            i < ringsCount;
            ++i, vtxIdx += nPtsInRing
          ) {
            this._countNormalsInRing(ptsCount, vtxIdx, false)
          }
        }
      },
      {
        key: '_setSlopeNormals',
        value: function _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
          var normals = this._normals
          var nPtsInRing = ptsCount * VEC_SIZE$1
          var vtxIdx = chunkStartIdx

          for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$1) {
            simpleNormal.toArray(normals, vtxIdx)
          }

          if (vtxIdx - 2 * nPtsInRing > 0) {
            for (var _j = 0; _j < ptsCount; ++_j, vtxIdx += VEC_SIZE$1) {
              tmpRes
                .fromArray(normals, vtxIdx - 2 * nPtsInRing)
                .toArray(normals, vtxIdx)
            }
          } else {
            this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing)

            vtxIdx += nPtsInRing
          }

          for (var i = 2; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
            this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing)
          }
        }
      },
      {
        key: '_countNormalsInRing',
        value: function _countNormalsInRing(
          ptsCount,
          vtxIdx,
          isSlope,
          shiftToExtraPt
        ) {
          var tmpShape = this._tmpShape
          var normals = this._normals
          tmpShape[0].fromArray(this._positions, vtxIdx)
          tmpShape[ptsCount - 1].fromArray(
            this._positions,
            vtxIdx + (ptsCount - 1) * VEC_SIZE$1
          )

          for (var j = 0; j < ptsCount; ++j, vtxIdx += VEC_SIZE$1) {
            if (j < ptsCount - 1) {
              tmpShape[j + 1].fromArray(this._positions, vtxIdx + VEC_SIZE$1)
            }

            if (isSlope) {
              nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt)
              tmpPrev
                .subVectors(
                  tmpShape[(j + ptsCount - 1) % ptsCount],
                  tmpShape[(j + 1) % ptsCount]
                )
                .normalize()
              tmpNext.subVectors(tmpShape[j], nearRingPt).normalize()
              tmpRes
                .crossVectors(tmpNext, tmpPrev)
                .normalize()
                .toArray(normals, vtxIdx)
            } else {
              tmpPrev
                .subVectors(
                  tmpShape[j],
                  tmpShape[(j + ptsCount - 1) % ptsCount]
                )
                .normalize()
              tmpNext
                .subVectors(tmpShape[j], tmpShape[(j + 1) % ptsCount])
                .normalize()
              tmpRes
                .addVectors(tmpPrev, tmpNext)
                .normalize()
                .toArray(normals, vtxIdx)
            }
          }
        }
      },
      {
        key: '_addCut',
        value: function _addCut(ptsCount, ringsCount, chunkStartIdx) {
          if (ptsCount < 3 || ringsCount < 2) {
            return
          }

          var positions = this._positions
          var normals = this._normals
          var tmpShape = this._tmpShape
          var nPtsInRing = ptsCount * VEC_SIZE$1
          tmpShape[0].fromArray(positions, chunkStartIdx)
          tmpShape[1].fromArray(positions, chunkStartIdx + VEC_SIZE$1)
          tmpShape[2].fromArray(positions, chunkStartIdx + 2 * VEC_SIZE$1)
          tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize()
          tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize()
          normalOnCut.crossVectors(tmpPrev, tmpNext).normalize()
          var vtxIdx = chunkStartIdx

          for (var j = 0; j < ptsCount * 2; ++j, vtxIdx += VEC_SIZE$1) {
            normalOnCut.toArray(normals, vtxIdx)
          }

          if (ringsCount > 2) {
            for (var _j2 = 0; _j2 < ptsCount; ++_j2, vtxIdx += VEC_SIZE$1) {
              tmpRes
                .fromArray(positions, vtxIdx - nPtsInRing)
                .toArray(positions, vtxIdx)
            }
          }
        }
      }
    ])

    return ExtrudedObjectsGeometry
  })(ChunkedObjectsGeometry)

  function _createSuper$1I(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1I()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1I() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var MAX_IDC_16BIT = 65535
  var VERTEX_PER_SEGMENT = 4
  var POS_SIZE = 4
  var DIR_SIZE = 3
  var COL_SIZE = 3
  var tmpColor$1 = new THREE__namespace.Color()
  var direction = new THREE__namespace.Vector3()

  function setArrayXYZ(arr, idx, x, y, z) {
    arr[idx] = x
    arr[idx + 1] = y
    arr[idx + 2] = z
  }

  function setArrayXYZW(arr, idx, x, y, z, w) {
    arr[idx] = x
    arr[idx + 1] = y
    arr[idx + 2] = z
    arr[idx + 3] = w
  }

  function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
    var start = startSegmentIdx * VERTEX_PER_SEGMENT
    var end = start + segmentsCount * VERTEX_PER_SEGMENT
    return arr.subarray(start * elemSize, end * elemSize)
  }

  var ThickLinesGeometry = /*#__PURE__*/ (function (_THREE$BufferGeometry) {
    _inherits(ThickLinesGeometry, _THREE$BufferGeometry)

    var _super = _createSuper$1I(ThickLinesGeometry)

    function ThickLinesGeometry(segmentsCount) {
      var _this

      _classCallCheck(this, ThickLinesGeometry)

      _this = _super.call(this)

      _this._initVertices(segmentsCount)

      return _this
    }

    _createClass(ThickLinesGeometry, [
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'finishUpdate',
        value: function finishUpdate() {
          this.getAttribute('position').needsUpdate = true
          this.getAttribute('color').needsUpdate = true
          this.getAttribute('alphaColor').needsUpdate = true
          this.getAttribute('direction').needsUpdate = true
        }
      },
      {
        key: 'setColor',
        value: function setColor(segmentIdx, colorVal) {
          tmpColor$1.set(colorVal)
          var idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE
          setArrayXYZ(
            this._colors,
            idx,
            tmpColor$1.r,
            tmpColor$1.g,
            tmpColor$1.b
          )
          idx += COL_SIZE
          setArrayXYZ(
            this._colors,
            idx,
            tmpColor$1.r,
            tmpColor$1.g,
            tmpColor$1.b
          )
          idx += COL_SIZE
          setArrayXYZ(
            this._colors,
            idx,
            tmpColor$1.r,
            tmpColor$1.g,
            tmpColor$1.b
          )
          idx += COL_SIZE
          setArrayXYZ(
            this._colors,
            idx,
            tmpColor$1.r,
            tmpColor$1.g,
            tmpColor$1.b
          )
        }
      },
      {
        key: 'setSegment',
        value: function setSegment(segmentIdx, pos1, pos2) {
          direction.subVectors(pos1, pos2)
          direction.normalize()
          var positions = this._positions
          var directions = this._directions
          var idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE
          var dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE
          setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, 0.5)
          setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z)
          idx += POS_SIZE
          dirIdx += DIR_SIZE
          setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, -0.5)
          setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z)
          idx += POS_SIZE
          dirIdx += DIR_SIZE
          setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, 0.5)
          setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z)
          idx += POS_SIZE
          dirIdx += DIR_SIZE
          setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, -0.5)
          setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z)
        }
      },
      {
        key: 'setOpacity',
        value: function setOpacity(startSegIdx, endSegIdx, value) {
          var start = startSegIdx * VERTEX_PER_SEGMENT
          var end = endSegIdx * VERTEX_PER_SEGMENT

          ___default['default'].fill(this.alpha, value, end, start)

          this.getAttribute('alphaColor').needsUpdate = true
        }
      },
      {
        key: 'getSubsetSegments',
        value: function getSubsetSegments(startSegmentIdx, segmentsCount) {
          return [
            getSubset(
              this._positions,
              startSegmentIdx,
              segmentsCount,
              POS_SIZE
            ),
            getSubset(
              this._directions,
              startSegmentIdx,
              segmentsCount,
              DIR_SIZE
            )
          ]
        }
      },
      {
        key: 'getSubsetColors',
        value: function getSubsetColors(startSegmentIdx, segmentsCount) {
          return getSubset(
            this._colors,
            startSegmentIdx,
            segmentsCount,
            COL_SIZE
          )
        }
      },
      {
        key: 'getSubsetOpacities',
        value: function getSubsetOpacities(startSegmentIdx, segmentsCount) {
          return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1)
        }
      },
      {
        key: 'getNumVertexPerSegment',
        value: function getNumVertexPerSegment() {
          return VERTEX_PER_SEGMENT
        }
      },
      {
        key: 'getPositionSize',
        value: function getPositionSize() {
          return POS_SIZE
        }
      },
      {
        key: 'setSegments',
        value: function setSegments(startSegmentIdx, positions) {
          var startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE

          if (positions instanceof Array && positions.length === 2) {
            this._positions.set(positions[0], startPos)

            var startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE

            this._directions.set(positions[1], startDir)
          } else {
            this._positions.set(positions, startPos)
          }
        }
      },
      {
        key: 'setColors',
        value: function setColors(startSegmentIdx, colors) {
          var start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE

          this._colors.set(colors, start)
        }
      },
      {
        key: '_initVertices',
        value: function _initVertices(segmentsCount) {
          this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT
          var pointsCount = this._buffersSize
          var use32bitIndex = pointsCount > MAX_IDC_16BIT
          this._index = utils.allocateTyped(
            use32bitIndex ? Uint32Array : Uint16Array,
            segmentsCount * 6
          )
          this._positions = utils.allocateTyped(
            Float32Array,
            pointsCount * POS_SIZE
          )
          this._colors = utils.allocateTyped(
            Float32Array,
            pointsCount * COL_SIZE
          )
          this._directions = utils.allocateTyped(
            Float32Array,
            pointsCount * DIR_SIZE
          )
          var alpha = (this._alpha = utils.allocateTyped(
            Float32Array,
            pointsCount
          ))

          ___default['default'].fill(alpha, 1.0)

          var index = this._index
          var indexOffset = 0
          var pointOffset = 0

          for (
            var j = 0;
            j < segmentsCount;
            j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT
          ) {
            index[indexOffset] = pointOffset
            index[indexOffset + 1] = pointOffset + 1
            index[indexOffset + 2] = pointOffset + 3
            index[indexOffset + 3] = pointOffset
            index[indexOffset + 4] = pointOffset + 2
            index[indexOffset + 5] = pointOffset + 3
          }

          this.setIndex(new THREE__namespace.BufferAttribute(this._index, 1))
          this.setAttribute(
            'position',
            new THREE__namespace.BufferAttribute(this._positions, POS_SIZE)
          )
          this.setAttribute(
            'color',
            new THREE__namespace.BufferAttribute(this._colors, COL_SIZE)
          )
          this.setAttribute(
            'alphaColor',
            new THREE__namespace.BufferAttribute(alpha, 1)
          )
          this.setAttribute(
            'direction',
            new THREE__namespace.BufferAttribute(this._directions, DIR_SIZE)
          )
        }
      }
    ])

    return ThickLinesGeometry
  })(THREE__namespace.BufferGeometry)

  function _createSuper$1H(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1H()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1H() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var LinesGeometry = /*#__PURE__*/ (function (_BaseLinesGeometry) {
    _inherits(LinesGeometry, _BaseLinesGeometry)

    var _super = _createSuper$1H(LinesGeometry)

    function LinesGeometry() {
      _classCallCheck(this, LinesGeometry)

      return _super.apply(this, arguments)
    }

    _createClass(LinesGeometry, [
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'computeBoundingSphere',
        value: function computeBoundingSphere() {
          var boundingBox = this.boundingBox
          var radiusSquared = 0.0
          var center = new THREE__namespace.Vector3()

          if (boundingBox) {
            boundingBox.getCenter(center)
          }

          var positions = this._positions
          var sphere = this.boundingSphere || new THREE__namespace.Sphere()
          var size = this._positions.length
          var pos = new THREE__namespace.Vector3()
          var posSize = this.getPositionSize()

          for (var i = 0; i < size; i += posSize) {
            pos.set(positions[i], positions[i + 1], positions[i + 2])
            var lengthSquared = center.distanceToSquared(pos)

            if (radiusSquared < lengthSquared) {
              radiusSquared = lengthSquared
            }
          }

          sphere.set(center, Math.sqrt(radiusSquared))
          this.boundingSphere = sphere
        }
      },
      {
        key: 'computeBoundingBox',
        value: function computeBoundingBox() {
          var positions = this._positions
          var box = new THREE__namespace.Box3()
          var size = this._positions.length
          var tmpVec = new THREE__namespace.Vector3()
          var posSize = this.getPositionSize()

          for (var i = 0; i < size; i += posSize) {
            tmpVec.set(positions[i], positions[i + 1], positions[i + 2])
            box.expandByPoint(tmpVec)
          }

          this.boundingBox = box
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
          this.computeBoundingSphere()
        }
      }
    ])

    return LinesGeometry
  })(ThickLinesGeometry)

  function _createSuper$1G(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1G()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1G() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var VEC_SIZE = 3
  var tmpVector$1 = new THREE__namespace.Vector3()
  var normMtx = new THREE__namespace.Matrix3()

  var CylinderCollisionGeo = /*#__PURE__*/ (function (_ChunkedObjectsGeomet) {
    _inherits(CylinderCollisionGeo, _ChunkedObjectsGeomet)

    var _super = _createSuper$1G(CylinderCollisionGeo)

    function CylinderCollisionGeo(instanceCount, polyComplexity) {
      var _this

      _classCallCheck(this, CylinderCollisionGeo)

      var cylGeometry = new THREE__namespace.CylinderBufferGeometry(
        1,
        1,
        1.0,
        Math.max(3, polyComplexity),
        2,
        true
      )
      _this = _super.call(this, cylGeometry, instanceCount)
      var chunkSize = _this._chunkSize
      _this._chunkPos = _this._chunkGeo.attributes.position.array
      _this._chunkNorms = _this._chunkGeo.attributes.normal.array
      _this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * VEC_SIZE)
      return _this
    }

    _createClass(CylinderCollisionGeo, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, botPos, topPos, itemRad) {
          var chunkSize = this._chunkSize
          var itemOffset = chunkSize * itemIdx * VEC_SIZE
          var tmpArray = this._tmpVector
          var geoPos = this._chunkPos
          var geoNorm = this._chunkNorms
          var mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad)
          normMtx.getNormalMatrix(mtx1)
          var idx

          for (var i = 0; i < chunkSize; ++i) {
            idx = i * VEC_SIZE
            tmpVector$1.fromArray(geoPos, idx)
            tmpVector$1.applyMatrix4(mtx1)
            tmpVector$1.toArray(tmpArray, idx)
          }

          this._positions.set(tmpArray, itemOffset)

          for (var _i = 0; _i < chunkSize; ++_i) {
            idx = _i * VEC_SIZE
            tmpVector$1.fromArray(geoNorm, idx)
            tmpVector$1.applyMatrix3(normMtx)
            tmpVector$1.toArray(tmpArray, idx)
          }

          this._normals.set(tmpArray, itemOffset)
        }
      }
    ])

    return CylinderCollisionGeo
  })(ChunkedObjectsGeometry)

  function _createSuper$1F(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1F()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1F() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var COLLISION_RAD$1 = 0.1

  var ChunkedLinesGeometry = /*#__PURE__*/ (function (_LinesGeometry) {
    _inherits(ChunkedLinesGeometry, _LinesGeometry)

    var _super = _createSuper$1F(ChunkedLinesGeometry)

    function ChunkedLinesGeometry(chunksCount, segmentsCount, enableCollision) {
      var _this

      _classCallCheck(this, ChunkedLinesGeometry)

      _this = _super.call(this, chunksCount * segmentsCount)

      _this._init(segmentsCount)

      _this._collisionGeo = enableCollision
        ? new CylinderCollisionGeo(chunksCount * segmentsCount, 3)
        : null
      return _this
    }

    _createClass(ChunkedLinesGeometry, [
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'computeBoundingSphere',
        value: function computeBoundingSphere() {
          var collisionGeo = this._collisionGeo

          if (collisionGeo) {
            collisionGeo.computeBoundingSphere()
            this.boundingSphere = collisionGeo.boundingSphere
            return
          }

          _get(
            _getPrototypeOf(ChunkedLinesGeometry.prototype),
            'computeBoundingSphere',
            this
          ).call(this)
        }
      },
      {
        key: 'computeBoundingBox',
        value: function computeBoundingBox() {
          var collisionGeo = this._collisionGeo

          if (collisionGeo) {
            collisionGeo.computeBoundingBox()
            this.boundingBox = collisionGeo.boundingBox
            return
          }

          _get(
            _getPrototypeOf(ChunkedLinesGeometry.prototype),
            'computeBoundingBox',
            this
          ).call(this)
        }
      },
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var collisionGeo = this._collisionGeo

          if (!collisionGeo) {
            return
          }

          var segCount = this._chunkSize

          this._collisionGeo.raycast(raycaster, intersects)

          for (var i = 0, n = intersects.length; i < n; ++i) {
            var chunkIdx = intersects[i].chunkIdx

            if (chunkIdx === undefined) {
              continue
            }

            chunkIdx = (chunkIdx / segCount) | 0
            intersects[i].chunkIdx = chunkIdx
          }
        }
      },
      {
        key: 'setColor',
        value: function setColor(chunkIdx, colorVal) {
          var chunkSize = this._chunkSize

          for (
            var i = chunkIdx * chunkSize, end = i + chunkSize;
            i < end;
            ++i
          ) {
            _get(
              _getPrototypeOf(ChunkedLinesGeometry.prototype),
              'setColor',
              this
            ).call(this, i, colorVal)
          }
        }
      },
      {
        key: 'setSegment',
        value: function setSegment(chunkIdx, segIdx, pos1, pos2) {
          var chunkSize = this._chunkSize
          var idx = chunkIdx * chunkSize + segIdx

          _get(
            _getPrototypeOf(ChunkedLinesGeometry.prototype),
            'setSegment',
            this
          ).call(this, idx, pos1, pos2)

          if (this._collisionGeo) {
            this._collisionGeo.setItem(
              chunkIdx * chunkSize + segIdx,
              pos1,
              pos2,
              COLLISION_RAD$1
            )
          }
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
          this.computeBoundingSphere()
        }
      },
      {
        key: 'setOpacity',
        value: function setOpacity(chunkIndices, value) {
          var chunkSize = this._chunkSize

          for (var i = 0, n = chunkIndices.length; i < n; ++i) {
            var left = chunkIndices[i] * chunkSize

            _get(
              _getPrototypeOf(ChunkedLinesGeometry.prototype),
              'setOpacity',
              this
            ).call(this, left, left + chunkSize - 1, value)
          }
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(chunkIndices) {
          var instanceCount = chunkIndices.length
          var chunkSize = this._chunkSize
          var subset = new ChunkedLinesGeometry(instanceCount, chunkSize, false)

          for (var i = 0, n = chunkIndices.length; i < n; ++i) {
            var dstPtOffset = i * chunkSize
            var startSegIdx = chunkIndices[i] * chunkSize
            subset.setSegments(
              dstPtOffset,
              this.getSubsetSegments(startSegIdx, chunkSize)
            )
            subset.setColors(
              dstPtOffset,
              this.getSubsetColors(startSegIdx, chunkSize)
            )
          }

          subset.boundingSphere = this.boundingSphere
          subset.boundingBox = this.boundingBox
          return [subset]
        }
      },
      {
        key: '_init',
        value: function _init(chunkSize) {
          this._chunkSize = chunkSize
        }
      }
    ])

    return ChunkedLinesGeometry
  })(LinesGeometry)

  function _createSuper$1E(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1E()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1E() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var COLLISION_RAD = 0.3
  var tmpVector = new THREE__namespace.Vector3()

  var TwoColorLinesGeometry = /*#__PURE__*/ (function (_LinesGeometry) {
    _inherits(TwoColorLinesGeometry, _LinesGeometry)

    var _super = _createSuper$1E(TwoColorLinesGeometry)

    function TwoColorLinesGeometry(segmentsCount) {
      var _this

      _classCallCheck(this, TwoColorLinesGeometry)

      _this = _super.call(this, segmentsCount * 2)

      _this._init(segmentsCount)

      _this._collisionGeo = new Simple2CCylindersGeometry(segmentsCount, 3)
      return _this
    }

    _createClass(TwoColorLinesGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, botPos, topPos) {
          this._collisionGeo.setItem(itemIdx, botPos, topPos, COLLISION_RAD)

          var offset = 2 * itemIdx
          tmpVector.lerpVectors(botPos, topPos, 0.5)

          _get(
            _getPrototypeOf(TwoColorLinesGeometry.prototype),
            'setSegment',
            this
          ).call(this, offset, botPos, tmpVector)

          _get(
            _getPrototypeOf(TwoColorLinesGeometry.prototype),
            'setSegment',
            this
          ).call(this, offset + 1, tmpVector, topPos)
        }
      },
      {
        key: 'setColor',
        value: function setColor(itemIdx, colorVal1, colorVal2) {
          var offset = 2 * itemIdx

          _get(
            _getPrototypeOf(TwoColorLinesGeometry.prototype),
            'setColor',
            this
          ).call(this, offset, colorVal1)

          _get(
            _getPrototypeOf(TwoColorLinesGeometry.prototype),
            'setColor',
            this
          ).call(this, offset + 1, colorVal2)
        }
      },
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          if (this._collisionGeo) {
            this._collisionGeo.raycast(raycaster, intersects)
          }
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(segmentIndices) {
          var instanceCount = segmentIndices.length
          var subset = new TwoColorLinesGeometry(instanceCount, false)

          for (var i = 0, n = instanceCount; i < n; ++i) {
            var startSegIdx = segmentIndices[i]
            subset.setSegments(i, this.getSubsetSegments(startSegIdx, 1))
            subset.setColors(i, this.getSubsetColors(startSegIdx, 1))
          }

          subset.boundingSphere = this.boundingSphere
          subset.boundingBox = this.boundingBox
          return [subset]
        }
      },
      {
        key: '_init',
        value: function _init(segmentsCount) {
          this._segCounts = segmentsCount * 2
        }
      }
    ])

    return TwoColorLinesGeometry
  })(LinesGeometry)

  function _createSuper$1D(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1D()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1D() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var vectors = [
    new THREE__namespace.Vector3(1, 0, 0),
    new THREE__namespace.Vector3(-1, 0, 0),
    new THREE__namespace.Vector3(0, 1, 0),
    new THREE__namespace.Vector3(0, -1, 0),
    new THREE__namespace.Vector3(0, 0, 1),
    new THREE__namespace.Vector3(0, 0, -1)
  ]
  var vecCount = vectors.length
  var tempPos1 = new THREE__namespace.Vector3()
  var tempPos2 = new THREE__namespace.Vector3()

  var CrossGeometry = /*#__PURE__*/ (function (_SphereCollisionGeo) {
    _inherits(CrossGeometry, _SphereCollisionGeo)

    var _super = _createSuper$1D(CrossGeometry)

    function CrossGeometry(chunksCount) {
      _classCallCheck(this, CrossGeometry)

      return _super.call(
        this,
        chunksCount,
        chunksCount,
        (vecCount / 2) | 0,
        false
      )
    }

    _createClass(CrossGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, itemPos, itemRad) {
          this.setSphere(itemIdx, itemPos, itemRad)

          for (var i = 0; i < vecCount / 2; ++i) {
            var first = i * 2
            tempPos1.x = itemPos.x + vectors[first].x * itemRad
            tempPos1.y = itemPos.y + vectors[first].y * itemRad
            tempPos1.z = itemPos.z + vectors[first].z * itemRad
            var second = first + 1
            tempPos2.x = itemPos.x + vectors[second].x * itemRad
            tempPos2.y = itemPos.y + vectors[second].y * itemRad
            tempPos2.z = itemPos.z + vectors[second].z * itemRad
            this.setSegment(itemIdx, i, tempPos1, tempPos2)
          }
        }
      }
    ])

    return CrossGeometry
  })(SphereCollisionGeo(ChunkedLinesGeometry))

  function _createSuper$1C(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1C()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1C() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var POS_RAD_SIZE = 4
  var COLOR_SIZE$1 = 3
  var tmpColor = new THREE__namespace.Color()

  var IsoSurfaceGeometry = /*#__PURE__*/ (function (_THREE$BufferGeometry) {
    _inherits(IsoSurfaceGeometry, _THREE$BufferGeometry)

    var _super = _createSuper$1C(IsoSurfaceGeometry)

    function IsoSurfaceGeometry(spheresCount, opts) {
      var _this

      _classCallCheck(this, IsoSurfaceGeometry)

      _this = _super.call(this)
      _this._opts = opts
      _this.zClip = _this._opts.zClip
      _this._posRad = utils.allocateTyped(
        Float32Array,
        spheresCount * POS_RAD_SIZE
      )
      _this._colors = utils.allocateTyped(
        Float32Array,
        spheresCount * COLOR_SIZE$1
      )
      return _this
    }

    _createClass(IsoSurfaceGeometry, [
      {
        key: 'setItem',
        value: function setItem(chunkIdx, pos, radius) {
          var posRad = this._posRad
          var idx = POS_RAD_SIZE * chunkIdx
          posRad[idx++] = pos.x
          posRad[idx++] = pos.y
          posRad[idx++] = pos.z
          posRad[idx] = radius
        }
      },
      {
        key: 'setColor',
        value: function setColor(chunkIdx, colorVal) {
          tmpColor.set(colorVal)
          var colors = this._colors
          var idx = COLOR_SIZE$1 * chunkIdx
          colors[idx++] = tmpColor.r
          colors[idx++] = tmpColor.g
          colors[idx] = tmpColor.b
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
          this.computeBoundingSphere()
        }
      },
      {
        key: 'finishUpdate',
        value: function finishUpdate() {
          this._build()
        }
      },
      {
        key: 'setOpacity',
        value: function setOpacity() {}
      },
      {
        key: 'raycast',
        value: function raycast() {}
      },
      {
        key: 'getSubset',
        value: function getSubset() {
          return []
        }
      }
    ])

    return IsoSurfaceGeometry
  })(THREE__namespace.BufferGeometry)

  var IsoSurfaceMarchCube = /*#__PURE__*/ (function () {
    function IsoSurfaceMarchCube() {
      _classCallCheck(this, IsoSurfaceMarchCube)

      this.pointsValuesLinear = null
      this.hasIntersection = null
      this.bitsInside = null
    }

    _createClass(IsoSurfaceMarchCube, [
      {
        key: 'create',
        value: function create(numCellsPerSide) {
          var vx7000000 = 0x7000000
          var n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide

          if (n3 > vx7000000) {
            throw new Error(
              'Too large cube dimension: lead to memory huge uasge'
            )
          }

          this.pointsValuesLinear = utils.allocateTyped(
            Float32Array,
            (2 << (2 + 2)) * n3
          )
          this.hasIntersection = utils.allocateTyped(Int32Array, n3)
          this.bitsInside = utils.allocateTyped(Int32Array, n3)
          return 0
        }
      },
      {
        key: 'destroy',
        value: function destroy() {
          this.bitsInside = null
          this.hasIntersection = null
          this.pointsValuesLinear = null
        }
      }
    ])

    return IsoSurfaceMarchCube
  })()

  IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0,
    2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8,
    -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9,
    11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1,
    -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8,
    10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8,
    4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10,
    -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1,
    -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11,
    2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1,
    -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1,
    -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11,
    10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7,
    11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1,
    -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2,
    10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4,
    9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1,
    -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5,
    4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4,
    9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1,
    -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3,
    11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10,
    1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1,
    -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7,
    8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7,
    3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1,
    -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7,
    8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3,
    0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1,
    -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8,
    9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7,
    11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11,
    2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10,
    1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11,
    10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5,
    7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6,
    1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1,
    -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1,
    -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1,
    -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1,
    -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5,
    3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11,
    6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6,
    5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1,
    -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10,
    6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8,
    -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1,
    -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3,
    2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1,
    -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7,
    8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11,
    4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1,
    11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6,
    11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,
    10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9,
    10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1,
    -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
    1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2,
    4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9,
    10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10,
    4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1,
    -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9,
    1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4,
    1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11,
    6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10,
    -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1,
    -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10,
    7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6,
    7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0,
    7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1,
    -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7,
    8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1,
    -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1,
    11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11,
    0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11,
    7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6,
    -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9,
    0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10,
    8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7,
    6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8,
    8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1,
    -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7,
    10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1,
    -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8,
    4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3,
    6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,
    1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11,
    0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4,
    6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4,
    6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4,
    3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,
    8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6,
    0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10,
    9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9,
    5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11,
    7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1,
    -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5,
    4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8,
    3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1,
    -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2,
    5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1,
    -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6,
    8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7,
    -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10,
    4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4,
    8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1,
    -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11,
    0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1,
    -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0,
    11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0,
    5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1,
    -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0,
    6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2,
    8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1,
    6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0,
    -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7,
    5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0,
    -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1,
    -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2,
    11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7,
    2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,
    7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7,
    5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1,
    -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2,
    1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0,
    3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1,
    -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0,
    1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5,
    11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1,
    -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5,
    9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5,
    10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3,
    8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1,
    -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5,
    -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7,
    9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11,
    -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11,
    7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11,
    2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1,
    -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9,
    2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2,
    0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8,
    7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1,
    -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,
    4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1,
    -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1,
    10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9,
    9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9,
    -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8,
    10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1,
    -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8,
    9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1
  ]

  var edgeTable = [
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f,
    0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f,
    0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230,
    0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936,
    0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5,
    0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569,
    0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a,
    0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453,
    0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53,
    0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc,
    0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca,
    0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9,
    0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55,
    0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6,
    0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f,
    0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af,
    0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30,
    0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636,
    0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895,
    0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09,
    0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a,
    0x203, 0x109, 0x0
  ]

  function _voxelGradientFast(v, point, grad) {
    var g = v.getValue(point.x, point.y, point.z)
    grad.set(g[0], g[1], g[2])
  }

  var GridCell = /*#__PURE__*/ _createClass(function GridCell() {
    _classCallCheck(this, GridCell)

    this._arrSize = 8
    this.p = new Array(this._arrSize)
    this.g = new Array(this._arrSize)
    this.val = new Array(this._arrSize)

    for (var i = 0; i < this._arrSize; ++i) {
      this.p[i] = new THREE__namespace.Vector3()
      this.g[i] = new THREE__namespace.Vector3()
    }

    this.cubeIndex = 0
  })

  var Triangle = /*#__PURE__*/ _createClass(function Triangle() {
    _classCallCheck(this, Triangle)

    this.a = {
      p: new THREE__namespace.Vector3(),
      n: new THREE__namespace.Vector3()
    }
    this.b = {
      p: new THREE__namespace.Vector3(),
      n: new THREE__namespace.Vector3()
    }
    this.c = {
      p: new THREE__namespace.Vector3(),
      n: new THREE__namespace.Vector3()
    }
  })

  function createArray(arrSize) {
    var arr = new Array(arrSize)

    for (var i = 0; i < arrSize; ++i) {
      arr[i] = new THREE__namespace.Vector3()
    }

    return arr
  }

  var IsoSurface = /*#__PURE__*/ (function () {
    function IsoSurface() {
      _classCallCheck(this, IsoSurface)

      this._numTriangles = 0
      this._numVertices = 0
      this._position = []
      this._normals = []
      this._colors = null
      this._indices = []
      this._volumetricData = null
      this._xAxis = new THREE__namespace.Vector3()
      this._yAxis = new THREE__namespace.Vector3()
      this._zAxis = new THREE__namespace.Vector3()
      this._xDir = new THREE__namespace.Vector3()
      this._yDir = new THREE__namespace.Vector3()
      this._zDir = new THREE__namespace.Vector3()
    }

    _createClass(IsoSurface, [
      {
        key: '_prepareAxesAndDirs',
        value: function _prepareAxesAndDirs() {
          var volData = this._volumetricData
          var cellSize = volData.getCellSize()
          var xAxis = this._xAxis
          var yAxis = this._yAxis
          var zAxis = this._zAxis
          var xDir = this._xDir
          var yDir = this._yDir
          var zDir = this._zDir
          xAxis.set(cellSize.x, 0, 0)
          yAxis.set(0, cellSize.y, 0)
          zAxis.set(0, 0, cellSize.z)
          xDir.set(1, 0, 0)
          yDir.set(0, 1, 0)
          zDir.set(0, 0, 1)
          var tmp = new THREE__namespace.Vector3()
          tmp.crossVectors(xDir, yDir)

          if (tmp.dot(zDir) < 0) {
            xDir.negate()
            yDir.negate()
            zDir.negate()
          }

          if (
            xDir.x < 0 ||
            xDir.y < 0 ||
            xDir.z < 0 ||
            yDir.x < 0 ||
            yDir.y < 0 ||
            yDir.z < 0 ||
            zDir.x < 0 ||
            zDir.y < 0 ||
            zDir.z < 0
          ) {
            return false
          }

          var notZero = function notZero(axe) {
            return Math.abs(axe) > Number.EPSILON
          }

          return !(
            notZero(xAxis.y) ||
            notZero(xAxis.z) ||
            notZero(yAxis.x) ||
            notZero(yAxis.z) ||
            notZero(zAxis.x) ||
            notZero(zAxis.y)
          )
        }
      },
      {
        key: '_vertexInterp',
        value: function _vertexInterp(
          isoLevel,
          grid,
          ind1,
          ind2,
          vertex,
          normal
        ) {
          var p1 = grid.p[ind1]
          var p2 = grid.p[ind2]
          var n1 = grid.g[ind1]
          var n2 = grid.g[ind2]
          var valP1 = grid.val[ind1]
          var valP2 = grid.val[ind2]
          var isoDiffP1 = isoLevel - valP1
          var diffValP2P1 = valP2 - valP1
          var mu = 0.0

          if (Math.abs(diffValP2P1) > 0.0) {
            mu = isoDiffP1 / diffValP2P1
          }

          mu = mu > 1.0 ? 1.0 : mu
          vertex.lerpVectors(p1, p2, mu)
          normal.lerpVectors(n1, n2, mu)
        }
      },
      {
        key: '_polygonize',
        value: function _polygonize(grid, isoLevel, triangles) {
          var cubeIndex = grid.cubeIndex
          var i = 0
          var arrSize = IsoSurface._arrSize
          var firstIndices = IsoSurface._firstIndices
          var secondIndices = IsoSurface._secondIndices
          var vertexList = IsoSurface._vertexList
          var normalList = IsoSurface._normalList

          for (; i < arrSize; ++i) {
            if (edgeTable[cubeIndex] & (1 << i)) {
              this._vertexInterp(
                isoLevel,
                grid,
                firstIndices[i],
                secondIndices[i],
                vertexList[i],
                normalList[i]
              )
            }
          }

          var triCount = 0
          var triTblIdx = cubeIndex * 16
          var triTable = IsoSurface._triTable

          for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
            triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]])
            triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]])
            triangles[triCount].b.p.copy(
              vertexList[triTable[triTblIdx + i + 1]]
            )
            triangles[triCount].b.n.copy(
              normalList[triTable[triTblIdx + i + 1]]
            )
            triangles[triCount].c.p.copy(
              vertexList[triTable[triTblIdx + i + 2]]
            )
            triangles[triCount].c.n.copy(
              normalList[triTable[triTblIdx + i + 2]]
            )
            ++triCount
          }

          return triCount
        }
      },
      {
        key: '_doGridPosNorms',
        value: function _doGridPosNorms(isoValue, step, appendSimple) {
          var vol = this._volumetricData

          var volData = this._volumetricData.getData()

          var dim = vol.getDimensions()
          var xSize = dim[0]
          var ySize = dim[1]
          var zSize = dim[2]
          var stepX = step * vol.getStrideX()
          var stepY = step * vol.getStrideY()
          var stepZ = step * vol.getStrideZ()
          var gc = new GridCell()
          var gcVal = gc.val
          var gcValSize = gc.val.length
          var additions = [
            new THREE__namespace.Vector3(0, 0, 0),
            new THREE__namespace.Vector3(step, 0, 0),
            new THREE__namespace.Vector3(step, step, 0),
            new THREE__namespace.Vector3(0, step, 0),
            new THREE__namespace.Vector3(0, 0, step),
            new THREE__namespace.Vector3(step, 0, step),
            new THREE__namespace.Vector3(step, step, step),
            new THREE__namespace.Vector3(0, step, step)
          ]
          var tmpTriCount = 5
          var triangles = new Array(tmpTriCount)

          for (var j = 0; j < tmpTriCount; ++j) {
            triangles[j] = new Triangle()
          }

          var appendVertex
          var self = this
          var positions = this._position
          var normals = this._normals

          if (appendSimple) {
            appendVertex = (function () {
              var axis = new THREE__namespace.Vector3(
                self._xAxis.x,
                self._yAxis.y,
                self._zAxis.z
              )
              return function (triVertex) {
                var vertex = triVertex.p.clone()
                vertex.multiply(axis)
                positions.push(vertex.add(self._origin))
                normals.push(triVertex.n.clone())
              }
            })()
          } else {
            appendVertex = (function () {
              var posMtx = new THREE__namespace.Matrix3()
              posMtx.set(
                self._xAxis.x,
                self._yAxis.x,
                self._zAxis.x,
                self._xAxis.y,
                self._yAxis.y,
                self._zAxis.y,
                self._xAxis.z,
                self._yAxis.z,
                self._zAxis.z
              )
              var normMtx = new THREE__namespace.Matrix3()
              normMtx.set(
                self._xDir.x,
                self._yDir.x,
                self._zDir.x,
                self._xDir.y,
                self._yDir.y,
                self._zDir.y,
                self._xDir.z,
                self._yDir.z,
                self._zDir.z
              )
              return function (triVertex) {
                positions.push(
                  triVertex.p.clone().applyMatrix3(posMtx).add(self._origin)
                )
                normals.push(triVertex.n.clone().applyMatrix3(normMtx))
              }
            })()
          }

          var indices = this._indices
          var globTriCount = 0

          for (var z = 0; z < zSize - step; z += step) {
            for (var y = 0; y < ySize - step; y += step) {
              var idx = vol.getDirectIdx(0, y, z)

              for (var x = 0; x < xSize - step; x += step, idx += stepX) {
                gcVal[0] = volData[idx]
                gcVal[1] = volData[idx + stepX]
                gcVal[3] = volData[idx + stepY]
                gcVal[2] = volData[idx + stepX + stepY]
                gcVal[4] = volData[idx + stepZ]
                gcVal[5] = volData[idx + stepX + stepZ]
                gcVal[7] = volData[idx + stepY + stepZ]
                gcVal[6] = volData[idx + stepX + stepY + stepZ]
                var cubeIndex = 0
                var i = 0

                for (; i < gcValSize; ++i) {
                  if (gcVal[i] < isoValue) {
                    cubeIndex |= 1 << i
                  }
                }

                if (edgeTable[cubeIndex] === 0) {
                  continue
                }

                gc.cubeIndex = cubeIndex

                for (i = 0; i < gcValSize; ++i) {
                  gc.p[i].set(
                    x + additions[i].x,
                    y + additions[i].y,
                    z + additions[i].z
                  )

                  _voxelGradientFast(this._gradient, gc.p[i], gc.g[i])
                }

                var triCount = this._polygonize(gc, isoValue, triangles)

                globTriCount += triCount

                for (i = 0; i < triCount; ++i) {
                  indices.push(this._numTriangles * 3)
                  indices.push(this._numTriangles * 3 + 1)
                  indices.push(this._numTriangles * 3 + 2)
                  ++this._numTriangles
                  appendVertex(triangles[i].a)
                  appendVertex(triangles[i].b)
                  appendVertex(triangles[i].c)
                }
              }
            }
          }

          return globTriCount
        }
      },
      {
        key: 'compute',
        value: function compute(volData, origin, isoValue, step) {
          this._volumetricData = volData
          this._origin = origin
          this._gradient = volData.computeGradient()

          this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs())
        }
      },
      {
        key: '_remapIndices',
        value: function _remapIndices(vertexMap, idcCount) {
          var indices = this._indices
          var newIndices = utils.allocateTyped(Uint32Array, idcCount)

          for (var i = 0; i < idcCount; ++i) {
            indices[i] = vertexMap[indices[i]]
            newIndices[i] = indices[i]
          }

          this._indices = newIndices
        }
      },
      {
        key: '_remapVertices',
        value: function _remapVertices(vertices, normals, count) {
          var newPositions = utils.allocateTyped(Float32Array, count * 3)
          var newNormals = utils.allocateTyped(Float32Array, count * 3)

          for (var i = 0; i < count; ++i) {
            var pos = vertices[i]
            newPositions[i * 3] = pos.x
            newPositions[i * 3 + 1] = pos.y
            newPositions[i * 3 + 2] = pos.z
            var norm = normals[i].normalize()
            newNormals[i * 3] = norm.x
            newNormals[i * 3 + 1] = norm.y
            newNormals[i * 3 + 2] = norm.z
          }

          this._position = newPositions
          this._normals = newNormals
        }
      },
      {
        key: 'vertexFusion',
        value: function vertexFusion(offset, len) {
          var faceVer = this._indices.length
          var vertices = this._position
          var normals = this._normals
          var oldVerCount = vertices.length | 0

          if (faceVer === 0 || oldVerCount === 0) {
            return
          }

          var vMap = utils.allocateTyped(Uint32Array, oldVerCount)
          vMap[0] = 0
          var newVer = 1
          var i = 1

          for (; i < oldVerCount; ++i) {
            var start = newVer - offset < 0 ? 0 : newVer - offset
            var end = start + len > newVer ? newVer : start + len
            var matchedIndex = -1

            for (var j = start; j < end; ++j) {
              if (Math.abs(vertices[i] - vertices[j]) < Number.EPSILON) {
                matchedIndex = j
                break
              }
            }

            if (matchedIndex !== -1) {
              vMap[i] = matchedIndex
            } else {
              vertices[newVer].copy(vertices[i])
              normals[newVer].copy(normals[i])
              vMap[i] = newVer
              ++newVer
            }
          }

          this._remapIndices(vMap, faceVer)

          this._remapVertices(vertices, normals, newVer)
        }
      },
      {
        key: 'setColorVolTex',
        value: function setColorVolTex(
          colorMap,
          atomMap,
          atomWeightMap,
          visibilitySelector
        ) {
          var i
          var idx
          var numVerts = this._position.length / 3
          var vertices = this._position
          var origin = this._origin

          var dim = this._volumetricData.getDimensions()

          var xs = dim[0] - 1
          var ys = dim[1] - 1
          var zs = dim[2] - 1
          var colorData = colorMap.getData()
          var strideX = colorMap.getStrideX()
          var strideY = colorMap.getStrideY()
          var strideZ = colorMap.getStrideZ()
          var atomWeightData
          var atomStrideX
          var atomStrideY
          var atomStrideZ

          if (visibilitySelector !== null) {
            atomWeightData = atomWeightMap.getData()
            atomStrideX = atomWeightMap.getStrideX()
            atomStrideY = atomWeightMap.getStrideY()
            atomStrideZ = atomWeightMap.getStrideZ()
          }

          var xInv = 1.0 / this._xAxis.x
          var yInv = 1.0 / this._yAxis.y
          var zInv = 1.0 / this._zAxis.z
          var atomLookup = []
          var atomWeights = []
          var colors = utils.allocateTyped(Float32Array, numVerts * 3)

          function interp(mu, idx1, idx2, c) {
            c[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2]
            c[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1]
            c[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2]
          }

          function collectWeight(ai, coefX, coefY, coefZ) {
            var a = atomMap[ai]

            if (a != null) {
              atomLookup[a.index] = a
              var w = coefX * coefY * coefZ * atomWeightData[ai]

              if (typeof atomWeights[a.index] === 'undefined') {
                atomWeights[a.index] = w
              } else {
                atomWeights[a.index] += w
              }
            }
          }

          var vMap = utils.allocateTyped(Int32Array, numVerts)
          var newVerCount = 0

          for (i = 0; i < numVerts; i++) {
            var ind = i * 3
            var vx = (vertices[ind] - origin.x) * xInv
            var vy = (vertices[ind + 1] - origin.y) * yInv
            var vz = (vertices[ind + 2] - origin.z) * zInv
            var x = Math.min(Math.max(vx, 0), xs) | 0
            var y = Math.min(Math.max(vy, 0), ys) | 0
            var z = Math.min(Math.max(vz, 0), zs) | 0
            var mux = vx - x
            var muy = vy - y
            var muz = vz - z

            if (visibilitySelector != null) {
              atomLookup = []
              atomWeights = []
              idx = atomWeightMap.getDirectIdx(x, y, z)
              collectWeight(idx, 1 - mux, 1 - muy, 1 - muz)
              collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz)
              collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz)
              collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz)
              collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz)
              collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz)
              collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz)
              collectWeight(
                idx + atomStrideX + atomStrideY + atomStrideZ,
                mux,
                muy,
                muz
              )
              var maxWeight = 0.0
              var dominantIdx = -1

              for (var atomIdx in atomWeights) {
                if (atomWeights[atomIdx] > maxWeight) {
                  dominantIdx = atomIdx
                  maxWeight = atomWeights[atomIdx]
                }
              }

              if (
                dominantIdx < 0 ||
                !visibilitySelector.includesAtom(atomLookup[dominantIdx])
              ) {
                vMap[i] = -1
                continue
              }
            }

            vMap[i] = newVerCount++
            var dx = x < xs ? strideX : 0
            var dy = y < ys ? strideY : 0
            var dz = z < zs ? strideZ : 0
            var c0 = [0, 0, 0]
            var c1 = [0, 0, 0]
            var c2 = [0, 0, 0]
            var c3 = [0, 0, 0]
            idx = colorMap.getDirectIdx(x, y, z)
            interp(mux, idx, idx + dx, c0)
            interp(mux, idx + dy, idx + dx + dy, c1)
            interp(mux, idx + dz, idx + dx + dz, c2)
            interp(mux, idx + dy + dz, idx + dx + dy + dz, c3)
            var cz0 = [0, 0, 0]
            cz0[0] = (1 - muy) * c0[0] + muy * c1[0]
            cz0[1] = (1 - muy) * c0[1] + muy * c1[1]
            cz0[2] = (1 - muy) * c0[2] + muy * c1[2]
            var cz1 = [0, 0, 0]
            cz1[0] = (1 - muy) * c2[0] + muy * c3[0]
            cz1[1] = (1 - muy) * c2[1] + muy * c3[1]
            cz1[2] = (1 - muy) * c2[2] + muy * c3[2]
            colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0]
            colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1]
            colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2]
          }

          this._colors = colors

          if (visibilitySelector != null) {
            for (i = 0; i < numVerts; ++i) {
              var j = vMap[i]

              if (j < 0) {
                continue
              }

              this._position[j * 3] = this._position[i * 3]
              this._position[j * 3 + 1] = this._position[i * 3 + 1]
              this._position[j * 3 + 2] = this._position[i * 3 + 2]
              this._normals[j * 3] = this._normals[i * 3]
              this._normals[j * 3 + 1] = this._normals[i * 3 + 1]
              this._normals[j * 3 + 2] = this._normals[i * 3 + 2]
              this._colors[j * 3] = this._colors[i * 3]
              this._colors[j * 3 + 1] = this._colors[i * 3 + 1]
              this._colors[j * 3 + 2] = this._colors[i * 3 + 2]
            }

            var numTriangles = this._indices.length / 3
            var newTriCount = 0

            for (i = 0; i < numTriangles; ++i) {
              var i0 = vMap[this._indices[3 * i]]
              var i1 = vMap[this._indices[3 * i + 1]]
              var i2 = vMap[this._indices[3 * i + 2]]

              if (i0 >= 0 && i1 >= 0 && i2 >= 0) {
                this._indices[3 * newTriCount] = i0
                this._indices[3 * newTriCount + 1] = i1
                this._indices[3 * newTriCount + 2] = i2
                ++newTriCount
              }
            }

            this._position = new Float32Array(
              this._position.buffer.slice(0, newVerCount * 3 * 4)
            )
            this._normals = new Float32Array(
              this._normals.buffer.slice(0, newVerCount * 3 * 4)
            )
            this._colors = new Float32Array(
              this._colors.buffer.slice(0, newVerCount * 3 * 4)
            )
            this._indices = new Uint32Array(
              this._indices.buffer.slice(0, newTriCount * 3 * 4)
            )
          }
        }
      },
      {
        key: 'toMesh',
        value: function toMesh() {
          var geo = new THREE__namespace.BufferGeometry()
          geo.setIndex(new THREE__namespace.BufferAttribute(this._indices, 1))
          geo.setAttribute(
            'position',
            new THREE__namespace.BufferAttribute(this._position, 3)
          )
          geo.setAttribute(
            'normal',
            new THREE__namespace.BufferAttribute(this._normals, 3)
          )
          geo.setAttribute(
            'color',
            new THREE__namespace.BufferAttribute(this._colors, 3)
          )
          geo.computeBoundingSphere()
          return geo
        }
      }
    ])

    return IsoSurface
  })()

  _defineProperty(
    IsoSurface,
    '_triTable',
    IsoSurfaceMarchCube.prototype.striIndicesMarchCube
  )

  _defineProperty(IsoSurface, '_arrSize', 12)

  _defineProperty(
    IsoSurface,
    '_firstIndices',
    [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]
  )

  _defineProperty(
    IsoSurface,
    '_secondIndices',
    [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7]
  )

  _defineProperty(IsoSurface, '_vertexList', createArray(IsoSurface._arrSize))

  _defineProperty(IsoSurface, '_normalList', createArray(IsoSurface._arrSize))

  function _createSuper$1B(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1B()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1B() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var VolumeSurfaceGeometry = /*#__PURE__*/ (function (_IsoSurfaceGeometry) {
    _inherits(VolumeSurfaceGeometry, _IsoSurfaceGeometry)

    var _super = _createSuper$1B(VolumeSurfaceGeometry)

    function VolumeSurfaceGeometry() {
      _classCallCheck(this, VolumeSurfaceGeometry)

      return _super.apply(this, arguments)
    }

    _createClass(VolumeSurfaceGeometry, [
      {
        key: '_build',
        value: function _build() {
          var params = this._opts
          this.numVoxels = [128, 128, 128]
          this.xAxis = new THREE__namespace.Vector3(1.0, 0.0, 0.0)
          this.yAxis = new THREE__namespace.Vector3(0.0, 1.0, 0.0)
          this.zAxis = new THREE__namespace.Vector3(0.0, 0.0, 1.0)
          this.origin = new THREE__namespace.Vector3(0.0, 0.0, 0.0)
          this._visibilitySelector = params.visibilitySelector

          this._calcSurface(params)
        }
      },
      {
        key: '_findMinMax',
        value: function _findMinMax(posRadArray) {
          var itemSize = 4
          var itemsCount = posRadArray.length / itemSize
          var maxPosRad = [
            posRadArray[0],
            posRadArray[1],
            posRadArray[2],
            posRadArray[3]
          ]
          var minPosRad = [
            posRadArray[0],
            posRadArray[1],
            posRadArray[2],
            posRadArray[3]
          ]

          for (var i = 1; i < itemsCount; ++i) {
            var ind = i * itemSize

            for (var itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
              var tmpVal = posRadArray[ind + itemIdx]
              maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx])
              minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx])
            }
          }

          return {
            maxPosRad: maxPosRad,
            minPosRad: minPosRad
          }
        }
      },
      {
        key: '_findNumVoxels',
        value: function _findNumVoxels(posRadArray, params) {
          var numVoxels = this.numVoxels

          var minMaxValues = this._findMinMax(posRadArray)

          var minCoordRad = minMaxValues.minPosRad
          var maxCoordRad = minMaxValues.maxPosRad

          if (minCoordRad[3] > 4.0) {
            params.gridSpacing *= minCoordRad[3]
          }

          var gridPadding = params.radScale * maxCoordRad[3] * 1.7
          var padRad = gridPadding
          padRad =
            0.65 * Math.sqrt((4.0 / 3.0) * Math.PI * padRad * padRad * padRad)
          gridPadding = Math.max(gridPadding, padRad)
          var i = 0

          for (; i < 3; ++i) {
            minCoordRad[i] -= gridPadding
            maxCoordRad[i] += gridPadding
          }

          for (i = 0; i < 3; ++i) {
            numVoxels[i] = Math.ceil(
              (maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing
            )
          }

          this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing
          this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing
          this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing

          var _minCoordRad = _slicedToArray(minCoordRad, 3)

          this.origin.x = _minCoordRad[0]
          this.origin.y = _minCoordRad[1]
          this.origin.z = _minCoordRad[2]
          return {
            bbox: minMaxValues,
            dim: numVoxels
          }
        }
      },
      {
        key: '_makeSurface',
        value: function _makeSurface(surface, params) {
          var isoSurf = new IsoSurface()
          isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1)
          isoSurf.vertexFusion(9, 9)

          if (isoSurf._numTriangles > 0) {
            isoSurf.setColorVolTex(
              surface.volTexMap,
              surface.atomMap,
              surface.atomWeightMap,
              this._visibilitySelector
            )
            this.setIndex(
              new THREE__namespace.BufferAttribute(isoSurf._indices, 1)
            )
            this.setAttribute(
              'position',
              new THREE__namespace.BufferAttribute(isoSurf._position, 3)
            )
            this.setAttribute(
              'normal',
              new THREE__namespace.BufferAttribute(isoSurf._normals, 3)
            )
            this.setAttribute(
              'color',
              new THREE__namespace.BufferAttribute(isoSurf._colors, 3)
            )
          } else {
            this.setAttribute(
              'position',
              new THREE__namespace.BufferAttribute(
                utils.allocateTyped(Float32Array, 0),
                3
              )
            )
          }
        }
      },
      {
        key: '_calcSurface',
        value: function _calcSurface(params) {
          var packedArrays = {
            posRad: this._posRad,
            colors: this._colors,
            atoms: this._opts.atoms
          }

          if (packedArrays.posRad.length === 0) {
            return
          }

          var boundaries = this._findNumVoxels(packedArrays.posRad, params)

          var box = new THREE__namespace.Box3(
            this.origin,
            new THREE__namespace.Vector3(
              this.xAxis.x,
              this.yAxis.y,
              this.zAxis.z
            ).add(this.origin)
          )

          var surface = this._computeSurface(
            packedArrays,
            box,
            boundaries,
            params
          )

          this._makeSurface(surface, params)
        }
      }
    ])

    return VolumeSurfaceGeometry
  })(IsoSurfaceGeometry)

  function _createSuper$1A(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1A()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1A() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Volume$1 = chem.Volume

  var QuickSurfGeometry = /*#__PURE__*/ (function (_VolumeSurfaceGeometr) {
    _inherits(QuickSurfGeometry, _VolumeSurfaceGeometr)

    var _super = _createSuper$1A(QuickSurfGeometry)

    function QuickSurfGeometry() {
      _classCallCheck(this, QuickSurfGeometry)

      return _super.apply(this, arguments)
    }

    _createClass(QuickSurfGeometry, [
      {
        key: '_computeSurface',
        value: function _computeSurface(packedArrays, box, boundaries, params) {
          this._shiftByOrigin(packedArrays.posRad)

          var surface = {
            volMap: new Volume$1(Float32Array, this.numVoxels, box),
            volTexMap: new Volume$1(Float32Array, this.numVoxels, box, 3)
          }

          if (this._visibilitySelector != null) {
            surface.atomMap = []
            surface.atomWeightMap = new Volume$1(
              Float32Array,
              this.numVoxels,
              box
            )
          }

          this.gaussdensity(surface, packedArrays, null, params)
          return surface
        }
      },
      {
        key: 'gaussdensity',
        value: function gaussdensity(surface, packedArrays, atomicNum, params) {
          var numAtoms = packedArrays.posRad.length / 4
          var posRad = packedArrays.posRad,
            colors = packedArrays.colors
          var numVoxels = this.numVoxels
          var radScale = params.radScale,
            gaussLim = params.gaussLim,
            gridSpacing = params.gridSpacing
          var invIsoValue = 1.0 / params.isoValue
          var invGridSpacing = 1.0 / gridSpacing
          var maxVoxelX = numVoxels[0] - 1
          var maxVoxelY = numVoxels[1] - 1
          var maxVoxelZ = numVoxels[2] - 1
          var volMap = surface.volMap,
            volTexMap = surface.volTexMap
          var volData = volMap.getData()
          var strideX = volMap.getStrideX()
          var volTexData = volTexMap.getData()
          var texStrideX = volTexMap.getStrideX()
          var atomWeightData

          if (this._visibilitySelector != null) {
            atomWeightData = surface.atomWeightMap.getData()
          }

          var atomMap = surface.atomMap

          for (var i = 0; i < numAtoms; ++i) {
            var ind = i * 4
            var scaledRad = posRad[ind + 3] * radScale
            var atomicNumFactor = atomicNum === null ? 1.0 : atomicNum[i]
            var radInv = 1 / (2 * scaledRad * scaledRad)
            var radLim = gaussLim * scaledRad
            var radLim2 = radLim * radLim
            radLim *= invGridSpacing
            var tmp = posRad[ind] * invGridSpacing
            var xMin = Math.max((tmp - radLim) | 0, 0)
            var xMax = Math.min((tmp + radLim) | 0, maxVoxelX)
            tmp = posRad[ind + 1] * invGridSpacing
            var yMin = Math.max((tmp - radLim) | 0, 0)
            var yMax = Math.min((tmp + radLim) | 0, maxVoxelY)
            tmp = posRad[ind + 2] * invGridSpacing
            var zMin = Math.max((tmp - radLim) | 0, 0)
            var zMax = Math.min((tmp + radLim) | 0, maxVoxelZ)
            var dz = zMin * gridSpacing - posRad[ind + 2]

            for (var z = zMin; z <= zMax; ++z, dz += gridSpacing) {
              var dy = yMin * gridSpacing - posRad[ind + 1]

              for (var y = yMin; y <= yMax; ++y, dy += gridSpacing) {
                var dy2dz2 = dy * dy + dz * dz

                if (dy2dz2 >= radLim2) {
                  continue
                }

                var addr = volMap.getDirectIdx(xMin, y, z)
                var texAddr = volTexMap.getDirectIdx(xMin, y, z)
                var dx = xMin * gridSpacing - posRad[ind]

                for (
                  var x = xMin;
                  x <= xMax;
                  ++x, dx += gridSpacing, addr += strideX, texAddr += texStrideX
                ) {
                  var r2 = dx * dx + dy2dz2
                  var expVal = -r2 * radInv
                  var density = Math.exp(expVal) * atomicNumFactor

                  if (
                    this._visibilitySelector != null &&
                    density > atomWeightData[addr]
                  ) {
                    atomWeightData[addr] = density
                    atomMap[addr] = packedArrays.atoms[i]
                  }

                  volData[addr] += density
                  density *= invIsoValue
                  var colInd = i * 3
                  volTexData[texAddr] += density * colors[colInd]
                  volTexData[texAddr + 1] += density * colors[colInd + 1]
                  volTexData[texAddr + 2] += density * colors[colInd + 2]
                }
              }
            }
          }
        }
      },
      {
        key: '_shiftByOrigin',
        value: function _shiftByOrigin(posRadArray) {
          var originX = this.origin.x
          var originY = this.origin.y
          var originZ = this.origin.z
          var itemSize = 4
          var itemsCount = posRadArray.length / itemSize

          for (var i = 0; i < itemsCount; ++i) {
            var ind = i * itemSize
            posRadArray[ind] -= originX
            posRadArray[ind + 1] -= originY
            posRadArray[ind + 2] -= originZ
          }
        }
      }
    ])

    return QuickSurfGeometry
  })(VolumeSurfaceGeometry)

  function AVHash(posRad, min, max, maxDistance) {
    var itemSize = 4
    var nAtoms = posRad.length / itemSize
    var minX = min[0]
    var minY = min[1]
    var minZ = min[2]
    var maxX = max[0]
    var maxY = max[1]
    var maxZ = max[2]

    function hashFunc(w, minW) {
      return Math.floor((w - minW) / maxDistance)
    }

    var iDim = hashFunc(maxX, minX) + 1
    var jDim = hashFunc(maxY, minY) + 1
    var kDim = hashFunc(maxZ, minZ) + 1
    var nCells = iDim * jDim * kDim
    var jkDim = jDim * kDim

    var cellID = function cellID(x, y, z) {
      return (
        (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim +
        hashFunc(z, minZ)
      )
    }

    var preHash = []
    var i
    var cid

    for (i = 0; i < nAtoms; i++) {
      var iIdx = itemSize * i
      cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2])

      if (preHash[cid] === undefined) {
        preHash[cid] = [i]
      } else {
        preHash[cid].push(i)
      }
    }

    var cellOffsets = utils.allocateTyped(Uint32Array, nCells)
    var cellLengths = utils.allocateTyped(Uint16Array, nCells)
    var data = utils.allocateTyped(Uint32Array, nAtoms)
    var offset = 0
    var maxCellLength = 0
    var j

    for (i = 0; i < nCells; i++) {
      var start = (cellOffsets[i] = offset)
      var subArray = preHash[i]

      if (subArray !== undefined) {
        for (j = 0; j < subArray.length; j++) {
          data[offset] = subArray[j]
          offset++
        }
      }

      var cellLength = offset - start
      cellLengths[i] = cellLength

      if (cellLength > maxCellLength) {
        maxCellLength = cellLength
      }
    }

    this.neighbourListLength = 27 * maxCellLength + 1

    this.withinRadii = function (x, y, z, rExtra, out) {
      var outIdx = 0
      var nearI = hashFunc(x, minX)
      var nearJ = hashFunc(y, minY)
      var nearK = hashFunc(z, minZ)
      var loI = Math.max(0, nearI - 1)
      var loJ = Math.max(0, nearJ - 1)
      var loK = Math.max(0, nearK - 1)
      var hiI = Math.min(iDim - 1, nearI + 1)
      var hiJ = Math.min(jDim - 1, nearJ + 1)
      var hiK = Math.min(kDim - 1, nearK + 1)

      for (i = loI; i <= hiI; ++i) {
        var iOffset = i * jkDim

        for (j = loJ; j <= hiJ; ++j) {
          var jOffset = j * kDim

          for (var k = loK; k <= hiK; ++k) {
            cid = iOffset + jOffset + k
            var cellStart = cellOffsets[cid]
            var cellEnd = cellStart + cellLengths[cid]

            for (var dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
              var atomIndex = data[dataIndex]
              var baseIndex = itemSize * atomIndex
              var dx = posRad[baseIndex] - x
              var dy = posRad[baseIndex + 1] - y
              var dz = posRad[baseIndex + 2] - z
              var rSum = posRad[baseIndex + 3] + rExtra

              if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
                out[outIdx++] = data[dataIndex]
              }
            }
          }
        }
      }

      out[outIdx] = -1
    }
  }

  function ContactSurface(packedArrays, boundaries, params, _indexList) {
    var itemSize = 4
    var posRad = packedArrays.posRad,
      colors = packedArrays.colors,
      atoms = packedArrays.atoms
    var nAtoms = posRad.length / itemSize
    var bbox = boundaries.bbox
    var min = bbox.minPosRad
    var max = bbox.maxPosRad
    var r2
    var maxRadius
    var probeRadius
    var scaleFactor
    var probePositions
    var lastClip = -1
    var dim
    var grid
    var volTex
    var weights
    var weightsMap = null
    var atomMap = null
    var visibilitySelector = null
    var gridx
    var gridy
    var gridz
    var sinTable
    var cosTable
    var hash
    var neighbours
    var mid = new THREE__namespace.Vector3(0.0, 0.0, 0.0)
    var n1 = new THREE__namespace.Vector3(0.0, 0.0, 0.0)
    var n2 = new THREE__namespace.Vector3(0.0, 0.0, 0.0)
    var ngTorus

    function uniformArray(TypeName, n, a) {
      var array = utils.allocateTyped(TypeName, n)

      for (var innI = 0; innI < n; ++innI) {
        array[innI] = a
      }

      return array
    }

    function fillGridDim(a, start, step) {
      for (var innI = 0; innI < a.length; innI++) {
        a[innI] = start + step * innI
      }
    }

    function initializeGrid() {
      scaleFactor = params.scaleFactor
      dim = boundaries.dim
      ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor))
      var gridSize = dim[0] * dim[1] * dim[2]
      grid = uniformArray(Float32Array, gridSize, -1001.0)
      volTex = utils.allocateTyped(Float32Array, gridSize * 3)
      weights = utils.allocateTyped(Float32Array, gridSize)

      if (visibilitySelector) {
        weightsMap = utils.allocateTyped(Float32Array, gridSize)
        atomMap = []
      }

      gridx = utils.allocateTyped(Float32Array, dim[0])
      gridy = utils.allocateTyped(Float32Array, dim[1])
      gridz = utils.allocateTyped(Float32Array, dim[2])
      fillGridDim(gridx, min[0], 1 / scaleFactor)
      fillGridDim(gridy, min[1], 1 / scaleFactor)
      fillGridDim(gridz, min[2], 1 / scaleFactor)
    }

    function initializeAngleTables() {
      var theta = 0.0
      var step = (2 * Math.PI) / probePositions
      cosTable = utils.allocateTyped(Float32Array, probePositions)
      sinTable = utils.allocateTyped(Float32Array, probePositions)

      for (var innI = 0; innI < probePositions; innI++) {
        cosTable[innI] = Math.cos(theta)
        sinTable[innI] = Math.sin(theta)
        theta += step
      }
    }

    function initializeHash() {
      hash = new AVHash(posRad, min, max, 2.01 * maxRadius)
      neighbours = new Int32Array(hash.neighbourListLength)
    }

    function init() {
      probeRadius = params.probeRadius
      scaleFactor = params.scaleFactor
      probePositions = params.probePositions
      visibilitySelector = params.visibilitySelector
      r2 = utils.allocateTyped(Float32Array, nAtoms)
      maxRadius = 0

      for (var innI = 0; innI < nAtoms; ++innI) {
        var rExt = (posRad[innI * itemSize + 3] += probeRadius)

        if (rExt > maxRadius) {
          maxRadius = rExt
        }

        r2[innI] = rExt * rExt
      }

      initializeGrid()
      initializeAngleTables()
      initializeHash()
      lastClip = -1
    }

    function singleAtomObscures(ai, innX, innY, innZ) {
      var innCI = itemSize * ai
      var ra2 = r2[ai]
      var dx = posRad[innCI] - innX
      var dy = posRad[innCI + 1] - innY
      var dz = posRad[innCI + 2] - innZ
      var d2 = dx * dx + dy * dy + dz * dz
      return d2 < ra2
    }

    function obscured(innX, innY, innZ, a, b) {
      var ai

      if (lastClip !== -1) {
        ai = lastClip

        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          return ai
        }

        lastClip = -1
      }

      var ni = 0
      ai = neighbours[ni]

      while (ai >= 0) {
        if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
          lastClip = ai
          return ai
        }

        ai = neighbours[++ni]
      }

      lastClip = -1
      return -1
    }

    function projectPoints() {
      var maxRad = 4.0
      var sigma = maxRad / 3
      var sigma2Inv = 1 / (2 * sigma * sigma)

      for (var innI = 0; innI < nAtoms; innI++) {
        var innCI = itemSize * innI
        var ax = posRad[innCI]
        var ay = posRad[innCI + 1]
        var az = posRad[innCI + 2]
        var ar = posRad[innCI + 3]
        var ar2 = r2[innI]
        hash.withinRadii(ax, ay, az, ar, neighbours)
        var ng = Math.ceil(ar * scaleFactor)
        var iax = Math.floor(scaleFactor * (ax - min[0]))
        var iay = Math.floor(scaleFactor * (ay - min[1]))
        var iaz = Math.floor(scaleFactor * (az - min[2]))
        var minx = Math.max(0, iax - ng)
        var miny = Math.max(0, iay - ng)
        var minz = Math.max(0, iaz - ng)
        var maxx = Math.min(dim[0], iax + ng + 2)
        var maxy = Math.min(dim[1], iay + ng + 2)
        var maxz = Math.min(dim[2], iaz + ng + 2)
        var colIdx = innI * 3
        var cr = colors[colIdx]
        var cg = colors[colIdx + 1]
        var cb = colors[colIdx + 2]

        for (var iz = minz; iz < maxz; iz++) {
          var dz = gridz[iz] - az
          var zOffset = dim[1] * dim[0] * iz

          for (var iy = miny; iy < maxy; iy++) {
            var dy = gridy[iy] - ay
            var dzy2 = dz * dz + dy * dy
            var zyOffset = zOffset + dim[0] * iy

            for (var ix = minx; ix < maxx; ix++) {
              var idx = ix + zyOffset
              var dx = gridx[ix] - ax
              var d2 = dzy2 + dx * dx

              if (d2 < ar2) {
                var w = Math.exp(-d2 * sigma2Inv)
                var cIdx = idx * 3
                volTex[cIdx] += cr * w
                volTex[cIdx + 1] += cg * w
                volTex[cIdx + 2] += cb * w
                weights[idx] += w

                if (visibilitySelector !== null && w > weightsMap[idx]) {
                  weightsMap[idx] = w
                  atomMap[idx] = atoms[innI]
                }

                if (grid[idx] < 0.0) {
                  grid[idx] = -grid[idx]
                }

                var d = Math.sqrt(d2)
                var ap = ar / d
                var spx = dx * ap
                var spy = dy * ap
                var spz = dz * ap
                spx += ax
                spy += ay
                spz += az

                if (obscured(spx, spy, spz, innI, -1) === -1) {
                  var dd = ar - d

                  if (dd < grid[idx]) {
                    grid[idx] = dd
                  }
                }
              }
            }
          }
        }
      }
    }

    function normalToLine(out, p) {
      out.x = out.y = out.z = 1.0

      if (p.x !== 0) {
        out.x = (p.y + p.z) / -p.x
      } else if (p.y !== 0) {
        out.y = (p.x + p.z) / -p.y
      } else if (p.z !== 0) {
        out.z = (p.x + p.y) / -p.z
      }

      return out
    }

    function projectTorus(a, b) {
      var aIdx = itemSize * a
      var bIdx = itemSize * b
      var xa = posRad[aIdx]
      var ya = posRad[aIdx + 1]
      var za = posRad[aIdx + 2]
      var r1 = posRad[aIdx + 3]
      var dx = (mid.x = posRad[bIdx] - xa)
      var dy = (mid.y = posRad[bIdx + 1] - ya)
      var dz = (mid.z = posRad[bIdx + 2] - za)
      var innR2 = posRad[bIdx + 3]
      var d2 = dx * dx + dy * dy + dz * dz
      var d = Math.sqrt(d2)
      var cosA = (r1 * r1 + d * d - innR2 * innR2) / (2.0 * r1 * d)
      var dmp = r1 * cosA
      mid.normalize()
      normalToLine(n1, mid)
      n1.normalize()
      n2.crossVectors(mid, n1)
      n2.normalize()
      var rInt = Math.sqrt(r1 * r1 - dmp * dmp)
      n1.multiplyScalar(rInt)
      n2.multiplyScalar(rInt)
      mid.multiplyScalar(dmp)
      mid.x += xa
      mid.y += ya
      mid.z += za
      lastClip = -1
      var ng = ngTorus

      for (var innI = 0; innI < probePositions; innI++) {
        var cost = cosTable[innI]
        var sint = sinTable[innI]
        var px = mid.x + cost * n1.x + sint * n2.x
        var py = mid.y + cost * n1.y + sint * n2.y
        var pz = mid.z + cost * n1.z + sint * n2.z

        if (obscured(px, py, pz, a, b) === -1) {
          var iax = Math.floor(scaleFactor * (px - min[0]))
          var iay = Math.floor(scaleFactor * (py - min[1]))
          var iaz = Math.floor(scaleFactor * (pz - min[2]))
          var minx = Math.max(0, iax - ng)
          var miny = Math.max(0, iay - ng)
          var minz = Math.max(0, iaz - ng)
          var maxx = Math.min(dim[0], iax + ng + 2)
          var maxy = Math.min(dim[1], iay + ng + 2)
          var maxz = Math.min(dim[2], iaz + ng + 2)

          for (var iz = minz; iz < maxz; iz++) {
            dz = pz - gridz[iz]
            var zOffset = dim[1] * dim[0] * iz

            for (var iy = miny; iy < maxy; iy++) {
              dy = py - gridy[iy]
              var dzy2 = dz * dz + dy * dy
              var zyOffset = zOffset + dim[0] * iy

              for (var ix = minx; ix < maxx; ix++) {
                dx = px - gridx[ix]
                d2 = dzy2 + dx * dx
                var idx = ix + zyOffset
                var current = grid[idx]

                if (current > 0.0 && d2 < current * current) {
                  grid[idx] = Math.sqrt(d2)
                }
              }
            }
          }
        }
      }
    }

    function projectTorii() {
      for (var innI = 0; innI < nAtoms; innI++) {
        var innIdx = itemSize * innI
        hash.withinRadii(
          posRad[innIdx],
          posRad[innIdx + 1],
          posRad[innIdx + 2],
          posRad[innIdx + 3],
          neighbours
        )
        var ia = 0
        var ni = neighbours[ia]

        while (ni >= 0) {
          if (innI < ni) {
            projectTorus(innI, ni)
          }

          ni = neighbours[++ia]
        }
      }
    }

    function fixNegatives() {
      for (var innI = 0, n = grid.length; innI < n; innI++) {
        if (grid[innI] < 0) grid[innI] = 0
        var w = weights[innI]

        if (w > 0) {
          w = 1 / w
          var innInnI = innI * 3
          volTex[innInnI] *= w
          volTex[innInnI + 1] *= w
          volTex[innInnI + 2] *= w
        }
      }
    }

    function getVolume() {
      console.time('ContactSurface.getVolume')
      console.time('ContactSurface.init')
      init()
      console.timeEnd('ContactSurface.init')
      console.time('ContactSurface.projectPoints')
      projectPoints()
      console.timeEnd('ContactSurface.projectPoints')
      console.time('ContactSurface.projectTorii')
      projectTorii()
      console.timeEnd('ContactSurface.projectTorii')
      fixNegatives()
      console.timeEnd('ContactSurface.getVolume')
    }

    this.build = function () {
      getVolume()
      this.volTexMap = volTex
      this.weightsMap = weightsMap
      this.atomMap = atomMap
      this.volMap = grid
    }
  }

  function _createSuper$1z(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1z()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1z() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Volume = chem.Volume

  var ContactSurfaceGeometry = /*#__PURE__*/ (function (_VolumeSurfaceGeometr) {
    _inherits(ContactSurfaceGeometry, _VolumeSurfaceGeometr)

    var _super = _createSuper$1z(ContactSurfaceGeometry)

    function ContactSurfaceGeometry() {
      _classCallCheck(this, ContactSurfaceGeometry)

      return _super.apply(this, arguments)
    }

    _createClass(ContactSurfaceGeometry, [
      {
        key: '_computeSurface',
        value: function _computeSurface(packedArrays, box, boundaries, params) {
          var contactSurface = new ContactSurface(
            packedArrays,
            boundaries,
            params
          )
          contactSurface.build()
          var surface = {
            volMap: new Volume(
              Float32Array,
              this.numVoxels,
              box,
              1,
              contactSurface.volMap
            ),
            volTexMap: new Volume(
              Float32Array,
              this.numVoxels,
              box,
              3,
              contactSurface.volTexMap
            ),
            atomMap: contactSurface.atomMap,
            atomWeightMap: new Volume(
              Float32Array,
              this.numVoxels,
              box,
              1,
              contactSurface.weightsMap
            )
          }
          return surface
        }
      }
    ])

    return ContactSurfaceGeometry
  })(VolumeSurfaceGeometry)

  var IsoSurfaceAtomColored = /*#__PURE__*/ _createClass(
    function IsoSurfaceAtomColored(vCenter, radiusAt) {
      _classCallCheck(this, IsoSurfaceAtomColored)

      this.coord = new THREE__namespace.Vector3()
      this.coord.copy(vCenter)
      this.radius = radiusAt
      this.colorX = 0.99999
      this.colorY = 0.0
      this.colorZ = 0.0
      this.atomType = 0
      this.srcAtom = null
    }
  )

  var IsosurfaceBuildNormals = /*#__PURE__*/ (function () {
    function IsosurfaceBuildNormals(
      numAtoms,
      atoms,
      vBoxMin,
      vBoxMax,
      probeRadius
    ) {
      _classCallCheck(this, IsosurfaceBuildNormals)

      this._numAtoms = numAtoms
      this._atoms = atoms
      this._vBoxMin = new THREE__namespace.Vector3()
      this._vBoxMax = new THREE__namespace.Vector3()

      this._vBoxMin.copy(vBoxMin)

      this._vBoxMax.copy(vBoxMax)

      this._probeRadius = probeRadius
      this._atomsList = null
      this._voxelList = null
    }

    _createClass(IsosurfaceBuildNormals, [
      {
        key: 'createVoxels',
        value: function createVoxels() {
          var numAtomsRefs
          var rad
          var ATOM_VOXEL_REF_SCALE = 4.5
          var numAtoms = this._numAtoms | 0
          var atoms = this._atoms
          var dx = this._vBoxMax.x - this._vBoxMin.x
          var dy = this._vBoxMax.y - this._vBoxMin.y
          var dz = this._vBoxMax.z - this._vBoxMin.z
          var w = dx < dy ? dx : dy
          w = dz < w ? dz : w
          var maxRad = 0.0
          var aveRad = 0.0
          var i

          for (i = 0; i < numAtoms; i++) {
            rad = (atoms[i].radius + this._probeRadius) * 2.0
            maxRad = rad > maxRad ? rad : maxRad
            aveRad += rad
          }

          var numCells = Math.floor(w / maxRad)

          if (numCells < 2) {
            numCells = 2
          }

          aveRad /= numAtoms
          this._numCells = numCells
          this._aveRad = aveRad
          this._maxRad = maxRad
          var side = numCells
          var side2 = numCells * numCells
          var side3 = numCells * numCells * numCells
          var xScale = (this._xScale =
            1.0 / (this._vBoxMax.x - this._vBoxMin.x))
          var yScale = (this._yScale =
            1.0 / (this._vBoxMax.y - this._vBoxMin.y))
          var zScale = (this._zScale =
            1.0 / (this._vBoxMax.z - this._vBoxMin.z))
          var maxAtomsRefs = 0
          var xNumVoxMult = xScale * numCells
          var yNumVoxMult = yScale * numCells
          var zNumVoxMult = zScale * numCells

          for (i = 0; i < numAtoms; i++) {
            var radAffect =
              (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE
            var diaAffect = radAffect * 2.0
            var numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8)
            var numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8)
            var numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8)
            numVoxX++
            numVoxY++
            numVoxZ++
            maxAtomsRefs += numVoxX * numVoxY * numVoxZ
          }

          this._voxelList = utils.allocateTyped(Int32Array, side3)
          var atomsList = []
          atomsList.length = maxAtomsRefs

          if (this._voxelList === null || atomsList === null) {
            return 0 - 1
          }

          for (i = 0; i < side3; i++) {
            this._voxelList[i] = -1
          }

          numAtomsRefs = 0

          for (i = 0; i < numAtoms; i++) {
            rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE
            var xIndMin = Math.floor(
              (atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale
            )
            var yIndMin = Math.floor(
              (atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale
            )
            var zIndMin = Math.floor(
              (atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale
            )
            var xIndMax = Math.floor(
              (atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale
            )
            var yIndMax = Math.floor(
              (atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale
            )
            var zIndMax = Math.floor(
              (atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale
            )
            xIndMin = xIndMin >= 0 ? xIndMin : 0
            yIndMin = yIndMin >= 0 ? yIndMin : 0
            zIndMin = zIndMin >= 0 ? zIndMin : 0
            xIndMax = xIndMax < numCells ? xIndMax : numCells - 1
            yIndMax = yIndMax < numCells ? yIndMax : numCells - 1
            zIndMax = zIndMax < numCells ? zIndMax : numCells - 1

            for (var z = zIndMin; z <= zIndMax; z++) {
              for (var y = yIndMin; y <= yIndMax; y++) {
                for (var x = xIndMin; x <= xIndMax; x++) {
                  var indVoxel = x + y * side + z * side2

                  if (this._voxelList[indVoxel] < 0) {
                    atomsList[numAtomsRefs * 2 + 0] = i
                    atomsList[numAtomsRefs * 2 + 1] = 0 - 1
                    this._voxelList[indVoxel] = numAtomsRefs
                    numAtomsRefs++
                    continue
                  }

                  var indexNext = this._voxelList[indVoxel]
                  this._voxelList[indVoxel] = numAtomsRefs
                  atomsList[numAtomsRefs * 2 + 0] = i
                  atomsList[numAtomsRefs * 2 + 1] = indexNext
                  numAtomsRefs++
                }
              }
            }
          }

          this._atomsList = Int32Array.from(atomsList)
          return 0
        }
      },
      {
        key: 'destroyVoxels',
        value: function destroyVoxels() {
          this._atomsList = null
          this._voxelList = null
          this._atoms = null
          this._vertices = null
          this._vBoxMin = null
          this._vBoxMax = null
        }
      },
      {
        key: 'forEachRelatedAtom',
        value: function forEachRelatedAtom(point, process) {
          var xInd = Math.floor(
            (point.x - this._vBoxMin.x) * this._numCells * this._xScale
          )
          var yInd = Math.floor(
            (point.y - this._vBoxMin.y) * this._numCells * this._yScale
          )
          var zInd = Math.floor(
            (point.z - this._vBoxMin.z) * this._numCells * this._zScale
          )
          var indVoxel =
            xInd +
            yInd * this._numCells +
            zInd * this._numCells * this._numCells
          var atoms = this._atoms

          for (
            var ref = this._voxelList[indVoxel];
            ref >= 0;
            ref = this._atomsList[ref * 2 + 1]
          ) {
            var indexAtom = this._atomsList[ref * 2]
            process(atoms[indexAtom])
          }
        }
      },
      {
        key: 'getClosestAtom',
        value: function getClosestAtom(point) {
          var closest = null
          var minDist2 = Number.MAX_VALUE
          this.forEachRelatedAtom(point, function (atom) {
            var dist2 = point.distanceToSquared(atom.coord)

            if (dist2 < minDist2) {
              minDist2 = dist2
              closest = atom
            }
          })
          return closest
        }
      },
      {
        key: 'buildNormals',
        value: function buildNormals(numVertices, vertices, normals) {
          var self = this
          var numCloseAtoms = 0
          var vx = 0
          var vy = 0
          var vz = 0
          var dist2
          var vNormalX = 0
          var vNormalY = 0
          var vNormalZ = 0
          var koef = 0
          var w = 0
          var r25 = 2.5
          var r01 = 0.1
          var maxRadAffect = this._aveRad * r25
          var maxRadAffect2 = maxRadAffect * maxRadAffect
          var expScale = -this._aveRad * r01

          var gatherNormals = function gatherNormals(atom) {
            var dx = vx - atom.coord.x
            var dy = vy - atom.coord.y
            var dz = vz - atom.coord.z
            dist2 = dx * dx + dy * dy + dz * dz

            if (dist2 > maxRadAffect2) {
              return
            }

            var rad = atom.radius + self._probeRadius
            koef = dist2 - rad * rad

            if (koef < 0.0) {
              koef = -koef
            }

            w = Math.exp(expScale * koef)
            vNormalX += dx * w
            vNormalY += dy * w
            vNormalZ += dz * w
            numCloseAtoms++
          }

          for (var i = 0; i < numVertices; i++) {
            vx = vertices[i].x
            vy = vertices[i].y
            vz = vertices[i].z
            numCloseAtoms = 0
            vNormalX = vNormalY = vNormalZ = 0.0
            this.forEachRelatedAtom(vertices[i], gatherNormals)
            dist2 =
              vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ

            if (numCloseAtoms > 0) {
              koef = 1.0 / Math.sqrt(dist2)
              vNormalX *= koef
              vNormalY *= koef
              vNormalZ *= koef
            }

            normals[i].x = vNormalX
            normals[i].y = vNormalY
            normals[i].z = vNormalZ
          }

          return 0
        }
      },
      {
        key: 'buildColors',
        value: function buildColors(
          numVertices,
          vertices,
          colors,
          radiusColorSmoothness
        ) {
          var self = this
          var vx = 0.0
          var vy = 0.0
          var vz = 0.0
          var koef = 0.0
          var w = 0.0
          var KOEF_ADD = 0.8
          var maxRadAffect = radiusColorSmoothness
          var maxRadAffect2 = maxRadAffect * maxRadAffect
          var colorsClose = []
          var weights = []
          var weightsSum = 0

          var gatherColors = function gatherColors(atom) {
            var dx = vx - atom.coord.x
            var dy = vy - atom.coord.y
            var dz = vz - atom.coord.z
            var dist2 = dx * dx + dy * dy + dz * dz

            if (dist2 > maxRadAffect2) {
              return
            }

            var rad = atom.radius + self._probeRadius
            koef = dist2 - rad * rad

            if (koef < 0.0) {
              koef = -koef
            }

            w = 1.0 / (KOEF_ADD + koef)
            colorsClose.push([atom.colorX, atom.colorY, atom.colorZ])
            weights.push(w)
            weightsSum += w
          }

          for (var i = 0; i < numVertices; i++) {
            vx = vertices[i].x
            vy = vertices[i].y
            vz = vertices[i].z
            colorsClose = []
            weights = []
            weightsSum = 0
            this.forEachRelatedAtom(vertices[i], gatherColors)

            for (var j = 0; j < colorsClose.length; ++j) {
              var weightNormalized = weights[j] / weightsSum
              colors[i].x += colorsClose[j][0] * weightNormalized
              colors[i].y += colorsClose[j][1] * weightNormalized
              colors[i].z += colorsClose[j][2] * weightNormalized
            }
          }

          return 0
        }
      }
    ])

    return IsosurfaceBuildNormals
  })()

  var IsoSurfaceGeo = /*#__PURE__*/ (function () {
    function IsoSurfaceGeo(maxNumVertices, maxNumTriangles, needVertexColors) {
      _classCallCheck(this, IsoSurfaceGeo)

      this._maxNumVertices = maxNumVertices
      this._maxNumTriangles = maxNumTriangles
      this._vertices = new Array(maxNumVertices)
      this._normals = new Array(maxNumVertices)
      this._colors = null

      if (needVertexColors) {
        this._colors = new Array(maxNumVertices)
      }

      this._indices = new Array(maxNumTriangles * (1 + 2))
      this._numVertices = 0
      this._numTriangles = 0
      var i

      for (i = 0; i < maxNumVertices; i++) {
        this._vertices[i] = new THREE__namespace.Vector3()
        this._normals[i] = new THREE__namespace.Vector3()
      }

      for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
        this._indices[i] = -1
      }

      if (needVertexColors) {
        for (i = 0; i < maxNumVertices; i++) {
          this._colors[i] = new THREE__namespace.Vector3()
        }
      }
    }

    _createClass(IsoSurfaceGeo, [
      {
        key: 'destroy',
        value: function destroy() {
          this._vertices = null
          this._normals = null
          this._indices = null
        }
      }
    ])

    return IsoSurfaceGeo
  })()

  function _createSuper$1y(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1y()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1y() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var COLOR_SIZE = 3
  var HASH_SIZE = 32768
  var Element$9 = chem.Element

  var SSIsosurfaceGeometry = /*#__PURE__*/ (function (_IsoSurfaceGeometry) {
    _inherits(SSIsosurfaceGeometry, _IsoSurfaceGeometry)

    var _super = _createSuper$1y(SSIsosurfaceGeometry)

    function SSIsosurfaceGeometry() {
      _classCallCheck(this, SSIsosurfaceGeometry)

      return _super.apply(this, arguments)
    }

    _createClass(SSIsosurfaceGeometry, [
      {
        key: '_build',
        value: function _build() {
          this._innerBuild()

          var geoOut = this.getGeo()
          this.destroy()

          this._fromGeo(geoOut)
        }
      },
      {
        key: '_fromGeo',
        value: function _fromGeo(geoOut) {
          var colors = null
          var positions = utils.allocateTyped(
            Float32Array,
            (1 + 2) * geoOut._numVertices
          )
          var normals = utils.allocateTyped(
            Float32Array,
            (1 + 2) * geoOut._numVertices
          )

          if (geoOut._colors !== null) {
            colors = utils.allocateTyped(
              Float32Array,
              (1 + 2) * geoOut._numVertices
            )
          }

          var indices = utils.allocateTyped(
            Uint32Array,
            (1 + 2) * geoOut._numTriangles
          )

          for (var i = 0, j = 0; i < geoOut._numVertices; i++) {
            positions[j + 0] = geoOut._vertices[i].x
            positions[j + 1] = geoOut._vertices[i].y
            positions[j + 2] = geoOut._vertices[i].z
            normals[j + 0] = geoOut._normals[i].x
            normals[j + 1] = geoOut._normals[i].y
            normals[j + 2] = geoOut._normals[i].z
            j += 3
          }

          if (colors !== null) {
            for (var _i = 0, _j = 0; _i < geoOut._numVertices; _i++, _j += 3) {
              colors[_j + 0] = geoOut._colors[_i].x
              colors[_j + 1] = geoOut._colors[_i].y
              colors[_j + 2] = geoOut._colors[_i].z
            }
          }

          var numTri3 = geoOut._numTriangles * (1 + 2)

          for (var _i2 = 0; _i2 < numTri3; _i2++) {
            indices[_i2] = geoOut._indices[_i2]
          }

          this.setIndex(new THREE__namespace.BufferAttribute(indices, 1))
          this.setAttribute(
            'position',
            new THREE__namespace.BufferAttribute(positions, 3)
          )
          this.setAttribute(
            'normal',
            new THREE__namespace.BufferAttribute(normals, 3)
          )
          this.setAttribute(
            'color',
            new THREE__namespace.BufferAttribute(colors, 3)
          )
          this.computeBoundingBox()
          this.computeBoundingSphere()
          geoOut.destroy()
        }
      },
      {
        key: 'convertToAtomsColored',
        value: function convertToAtomsColored(packedArrays, atomsColored) {
          var atoms = packedArrays.atoms,
            colors = packedArrays.colors

          for (var i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
            var vCenter = atoms[i].position
            var radius = atoms[i].element.radius
            atomsColored[i] = new IsoSurfaceAtomColored(vCenter, radius)
            var nm = atoms[i].element.number
            atomsColored[i].atomType = this.getType(nm)
            var cIdx = COLOR_SIZE * i
            atomsColored[i].colorX = colors[cIdx++]
            atomsColored[i].colorY = colors[cIdx++]
            atomsColored[i].colorZ = colors[cIdx]
            atomsColored[i].srcAtom = atoms[i]
          }
        }
      },
      {
        key: 'getGeo',
        value: function getGeo() {
          return this.geoOut
        }
      },
      {
        key: 'destroy',
        value: function destroy() {
          this.atoms = null
          this.hashLines = null
          this.hashEntries = null
        }
      },
      {
        key: 'getBoundingBox',
        value: function getBoundingBox(atoms, vBoxMin, vBoxMax) {
          var bigNum = 10000000.0
          vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum
          vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum
          var probeRadius2 = this.probeRadius * this.atomRadiusScale
          var radMax = 0.0

          for (var i = 0, num = atoms.length; i < num; i++) {
            var vCenter = atoms[i].coord
            var rad = atoms[i].radius + probeRadius2
            radMax = rad > radMax ? rad : radMax

            if (vCenter.x - rad < vBoxMin.x) {
              vBoxMin.x = vCenter.x - rad
            }

            if (vCenter.y - rad < vBoxMin.y) {
              vBoxMin.y = vCenter.y - rad
            }

            if (vCenter.z - rad < vBoxMin.z) {
              vBoxMin.z = vCenter.z - rad
            }

            if (vCenter.x + rad > vBoxMax.x) {
              vBoxMax.x = vCenter.x + rad
            }

            if (vCenter.y + rad > vBoxMax.y) {
              vBoxMax.y = vCenter.y + rad
            }

            if (vCenter.z + rad > vBoxMax.z) {
              vBoxMax.z = vCenter.z + rad
            }
          }

          vBoxMin.x -= radMax
          vBoxMin.y -= radMax
          vBoxMin.z -= radMax
          vBoxMax.x += radMax
          vBoxMax.y += radMax
          vBoxMax.z += radMax
        }
      },
      {
        key: 'getCornerCoord',
        value: function getCornerCoord(
          vBoxMin,
          vBoxMax,
          x,
          y,
          z,
          numPoints,
          vOut
        ) {
          var invNP = 1.0 / (numPoints - 1.0)
          var tx = x * invNP
          var ty = y * invNP
          var tz = z * invNP
          vOut.x = vBoxMin.x * (1.0 - tx) + vBoxMax.x * tx
          vOut.y = vBoxMin.y * (1.0 - ty) + vBoxMax.y * ty
          vOut.z = vBoxMin.z * (1.0 - tz) + vBoxMax.z * tz
        }
      },
      {
        key: 'buildEdgePoint',
        value: function buildEdgePoint(
          indexA,
          indexB,
          sign,
          cube,
          indexPointValue,
          vOut
        ) {
          if (sign[indexA] ^ sign[indexB]) {
            var cTwentyFour = 24
            var t =
              (0 -
                cube.pointsValuesLinear[
                  indexPointValue + cTwentyFour + indexA
                ]) /
              (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] -
                cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA])
            var xa =
              cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0]
            var ya =
              cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1]
            var za =
              cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2]
            var xb =
              cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0]
            var yb =
              cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1]
            var zb =
              cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2]
            vOut.x = xa * (1.0 - t) + xb * t
            vOut.y = ya * (1.0 - t) + yb * t
            vOut.z = za * (1.0 - t) + zb * t
          }
        }
      },
      {
        key: 'isTriangleVisible',
        value: function isTriangleVisible(v0, v1, v2) {
          var a0 = this.voxelWorld.getClosestAtom(v0)
          var a1 = this.voxelWorld.getClosestAtom(v1)
          var a2 = this.voxelWorld.getClosestAtom(v2)

          if (
            a0 === null ||
            a1 === null ||
            a2 === null ||
            a0.srcAtom === null ||
            a1.srcAtom === null ||
            a2.srcAtom === null
          ) {
            return false
          }

          return (
            this.visibilitySelector.includesAtom(a0.srcAtom) &&
            this.visibilitySelector.includesAtom(a1.srcAtom) &&
            this.visibilitySelector.includesAtom(a2.srcAtom)
          )
        }
      },
      {
        key: 'addTriangle',
        value: function addTriangle(v0, v1, v2) {
          if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
            return true
          }

          var geo = this.geoOut

          if (geo._numTriangles >= this.maxNumTriangles) {
            return false
          }

          var indInGeo0 = this.addVertexToGeo(geo, v0)
          var indInGeo1 = this.addVertexToGeo(geo, v1)
          var indInGeo2 = this.addVertexToGeo(geo, v2)

          if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
            return false
          }

          var itr = 3 * geo._numTriangles
          geo._indices[itr + 0] = indInGeo0
          geo._indices[itr + 1] = indInGeo1
          geo._indices[itr + 2] = indInGeo2
          geo._numTriangles++
          return true
        }
      },
      {
        key: 'buildGeoFromCorners',
        value: function buildGeoFromCorners(
          meshRes,
          vBoxMin,
          vBoxMax,
          corners,
          vCellStep,
          cube
        ) {
          var arrSize = 12
          var cNumVerts = 8
          var numCells = meshRes - 1
          var side = meshRes
          var side2 = meshRes * meshRes
          var vaEdges = new Array(arrSize)

          for (var i = 0; i < arrSize; i++) {
            vaEdges[i] = new THREE__namespace.Vector3()
          }

          var sign = []

          for (var _i3 = 0; _i3 < cNumVerts; _i3++) {
            sign[_i3] = 1.0
          }

          var vCorner = new THREE__namespace.Vector3()
          var indCell = 0
          var indY = 0

          for (var y = 0; y < numCells; y++, indY += side2) {
            var indZ = 0

            for (var z = 0; z < numCells; z++, indZ += side) {
              for (var x = 0; x < numCells; x++) {
                if (!cube.hasIntersection[indCell]) {
                  indCell++
                  continue
                }

                var bitsInside = cube.bitsInside[indCell]
                this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner)
                var indPointValues = indCell * (2 << (2 + 2))

                for (var _i4 = 0, j = 0; _i4 < cNumVerts; _i4++) {
                  cube.pointsValuesLinear[indPointValues + j++] = vCorner.x
                  cube.pointsValuesLinear[indPointValues + j++] = vCorner.y
                  cube.pointsValuesLinear[indPointValues + j++] = vCorner.z
                }

                cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x
                cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x
                cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x
                cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x
                cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] +=
                  vCellStep.z
                cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] +=
                  vCellStep.z
                cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] +=
                  vCellStep.z
                cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] +=
                  vCellStep.z
                cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] +=
                  vCellStep.y
                cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] +=
                  vCellStep.y
                cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] +=
                  vCellStep.y
                cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] +=
                  vCellStep.y
                var indValues = indPointValues + 24

                for (var _i5 = 0; _i5 < cNumVerts; ++_i5) {
                  sign[_i5] =
                    cube.pointsValuesLinear[indValues + _i5] < 0.0 ? 1 : 0
                }

                this.buildEdgePoint(
                  0,
                  1,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[0]
                )
                this.buildEdgePoint(
                  1,
                  2,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[1]
                )
                this.buildEdgePoint(
                  2,
                  3,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[2]
                )
                this.buildEdgePoint(
                  3,
                  0,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[3]
                )
                this.buildEdgePoint(
                  4,
                  5,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[4]
                )
                this.buildEdgePoint(
                  5,
                  6,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[5]
                )
                this.buildEdgePoint(
                  6,
                  7,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[6]
                )
                this.buildEdgePoint(
                  7,
                  4,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[7]
                )
                this.buildEdgePoint(
                  0,
                  4,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[8]
                )
                this.buildEdgePoint(
                  1,
                  5,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[9]
                )
                this.buildEdgePoint(
                  2,
                  6,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[10]
                )
                this.buildEdgePoint(
                  3,
                  7,
                  sign,
                  cube,
                  indPointValues,
                  vaEdges[11]
                )
                var offs = bitsInside * (2 << (1 + 2))

                for (
                  var numTri = 0, indTri = 0;
                  numTri < 2 + 2 + 2;
                  numTri++, indTri += 3
                ) {
                  var i0 = cube.striIndicesMarchCube[offs + indTri]

                  if (i0 < 0) {
                    break
                  }

                  var i1 = cube.striIndicesMarchCube[offs + indTri + 1]
                  var i2 = cube.striIndicesMarchCube[offs + indTri + 2]

                  if (
                    !this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])
                  ) {
                    return 0 - 2
                  }
                }

                indCell++
              }
            }
          }

          return 0
        }
      },
      {
        key: 'getNumIntersectedCells',
        value: function getNumIntersectedCells(side, numCells, corners, cube) {
          var side2 = side * side
          var cNumVerts = 8
          var numIntersectedCells = 0
          var indCell = 0
          var indY = 0

          for (var y = 0; y < numCells; y++, indY += side2) {
            var indZ = 0

            for (var z = 0; z < numCells; z++, indZ += side) {
              for (var x = 0; x < numCells; x++) {
                var cubeValuesIndex = indCell * (2 << (2 + 2)) + 24
                var indCorner = x + indZ + indY
                cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner]
                cube.pointsValuesLinear[cubeValuesIndex + 1] =
                  corners[indCorner + 1]
                cube.pointsValuesLinear[cubeValuesIndex + 2] =
                  corners[indCorner + side + 1]
                cube.pointsValuesLinear[cubeValuesIndex + 3] =
                  corners[indCorner + side]
                cube.pointsValuesLinear[cubeValuesIndex + 4] =
                  corners[side2 + indCorner]
                cube.pointsValuesLinear[cubeValuesIndex + 5] =
                  corners[side2 + indCorner + 1]
                cube.pointsValuesLinear[cubeValuesIndex + 6] =
                  corners[side2 + indCorner + side + 1]
                cube.pointsValuesLinear[cubeValuesIndex + 7] =
                  corners[side2 + indCorner + side]
                var bitsInside = 0

                for (var i = 0; i < cNumVerts; ++i) {
                  if (cube.pointsValuesLinear[cubeValuesIndex + i] < 0.0) {
                    bitsInside |= 1 << i
                  }
                }

                if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
                  cube.hasIntersection[indCell] = false
                } else {
                  cube.hasIntersection[indCell] = true
                  numIntersectedCells++
                }

                cube.bitsInside[indCell] = bitsInside
                indCell++
              }
            }
          }

          return numIntersectedCells
        }
      },
      {
        key: 'getType',
        value: function getType(letter) {
          var atomT = [
            0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6,
            11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20,
            6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6,
            30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39,
            6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6,
            49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58,
            6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6,
            68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77,
            6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6,
            87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96,
            6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105,
            6, 106, 6, 107, 6, 108, 6, 109, 6
          ]

          if (
            letter < 1 ||
            letter > atomT.length / 2 ||
            Object.keys(Element$9.ByAtomicNumber).length * 2 !== atomT.length
          ) {
            throw new Error(
              'atomT.length  should be equal Element.ByAtomicNumber.length * 2'
            )
          }

          return atomT[letter * 2]
        }
      },
      {
        key: 'calculateGridCorners',
        value: function calculateGridCorners(
          corners,
          side,
          vBoxMin,
          vBoxMax,
          atoms,
          probeRad
        ) {
          var side2 = side * side
          var side3 = side2 * side
          var vCorner = new THREE__namespace.Vector3()
          var vDif = new THREE__namespace.Vector3()
          var aLot = +1.0e12

          for (var i = 0; i < side3; i++) {
            corners[i] = aLot
          }

          var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x)
          var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y)
          var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z)

          for (var s = 0, numAtoms = atoms.length; s < numAtoms; s++) {
            var atom = atoms[s]
            var radius = atom.radius + probeRad
            var fx = (atom.coord.x - radius - vBoxMin.x) * xScale
            var fy = (atom.coord.y - radius - vBoxMin.y) * yScale
            var fz = (atom.coord.z - radius - vBoxMin.z) * zScale
            var indXMin = Math.floor(fx)
            var indYMin = Math.floor(fy)
            var indZMin = Math.floor(fz)
            var indXMax = Math.floor(
              (atom.coord.x + radius - vBoxMin.x) * xScale
            )
            var indYMax = Math.floor(
              (atom.coord.y + radius - vBoxMin.y) * yScale
            )
            var indZMax = Math.floor(
              (atom.coord.z + radius - vBoxMin.z) * zScale
            )
            indXMax++
            indYMax++
            indZMax++
            indXMax = indXMax <= side - 1 ? indXMax : side - 1
            indYMax = indYMax <= side - 1 ? indYMax : side - 1
            indZMax = indZMax <= side - 1 ? indZMax : side - 1

            for (var y = indYMin; y <= indYMax; y++) {
              var indY = y * side2

              for (var z = indZMin; z <= indZMax; z++) {
                var indZ = z * side

                for (var x = indXMin; x <= indXMax; x++) {
                  var ind = indY + indZ + x
                  this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner)
                  vDif.x = vCorner.x - atom.coord.x
                  vDif.y = vCorner.y - atom.coord.y
                  vDif.z = vCorner.z - atom.coord.z
                  var distToSphere = Math.sqrt(
                    vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z
                  )
                  var val = distToSphere - radius

                  if (val < corners[ind]) {
                    corners[ind] = val
                  }
                }
              }
            }
          }
        }
      },
      {
        key: 'createVertexHash',
        value: function createVertexHash(maxNumVertices, maxNumTriangles) {
          this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2)

          if (this.hashLines === null) {
            return 0 - 1
          }

          for (var i = 0, j = 0; i < HASH_SIZE; i++) {
            this.hashLines[j++] = 0
            this.hashLines[j++] = 0 - 1
          }

          this.maxNumVertices = maxNumVertices
          this.maxNumTriangles = maxNumTriangles
          this.numHashEtriesAllocated = maxNumVertices
          this.hashEntries = utils.allocateTyped(
            Int32Array,
            2 * this.numHashEtriesAllocated
          )

          if (this.hashEntries === null) {
            return 0 - 1
          }

          for (var _i6 = 0, _j2 = 0; _i6 < this.numHashEtriesAllocated; _i6++) {
            this.hashEntries[_j2++] = 0 - 1
            this.hashEntries[_j2++] = 0 - 1
          }

          this.numHashEntryIndex = 0
          return 0
        }
      },
      {
        key: 'getNewHashEntry',
        value: function getNewHashEntry() {
          if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
            var i = this.numHashEntryIndex
            this.numHashEntryIndex++
            return i
          }

          return 0 - 1
        }
      },
      {
        key: 'addVertexToGeo',
        value: function addVertexToGeo(geoOut, vAdd) {
          var entry
          var oneHynberes = 0.01
          var n815851 = 815851
          var n37633 = 37633
          var n2453543 = 2453543
          var r106 = 1.0e-6
          var hashResolution = this.marCubeResoultion << 2
          var v = new THREE__namespace.Vector3()
          var ix = Math.floor(
            (hashResolution * (vAdd.x - this.vBoxMin.x)) /
              (this.vBoxMax.x + oneHynberes - this.vBoxMin.x)
          )
          var iy = Math.floor(
            (hashResolution * (vAdd.y - this.vBoxMin.y)) /
              (this.vBoxMax.y + oneHynberes - this.vBoxMin.y)
          )
          var iz = Math.floor(
            (hashResolution * (vAdd.z - this.vBoxMin.z)) /
              (this.vBoxMax.z + oneHynberes - this.vBoxMin.z)
          )
          var iHash = ix * n815851 + iz * n37633 + iy * n2453543
          iHash &= HASH_SIZE - 1
          var hLineIndex = iHash + iHash

          if (this.vBoxMin !== null && this.vBoxMax !== null) {
            for (
              entry = this.hashLines[hLineIndex + 1];
              entry >= 0;
              entry = this.hashEntries[entry * 2 + 1]
            ) {
              var ind = this.hashEntries[entry * 2 + 0]
              v.copy(geoOut._vertices[ind])
              v.x -= vAdd.x
              v.y -= vAdd.y
              v.z -= vAdd.z
              var dot2 = v.x * v.x + v.y * v.y + v.z * v.z

              if (dot2 < r106) {
                return ind
              }
            }
          }

          if (geoOut._numVertices >= this.maxNumVertices) {
            return 0 - 1
          }

          var iVertAdd = geoOut._numVertices

          geoOut._vertices[iVertAdd].copy(vAdd)

          if (this.vBoxMin !== null && this.vBoxMax !== null) {
            entry = this.getNewHashEntry()

            if (entry < 0) {
              return 0 - 1
            }

            var entryFirst = this.hashLines[hLineIndex + 1]
            this.hashLines[hLineIndex + 1] = entry
            this.hashEntries[entry * 2 + 0] = iVertAdd
            this.hashEntries[entry * 2 + 1] = entryFirst
            this.hashLines[hLineIndex + 0]++
          }

          geoOut._numVertices++
          return iVertAdd
        }
      },
      {
        key: 'modifyExcludedFromGeo',
        value: function modifyExcludedFromGeo(
          side,
          probeSphereRadius,
          vBoxMin,
          vBoxMax,
          geoOut,
          corners
        ) {
          var ind
          var distToSphere
          var distToBorder
          var r11 = 1.1

          function innerBlockWorkAround() {
            if (distToBorder > 0.0) {
              if (corners[ind] < 0.0) {
                corners[ind] = distToBorder
              }

              if (distToBorder > corners[ind]) {
                corners[ind] = distToBorder
              }
            } else if (distToBorder > corners[ind]) {
              corners[ind] = distToBorder
            }
          }

          var side2 = side * side
          var xScale = (side - 1) / (vBoxMax.x - vBoxMin.x)
          var yScale = (side - 1) / (vBoxMax.y - vBoxMin.y)
          var zScale = (side - 1) / (vBoxMax.z - vBoxMin.z)
          var probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2)
          var sideInv = 1.0 / (side - 1)

          for (var i = 0; i < geoOut._numVertices; i++) {
            var vCenter = geoOut._vertices[i]
            var radEst = probeSphereRadius * r11
            var indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale)
            var indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale)
            var indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale)
            var indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale)
            var indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale)
            var indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale)
            indXMin = indXMin >= 0 ? indXMin : 0
            indYMin = indYMin >= 0 ? indYMin : 0
            indZMin = indZMin >= 0 ? indZMin : 0
            indXMax = indXMax <= side - 1 ? indXMax : side - 1
            indYMax = indYMax <= side - 1 ? indYMax : side - 1
            indZMax = indZMax <= side - 1 ? indZMax : side - 1

            for (var iy = indYMin; iy <= indYMax; iy++) {
              var indY = iy * side2

              for (var iz = indZMin; iz <= indZMax; iz++) {
                var indZ = iz * side

                for (var ix = indXMin; ix <= indXMax; ix++) {
                  ind = indY + indZ + ix
                  var t = ix * sideInv
                  var xCorner = vBoxMin.x * (1.0 - t) + vBoxMax.x * t
                  t = iy * sideInv
                  var yCorner = vBoxMin.y * (1.0 - t) + vBoxMax.y * t
                  t = iz * sideInv
                  var zCorner = vBoxMin.z * (1.0 - t) + vBoxMax.z * t
                  var dx = xCorner - vCenter.x
                  var dy = yCorner - vCenter.y
                  var dz = zCorner - vCenter.z
                  var dist2 = dx * dx + dy * dy + dz * dz

                  if (dist2 < probeSpRad2) {
                    distToSphere = Math.sqrt(dist2)
                    distToBorder = -(distToSphere - probeSphereRadius)
                    innerBlockWorkAround()
                  }
                }
              }
            }
          }

          return 0
        }
      },
      {
        key: '_innerBuild',
        value: function _innerBuild() {
          var ok
          var expandFactor = 1.2
          var packedArrays = {
            posRad: this._posRad,
            colors: this._colors,
            atoms: this._opts.atoms
          }
          this.complex = this._opts.parent
          this.atoms = packedArrays.atoms
          this.meshResolution = this._opts.gridSpacing
          this.atomRadiusScale = this._opts.radScale
          this.colorMode = this._opts.colorMode
          this.probeRadius = this._opts.probeRadius
          this.useVertexColors = true
          this.excludeProbe = this._opts.excludeProbe
          this.visibilitySelector = this._opts.visibilitySelector
          this.geoOut = null
          this.hashLines = null
          this.hashEntries = null
          this.numHashEtriesAllocated = 0
          this.numHashEntryIndex = 0
          this.maxNumVertices = 0
          this.maxNumTriangles = 0
          var atomsColored = new Array(this.atoms.length)
          this.convertToAtomsColored(packedArrays, atomsColored)
          var vBoxMin = (this.vBoxMin = new THREE__namespace.Vector3())
          var vBoxMax = (this.vBoxMax = new THREE__namespace.Vector3())
          this.getBoundingBox(atomsColored, vBoxMin, vBoxMax)
          var marCubeResoultion = (this.marCubeResoultion =
            this.meshResolution * (2 + 2))
          var side = marCubeResoultion
          var side2 = side * side
          var side3 = side2 * side
          var corners = utils.allocateTyped(Float32Array, side3)
          var rProbeRadius = this.probeRadius * this.atomRadiusScale
          this.calculateGridCorners(
            corners,
            side,
            vBoxMin,
            vBoxMax,
            atomsColored,
            rProbeRadius
          )
          var numCells = marCubeResoultion - 1
          var cube = new IsoSurfaceMarchCube()
          ok = cube.create(numCells)

          if (ok < 0) {
            return ok
          }

          var vCellStep = new THREE__namespace.Vector3()
          vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells
          vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells
          vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells
          var numIntersectedCellsEstim = this.getNumIntersectedCells(
            side,
            numCells,
            corners,
            cube
          )
          var maxNumVertices = Math.floor(
            numIntersectedCellsEstim * expandFactor
          )
          var maxNumTriangles = Math.floor(
            numIntersectedCellsEstim * expandFactor * 2
          )
          this.geoOut = new IsoSurfaceGeo(
            maxNumVertices,
            maxNumTriangles,
            this.useVertexColors
          )
          ok = this.createVertexHash(maxNumVertices, maxNumTriangles)

          if (ok < 0) {
            return ok
          }

          var probeRadForNormalsColors = rProbeRadius

          if (this.excludeProbe) {
            probeRadForNormalsColors = 0.01
          }

          this.voxelWorld = new IsosurfaceBuildNormals(
            atomsColored.length,
            atomsColored,
            vBoxMin,
            vBoxMax,
            probeRadForNormalsColors
          )
          this.voxelWorld.createVoxels()
          ok = this.buildGeoFromCorners(
            marCubeResoultion,
            vBoxMin,
            vBoxMax,
            corners,
            vCellStep,
            cube
          )

          if (this.excludeProbe) {
            this.modifyExcludedFromGeo(
              side,
              rProbeRadius,
              vBoxMin,
              vBoxMax,
              this.geoOut,
              corners
            )
            this.geoOut._vertices = null
            this.geoOut._colors = null
            this.geoOut._indices = null
            this.geoOut._normals = null
            this.geoOut._numVertices = 0
            this.geoOut._numTriangles = 0
            this.geoOut = null
            numIntersectedCellsEstim = this.getNumIntersectedCells(
              side,
              numCells,
              corners,
              cube
            )
            maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor)
            maxNumTriangles = Math.floor(
              numIntersectedCellsEstim * expandFactor * 2
            )
            this.geoOut = new IsoSurfaceGeo(
              maxNumVertices,
              maxNumTriangles,
              this.useVertexColors
            )
            ok = this.createVertexHash(maxNumVertices, maxNumTriangles)

            if (ok < 0) {
              return ok
            }

            ok = this.buildGeoFromCorners(
              side,
              vBoxMin,
              vBoxMax,
              corners,
              vCellStep,
              cube
            )
          }

          this.voxelWorld.buildNormals(
            this.geoOut._vertices.length,
            this.geoOut._vertices,
            this.geoOut._normals
          )
          var radiusColorSmoothness = 6.5

          if (this.excludeProbe) {
            radiusColorSmoothness -= 1.5
          }

          if (this.useVertexColors) {
            this.voxelWorld.buildColors(
              this.geoOut._vertices.length,
              this.geoOut._vertices,
              this.geoOut._colors,
              radiusColorSmoothness
            )
          }

          this.voxelWorld.destroyVoxels()
          this.voxelWorld = null
          cube.destroy()
          return ok
        }
      }
    ])

    return SSIsosurfaceGeometry
  })(IsoSurfaceGeometry)

  function _createSuper$1x(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1x()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1x() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function createLabel(fieldTxt, className) {
    var text = document.createElement('div')
    text.className = className

    if (typeof fieldTxt === 'string') {
      var spanText = document.createElement('span')
      spanText.style.fontSize = '150%'
      var strings = fieldTxt.split('\n')

      for (var i = 0, n = strings.length; i < n; ++i) {
        var spanNodeP = document.createElement('span')
        var spanNodeText = document.createTextNode(strings[i])
        spanNodeP.appendChild(spanNodeText)
        spanText.appendChild(spanNodeP)

        if (i < n - 1) {
          spanText.appendChild(document.createElement('br'))
        }
      }

      text.appendChild(spanText)
    } else {
      text.appendChild(fieldTxt)
    }

    text.worldPos = new THREE__namespace.Vector3()
    return text
  }

  var LabelsGeometry = /*#__PURE__*/ (function (_EventDispatcher) {
    _inherits(LabelsGeometry, _EventDispatcher)

    var _super = _createSuper$1x(LabelsGeometry)

    function LabelsGeometry(instanceCount, opts) {
      var _this

      _classCallCheck(this, LabelsGeometry)

      _this = _super.call(this)
      _this._opts = opts
      _this.items = []
      _this.needsUpdate = false
      var xTranslation = -50
      var yTranslation = -50

      switch (opts.horizontalAlign) {
        case 'left':
          xTranslation = 0
          break

        case 'right':
          xTranslation = -100
          break
      }

      switch (opts.verticalAlign) {
        case 'top':
          yTranslation = -100
          break

        case 'bottom':
          yTranslation = 0
          break
      }

      var deltaPos = new THREE__namespace.Vector3(
        opts.dx || 0,
        opts.dy || 0,
        opts.dz || 0
      )
      _this.userData = {
        translation: 'translate('
          .concat(xTranslation, '%, ')
          .concat(yTranslation, '%)'),
        offset: deltaPos
      }
      return _this
    }

    _createClass(LabelsGeometry, [
      {
        key: 'setItem',
        value: function setItem(itemIdx, itemPos, fieldTxt) {
          var opts = this._opts
          var text = this.items[itemIdx] || createLabel(fieldTxt, 'label')
          text.worldPos.copy(itemPos)
          text.style.textAlign = opts.horizontalAlign
          text.style.verticalAlign = opts.verticalAlign
          this.items[itemIdx] = text
        }
      },
      {
        key: 'setColor',
        value: function setColor(itemIdx, fColor, bColor) {
          var text = this.items[itemIdx]
          text.opts = {
            color: fColor,
            background: bColor
          }
        }
      },
      {
        key: 'startUpdate',
        value: function startUpdate() {
          return true
        }
      },
      {
        key: 'finishUpdate',
        value: function finishUpdate() {
          this.needsUpdate = true
          this.dispatchEvent({
            type: 'update'
          })
        }
      },
      {
        key: 'finalize',
        value: function finalize() {
          this.finishUpdate()
        }
      },
      {
        key: 'raycast',
        value: function raycast() {}
      },
      {
        key: 'setOpacity',
        value: function setOpacity() {}
      },
      {
        key: 'getSubset',
        value: function getSubset() {
          return []
        }
      }
    ])

    return LabelsGeometry
  })(EventDispatcher)

  var geometries = {
    InstancedSpheresGeometry: InstancedSpheresGeometry,
    SimpleSpheresGeometry: SimpleSpheresGeometry,
    Simple2CCylindersGeometry: Simple2CCylindersGeometry,
    Instanced2CCylindersGeometry: Instanced2CCylindersGeometry,
    ExtrudedObjectsGeometry: ExtrudedObjectsGeometry,
    ChunkedLinesGeometry: ChunkedLinesGeometry,
    TwoColorLinesGeometry: TwoColorLinesGeometry,
    CrossGeometry: CrossGeometry,
    QuickSurfGeometry: QuickSurfGeometry,
    ContactSurfaceGeometry: ContactSurfaceGeometry,
    SSIsosurfaceGeometry: SSIsosurfaceGeometry,
    LabelsGeometry: LabelsGeometry
  }

  var vertexShader =
    'float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n    varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform mat4 projMatrixInv;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 objectNormal = vec3(\r\n    dot(normal, matVector1.xyz),\r\n    dot(normal, matVector2.xyz),\r\n    dot(normal, matVector3.xyz));\r\n#else\r\n  vec3 objectNormal = vec3( normal );\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n    spritePosEye = posEye;\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n    vec2 spriteSize;\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // In ortho projection we skip z coordinate\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r\n\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r\n    #else\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n      // full sprite size in eye coords\r\n      float minZ = min(abs(p1.z), abs(p2.z));\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r\n    #endif\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t  vec4 worldPosition;\r\n\t  // see THREE.WebGLProgram.unrollLoops\r\n\t  #pragma unroll_loop_start\r\n\t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r\n\t  }\r\n\t  #pragma unroll_loop_end\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n'

  var fragmentShader$6 =
    "#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r\n\r\n    #ifdef SHADOWMAP_PCF_RAND\r\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r\n      // unroll_loop and unroll_loop has pattern:\r\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n      uniform sampler2D noiseTex;\r\n      uniform vec2 noiseTexelSize;\r\n      uniform vec2 srcTexelSize;\r\n      uniform mat4 projectionMatrix;\r\n    #endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define PI 3.14159265359\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n  uniform float nearPlaneValue;\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n\r\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r\n    uniform mat4 projectionMatrix;\r\n  #endif\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n\r\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point inside frustum\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r\n      // t1 is always smaller than t2 (from calculations)\r\n      point = p1;\r\n      frontFaced = 1.0;\r\n      return true;\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into sphere local coords\r\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\r\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r\n\r\n      // transform camera orientation vector into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into sphere local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n      // transform vector from camera pos to curPixel into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  varying vec4 spritePosEye;\r\n\r\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    float halfHeight = 0.5;\r\n\r\n    // choose nearest point\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\r\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n    vec4 v;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform camera orientation vector into cylinder local coords\r\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into cylinder local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform vector from camera pos to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n  vec4 r = vec4( fract( v * PackFactors ), v );\r\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n  return r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n  return dot( v, UnpackFactors );\r\n}\r\n\r\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n  struct DirectionalLightShadow {\r\n     vec2 shadowMapSize;\r\n     float shadowBias;\r\n     float shadowRadius;\r\n   };\r\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r\n\r\n  uniform vec3 ambientLightColor;\r\n\r\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r\n\r\n  #if defined(SHADOWMAP)\r\n  \tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n  \t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n  \t}\r\n\r\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r\n   \t  float shadow = 0.0;\r\n\r\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r\n      shadowCoord.xyz /= shadowCoord.w;\r\n\r\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n      bool inFrustum = all( inFrustumVec );\r\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n      bool frustumTest = all( frustumTestVec );\r\n\r\n      if ( frustumTest ) {\r\n        #ifdef SHADOWMAP_BASIC\r\n      \t  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n      \t#endif\r\n\r\n      \t#ifdef SHADOWMAP_PCF_SHARP\r\n      \t  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\r\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\r\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\r\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\r\n\r\n            shadow = (\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n            ) * ( 1.0 / 9.0 );\r\n        #endif\r\n\r\n        #ifdef SHADOWMAP_PCF_RAND\r\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r\n\r\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r\n\r\n          vec2 offset;\r\n          #pragma unroll_loop_start\r\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r\n          }\r\n          #pragma unroll_loop_end\r\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n        #endif\r\n      }\r\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r\n   }\r\n  #endif\r\n\r\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color * PI;\r\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor * PI;\r\n\r\n    float shadowMask = 1.0;\r\n    // see THREE.WebGLProgram.unrollLoops\r\n  \t#pragma unroll_loop_start\r\n  \t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n  \t    #ifdef SHADOWMAP\r\n  \t      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r\n        #endif\r\n\r\n  \t\t  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r\n  \t\t}\r\n  \t\t#pragma unroll_loop_end\r\n\r\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n  #if NUM_DIR_LIGHTS > 0\r\n    // see THREE.WebGLProgram.unrollLoops\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n  #ifdef ATTR_COLOR\r\n    vec3 vertexColor = vColor;\r\n  #else\r\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n  #endif\r\n\r\n  #ifdef ATTR_COLOR2\r\n    #ifdef CYLINDER_SPRITE\r\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n    #else\r\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n    #endif\r\n      // choose either color or color2\r\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n  #endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n  #ifdef DASHED_LINE\r\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n  #endif\r\n\r\n  // transparency prepass writes only z, so we don't need to calc the color\r\n  #ifdef PREPASS_TRANSP\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n    float totalOpacity = opacity;\r\n\r\n  #ifdef ATTR_ALPHA_COLOR\r\n    totalOpacity *= alphaCol;\r\n  #endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n  #ifdef FAKE_OPACITY\r\n    // discard pixels in checker pattern\r\n    vec2 dm_coord = floor(gl_FragCoord.xy);\r\n    dm_coord = fract(dm_coord * 0.5);\r\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n    vec4 diffuseColor = vec4(diffuse, 1.0);\r\n  #else\r\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n  #endif\r\n\r\n  float flipNormal;\r\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n    flipNormal = 1.0;\r\n    #ifdef DOUBLE_SIDED\r\n      flipNormal = float( gl_FrontFacing );\r\n    #endif\r\n    vec3 normal = normalize( vNormal ) * flipNormal;\r\n  #endif\r\n\r\n    diffuseColor.rgb *= vertexColor;\r\n\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n\r\n  #ifdef NORMALS_TO_G_BUFFER\r\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n      vec3 viewNormaInColor = viewNormalSprites;\r\n    #else\r\n      vec3 viewNormaInColor = viewNormal;\r\n      float frontFaced = float( gl_FrontFacing );\r\n    #endif\r\n    // [-1, 1] -> [0, 1]\r\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r\n  #endif\r\n\r\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n    vec3 viewDir;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDir = -pixelPosEye.xyz;\r\n    #else\r\n      viewDir = vViewPosition;\r\n    #endif\r\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r\n  #else\r\n    vec3 outgoingLight = diffuseColor.rgb;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_DEPTH\r\n    float depth = 0.0;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n      depth = gl_FragDepthEXT;\r\n    #else\r\n      depth = gl_FragCoord.z;\r\n    #endif\r\n    fragColor = packDepthToRGBA(depth);\r\n    return;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_POS\r\n    fragColor = world2colorMatrix * pixelPosWorld;\r\n  #else\r\n    #ifdef OVERRIDE_COLOR\r\n      fragColor = vec4(fixedColor, diffuseColor.a);\r\n    #else\r\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n    #endif\r\n\r\n    #ifdef USE_FOG\r\n      float viewDistance;\r\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n        viewDistance = abs(pixelPosEye.z);\r\n      #else\r\n        viewDistance = vViewPosition.z;\r\n      #endif\r\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n      #ifdef FOG_TRANSPARENT\r\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n      #else\r\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n      #endif\r\n    #endif\r\n\r\n  #endif\r\n}\r\n"

  var capabilities = {
    precision: 'mediump',
    init: function init(renderer) {
      this.precision = renderer.capabilities.getMaxPrecision('highp')
    }
  }

  var noiseWidth = 4
  var noiseHeight = 4

  var _noiseData = new Uint8Array([
    24, 52, 0, 254, 145, 0, 122, 0, 0, 7, 170, 0, 34, 214, 0, 173, 8, 0, 86,
    249, 0, 160, 4, 0, 226, 46, 0, 224, 211, 0, 3, 157, 0, 174, 247, 0, 12, 182,
    0, 220, 216, 0, 1, 109, 0, 253, 154, 0
  ])

  var _noiseWrapS = THREE__namespace.RepeatWrapping
  var _noiseWrapT = THREE__namespace.RepeatWrapping
  var _noiseMinFilter = THREE__namespace.NearestFilter
  var _noiseMagFilter = THREE__namespace.NearestFilter
  var _noiseMapping = THREE__namespace.UVMapping
  var noiseTexture = new THREE__namespace.DataTexture(
    _noiseData,
    noiseWidth,
    noiseHeight,
    THREE__namespace.RGBFormat,
    THREE__namespace.UnsignedByteType,
    _noiseMapping,
    _noiseWrapS,
    _noiseWrapT,
    _noiseMagFilter,
    _noiseMinFilter,
    1
  )
  noiseTexture.needsUpdate = true
  var noise = {
    noiseWidth: noiseWidth,
    noiseHeight: noiseHeight,
    noiseTexture: noiseTexture
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object)
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object)
      enumerableOnly &&
        (symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable
        })),
        keys.push.apply(keys, symbols)
    }
    return keys
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {}
      i % 2
        ? ownKeys(Object(source), !0).forEach(function (key) {
            _defineProperty(target, key, source[key])
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(
            target,
            Object.getOwnPropertyDescriptors(source)
          )
        : ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(
              target,
              key,
              Object.getOwnPropertyDescriptor(source, key)
            )
          })
    }
    return target
  }

  function _createSuper$1w(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1w()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1w() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var _samplesKernel$1 = [
    new THREE__namespace.Vector2(-0.541978, 0.840393),
    new THREE__namespace.Vector2(0.125533, -0.992089),
    new THREE__namespace.Vector2(0.374329, 0.927296),
    new THREE__namespace.Vector2(-0.105475, 0.994422)
  ]
  var defaultUniforms = THREE__namespace.UniformsUtils.merge([
    THREE__namespace.UniformsLib.fog,
    THREE__namespace.UniformsLib.lights,
    {
      diffuse: {
        value: new THREE__namespace.Color(0xeeeeee)
      },
      opacity: {
        value: 1.0
      },
      specular: {
        type: 'c',
        value: new THREE__namespace.Color(0x111111)
      },
      shininess: {
        type: 'f',
        value: 30
      },
      fixedColor: {
        type: 'c',
        value: new THREE__namespace.Color(0xffffff)
      },
      zOffset: {
        type: 'f',
        value: 0.0
      },
      zClipValue: {
        type: 'f',
        value: 0.0
      },
      clipPlaneValue: {
        type: 'f',
        value: 0.0
      },
      nearPlaneValue: {
        type: 'f',
        value: -0.5
      },
      invModelViewMatrix: {
        type: '4fv',
        value: new THREE__namespace.Matrix4()
      },
      world2colorMatrix: {
        type: '4fv',
        value: new THREE__namespace.Matrix4()
      },
      dashedLineSize: {
        type: 'f',
        value: 0.1
      },
      dashedLinePeriod: {
        type: 'f',
        value: 0.2
      },
      projMatrixInv: {
        type: '4fv',
        value: new THREE__namespace.Matrix4()
      },
      viewport: {
        type: 'v2',
        value: new THREE__namespace.Vector2()
      },
      lineWidth: {
        type: 'f',
        value: 2.0
      },
      fogAlpha: {
        type: 'f',
        value: 1.0
      },
      samplesKernel: {
        type: 'v2v',
        value: null
      },
      noiseTex: {
        type: 't',
        value: null
      },
      noiseTexelSize: {
        type: 'v2',
        value: null
      },
      srcTexelSize: {
        type: 'v2',
        value: null
      }
    }
  ])
  var uberOptionNames = [
    'shininess',
    'opacity',
    'zOffset',
    'diffuse',
    'specular',
    'fixedColor',
    'zClipCoef',
    'zClipValue',
    'clipPlaneValue',
    'world2colorMatrix',
    'dashedLineSize',
    'dashedLinePeriod',
    'projMatrixInv',
    'viewport',
    'lineWidth',
    'fogAlpha',
    'samplesKernel',
    'noiseTex',
    'noiseTexelSize',
    'srcTexelSize'
  ]
  var uberOptions = {
    diffuse: new THREE__namespace.Color(0xffffff),
    specular: new THREE__namespace.Color(0x111111),
    shininess: 30,
    opacity: 1,
    fixedColor: new THREE__namespace.Color(0xffffff),
    zOffset: 0.0,
    zClipCoef: 2.0,
    zClipValue: 0.0,
    clipPlaneValue: 0.0,
    world2colorMatrix: new THREE__namespace.Matrix4(),
    dashedLineSize: 0.1,
    dashedLinePeriod: 0.3,
    projMatrixInv: new THREE__namespace.Matrix4(),
    viewport: new THREE__namespace.Vector2(800, 600),
    lineWidth: 2.0,
    fogAlpha: 1.0,
    samplesKernel: _samplesKernel$1,
    noiseTex: noise.noiseTexture,
    noiseTexelSize: new THREE__namespace.Vector2(
      1.0 / noise.noiseWidth,
      1.0 / noise.noiseHeight
    ),
    srcTexelSize: new THREE__namespace.Vector2(1.0 / 800.0, 1.0 / 600.0),
    copy: function copy(source) {
      this.diffuse.copy(source.diffuse)
      this.specular.copy(source.specular)
      this.shininess = source.shininess
      this.opacity = source.opacity
      this.fixedColor.copy(source.fixedColor)
      this.zOffset = source.zOffset
      this.zClipCoef = source.zClipCoef
      this.zClipValue = source.zClipValue
      this.clipPlaneValue = source.clipPlaneValue
      this.world2colorMatrix.copy(source.world2colorMatrix)
      this.dashedLineSize = source.dashedLineSize
      this.dashedLinePeriod = source.dashedLinePeriod
      this.projMatrixInv = source.projMatrixInv
      this.viewport = source.viewport
      this.lineWidth = source.lineWidth
      this.toonShading = source.toonShading
      this.fogAlpha = source.fogAlpha
      this.samplesKernel = source.samplesKernel
      this.noiseTex = source.noiseTex
      this.noiseTexelSize = source.noiseTexelSize
      this.srcTexelSize = source.srcTexelSize
    }
  }

  var UberMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(UberMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$1w(UberMaterial)

    function UberMaterial(params) {
      var _this

      _classCallCheck(this, UberMaterial)

      _this = _super.call(this, params)
      _this.fog = true
      _this.instancedPos = false
      _this.instancedMatrix = false
      _this.attrColor = false
      _this.attrColor2 = false
      _this.attrAlphaColor = false
      _this.overrideColor = false
      _this.sphereSprite = false
      _this.cylinderSprite = false
      _this.zClip = false
      _this.clipPlane = false
      _this.fakeOpacity = false
      _this.prepassTransparancy = false
      _this.colorFromPos = false
      _this.shadowmap = false
      _this.shadowmapType = 'random'
      _this.colorFromDepth = false
      _this.orthoCam = false
      _this.dashedLine = false
      _this.transparent = true
      _this.thickLine = false
      _this.fogTransparent = false
      _this.normalsToGBuffer = false
      _this.toonShading = false
      _this.uberOptions = uberOptions

      _this.setValues(
        _objectSpread(
          {
            uniforms: THREE__namespace.UniformsUtils.clone(defaultUniforms),
            vertexShader: _this.precisionString() + vertexShader,
            fragmentShader: _this.precisionString() + fragmentShader$6,
            lights: true,
            fog: true,
            side: THREE__namespace.DoubleSide
          },
          params
        )
      )

      return _this
    }

    _createClass(UberMaterial, [
      {
        key: 'precisionString',
        value: function precisionString() {
          var precision = capabilities.precision
          var str =
            'precision '.concat(precision, ' float;\n') +
            'precision '.concat(precision, ' int;\n\n')
          return str
        }
      },
      {
        key: 'copy',
        value: function copy(source) {
          _get(_getPrototypeOf(UberMaterial.prototype), 'copy', this).call(
            this,
            source
          )

          this.fragmentShader = source.fragmentShader
          this.vertexShader = source.vertexShader
          this.uniforms = THREE__namespace.UniformsUtils.clone(source.uniforms)
          this.defines = _objectSpread({}, source.defines)
          this.extensions = source.extensions
          this.fog = source.fog
          this.instancedPos = source.instancedPos
          this.instancedMatrix = source.instancedMatrix
          this.attrColor = source.attrColor
          this.attrColor2 = source.attrColor2
          this.attrAlphaColor = source.attrAlphaColor
          this.overrideColor = source.overrideColor
          this.sphereSprite = source.sphereSprite
          this.cylinderSprite = source.cylinderSprite
          this.zClip = source.zClip
          this.clipPlane = source.clipPlane
          this.fakeOpacity = source.fakeOpacity
          this.colorFromPos = source.colorFromPos
          this.shadowmap = source.shadowmap
          this.shadowmapType = source.shadowmapType
          this.colorFromDepth = source.colorFromDepth
          this.orthoCam = source.orthoCam
          this.prepassTransparancy = source.prepassTransparancy
          this.dashedLine = source.dashedLine
          this.thickLine = source.thickLine
          this.fogTransparent = source.fogTransparent
          this.normalsToGBuffer = source.normalsToGBuffer
          this.toonShading = source.toonShading
          this.uberOptions.copy(source.uberOptions)
          return this
        }
      },
      {
        key: 'createInstance',
        value: function createInstance() {
          var inst = new UberMaterial()
          inst.copy(this)
          inst.uberOptions = Object.create(this.uberOptions)
          return inst
        }
      },
      {
        key: 'setValues',
        value: function setValues(values) {
          if (typeof values === 'undefined') {
            return
          }

          _get(_getPrototypeOf(UberMaterial.prototype), 'setValues', this).call(
            this,
            values
          )

          var defines = {}
          var extensions = {}

          if (this.fog) {
            defines.USE_FOG = 1
          }

          if (this.instancedPos) {
            defines.INSTANCED_POS = 1
          }

          if (this.instancedMatrix) {
            defines.INSTANCED_MATRIX = 1
          }

          if (this.attrColor) {
            defines.ATTR_COLOR = 1
          }

          if (this.attrColor2) {
            defines.ATTR_COLOR2 = 1
          }

          if (this.attrAlphaColor) {
            defines.ATTR_ALPHA_COLOR = 1
          }

          if (this.overrideColor) {
            defines.OVERRIDE_COLOR = 1
          }

          if (this.sphereSprite) {
            defines.SPHERE_SPRITE = 1
            extensions.fragDepth = 1
          }

          if (this.cylinderSprite) {
            defines.CYLINDER_SPRITE = 1
            extensions.fragDepth = 1
          }

          if (this.zClip) {
            defines.ZCLIP = 1
          }

          if (this.clipPlane) {
            defines.CLIP_PLANE = 1
          }

          if (this.fakeOpacity) {
            defines.FAKE_OPACITY = 1
          }

          if (this.lights) {
            defines.USE_LIGHTS = 1
          }

          if (this.colorFromPos) {
            defines.COLOR_FROM_POS = 1
          }

          if (this.shadowmap) {
            defines.SHADOWMAP = 1

            if (this.shadowmapType === 'pcf') {
              defines.SHADOWMAP_PCF_SHARP = 1
            } else if (this.shadowmapType === 'random') {
              defines.SHADOWMAP_PCF_RAND = 1
            } else {
              defines.SHADOWMAP_BASIC = 1
            }
          }

          if (this.colorFromDepth) {
            defines.COLOR_FROM_DEPTH = 1
          }

          if (this.orthoCam) {
            defines.ORTHOGRAPHIC_CAMERA = 1
          }

          if (this.prepassTransparancy) {
            defines.PREPASS_TRANSP = 1
          }

          if (this.dashedLine) {
            defines.DASHED_LINE = 1
          }

          if (this.thickLine) {
            defines.THICK_LINE = 1
          }

          if (this.fogTransparent) {
            defines.FOG_TRANSPARENT = 1
          }

          if (this.normalsToGBuffer) {
            extensions.drawBuffers = 1
            defines.NORMALS_TO_G_BUFFER = 1
          }

          if (this.toonShading) {
            defines.TOON_SHADING = 1
          }

          this.defines = defines
          this.extensions = extensions
        }
      },
      {
        key: 'setUberOptions',
        value: function setUberOptions(values) {
          if (typeof values === 'undefined') {
            return
          }

          for (var key in values) {
            if (!values.hasOwnProperty(key)) {
              continue
            }

            if (this.uberOptions[key] instanceof THREE__namespace.Color) {
              this.uberOptions[key] = values[key].clone()
            } else {
              this.uberOptions[key] = values[key]
            }
          }
        }
      },
      {
        key: 'clone',
        value: function clone(shallow) {
          if (!shallow) {
            return THREE__namespace.Material.prototype.clone.call(this)
          }

          return this.createInstance()
        }
      },
      {
        key: 'updateUniforms',
        value: function updateUniforms() {
          var self = this
          uberOptionNames.forEach(function (p) {
            if (self.uniforms.hasOwnProperty(p)) {
              if (
                self.uberOptions[p] instanceof THREE__namespace.Color ||
                self.uberOptions[p] instanceof THREE__namespace.Matrix4
              ) {
                self.uniforms[p].value = self.uberOptions[p].clone()
              } else {
                self.uniforms[p].value = self.uberOptions[p]
              }
            }
          })
        }
      }
    ])

    return UberMaterial
  })(THREE__namespace.RawShaderMaterial)

  function _createSuper$1v(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1v()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1v() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  function UberObject(SuperClass) {
    var NewObjectType = /*#__PURE__*/ (function (_SuperClass) {
      _inherits(NewObjectType, _SuperClass)

      var _super = _createSuper$1v(NewObjectType)

      function NewObjectType() {
        var _this

        _classCallCheck(this, NewObjectType)

        for (
          var _len = arguments.length, rest = new Array(_len), _key = 0;
          _key < _len;
          _key++
        ) {
          rest[_key] = arguments[_key]
        }

        _this = _super.call.apply(_super, [this].concat(rest))
        _this.onBeforeRender = NewObjectType.prototype.onBeforeRender
        return _this
      }

      _createClass(NewObjectType, [
        {
          key: 'onBeforeRender',
          value: function onBeforeRender(
            renderer,
            scene,
            camera,
            geometry,
            material,
            group
          ) {
            this._onBeforeRender(
              renderer,
              scene,
              camera,
              geometry,
              material,
              group
            )

            this._update()
          }
        },
        {
          key: '_onBeforeRender',
          value: function _onBeforeRender() {}
        },
        {
          key: '_update',
          value: function _update() {
            var material = this.material

            if (!material) {
              return
            }

            if (material instanceof UberMaterial) {
              material.updateUniforms()
            }
          }
        }
      ])

      return NewObjectType
    })(SuperClass)

    return NewObjectType
  }

  function _createSuper$1u(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1u()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1u() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Mesh$4 = UberObject(THREE__namespace.Mesh)

  var ZSpriteMesh = /*#__PURE__*/ (function (_Mesh) {
    _inherits(ZSpriteMesh, _Mesh)

    var _super = _createSuper$1u(ZSpriteMesh)

    function ZSpriteMesh() {
      var _this

      _classCallCheck(this, ZSpriteMesh)

      for (
        var _len = arguments.length, rest = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        rest[_key] = arguments[_key]
      }

      _this = _super.call.apply(_super, [this].concat(rest))
      _this.castShadow = true
      _this.receiveShadow = true
      return _this
    }

    _createClass(ZSpriteMesh, [
      {
        key: '_onBeforeRender',
        value: function _onBeforeRender(
          renderer,
          scene,
          camera,
          _geometry,
          _material,
          _group
        ) {
          Mesh$4.prototype._onBeforeRender.call(this, renderer, scene, camera)

          var material = this.material

          if (!material) {
            return
          }

          if (material.uniforms.invModelViewMatrix) {
            this.modelViewMatrix.multiplyMatrices(
              camera.matrixWorldInverse,
              this.matrixWorld
            )
            material.uniforms.invModelViewMatrix.value
              .copy(this.modelViewMatrix)
              .invert()
            material.uniforms.nearPlaneValue.value = camera.near
            material.uniformsNeedUpdate = true
          }
        }
      }
    ])

    return ZSpriteMesh
  })(Mesh$4)

  function _createSuper$1t(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1t()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1t() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Mesh$3 = UberObject(THREE__namespace.Mesh)

  var ZClippedMesh = /*#__PURE__*/ (function (_Mesh) {
    _inherits(ZClippedMesh, _Mesh)

    var _super = _createSuper$1t(ZClippedMesh)

    function ZClippedMesh(geometry, material) {
      var _this

      _classCallCheck(this, ZClippedMesh)

      _this = _super.call(this, geometry, material)
      _this.castShadow = true
      _this.receiveShadow = true
      return _this
    }

    _createClass(ZClippedMesh, [
      {
        key: '_onBeforeRender',
        value: function _onBeforeRender(renderer, scene, camera) {
          Mesh$3.prototype._onBeforeRender.call(this, renderer, scene, camera)

          var geo = this.geometry
          var material = this.material

          if (!geo.zClip || !material.uberOptions) {
            return
          }

          var zClipCoef = 0.5
          var modelView = ZClippedMesh._modelView
          var mvLength = ZClippedMesh._mvLength
          var center = ZClippedMesh._center
          modelView.multiplyMatrices(
            this.matrixWorld,
            camera.matrixWorldInverse
          )
          var s = mvLength.setFromMatrixColumn(modelView, 0).length()
          center.copy(geo.boundingSphere.center)
          this.localToWorld(center)
          material.uberOptions.zClipValue =
            camera.position.z -
            center.z -
            s * (zClipCoef * geo.boundingSphere.radius)
        }
      }
    ])

    return ZClippedMesh
  })(Mesh$3)

  _defineProperty(ZClippedMesh, '_mvLength', new THREE__namespace.Vector3())

  _defineProperty(ZClippedMesh, '_center', new THREE__namespace.Vector3())

  _defineProperty(ZClippedMesh, '_modelView', new THREE__namespace.Matrix4())

  function _createSuper$1s(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1s()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1s() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var TextMesh = /*#__PURE__*/ (function (_THREE$Group) {
    _inherits(TextMesh, _THREE$Group)

    var _super = _createSuper$1s(TextMesh)

    function TextMesh(geometry, _material) {
      var _this

      _classCallCheck(this, TextMesh)

      _this = _super.call(this)
      _this.geometry = geometry

      var self = _assertThisInitialized(_this)

      self.initialized = false

      _this.geometry.addEventListener('update', function () {
        self.update()
      })

      return _this
    }

    _createClass(TextMesh, [
      {
        key: 'init',
        value: function init() {
          var children = this.children

          for (var i = children.length - 1; i >= 0; --i) {
            this.remove(children[i])
          }

          var _this$geometry = this.geometry,
            items = _this$geometry.items,
            userData = _this$geometry.userData

          for (var _i = 0, n = items.length; _i < n; ++_i) {
            var srcItem = items[_i]

            if (!srcItem) {
              continue
            }

            var item = utils.shallowCloneNode(srcItem)
            var label = new CSS2DObject(item)
            label.userData = ___default['default'].clone(userData)
            var el = label.getElement()
            el.style.visibility = 'visible'
            label.source = srcItem
            this.add(label)
          }

          this.initialized = true
        }
      },
      {
        key: 'update',
        value: function update() {
          var geo = this.geometry

          if (!geo.needsUpdate) {
            return
          }

          var children = this.children

          if (!this.initialized) {
            this.init()
          }

          for (var i = 0, n = children.length; i < n; ++i) {
            var child = children[i]
            var item = child.source
            child.position.copy(item.worldPos)
            child.userData.color = item.opts.color
            child.userData.background = item.opts.background
          }
        }
      }
    ])

    return TextMesh
  })(THREE__namespace.Group)

  function _createSuper$1r(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1r()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1r() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Mesh$2 = UberObject(THREE__namespace.Mesh)

  var SimpleMesh = /*#__PURE__*/ (function (_Mesh) {
    _inherits(SimpleMesh, _Mesh)

    var _super = _createSuper$1r(SimpleMesh)

    function SimpleMesh(geometry, material) {
      var _this

      _classCallCheck(this, SimpleMesh)

      _this = _super.call(this, geometry, material)
      _this.castShadow = true
      _this.receiveShadow = true
      return _this
    }

    return _createClass(SimpleMesh)
  })(Mesh$2)

  function _createSuper$1q(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1q()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1q() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Mesh$1 = UberObject(THREE__namespace.Mesh)

  var _viewport = new THREE__namespace.Vector2()

  var ThickLineMesh = /*#__PURE__*/ (function (_Mesh) {
    _inherits(ThickLineMesh, _Mesh)

    var _super = _createSuper$1q(ThickLineMesh)

    function ThickLineMesh() {
      _classCallCheck(this, ThickLineMesh)

      return _super.apply(this, arguments)
    }

    _createClass(ThickLineMesh, [
      {
        key: '_onBeforeRender',
        value: function _onBeforeRender(
          renderer,
          scene,
          camera,
          _geometry,
          _material,
          _group
        ) {
          var material = this.material

          if (!material.uberOptions) {
            return
          }

          material.uberOptions.projMatrixInv
            .copy(camera.projectionMatrix)
            .invert()
          renderer.getSize(_viewport)
          material.uberOptions.viewport.set(_viewport.width, _viewport.height)
        }
      }
    ])

    return ThickLineMesh
  })(Mesh$1)

  function _createSuper$1p(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1p()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1p() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Mesh = UberObject(THREE__namespace.Mesh)

  var InstancedMesh = /*#__PURE__*/ (function (_Mesh) {
    _inherits(InstancedMesh, _Mesh)

    var _super = _createSuper$1p(InstancedMesh)

    function InstancedMesh() {
      var _this

      _classCallCheck(this, InstancedMesh)

      for (
        var _len = arguments.length, rest = new Array(_len), _key = 0;
        _key < _len;
        _key++
      ) {
        rest[_key] = arguments[_key]
      }

      _this = _super.call.apply(_super, [this].concat(rest))
      _this.castShadow = true
      _this.receiveShadow = true
      return _this
    }

    return _createClass(InstancedMesh)
  })(Mesh)

  var meshes = {
    ZClipped: ZClippedMesh,
    ZSprite: ZSpriteMesh,
    Text: TextMesh,
    Line: UberObject(THREE__namespace.Line),
    LineSegments: UberObject(THREE__namespace.LineSegments),
    Mesh: SimpleMesh,
    ThickLineMesh: ThickLineMesh,
    Instanced: InstancedMesh
  }

  function setMatParams(params, uniforms) {
    return function (material) {
      material.setValues(params)
      material.setUberOptions(uniforms)
    }
  }

  function _createInstancedCylinders(useZSprites, openEnded) {
    return {
      Geometry: function Geometry(a, b) {
        return new geometries.Instanced2CCylindersGeometry(
          a,
          b,
          useZSprites,
          openEnded
        )
      },
      Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
      initMaterial: setMatParams({
        instancedMatrix: true,
        attrColor: true,
        attrColor2: true,
        attrAlphaColor: true,
        cylinderSprite: useZSprites
      })
    }
  }

  function _createLineSegmentsGeoTriplet(geo, renderParams) {
    var thickLines = geo.prototype instanceof ThickLinesGeometry
    var lineWidth = renderParams.lineWidth || 0
    return {
      Geometry: geo,
      Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
      initMaterial: setMatParams(
        {
          lights: false,
          attrColor: true,
          attrAlphaColor: true,
          thickLine: thickLines
        },
        {
          lineWidth: lineWidth
        }
      )
    }
  }

  function _createSimpleGeoTriplet(geoClass) {
    return {
      Geometry: geoClass,
      Object: meshes.Mesh,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: true
      })
    }
  }

  function _createIsoSurfaceGeoTriplet(geoClass, caps, settings, renderParams) {
    var surfaceOpts = {
      wireframe: !!renderParams.wireframe,
      fakeOpacity: settings.now.isoSurfaceFakeOpacity,
      zClip: renderParams.zClip
    }
    return {
      Geometry: geoClass,
      Object: meshes.ZClipped,
      initMaterial: setMatParams({
        attrColor: true,
        attrAlphaColor: false,
        wireframe: surfaceOpts.wireframe,
        fakeOpacity: surfaceOpts.fakeOpacity,
        zClip: surfaceOpts.zClip
      })
    }
  }

  var MeshCreator = /*#__PURE__*/ (function () {
    function MeshCreator() {
      _classCallCheck(this, MeshCreator)
    }

    _createClass(MeshCreator, null, [
      {
        key: 'createSpheres',
        value: function createSpheres(caps, settings) {
          var useZSprites = settings.now.zSprites
          return {
            Geometry: function Geometry(a, b) {
              return new geometries.InstancedSpheresGeometry(a, b, useZSprites)
            },
            Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
            initMaterial: setMatParams({
              instancedPos: true,
              attrColor: true,
              attrAlphaColor: true,
              sphereSprite: useZSprites
            })
          }
        }
      },
      {
        key: 'create2CClosedCylinders',
        value: function create2CClosedCylinders(_caps, _settings) {
          return _createInstancedCylinders(false, false)
        }
      },
      {
        key: 'create2CCylinders',
        value: function create2CCylinders(caps, settings) {
          return _createInstancedCylinders(settings.now.zSprites, true)
        }
      },
      {
        key: 'create2CLines',
        value: function create2CLines(_caps, _settings, renderParams) {
          return _createLineSegmentsGeoTriplet(
            geometries.TwoColorLinesGeometry,
            renderParams
          )
        }
      },
      {
        key: 'createCrosses',
        value: function createCrosses(_caps, _settings, renderParams) {
          return _createLineSegmentsGeoTriplet(
            geometries.CrossGeometry,
            renderParams
          )
        }
      },
      {
        key: 'createExtrudedChains',
        value: function createExtrudedChains(_caps, _settings) {
          return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry)
        }
      },
      {
        key: 'createChunkedLines',
        value: function createChunkedLines(_caps, _settings, renderParams) {
          return _createLineSegmentsGeoTriplet(
            geometries.ChunkedLinesGeometry,
            renderParams
          )
        }
      },
      {
        key: 'createQuickSurface',
        value: function createQuickSurface(caps, settings, renderParams) {
          return _createIsoSurfaceGeoTriplet(
            geometries.QuickSurfGeometry,
            caps,
            settings,
            renderParams
          )
        }
      },
      {
        key: 'createContactSurface',
        value: function createContactSurface(caps, settings, renderParams) {
          return _createIsoSurfaceGeoTriplet(
            geometries.ContactSurfaceGeometry,
            caps,
            settings,
            renderParams
          )
        }
      },
      {
        key: 'createSASSES',
        value: function createSASSES(caps, settings, renderParams) {
          return _createIsoSurfaceGeoTriplet(
            geometries.SSIsosurfaceGeometry,
            caps,
            settings,
            renderParams
          )
        }
      },
      {
        key: 'createLabels',
        value: function createLabels(_caps, _settings) {
          return {
            Geometry: geometries.LabelsGeometry,
            Object: meshes.Text,
            initMaterial: function initMaterial() {}
          }
        }
      }
    ])

    return MeshCreator
  })()

  function _createSuper$1o(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1o()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1o() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var TransformGroup = /*#__PURE__*/ (function (_THREE$Object3D) {
    _inherits(TransformGroup, _THREE$Object3D)

    var _super = _createSuper$1o(TransformGroup)

    function TransformGroup(geometry, geoParams, material, transforms) {
      var _this

      _classCallCheck(this, TransformGroup)

      _this = _super.call(this)
      _this._geometry = geometry
      _this._geoParams = geoParams
      var mat = material.createInstance()
      geoParams.initMaterial(mat)
      _this._material = mat
      _this._transforms =
        transforms.length > 0 ? transforms : [new THREE__namespace.Matrix4()]

      var meshes = _this._createMeshes(geometry)

      for (var i = 0, n = meshes.length; i < n; ++i) {
        _this.add(meshes[i])
      }

      return _this
    }

    _createClass(TransformGroup, [
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var ray = TransformGroup._ray
          var inverseMatrix = TransformGroup._inverseMatrix
          var children = this.children
          ray.copy(raycaster.ray)

          for (var i = 0, n = children.length; i < n; ++i) {
            var child = children[i]

            if (!gfxutils.belongToSelectLayers(child)) {
              continue
            }

            child.updateMatrixWorld()
            var mtx = child.matrixWorld
            inverseMatrix.copy(mtx).invert()
            raycaster.ray.copy(ray).applyMatrix4(inverseMatrix)
            var childIntersects = []

            this._geometry.raycast(raycaster, childIntersects)

            for (
              var j = 0, ciCount = childIntersects.length;
              j < ciCount;
              ++j
            ) {
              var inters = childIntersects[j]

              if (inters.point) {
                inters.point.applyMatrix4(mtx)
                inters.distance = ray.origin.distanceTo(inters.point)
              }

              inters.object = child
              intersects[intersects.length] = inters
            }
          }

          raycaster.ray.copy(ray)
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(chunkIndices) {
          var geos = this._geometry.getSubset(chunkIndices)

          var subset = []
          var subIdx = 0

          for (var i = 0, n = geos.length; i < n; ++i) {
            var meshes = this._createMeshes(geos[i])

            for (var j = 0, meshCnt = meshes.length; j < meshCnt; ++j) {
              subset[subIdx++] = meshes[j]
            }
          }

          return subset
        }
      },
      {
        key: '_createMeshes',
        value: function _createMeshes(geometry) {
          var transforms = this._transforms
          var Mesh = this._geoParams.Object
          var material = this._material
          var meshes = []

          for (var i = 0, n = transforms.length; i < n; ++i) {
            var mesh = new Mesh(geometry, material)
            mesh.applyMatrix4(transforms[i])
            meshes[i] = mesh
          }

          return meshes
        }
      }
    ])

    return TransformGroup
  })(THREE__namespace.Object3D)

  _defineProperty(
    TransformGroup,
    '_inverseMatrix',
    new THREE__namespace.Matrix4()
  )

  _defineProperty(TransformGroup, '_ray', new THREE__namespace.Ray())

  function _createSuper$1n(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1n()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1n() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function wrapper(Name, args) {
    var params = [Name].concat(args)
    return Name.bind.apply(Name, _toConsumableArray(params))
  }

  var ChemGroup = /*#__PURE__*/ (function (_RCGroup) {
    _inherits(ChemGroup, _RCGroup)

    var _super = _createSuper$1n(ChemGroup)

    function ChemGroup(
      geoParams,
      selection,
      colorer,
      mode,
      transforms,
      polyComplexity,
      material
    ) {
      var _this

      _classCallCheck(this, ChemGroup)

      _this = _super.call(this)

      if (_this.constructor === ChemGroup) {
        throw new Error('Can not instantiate abstract class!')
      }

      _this._selection = selection
      _this._mode = mode
      _this._colorer = colorer
      _this._chunksIdc = selection.chunks
      _this._polyComplexity = polyComplexity
      _this._geo = new (wrapper(geoParams.Geometry, _this._makeGeoArgs()))()
      _this._mesh = new TransformGroup(
        _this._geo,
        geoParams,
        material,
        transforms
      )

      _this.add(_this._mesh)

      _this._build()

      return _this
    }

    _createClass(ChemGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          throw new Error(
            'ChemGroup subclass must override _makeGeoArgs() method'
          )
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          innerOnly = innerOnly !== undefined ? innerOnly : false

          var chunksList = this._calcChunksList(mask, innerOnly)

          if (chunksList.length === 0) {
            return []
          }

          return this._mesh.getSubset(chunksList)
        }
      },
      {
        key: '_changeSubsetOpacity',
        value: function _changeSubsetOpacity(mask, value, innerOnly) {
          var chunksList = this._calcChunksList(mask, innerOnly)

          if (chunksList.length === 0) {
            return
          }

          this._geo.setOpacity(chunksList, value)
        }
      },
      {
        key: 'enableSubset',
        value: function enableSubset(mask, innerOnly) {
          innerOnly = innerOnly !== undefined ? innerOnly : true

          this._changeSubsetOpacity(mask, 1.0, innerOnly)
        }
      },
      {
        key: 'disableSubset',
        value: function disableSubset(mask, innerOnly) {
          innerOnly = innerOnly !== undefined ? innerOnly : true

          this._changeSubsetOpacity(mask, 0.0, innerOnly)
        }
      }
    ])

    return ChemGroup
  })(RCGroup)

  function _createSuper$1m(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1m()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1m() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AtomsGroup = /*#__PURE__*/ (function (_ChemGroup) {
    _inherits(AtomsGroup, _ChemGroup)

    var _super = _createSuper$1m(AtomsGroup)

    function AtomsGroup() {
      _classCallCheck(this, AtomsGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AtomsGroup, [
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var atoms = this._selection.atoms
          var inters = []

          this._mesh.raycast(raycaster, inters)

          var atomsIdc = this._chunksIdc

          for (var i = 0, n = inters.length; i < n; ++i) {
            if (!inters[i].hasOwnProperty('chunkIdx')) {
              continue
            }

            var atomIdx = atomsIdc[inters[i].chunkIdx]

            if (atomIdx < atoms.length) {
              inters[i].atom = atoms[atomIdx]
              intersects.push(inters[i])
            }
          }
        }
      },
      {
        key: '_calcChunksList',
        value: function _calcChunksList(mask) {
          var chunksList = []
          var atoms = this._selection.atoms
          var atomsIdc = this._chunksIdc

          for (var i = 0, n = atomsIdc.length; i < n; ++i) {
            var atom = atoms[atomsIdc[i]]

            if ((atom.mask & mask) !== 0) {
              chunksList.push(i)
            }
          }

          return chunksList
        }
      }
    ])

    return AtomsGroup
  })(ChemGroup)

  function _createSuper$1l(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1l()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1l() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AtomsSphereGroup = /*#__PURE__*/ (function (_AtomsGroup) {
    _inherits(AtomsSphereGroup, _AtomsGroup)

    var _super = _createSuper$1l(AtomsSphereGroup)

    function AtomsSphereGroup() {
      _classCallCheck(this, AtomsSphereGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AtomsSphereGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          return [this._selection.chunks.length, this._polyComplexity]
        }
      },
      {
        key: '_build',
        value: function _build() {
          var atomsIdc = this._selection.chunks
          var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo

          for (var i = 0, n = atomsIdc.length; i < n; ++i) {
            var atom = atoms[atomsIdc[i]]
            geo.setItem(i, atom.position, mode.calcAtomRadius(atom))
            geo.setColor(i, colorer.getAtomColor(atom, parent))
          }

          geo.finalize()
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var atomsIdc = this._selection.chunks
          var atoms = this._selection.atoms
          var mode = this._mode
          var colorer = this._colorer
          var updateColor = frameData.needsColorUpdate(colorer)
          var geo = this._geo

          for (var i = 0, n = atomsIdc.length; i < n; ++i) {
            var atom = atoms[atomsIdc[i]]
            geo.setItem(
              i,
              frameData.getAtomPos(atomsIdc[i]),
              mode.calcAtomRadius(atom)
            )

            if (updateColor) {
              geo.setColor(i, frameData.getAtomColor(colorer, atom))
            }
          }

          geo.finalize()
        }
      }
    ])

    return AtomsSphereGroup
  })(AtomsGroup)

  function _createSuper$1k(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1k()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1k() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AtomsSurfaceGroup = /*#__PURE__*/ (function (_AtomsSphereGroup) {
    _inherits(AtomsSurfaceGroup, _AtomsSphereGroup)

    var _super = _createSuper$1k(AtomsSurfaceGroup)

    function AtomsSurfaceGroup() {
      _classCallCheck(this, AtomsSurfaceGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AtomsSurfaceGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          var selectedAtoms = []
          var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks
          var n = chunks.length

          for (var i = 0; i < n; ++i) {
            selectedAtoms[i] = atoms[chunks[i]]
          }

          var opts = this._mode.getSurfaceOpts()

          opts.atoms = selectedAtoms
          return [n, opts]
        }
      }
    ])

    return AtomsSurfaceGroup
  })(AtomsSphereGroup)

  function _createSuper$1j(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1j()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1j() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AtomsSASSESGroupStub = /*#__PURE__*/ (function (_AtomsSphereGroup) {
    _inherits(AtomsSASSESGroupStub, _AtomsSphereGroup)

    var _super = _createSuper$1j(AtomsSASSESGroupStub)

    function AtomsSASSESGroupStub() {
      _classCallCheck(this, AtomsSASSESGroupStub)

      return _super.apply(this, arguments)
    }

    _createClass(AtomsSASSESGroupStub, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          var selectedAtoms = []
          var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            chunks = _this$_selection.chunks
          var n = chunks.length

          for (var i = 0; i < n; ++i) {
            selectedAtoms[i] = atoms[chunks[i]]
          }

          var opts = this._mode.getSurfaceOpts()

          opts.atoms = selectedAtoms
          opts.selection = this._selection
          opts.colorMode = this._colorer
          return [n, opts]
        }
      }
    ])

    return AtomsSASSESGroupStub
  })(AtomsSphereGroup)

  function _createSuper$1i(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1i()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1i() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function adjustColor(color) {
    var r = (color >> 16) & 255
    var g = (color >> 8) & 255
    var b = color & 255

    if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
      r = (r * 3) / 10
      g = (g * 3) / 10
      b = (b * 3) / 10
    } else {
      r = 255 - ((255 - r) * 3) / 10
      g = 255 - ((255 - g) * 3) / 10
      b = 255 - ((255 - b) * 3) / 10
    }

    return (r << 16) | (g << 8) | b
  }

  function inverseColor(color) {
    var r = (color >> 16) & 255
    var g = (color >> 8) & 255
    var b = color & 255
    return ((255 - r) << 16) | ((255 - g) << 8) | (255 - b)
  }

  function getAtomText(atom) {
    if (atom.name.getNode() !== null) {
      return atom.name.getNode()
    }

    return atom.getVisualName()
  }

  var colorMappings = {
    none: function none(c) {
      return c
    },
    adjust: adjustColor,
    inverse: inverseColor
  }

  function propagateColor(color, rule) {
    var result

    if (colorMappings.hasOwnProperty(rule)) {
      result = utils.hexColor(colorMappings[rule](color))
    } else {
      var val = parseInt(rule, 16)

      if (!Number.isNaN(val) && rule.toLowerCase().startsWith('0x')) {
        result = utils.hexColor(val)
      } else {
        result = '#000000'
      }
    }

    return result
  }

  var templateMappings = {
    serial: function serial(a) {
      return a.serial
    },
    name: function name(a) {
      return a.getVisualName()
    },
    elem: function elem(a) {
      return a.element.name
    },
    residue: function residue(a) {
      return a.residue.getType().getName()
    },
    sequence: function sequence(a) {
      return a.residue.getSequence()
    },
    chain: function chain(a) {
      return a.residue.getChain().getName()
    },
    hetatm: function hetatm(a) {
      return a.isHet()
    },
    water: function water(a) {
      return (
        a.residue.getType().getName() === 'HOH' ||
        a.residue.getType().getName() === 'WAT'
      )
    }
  }

  var parseTemplate = function parseTemplate(atom, str) {
    return str.replace(/\{\{(\s*\w+\s*)\}\}/g, function (m) {
      var key = m.replace(/\s+/g, '')
      key = key.substring(2, key.length - 2).toLowerCase()

      if (templateMappings.hasOwnProperty(key)) {
        return templateMappings[key](atom)
      }

      return 'null'
    })
  }

  var AtomsTextGroup = /*#__PURE__*/ (function (_AtomsGroup) {
    _inherits(AtomsTextGroup, _AtomsGroup)

    var _super = _createSuper$1i(AtomsTextGroup)

    function AtomsTextGroup() {
      _classCallCheck(this, AtomsTextGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AtomsTextGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          var opts = this._mode.getLabelOpts()

          return [this._selection.chunks.length, opts]
        }
      },
      {
        key: '_build',
        value: function _build() {
          var opts = this._mode.getLabelOpts()

          var atomsIdc = this._selection.chunks
          var _this$_selection = this._selection,
            atoms = _this$_selection.atoms,
            parent = _this$_selection.parent
          var colorer = this._colorer
          var geo = this._geo

          for (var i = 0, n = atomsIdc.length; i < n; ++i) {
            var atom = atoms[atomsIdc[i]]
            var text = opts.template
              ? parseTemplate(atom, opts.template)
              : getAtomText(atom)

            if (!text) {
              continue
            }

            var color = colorer.getAtomColor(atom, parent)
            var fgColor = parseInt(
              propagateColor(color, opts.fg).substring(1),
              16
            )
            var bgColor = opts.showBg
              ? parseInt(propagateColor(color, opts.bg).substring(1), 16)
              : 'transparent'
            geo.setItem(i, atom.position, text)
            geo.setColor(i, fgColor, bgColor)
          }

          geo.finalize()
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var opts = this._mode.getLabelOpts()

          var atomsIdc = this._selection.chunks
          var atoms = this._selection.atoms
          var colorer = this._colorer
          var geo = this._geo
          var updateColor = frameData.needsColorUpdate(colorer)

          for (var i = 0, n = atomsIdc.length; i < n; ++i) {
            var atom = atoms[atomsIdc[i]]
            var text = opts.template
              ? parseTemplate(atom, opts.template)
              : getAtomText(atom)

            if (!text) {
              continue
            }

            var color = frameData.getAtomColor(colorer, atom)
            var fgColor = parseInt(
              propagateColor(color, opts.fg).substring(1),
              16
            )
            var bgColor = opts.showBg
              ? parseInt(propagateColor(color, opts.bg).substring(1), 16)
              : 'transparent'
            geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), text)

            if (updateColor) {
              geo.setColor(i, fgColor, bgColor)
            }
          }

          geo.finalize()
        }
      }
    ])

    return AtomsTextGroup
  })(AtomsGroup)

  function _createSuper$1h(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1h()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1h() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function _slerp(omega, v1, v2, t) {
    var oSin = Math.sin(omega)
    return v1
      .clone()
      .multiplyScalar(Math.sin((1 - t) * omega) / oSin)
      .addScaledVector(v2, Math.sin(t * omega) / oSin)
  }

  var AromaticGroup = /*#__PURE__*/ (function (_AtomsGroup) {
    _inherits(AromaticGroup, _AtomsGroup)

    var _super = _createSuper$1h(AromaticGroup)

    function AromaticGroup() {
      _classCallCheck(this, AromaticGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AromaticGroup, [
      {
        key: '_buildInner',
        value: function _buildInner(radOffset, addChunk) {
          var chunksToIdx = this._selection.chunks
          var prevVector = new THREE__namespace.Vector3()
          var currVector = new THREE__namespace.Vector3()
          var segmentsHeight = this._segmentsHeight
          var leprStep = 1.0 / segmentsHeight
          var colorer = this._colorer
          var _this$_selection = this._selection,
            cycles = _this$_selection.cycles,
            parent = _this$_selection.parent
          var chunkIdx = 0
          var currAtomIdx = chunksToIdx[chunkIdx]

          for (var cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
            var cycle = cycles[cIdx]
            var cycAtoms = cycle.atoms
            var chunkPoints = []
            var tmpDir = []
            var center = cycle.center
            var cycleRad = cycle.radius - radOffset
            var n = cycAtoms.length
            var i = 0
            var prevPos = cycAtoms[n - 1].position
            var currPos = cycAtoms[i].position
            prevVector.subVectors(prevPos, center)
            currVector.subVectors(currPos, center)
            var upDir = currVector.clone().cross(prevVector).normalize()

            for (; i < n; ++i) {
              var omega = prevVector.angleTo(currVector)
              tmpDir[i] = _slerp(omega, prevVector, currVector, 0.5).normalize()
              currPos = cycAtoms[(i + 1) % n].position
              prevVector.copy(currVector)
              currVector.subVectors(currPos, center)
            }

            for (i = 0; i < n; ++i) {
              if (cycAtoms[i].index !== currAtomIdx) {
                continue
              }

              var start = tmpDir[i]
              var end = tmpDir[(i + 1) % n]
              var color = colorer.getAtomColor(cycAtoms[i], parent)
              var currAngle = start.angleTo(end)

              for (var j = 0; j <= segmentsHeight; ++j) {
                chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep)
                  .multiplyScalar(cycleRad)
                  .add(center)
              }

              addChunk(chunkIdx++, color, chunkPoints, center, upDir)
              currAtomIdx = chunksToIdx[chunkIdx]
            }
          }
        }
      }
    ])

    return AromaticGroup
  })(AtomsGroup)

  function _createSuper$1g(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1g()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1g() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function _createShape$1(rad, parts) {
    var pts = []

    for (var i = 0; i < parts; ++i) {
      var a = ((-2 * i) / parts) * Math.PI
      pts.push(
        new THREE__namespace.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0)
      )
    }

    return pts
  }

  var calcChunkMatrix = gfxutils.calcChunkMatrix

  var AromaticTorusGroup = /*#__PURE__*/ (function (_AromaticGroup) {
    _inherits(AromaticTorusGroup, _AromaticGroup)

    var _super = _createSuper$1g(AromaticTorusGroup)

    function AromaticTorusGroup() {
      _classCallCheck(this, AromaticTorusGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AromaticTorusGroup, [
      {
        key: '_build',
        value: function _build() {
          var segmentsHeight = this._segmentsHeight

          var torusRad = this._mode.getAromRadius()

          var radiusV = new THREE__namespace.Vector2(torusRad, torusRad)
          var radOffset = this._mode.calcStickRadius() + 2 * torusRad
          var lookAtVector = new THREE__namespace.Vector3()
          var mtc = []
          var geo = this._geo

          this._buildInner(
            radOffset,
            function (chunkIdx, color, points, center, upDir) {
              for (var j = 0; j <= segmentsHeight; ++j) {
                var currPoint = points[j]
                var currDir = currPoint.clone().sub(center).cross(upDir)
                lookAtVector.addVectors(currPoint, currDir)
                mtc[j] = calcChunkMatrix(
                  currPoint,
                  lookAtVector,
                  upDir,
                  radiusV
                )
              }

              geo.setItem(chunkIdx, mtc)
              geo.setColor(chunkIdx, color)
            }
          )

          geo.finalize()
        }
      },
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          this._segmentsHeight = this._polyComplexity
          return [
            _createShape$1(1.0, this._polyComplexity),
            this._segmentsHeight + 1,
            this._selection.chunks.length
          ]
        }
      }
    ])

    return AromaticTorusGroup
  })(AromaticGroup)

  function _createSuper$1f(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1f()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1f() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AromaticLinesGroup = /*#__PURE__*/ (function (_AromaticGroup) {
    _inherits(AromaticLinesGroup, _AromaticGroup)

    var _super = _createSuper$1f(AromaticLinesGroup)

    function AromaticLinesGroup() {
      _classCallCheck(this, AromaticLinesGroup)

      return _super.apply(this, arguments)
    }

    _createClass(AromaticLinesGroup, [
      {
        key: '_build',
        value: function _build() {
          var _this = this

          var geo = this._geo

          var radOffset = this._mode.getAromaticOffset()

          this._buildInner(radOffset, function (chunkIdx, color, points) {
            var prevPt = points[0]

            for (var j = 1; j <= _this._segmentsHeight; ++j) {
              var currPoint = points[j]
              geo.setSegment(chunkIdx, j - 1, prevPt, currPoint)
              prevPt = currPoint
            }

            geo.setColor(chunkIdx, color)
          })

          geo.finalize()
        }
      },
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          this._segmentsHeight = this._mode.getAromaticArcChunks()
          return [this._selection.chunks.length, this._segmentsHeight, true]
        }
      }
    ])

    return AromaticLinesGroup
  })(AromaticGroup)

  function _createSuper$1e(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1e()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1e() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ResiduesGroup = /*#__PURE__*/ (function (_ChemGroup) {
    _inherits(ResiduesGroup, _ChemGroup)

    var _super = _createSuper$1e(ResiduesGroup)

    function ResiduesGroup() {
      _classCallCheck(this, ResiduesGroup)

      return _super.apply(this, arguments)
    }

    _createClass(ResiduesGroup, [
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var residues = this._selection.residues
          var inters = []

          this._mesh.raycast(raycaster, inters)

          var chunksIdc = this._chunksIdc

          for (var i = 0, n = inters.length; i < n; ++i) {
            if (!inters[i].hasOwnProperty('chunkIdx')) {
              continue
            }

            var resIdx = chunksIdc[inters[i].chunkIdx]

            if (resIdx < residues.length) {
              inters[i].residue = residues[resIdx]
              intersects.push(inters[i])
            }
          }
        }
      },
      {
        key: '_calcChunksList',
        value: function _calcChunksList(mask) {
          var chunksList = []
          var residues = this._selection.residues
          var resIdc = this._chunksIdc

          for (var i = 0, n = resIdc.length; i < n; ++i) {
            var res = residues[resIdc[i]]

            if ((res._mask & mask) !== 0) {
              chunksList.push(i)
            }
          }

          return chunksList
        }
      }
    ])

    return ResiduesGroup
  })(ChemGroup)

  function _createSuper$1d(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1d()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1d() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var NucleicItemGroup = /*#__PURE__*/ (function (_ResiduesGroup) {
    _inherits(NucleicItemGroup, _ResiduesGroup)

    var _super = _createSuper$1d(NucleicItemGroup)

    function NucleicItemGroup() {
      _classCallCheck(this, NucleicItemGroup)

      return _super.apply(this, arguments)
    }

    _createClass(NucleicItemGroup, [
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var residues = this._selection.residues
          var inters = []

          this._mesh.raycast(raycaster, inters)

          var chunksIdc = this._chunksIdc

          for (var i = 0, n = inters.length; i < n; ++i) {
            if (!inters[i].hasOwnProperty('chunkIdx')) {
              continue
            }

            var resIdx = chunksIdc[Math.floor(inters[i].chunkIdx / 2)]

            if (resIdx < residues.length) {
              inters[i].residue = residues[resIdx]
              intersects.push(inters[i])
            }
          }
        }
      },
      {
        key: '_build',
        value: function _build() {
          var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent
          var colorer = this._colorer
          var geo = this._geo

          var stickRad = this._mode.calcStickRadius()

          var chunkIdx = 0
          var resIdc = this._selection.chunks

          for (var i = 0, n = resIdc.length; i < n; ++i) {
            var res = residues[resIdc[i]]
            var color = colorer.getResidueColor(res, parent)

            this._processItem(
              chunkIdx++,
              res._cylinders[0],
              res._cylinders[1],
              stickRad,
              color
            )
          }

          geo.finalize()
        }
      },
      {
        key: '_calcChunksList',
        value: function _calcChunksList(mask) {
          var chunksList = []
          var chunkIdx = 0
          var residues = this._selection.residues
          var resIdc = this._chunksIdc

          for (var i = 0, n = resIdc.length; i < n; ++i) {
            var res = residues[resIdc[i]]

            if ((res._mask & mask) !== 0) {
              chunksList[chunkIdx++] = 2 * i
              chunksList[chunkIdx++] = 2 * i + 1
            }
          }

          return chunksList
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var residues = frameData.getResidues()
          var parent = this._selection.parent
          var colorer = this._colorer
          var geo = this._geo

          var stickRad = this._mode.calcStickRadius()

          var chunkIdx = 0
          var resIdc = this._selection.chunks

          for (var i = 0, n = resIdc.length; i < n; ++i) {
            var res = residues[resIdc[i]]
            var color = colorer.getResidueColor(res, parent)

            this._processItem(
              chunkIdx++,
              res._cylinders[0],
              res._cylinders[1],
              stickRad,
              color
            )
          }

          geo.finishUpdate()
        }
      }
    ])

    return NucleicItemGroup
  })(ResiduesGroup)

  function _createSuper$1c(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1c()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1c() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var NucleicCylindersGroup = /*#__PURE__*/ (function (_NucleicItemGroup) {
    _inherits(NucleicCylindersGroup, _NucleicItemGroup)

    var _super = _createSuper$1c(NucleicCylindersGroup)

    function NucleicCylindersGroup() {
      _classCallCheck(this, NucleicCylindersGroup)

      return _super.apply(this, arguments)
    }

    _createClass(NucleicCylindersGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          return [this._selection.chunks.length, this._polyComplexity]
        }
      },
      {
        key: '_processItem',
        value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
          var geo = this._geo
          geo.setItem(chunkIdx, cyl1, cyl2, stickRad)
          geo.setColor(chunkIdx, color, color)
        }
      }
    ])

    return NucleicCylindersGroup
  })(NucleicItemGroup)

  function _createSuper$1b(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1b()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1b() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var NucleicSpheresGroup = /*#__PURE__*/ (function (_NucleicItemGroup) {
    _inherits(NucleicSpheresGroup, _NucleicItemGroup)

    var _super = _createSuper$1b(NucleicSpheresGroup)

    function NucleicSpheresGroup() {
      _classCallCheck(this, NucleicSpheresGroup)

      return _super.apply(this, arguments)
    }

    _createClass(NucleicSpheresGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          return [this._selection.chunks.length * 2, this._polyComplexity]
        }
      },
      {
        key: '_processItem',
        value: function _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
          var geo = this._geo
          var idx = chunkIdx * 2
          geo.setItem(idx, cyl1, stickRad)
          geo.setColor(idx, color)
          idx++
          geo.setItem(idx, cyl2, stickRad)
          geo.setColor(idx, color)
        }
      }
    ])

    return NucleicSpheresGroup
  })(NucleicItemGroup)

  var Smooth = {}

  ;(function (exports) {
    /*
  Smooth.js version 0.1.7

  Turn arrays into smooth functions.

  Copyright 2012 Spencer Cohen
  Licensed under MIT license (see "Smooth.js MIT license.txt")
  */

    /*Constants (these are accessible by Smooth.WHATEVER in user space)
     */

    ;(function () {
      var AbstractInterpolator,
        CubicInterpolator,
        Enum,
        LinearInterpolator,
        NearestInterpolator,
        PI,
        SincFilterInterpolator,
        Smooth,
        clipClamp,
        clipMirror,
        clipPeriodic,
        defaultConfig,
        getColumn,
        getType,
        isValidNumber,
        k,
        makeLanczosWindow,
        makeScaledFunction,
        makeSincKernel,
        normalizeScaleTo,
        shallowCopy,
        sin,
        sinc,
        v,
        validateNumber,
        validateVector,
        __hasProp = Object.prototype.hasOwnProperty,
        __extends = function (child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key)) child[key] = parent[key]
          }
          function ctor() {
            this.constructor = child
          }
          ctor.prototype = parent.prototype
          child.prototype = new ctor()
          child.__super__ = parent.prototype
          return child
        }

      Enum = {
        /*Interpolation methods
         */
        METHOD_NEAREST: 'nearest',
        METHOD_LINEAR: 'linear',
        METHOD_CUBIC: 'cubic',
        METHOD_LANCZOS: 'lanczos',
        METHOD_SINC: 'sinc',
        /*Input clipping modes
         */
        CLIP_CLAMP: 'clamp',
        CLIP_ZERO: 'zero',
        CLIP_PERIODIC: 'periodic',
        CLIP_MIRROR: 'mirror',
        /* Constants for control over the cubic interpolation tension
         */
        CUBIC_TENSION_DEFAULT: 0,
        CUBIC_TENSION_CATMULL_ROM: 0
      }

      defaultConfig = {
        method: Enum.METHOD_CUBIC,
        cubicTension: Enum.CUBIC_TENSION_DEFAULT,
        clip: Enum.CLIP_CLAMP,
        scaleTo: 0,
        sincFilterSize: 2,
        sincWindow: void 0
      }

      /*Index clipping functions
       */

      clipClamp = function (i, n) {
        return Math.max(0, Math.min(i, n - 1))
      }

      clipPeriodic = function (i, n) {
        i = i % n
        if (i < 0) i += n
        return i
      }

      clipMirror = function (i, n) {
        var period
        period = 2 * (n - 1)
        i = clipPeriodic(i, period)
        if (i > n - 1) i = period - i
        return i
      }

      /*
    Abstract scalar interpolation class which provides common functionality for all interpolators
    
    Subclasses must override interpolate().
    */

      AbstractInterpolator = (function () {
        function AbstractInterpolator(array, config) {
          this.array = array.slice(0)
          this.length = this.array.length
          if (
            !(this.clipHelper = {
              clamp: this.clipHelperClamp,
              zero: this.clipHelperZero,
              periodic: this.clipHelperPeriodic,
              mirror: this.clipHelperMirror
            }[config.clip])
          ) {
            throw 'Invalid clip: ' + config.clip
          }
        }

        AbstractInterpolator.prototype.getClippedInput = function (i) {
          if (0 <= i && i < this.length) {
            return this.array[i]
          } else {
            return this.clipHelper(i)
          }
        }

        AbstractInterpolator.prototype.clipHelperClamp = function (i) {
          return this.array[clipClamp(i, this.length)]
        }

        AbstractInterpolator.prototype.clipHelperZero = function (i) {
          return 0
        }

        AbstractInterpolator.prototype.clipHelperPeriodic = function (i) {
          return this.array[clipPeriodic(i, this.length)]
        }

        AbstractInterpolator.prototype.clipHelperMirror = function (i) {
          return this.array[clipMirror(i, this.length)]
        }

        AbstractInterpolator.prototype.interpolate = function (t) {
          throw 'Subclasses of AbstractInterpolator must override the interpolate() method.'
        }

        return AbstractInterpolator
      })()

      NearestInterpolator = (function (_super) {
        __extends(NearestInterpolator, _super)

        function NearestInterpolator() {
          NearestInterpolator.__super__.constructor.apply(this, arguments)
        }

        NearestInterpolator.prototype.interpolate = function (t) {
          return this.getClippedInput(Math.round(t))
        }

        return NearestInterpolator
      })(AbstractInterpolator)

      LinearInterpolator = (function (_super) {
        __extends(LinearInterpolator, _super)

        function LinearInterpolator() {
          LinearInterpolator.__super__.constructor.apply(this, arguments)
        }

        LinearInterpolator.prototype.interpolate = function (t) {
          var k
          k = Math.floor(t)
          t -= k
          return (
            (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1)
          )
        }

        return LinearInterpolator
      })(AbstractInterpolator)

      CubicInterpolator = (function (_super) {
        __extends(CubicInterpolator, _super)

        function CubicInterpolator(array, config) {
          this.tangentFactor =
            1 - Math.max(-1, Math.min(1, config.cubicTension))
          CubicInterpolator.__super__.constructor.apply(this, arguments)
        }

        CubicInterpolator.prototype.getTangent = function (k) {
          return (
            (this.tangentFactor *
              (this.getClippedInput(k + 1) - this.getClippedInput(k - 1))) /
            2
          )
        }

        CubicInterpolator.prototype.interpolate = function (t) {
          var k, m, p, t2, t3
          k = Math.floor(t)
          m = [this.getTangent(k), this.getTangent(k + 1)]
          p = [this.getClippedInput(k), this.getClippedInput(k + 1)]
          t -= k
          t2 = t * t
          t3 = t * t2
          return (
            (2 * t3 - 3 * t2 + 1) * p[0] +
            (t3 - 2 * t2 + t) * m[0] +
            (-2 * t3 + 3 * t2) * p[1] +
            (t3 - t2) * m[1]
          )
        }

        return CubicInterpolator
      })(AbstractInterpolator)

      ;(sin = Math.sin), (PI = Math.PI)

      sinc = function (x) {
        if (x === 0) {
          return 1
        } else {
          return sin(PI * x) / (PI * x)
        }
      }

      makeLanczosWindow = function (a) {
        return function (x) {
          return sinc(x / a)
        }
      }

      makeSincKernel = function (window) {
        return function (x) {
          return sinc(x) * window(x)
        }
      }

      SincFilterInterpolator = (function (_super) {
        __extends(SincFilterInterpolator, _super)

        function SincFilterInterpolator(array, config) {
          SincFilterInterpolator.__super__.constructor.apply(this, arguments)
          this.a = config.sincFilterSize
          if (!config.sincWindow) throw 'No sincWindow provided'
          this.kernel = makeSincKernel(config.sincWindow)
        }

        SincFilterInterpolator.prototype.interpolate = function (t) {
          var k, n, sum, _ref, _ref2
          k = Math.floor(t)
          sum = 0
          for (
            n = _ref = k - this.a + 1, _ref2 = k + this.a;
            _ref <= _ref2 ? n <= _ref2 : n >= _ref2;
            _ref <= _ref2 ? n++ : n--
          ) {
            sum += this.kernel(t - n) * this.getClippedInput(n)
          }
          return sum
        }

        return SincFilterInterpolator
      })(AbstractInterpolator)

      getColumn = function (arr, i) {
        var row, _i, _len, _results
        _results = []
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          row = arr[_i]
          _results.push(row[i])
        }
        return _results
      }

      makeScaledFunction = function (f, baseScale, scaleRange) {
        var scaleFactor, translation
        if (scaleRange.join === '0,1') {
          return f
        } else {
          scaleFactor = baseScale / (scaleRange[1] - scaleRange[0])
          translation = scaleRange[0]
          return function (t) {
            return f(scaleFactor * (t - translation))
          }
        }
      }

      getType = function (x) {
        return Object.prototype.toString.call(x).slice('[object '.length, -1)
      }

      validateNumber = function (n) {
        if (isNaN(n)) throw 'NaN in Smooth() input'
        if (getType(n) !== 'Number') throw 'Non-number in Smooth() input'
        if (!isFinite(n)) throw 'Infinity in Smooth() input'
      }

      validateVector = function (v, dimension) {
        var n, _i, _len
        if (getType(v) !== 'Array') throw 'Non-vector in Smooth() input'
        if (v.length !== dimension)
          throw 'Inconsistent dimension in Smooth() input'
        for (_i = 0, _len = v.length; _i < _len; _i++) {
          n = v[_i]
          validateNumber(n)
        }
      }

      isValidNumber = function (n) {
        return getType(n) === 'Number' && isFinite(n) && !isNaN(n)
      }

      normalizeScaleTo = function (s) {
        var invalidErr
        invalidErr = 'scaleTo param must be number or array of two numbers'
        switch (getType(s)) {
          case 'Number':
            if (!isValidNumber(s)) throw invalidErr
            s = [0, s]
            break
          case 'Array':
            if (s.length !== 2) throw invalidErr
            if (!(isValidNumber(s[0]) && isValidNumber(s[1]))) throw invalidErr
            break
          default:
            throw invalidErr
        }
        return s
      }

      shallowCopy = function (obj) {
        var copy, k, v
        copy = {}
        for (k in obj) {
          if (!__hasProp.call(obj, k)) continue
          v = obj[k]
          copy[k] = v
        }
        return copy
      }

      Smooth = function (arr, config) {
        var baseDomainEnd,
          dimension,
          i,
          interpolator,
          interpolatorClass,
          interpolators,
          k,
          n,
          properties,
          smoothFunc,
          v
        if (config == null) config = {}
        properties = {}
        config = shallowCopy(config)
        properties.config = shallowCopy(config)
        if (config.scaleTo == null) config.scaleTo = config.period
        if (config.sincFilterSize == null) {
          config.sincFilterSize = config.lanczosFilterSize
        }
        for (k in defaultConfig) {
          if (!__hasProp.call(defaultConfig, k)) continue
          v = defaultConfig[k]
          if (config[k] == null) config[k] = v
        }
        if (
          !(interpolatorClass = {
            nearest: NearestInterpolator,
            linear: LinearInterpolator,
            cubic: CubicInterpolator,
            lanczos: SincFilterInterpolator,
            sinc: SincFilterInterpolator
          }[config.method])
        ) {
          throw 'Invalid method: ' + config.method
        }
        if (config.method === 'lanczos') {
          config.sincWindow = makeLanczosWindow(config.sincFilterSize)
        }
        if (arr.length < 2) throw 'Array must have at least two elements'
        properties.count = arr.length
        smoothFunc = (function () {
          var _i, _j, _len, _len2
          switch (getType(arr[0])) {
            case 'Number':
              properties.dimension = 'scalar'
              if (Smooth.deepValidation) {
                for (_i = 0, _len = arr.length; _i < _len; _i++) {
                  n = arr[_i]
                  validateNumber(n)
                }
              }
              interpolator = new interpolatorClass(arr, config)
              return function (t) {
                return interpolator.interpolate(t)
              }
            case 'Array':
              properties.dimension = dimension = arr[0].length
              if (!dimension) throw 'Vectors must be non-empty'
              if (Smooth.deepValidation) {
                for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
                  v = arr[_j]
                  validateVector(v, dimension)
                }
              }
              interpolators = (function () {
                var _results
                _results = []
                for (
                  i = 0;
                  0 <= dimension ? i < dimension : i > dimension;
                  0 <= dimension ? i++ : i--
                ) {
                  _results.push(
                    new interpolatorClass(getColumn(arr, i), config)
                  )
                }
                return _results
              })()
              return function (t) {
                var interpolator, _k, _len3, _results
                _results = []
                for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
                  interpolator = interpolators[_k]
                  _results.push(interpolator.interpolate(t))
                }
                return _results
              }
            default:
              throw 'Invalid element type: ' + getType(arr[0])
          }
        })()
        if (config.clip === 'periodic') {
          baseDomainEnd = arr.length
        } else {
          baseDomainEnd = arr.length - 1
        }
        config.scaleTo || (config.scaleTo = baseDomainEnd)
        properties.domain = normalizeScaleTo(config.scaleTo)
        smoothFunc = makeScaledFunction(
          smoothFunc,
          baseDomainEnd,
          properties.domain
        )
        properties.domain.sort()
        /*copy properties
         */
        for (k in properties) {
          if (!__hasProp.call(properties, k)) continue
          v = properties[k]
          smoothFunc[k] = v
        }
        return smoothFunc
      }

      for (k in Enum) {
        if (!__hasProp.call(Enum, k)) continue
        v = Enum[k]
        Smooth[k] = v
      }

      Smooth.deepValidation = true

      ;(exports !== null ? exports : window).Smooth = Smooth
    }.call(commonjsGlobal))
  })(Smooth)

  var ResidueType = chem.ResidueType
  var calcMatrix = gfxutils.calcChunkMatrix

  function _buildStructureInterpolator(points, tension) {
    var path = Smooth.Smooth(points, {
      method: Smooth.Smooth.METHOD_CUBIC,
      clip: Smooth.Smooth.CLIP_CLAMP,
      cubicTension: tension,
      scaleTo: 1
    })
    return function (t, argTrans) {
      var transformT = argTrans

      if (transformT === null) {
        transformT = function transformT(tt) {
          return (tt * (points.length - 1 - 2) + 1) / (points.length - 1)
        }
      }

      var newt = transformT(t)
      var ans = path(newt)
      return new THREE__namespace.Vector3(ans[0], ans[1], ans[2])
    }
  }

  function _addPoints(centerPoints, topPoints, idx, residue) {
    if (!residue._isValid) {
      centerPoints[idx] = centerPoints[idx - 1]
      topPoints[idx] = topPoints[idx - 1]
      return
    }

    var cp = residue._controlPoint
    centerPoints[idx] = [cp.x, cp.y, cp.z]
    var tp = cp.clone().add(residue._wingVector)
    topPoints[idx] = [tp.x, tp.y, tp.z]
  }

  function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
    var nucleic = (residue._type.flags & ResidueType.Flags.NUCLEIC) !== 0
    var nameFrom = nucleic ? "C5'" : 'N'
    var nameTo = nucleic ? "C3'" : 'C'
    var posFrom
    var posTo
    residue.forEachAtom(function (atom) {
      var name = atom.getVisualName()

      if (!posFrom && name === nameFrom) {
        posFrom = atom.position
      } else if (!posTo && name === nameTo) {
        posTo = atom.position
      }
    })

    if (!(posFrom && posTo)) {
      posFrom = residue._firstAtom.position
      posTo = residue._lastAtom.position
    }

    if (posFrom && posTo) {
      var shift = posTo.clone().sub(posFrom)
      var wing = residue._wingVector
      var cp = residue._controlPoint
      var tp = cp.clone().add(wing)
      var cpPrev = cp.clone().sub(shift)
      var tpPrev = cpPrev.clone().add(wing)
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z]
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z]
      ++idx
      centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z]
      topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z]
      ++idx
      centerPoints[idx] = [cp.x, cp.y, cp.z]
      topPoints[idx] = [tp.x, tp.y, tp.z]
      ++idx
      var cpNext = cp.clone().add(shift)
      var tpNext = cpNext.clone().add(wing)
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z]
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z]
      ++idx
      centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z]
      topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z]
    }
  }

  function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
    var left = boundaries.start
    var right = boundaries.end

    function _prevIdx(idx) {
      return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx
    }

    function _nextIdx(idx) {
      return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx
    }

    var topPoints = []
    var centerPoints = []
    var arrIdx = 0

    function _extrapolate2(currIdx, otherIdx) {
      var cp = residues[currIdx]._controlPoint
        .clone()
        .lerp(residues[otherIdx]._controlPoint, -0.25)

      var tp = cp.clone().add(residues[currIdx]._wingVector)
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z]
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z]
      centerPoints[arrIdx] = [cp.x, cp.y, cp.z]
      topPoints[arrIdx++] = [tp.x, tp.y, tp.z]
    }

    var prevIdx = _prevIdx(firstIdx)

    var nextIdx = _nextIdx(lastIdx)

    if (prevIdx === nextIdx) {
      _addPointsForLoneResidue(
        centerPoints,
        topPoints,
        arrIdx,
        residues[firstIdx]
      )

      return {
        centerPoints: centerPoints,
        topPoints: topPoints
      }
    }

    if (firstIdx === prevIdx) {
      _extrapolate2(firstIdx, _nextIdx(firstIdx))
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)])

      _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx])
    }

    for (var idx = firstIdx; idx <= lastIdx; ++idx) {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[idx])
    }

    if (nextIdx === _nextIdx(nextIdx)) {
      _extrapolate2(lastIdx, _prevIdx(lastIdx))
    } else {
      _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx])

      _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)])
    }

    return {
      centerPoints: centerPoints,
      topPoints: topPoints
    }
  }

  var CartoonHelper = /*#__PURE__*/ (function () {
    function CartoonHelper(
      residues,
      startIdx,
      endIdx,
      segmentsCount,
      tension,
      boundaries
    ) {
      _classCallCheck(this, CartoonHelper)

      var pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries)

      this._topInterp = _buildStructureInterpolator(
        pointsArrays.topPoints,
        tension
      )
      this._centerInterp = _buildStructureInterpolator(
        pointsArrays.centerPoints,
        tension
      )
      this._shift = 0.5 / (endIdx - startIdx + 2)
      this._valueStep =
        (1.0 - 2 * this._shift) /
        (2 * (endIdx - startIdx + 1) * (segmentsCount - 1))
      this._segmentsCount = segmentsCount
    }

    _createClass(CartoonHelper, [
      {
        key: 'prepareMatrices',
        value: function prepareMatrices(idx, firstRad, secondRad) {
          var mtcCount = this._segmentsCount
          var outMtc = new Array(mtcCount)
          var currRad = new THREE__namespace.Vector2(0, 0)
          var topInterp = this._topInterp
          var cenInterp = this._centerInterp
          var currentValue =
            this._shift + this._valueStep * (mtcCount - 1) * idx

          for (var mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
            var lerpVal = Math.min(1.0, mtxIdx / (mtcCount - 1))
            currRad.lerpVectors(firstRad, secondRad, lerpVal)
            var currTop = topInterp(currentValue, null)
            var currCenter = cenInterp(currentValue, null)
            currentValue += this._valueStep
            var nextCenter = cenInterp(currentValue, null)
            outMtc[mtxIdx] = calcMatrix(
              currCenter.clone(),
              nextCenter.clone(),
              currTop.clone().sub(currCenter),
              currRad
            )
          }

          return outMtc
        }
      }
    ])

    return CartoonHelper
  })()

  function _createSuper$1a(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1a()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1a() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function _createShape(rad, parts) {
    var pts = []

    for (var i = 0; i < parts; ++i) {
      var a = Math.PI / 2.0 - (2 * Math.PI * i) / parts
      pts.push(
        new THREE__namespace.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0)
      )
    }

    return pts
  }

  function _loopThrough(
    subDiv,
    residues,
    segmentsHeight,
    tension,
    mode,
    callback
  ) {
    for (
      var subDivI = 0, subDivN = subDiv.length;
      subDivI < subDivN;
      ++subDivI
    ) {
      var subs = subDiv[subDivI].arr
      var boundaries = subDiv[subDivI].boundaries

      for (var i = 0, n = subs.length; i < n; ++i) {
        var idc = [subs[i].start, subs[i].end]
        var matrixHelper = new CartoonHelper(
          residues,
          idc[0],
          idc[1],
          segmentsHeight,
          tension,
          boundaries
        )
        var prevLast = null
        var startIdx = subs[i].start * 2
        var endIdx = subs[i].end * 2 + 1
        var prevSecondRad = mode.getResidueRadius(residues[0], 0)

        for (var idx = startIdx; idx <= endIdx; ++idx) {
          var resIdx = (idx / 2) | 0
          var currRes = residues[resIdx]
          var firstRad = mode.getResidueRadius(currRes, idx % 2)
          var secondRad = mode.getResidueRadius(currRes, 1 + (idx % 2))
          var mtc = matrixHelper.prepareMatrices(
            idx - idc[0] * 2,
            firstRad,
            secondRad
          )
          mtc.unshift(prevLast === null ? mtc[0] : prevLast)
          var hasSlope =
            firstRad.x !== secondRad.x || firstRad.y !== secondRad.y
          var hasCut =
            firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y
          callback(currRes, mtc, hasSlope, hasCut)
          prevLast = mtc[segmentsHeight]
          prevSecondRad = secondRad
        }
      }
    }
  }

  var ResiduesSubseqGroup = /*#__PURE__*/ (function (_ResiduesGroup) {
    _inherits(ResiduesSubseqGroup, _ResiduesGroup)

    var _super = _createSuper$1a(ResiduesSubseqGroup)

    function ResiduesSubseqGroup() {
      _classCallCheck(this, ResiduesSubseqGroup)

      return _super.apply(this, arguments)
    }

    _createClass(ResiduesSubseqGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          var cmpMultiplier = this._mode.getHeightSegmentsRatio()

          this._segmentsHeight = (this._polyComplexity * cmpMultiplier) | 0
          return [
            _createShape(1.0, this._polyComplexity),
            this._segmentsHeight + 1,
            this._selection.chunks.length * 2
          ]
        }
      },
      {
        key: '_build',
        value: function _build() {
          var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var tension = mode.getTension()
          var geo = this._geo
          var chunkIdx = 0
          var chunkIdc = []

          _loopThrough(
            this._selection.subdivs,
            residues,
            this._segmentsHeight,
            tension,
            mode,
            function (currRes, mtc) {
              var hasSlope =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : false
              var hasCut =
                arguments.length > 3 && arguments[3] !== undefined
                  ? arguments[3]
                  : false
              var color = colorer.getResidueColor(currRes, parent)
              chunkIdc[chunkIdx] = currRes._index
              geo.setItem(chunkIdx, mtc, hasSlope, hasCut)
              geo.setColor(chunkIdx++, color)
            }
          )

          this._chunksIdc = chunkIdc
          geo.finalize()
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var parent = this._selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var tension = mode.getTension()
          var geo = this._geo
          var frameRes = frameData.getResidues()
          var chunkIdx = 0
          var updateColor = frameData.needsColorUpdate(colorer)

          _loopThrough(
            this._selection.subdivs,
            frameRes,
            this._segmentsHeight,
            tension,
            mode,
            function (currRes, mtc) {
              geo.setItem(chunkIdx, mtc)

              if (updateColor) {
                geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent))
              }

              chunkIdx++
            }
          )

          geo.finalize()
        }
      }
    ])

    return ResiduesSubseqGroup
  })(ResiduesGroup)

  function _createSuper$19(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$19()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$19() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ResiduesTraceGroup = /*#__PURE__*/ (function (_ChemGroup) {
    _inherits(ResiduesTraceGroup, _ChemGroup)

    var _super = _createSuper$19(ResiduesTraceGroup)

    function ResiduesTraceGroup() {
      _classCallCheck(this, ResiduesTraceGroup)

      return _super.apply(this, arguments)
    }

    _createClass(ResiduesTraceGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          var subDiv = this._selection.subdivs
          var chunksCount = 0

          for (
            var subDivI = 0, subDivN = subDiv.length;
            subDivI < subDivN;
            ++subDivI
          ) {
            var subs = subDiv[subDivI].arr

            for (var i = 0, n = subs.length; i < n; ++i) {
              chunksCount += subs[i].end - subs[i].start
            }
          }

          return [chunksCount, this._polyComplexity]
        }
      },
      {
        key: '_build',
        value: function _build() {
          var _this$_selection = this._selection,
            residues = _this$_selection.residues,
            parent = _this$_selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo
          var chunkIdx = 0
          var chunkIdc = []
          var subDiv = this._selection.subdivs
          var stickRad = mode.calcStickRadius()

          for (
            var subDivI = 0, subDivN = subDiv.length;
            subDivI < subDivN;
            ++subDivI
          ) {
            var subs = subDiv[subDivI].arr

            for (var i = 0, n = subs.length; i < n; ++i) {
              var startIdx = subs[i].start
              var endIdx = subs[i].end
              var prevRes = residues[startIdx]

              for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
                var currRes = residues[idx]
                chunkIdc[chunkIdx] = {
                  first: prevRes._index,
                  second: currRes._index
                }
                geo.setItem(
                  chunkIdx,
                  prevRes._controlPoint,
                  currRes._controlPoint,
                  stickRad
                )
                geo.setColor(
                  chunkIdx,
                  colorer.getResidueColor(prevRes, parent),
                  colorer.getResidueColor(currRes, parent)
                )
                chunkIdx++
                prevRes = currRes
              }
            }
          }

          this._chunksIdc = chunkIdc
          geo.finalize()
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var residues = frameData.getResidues()
          var parent = this._selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo
          var chunkIdx = 0
          var subDiv = this._selection.subdivs
          var stickRad = mode.calcStickRadius()
          var updateColor = frameData.needsColorUpdate(colorer)

          for (
            var subDivI = 0, subDivN = subDiv.length;
            subDivI < subDivN;
            ++subDivI
          ) {
            var subs = subDiv[subDivI].arr

            for (var i = 0, n = subs.length; i < n; ++i) {
              var startIdx = subs[i].start
              var endIdx = subs[i].end
              var prevRes = residues[startIdx]

              for (var idx = startIdx + 1; idx <= endIdx; ++idx) {
                var currRes = residues[idx]
                geo.setItem(
                  chunkIdx,
                  prevRes._controlPoint,
                  currRes._controlPoint,
                  stickRad
                )

                if (updateColor) {
                  geo.setColor(
                    chunkIdx,
                    colorer.getResidueColor(prevRes, parent),
                    colorer.getResidueColor(currRes, parent)
                  )
                }

                chunkIdx++
                prevRes = currRes
              }
            }
          }

          geo.finalize()
        }
      },
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var inters = []
          var residues = this._selection.residues

          this._mesh.raycast(raycaster, inters)

          var chunksToIdx = this._chunksIdc

          for (var i = 0, n = inters.length; i < n; ++i) {
            if (!inters[i].hasOwnProperty('chunkIdx')) {
              continue
            }

            var chunkIdx = inters[i].chunkIdx
            var chunk = chunksToIdx[Math.floor(chunkIdx / 2)]
            var resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second

            if (resIdx < residues.length) {
              inters[i].residue = residues[resIdx]
              intersects.push(inters[i])
            }
          }
        }
      },
      {
        key: '_calcChunksList',
        value: function _calcChunksList(mask) {
          var chunksList = []
          var chunksToIdx = this._chunksIdc
          var residues = this._selection.residues

          for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
            var chunk = chunksToIdx[i]

            if (residues[chunk.first]._mask & mask) {
              chunksList.push(i * 2)
            }

            if (residues[chunk.second]._mask & mask) {
              chunksList.push(i * 2 + 1)
            }
          }

          return chunksList
        }
      }
    ])

    return ResiduesTraceGroup
  })(ChemGroup)

  function _createSuper$18(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$18()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$18() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function getCylinderCount(bondOrder) {
    return bondOrder < 2 ? 1 : bondOrder
  }

  var BondsGroup = /*#__PURE__*/ (function (_ChemGroup) {
    _inherits(BondsGroup, _ChemGroup)

    var _super = _createSuper$18(BondsGroup)

    function BondsGroup() {
      _classCallCheck(this, BondsGroup)

      return _super.apply(this, arguments)
    }

    _createClass(BondsGroup, [
      {
        key: '_makeGeoArgs',
        value: function _makeGeoArgs() {
          var drawMultiple = this._mode.drawMultiorderBonds()

          var showAromatic = this._mode.showAromaticLoops()

          var bondsIdc = this._selection.chunks
          var bonds = this._selection.bonds
          var bondsCount = 0

          for (var i = 0, n = bondsIdc.length; i < n; ++i) {
            bondsCount += this.getBondOrder(
              bonds[bondsIdc[i]],
              drawMultiple,
              showAromatic
            )
          }

          return [bondsCount, this._polyComplexity]
        }
      },
      {
        key: 'getBondOrder',
        value: function getBondOrder(bond, drawMultiple, showAromatic) {
          var bondOrder = 1

          if (
            drawMultiple &&
            (!showAromatic || bond._type !== Bond$5.BondType.AROMATIC)
          ) {
            bondOrder = getCylinderCount(bond._order)
          }

          return bondOrder
        }
      },
      {
        key: 'raycast',
        value: function raycast(raycaster, intersects) {
          var bonds = this._selection.bonds
          var inters = []

          this._mesh.raycast(raycaster, inters)

          var bondsIdc = this._chunksIdc

          for (var i = 0, n = inters.length; i < n; ++i) {
            if (!inters[i].hasOwnProperty('chunkIdx')) {
              continue
            }

            var chunkIdx = inters[i].chunkIdx
            var bondIdx = bondsIdc[Math.floor(chunkIdx / 2)]

            if (bondIdx < bonds.length) {
              var bond = bonds[bondIdx]
              inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right
              intersects.push(inters[i])
            }
          }
        }
      },
      {
        key: '_calcChunksList',
        value: function _calcChunksList(mask, innerOnly) {
          var chunksList = []
          var bonds = this._selection.bonds
          var chunksToIdx = this._chunksIdc

          for (var i = 0, n = chunksToIdx.length; i < n; ++i) {
            var bond = bonds[chunksToIdx[i]]

            if (
              bond._left.mask & mask &&
              (!innerOnly || bond._right.mask & mask)
            ) {
              chunksList.push(2 * i)
            }

            if (
              bond._right.mask & mask &&
              (!innerOnly || bond._left.mask & mask)
            ) {
              chunksList.push(2 * i + 1)
            }
          }

          return chunksList
        }
      }
    ])

    return BondsGroup
  })(ChemGroup)

  function _createSuper$17(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$17()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$17() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var BondsCylinderGroup = /*#__PURE__*/ (function (_BondsGroup) {
    _inherits(BondsCylinderGroup, _BondsGroup)

    var _super = _createSuper$17(BondsCylinderGroup)

    function BondsCylinderGroup() {
      _classCallCheck(this, BondsCylinderGroup)

      return _super.apply(this, arguments)
    }

    _createClass(BondsCylinderGroup, [
      {
        key: '_build',
        value: function _build() {
          var bondsIdc = this._selection.chunks
          var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo
          var drawMultiple = mode.drawMultiorderBonds()
          var showAromatic = mode.showAromaticLoops()
          var stickRad = mode.calcStickRadius()
          var emptyOffset = mode.calcSpaceFraction()
          var normDir
          var leftPos = new THREE__namespace.Vector3()
          var rightPos = new THREE__namespace.Vector3()
          var currBondIdx = 0
          var chunksToIdx = []

          for (var i = 0, n = bondsIdc.length; i < n; ++i) {
            var bond = bonds[bondsIdc[i]]
            var atom1 = bond._left
            var atom2 = bond._right
            var a1Pos = atom1.position
            var a2Pos = atom2.position
            normDir = bond.calcNormalDir()
            var order = this.getBondOrder(bond, drawMultiple, showAromatic)
            var minRad = Math.min(
              mode.calcAtomRadius(atom1),
              mode.calcAtomRadius(atom2)
            )
            var dist = (2 * minRad) / order
            var currStickRad = drawMultiple
              ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset))
              : stickRad

            for (var j = 0; j < order; ++j) {
              var scale =
                dist *
                (order % 2 === 0
                  ? (((j / 2) | 0) + 0.5) * (1 - 2 * (j % 2))
                  : (((j + 1) / 2) | 0) * (-1 + 2 * (j % 2)))
              chunksToIdx[currBondIdx] = bond._index
              leftPos.copy(a1Pos)
              leftPos.addScaledVector(normDir, scale)
              rightPos.copy(a2Pos)
              rightPos.addScaledVector(normDir, scale)
              geo.setItem(currBondIdx, leftPos, rightPos, currStickRad)
              geo.setColor(
                currBondIdx++,
                colorer.getAtomColor(atom1, parent),
                colorer.getAtomColor(atom2, parent)
              )
            }
          }

          geo.finalize()
          this._chunksIdc = chunksToIdx
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var bondsIdc = this._selection.chunks
          var bonds = this._selection.bonds
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo
          var drawMultiple = mode.drawMultiorderBonds()
          var showAromatic = mode.showAromaticLoops()
          var stickRad = mode.calcStickRadius()
          var emptyOffset = mode.calcSpaceFraction()
          var normDir
          var leftPos = new THREE__namespace.Vector3()
          var rightPos = new THREE__namespace.Vector3()
          var currBondIdx = 0
          var updateColor = frameData.needsColorUpdate(colorer)

          for (var i = 0, n = bondsIdc.length; i < n; ++i) {
            var bond = bonds[bondsIdc[i]]
            var atom1 = bond._left
            var atom2 = bond._right
            var a1Pos = frameData.getAtomPos(atom1.index).clone()
            var a2Pos = frameData.getAtomPos(atom2.index)
            normDir = bond.calcNormalDir()
            var order = this.getBondOrder(bond, drawMultiple, showAromatic)
            var minRad = Math.min(
              mode.calcAtomRadius(atom1),
              mode.calcAtomRadius(atom2)
            )
            var dist = (2 * minRad) / order
            var currStickRad = drawMultiple
              ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset))
              : stickRad

            for (var j = 0; j < order; ++j) {
              var scale =
                dist *
                (order % 2 === 0
                  ? (((j / 2) | 0) + 0.5) * (1 - 2 * (j % 2))
                  : (((j + 1) / 2) | 0) * (-1 + 2 * (j % 2)))
              leftPos.copy(a1Pos)
              leftPos.addScaledVector(normDir, scale)
              rightPos.copy(a2Pos)
              rightPos.addScaledVector(normDir, scale)
              geo.setItem(currBondIdx, leftPos, rightPos, currStickRad)

              if (updateColor) {
                geo.setColor(
                  currBondIdx,
                  frameData.getAtomColor(colorer, atom1),
                  frameData.getAtomColor(colorer, atom2)
                )
              }

              currBondIdx++
            }
          }

          geo.finalize()
        }
      }
    ])

    return BondsCylinderGroup
  })(BondsGroup)

  function _createSuper$16(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$16()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$16() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var STEP_SIZE = 0.15

  var BondsLinesGroup = /*#__PURE__*/ (function (_BondsGroup) {
    _inherits(BondsLinesGroup, _BondsGroup)

    var _super = _createSuper$16(BondsLinesGroup)

    function BondsLinesGroup() {
      _classCallCheck(this, BondsLinesGroup)

      return _super.apply(this, arguments)
    }

    _createClass(BondsLinesGroup, [
      {
        key: '_build',
        value: function _build() {
          var bondsIdc = this._selection.chunks
          var _this$_selection = this._selection,
            bonds = _this$_selection.bonds,
            parent = _this$_selection.parent
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo
          var drawMultiple = mode.drawMultiorderBonds()
          var showAromatic = mode.showAromaticLoops()
          var bondDir = new THREE__namespace.Vector3()
          var leftPos = new THREE__namespace.Vector3()
          var rightPos = new THREE__namespace.Vector3()
          var currBondIdx = 0
          var chunksToIdx = []

          for (var i = 0, n = bondsIdc.length; i < n; ++i) {
            var bond = bonds[bondsIdc[i]]
            var atom1 = bond._left
            var atom2 = bond._right
            var a1Pos = atom1.position
            var a2Pos = atom2.position
            var a1Hangs = atom1.bonds.length === 1
            var a2Hangs = atom2.bonds.length === 1
            bondDir.subVectors(a2Pos, a1Pos)
            var len = bondDir.length()
            var normDir = bond.calcNormalDir()
            var order = this.getBondOrder(bond, drawMultiple, showAromatic)

            for (var j = 0; j < order; ++j) {
              leftPos.copy(a1Pos)
              rightPos.copy(a2Pos)
              var scale =
                order % 2 === 0
                  ? (((j / 2) | 0) + 0.5) * (1 - 2 * (j % 2))
                  : (((j + 1) / 2) | 0) * (-1 + 2 * (j % 2))
              chunksToIdx[currBondIdx] = bond._index

              if (order === 2 && !a1Hangs && !a2Hangs) {
                scale -= 0.5
                scale *= -1
              }

              if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
                leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len)
                rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len)
              }

              scale *= STEP_SIZE
              leftPos.addScaledVector(normDir, scale)
              rightPos.addScaledVector(normDir, scale)
              geo.setItem(currBondIdx, leftPos, rightPos)
              geo.setColor(
                currBondIdx++,
                colorer.getAtomColor(atom1, parent),
                colorer.getAtomColor(atom2, parent)
              )
            }
          }

          geo.finalize()
          this._chunksIdc = chunksToIdx
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          var bondsIdc = this._selection.chunks
          var bonds = this._selection.bonds
          var mode = this._mode
          var colorer = this._colorer
          var geo = this._geo
          var drawMultiple = mode.drawMultiorderBonds()
          var showAromatic = mode.showAromaticLoops()
          var bondDir = new THREE__namespace.Vector3()
          var leftPos = new THREE__namespace.Vector3()
          var rightPos = new THREE__namespace.Vector3()
          var currBondIdx = 0
          var updateColor = frameData.needsColorUpdate(colorer)

          for (var i = 0, n = bondsIdc.length; i < n; ++i) {
            var bond = bonds[bondsIdc[i]]
            var atom1 = bond._left
            var atom2 = bond._right
            var a1Pos = frameData.getAtomPos(atom1.index).clone()
            var a2Pos = frameData.getAtomPos(atom2.index)
            var a1Hangs = atom1.bonds.length === 1
            var a2Hangs = atom2.bonds.length === 1
            bondDir.subVectors(a2Pos, a1Pos)
            var len = bondDir.length()
            var normDir = bond.calcNormalDir()
            var order = this.getBondOrder(bond, drawMultiple, showAromatic)

            for (var j = 0; j < order; ++j) {
              leftPos.copy(a1Pos)
              rightPos.copy(a2Pos)
              var scale =
                order % 2 === 0
                  ? (((j / 2) | 0) + 0.5) * (1 - 2 * (j % 2))
                  : (((j + 1) / 2) | 0) * (-1 + 2 * (j % 2))

              if (order === 2 && !a1Hangs && !a2Hangs) {
                scale -= 0.5
                scale *= -1
              }

              if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
                leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len)
                rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len)
              }

              scale *= STEP_SIZE
              leftPos.addScaledVector(normDir, scale)
              rightPos.addScaledVector(normDir, scale)
              geo.setItem(currBondIdx, leftPos, rightPos)

              if (updateColor) {
                geo.setColor(
                  currBondIdx,
                  frameData.getAtomColor(colorer, atom1),
                  frameData.getAtomColor(colorer, atom2)
                )
              }

              currBondIdx++
            }
          }

          geo.finalize()
        }
      }
    ])

    return BondsLinesGroup
  })(BondsGroup)

  var groups = {
    AtomsSphereGroup: AtomsSphereGroup,
    AtomsSurfaceGroup: AtomsSurfaceGroup,
    AtomsSASSESGroupStub: AtomsSASSESGroupStub,
    AtomsTextGroup: AtomsTextGroup,
    AromaticTorusGroup: AromaticTorusGroup,
    AromaticLinesGroup: AromaticLinesGroup,
    NucleicCylindersGroup: NucleicCylindersGroup,
    NucleicSpheresGroup: NucleicSpheresGroup,
    ResiduesSubseqGroup: ResiduesSubseqGroup,
    ResiduesTraceGroup: ResiduesTraceGroup,
    BondsCylinderGroup: BondsCylinderGroup,
    BondsLinesGroup: BondsLinesGroup
  }

  function _createSuper$15(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$15()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$15() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AtomsProcessor = /*#__PURE__*/ (function (_RCGroup) {
    _inherits(AtomsProcessor, _RCGroup)

    var _super = _createSuper$15(AtomsProcessor)

    function AtomsProcessor(
      AtomsGroup,
      geoParams,
      complex,
      colorer,
      mode,
      polyComplexity,
      mask,
      material
    ) {
      var _this

      _classCallCheck(this, AtomsProcessor)

      _this = _super.call(this)

      var self = _assertThisInitialized(_this)

      _this._complex = complex
      _this._mode = mode
      var atoms = complex.getAtoms()
      var transforms = complex.getTransforms()
      complex.forEachComponent(function (component) {
        var atomsIdc = []
        var atomCount = 0
        component.forEachAtom(function (atom) {
          if (!self._checkAtom(atom, mask)) {
            return
          }

          atomsIdc[atomCount++] = atom.index
        })

        if (atomCount === 0) {
          return
        }

        var atomsGroup = new AtomsGroup(
          geoParams,
          {
            atoms: atoms,
            chunks: atomsIdc,
            parent: complex
          },
          colorer,
          mode,
          transforms,
          polyComplexity,
          material
        )
        atomsGroup._component = component
        self.add(atomsGroup)
      })
      return _this
    }

    _createClass(AtomsProcessor, [
      {
        key: '_checkAtom',
        value: function _checkAtom(atom, mask) {
          return atom.mask & mask
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          var totalSubset = []
          var children = this.children
          var meshIdx = 0

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].getSubset) {
              var chSubset = children[i].getSubset(mask, innerOnly)

              for (var j = 0, m = chSubset.length; j < m; ++j) {
                var subsetEl = chSubset[j]
                subsetEl._component = children[i]._component
                totalSubset[meshIdx++] = subsetEl
              }
            }
          }

          return totalSubset
        }
      }
    ])

    return AtomsProcessor
  })(RCGroup)

  function _createSuper$14(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$14()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$14() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var OrphanAtomsProcessor = /*#__PURE__*/ (function (_AtomsProcessor) {
    _inherits(OrphanAtomsProcessor, _AtomsProcessor)

    var _super = _createSuper$14(OrphanAtomsProcessor)

    function OrphanAtomsProcessor() {
      _classCallCheck(this, OrphanAtomsProcessor)

      return _super.apply(this, arguments)
    }

    _createClass(OrphanAtomsProcessor, [
      {
        key: '_checkAtom',
        value: function _checkAtom(atom, mask) {
          if (!(atom.mask & mask)) {
            return false
          }

          var bonds = atom.bonds

          for (var i = 0, n = bonds.length; i < n; ++i) {
            if (bonds[i]._left.mask & mask && bonds[i]._right.mask & mask) {
              return false
            }
          }

          return true
        }
      }
    ])

    return OrphanAtomsProcessor
  })(AtomsProcessor)

  function _createSuper$13(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$13()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$13() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ResiduesProcessor = /*#__PURE__*/ (function (_RCGroup) {
    _inherits(ResiduesProcessor, _RCGroup)

    var _super = _createSuper$13(ResiduesProcessor)

    function ResiduesProcessor(
      ResidueGroup,
      geoParams,
      complex,
      colorer,
      mode,
      polyComplexity,
      mask,
      material
    ) {
      var _this

      _classCallCheck(this, ResiduesProcessor)

      _this = _super.call(this)

      var self = _assertThisInitialized(_this)

      _this._complex = complex
      var residues = complex.getResidues()
      var transforms = complex.getTransforms()
      complex.forEachComponent(function (component) {
        var chunksCount = 0
        var resIdc = []
        component.forEachResidue(function (residue) {
          if (self._checkResidue(residue, mask)) {
            resIdc[chunksCount++] = residue._index
          }
        })

        if (chunksCount === 0) {
          return
        }

        var residuesGroup = new ResidueGroup(
          geoParams,
          {
            residues: residues,
            chunks: resIdc,
            parent: complex
          },
          colorer,
          mode,
          transforms,
          polyComplexity,
          material
        )
        residuesGroup._component = component
        self.add(residuesGroup)
      })
      return _this
    }

    _createClass(ResiduesProcessor, [
      {
        key: 'checkResidue',
        value: function checkResidue(residue, mask) {
          return residue._mask & mask
        }
      },
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          var totalSubset = []
          var children = this.children
          var meshIdx = 0

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].getSubset) {
              var chSubset = children[i].getSubset(mask, innerOnly)

              for (var j = 0, m = chSubset.length; j < m; ++j) {
                var subsetEl = chSubset[j]
                subsetEl._component = children[i]._component
                totalSubset[meshIdx++] = subsetEl
              }
            }
          }

          return totalSubset
        }
      }
    ])

    return ResiduesProcessor
  })(RCGroup)

  function _createSuper$12(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$12()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$12() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var NucleicProcessor = /*#__PURE__*/ (function (_ResidueProcessor) {
    _inherits(NucleicProcessor, _ResidueProcessor)

    var _super = _createSuper$12(NucleicProcessor)

    function NucleicProcessor() {
      _classCallCheck(this, NucleicProcessor)

      return _super.apply(this, arguments)
    }

    _createClass(NucleicProcessor, [
      {
        key: '_checkResidue',
        value: function _checkResidue(residue, mask) {
          return mask & residue._mask && residue._cylinders !== null
        }
      }
    ])

    return NucleicProcessor
  })(ResiduesProcessor)

  function _createSuper$11(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$11()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$11() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var SubseqsProcessor = /*#__PURE__*/ (function (_RCGroup) {
    _inherits(SubseqsProcessor, _RCGroup)

    var _super = _createSuper$11(SubseqsProcessor)

    function SubseqsProcessor(
      ResidueGroup,
      geoParams,
      complex,
      colorer,
      mode,
      polyComplexity,
      mask,
      material
    ) {
      var _this

      _classCallCheck(this, SubseqsProcessor)

      _this = _super.call(this)

      var self = _assertThisInitialized(_this)

      _this._complex = complex
      var residues = complex.getResidues()
      var transforms = complex.getTransforms()
      complex.forEachComponent(function (component) {
        var subDivs = component.getMaskedSubdivSequences(mask)
        var chunksCount = 0
        var resIdc = []

        for (
          var subDivI = 0, subDivN = subDivs.length;
          subDivI < subDivN;
          ++subDivI
        ) {
          var subs = subDivs[subDivI].arr

          for (var i = 0, n = subs.length; i < n; ++i) {
            for (var j = subs[i].start, jEnd = subs[i].end; j <= jEnd; ++j) {
              resIdc[chunksCount++] = residues[j]._index
            }
          }
        }

        if (chunksCount === 0) {
          return
        }

        var residuesGroup = new ResidueGroup(
          geoParams,
          {
            residues: residues,
            chunks: resIdc,
            subdivs: subDivs,
            parent: complex
          },
          colorer,
          mode,
          transforms,
          polyComplexity,
          material
        )
        residuesGroup._component = component
        self.add(residuesGroup)
      })
      return _this
    }

    _createClass(SubseqsProcessor, [
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          var totalSubset = []
          var children = this.children
          var meshIdx = 0

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].getSubset) {
              var chSubset = children[i].getSubset(mask, innerOnly)

              for (var j = 0, m = chSubset.length; j < m; ++j) {
                var subsetEl = chSubset[j]
                subsetEl._component = children[i]._component
                totalSubset[meshIdx++] = subsetEl
              }
            }
          }

          return totalSubset
        }
      }
    ])

    return SubseqsProcessor
  })(RCGroup)

  function _createSuper$10(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$10()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$10() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var BondsProcessor = /*#__PURE__*/ (function (_RCGroup) {
    _inherits(BondsProcessor, _RCGroup)

    var _super = _createSuper$10(BondsProcessor)

    function BondsProcessor(
      BondsGroup,
      geoParams,
      complex,
      colorer,
      mode,
      polyComplexity,
      mask,
      material
    ) {
      var _this

      _classCallCheck(this, BondsProcessor)

      _this = _super.call(this)

      var self = _assertThisInitialized(_this)

      _this._complex = complex
      var bonds = complex.getBonds()
      var transforms = complex.getTransforms()
      complex.forEachComponent(function (component) {
        var bondsIdc = []
        var bondsCount = 0
        component.forEachBond(function (bond) {
          var atom1 = bond._left
          var atom2 = bond._right

          if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
            return
          }

          bondsIdc[bondsCount++] = bond._index
        })

        if (bondsCount === 0) {
          return
        }

        var bondsGroup = new BondsGroup(
          geoParams,
          {
            bonds: bonds,
            chunks: bondsIdc,
            parent: complex
          },
          colorer,
          mode,
          transforms,
          polyComplexity,
          material
        )
        bondsGroup._component = component
        self.add(bondsGroup)
      })
      return _this
    }

    _createClass(BondsProcessor, [
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          var totalSubset = []
          var children = this.children
          var meshIdx = 0

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].getSubset) {
              var chSubset = children[i].getSubset(mask, innerOnly)

              for (var j = 0, m = chSubset.length; j < m; ++j) {
                var subsetEl = chSubset[j]
                subsetEl._component = children[i]._component
                totalSubset[meshIdx++] = subsetEl
              }
            }
          }

          return totalSubset
        }
      }
    ])

    return BondsProcessor
  })(RCGroup)

  function _createSuper$$(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$$()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$$() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AromaticProcessor = /*#__PURE__*/ (function (_RCGroup) {
    _inherits(AromaticProcessor, _RCGroup)

    var _super = _createSuper$$(AromaticProcessor)

    function AromaticProcessor(
      AromaticGroup,
      geoParams,
      complex,
      colorer,
      mode,
      polyComplexity,
      mask,
      material
    ) {
      var _this

      _classCallCheck(this, AromaticProcessor)

      _this = _super.call(this)

      var self = _assertThisInitialized(_this)

      _this._complex = complex
      var atoms = complex.getAtoms()
      var transforms = complex.getTransforms()

      if (!mode.showAromaticLoops()) {
        return _possibleConstructorReturn(_this)
      }

      complex.forEachComponent(function (component) {
        var atomsIdc = []
        var chunksCount = 0
        var cycles = []
        var cycleIdx = 0
        component.forEachCycle(function (cycle) {
          var cycAtoms = cycle.atoms
          var perCycle = 0

          for (var i = 0, n = cycAtoms.length; i < n; ++i) {
            if ((cycAtoms[i].mask & mask) !== 0) {
              ++perCycle
              atomsIdc[chunksCount++] = cycAtoms[i].index
            }
          }

          if (perCycle > 0) {
            cycles[cycleIdx++] = cycle
          }
        })
        var atomsGroup = new AromaticGroup(
          geoParams,
          {
            cycles: cycles,
            atoms: atoms,
            chunks: atomsIdc,
            parent: complex
          },
          colorer,
          mode,
          transforms,
          polyComplexity,
          material
        )
        atomsGroup._component = component
        self.add(atomsGroup)
      })
      return _this
    }

    _createClass(AromaticProcessor, [
      {
        key: 'getSubset',
        value: function getSubset(mask, innerOnly) {
          var totalSubset = []
          var children = this.children
          var meshIdx = 0

          for (var i = 0, n = children.length; i < n; ++i) {
            if (children[i].getSubset) {
              var chSubset = children[i].getSubset(mask, innerOnly)

              for (var j = 0, m = chSubset.length; j < m; ++j) {
                var subsetEl = chSubset[j]
                subsetEl._component = children[i]._component
                totalSubset[meshIdx++] = subsetEl
              }
            }
          }

          return totalSubset
        }
      }
    ])

    return AromaticProcessor
  })(RCGroup)

  var processors = {
    Atoms: AtomsProcessor,
    OrphanAtoms: OrphanAtomsProcessor,
    Residues: ResiduesProcessor,
    Nucleic: NucleicProcessor,
    Subseqs: SubseqsProcessor,
    Bonds: BondsProcessor,
    Aromatic: AromaticProcessor
  }

  function _bakeGroup(triplet, Processor, Group) {
    return function (complex, colorer, mode, polyComplexity, mask, material) {
      return new Processor(
        Group,
        triplet,
        complex,
        colorer,
        mode,
        polyComplexity,
        mask,
        material
      )
    }
  }

  var GroupsFactory = /*#__PURE__*/ (function () {
    function GroupsFactory() {
      _classCallCheck(this, GroupsFactory)
    }

    _createClass(GroupsFactory, null, [
      {
        key: 'AtomsSpheres',
        value: function AtomsSpheres(caps, settings) {
          var gfxTriplet = MeshCreator.createSpheres(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Atoms,
            groups.AtomsSphereGroup
          )
        }
      },
      {
        key: 'OrphanedAtomsCrosses',
        value: function OrphanedAtomsCrosses(caps, settings, renderParams) {
          var gfxTriplet = MeshCreator.createCrosses(
            caps,
            settings,
            renderParams
          )
          return _bakeGroup(
            gfxTriplet,
            processors.OrphanAtoms,
            groups.AtomsSphereGroup
          )
        }
      },
      {
        key: 'BondsCylinders',
        value: function BondsCylinders(caps, settings) {
          var gfxTriplet = MeshCreator.create2CCylinders(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Bonds,
            groups.BondsCylinderGroup
          )
        }
      },
      {
        key: 'BondsLines',
        value: function BondsLines(caps, settings, renderParams) {
          var gfxTriplet = MeshCreator.create2CLines(
            caps,
            settings,
            renderParams
          )
          return _bakeGroup(
            gfxTriplet,
            processors.Bonds,
            groups.BondsLinesGroup
          )
        }
      },
      {
        key: 'CartoonChains',
        value: function CartoonChains(caps, settings) {
          var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Subseqs,
            groups.ResiduesSubseqGroup
          )
        }
      },
      {
        key: 'TraceChains',
        value: function TraceChains(caps, settings) {
          var gfxTriplet = MeshCreator.create2CClosedCylinders(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Subseqs,
            groups.ResiduesTraceGroup
          )
        }
      },
      {
        key: 'NucleicSpheres',
        value: function NucleicSpheres(caps, settings) {
          var gfxTriplet = MeshCreator.createSpheres(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Nucleic,
            groups.NucleicSpheresGroup
          )
        }
      },
      {
        key: 'NucleicCylinders',
        value: function NucleicCylinders(caps, settings) {
          var gfxTriplet = MeshCreator.create2CCylinders(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Nucleic,
            groups.NucleicCylindersGroup
          )
        }
      },
      {
        key: 'ALoopsTorus',
        value: function ALoopsTorus(caps, settings) {
          var gfxTriplet = MeshCreator.createExtrudedChains(caps, settings)
          return _bakeGroup(
            gfxTriplet,
            processors.Aromatic,
            groups.AromaticTorusGroup
          )
        }
      },
      {
        key: 'ALoopsLines',
        value: function ALoopsLines(caps, settings, renderParams) {
          var gfxTriplet = MeshCreator.createChunkedLines(
            caps,
            settings,
            renderParams
          )
          return _bakeGroup(
            gfxTriplet,
            processors.Aromatic,
            groups.AromaticLinesGroup
          )
        }
      },
      {
        key: 'QuickSurfGeo',
        value: function QuickSurfGeo(caps, settings, renderParams) {
          var gfxTriplet = MeshCreator.createQuickSurface(
            caps,
            settings,
            renderParams
          )
          return _bakeGroup(
            gfxTriplet,
            processors.Atoms,
            groups.AtomsSurfaceGroup
          )
        }
      },
      {
        key: 'ContactSurfaceGeo',
        value: function ContactSurfaceGeo(caps, settings, renderParams) {
          var gfxTriplet = MeshCreator.createContactSurface(
            caps,
            settings,
            renderParams
          )
          return _bakeGroup(
            gfxTriplet,
            processors.Atoms,
            groups.AtomsSurfaceGroup
          )
        }
      },
      {
        key: 'SASSESSurfaceGeo',
        value: function SASSESSurfaceGeo(caps, settings, renderParams) {
          var gfxTriplet = MeshCreator.createSASSES(
            caps,
            settings,
            renderParams
          )
          return _bakeGroup(
            gfxTriplet,
            processors.Atoms,
            groups.AtomsSASSESGroupStub
          )
        }
      },
      {
        key: 'TextLabelsGeo',
        value: function TextLabelsGeo(caps, settings) {
          var gfxTriplet = MeshCreator.createLabels(caps, settings)
          return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup)
        }
      }
    ])

    return GroupsFactory
  })()

  var Mode = /*#__PURE__*/ (function () {
    function Mode(opts) {
      _classCallCheck(this, Mode)

      if (this.constructor === Mode) {
        throw new Error('Can not instantiate abstract class!')
      }

      this.opts = ___default['default'].merge(
        utils.deriveDeep(this.settings.now.modes[this.id], true),
        opts
      )
    }

    _createClass(Mode, [
      {
        key: 'identify',
        value: function identify() {
          var diff = utils.objectsDiff(
            this.opts,
            this.settings.now.modes[this.id]
          )

          if (!___default['default'].isEmpty(diff)) {
            return [this.id, diff]
          }

          return this.id
        }
      },
      {
        key: 'buildGeometry',
        value: function buildGeometry(complex, colorer, mask, material) {
          var polyComplexity = this.opts.polyComplexity
            ? this.opts.polyComplexity[this.settings.now.resolution]
            : 0
          var groupList = this.depGroups
          var groupCount = groupList.length
          var group = new gfxutils.RCGroup()
          var self = this

          for (var i = 0; i < groupCount; ++i) {
            var currGroup = groupList[i]
            var renderParams = {}

            if (___default['default'].isArray(currGroup)) {
              renderParams = currGroup[1].call(this)
              var _currGroup = currGroup

              var _currGroup2 = _slicedToArray(_currGroup, 1)

              currGroup = _currGroup2[0]
            }

            var Group = GroupsFactory[currGroup](
              null,
              this.settings,
              renderParams
            )
            var newGroup = new Group(
              complex,
              colorer,
              self,
              polyComplexity,
              mask,
              material
            )

            if (newGroup.children.length > 0) {
              group.add(newGroup)
            }
          }

          return group
        }
      }
    ])

    return Mode
  })()

  makeContextDependent(Mode.prototype)
  Mode.prototype.id = '__'
  Mode.prototype.depGroups = []

  function _createSuper$_(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$_()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$_() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function getRenderParams$1() {
    return {
      lineWidth: this.opts.lineWidth
    }
  }

  var LinesMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(LinesMode, _Mode)

    var _super = _createSuper$_(LinesMode)

    function LinesMode(opts) {
      var _this

      _classCallCheck(this, LinesMode)

      _this = _super.call(this, opts)
      _this.depGroups = _this.depGroups.slice(0)
      var groups = _this.depGroups

      for (var i = 0, n = groups.length; i < n; ++i) {
        groups[i] = [groups[i], getRenderParams$1]
      }

      return _this
    }

    _createClass(LinesMode, [
      {
        key: 'drawMultiorderBonds',
        value: function drawMultiorderBonds() {
          return this.opts.multibond
        }
      },
      {
        key: 'calcAtomRadius',
        value: function calcAtomRadius() {
          return this.opts.atom
        }
      },
      {
        key: 'getAromaticOffset',
        value: function getAromaticOffset() {
          return this.opts.offsarom
        }
      },
      {
        key: 'getAromaticArcChunks',
        value: function getAromaticArcChunks() {
          return this.opts.chunkarom
        }
      },
      {
        key: 'showAromaticLoops',
        value: function showAromaticLoops() {
          return this.opts.showarom
        }
      }
    ])

    return LinesMode
  })(Mode)

  _defineProperty(LinesMode, 'id', 'LN')

  LinesMode.prototype.id = 'LN'
  LinesMode.prototype.name = 'Lines'
  LinesMode.prototype.shortName = 'Lines'
  LinesMode.prototype.depGroups = [
    'ALoopsLines',
    'BondsLines',
    'OrphanedAtomsCrosses'
  ]

  function _createSuper$Z(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$Z()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$Z() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var LicoriceMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(LicoriceMode, _Mode)

    var _super = _createSuper$Z(LicoriceMode)

    function LicoriceMode() {
      _classCallCheck(this, LicoriceMode)

      return _super.apply(this, arguments)
    }

    _createClass(LicoriceMode, [
      {
        key: 'calcAtomRadius',
        value: function calcAtomRadius(_atom) {
          return this.opts.bond
        }
      },
      {
        key: 'calcStickRadius',
        value: function calcStickRadius() {
          return this.opts.bond
        }
      },
      {
        key: 'calcSpaceFraction',
        value: function calcSpaceFraction() {
          return this.opts.space
        }
      },
      {
        key: 'getAromRadius',
        value: function getAromRadius() {
          return this.opts.aromrad
        }
      },
      {
        key: 'showAromaticLoops',
        value: function showAromaticLoops() {
          return this.opts.showarom
        }
      },
      {
        key: 'drawMultiorderBonds',
        value: function drawMultiorderBonds() {
          return this.opts.multibond
        }
      }
    ])

    return LicoriceMode
  })(Mode)

  _defineProperty(LicoriceMode, 'id', 'LC')

  LicoriceMode.prototype.id = 'LC'
  LicoriceMode.prototype.name = 'Licorice'
  LicoriceMode.prototype.shortName = 'Licorice'
  LicoriceMode.prototype.depGroups = [
    'AtomsSpheres',
    'BondsCylinders',
    'ALoopsTorus'
  ]

  function _createSuper$Y(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$Y()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$Y() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var BallsAndSticksMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(BallsAndSticksMode, _Mode)

    var _super = _createSuper$Y(BallsAndSticksMode)

    function BallsAndSticksMode() {
      _classCallCheck(this, BallsAndSticksMode)

      return _super.apply(this, arguments)
    }

    _createClass(BallsAndSticksMode, [
      {
        key: 'calcAtomRadius',
        value: function calcAtomRadius(atom) {
          return atom.element.radius * this.opts.atom
        }
      },
      {
        key: 'calcStickRadius',
        value: function calcStickRadius() {
          return this.opts.bond
        }
      },
      {
        key: 'getAromRadius',
        value: function getAromRadius() {
          return this.opts.aromrad
        }
      },
      {
        key: 'showAromaticLoops',
        value: function showAromaticLoops() {
          return this.opts.showarom
        }
      },
      {
        key: 'calcSpaceFraction',
        value: function calcSpaceFraction() {
          return this.opts.space
        }
      },
      {
        key: 'drawMultiorderBonds',
        value: function drawMultiorderBonds() {
          return this.opts.multibond
        }
      }
    ])

    return BallsAndSticksMode
  })(Mode)

  _defineProperty(BallsAndSticksMode, 'id', 'BS')

  BallsAndSticksMode.prototype.id = 'BS'
  BallsAndSticksMode.prototype.name = 'Balls and Sticks'
  BallsAndSticksMode.prototype.shortName = 'Balls'
  BallsAndSticksMode.prototype.depGroups = [
    'AtomsSpheres',
    'BondsCylinders',
    'ALoopsTorus'
  ]

  function _createSuper$X(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$X()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$X() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var VanDerWaalsMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(VanDerWaalsMode, _Mode)

    var _super = _createSuper$X(VanDerWaalsMode)

    function VanDerWaalsMode() {
      _classCallCheck(this, VanDerWaalsMode)

      return _super.apply(this, arguments)
    }

    _createClass(VanDerWaalsMode, [
      {
        key: 'calcAtomRadius',
        value: function calcAtomRadius(atom) {
          return atom.element.radius
        }
      }
    ])

    return VanDerWaalsMode
  })(Mode)

  _defineProperty(VanDerWaalsMode, 'id', 'VW')

  VanDerWaalsMode.prototype.id = 'VW'
  VanDerWaalsMode.prototype.name = 'Van der Waals'
  VanDerWaalsMode.prototype.shortName = 'VDW'
  VanDerWaalsMode.prototype.depGroups = ['AtomsSpheres']

  function _createSuper$W(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$W()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$W() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var TraceMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(TraceMode, _Mode)

    var _super = _createSuper$W(TraceMode)

    function TraceMode() {
      _classCallCheck(this, TraceMode)

      return _super.apply(this, arguments)
    }

    _createClass(TraceMode, [
      {
        key: 'calcStickRadius',
        value: function calcStickRadius() {
          return this.opts.radius
        }
      }
    ])

    return TraceMode
  })(Mode)

  _defineProperty(TraceMode, 'id', 'TR')

  TraceMode.prototype.id = 'TR'
  TraceMode.prototype.name = 'Trace'
  TraceMode.prototype.shortName = 'Trace'
  TraceMode.prototype.depGroups = ['TraceChains']

  function _createSuper$V(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$V()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$V() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var TubeMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(TubeMode, _Mode)

    var _super = _createSuper$V(TubeMode)

    function TubeMode() {
      _classCallCheck(this, TubeMode)

      return _super.apply(this, arguments)
    }

    _createClass(TubeMode, [
      {
        key: 'getResidueRadius',
        value: function getResidueRadius(_residue) {
          return this.TUBE_RADIUS
        }
      },
      {
        key: 'getHeightSegmentsRatio',
        value: function getHeightSegmentsRatio() {
          return this.opts.heightSegmentsRatio
        }
      },
      {
        key: 'getTension',
        value: function getTension() {
          return this.opts.tension
        }
      },
      {
        key: 'buildGeometry',
        value: function buildGeometry(complex, colorer, mask, material) {
          var rad = this.opts.radius
          this.TUBE_RADIUS = new THREE__namespace.Vector2(rad, rad)
          return Mode.prototype.buildGeometry.call(
            this,
            complex,
            colorer,
            mask,
            material
          )
        }
      }
    ])

    return TubeMode
  })(Mode)

  _defineProperty(TubeMode, 'id', 'TU')

  TubeMode.prototype.id = 'TU'
  TubeMode.prototype.name = 'Tube'
  TubeMode.prototype.shortName = 'Tube'
  TubeMode.prototype.depGroups = ['CartoonChains']

  function _createSuper$U(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$U()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$U() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var CartoonMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(CartoonMode, _Mode)

    var _super = _createSuper$U(CartoonMode)

    function CartoonMode(opts) {
      var _this

      _classCallCheck(this, CartoonMode)

      _this = _super.call(this, opts)
      _this.secCache = {}
      return _this
    }

    _createClass(CartoonMode, [
      {
        key: 'getResidueStartRadius',
        value: function getResidueStartRadius(residue) {
          var second = residue.getSecondary()

          if (!second || !second.generic) {
            return this.TUBE_RADIUS
          }

          var secOpts = this.secCache[second.generic]

          if (!secOpts) {
            return this.TUBE_RADIUS
          }

          if (second.term === residue) {
            return secOpts.start
          }

          return secOpts.center
        }
      },
      {
        key: 'getResidueEndRadius',
        value: function getResidueEndRadius(residue) {
          var second = residue.getSecondary()

          if (second === null || !second.generic) {
            return this.TUBE_RADIUS
          }

          var secOpts = this.secCache[second.generic]

          if (!secOpts) {
            return this.TUBE_RADIUS
          }

          if (second.term === residue) {
            return this.ARROW_END
          }

          return secOpts.center
        }
      },
      {
        key: 'getResidueRadius',
        value: function getResidueRadius(residue, val) {
          var startRad = this.getResidueStartRadius(residue)

          if (val === 0) {
            return startRad
          }

          var endRad = this.getResidueEndRadius(residue)

          if (val === 2) {
            return endRad
          }

          return startRad.clone().lerp(endRad, val / 2.0)
        }
      },
      {
        key: 'calcStickRadius',
        value: function calcStickRadius(_res) {
          return this.opts.radius
        }
      },
      {
        key: 'getHeightSegmentsRatio',
        value: function getHeightSegmentsRatio() {
          return this.opts.heightSegmentsRatio
        }
      },
      {
        key: 'getTension',
        value: function getTension() {
          return this.opts.tension
        }
      },
      {
        key: 'buildGeometry',
        value: function buildGeometry(complex, colorer, mask, material) {
          var tubeRad = this.opts.radius
          var secHeight = this.opts.depth
          this.TUBE_RADIUS = new THREE__namespace.Vector2(tubeRad, tubeRad)
          this.ARROW_END = new THREE__namespace.Vector2(secHeight, tubeRad)
          var secCache = {}
          var secData = this.opts.ss

          for (var prop in secData) {
            secCache[prop] = {
              center: new THREE__namespace.Vector2(
                secHeight,
                secData[prop].width
              ),
              start: new THREE__namespace.Vector2(
                secHeight,
                secData[prop].arrow
              )
            }
          }

          this.secCache = secCache
          return Mode.prototype.buildGeometry.call(
            this,
            complex,
            colorer,
            mask,
            material
          )
        }
      }
    ])

    return CartoonMode
  })(Mode)

  _defineProperty(CartoonMode, 'id', 'CA')

  CartoonMode.prototype.id = 'CA'
  CartoonMode.prototype.name = 'Cartoon'
  CartoonMode.prototype.shortName = 'Cartoon'
  CartoonMode.prototype.depGroups = [
    'CartoonChains',
    'NucleicSpheres',
    'NucleicCylinders'
  ]

  function _createSuper$T(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$T()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$T() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var selectors$4 = chem.selectors

  function getRenderParams() {
    return {
      wireframe: this.opts.wireframe,
      zClip: this.opts.zClip
    }
  }

  var SurfaceMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(SurfaceMode, _Mode)

    var _super = _createSuper$T(SurfaceMode)

    function SurfaceMode(opts) {
      var _this

      _classCallCheck(this, SurfaceMode)

      _this = _super.call(this, opts)
      _this.depGroups = _this.depGroups.slice(0)
      var surfaces = _this.surfaceNames
      var groups = _this.depGroups

      for (var i = 0, n = surfaces.length; i < n; ++i) {
        groups[groups.length] = [surfaces[i], getRenderParams]
      }

      return _this
    }

    _createClass(SurfaceMode, [
      {
        key: 'calcAtomRadius',
        value: function calcAtomRadius(atom) {
          return atom.element.radius
        }
      },
      {
        key: 'getVisibilitySelector',
        value: function getVisibilitySelector() {
          var visibilitySelector = null

          if (this.opts.subset !== '') {
            var res = selectors$4.parse(this.opts.subset)

            if (!res.error) {
              visibilitySelector = res.selector
            }
          }

          return visibilitySelector
        }
      }
    ])

    return SurfaceMode
  })(Mode)

  SurfaceMode.prototype.isSurface = true
  SurfaceMode.prototype.surfaceNames = []

  function _createSuper$S(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$S()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$S() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var QuickSurfaceMode = /*#__PURE__*/ (function (_SurfaceMode) {
    _inherits(QuickSurfaceMode, _SurfaceMode)

    var _super = _createSuper$S(QuickSurfaceMode)

    function QuickSurfaceMode() {
      _classCallCheck(this, QuickSurfaceMode)

      return _super.apply(this, arguments)
    }

    _createClass(QuickSurfaceMode, [
      {
        key: 'getSurfaceOpts',
        value: function getSurfaceOpts() {
          return {
            useBeads: false,
            isoValue: this.opts.isoValue,
            gaussLim: this.opts.gaussLim[this.settings.now.resolution],
            radScale: this.opts.scale,
            gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
            zClip: this.opts.zClip,
            visibilitySelector: this.getVisibilitySelector()
          }
        }
      }
    ])

    return QuickSurfaceMode
  })(SurfaceMode)

  _defineProperty(QuickSurfaceMode, 'id', 'QS')

  QuickSurfaceMode.prototype.id = 'QS'
  QuickSurfaceMode.prototype.name = 'Quick Surface'
  QuickSurfaceMode.prototype.shortName = 'Quick Surf'
  QuickSurfaceMode.prototype.surfaceNames = ['QuickSurfGeo']

  function _createSuper$R(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$R()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$R() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var IsoSurfaceMode = /*#__PURE__*/ (function (_SurfaceMode) {
    _inherits(IsoSurfaceMode, _SurfaceMode)

    var _super = _createSuper$R(IsoSurfaceMode)

    function IsoSurfaceMode(excludeProbe, opts) {
      var _this

      _classCallCheck(this, IsoSurfaceMode)

      _this = _super.call(this, opts)
      _this._excludeProbe = excludeProbe
      return _this
    }

    _createClass(IsoSurfaceMode, [
      {
        key: 'calcAtomRadius',
        value: function calcAtomRadius(atom) {
          return atom.element.radius
        }
      },
      {
        key: 'getSurfaceOpts',
        value: function getSurfaceOpts() {
          return {
            gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
            radScale: this._radScale,
            zClip: this.opts.zClip,
            visibilitySelector: this.getVisibilitySelector(),
            probeRadius: this.opts.probeRadius,
            excludeProbe: this._excludeProbe
          }
        }
      }
    ])

    return IsoSurfaceMode
  })(SurfaceMode)

  IsoSurfaceMode.prototype.id = 'SU'
  IsoSurfaceMode.prototype.name = 'Surface'
  IsoSurfaceMode.prototype.shortName = 'Surface'
  IsoSurfaceMode.prototype.surfaceNames = ['SASSESSurfaceGeo']
  IsoSurfaceMode.prototype._radScale = 1
  IsoSurfaceMode.prototype._excludeProbe = false

  function _createSuper$Q(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$Q()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$Q() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var IsoSurfaceSASMode = /*#__PURE__*/ (function (_IsoSurfaceMode) {
    _inherits(IsoSurfaceSASMode, _IsoSurfaceMode)

    var _super = _createSuper$Q(IsoSurfaceSASMode)

    function IsoSurfaceSASMode(opts) {
      _classCallCheck(this, IsoSurfaceSASMode)

      return _super.call(this, false, opts)
    }

    return _createClass(IsoSurfaceSASMode)
  })(IsoSurfaceMode)

  _defineProperty(IsoSurfaceSASMode, 'id', 'SA')

  IsoSurfaceSASMode.prototype.id = 'SA'
  IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface'
  IsoSurfaceSASMode.prototype.shortName = 'SAS'

  function _createSuper$P(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$P()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$P() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var IsoSurfaceSESMode = /*#__PURE__*/ (function (_IsoSurfaceMode) {
    _inherits(IsoSurfaceSESMode, _IsoSurfaceMode)

    var _super = _createSuper$P(IsoSurfaceSESMode)

    function IsoSurfaceSESMode(opts) {
      _classCallCheck(this, IsoSurfaceSESMode)

      return _super.call(this, true, opts)
    }

    return _createClass(IsoSurfaceSESMode)
  })(IsoSurfaceMode)

  _defineProperty(IsoSurfaceSESMode, 'id', 'SE')

  IsoSurfaceSESMode.prototype.id = 'SE'
  IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface'
  IsoSurfaceSESMode.prototype.shortName = 'SES'

  function _createSuper$O(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$O()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$O() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ContactSurfaceMode = /*#__PURE__*/ (function (_SurfaceMode) {
    _inherits(ContactSurfaceMode, _SurfaceMode)

    var _super = _createSuper$O(ContactSurfaceMode)

    function ContactSurfaceMode() {
      _classCallCheck(this, ContactSurfaceMode)

      return _super.apply(this, arguments)
    }

    _createClass(ContactSurfaceMode, [
      {
        key: 'getSurfaceOpts',
        value: function getSurfaceOpts() {
          return {
            probeRadius: this.opts.probeRadius,
            radScale: this.opts.polyComplexity[this.settings.now.resolution],
            scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
            gridSpacing:
              1.0 / this.opts.polyComplexity[this.settings.now.resolution],
            isoValue: this.opts.isoValue,
            probePositions: this.opts.probePositions,
            zClip: this.opts.zClip,
            visibilitySelector: this.getVisibilitySelector()
          }
        }
      }
    ])

    return ContactSurfaceMode
  })(SurfaceMode)

  _defineProperty(ContactSurfaceMode, 'id', 'CS')

  ContactSurfaceMode.prototype.id = 'CS'
  ContactSurfaceMode.prototype.name = 'Contact Surface'
  ContactSurfaceMode.prototype.shortName = 'Contact Surf'
  ContactSurfaceMode.prototype.isSurface = true
  ContactSurfaceMode.prototype.surfaceNames = ['ContactSurfaceGeo']

  function _createSuper$N(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$N()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$N() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var TextMode = /*#__PURE__*/ (function (_Mode) {
    _inherits(TextMode, _Mode)

    var _super = _createSuper$N(TextMode)

    function TextMode() {
      _classCallCheck(this, TextMode)

      return _super.apply(this, arguments)
    }

    _createClass(TextMode, [
      {
        key: 'getTemplateOptions',
        value: function getTemplateOptions() {
          return this.opts.template
        }
      },
      {
        key: 'getLabelOpts',
        value: function getLabelOpts() {
          return ___default['default'].merge(this.opts, {
            colors: true,
            adjustColor: true,
            transparent: true
          })
        }
      }
    ])

    return TextMode
  })(Mode)

  _defineProperty(TextMode, 'id', 'TX')

  TextMode.prototype.id = 'TX'
  TextMode.prototype.name = 'Text mode'
  TextMode.prototype.shortName = 'Text'
  TextMode.prototype.depGroups = ['TextLabelsGeo']

  var modes$1 = new EntityList([
    LinesMode,
    LicoriceMode,
    BallsAndSticksMode,
    VanDerWaalsMode,
    TraceMode,
    TubeMode,
    CartoonMode,
    QuickSurfaceMode,
    IsoSurfaceSASMode,
    IsoSurfaceSESMode,
    ContactSurfaceMode,
    TextMode
  ])

  function clamp(x, a, b) {
    return x <= b ? (x < 0 ? 0 : x) : b
  }

  function lerpColor(c1, c2, alpha) {
    var beta = 1 - alpha
    var r1 = (c1 >> 16) & 0xff
    var g1 = (c1 >> 8) & 0xff
    var b1 = c1 & 0xff
    var r2 = (c2 >> 16) & 0xff
    var g2 = (c2 >> 8) & 0xff
    var b2 = c2 & 0xff
    var r = beta * r1 + alpha * r2
    var g = beta * g1 + alpha * g2
    var b = beta * b1 + alpha * b2
    return (r << 16) | (g << 8) | b
  }

  var Palette = /*#__PURE__*/ (function () {
    function Palette(name, id) {
      _classCallCheck(this, Palette)

      this.name = name || 'Custom'
      this.id = id || 'CP'
    }

    _createClass(Palette, [
      {
        key: 'getElementColor',
        value: function getElementColor(name) {
          var asIs =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false
          var color = this.elementColors[name]
          return color === undefined && !asIs ? this.defaultElementColor : color
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(name) {
          var asIs =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false
          var color = this.residueColors[name]
          return color === undefined && !asIs ? this.defaultResidueColor : color
        }
      },
      {
        key: 'getChainColor',
        value: function getChainColor(name) {
          var chain = name.charCodeAt(0)
          chain =
            ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 0x1f) %
            this.chainColors.length
          return this.chainColors[chain]
        }
      },
      {
        key: 'getSecondaryColor',
        value: function getSecondaryColor(type) {
          var asIs =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false
          var color = this.secondaryColors[type]
          return color === undefined && !asIs
            ? this.defaultSecondaryColor
            : color
        }
      },
      {
        key: 'getSequentialColor',
        value: function getSequentialColor(index) {
          var colors = this.colors
          var len = colors.length
          return index < 0 ? colors[(index % len) + len] : colors[index % len]
        }
      },
      {
        key: 'getGradientColor',
        value: function getGradientColor(value, gradientName) {
          var gradient = this.gradients[gradientName]

          if (!gradient) {
            return this.defaultNamedColor
          }

          var count = gradient.length
          var index = value * (count - 1)
          var left = Math.floor(index)
          var right = clamp(left + 1, 0, count - 1)
          left = clamp(left, 0, count - 1)
          return lerpColor(gradient[left], gradient[right], index - left)
        }
      },
      {
        key: 'getNamedColor',
        value: function getNamedColor(name) {
          var asIs =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false
          var color = this.namedColors[name]
          return color === undefined && !asIs ? this.defaultNamedColor : color
        }
      }
    ])

    return Palette
  })()

  ___default['default'].assign(Palette.prototype, {
    colors: [0xffffff, 0xff0000, 0x00ff00, 0x0000ff, 0x808080],
    minRangeColor: 0x000000,
    midRangeColor: 0x7f7f7f,
    maxRangeColor: 0xffffff,
    defaultElementColor: 0xffffff,
    elementColors: {},
    defaultResidueColor: 0xffffff,
    residueColors: {},
    chainColors: [0xffffff],
    defaultSecondaryColor: 0xffffff,
    secondaryColors: {},
    defaultGradientColor: 0x000000,
    defaultNamedColor: 0xffffff,
    namedColorsArray: [
      ['indianred', 0xcd5c5c],
      ['lightcoral', 0xf08080],
      ['salmon', 0xfa8072],
      ['darksalmon', 0xe9967a],
      ['lightsalmon', 0xffa07a],
      ['crimson', 0xdc143c],
      ['red', 0xff0000],
      ['firebrick', 0xb22222],
      ['darkred', 0x8b0000],
      ['pink', 0xffc0cb],
      ['lightpink', 0xffb6c1],
      ['hotpink', 0xff69b4],
      ['deeppink', 0xff1493],
      ['mediumvioletred', 0xc71585],
      ['palevioletred', 0xdb7093],
      ['coral', 0xff7f50],
      ['tomato', 0xff6347],
      ['orangered', 0xff4500],
      ['darkorange', 0xff8c00],
      ['orange', 0xffa500],
      ['gold', 0xffd700],
      ['yellow', 0xffff00],
      ['lightyellow', 0xffffe0],
      ['lemonchiffon', 0xfffacd],
      ['lightgoldenrodyellow', 0xfafad2],
      ['papayawhip', 0xffefd5],
      ['moccasin', 0xffe4b5],
      ['peachpuff', 0xffdab9],
      ['palegoldenrod', 0xeee8aa],
      ['khaki', 0xf0e68c],
      ['darkkhaki', 0xbdb76b],
      ['lavender', 0xe6e6fa],
      ['thistle', 0xd8bfd8],
      ['plum', 0xdda0dd],
      ['violet', 0xee82ee],
      ['orchid', 0xda70d6],
      ['fuchsia', 0xff00ff],
      ['magenta', 0xff00ff],
      ['mediumorchid', 0xba55d3],
      ['mediumpurple', 0x9370db],
      ['rebeccapurple', 0x663399],
      ['blueviolet', 0x8a2be2],
      ['darkviolet', 0x9400d3],
      ['darkorchid', 0x9932cc],
      ['darkmagenta', 0x8b008b],
      ['purple', 0x800080],
      ['indigo', 0x4b0082],
      ['slateblue', 0x6a5acd],
      ['mediumslateblue', 0x7b68ee],
      ['darkslateblue', 0x483d8b],
      ['greenyellow', 0xadff2f],
      ['chartreuse', 0x7fff00],
      ['lawngreen', 0x7cfc00],
      ['lime', 0x00ff00],
      ['limegreen', 0x32cd32],
      ['palegreen', 0x98fb98],
      ['lightgreen', 0x90ee90],
      ['mediumspringgreen', 0x00fa9a],
      ['springgreen', 0x00ff7f],
      ['mediumseagreen', 0x3cb371],
      ['seagreen', 0x2e8b57],
      ['forestgreen', 0x228b22],
      ['green', 0x008000],
      ['darkgreen', 0x006400],
      ['yellowgreen', 0x9acd32],
      ['olivedrab', 0x6b8e23],
      ['olive', 0x808000],
      ['darkolivegreen', 0x556b2f],
      ['mediumaquamarine', 0x66cdaa],
      ['darkseagreen', 0x8fbc8f],
      ['lightseagreen', 0x20b2aa],
      ['darkcyan', 0x008b8b],
      ['teal', 0x008080],
      ['aqua', 0x00ffff],
      ['cyan', 0x00ffff],
      ['lightcyan', 0xe0ffff],
      ['paleturquoise', 0xafeeee],
      ['aquamarine', 0x7fffd4],
      ['turquoise', 0x40e0d0],
      ['mediumturquoise', 0x48d1cc],
      ['darkturquoise', 0x00ced1],
      ['cadetblue', 0x5f9ea0],
      ['steelblue', 0x4682b4],
      ['lightsteelblue', 0xb0c4de],
      ['powderblue', 0xb0e0e6],
      ['lightblue', 0xadd8e6],
      ['skyblue', 0x87ceeb],
      ['lightskyblue', 0x87cefa],
      ['deepskyblue', 0x00bfff],
      ['dodgerblue', 0x1e90ff],
      ['cornflowerblue', 0x6495ed],
      ['royalblue', 0x4169e1],
      ['blue', 0x0000ff],
      ['mediumblue', 0x0000cd],
      ['darkblue', 0x00008b],
      ['navy', 0x000080],
      ['midnightblue', 0x191970],
      ['cornsilk', 0xfff8dc],
      ['blanchedalmond', 0xffebcd],
      ['bisque', 0xffe4c4],
      ['navajowhite', 0xffdead],
      ['wheat', 0xf5deb3],
      ['burlywood', 0xdeb887],
      ['tan', 0xd2b48c],
      ['rosybrown', 0xbc8f8f],
      ['sandybrown', 0xf4a460],
      ['goldenrod', 0xdaa520],
      ['darkgoldenrod', 0xb8860b],
      ['peru', 0xcd853f],
      ['chocolate', 0xd2691e],
      ['saddlebrown', 0x8b4513],
      ['sienna', 0xa0522d],
      ['brown', 0xa52a2a],
      ['maroon', 0x800000],
      ['white', 0xffffff],
      ['snow', 0xfffafa],
      ['honeydew', 0xf0fff0],
      ['mintcream', 0xf5fffa],
      ['azure', 0xf0ffff],
      ['aliceblue', 0xf0f8ff],
      ['ghostwhite', 0xf8f8ff],
      ['whitesmoke', 0xf5f5f5],
      ['seashell', 0xfff5ee],
      ['beige', 0xf5f5dc],
      ['oldlace', 0xfdf5e6],
      ['floralwhite', 0xfffaf0],
      ['ivory', 0xfffff0],
      ['antiquewhite', 0xfaebd7],
      ['linen', 0xfaf0e6],
      ['lavenderblush', 0xfff0f5],
      ['mistyrose', 0xffe4e1],
      ['gainsboro', 0xdcdcdc],
      ['lightgray', 0xd3d3d3],
      ['silver', 0xc0c0c0],
      ['darkgray', 0xa9a9a9],
      ['gray', 0x808080],
      ['dimgray', 0x696969],
      ['lightslategray', 0x778899],
      ['slategray', 0x708090],
      ['darkslategray', 0x2f4f4f],
      ['black', 0x000000]
    ],
    namedColors: {},
    gradients: {
      rainbow: [0x0000ff, 0x00ffff, 0x00ff00, 0xffff00, 0xff0000],
      temp: [0x0000ff, 0x007fff, 0xffffff, 0xff7f00, 0xff0000],
      hot: [0xffffff, 0xff7f00, 0xff0000],
      cold: [0xffffff, 0x007fff, 0x0000ff],
      'blue-red': [0x0000ff, 0xffffff, 0xff0000],
      reds: [0xffffff, 0xff0000],
      blues: [0xffffff, 0x0000ff]
    }
  })

  var _Palette$prototype = Palette.prototype,
    namedColorsArray = _Palette$prototype.namedColorsArray,
    namedColors = _Palette$prototype.namedColors

  for (var i = 0, length = namedColorsArray.length; i < length; ++i) {
    var _namedColorsArray$i = _slicedToArray(namedColorsArray[i], 2),
      name = _namedColorsArray$i[0],
      value = _namedColorsArray$i[1]

    namedColors[name] = value
  }

  var palette$2 = new Palette('CPK', 'CP')
  palette$2.elementColors = {
    H: 0xffffff,
    C: 0x202020,
    N: 0x2060ff,
    O: 0xee2010,
    F: 0x00ff00,
    P: 0x8020ff,
    S: 0xffff00,
    CL: 0x00bb00,
    FE: 0xd0d0d0,
    CO: 0xd0d0d0,
    NI: 0xd0d0d0,
    CU: 0xd0d0d0,
    BR: 0x008800,
    I: 0x005500
  }

  var _palette$secondaryCol$1
  var palette$1 = new Palette('Jmol', 'JM')
  palette$1.colors = [
    0x0000ff, 0x0055ff, 0x00abff, 0x00ffff, 0x00ffab, 0x00ff55, 0x00ff00,
    0x55ff00, 0xabff00, 0xffff00, 0xffab00, 0xff5500, 0xff0000, 0xff0055,
    0xff00ab, 0xff00ff, 0xab00ff, 0x5500ff
  ]
  palette$1.elementColors = {
    H: 0xffffff,
    D: 0xffffc0,
    T: 0xffffa0,
    HE: 0xd9ffff,
    LI: 0xcc80ff,
    BE: 0xc2ff00,
    B: 0xffb5b5,
    C: 0x909090,
    N: 0x3050f8,
    O: 0xff0d0d,
    F: 0x90e050,
    NE: 0xb3e3f5,
    NA: 0xab5cf2,
    MG: 0x8aff00,
    AL: 0xbfa6a6,
    SI: 0xf0c8a0,
    P: 0xff8000,
    S: 0xffff30,
    CL: 0x1ff01f,
    AR: 0x80d1e3,
    K: 0x8f40d4,
    CA: 0x3dff00,
    SC: 0xe6e6e6,
    TI: 0xbfc2c7,
    V: 0xa6a6ab,
    CR: 0x8a99c7,
    MN: 0x9c7ac7,
    FE: 0xe06633,
    CO: 0xf090a0,
    NI: 0x50d050,
    CU: 0xc88033,
    ZN: 0x7d80b0,
    GA: 0xc28f8f,
    GE: 0x668f8f,
    AS: 0xbd80e3,
    SE: 0xffa100,
    BR: 0xa62929,
    KR: 0x5cb8d1,
    RB: 0x702eb0,
    SR: 0x00ff00,
    Y: 0x94ffff,
    ZR: 0x94e0e0,
    NB: 0x73c2c9,
    MO: 0x54b5b5,
    TC: 0x3b9e9e,
    RU: 0x248f8f,
    RH: 0x0a7d8c,
    PD: 0x006985,
    AG: 0xc0c0c0,
    CD: 0xffd98f,
    IN: 0xa67573,
    SN: 0x668080,
    SB: 0x9e63b5,
    TE: 0xd47a00,
    I: 0x940094,
    XE: 0x429eb0,
    CS: 0x57178f,
    BA: 0x00c900,
    LA: 0x70d4ff,
    CE: 0xffffc7,
    PR: 0xd9ffc7,
    ND: 0xc7ffc7,
    PM: 0xa3ffc7,
    SM: 0x8fffc7,
    EU: 0x61ffc7,
    GD: 0x45ffc7,
    TB: 0x30ffc7,
    DY: 0x1fffc7,
    HO: 0x00ff9c,
    ER: 0x00e675,
    TM: 0x00d452,
    YB: 0x00bf38,
    LU: 0x00ab24,
    HF: 0x4dc2ff,
    TA: 0x4da6ff,
    W: 0x2194d6,
    RE: 0x267dab,
    OS: 0x266696,
    IR: 0x175487,
    PT: 0xd0d0e0,
    AU: 0xffd123,
    HG: 0xb8b8d0,
    TL: 0xa6544d,
    PB: 0x575961,
    BI: 0x9e4fb5,
    PO: 0xab5c00,
    AT: 0x754f45,
    RN: 0x428296,
    FR: 0x420066,
    RA: 0x007d00,
    AC: 0x70abfa,
    TH: 0x00baff,
    PA: 0x00a1ff,
    U: 0x008fff,
    NP: 0x0080ff,
    PU: 0x006bff,
    AM: 0x545cf2,
    CM: 0x785ce3,
    BK: 0x8a4fe3,
    CF: 0xa136d4,
    ES: 0xb31fd4,
    FM: 0xb31fba,
    MD: 0xb30da6,
    NO: 0xbd0d87,
    LR: 0xc70066,
    RF: 0xcc0059,
    DB: 0xd1004f,
    SG: 0xd90045,
    BH: 0xe00038,
    HS: 0xe6002e,
    MT: 0xeb0026
  }
  palette$1.defaultResidueColor = 0xbea06e
  palette$1.residueColors = {
    ALA: 0xc8c8c8,
    ARG: 0x145aff,
    ASN: 0x00dcdc,
    ASP: 0xe60a0a,
    CYS: 0xe6e600,
    GLN: 0x00dcdc,
    GLU: 0xe60a0a,
    GLY: 0xebebeb,
    HIS: 0x8282d2,
    ILE: 0x0f820f,
    LEU: 0x0f820f,
    LYS: 0x145aff,
    MET: 0xe6e600,
    PHE: 0x3232aa,
    PRO: 0xdc9682,
    SER: 0xfa9600,
    THR: 0xfa9600,
    TRP: 0xb45ab4,
    TYR: 0x3232aa,
    VAL: 0x0f820f,
    A: 0xa0a0ff,
    C: 0xff8c4b,
    G: 0xff7070,
    I: 0x80ffff,
    T: 0xa0ffa0,
    U: 0xff8080,
    DA: 0xa0a0ff,
    DC: 0xff8c4b,
    DG: 0xff7070,
    DI: 0x80ffff,
    DT: 0xa0ffa0,
    DU: 0xff8080,
    '+A': 0xa0a0ff,
    '+C': 0xff8c4b,
    '+G': 0xff7070,
    '+I': 0x80ffff,
    '+T': 0xa0ffa0,
    '+U': 0xff8080
  }
  palette$1.chainColors = [
    0xffffffff, 0xffc0d0ff, 0xffb0ffb0, 0xffffc0c8, 0xffffff80, 0xffffc0ff,
    0xffb0f0f0, 0xffffd070, 0xfff08080, 0xfff5deb3, 0xff00bfff, 0xffcd5c5c,
    0xff66cdaa, 0xff9acd32, 0xffee82ee, 0xff00ced1, 0xff00ff7f, 0xff3cb371,
    0xff00008b, 0xffbdb76b, 0xff006400, 0xff800000, 0xff808000, 0xff800080,
    0xff008080, 0xffb8860b, 0xffb22222
  ]
  var StructuralElementType$2 = StructuralElement.Type
  palette$1.secondaryColors =
    ((_palette$secondaryCol$1 = {}),
    _defineProperty(
      _palette$secondaryCol$1,
      StructuralElementType$2.HELIX_ALPHA,
      0xff0080
    ),
    _defineProperty(
      _palette$secondaryCol$1,
      StructuralElementType$2.HELIX_PI,
      0x600080
    ),
    _defineProperty(
      _palette$secondaryCol$1,
      StructuralElementType$2.HELIX_310,
      0xa00080
    ),
    _defineProperty(
      _palette$secondaryCol$1,
      StructuralElementType$2.STRAND,
      0xffc800
    ),
    _defineProperty(
      _palette$secondaryCol$1,
      StructuralElementType$2.TURN,
      0x6080ff
    ),
    _defineProperty(_palette$secondaryCol$1, 'dna', 0xae00fe),
    _defineProperty(_palette$secondaryCol$1, 'rna', 0xfd0162),
    _palette$secondaryCol$1)

  var _palette$secondaryCol
  var palette = new Palette('VMD', 'VM')
  palette.colors = [
    0x0000ff, 0xff0000, 0x606060, 0xff8000, 0xffff00, 0x808033, 0x999999,
    0x00ff00, 0xffffff, 0xff9999, 0x40c0c0, 0xa600a6, 0x80e666, 0xe666b3,
    0x804d00, 0x8080c0
  ]
  palette.defaultElementColor = 0x804d00
  palette.elementColors = {
    H: 0xffffff,
    C: 0x40bfbf,
    N: 0x0000ff,
    O: 0xff0000,
    P: 0x808033,
    S: 0xffff00
  }
  palette.defaultResidueColor = 0x40c0c0
  palette.residueColors = {
    ALA: 0x0000ff,
    ARG: 0xffffff,
    ASN: 0x808033,
    ASP: 0xff0000,
    CYS: 0xffff00,
    GLN: 0xff8000,
    GLU: 0xff9999,
    GLY: 0xffffff,
    HIS: 0x40c0c0,
    ILE: 0x00ff00,
    LEU: 0xff9999,
    LYS: 0x40c0c0,
    MET: 0xffff00,
    PHE: 0xa600a6,
    PRO: 0x804c00,
    SER: 0xffff00,
    THR: 0xe666b3,
    TRP: 0x999999,
    TYR: 0x00ff00,
    VAL: 0x808033,
    A: 0x0000ff,
    C: 0xff8000,
    G: 0xffff00,
    T: 0xa600a6,
    U: 0x00ff00,
    DA: 0x0000ff,
    DC: 0xff8000,
    DG: 0xffff00,
    DT: 0xa600a6,
    DU: 0x00ff00,
    '+A': 0x0000ff,
    '+C': 0xff8000,
    '+G': 0xffff00,
    '+T': 0xa600a6,
    '+U': 0x00ff00,
    WAT: 0x40c0c0,
    H2O: 0x40c0c0,
    HOH: 0x40c0c0
  }
  palette.chainColors = [0xffffff].concat(palette.colors)
  var StructuralElementType$1 = StructuralElement.Type
  palette.secondaryColors =
    ((_palette$secondaryCol = {}),
    _defineProperty(
      _palette$secondaryCol,
      StructuralElementType$1.HELIX_ALPHA,
      0xa600a6
    ),
    _defineProperty(
      _palette$secondaryCol,
      StructuralElementType$1.HELIX_310,
      0x0000ff
    ),
    _defineProperty(
      _palette$secondaryCol,
      StructuralElementType$1.HELIX_PI,
      0xff0000
    ),
    _defineProperty(
      _palette$secondaryCol,
      StructuralElementType$1.STRAND,
      0xffff00
    ),
    _defineProperty(
      _palette$secondaryCol,
      StructuralElementType$1.BRIDGE,
      0x808033
    ),
    _defineProperty(
      _palette$secondaryCol,
      StructuralElementType$1.TURN,
      0x40c0c0
    ),
    _palette$secondaryCol)

  var palettes$1 = new EntityList([palette$2, palette$1, palette])

  var Colorer = /*#__PURE__*/ (function () {
    function Colorer(opts) {
      _classCallCheck(this, Colorer)

      if (this.constructor === Colorer) {
        throw new Error('Can not instantiate abstract class!')
      }

      this.opts = ___default['default'].merge(
        utils.deriveDeep(settings$1.now.colorers[this.id], true),
        opts
      )
      this.palette = palettes$1.first
    }

    _createClass(Colorer, [
      {
        key: 'identify',
        value: function identify() {
          var diff = utils.objectsDiff(
            this.opts,
            settings$1.now.colorers[this.id]
          )

          if (!___default['default'].isEmpty(diff)) {
            return [this.id, diff]
          }

          return this.id
        }
      }
    ])

    return Colorer
  })()

  Colorer.prototype.id = '__'

  function _createSuper$M(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$M()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$M() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ElementColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(ElementColorer, _Colorer)

    var _super = _createSuper$M(ElementColorer)

    function ElementColorer() {
      _classCallCheck(this, ElementColorer)

      return _super.apply(this, arguments)
    }

    _createClass(ElementColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, _complex) {
          var type = atom.element.name

          if (type === 'C' && this.opts.carbon >= 0) {
            return this.opts.carbon
          }

          return this.palette.getElementColor(type)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(_residue, _complex) {
          return this.palette.defaultResidueColor
        }
      }
    ])

    return ElementColorer
  })(Colorer)

  _defineProperty(ElementColorer, 'id', 'EL')

  ElementColorer.prototype.id = 'EL'
  ElementColorer.prototype.name = 'Element'
  ElementColorer.prototype.shortName = 'Element'

  function _createSuper$L(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$L()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$L() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ResidueTypeColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(ResidueTypeColorer, _Colorer)

    var _super = _createSuper$L(ResidueTypeColorer)

    function ResidueTypeColorer() {
      _classCallCheck(this, ResidueTypeColorer)

      return _super.apply(this, arguments)
    }

    _createClass(ResidueTypeColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, complex) {
          return this.getResidueColor(atom.residue, complex)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          return this.palette.getResidueColor(residue._type._name)
        }
      }
    ])

    return ResidueTypeColorer
  })(Colorer)

  _defineProperty(ResidueTypeColorer, 'id', 'RT')

  ResidueTypeColorer.prototype.id = 'RT'
  ResidueTypeColorer.prototype.name = 'Residue Type'
  ResidueTypeColorer.prototype.shortName = 'Residue'

  function _createSuper$K(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$K()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$K() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var SequenceColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(SequenceColorer, _Colorer)

    var _super = _createSuper$K(SequenceColorer)

    function SequenceColorer() {
      _classCallCheck(this, SequenceColorer)

      return _super.apply(this, arguments)
    }

    _createClass(SequenceColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, complex) {
          return this.getResidueColor(atom.residue, complex)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          var chain = residue._chain

          if (
            chain.minSequence === Number.POSITIVE_INFINITY &&
            chain.maxSequence === Number.NEGATIVE_INFINITY
          ) {
            return this.palette.defaultNamedColor
          }

          var min = chain.minSequence
          var max = chain.maxSequence > min ? chain.maxSequence : min + 1
          return this.palette.getGradientColor(
            (residue._sequence - min) / (max - min),
            this.opts.gradient
          )
        }
      }
    ])

    return SequenceColorer
  })(Colorer)

  _defineProperty(SequenceColorer, 'id', 'SQ')

  SequenceColorer.prototype.id = 'SQ'
  SequenceColorer.prototype.name = 'Sequence'
  SequenceColorer.prototype.shortName = 'Sequence'

  function _createSuper$J(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$J()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$J() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ChainColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(ChainColorer, _Colorer)

    var _super = _createSuper$J(ChainColorer)

    function ChainColorer() {
      _classCallCheck(this, ChainColorer)

      return _super.apply(this, arguments)
    }

    _createClass(ChainColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, complex) {
          return this.getResidueColor(atom.residue, complex)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          return this.palette.getChainColor(residue.getChain()._name)
        }
      }
    ])

    return ChainColorer
  })(Colorer)

  _defineProperty(ChainColorer, 'id', 'CH')

  ChainColorer.prototype.id = 'CH'
  ChainColorer.prototype.name = 'Chain'
  ChainColorer.prototype.shortName = 'Chain'

  function _createSuper$I(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$I()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$I() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var SecondaryStructureColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(SecondaryStructureColorer, _Colorer)

    var _super = _createSuper$I(SecondaryStructureColorer)

    function SecondaryStructureColorer() {
      _classCallCheck(this, SecondaryStructureColorer)

      return _super.apply(this, arguments)
    }

    _createClass(SecondaryStructureColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, complex) {
          return this.getResidueColor(atom.residue, complex)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          if (residue._type.flags & ResidueType$1.Flags.DNA) {
            return this.palette.getSecondaryColor('dna')
          }

          if (residue._type.flags & ResidueType$1.Flags.RNA) {
            return this.palette.getSecondaryColor('rna')
          }

          var secondary = residue.getSecondary()

          if (secondary) {
            var color = this.palette.getSecondaryColor(secondary.type, true)

            if (color === undefined) {
              color = this.palette.getSecondaryColor(secondary.generic)
            }

            return color
          }

          return this.palette.defaultSecondaryColor
        }
      }
    ])

    return SecondaryStructureColorer
  })(Colorer)

  _defineProperty(SecondaryStructureColorer, 'id', 'SS')

  SecondaryStructureColorer.prototype.id = 'SS'
  SecondaryStructureColorer.prototype.name = 'Secondary Structure'
  SecondaryStructureColorer.prototype.shortName = 'Structure'

  function _createSuper$H(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$H()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$H() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var UniformColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(UniformColorer, _Colorer)

    var _super = _createSuper$H(UniformColorer)

    function UniformColorer() {
      _classCallCheck(this, UniformColorer)

      return _super.apply(this, arguments)
    }

    _createClass(UniformColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(_atom, _complex) {
          return this.opts.color
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(_residue, _complex) {
          return this.opts.color
        }
      }
    ])

    return UniformColorer
  })(Colorer)

  _defineProperty(UniformColorer, 'id', 'UN')

  UniformColorer.prototype.id = 'UN'
  UniformColorer.prototype.name = 'Uniform'
  UniformColorer.prototype.shortName = 'Uniform'

  function _createSuper$G(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$G()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$G() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ConditionalColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(ConditionalColorer, _Colorer)

    var _super = _createSuper$G(ConditionalColorer)

    function ConditionalColorer(opts) {
      var _this

      _classCallCheck(this, ConditionalColorer)

      _this = _super.call(this, opts)
      var parsed = selectors$5.parse(_this.opts.subset)
      _this._subsetCached = parsed.error ? selectors$5.none() : parsed.selector
      return _this
    }

    _createClass(ConditionalColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, _complex) {
          return this._subsetCached.includesAtom(atom)
            ? this.opts.color
            : this.opts.baseColor
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          var subset = this._subsetCached
          var atoms = residue._atoms

          for (var i = 0, n = atoms.length; i < n; ++i) {
            if (!subset.includesAtom(atoms[i])) {
              return this.opts.baseColor
            }
          }

          return this.opts.color
        }
      }
    ])

    return ConditionalColorer
  })(Colorer)

  _defineProperty(ConditionalColorer, 'id', 'CO')

  ConditionalColorer.prototype.id = 'CO'
  ConditionalColorer.prototype.name = 'Conditional'
  ConditionalColorer.prototype.shortName = 'Conditional'

  function _createSuper$F(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$F()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$F() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ConformationColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(ConformationColorer, _Colorer)

    var _super = _createSuper$F(ConformationColorer)

    function ConformationColorer() {
      _classCallCheck(this, ConformationColorer)

      return _super.apply(this, arguments)
    }

    _createClass(ConformationColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, _complex) {
          return this.palette.getChainColor(String.fromCharCode(atom.location))
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(_residue, _complex) {
          return this.palette.defaultResidueColor
        }
      }
    ])

    return ConformationColorer
  })(Colorer)

  _defineProperty(ConformationColorer, 'id', 'CF')

  ConformationColorer.prototype.id = 'CF'
  ConformationColorer.prototype.name = 'Conformation'
  ConformationColorer.prototype.shortName = 'Conformation'

  function _createSuper$E(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$E()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$E() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var TemperatureColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(TemperatureColorer, _Colorer)

    var _super = _createSuper$E(TemperatureColorer)

    function TemperatureColorer() {
      _classCallCheck(this, TemperatureColorer)

      return _super.apply(this, arguments)
    }

    _createClass(TemperatureColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, _complex) {
          var opts = this.opts
          var factor = 1

          if (atom.temperature && opts) {
            if (opts.min === opts.max) {
              factor = atom.temperature > opts.max ? 1 : 0
            } else {
              factor = (atom.temperature - opts.min) / (opts.max - opts.min)
            }

            return this.palette.getGradientColor(factor, opts.gradient)
          }

          return this.palette.defaultGradientColor
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          var opts = this.opts

          if (!opts) {
            return this.palette.defaultGradientColor
          }

          if (residue.temperature) {
            var factor = 0

            if (opts.min === opts.max) {
              factor = residue.temperature > opts.max ? 1 : 0
            } else {
              factor = (residue.temperature - opts.min) / (opts.max - opts.min)
            }

            return this.palette.getGradientColor(factor, opts.gradient)
          }

          return this.palette.defaultGradientColor
        }
      }
    ])

    return TemperatureColorer
  })(Colorer)

  _defineProperty(TemperatureColorer, 'id', 'TM')

  TemperatureColorer.prototype.id = 'TM'
  TemperatureColorer.prototype.name = 'Temperature'
  TemperatureColorer.prototype.shortName = 'Temperature'

  function _createSuper$D(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$D()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$D() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var OccupancyColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(OccupancyColorer, _Colorer)

    var _super = _createSuper$D(OccupancyColorer)

    function OccupancyColorer() {
      _classCallCheck(this, OccupancyColorer)

      return _super.apply(this, arguments)
    }

    _createClass(OccupancyColorer, [
      {
        key: '_getColorByOccupancy',
        value: function _getColorByOccupancy(occupancy, opts) {
          if (occupancy !== undefined) {
            var factor = 1 - occupancy
            return this.palette.getGradientColor(factor, opts.gradient)
          }

          return this.palette.defaultGradientColor
        }
      },
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, _complex) {
          var opts = this.opts
          return this._getColorByOccupancy(atom.occupancy, opts)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          var opts = this.opts
          return this._getColorByOccupancy(residue.occupancy, opts)
        }
      }
    ])

    return OccupancyColorer
  })(Colorer)

  _defineProperty(OccupancyColorer, 'id', 'OC')

  OccupancyColorer.prototype.id = 'OC'
  OccupancyColorer.prototype.name = 'Occupancy'
  OccupancyColorer.prototype.shortName = 'Occupancy'

  function _createSuper$C(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$C()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$C() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var HydrophobicityColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(HydrophobicityColorer, _Colorer)

    var _super = _createSuper$C(HydrophobicityColorer)

    function HydrophobicityColorer() {
      _classCallCheck(this, HydrophobicityColorer)

      return _super.apply(this, arguments)
    }

    _createClass(HydrophobicityColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, complex) {
          return this.getResidueColor(atom.residue, complex)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          var color = this.palette.defaultResidueColor

          if (residue._type.hydrophobicity !== undefined) {
            var min = -4.5
            var max = 4.5
            color = this.palette.getGradientColor(
              (residue._type.hydrophobicity - min) / (max - min),
              this.opts.gradient
            )
          }

          return color
        }
      }
    ])

    return HydrophobicityColorer
  })(Colorer)

  _defineProperty(HydrophobicityColorer, 'id', 'HY')

  HydrophobicityColorer.prototype.id = 'HY'
  HydrophobicityColorer.prototype.name = 'Hydrophobicity'
  HydrophobicityColorer.prototype.shortName = 'Hydrophobicity'

  function _createSuper$B(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$B()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$B() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var MoleculeColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(MoleculeColorer, _Colorer)

    var _super = _createSuper$B(MoleculeColorer)

    function MoleculeColorer() {
      _classCallCheck(this, MoleculeColorer)

      return _super.apply(this, arguments)
    }

    _createClass(MoleculeColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, complex) {
          return this.getResidueColor(atom.residue, complex)
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(residue, _complex) {
          var molecule = residue._molecule

          var count = _complex.getMoleculeCount()

          if (count > 1) {
            return this.palette.getGradientColor(
              (molecule.index - 1) / (count - 1),
              this.opts.gradient
            )
          }

          return this.palette.getGradientColor(0, this.opts.gradient)
        }
      }
    ])

    return MoleculeColorer
  })(Colorer)

  _defineProperty(MoleculeColorer, 'id', 'MO')

  MoleculeColorer.prototype.id = 'MO'
  MoleculeColorer.prototype.name = 'Molecule'
  MoleculeColorer.prototype.shortName = 'Molecule'

  function _createSuper$A(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$A()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$A() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function scaleColor(c, factor) {
    var r1 = (c >> 16) & 0xff
    var g1 = (c >> 8) & 0xff
    var b1 = c & 0xff
    var r = factor * r1
    var g = factor * g1
    var b = factor * b1
    return (r << 16) | (g << 8) | b
  }

  var CarbonColorer = /*#__PURE__*/ (function (_Colorer) {
    _inherits(CarbonColorer, _Colorer)

    var _super = _createSuper$A(CarbonColorer)

    function CarbonColorer() {
      _classCallCheck(this, CarbonColorer)

      return _super.apply(this, arguments)
    }

    _createClass(CarbonColorer, [
      {
        key: 'getAtomColor',
        value: function getAtomColor(atom, _complex) {
          var colorCarbon = this.opts.color
          var colorNotCarbon = scaleColor(colorCarbon, this.opts.factor)
          return atom.flags & Atom$2.Flags.CARBON ? colorCarbon : colorNotCarbon
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(_residue, _complex) {
          return this.opts.color
        }
      }
    ])

    return CarbonColorer
  })(Colorer)

  _defineProperty(CarbonColorer, 'id', 'CB')

  CarbonColorer.prototype.id = 'CB'
  CarbonColorer.prototype.name = 'Carbon'
  CarbonColorer.prototype.shortName = 'Carbon'

  var colorers$1 = new EntityList([
    ElementColorer,
    ResidueTypeColorer,
    SequenceColorer,
    ChainColorer,
    SecondaryStructureColorer,
    UniformColorer,
    ConditionalColorer,
    ConformationColorer,
    TemperatureColorer,
    OccupancyColorer,
    HydrophobicityColorer,
    MoleculeColorer,
    CarbonColorer
  ])

  function neutralColor(intensity) {
    return new THREE__namespace.Color(intensity, intensity, intensity)
  }

  var materialList = [
    {
      id: 'DF',
      name: 'Diffuse',
      shortName: 'Diffuse',
      uberOptions: {
        diffuse: neutralColor(1.0),
        specular: neutralColor(0.0),
        shininess: 1,
        opacity: 1.0
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: false,
        toonShading: false
      }
    },
    {
      id: 'SF',
      name: 'Soft Plastic',
      shortName: 'Soft',
      uberOptions: {
        diffuse: neutralColor(1.0),
        specular: neutralColor(0.1),
        shininess: 30,
        opacity: 1.0
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: false,
        toonShading: false
      }
    },
    {
      id: 'PL',
      name: 'Glossy Plastic',
      shortName: 'Glossy',
      uberOptions: {
        diffuse: neutralColor(0.56),
        specular: neutralColor(0.28),
        shininess: 100,
        opacity: 1.0
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: false,
        toonShading: false
      }
    },
    {
      id: 'ME',
      name: 'Metal',
      shortName: 'Metal',
      uberOptions: {
        diffuse: neutralColor(0.56),
        specular: neutralColor(0.55),
        shininess: 30,
        opacity: 1.0
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: false,
        toonShading: false
      }
    },
    {
      id: 'TR',
      name: 'Transparent',
      shortName: 'Transparent',
      uberOptions: {
        diffuse: neutralColor(1.0),
        specular: neutralColor(0.0),
        shininess: 1,
        opacity: 0.5
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: true,
        toonShading: false
      }
    },
    {
      id: 'GL',
      name: 'Glass',
      shortName: 'Glass',
      uberOptions: {
        diffuse: neutralColor(0.5),
        specular: neutralColor(0.65),
        shininess: 100,
        opacity: 0.5
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: true,
        toonShading: false
      }
    },
    {
      id: 'BA',
      name: 'Backdrop',
      shortName: 'Backdrop',
      uberOptions: {
        diffuse: neutralColor(1.0),
        specular: neutralColor(0.0),
        shininess: 1,
        opacity: 1.0
      },
      values: {
        lights: false,
        fog: false,
        depthWrite: false,
        transparent: false,
        toonShading: false
      }
    },
    {
      id: 'TN',
      name: 'Toon',
      shortName: 'Toon',
      uberOptions: {
        diffuse: neutralColor(1.0),
        specular: neutralColor(0.0),
        shininess: 1,
        opacity: 1.0
      },
      values: {
        lights: true,
        fog: true,
        depthWrite: true,
        transparent: false,
        toonShading: true
      }
    },
    {
      id: 'FL',
      name: 'Flat',
      shortName: 'Flat',
      uberOptions: {
        diffuse: neutralColor(1.0),
        specular: neutralColor(0.0),
        shininess: 0,
        opacity: 1.0
      },
      values: {
        lights: false,
        fog: true,
        depthWrite: true,
        transparent: false
      }
    }
  ]
  var materials$1 = new EntityList(materialList)

  function _gatherObjects(root, meshTypes) {
    var meshes = []
    root.traverse(function (object) {
      for (var i = 0; i < meshTypes.length; i++) {
        if (object instanceof meshTypes[i]) {
          meshes[meshes.length] = object
          break
        }
      }
    })
    return meshes
  }

  function createDerivativeMesh(mesh, values, layer) {
    var material = mesh.material.createInstance()
    material.setValues(values)
    var newMesh = new mesh.constructor(mesh.geometry, material)
    newMesh.material.needsUpdate = true
    newMesh.applyMatrix4(mesh.matrix)
    newMesh.layers.set(layer)
    return newMesh
  }

  function traverseMeshes(root, meshTypes, func) {
    var meshes = _gatherObjects(root, meshTypes)

    for (var i = 0, n = meshes.length; i < n; ++i) {
      var mesh = meshes[i]

      if (!mesh.parent) {
        continue
      }

      func(mesh)
    }
  }

  function applyTransformsToMeshes(root, mtc) {
    var mtcCount = mtc.length

    if (mtcCount < 1) {
      return
    }

    var meshTypes = [
      THREE__namespace.Mesh,
      THREE__namespace.LineSegments,
      THREE__namespace.Line
    ]
    traverseMeshes(root, meshTypes, function (mesh) {
      mesh.applyMatrix4(mtc[0])

      for (var j = 1; j < mtcCount; ++j) {
        var newMesh = new mesh.constructor(mesh.geometry, mesh.material)
        mesh.parent.add(newMesh)
        newMesh.applyMatrix4(mtc[j])
      }
    })
  }

  var processTransparentMaterial = (function () {
    var matValues = {
      prepassTransparancy: true,
      fakeOpacity: false,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false
    }
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return
      }

      traverseMeshes(
        root,
        [THREE__namespace.Mesh, THREE__namespace.LineSegments],
        function (mesh) {
          mesh.material.setValues({
            prepassTransparancy: false,
            fakeOpacity: false
          })
          mesh.material.needsUpdate = true
          mesh.layers.set(gfxutils.LAYERS.TRANSPARENT)
          var prepassTranspMesh = createDerivativeMesh(
            mesh,
            matValues,
            gfxutils.LAYERS.PREPASS_TRANSPARENT
          )
          mesh.parent.add(prepassTranspMesh)
        }
      )
    }
  })()

  var processColFromPosMaterial = (function () {
    var matValues = {
      colorFromPos: true,
      transparent: false,
      colorFromDepth: false,
      lights: false,
      shadowmap: false,
      fog: false,
      overrideColor: false,
      fogTransparent: false,
      attrColor: false,
      attrColor2: false,
      attrAlphaColor: false,
      fakeOpacity: false
    }
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return
      }

      traverseMeshes(
        root,
        [THREE__namespace.Mesh, THREE__namespace.LineSegments],
        function (mesh) {
          var colFromPosMesh = createDerivativeMesh(
            mesh,
            matValues,
            gfxutils.LAYERS.COLOR_FROM_POSITION
          )
          mesh.parent.add(colFromPosMesh)
        }
      )
    }
  })()

  var createShadowmapMaterial = (function () {
    var matValues = {
      colorFromDepth: true,
      orthoCam: true,
      lights: false,
      shadowmap: false,
      fog: false
    }
    return function (root, material) {
      if (!(material instanceof UberMaterial)) {
        return
      }

      traverseMeshes(
        root,
        [THREE__namespace.Mesh, THREE__namespace.LineSegments],
        function (mesh) {
          if (!mesh.receiveShadow && mesh.material.shadowmap) {
            mesh.material.setValues({
              shadowmap: false
            })
          }

          if (!mesh.material.lights) {
            return
          }

          if (!mesh.castShadow) {
            return
          }

          if (!gfxutils.belongToSelectLayers(mesh)) {
            return
          }

          var shadowmapMesh = createDerivativeMesh(
            mesh,
            matValues,
            gfxutils.LAYERS.SHADOWMAP
          )
          shadowmapMesh.isShadowmapMesh = true
          mesh.parent.add(shadowmapMesh)
        }
      )
    }
  })()

  function removeShadowmapMaterial(root, material) {
    if (!(material instanceof UberMaterial)) {
      return
    }

    traverseMeshes(
      root,
      [THREE__namespace.Mesh, THREE__namespace.LineSegments],
      function (mesh) {
        if (mesh.isShadowmapMesh) {
          mesh.parent.remove(mesh)
        }
      }
    )
  }

  function forEachMeshInGroup(group, process) {
    function processObj(object) {
      if (object instanceof THREE__namespace.Mesh) {
        process(object)
      }

      for (var i = 0, l = object.children.length; i < l; i++) {
        processObj(object.children[i])
      }
    }

    processObj(group)
  }

  function _countMeshTriangles(mesh) {
    var geom = mesh.geometry

    if (geom instanceof THREE__namespace.InstancedBufferGeometry) {
      var attribs = geom.attributes

      for (var property in attribs) {
        if (
          attribs.hasOwnProperty(property) &&
          attribs[property] instanceof THREE__namespace.InstancedBufferAttribute
        ) {
          var currAttr = attribs[property]
          var indexSize = geom.index ? geom.index.array.length / 3 : 0
          return (indexSize * currAttr.array.length) / currAttr.itemSize
        }
      }

      return 0
    }

    if (geom instanceof THREE__namespace.BufferGeometry) {
      return geom.index ? geom.index.array.length / 3 : 0
    }

    return geom.faces ? geom.faces.length : 0
  }

  function countTriangles(group) {
    var totalCount = 0
    forEachMeshInGroup(group, function (mesh) {
      totalCount += _countMeshTriangles(mesh)
    })
    return totalCount
  }

  var meshutils = {
    applyTransformsToMeshes: applyTransformsToMeshes,
    processTransparentMaterial: processTransparentMaterial,
    processColFromPosMaterial: processColFromPosMaterial,
    createShadowmapMaterial: createShadowmapMaterial,
    removeShadowmapMaterial: removeShadowmapMaterial,
    forEachMeshInGroup: forEachMeshInGroup,
    countTriangles: countTriangles
  }

  var selectors$3 = chem.selectors

  var Representation = /*#__PURE__*/ (function () {
    function Representation(index, mode, colorer, selector) {
      _classCallCheck(this, Representation)

      var startMaterialValues = {
        clipPlane: settings$1.now.draft.clipPlane,
        fogTransparent: settings$1.now.bg.transparent,
        shadowmap: settings$1.now.shadow.on,
        shadowmapType: settings$1.now.shadow.type
      }
      this.index = index
      this.mode = mode
      this.colorer = colorer
      this.selector = selector
      this.selectorString = ''
      this.count = 0
      this.material = new UberMaterial()
      this.material.setValues(startMaterialValues)
      this.material.setUberOptions({
        fogAlpha: settings$1.now.fogAlpha
      })
      this.materialPreset = materials$1.first
      this.needsRebuild = true
      this.visible = true
      this.setMode(mode)
    }

    _createClass(Representation, [
      {
        key: 'markAtoms',
        value: function markAtoms(complex) {
          this.count = complex.markAtoms(this.selector, 1 << this.index)
          this.needsRebuild = true
          return this.count
        }
      },
      {
        key: 'unmarkAtoms',
        value: function unmarkAtoms(complex) {
          complex.clearAtomBits(1 << this.index)
          this.count = 0
        }
      },
      {
        key: 'setMode',
        value: function setMode(mode) {
          this.mode = mode
        }
      },
      {
        key: 'setMaterialPreset',
        value: function setMaterialPreset(preset) {
          this.materialPreset = preset
          this.material.setUberOptions(preset.uberOptions)
          this.material.setValues(preset.values)
        }
      },
      {
        key: 'reset',
        value: function reset() {
          this.geo = null
          this.selectionGeo = null
        }
      },
      {
        key: 'buildGeometry',
        value: function buildGeometry(complex) {
          this.reset()
          this.needsRebuild = false

          if (settings$1.now.ao) {
            this.material.setValues({
              normalsToGBuffer: settings$1.now.ao
            })
          }

          this.geo = this.mode.buildGeometry(
            complex,
            this.colorer,
            1 << this.index,
            this.material
          )

          if (
            this.material.uberOptions.opacity < 0.99 &&
            settings$1.now.transparency === 'prepass'
          ) {
            meshutils.processTransparentMaterial(this.geo, this.material)
          }

          this.geo.visible = this.visible
          gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id)
          meshutils.processColFromPosMaterial(this.geo, this.material)

          if (settings$1.now.shadow.on) {
            meshutils.createShadowmapMaterial(this.geo, this.material)
          }

          return this.geo
        }
      },
      {
        key: 'buildSelectionGeometry',
        value: function buildSelectionGeometry(mask) {
          var sg = null

          if (this.geo && 'getSubset' in this.geo) {
            var meshes = this.geo.getSubset(mask)

            if (meshes && meshes.length > 0) {
              sg = new THREE__namespace.Group()
              sg.matrixAutoUpdate = false
              sg.matrix = this.geo.matrix

              for (var j = 0; j < meshes.length; j++) {
                var m = meshes[j]
                sg.add(m)
              }
            }
          }

          if (sg) {
            sg.visible = this.visible
          }

          this.selectionGeo = sg
          return this.selectionGeo
        }
      },
      {
        key: 'compare',
        value: function compare(repSettings) {
          var diff = {}
          var selStr = String(this.selector)

          if (
            !repSettings ||
            selStr.valueOf() !== String(repSettings.selector).valueOf()
          ) {
            diff.selector = selStr
          }

          var modeDiff = this.mode.identify()

          if (
            !repSettings ||
            Array.isArray(modeDiff) ||
            modeDiff !== repSettings.mode
          ) {
            diff.mode = modeDiff
          }

          var colorerDiff = this.colorer.identify()

          if (
            !repSettings ||
            Array.isArray(colorerDiff) ||
            colorerDiff !== repSettings.colorer
          ) {
            diff.colorer = colorerDiff
          }

          if (!repSettings || this.materialPreset.id !== repSettings.material) {
            diff.material = this.materialPreset.id
          }

          return diff
        }
      },
      {
        key: 'change',
        value: function change(repSettings, complex, mode, color) {
          var diff = {}

          if (repSettings.selector) {
            var newSelectorObject = selectors$3.parse(
              repSettings.selector
            ).selector
            var newSelector = String(newSelectorObject)

            if (this.selectorString !== newSelector) {
              diff.selector = newSelector
              this.selectorString = newSelector
              this.selector = newSelectorObject
              this.markAtoms(complex)
            }
          }

          if (repSettings.mode) {
            var newMode = repSettings.mode

            if (!___default['default'].isEqual(this.mode.identify(), newMode)) {
              diff.mode = newMode
              this.setMode(mode)
            }
          }

          if (repSettings.colorer) {
            var newColorer = repSettings.colorer

            if (
              !___default['default'].isEqual(
                this.colorer.identify(),
                newColorer
              )
            ) {
              diff.colorer = newColorer
              this.colorer = color
            }
          }

          if (repSettings.material) {
            var newMaterial = repSettings.material

            if (
              !___default['default'].isEqual(
                this.materialPreset.id,
                newMaterial
              )
            ) {
              diff.material = newMaterial
              this.setMaterialPreset(materials$1.get(repSettings.material))
            }
          }

          return diff
        }
      },
      {
        key: 'show',
        value: function show(visible) {
          this.visible = visible

          if (this.geo) {
            this.geo.visible = visible
          }

          if (this.selectionGeo) {
            this.selectionGeo.visible = visible
          }
        }
      }
    ])

    return Representation
  })()

  function _createSuper$z(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$z()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$z() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  function _traverseComponentGroups(root, component, callback) {
    var children = root.children

    if (!children) {
      return
    }

    for (var i = 0, n = children.length; i < n; ++i) {
      var child = children[i]

      if (child._component === component) {
        callback(child)
      }

      if (child instanceof gfxutils.RCGroup) {
        _traverseComponentGroups(child, component, callback)
      }
    }
  }

  function ComplexEditor() {}

  var ComplexComponentEditor = /*#__PURE__*/ (function (_ComplexEditor) {
    _inherits(ComplexComponentEditor, _ComplexEditor)

    var _super = _createSuper$z(ComplexComponentEditor)

    function ComplexComponentEditor(complexVisual) {
      var _this

      _classCallCheck(this, ComplexComponentEditor)

      _this = _super.call(this)
      _this._complexVisual = complexVisual
      _this._inProgress = false
      return _this
    }

    _createClass(ComplexComponentEditor, [
      {
        key: 'begin',
        value: function begin() {
          var complex = this._complexVisual.getComplex()

          this._componentTransforms = []

          for (var i = 0; i < complex._components.length; ++i) {
            var component = complex._components[i]
            this._componentTransforms[component._index] =
              new THREE__namespace.Object3D()
          }

          this._inProgress = true
          return true
        }
      },
      {
        key: 'apply',
        value: function apply() {
          if (!this._inProgress) {
            return
          }

          var complex = this._complexVisual.getComplex()

          for (var i = 0; i < complex._components.length; ++i) {
            this._bakeComponentTransform(complex._components[i])
          }

          complex.onAtomPositionChanged()

          this._resetComponentTransform()

          this._complexVisual.finalizeEdit()
        }
      },
      {
        key: 'discard',
        value: function discard() {
          if (!this._inProgress) {
            return
          }

          this._resetComponentTransform()

          this._complexVisual.finalizeEdit()
        }
      },
      {
        key: 'getAltObj',
        value: function getAltObj() {
          var res = {
            objects: [],
            pivot: new THREE__namespace.Vector3(0, 0, 0)
          }
          var visual = this._complexVisual
          var component = visual.getSelectedComponent()

          if (component === null) {
            return res
          }

          var selection = this._complexVisual.getSelectionGeo()

          var selectionMask = 1 << visual.getSelectionBit()
          var i
          var j
          var reprNode
          var geo

          _traverseComponentGroups(visual, component, function (child) {
            res.objects.push(child)
          })

          for (i = 0; i < selection.children.length; ++i) {
            reprNode = selection.children[i]

            for (j = 0; j < reprNode.children.length; ++j) {
              geo = reprNode.children[j]

              if (
                geo.hasOwnProperty('_component') &&
                geo._component === component
              ) {
                res.objects.push(geo)
              }
            }
          }

          res.objects.push(this._componentTransforms[component._index])
          var bbmin = new THREE__namespace.Vector3(
            Number.MAX_VALUE,
            Number.MAX_VALUE,
            Number.MAX_VALUE
          )
          var bbmax = new THREE__namespace.Vector3(
            -Number.MAX_VALUE,
            -Number.MAX_VALUE,
            -Number.MAX_VALUE
          )
          component.forEachResidue(function (residue) {
            var atoms = residue._atoms

            for (j = 0; j < atoms.length; ++j) {
              if (atoms[j].mask & selectionMask) {
                bbmin.min(atoms[j].position)
                bbmax.max(atoms[j].position)
              }
            }
          })
          res.pivot.lerpVectors(bbmin, bbmax, 0.5)
          return res
        }
      },
      {
        key: '_bakeComponentTransform',
        value: function _bakeComponentTransform(component) {
          var t = this._componentTransforms[component._index]

          if (
            t &&
            (!(
              t.position.x === 0 &&
              t.position.y === 0 &&
              t.position.z === 0
            ) ||
              !(
                t.quaternion.x === 0 &&
                t.quaternion.y === 0 &&
                t.quaternion.z === 0 &&
                t.quaternion.w === 1
              ))
          ) {
            t.updateMatrix()
            component.forEachResidue(function (residue) {
              var atoms = residue._atoms

              for (var j = 0; j < atoms.length; ++j) {
                atoms[j].position.applyMatrix4(t.matrix)
              }
            })
          }
        }
      },
      {
        key: '_resetComponentTransform',
        value: function _resetComponentTransform() {
          var visual = this._complexVisual

          var selection = this._complexVisual.getSelectionGeo()

          var i
          var j
          var reprNode
          var geo

          for (i = 0; i < this._componentTransforms.length; ++i) {
            geo = this._componentTransforms[i]
            geo.position.set(0, 0, 0)
            geo.quaternion.set(0, 0, 0, 1)
          }

          for (i = 0; i < visual.children.length; ++i) {
            reprNode = visual.children[i]

            for (j = 0; j < reprNode.children.length; ++j) {
              geo = reprNode.children[j]

              if (geo.hasOwnProperty('_component')) {
                geo.position.set(0, 0, 0)
                geo.quaternion.set(0, 0, 0, 1)
              }
            }
          }

          for (i = 0; i < selection.children.length; ++i) {
            reprNode = selection.children[i]

            for (j = 0; j < reprNode.children.length; ++j) {
              geo = reprNode.children[j]

              if (geo.hasOwnProperty('_component')) {
                geo.position.set(0, 0, 0)
                geo.quaternion.set(0, 0, 0, 1)
              }
            }
          }
        }
      }
    ])

    return ComplexComponentEditor
  })(ComplexEditor)

  var ComplexFragmentEditor = /*#__PURE__*/ (function (_ComplexEditor2) {
    _inherits(ComplexFragmentEditor, _ComplexEditor2)

    var _super2 = _createSuper$z(ComplexFragmentEditor)

    function ComplexFragmentEditor(complexVisual) {
      var _this2

      _classCallCheck(this, ComplexFragmentEditor)

      _this2 = _super2.call(this)
      _this2._complexVisual = complexVisual
      _this2._inProgress = false
      return _this2
    }

    _createClass(ComplexFragmentEditor, [
      {
        key: 'begin',
        value: function begin() {
          var visual = this._complexVisual

          var selection = this._complexVisual.getSelectionGeo()

          var atoms = this._getSelectionBorderAtoms()

          if (atoms.length < 1 || atoms.length > 2) {
            logger.error('Can only edit fragments with one or two bound atoms.')
            return false
          }

          this._fragmentBoundAtoms = atoms
          var selectionMask = 1 << visual.getSelectionBit()
          visual.disableSubset(selectionMask, true)

          for (var k = 0; k < selection.children.length; ++k) {
            selection.children[k].visible = false
          }

          var pivotPos = atoms[0].position.clone()

          if (atoms.length === 2) {
            pivotPos.lerp(atoms[1].position, 0.5)
          }

          this._fragmentGeo = new THREE__namespace.Group()
          visual.add(this._fragmentGeo)

          this._fragmentGeo.position.copy(pivotPos)

          this._fragmentSelectionGeo = new THREE__namespace.Group()
          selection.add(this._fragmentSelectionGeo)

          this._fragmentSelectionGeo.position.copy(pivotPos)

          var offset = pivotPos.clone()
          offset.negate()

          for (var i = 0; i < visual.children.length; ++i) {
            var g = visual.children[i]

            if (!('getSubset' in g)) {
              continue
            }

            var vg = new THREE__namespace.Group()

            this._fragmentGeo.add(vg)

            var sg = new THREE__namespace.Group()

            this._fragmentSelectionGeo.add(sg)

            var meshes = g.getSubset(selectionMask, true)

            for (var j = 0; j < meshes.length; j++) {
              var m = meshes[j]
              vg.add(m)
              m.position.copy(offset)
            }

            var smeshes = g.getSubset(selectionMask, true)

            for (var h = 0; h < smeshes.length; h++) {
              var sm = smeshes[h]
              sg.add(sm)
              sm.position.copy(offset)
            }
          }

          gfxutils.applySelectionMaterial(this._fragmentSelectionGeo)
          this._inProgress = true
          return true
        }
      },
      {
        key: 'apply',
        value: function apply() {
          if (!this._inProgress) {
            return
          }

          var visual = this._complexVisual
          var selectionBit = visual.getSelectionBit()
          var p = this._fragmentGeo.position

          var m = this._fragmentGeo.matrix.clone()

          m.multiply(
            new THREE__namespace.Matrix4().makeTranslation(-p.x, -p.y, -p.z)
          )

          this._bakeAtomTransform(m, 1 << selectionBit)

          visual.enableSubset(1 << selectionBit, true)
          visual.getComplex().onAtomPositionChanged()
          visual.finalizeEdit()
        }
      },
      {
        key: 'discard',
        value: function discard() {
          if (!this._inProgress) {
            return
          }

          var visual = this._complexVisual

          var selection = this._complexVisual.getSelectionGeo()

          this._fragmentGeo.parent.remove(this._fragmentGeo)

          visual.enableSubset(1 << visual.getSelectionBit(), true)

          for (var i = 0; i < selection.children.length; ++i) {
            var node = selection.children[i]

            if (node.visible) {
              selection.remove(node)
            } else {
              node.visible = true
            }
          }

          visual.finalizeEdit()
        }
      },
      {
        key: 'isFreeRotationAllowed',
        value: function isFreeRotationAllowed() {
          return this._fragmentBoundAtoms.length < 2
        }
      },
      {
        key: 'getAltObj',
        value: function getAltObj() {
          var res = {
            objects: [],
            pivot: new THREE__namespace.Vector3(0, 0, 0)
          }
          res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo)
          var boundAtoms = this._fragmentBoundAtoms

          if (boundAtoms.length === 1) {
            if (boundAtoms[0].bonds.length === 1) {
              var bond = boundAtoms[0].bonds[0]
              res.axis = new THREE__namespace.Vector3().subVectors(
                bond._right.position,
                bond._left.position
              )
              res.axis.normalize()
              res.axis.transformDirection(this._complexVisual.matrixWorld)
            }
          } else if (boundAtoms.length === 2) {
            res.axis = new THREE__namespace.Vector3().subVectors(
              boundAtoms[1].position,
              boundAtoms[0].position
            )
            res.axis.normalize()
            res.axis.transformDirection(this._complexVisual.matrixWorld)
          }

          return res
        }
      },
      {
        key: '_getSelectionBorderAtoms',
        value: function _getSelectionBorderAtoms() {
          var complex = this._complexVisual.getComplex()

          var selectionMask = 1 << this._complexVisual.getSelectionBit()

          var atomHash = {}
          complex.forEachBond(function (bond) {
            if (bond._left.mask & selectionMask) {
              if ((bond._right.mask & selectionMask) === 0) {
                atomHash[bond._left.index] = 1
              }
            } else if (bond._right.mask & selectionMask) {
              atomHash[bond._right.index] = 1
            }
          })
          var atoms = []
          var keys = Object.keys(atomHash)

          for (var i = 0, n = keys.length; i < n; ++i) {
            var idx = keys[i]
            atoms.push(complex._atoms[idx])
          }

          return atoms
        }
      },
      {
        key: '_bakeAtomTransform',
        value: function _bakeAtomTransform(matrix, mask) {
          this._complexVisual.getComplex().forEachAtom(function (atom) {
            if (atom.mask & mask) {
              atom.position.applyMatrix4(matrix)
            }
          })
        }
      }
    ])

    return ComplexFragmentEditor
  })(ComplexEditor)

  var ComplexVisualEdit = {
    ComponentEditor: ComplexComponentEditor,
    FragmentEditor: ComplexFragmentEditor
  }

  function _createSuper$y(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$y()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$y() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var selectors$2 = chem.selectors

  function lookupAndCreate(entityList, specs) {
    if (!Array.isArray(specs)) {
      specs = [specs]
    }

    var _specs = specs,
      _specs2 = _slicedToArray(_specs, 2),
      id = _specs2[0],
      opts = _specs2[1]

    var Entity = entityList.get(id) || entityList.first
    return new Entity(opts)
  }

  var ComplexVisual = /*#__PURE__*/ (function (_Visual) {
    _inherits(ComplexVisual, _Visual)

    var _super = _createSuper$y(ComplexVisual)

    function ComplexVisual(name, dataSource) {
      var _this

      _classCallCheck(this, ComplexVisual)

      _this = _super.call(this, name, dataSource)
      _this._complex = dataSource
      _this._reprList = []
      _this._repr = null
      _this._reprListChanged = true
      _this._selectionBit = 0
      _this._reprUsedBits = 0
      _this._selectionCount = 0
      _this._selectionGeometry = new THREE__namespace.Group()
      return _this
    }

    _createClass(ComplexVisual, [
      {
        key: 'getBoundaries',
        value: function getBoundaries() {
          return this._complex.getBoundaries()
        }
      },
      {
        key: 'release',
        value: function release() {
          if (this._selectionGeometry.parent) {
            this._selectionGeometry.remove(this._selectionGeometry)
          }

          Visual.prototype.release.call(this)
        }
      },
      {
        key: 'getComplex',
        value: function getComplex() {
          return this._complex
        }
      },
      {
        key: 'getSelectionCount',
        value: function getSelectionCount() {
          return this._selectionCount
        }
      },
      {
        key: 'getSelectionGeo',
        value: function getSelectionGeo() {
          return this._selectionGeometry
        }
      },
      {
        key: 'getSelectionBit',
        value: function getSelectionBit() {
          return this._selectionBit
        }
      },
      {
        key: 'getEditor',
        value: function getEditor() {
          return this._editor
        }
      },
      {
        key: 'resetReps',
        value: function resetReps(reps) {
          if (this._complex) {
            this._complex.clearAtomBits(~0)
          }

          this._reprListChanged = true
          this._reprUsedBits = 0
          this._reprList.length = reps.length

          for (var i = 0, n = reps.length; i < n; ++i) {
            var rep = reps[i]
            var selector = void 0
            var selectorString = void 0

            if (typeof rep.selector === 'string') {
              selectorString = rep.selector

              var _selectors$parse = selectors$2.parse(selectorString)

              selector = _selectors$parse.selector
            } else if (typeof rep.selector === 'undefined') {
              selectorString = settings$1.now.presets.default[0].selector

              var _selectors$parse2 = selectors$2.parse(selectorString)

              selector = _selectors$parse2.selector
            } else {
              selector = rep.selector
              selectorString = selector.toString()
            }

            var mode = lookupAndCreate(modes$1, rep.mode)
            var colorer = lookupAndCreate(colorers$1, rep.colorer)
            var material = materials$1.get(rep.material) || materials$1.first
            this._reprList[i] = new Representation(i, mode, colorer, selector)

            this._reprList[i].setMaterialPreset(material)

            this._reprList[i].selectorString = selectorString

            if (this._complex) {
              this._complex.markAtoms(selector, 1 << i)
            }

            this._reprUsedBits |= 1 << i
          }

          this._repr = reps.length > 0 ? this._reprList[0] : null
          this._selectionBit = reps.length
          this._reprUsedBits |= 1 << this._selectionBit
          this._selectionCount = 0

          if (this._complex) {
            this._complex.update()
          }
        }
      },
      {
        key: 'repCount',
        value: function repCount() {
          return this._reprList.length
        }
      },
      {
        key: 'repCurrent',
        value: function repCurrent(index) {
          if (index >= 0 && index < this._reprList.length) {
            this._repr = this._reprList[index]
          } else {
            index = this._reprList.indexOf(this._repr)
          }

          return index
        }
      },
      {
        key: 'rep',
        value: function rep(index, _rep) {
          if (!_rep && (index === undefined || index instanceof Object)) {
            _rep = index
            index = this.repCurrent()
          }

          if (index < 0 || index > this._reprList.length) {
            logger.error('Rep '.concat(index, ' does not exist!'))
            return null
          }

          if (index === this._reprList.length) {
            var res = this.repAdd(_rep)
            logger.warn(
              'Rep '.concat(
                index,
                ' does not exist! New representation was created.'
              )
            )
            return {
              desc: res.desc,
              index: index,
              status: 'created'
            }
          }

          var target = this._reprList[index]
          var desc = {
            selector: target.selectorString,
            mode: target.mode.identify(),
            colorer: target.colorer.identify(),
            material: target.materialPreset.id
          }

          if (_rep) {
            var diff = target.change(
              _rep,
              this._complex,
              lookupAndCreate(modes$1, _rep.mode),
              lookupAndCreate(colorers$1, _rep.colorer)
            )

            if (!___default['default'].isEmpty(diff)) {
              target.needsRebuild = true

              for (var key in diff) {
                if (diff.hasOwnProperty(key)) {
                  desc[key] = diff[key]
                  logger.debug(
                    'rep['
                      .concat(index, '].')
                      .concat(key, ' changed to ')
                      .concat(diff[key])
                  )
                }
              }

              if (
                diff.mode &&
                target.mode.isSurface &&
                (settings$1.now.resolution === 'ultra' ||
                  settings$1.now.resolution === 'high')
              ) {
                logger.report(
                  'Surface resolution was changed to "medium" to avoid hang-ups.'
                )
                settings$1.set('resolution', 'medium')
              }

              return {
                desc: desc,
                index: index,
                status: 'changed'
              }
            }
          }

          return {
            desc: desc,
            index: index,
            status: ''
          }
        }
      },
      {
        key: 'repGet',
        value: function repGet(index) {
          if (index === undefined || index instanceof Object) {
            index = this.repCurrent()
          }

          if (index < 0 || index >= this._reprList.length) {
            return null
          }

          return this._reprList[index]
        }
      },
      {
        key: '_getFreeReprIdx',
        value: function _getFreeReprIdx() {
          var bits = this._reprUsedBits

          for (
            var i = 0;
            i <= ComplexVisual.NUM_REPRESENTATION_BITS;
            ++i, bits >>= 1
          ) {
            if ((bits & 1) === 0) {
              return i
            }
          }

          return -1
        }
      },
      {
        key: 'repAdd',
        value: function repAdd(rep) {
          if (this._reprList.length >= ComplexVisual.NUM_REPRESENTATION_BITS) {
            return null
          }

          var newSelectionBit = this._getFreeReprIdx()

          if (newSelectionBit < 0) {
            return null
          }

          var originalSelection = this.buildSelectorFromMask(
            1 << this._selectionBit
          )
          var def = settings$1.now.presets.default[0]

          var desc = ___default['default'].merge(
            {
              selector: def.selector,
              mode: def.mode,
              colorer: def.colorer,
              material: def.material
            },
            rep
          )

          var selector =
            typeof desc.selector === 'string'
              ? selectors$2.parse(desc.selector).selector
              : desc.selector
          var target = new Representation(
            this._selectionBit,
            lookupAndCreate(modes$1, desc.mode),
            lookupAndCreate(colorers$1, desc.colorer),
            selector
          )
          target.selectorString = selector.toString()
          target.setMaterialPreset(materials$1.get(desc.material))
          target.markAtoms(this._complex)

          this._reprList.push(target)

          this._selectionBit = newSelectionBit
          this._reprUsedBits |= 1 << this._selectionBit

          this._complex.markAtoms(originalSelection, 1 << this._selectionBit)

          return {
            desc: desc,
            index: this._reprList.length - 1
          }
        }
      },
      {
        key: 'repRemove',
        value: function repRemove(index) {
          if (index === undefined) {
            index = this.repCurrent()
          }

          var count = this._reprList.length

          if (index < 0 || index >= count || count <= 1) {
            return
          }

          var target = this._reprList[index]
          target.unmarkAtoms(this._complex)
          this._reprUsedBits &= ~(1 << target.index)

          this._reprList.splice(index, 1)

          if (target === this._repr) {
            --count
            index = index < count ? index : count - 1
            this._repr = this._reprList[index]
          }

          this._reprListChanged = true
        }
      },
      {
        key: 'repHide',
        value: function repHide(index, hide) {
          if (hide === undefined) {
            hide = true
          }

          if (index < 0 || index >= this._reprList.length) {
            return
          }

          var target = this._reprList[index]
          target.show(!hide)
        }
      },
      {
        key: 'select',
        value: function select(selector, append) {
          if (append) {
            this._selectionCount += this._complex.markAtomsAdditionally(
              selector,
              1 << this._selectionBit
            )
          } else {
            this._selectionCount = this._complex.markAtoms(
              selector,
              1 << this._selectionBit
            )
          }

          this._complex.updateStructuresMask()

          this.rebuildSelectionGeometry()
        }
      },
      {
        key: 'resetSelectionMask',
        value: function resetSelectionMask() {
          if (this._selectionCount !== 0) {
            this._selectionCount = 0

            if (this._complex) {
              this._complex.clearAtomBits(1 << this._selectionBit)
            }
          }
        }
      },
      {
        key: 'updateSelectionMask',
        value: function updateSelectionMask(pickedObj) {
          var self = this
          var atom = pickedObj.atom
          var residue = pickedObj.residue,
            chain = pickedObj.chain,
            molecule = pickedObj.molecule
          var setMask = 1 << this._selectionBit
          var clearMask = ~setMask

          if (atom) {
            residue = atom.residue
            chain = residue._chain
            molecule = residue._molecule

            if (atom.mask & setMask) {
              atom.mask &= clearMask
              residue._mask &= clearMask
              chain._mask &= clearMask

              if (molecule) {
                molecule.mask &= clearMask
              }

              this._selectionCount--
            } else {
              atom.mask |= setMask
              this._selectionCount++
              residue.collectMask()
              chain.collectMask()

              if (molecule) {
                molecule.collectMask()
              }
            }
          } else if (residue) {
            chain = residue._chain
            molecule = residue._molecule

            if (residue._mask & setMask) {
              residue._mask &= clearMask
              chain._mask &= clearMask
              residue.forEachAtom(function (a) {
                if (a.mask & setMask) {
                  a.mask &= clearMask
                  self._selectionCount--
                }
              })
            } else {
              residue._mask |= setMask
              residue.forEachAtom(function (a) {
                if (!(a.mask & setMask)) {
                  a.mask |= setMask
                  self._selectionCount++
                }
              })
              chain.collectMask()

              if (molecule) {
                molecule.collectMask()
              }
            }
          } else if (chain || molecule) {
            var obj = chain || molecule

            if (obj._mask & setMask) {
              obj._mask &= clearMask
              obj.forEachResidue(function (r) {
                if (r._mask & setMask) {
                  r._mask &= clearMask
                  r.forEachAtom(function (a) {
                    if (a.mask & setMask) {
                      a.mask &= clearMask
                      self._selectionCount--
                    }
                  })
                  r._mask &= clearMask
                }
              })
            } else {
              obj._mask |= setMask
              obj.forEachResidue(function (r) {
                if (!(r._mask & setMask)) {
                  r._mask |= setMask
                  r.forEachAtom(function (a) {
                    if (!(a.mask & setMask)) {
                      a.mask |= setMask
                      self._selectionCount++
                    }
                  })
                  var otherObj = chain ? r.getMolecule() : r.getChain()

                  if (otherObj) {
                    otherObj.collectMask()
                  }
                }
              })
            }
          } else {
            this.resetSelectionMask()
          }
        }
      },
      {
        key: 'expandSelection',
        value: function expandSelection() {
          var self = this
          var selectionMask = 1 << this._selectionBit
          var tmpMask = 1 << 31

          this._complex.forEachBond(function (bond) {
            if (bond._left.mask & selectionMask) {
              if ((bond._right.mask & selectionMask) === 0) {
                bond._right.mask |= tmpMask
              }
            } else if (bond._right.mask & selectionMask) {
              bond._left.mask |= tmpMask
            }
          })

          var deselectionMask = ~tmpMask

          this._complex.forEachAtom(function (atom) {
            if (atom.mask & tmpMask) {
              atom.mask = (atom.mask & deselectionMask) | selectionMask
              ++self._selectionCount
            }
          })

          this._complex.updateStructuresMask()
        }
      },
      {
        key: 'shrinkSelection',
        value: function shrinkSelection() {
          var self = this
          var selectionMask = 1 << this._selectionBit
          var tmpMask = 1 << 31

          this._complex.forEachBond(function (bond) {
            if (bond._left.mask & selectionMask) {
              if ((bond._right.mask & selectionMask) === 0) {
                bond._left.mask |= tmpMask
              }
            } else if (bond._right.mask & selectionMask) {
              bond._right.mask |= tmpMask
            }
          })

          this._complex.forEachAtom(function (atom) {
            if (atom.mask & selectionMask && atom.bonds.length === 1) {
              atom.mask |= tmpMask
            }
          })

          var deselectionMask = ~(selectionMask | tmpMask)

          this._complex.forEachAtom(function (atom) {
            if (atom.mask & tmpMask) {
              atom.mask &= deselectionMask
              --self._selectionCount
            }
          })

          this._complex.updateStructuresMask()
        }
      },
      {
        key: 'getSelectedComponent',
        value: function getSelectedComponent() {
          var selectionMask = 1 << this._selectionBit
          var component = null
          var multiple = false

          this._complex.forEachAtom(function (atom) {
            if (atom.mask & selectionMask) {
              if (component === null) {
                component = atom.residue._component
              } else if (component !== atom.residue._component) {
                multiple = true
              }
            }
          })

          return multiple ? null : component
        }
      },
      {
        key: 'getSelectionCenter',
        value: function getSelectionCenter(center, includesAtom, selRule) {
          center.set(0.0, 0.0, 0.0)
          var count = 0

          this._complex.forEachAtom(function (atom) {
            if (includesAtom(atom, selRule)) {
              center.add(atom.position)
              count++
            }
          })

          if (count === 0) {
            return false
          }

          center.divideScalar(count)
          center.applyMatrix4(this.matrix)
          return true
        }
      },
      {
        key: 'needsRebuild',
        value: function needsRebuild() {
          if (this._reprListChanged) {
            return true
          }

          var reprList = this._reprList

          for (var i = 0, n = reprList.length; i < n; ++i) {
            var repr = reprList[i]

            if (repr.needsRebuild) {
              return true
            }
          }

          return false
        }
      },
      {
        key: 'rebuild',
        value: function rebuild() {
          var self = this
          gfxutils.clearTree(this)
          return new Promise(function (resolve) {
            var complex = self._complex

            if (!complex) {
              resolve()
              return
            }

            var errorOccured = false
            setTimeout(function () {
              console.time('build')
              var reprList = self._reprList
              var palette =
                palettes$1.get(settings$1.now.palette) || palettes$1.first
              var hasGeometry = false

              for (var i = 0, n = reprList.length; i < n; ++i) {
                var repr = reprList[i]
                repr.colorer.palette = palette

                if (repr.needsRebuild) {
                  repr.reset()

                  try {
                    repr.buildGeometry(complex)
                  } catch (e) {
                    if (e instanceof utils.OutOfMemoryError) {
                      repr.needsRebuild = false
                      repr.reset()
                      logger.error(
                        'Not enough memory to build geometry for representation '.concat(
                          repr.index + 1
                        )
                      )
                      errorOccured = true
                    } else {
                      throw e
                    }
                  }
                }

                hasGeometry =
                  errorOccured ||
                  hasGeometry ||
                  gfxutils.groupHasGeometryToRender(repr.geo)

                if (repr.geo) {
                  self.add(repr.geo)
                }
              }

              self._reprListChanged = false
              console.timeEnd('build')
              resolve()
            }, 10)
          })
        }
      },
      {
        key: 'setNeedsRebuild',
        value: function setNeedsRebuild() {
          var reprList = this._reprList

          for (var i = 0, n = reprList.length; i < n; ++i) {
            reprList[i].needsRebuild = true
          }
        }
      },
      {
        key: 'rebuildSelectionGeometry',
        value: function rebuildSelectionGeometry() {
          var mask = 1 << this._selectionBit
          gfxutils.clearTree(this._selectionGeometry)

          for (var i = 0, n = this._reprList.length; i < n; ++i) {
            var repr = this._reprList[i]
            var sg = repr.buildSelectionGeometry(mask)

            if (!sg) {
              continue
            }

            this._selectionGeometry.add(sg)

            for (var j = 0; j < sg.children.length; j++) {
              var m = sg.children[j]

              if (this._editor && this._editor._componentTransforms) {
                var t = this._editor._componentTransforms[m._component._index]

                if (t) {
                  m.position.copy(t.position)
                  m.quaternion.copy(t.quaternion)
                }
              }
            }

            gfxutils.applySelectionMaterial(sg)
          }
        }
      },
      {
        key: '_buildSelectorFromSortedLists',
        value: function _buildSelectorFromSortedLists(atoms, residues, chains) {
          var complex = this._complex

          function optimizeList(list) {
            var result = []
            var k = 0
            var first = NaN
            var last = NaN

            for (var i = 0, n = list.length; i < n; ++i) {
              var value = list[i]

              if (value === last + 1) {
                last = value
              } else {
                if (!Number.isNaN(first)) {
                  result[k++] = new selectors$2.Range(first, last)
                }

                first = last = value
              }
            }

            if (!Number.isNaN(first)) {
              result[k] = new selectors$2.Range(first, last)
            }

            return result
          }

          var expression = null

          if (chains.length === complex._chains.length) {
            expression = selectors$2.all()
          } else {
            var selector

            if (chains.length > 0) {
              selector = selectors$2.chain(chains)
              expression = expression
                ? selectors$2.or(expression, selector)
                : selector
            }

            if (Object.keys(residues).length > 0) {
              for (var ch in residues) {
                if (residues.hasOwnProperty(ch)) {
                  selector = selectors$2.and(
                    selectors$2.chain(ch),
                    selectors$2.residx(optimizeList(residues[ch]))
                  )
                  expression = expression
                    ? selectors$2.or(expression, selector)
                    : selector
                }
              }
            }

            if (atoms.length > 0) {
              selector = selectors$2.serial(optimizeList(atoms))
              expression = expression
                ? selectors$2.or(expression, selector)
                : selector
            }

            if (!expression) {
              expression = selectors$2.none()
            }
          }

          return expression
        }
      },
      {
        key: 'buildSelectorFromMask',
        value: function buildSelectorFromMask(mask) {
          var complex = this._complex
          var chains = []
          var residues = {}
          var atoms = []
          complex.forEachChain(function (chain) {
            if (chain._mask & mask) {
              chains.push(chain._name)
            }
          })
          complex.forEachResidue(function (residue) {
            if (residue._mask & mask && !(residue._chain._mask & mask)) {
              var c = residue._chain._name

              if (!(c in residues)) {
                residues[c] = [residue._index]
              } else {
                residues[c].push(residue._index)
              }
            }
          })
          complex.forEachAtom(function (atom) {
            if (atom.mask & mask && !(atom.residue._mask & mask)) {
              atoms.push(atom.serial)
            }
          })
          return this._buildSelectorFromSortedLists(atoms, residues, chains)
        }
      },
      {
        key: 'forSelectedResidues',
        value: function forSelectedResidues(process) {
          var selectionMask = 1 << this._selectionBit

          this._complex.forEachResidue(function (residue) {
            if (residue._mask & selectionMask) {
              process(residue)
            }
          })
        }
      },
      {
        key: 'beginComponentEdit',
        value: function beginComponentEdit() {
          if (this._editor) {
            return null
          }

          var editor = new ComplexVisualEdit.ComponentEditor(this)

          if (!editor.begin()) {
            return null
          }

          this._editor = editor
          return editor
        }
      },
      {
        key: 'beginFragmentEdit',
        value: function beginFragmentEdit() {
          if (this._editor) {
            return null
          }

          var editor = new ComplexVisualEdit.FragmentEditor(this)

          if (!editor.begin()) {
            return null
          }

          this._editor = editor
          return editor
        }
      },
      {
        key: 'finalizeEdit',
        value: function finalizeEdit() {
          this._editor = null
        }
      },
      {
        key: 'setMaterialValues',
        value: function setMaterialValues(values) {
          var needTraverse =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false
          var process =
            arguments.length > 2 && arguments[2] !== undefined
              ? arguments[2]
              : undefined

          for (var i = 0, n = this._reprList.length; i < n; ++i) {
            var rep = this._reprList[i]
            rep.material.setValues(values)

            if (needTraverse) {
              rep.geo.traverse(function (object) {
                if (object instanceof THREE__namespace.Mesh) {
                  object.material.setValues(values)

                  if (process !== undefined) {
                    process(object)
                  }

                  object.material.needsUpdate = true
                }
              })
            }
          }
        }
      },
      {
        key: 'setUberOptions',
        value: function setUberOptions(values) {
          for (var i = 0, n = this._reprList.length; i < n; ++i) {
            var rep = this._reprList[i]
            rep.material.setUberOptions(values)
          }
        }
      },
      {
        key: 'within',
        value: function within(selector, radius) {
          var vw = this._complex.getVoxelWorld()

          if (vw === null) {
            return false
          }

          var selectionMask = 1 << this._selectionBit

          this._complex.markAtoms(selector, selectionMask)

          if (vw) {
            vw.forEachAtomWithinDistFromMasked(
              this._complex,
              selectionMask,
              Number(radius),
              function (atom) {
                atom.mask |= selectionMask
              }
            )
          }

          this._selectionCount = this._complex.countAtomsByMask(selectionMask)

          this._complex.updateStructuresMask()

          return this.buildSelectorFromMask(selectionMask)
        }
      }
    ])

    return ComplexVisual
  })(Visual)

  ComplexVisual.NUM_REPRESENTATION_BITS = 30

  var vertexVolumeFaces =
    "varying vec3 pos;\r\n\r\nvoid main() {\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  pos = position.xyz + 0.5;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}"

  var fragmentVolumeFaces =
    'varying vec3 pos;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(pos, 0.5);\r\n}'

  var vertexVolume =
    'varying vec4 screenSpacePos;\r\n\r\nvoid main() {\r\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = screenSpacePos;\r\n}'

  var fragmentVolume =
    "uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r\n\r\nuniform vec3 _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\n#define NO_COLOR vec4(0., 0., 0., 0.)\r\n\r\nvec4 sample3DTexture(vec3 texCoord) {\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r\n  vec3 textCoord = boxCoord;\r\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r\n\r\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r\n    return NO_COLOR;\r\n\r\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r\n\r\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r\n    return NO_COLOR;\r\n\r\n  return sample3DTexture(textCoord);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir) {\r\n  float d = 1. / 128.;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n\r\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r\n  vec3 coordInc = mix(\r\n    vec3(\r\n      sample3DTextureInclined(iter + dx).x,\r\n      sample3DTextureInclined(iter + dy).x,\r\n      sample3DTextureInclined(iter + dz).x\r\n    ),\r\n    vec3(0. ,0. , 0.),\r\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r\n  );\r\n\r\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r\n  vec3 coordDec = mix(\r\n    vec3(0. ,0. , 0.),\r\n    vec3(\r\n      sample3DTextureInclined(iter - dx).x,\r\n      sample3DTextureInclined(iter - dy).x,\r\n      sample3DTextureInclined(iter - dz).x\r\n    ),\r\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r\n  );\r\n\r\n  vec3 N = normalize(coordInc - coordDec);\r\n  float dif = max(0.0, dot(N, dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r\n  for (int i = 0; i < 5; i++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\r\n  for (int j = 0; j < 5; j++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r\n  vec3 step = stepSize * dir, iterator = start, left, right;\r\n  vec4 acc = NO_COLOR;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    iterator = iterator + step;\r\n    vol = sample3DTextureInclined(iterator).r;\r\n    if (length(iterator - back) <= stepSize || (vol > tr))\r\n      break;\r\n  }\r\n\r\n  if (vol > tr)\r\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r\n\r\n  return acc;\r\n}\r\n\r\nfloat easeOut(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return 1.0 - (1.0 - t) * (1.0 - t);\r\n}\r\n\r\nfloat easeIn(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return t * t;\r\n}\r\n\r\nvec3 GetColSimple(float vol) {\r\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 acc = NO_COLOR, iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r\n  vec3 step, col, colOld, right;\r\n  float tr0 = _isoLevel0.x;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n\r\n  for (int k = 0; k < 3; k++) {\r\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r\n    kd = 140. * tr0 * stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize * dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r\n      break;\r\n    iterator = iso.xyz;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetColSimple(tr0);\r\n    curStepSize = stepSize;\r\n    for (int i = 0; i < STEPS_COUNT; i++) {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTextureInclined(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetColSimple(vol);\r\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r\n      vec3 colMid = GetColSimple(vol);\r\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n\r\n    if (molD > molDist) {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist) * dir;\r\n      vol = sample3DTextureInclined(right).r;\r\n    } else {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n\r\n    alpha = (1. - r) * curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetColSimple(vol);\r\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r\n    vec3 colMid = GetColSimple(vol);\r\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1. * sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  float stepSize = 1.0 / float(STEPS_COUNT);\r\n  float len = length(back - start);\r\n  vec3 step = stepSize * dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    if (float(i) * stepSize > len)\r\n      break;\r\n    iterator = iterator + step;\r\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r\n  }\r\n\r\n  return vec4(1.,1.,1., acc);\r\n}\r\n\r\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r\n  vec4 col = NO_COLOR;\r\n\r\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r\n    float dif =  CalcColor(tst.xyz, dir);\r\n    dif = 0.9 * dif * dif;\r\n    col = vec4(dif, dif, dif, 1);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main() {\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0) {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  } else {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001) {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  #ifdef ISO_MODE\r\n    gl_FragColor = IsoRender(start, back, molDist, dir);\r\n  #else\r\n    gl_FragColor = VolRender(start, back, molDist, dir);\r\n  #endif\r\n}\r\n"

  var vertexFarPlane =
    "varying vec4 volPos;\r\nuniform float aspectRatio;\r\nuniform float farZ;\r\nuniform float tanHalfFOV;\r\nuniform mat4  matWorld2Volume;\r\n\r\nvoid main() {\r\n  // rescale plane to fill in the whole far plane area seen from camera\r\n  vec3 pos = position.xyz;\r\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r\n  pos.y = pos.y * tanHalfFOV * farZ;\r\n  // common transformation\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  // calc pos in volume CS\r\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  volPos = volPos + 0.5;\r\n  volPos.w = 0.5;\r\n}\r\n"

  var fragmentFarPlane =
    'varying vec4 volPos;\r\n\r\nvoid main() {\r\n  gl_FragColor = volPos;\r\n}'

  function _createSuper$x(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$x()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$x() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var volumeUniforms = THREE__namespace.UniformsUtils.merge([
    {
      volumeDim: {
        type: 'v3',
        value: new THREE__namespace.Vector3(512, 512, 512)
      },
      tileTex: {
        type: 't',
        value: null
      },
      tileTexSize: {
        type: 'v2',
        value: new THREE__namespace.Vector2(512, 512)
      },
      tileStride: {
        type: 'v2',
        value: new THREE__namespace.Vector2(512, 512)
      },
      boxAngles: {
        type: 'v3',
        value: new THREE__namespace.Vector3(1, 1, 1)
      },
      delta: {
        type: 'v3',
        value: new THREE__namespace.Vector3(0, 0, 0)
      },
      _isoLevel0: {
        type: 'v2',
        value: new THREE__namespace.Vector3(0.5, 0.75, 1.0)
      },
      _flipV: {
        type: 'f',
        value: 0.0
      },
      _BFLeft: {
        type: 't',
        value: null
      },
      _BFRight: {
        type: 't',
        value: null
      },
      _FFLeft: {
        type: 't',
        value: null
      },
      _FFRight: {
        type: 't',
        value: null
      },
      _WFFLeft: {
        type: 't',
        value: null
      },
      _WFFRight: {
        type: 't',
        value: null
      }
    }
  ])

  function overrideUniforms(params, defUniforms) {
    var uniforms = THREE__namespace.UniformsUtils.clone(defUniforms)

    for (var p in params) {
      if (uniforms.hasOwnProperty(p)) {
        uniforms[p].value = params[p]
      }
    }

    return uniforms
  }

  function facesPosMaterialParams(params, sideType) {
    return {
      uniforms: overrideUniforms(params, {}),
      vertexShader: vertexVolumeFaces,
      fragmentShader: fragmentVolumeFaces,
      transparent: false,
      depthTest: false,
      depthWrite: false,
      side: sideType
    }
  }

  var BackFacePosMaterial = /*#__PURE__*/ (function (_THREE$ShaderMaterial) {
    _inherits(BackFacePosMaterial, _THREE$ShaderMaterial)

    var _super = _createSuper$x(BackFacePosMaterial)

    function BackFacePosMaterial(params) {
      _classCallCheck(this, BackFacePosMaterial)

      var backFaceParams = facesPosMaterialParams(
        params,
        THREE__namespace.BackSide
      )
      return _super.call(this, backFaceParams)
    }

    return _createClass(BackFacePosMaterial)
  })(THREE__namespace.ShaderMaterial)

  var ShaderParams = /*#__PURE__*/ _createClass(function ShaderParams(
    params,
    uniforms,
    vertexShader,
    fragmentShader
  ) {
    _classCallCheck(this, ShaderParams)

    this.uniforms = overrideUniforms(params, uniforms)
    this.vertexShader = vertexShader
    this.fragmentShader = fragmentShader
    this.transparent = false
    this.depthTest = false
    this.depthWrite = false
    this.side = THREE__namespace.FrontSide
  })

  var BackFacePosMaterialFarPlane = /*#__PURE__*/ (function (
    _THREE$ShaderMaterial2
  ) {
    _inherits(BackFacePosMaterialFarPlane, _THREE$ShaderMaterial2)

    var _super2 = _createSuper$x(BackFacePosMaterialFarPlane)

    function BackFacePosMaterialFarPlane(params) {
      _classCallCheck(this, BackFacePosMaterialFarPlane)

      var matUniforms = THREE__namespace.UniformsUtils.merge([
        {
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          farZ: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          matWorld2Volume: {
            type: '4fv',
            value: new THREE__namespace.Matrix4()
          }
        }
      ])
      var shaderParams = new ShaderParams(
        params,
        matUniforms,
        vertexFarPlane,
        fragmentFarPlane
      )
      return _super2.call(this, shaderParams)
    }

    return _createClass(BackFacePosMaterialFarPlane)
  })(THREE__namespace.ShaderMaterial)

  var FrontFacePosMaterial = /*#__PURE__*/ (function (_THREE$ShaderMaterial3) {
    _inherits(FrontFacePosMaterial, _THREE$ShaderMaterial3)

    var _super3 = _createSuper$x(FrontFacePosMaterial)

    function FrontFacePosMaterial(params) {
      _classCallCheck(this, FrontFacePosMaterial)

      var frontFaceParams = facesPosMaterialParams(
        params,
        THREE__namespace.FrontSide
      )
      return _super3.call(this, frontFaceParams)
    }

    return _createClass(FrontFacePosMaterial)
  })(THREE__namespace.ShaderMaterial)

  var VolumeMaterial = /*#__PURE__*/ (function (_THREE$ShaderMaterial4) {
    _inherits(VolumeMaterial, _THREE$ShaderMaterial4)

    var _super4 = _createSuper$x(VolumeMaterial)

    function VolumeMaterial(params) {
      var _this

      _classCallCheck(this, VolumeMaterial)

      var shaderParams = new ShaderParams(
        params,
        volumeUniforms,
        vertexVolume,
        fragmentVolume
      )
      shaderParams.transparent = true
      shaderParams.depthTest = true
      _this = _super4.call(this, shaderParams)

      _this.updateDefines()

      return _this
    }

    _createClass(VolumeMaterial, [
      {
        key: 'updateDefines',
        value: function updateDefines() {
          this.defines = {
            ISO_MODE: settings$1.now.modes.VD.isoMode,
            STEPS_COUNT:
              settings$1.now.modes.VD.polyComplexity[
                settings$1.now.resolution
              ] * 100
          }
          this.needsUpdate = true
        }
      }
    ])

    return VolumeMaterial
  })(THREE__namespace.ShaderMaterial)

  var VolumeMaterial$1 = {
    BackFacePosMaterial: BackFacePosMaterial,
    BackFacePosMaterialFarPlane: BackFacePosMaterialFarPlane,
    FrontFacePosMaterial: FrontFacePosMaterial,
    VolumeMaterial: VolumeMaterial
  }

  function _createSuper$w(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$w()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$w() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var VolumeMesh = /*#__PURE__*/ (function (_THREE$Mesh) {
    _inherits(VolumeMesh, _THREE$Mesh)

    var _super = _createSuper$w(VolumeMesh)

    function VolumeMesh() {
      var _this

      _classCallCheck(this, VolumeMesh)

      var geo = new THREE__namespace.BufferGeometry()
      _this = _super.call(this, geo)

      _defineProperty(_assertThisInitialized(_this), 'volumeInfo', {})

      _this.clipPlane = new THREE__namespace.Plane()
      var size = new THREE__namespace.Vector3(0.5, 0.5, 0.5)
      _this.size = size
      _this.cullFlag = [
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        false
      ]
      _this.faces = [
        {
          indices: [],
          norm: new THREE__namespace.Vector3(0, 0, -1)
        },
        {
          indices: [],
          norm: new THREE__namespace.Vector3(0, 0, 1)
        },
        {
          indices: [],
          norm: new THREE__namespace.Vector3(0, -1, 0)
        },
        {
          indices: [],
          norm: new THREE__namespace.Vector3(0, 1, 0)
        },
        {
          indices: [],
          norm: new THREE__namespace.Vector3(-1, 0, 0)
        },
        {
          indices: [],
          norm: new THREE__namespace.Vector3(1, 0, 0)
        },
        {
          indices: [],
          norm: new THREE__namespace.Vector3(0, 0, 0)
        }
      ]
      _this.vertices = [
        new THREE__namespace.Vector3(-size.x, -size.y, -size.z),
        new THREE__namespace.Vector3(-size.x, size.y, -size.z),
        new THREE__namespace.Vector3(size.x, -size.y, -size.z),
        new THREE__namespace.Vector3(size.x, size.y, -size.z),
        new THREE__namespace.Vector3(-size.x, -size.y, size.z),
        new THREE__namespace.Vector3(-size.x, size.y, size.z),
        new THREE__namespace.Vector3(size.x, -size.y, size.z),
        new THREE__namespace.Vector3(size.x, size.y, size.z),
        new THREE__namespace.Vector3(0.0, 0.0, 0.0),
        new THREE__namespace.Vector3(0.0, 0.0, 0.0),
        new THREE__namespace.Vector3(0.0, 0.0, 0.0),
        new THREE__namespace.Vector3(0.0, 0.0, 0.0),
        new THREE__namespace.Vector3(0.0, 0.0, 0.0),
        new THREE__namespace.Vector3(0.0, 0.0, 0.0)
      ]
      geo.setAttribute(
        'position',
        new THREE__namespace.BufferAttribute(
          new Float32Array(_this.vertices.length * 3),
          3
        )
      )
      _this.name = 'VolumeMesh'
      return _this
    }

    _createClass(VolumeMesh, [
      {
        key: '_updateVertices',
        value: function _updateVertices() {
          var corners = VolumeMesh._corners
          var edges = VolumeMesh._edges
          var edgeIntersections = VolumeMesh._edgeIntersections
          var i
          var norm = this.clipPlane.normal
          var D = this.clipPlane.constant
          var vert = this.vertices
          var size = this.size
          var cornerMark = [0, 0, 0, 0, 0, 0, 0, 0]
          var edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
          var curEdge = new THREE__namespace.Vector3()
          var curEdgeInter = null

          function CheckX() {
            if (norm.x === 0) return 0
            var x = -(norm.dot(curEdge) + D) / norm.x

            if (-size.x <= x && x <= size.x) {
              curEdgeInter.set(x, curEdge.y, curEdge.z)
              if (x === size.x) return 2
              if (x === -size.x) return -2
              return 1
            }

            return 0
          }

          function CheckY() {
            if (norm.y === 0) return 0
            var y = -(norm.dot(curEdge) + D) / norm.y

            if (-size.y <= y && y <= size.y) {
              curEdgeInter.set(curEdge.x, y, curEdge.z)
              if (y === size.y) return 2
              if (y === -size.y) return -2
              return 1
            }

            return 0
          }

          function CheckZ() {
            if (norm.z === 0) return 0
            var z = -(norm.dot(curEdge) + D) / norm.z

            if (-size.z <= z && z <= size.z) {
              curEdgeInter.set(curEdge.x, curEdge.y, z)
              if (z === size.z) return 2
              if (z === -size.z) return -2
              return 1
            }

            return 0
          }

          for (var curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
            var curEdgeSource = edges[curEdgeIdx]
            curEdgeInter = edgeIntersections[curEdgeIdx]
            curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4])
            curEdge.multiply(size)
            var flag = 0
            if (curEdgeSource[2] === 0) flag = CheckX()
            if (curEdgeSource[3] === 0) flag = CheckY()
            if (curEdgeSource[4] === 0) flag = CheckZ()

            if (flag === -2) {
              cornerMark[curEdgeSource[0]] = 1
            } else if (flag === 2) {
              cornerMark[curEdgeSource[1]] = 1
            } else if (flag === 0) {
              edgeMark[curEdgeIdx] = 0
            }
          }

          var face = {
            indices: [],
            norm: norm.clone().negate()
          }
          var nextVertex = 8

          for (i = 0; i < 8; ++i) {
            if (cornerMark[i] === 1) {
              vert[nextVertex]
                .set(corners[i][0], corners[i][1], corners[i][2])
                .multiply(size)
              face.indices.push(nextVertex++)
              edgeMark[corners[i][3]] = 0
              edgeMark[corners[i][4]] = 0
              edgeMark[corners[i][5]] = 0
            }
          }

          for (i = 0; i < 12; ++i) {
            if (edgeMark[i] === 1) {
              vert[nextVertex].copy(edgeIntersections[i])
              face.indices.push(nextVertex++)
            }
          }

          this.faces[6] = face
          var diff = new THREE__namespace.Vector3()
          var coplanarPoint = new THREE__namespace.Vector3()
          this.clipPlane.coplanarPoint(coplanarPoint)

          for (i = 0; i < vert.length; ++i) {
            this.cullFlag[i] = false

            if (i < 8) {
              diff.subVectors(vert[i], coplanarPoint)
              this.cullFlag[i] = norm.dot(diff) >= 0.0
            } else if (i < 8 + face.indices.length) {
              this.cullFlag[i] = true
            }
          }

          var positions = this.geometry.getAttribute('position')
          var idx = 0

          for (i = 0; i < vert.length; ++i) {
            positions.array[idx++] = vert[i].x
            positions.array[idx++] = vert[i].y
            positions.array[idx++] = vert[i].z
          }

          positions.needsUpdate = true
        }
      },
      {
        key: '_collectVertices',
        value: function _collectVertices(face, filter) {
          var i
          var vert = this.vertices
          face.indices = []

          for (i = 0; i < vert.length; ++i) {
            if (this.cullFlag[i] && filter(vert[i])) {
              face.indices.push(i)
            }
          }
        }
      },
      {
        key: '_sortIndices',
        value: function _sortIndices(face, right) {
          var i
          var j
          var vert = this.vertices
          var angle = []
          var dir = new THREE__namespace.Vector3()

          for (i = 1; i < face.indices.length; ++i) {
            dir.subVectors(vert[face.indices[i]], vert[face.indices[0]])
            dir.normalize()
            dir.cross(right)
            dir.negate()
            angle[i] = face.norm.dot(dir)
          }

          for (i = 1; i < face.indices.length - 1; ++i) {
            for (j = i + 1; j < face.indices.length; ++j) {
              if (angle[j] < angle[i]) {
                var t = angle[i]
                angle[i] = angle[j]
                angle[j] = t
                t = face.indices[i]
                face.indices[i] = face.indices[j]
                face.indices[j] = t
              }
            }
          }
        }
      },
      {
        key: '_updateIndices',
        value: function _updateIndices() {
          var i
          var faceIdx
          var face
          var vert = this.vertices
          var size = this.size

          this._collectVertices(this.faces[0], function (vertex) {
            return vertex.z === -size.z
          })

          this._collectVertices(this.faces[1], function (vertex) {
            return vertex.z === size.z
          })

          this._collectVertices(this.faces[2], function (vertex) {
            return vertex.y === -size.y
          })

          this._collectVertices(this.faces[3], function (vertex) {
            return vertex.y === size.y
          })

          this._collectVertices(this.faces[4], function (vertex) {
            return vertex.x === -size.x
          })

          this._collectVertices(this.faces[5], function (vertex) {
            return vertex.x === size.x
          })

          var vCenter = new THREE__namespace.Vector3()
          var vRight = new THREE__namespace.Vector3()
          var vDir = new THREE__namespace.Vector3()

          for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
            face = this.faces[faceIdx]
            if (face.indices.length === 0) continue
            vCenter.set(0, 0, 0)

            for (i = 0; i < face.indices.length; ++i) {
              vCenter.add(vert[face.indices[i]])
            }

            vCenter.multiplyScalar(1.0 / face.indices.length)
            vRight.subVectors(vert[face.indices[0]], vCenter)
            vRight.normalize()
            var rightProj = []

            for (i = 0; i < face.indices.length; ++i) {
              vDir.subVectors(vert[face.indices[i]], vCenter)
              rightProj[i] = vDir.dot(vRight)
            }

            for (i = 1; i < face.indices.length; ++i) {
              if (rightProj[i] < rightProj[0]) {
                var t = rightProj[0]
                rightProj[0] = rightProj[i]
                rightProj[i] = t

                var _face$indices = _slicedToArray(face.indices, 1)

                t = _face$indices[0]
                face.indices[0] = face.indices[i]
                face.indices[i] = t
              }
            }

            this._sortIndices(face, vRight)
          }

          var numIndices = 0

          for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
            face = this.faces[faceIdx]

            if (face.indices.length >= 3) {
              numIndices += 3 * (face.indices.length - 2)
            }
          }

          var offset = 0
          var indices = new Uint16Array(numIndices)

          for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
            face = this.faces[faceIdx]

            for (i = 0; i < face.indices.length - 2; ++i) {
              indices[offset] = face.indices[0]
              indices[offset + 1] = face.indices[i + 1]
              indices[offset + 2] = face.indices[i + 2]
              offset += 3
            }
          }

          this.geometry.setIndex(
            new THREE__namespace.BufferAttribute(indices, 1)
          )
        }
      },
      {
        key: 'setDataSource',
        value: function setDataSource(dataSource) {
          var vm = new VolumeMaterial$1.VolumeMaterial()
          var dim = dataSource.getDimensions()
          var stride = dataSource.getTiledTextureStride()
          var texture = dataSource.buildTiledTexture()
          var bbox = dataSource.getBox()
          vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2])
          vm.uniforms.tileTex.value = texture
          vm.uniforms.tileTexSize.value.set(
            texture.image.width,
            texture.image.height
          )
          vm.uniforms.tileStride.value.set(stride[0], stride[1])
          Object.assign(this.volumeInfo, dataSource.getVolumeInfo())
          var volInfo = this.volumeInfo
          vm.uniforms.delta.value.copy(volInfo.delta)
          vm.uniforms.boxAngles.value.set(
            volInfo.obtuseAngle[0],
            volInfo.obtuseAngle[1],
            volInfo.obtuseAngle[2]
          )
          this.material = vm
          bbox.getSize(this.scale)
          bbox.getCenter(this.position)
        }
      },
      {
        key: '_updateIsoLevel',
        value: function _updateIsoLevel() {
          var _settings$now$modes$V = settings$1.now.modes.VD,
            kSigma = _settings$now$modes$V.kSigma,
            kSigmaMed = _settings$now$modes$V.kSigmaMed,
            kSigmaMax = _settings$now$modes$V.kSigmaMax
          var volInfo = this.volumeInfo
          var mean = volInfo.dmean - volInfo.dmin
          var span = volInfo.dmax - volInfo.dmin

          var level = function level(k) {
            return (mean + k * volInfo.sd) / span
          }

          this.material.uniforms._isoLevel0.value.set(
            level(kSigma),
            level(kSigmaMed),
            level(kSigmaMax)
          )
        }
      },
      {
        key: 'rebuild',
        value: function rebuild(camera) {
          var nearClipPlaneOffset = VolumeMesh._nearClipPlaneOffset
          var pos = VolumeMesh._pos
          var norm = VolumeMesh._norm
          var norm4D = VolumeMesh._norm4D
          var matrixWorldToLocal = VolumeMesh._matrixWorldToLocal
          var clipPlane = VolumeMesh._clipPlane

          this._updateIsoLevel()

          camera.getWorldDirection(norm)
          camera.getWorldPosition(pos)
          pos.addScaledVector(norm, camera.near + nearClipPlaneOffset)
          matrixWorldToLocal.copy(this.matrixWorld).invert()
          pos.applyMatrix4(matrixWorldToLocal)
          norm4D.set(norm.x, norm.y, norm.z, 0.0)
          norm4D.applyMatrix4(matrixWorldToLocal)
          norm.copy(norm4D)
          norm.normalize()
          clipPlane.setFromNormalAndCoplanarPoint(norm, pos)

          if (!this.clipPlane.equals(clipPlane)) {
            this.clipPlane = clipPlane.clone()

            this._updateVertices()

            this._updateIndices()
          }
        }
      }
    ])

    return VolumeMesh
  })(THREE__namespace.Mesh)

  _defineProperty(VolumeMesh, '_corners', [
    [-1, -1, -1, 0, 4, 8],
    [1, -1, -1, 0, 5, 9],
    [1, 1, -1, 1, 5, 10],
    [-1, 1, -1, 1, 4, 11],
    [-1, -1, 1, 2, 6, 8],
    [1, -1, 1, 2, 7, 9],
    [1, 1, 1, 3, 7, 10],
    [-1, 1, 1, 3, 6, 11]
  ])

  _defineProperty(VolumeMesh, '_edges', [
    [0, 1, 0, -1, -1],
    [2, 3, 0, 1, -1],
    [4, 5, 0, -1, 1],
    [6, 7, 0, 1, 1],
    [0, 3, -1, 0, -1],
    [1, 2, 1, 0, -1],
    [4, 7, -1, 0, 1],
    [5, 6, 1, 0, 1],
    [0, 4, -1, -1, 0],
    [1, 5, 1, -1, 0],
    [2, 6, -1, 1, 0],
    [3, 7, 1, 1, 0]
  ])

  _defineProperty(
    VolumeMesh,
    '_edgeIntersections',
    (function () {
      var edgeIntersections = []

      for (var j = 0; j < 12; ++j) {
        edgeIntersections.push(new THREE__namespace.Vector3())
      }

      return edgeIntersections
    })()
  )

  _defineProperty(VolumeMesh, '_nearClipPlaneOffset', 0.2)

  _defineProperty(VolumeMesh, '_pos', new THREE__namespace.Vector3())

  _defineProperty(VolumeMesh, '_norm', new THREE__namespace.Vector3())

  _defineProperty(VolumeMesh, '_norm4D', new THREE__namespace.Vector4())

  _defineProperty(
    VolumeMesh,
    '_matrixWorldToLocal',
    new THREE__namespace.Matrix4()
  )

  _defineProperty(VolumeMesh, '_clipPlane', new THREE__namespace.Plane())

  function _flattenArray(input) {
    var n = input.length
    var output = new Float32Array(n * 3)

    for (var i = 0; i < n; ++i) {
      var j = 3 * i
      var v = input[i]
      output[j] = v.x
      output[j + 1] = v.y
      output[j + 2] = v.z
    }

    return output
  }

  var VolumeBounds = /*#__PURE__*/ (function () {
    function VolumeBounds(bBox, volInfo) {
      _classCallCheck(this, VolumeBounds)

      var delta = volInfo.delta
      var obtuseAngle = volInfo.obtuseAngle
      var bSize = new THREE__namespace.Vector3()
      bBox.getSize(bSize)
      bSize.multiplyScalar(0.5)

      var offsetVert = this._getBaseVertices(delta, obtuseAngle)

      var geometry = new THREE__namespace.BufferGeometry()
      var vertices = []

      for (var i = 0; i < 4; i++) {
        vertices.push(offsetVert[i].clone().multiply(bSize))
        vertices.push(offsetVert[(i + 1) % 4].clone().multiply(bSize))
      }

      var translation = new THREE__namespace.Vector3(
        2 * bSize.x * (1 - delta.x - delta.y),
        0,
        0
      )

      for (var _i = 0; _i < 8; _i++) {
        vertices.push(vertices[_i].clone().add(translation))
      }

      for (var _i2 = 0; _i2 < 4; _i2++) {
        vertices.push(vertices[_i2 * 2].clone())
        vertices.push(vertices[_i2 * 2 + 8].clone())
      }

      var center = new THREE__namespace.Vector3()
      bBox.getCenter(center)
      vertices.forEach(function (vertex) {
        return vertex.add(center)
      })

      var flatVertices = _flattenArray(vertices)

      geometry.setAttribute(
        'position',
        new THREE__namespace.BufferAttribute(flatVertices, 3)
      )
      this._lines = new THREE__namespace.LineSegments(
        geometry,
        new THREE__namespace.LineBasicMaterial({
          color: 0xffffff
        })
      )

      this._lines.layers.set(gfxutils.LAYERS.VOLUME)
    }

    _createClass(VolumeBounds, [
      {
        key: '_getBaseVertices',
        value: function _getBaseVertices(delta, obtuseAngle) {
          var projTable = VolumeBounds._projectionTable

          var proj = function proj(index, inv) {
            var currDelta = delta[projTable[index][0]]
            var angleValue =
              -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]]
            return angleValue * currDelta
          }

          var offsetVert = [
            new THREE__namespace.Vector3(
              -1 + 2 * (proj('XZ', 1) + proj('XY', 1)),
              -1 + 2 * proj('YZ', 1),
              -1
            ),
            new THREE__namespace.Vector3(
              -1 + 2 * (proj('XZ', -1) + proj('XY', 1)),
              -1 + 2 * proj('YZ', -1),
              1
            ),
            new THREE__namespace.Vector3(
              -1 + 2 * (proj('XZ', -1) + proj('XY', -1)),
              1 - 2 * proj('YZ', 1),
              1
            ),
            new THREE__namespace.Vector3(
              -1 + 2 * (proj('XZ', 1) + proj('XY', -1)),
              1 - 2 * proj('YZ', -1),
              -1
            )
          ]
          return offsetVert
        }
      },
      {
        key: 'getMesh',
        value: function getMesh() {
          return this._lines
        }
      }
    ])

    return VolumeBounds
  })()

  _defineProperty(VolumeBounds, '_projectionTable', {
    XY: ['x', 2],
    XZ: ['y', 1],
    YZ: ['z', 0]
  })

  var VolumeFarPlane = /*#__PURE__*/ (function () {
    function VolumeFarPlane(volume, width, height) {
      _classCallCheck(this, VolumeFarPlane)

      var planeGeo = this._initPlaneGeo(width, height)

      var mat = new VolumeMaterial$1.BackFacePosMaterialFarPlane()
      this._plane = new meshes.Mesh(planeGeo, mat)
      this._plane.frustumCulled = false
      this._plane.doubleSided = true
      var matWorldToVolume = new THREE__namespace.Matrix4()

      this._plane._onBeforeRender = function (
        _renderer,
        _scene,
        camera,
        _geometry,
        _material,
        _group
      ) {
        var material = this.material

        if (!volume || !material) {
          return
        }

        var planeCamPos = new THREE__namespace.Vector4(
          0,
          0,
          -(camera.far - 0.1),
          1
        )
        planeCamPos.applyMatrix4(camera.matrixWorld)
        this.matrix.identity()
        this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z)
        this.matrixWorld.copy(this.matrix)
        this.modelViewMatrix.multiplyMatrices(
          camera.matrixWorldInverse,
          this.matrixWorld
        )
        this.normalMatrix.getNormalMatrix(this.modelViewMatrix)
        var volumeMatrix = volume.matrixWorld
        matWorldToVolume.copy(volumeMatrix).invert()
        material.uniforms.aspectRatio.value = camera.aspect
        material.uniforms.farZ.value = camera.far
        material.uniforms.tanHalfFOV.value = Math.tan(
          THREE__namespace.MathUtils.DEG2RAD * 0.5 * camera.fov
        )
        material.uniforms.matWorld2Volume.value = matWorldToVolume
      }

      this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE)
    }

    _createClass(VolumeFarPlane, [
      {
        key: '_initPlaneGeo',
        value: function _initPlaneGeo(width, height) {
          var planeGeo = new THREE__namespace.BufferGeometry()
          width = width || 1
          height = height || 1
          var vertices = new Float32Array([
            -0.5 * width,
            0.5 * height,
            0,
            0.5 * width,
            0.5 * height,
            0,
            -0.5 * width,
            -0.5 * height,
            0,
            0.5 * width,
            -0.5 * height,
            0
          ])
          planeGeo.setAttribute(
            'position',
            new THREE__namespace.BufferAttribute(vertices, 3)
          )
          planeGeo.setIndex([0, 2, 1, 2, 3, 1])
          return planeGeo
        }
      },
      {
        key: 'getMesh',
        value: function getMesh() {
          return this._plane
        }
      }
    ])

    return VolumeFarPlane
  })()

  function _createSuper$v(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$v()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$v() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var VolumeVisual = /*#__PURE__*/ (function (_Visual) {
    _inherits(VolumeVisual, _Visual)

    var _super = _createSuper$v(VolumeVisual)

    function VolumeVisual(name, dataSource) {
      var _this

      _classCallCheck(this, VolumeVisual)

      _this = _super.call(this, name, dataSource)
      _this._mesh = new VolumeMesh()

      _this._mesh.setDataSource(dataSource)

      _this.add(_this._mesh)

      _this._frame = new VolumeBounds(
        _this.getBoundaries().boundingBox,
        _this._mesh.volumeInfo
      )

      _this.add(_this._frame.getMesh())

      _this.showFrame(settings$1.now.modes.VD.frame)

      _this._farPlane = new VolumeFarPlane(_this._mesh, 2, 2)

      _this.add(_this._farPlane.getMesh())

      return _this
    }

    _createClass(VolumeVisual, [
      {
        key: 'getBoundaries',
        value: function getBoundaries() {
          var box = this._dataSource.getBox()

          var sphere = new THREE__namespace.Sphere()
          box.getBoundingSphere(sphere)
          return {
            boundingBox: box,
            boundingSphere: sphere
          }
        }
      },
      {
        key: 'getMesh',
        value: function getMesh() {
          return this._mesh
        }
      },
      {
        key: 'showFrame',
        value: function showFrame(needShow) {
          this._frame.getMesh().material.visible = needShow
        }
      }
    ])

    return VolumeVisual
  })(Visual)

  function _createSuper$u(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$u()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$u() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var LoaderList = /*#__PURE__*/ (function (_EntityList) {
    _inherits(LoaderList, _EntityList)

    var _super = _createSuper$u(LoaderList)

    function LoaderList() {
      var someLoaders =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []

      _classCallCheck(this, LoaderList)

      return _super.call(this, someLoaders, ['types'])
    }

    _createClass(LoaderList, [
      {
        key: 'find',
        value: function find(specs) {
          var list = []

          if (specs.type) {
            list = this._dict.types[specs.type.toLowerCase()] || []
          } else if (specs.source) {
            return this._list.filter(function (SomeLoader) {
              return (
                SomeLoader.canProbablyLoad &&
                SomeLoader.canProbablyLoad(specs.source)
              )
            })
          }

          return _toConsumableArray(list)
        }
      }
    ])

    return LoaderList
  })(EntityList)

  function _createSuper$t(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$t()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$t() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var Loader = /*#__PURE__*/ (function (_EventDispatcher) {
    _inherits(Loader, _EventDispatcher)

    var _super = _createSuper$t(Loader)

    function Loader(source, options) {
      var _this

      _classCallCheck(this, Loader)

      _this = _super.call(this)
      _this._source = source
      _this._options = options || {}
      _this._abort = false
      _this._agent = null
      return _this
    }

    _createClass(
      Loader,
      [
        {
          key: 'load',
          value: function load() {
            return Promise.reject(
              new Error('Loading from this source is not implemented')
            )
          }
        },
        {
          key: 'abort',
          value: function abort() {
            this._abort = true

            if (this._agent) {
              this._agent.abort()
            }
          }
        }
      ],
      [
        {
          key: 'extractName',
          value: function extractName(_source) {
            return undefined
          }
        }
      ]
    )

    return Loader
  })(EventDispatcher)
  makeContextDependent(Loader.prototype)

  function _createSuper$s(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$s()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$s() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var FileLoader = /*#__PURE__*/ (function (_Loader) {
    _inherits(FileLoader, _Loader)

    var _super = _createSuper$s(FileLoader)

    function FileLoader(source, options) {
      var _this

      _classCallCheck(this, FileLoader)

      _this = _super.call(this, source, options)
      options = _this._options
      _this._binary = options.binary === true
      return _this
    }

    _createClass(
      FileLoader,
      [
        {
          key: 'load',
          value: function load() {
            var _this2 = this

            return new Promise(function (resolve, reject) {
              if (_this2._abort) {
                throw new Error('Loading aborted')
              }

              var blob = _this2._source
              var reader = (_this2._agent = new FileReader())
              reader.addEventListener('load', function () {
                resolve(reader.result)
              })
              reader.addEventListener('error', function () {
                reject(reader.error)
              })
              reader.addEventListener('abort', function () {
                reject(new Error('Loading aborted'))
              })
              reader.addEventListener('progress', function (event) {
                _this2.dispatchEvent(event)
              })

              if (_this2._binary) {
                reader.readAsArrayBuffer(blob)
              } else {
                reader.readAsText(blob)
              }
            })
          }
        }
      ],
      [
        {
          key: 'canProbablyLoad',
          value: function canProbablyLoad(source) {
            return (
              (File && source instanceof File) ||
              (Blob && source instanceof Blob)
            )
          }
        },
        {
          key: 'extractName',
          value: function extractName(source) {
            return source && source.name
          }
        }
      ]
    )

    return FileLoader
  })(Loader)
  FileLoader.types = ['file', 'blob']

  function _createSuper$r(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$r()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$r() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var urlStartRegexp = /^(https?|ftp):\/\//i

  var XHRLoader = /*#__PURE__*/ (function (_Loader) {
    _inherits(XHRLoader, _Loader)

    var _super = _createSuper$r(XHRLoader)

    function XHRLoader(source, options) {
      var _this

      _classCallCheck(this, XHRLoader)

      _this = _super.call(this, source, options)
      options = _this._options
      _this._binary = options.binary === true
      return _this
    }

    _createClass(
      XHRLoader,
      [
        {
          key: 'load',
          value: function load() {
            var _this2 = this

            return new Promise(function (resolve, reject) {
              if (_this2._abort) {
                throw new Error('Loading aborted')
              }

              var url = _this2._source
              var request = (_this2._agent = new XMLHttpRequest())
              request.addEventListener('load', function () {
                if (request.status === 200) {
                  resolve(request.response)
                } else {
                  reject(
                    new Error(
                      'HTTP '
                        .concat(request.status, ' while fetching ')
                        .concat(url)
                    )
                  )
                }
              })
              request.addEventListener('error', function () {
                reject(new Error('HTTP request failed'))
              })
              request.addEventListener('abort', function () {
                reject(new Error('Loading aborted'))
              })
              request.addEventListener('progress', function (event) {
                _this2.dispatchEvent(event)
              })
              request.open('GET', url)

              if (_this2._binary) {
                request.responseType = 'arraybuffer'
              } else {
                request.responseType = 'text'
              }

              request.send()
            })
          }
        }
      ],
      [
        {
          key: 'canProbablyLoad',
          value: function canProbablyLoad(source) {
            return (
              ___default['default'].isString(source) &&
              urlStartRegexp.test(source)
            )
          }
        },
        {
          key: 'extractName',
          value: function extractName(source) {
            if (source) {
              var last =
                (source.indexOf('?') + 1 ||
                  source.lastIndexOf('#') + 1 ||
                  source.length + 1) - 1
              return source.slice(source.lastIndexOf('/', last) + 1, last)
            }

            return undefined
          }
        }
      ]
    )

    return XHRLoader
  })(Loader)
  XHRLoader.types = ['url']

  function _createSuper$q(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$q()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$q() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ImmediateLoader = /*#__PURE__*/ (function (_Loader) {
    _inherits(ImmediateLoader, _Loader)

    var _super = _createSuper$q(ImmediateLoader)

    function ImmediateLoader() {
      _classCallCheck(this, ImmediateLoader)

      return _super.apply(this, arguments)
    }

    _createClass(
      ImmediateLoader,
      [
        {
          key: 'load',
          value: function load() {
            var _this = this

            return new Promise(function (resolve) {
              if (_this._abort) {
                throw new Error('Loading aborted')
              }

              resolve(_this._source)
            })
          }
        }
      ],
      [
        {
          key: 'canProbablyLoad',
          value: function canProbablyLoad(_source) {
            return false
          }
        }
      ]
    )

    return ImmediateLoader
  })(Loader)
  ImmediateLoader.types = ['immediate']

  var loaders = new LoaderList([FileLoader, XHRLoader, ImmediateLoader])

  function _createSuper$p(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$p()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$p() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ParserList = /*#__PURE__*/ (function (_EntityList) {
    _inherits(ParserList, _EntityList)

    var _super = _createSuper$p(ParserList)

    function ParserList() {
      var someParsers =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []

      _classCallCheck(this, ParserList)

      return _super.call(this, someParsers, ['formats', 'extensions'])
    }

    _createClass(ParserList, [
      {
        key: 'find',
        value: function find(specs) {
          var list = []

          if (specs.format) {
            list = this._dict.formats[specs.format.toLowerCase()] || []
          } else if (specs.ext) {
            list = this._dict.extensions[specs.ext.toLowerCase()] || []
          }

          if (list.length === 0 && !specs.format && specs.data) {
            return this._list.filter(function (SomeParser) {
              return (
                SomeParser.canProbablyParse &&
                SomeParser.canProbablyParse(specs.data)
              )
            })
          }

          return _toConsumableArray(list)
        }
      }
    ])

    return ParserList
  })(EntityList)

  var Parser = /*#__PURE__*/ (function () {
    function Parser(data, options) {
      _classCallCheck(this, Parser)

      this._data = data
      this._options = options || {}
      this._abort = false
    }

    _createClass(Parser, [
      {
        key: 'parseSync',
        value: function parseSync() {
          throw new Error('Parsing this type of data is not implemented')
        }
      },
      {
        key: 'parse',
        value: function parse() {
          var _this = this

          return new Promise(function (resolve, reject) {
            setTimeout(function () {
              try {
                if (_this._abort) {
                  return reject(new Error('Parsing aborted'))
                }

                return resolve(_this.parseSync())
              } catch (error) {
                return reject(error)
              }
            })
          })
        }
      },
      {
        key: 'getModel',
        value: function getModel() {
          this.model._parseHeader(this._data)

          return this.model
        }
      },
      {
        key: 'abort',
        value: function abort() {
          this._abort = true
        }
      }
    ])

    return Parser
  })()
  makeContextDependent(Parser.prototype)

  var Remark290 = /*#__PURE__*/ (function () {
    function Remark290() {
      _classCallCheck(this, Remark290)

      this.matrices = []
      this._matrix = null
      this._matrixIndex = -1
    }

    _createClass(Remark290, [
      {
        key: 'parse',
        value: function parse(stream) {
          var matrix = this._matrix

          if (stream.readString(12, 18) === '  SMTRY') {
            var matrixRow = stream.readCharCode(19) - 49
            var matrixData = stream.readString(20, 80).trim().split(/\s+/)
            var matrixIndex = parseInt(matrixData[0], 10)

            if (this._matrix === null || matrixIndex !== this._matrixIndex) {
              this._matrixIndex = matrixIndex
              this._matrix = matrix = new THREE__namespace.Matrix4()
              this.matrices[this.matrices.length] = matrix
            }

            var _matrix = matrix,
              elements = _matrix.elements
            elements[matrixRow] = parseFloat(matrixData[1])
            elements[matrixRow + 4] = parseFloat(matrixData[2])
            elements[matrixRow + 8] = parseFloat(matrixData[3])
            elements[matrixRow + 12] = parseFloat(matrixData[4])
          }
        }
      }
    ])

    return Remark290
  })()

  Remark290.prototype.id = 290

  var Assembly$2 = chem.Assembly

  var Remark350 = /*#__PURE__*/ (function () {
    function Remark350(complex) {
      _classCallCheck(this, Remark350)

      this._complex = complex
      this.assemblies = []
      this._assembly = null
      this._matrix = null
      this._matrixIndex = -1
    }

    _createClass(Remark350, [
      {
        key: 'parse',
        value: function parse(stream) {
          var assembly = this._assembly
          var matrix = this._matrix

          if (assembly && stream.readString(12, 18) === '  BIOMT') {
            var matrixRow = stream.readCharCode(19) - 49
            var matrixData = stream.readString(20, 80).trim().split(/\s+/)
            var matrixIndex = parseInt(matrixData[0], 10)

            if (this._matrix === null || matrixIndex !== this._matrixIndex) {
              this._matrixIndex = matrixIndex
              this._matrix = matrix = new THREE__namespace.Matrix4()
              assembly.addMatrix(matrix)
            }

            var _matrix = matrix,
              elements = _matrix.elements
            elements[matrixRow] = parseFloat(matrixData[1])
            elements[matrixRow + 4] = parseFloat(matrixData[2])
            elements[matrixRow + 8] = parseFloat(matrixData[3])
            elements[matrixRow + 12] = parseFloat(matrixData[4])
          } else if (assembly && stream.readString(35, 41) === 'CHAINS:') {
            var entries = stream.readString(42, 80).split(',')

            for (var i = 0, n = entries.length; i < n; ++i) {
              var chain = entries[i].trim()

              if (chain.length > 0) {
                assembly.addChain(chain)
              }
            }
          } else if (stream.readString(12, 23) === 'BIOMOLECULE:') {
            this._matrix = null
            this._matrixIndex = -1
            this._assembly = assembly = new Assembly$2(this._complex)
            this.assemblies.push(assembly)
          }
        }
      }
    ])

    return Remark350
  })()

  Remark350.prototype.id = 350

  var PDBStream = /*#__PURE__*/ (function () {
    function PDBStream(data) {
      _classCallCheck(this, PDBStream)

      this._data = data
      this._start = 0
      this._nextCR = -1
      this._nextLF = -1
      this._next = -1
      this._end = data.length
      this.next()
    }

    _createClass(PDBStream, [
      {
        key: 'readLine',
        value: function readLine() {
          return this._data.slice(this._start, this._next)
        }
      },
      {
        key: 'readChar',
        value: function readChar(pos) {
          pos = this._start + pos - 1
          return pos < this._next ? this._data[pos] : ' '
        }
      },
      {
        key: 'readCharCode',
        value: function readCharCode(pos) {
          pos = this._start + pos - 1
          return pos < this._next ? this._data.charCodeAt(pos) : 32
        }
      },
      {
        key: 'readString',
        value: function readString(begin, end) {
          var from = this._start + begin - 1
          var to = this._start + end
          return this._data.slice(from, to < this._next ? to : this._next)
        }
      },
      {
        key: 'readInt',
        value: function readInt(begin, end) {
          return parseInt(this.readString(begin, end), 10)
        }
      },
      {
        key: 'readFloat',
        value: function readFloat(begin, end) {
          return parseFloat(this.readString(begin, end))
        }
      },
      {
        key: 'end',
        value: function end() {
          return this._start >= this._end
        }
      },
      {
        key: 'next',
        value: function next() {
          var start = this._next + 1
          this._start = start < this._end ? start : this._end

          if (this._start > this._nextCR) {
            this._nextCR =
              (this._data.indexOf('\r', this._start) + 1 || this._end + 1) - 1
          }

          if (this._start > this._nextLF) {
            this._nextLF =
              (this._data.indexOf('\n', this._start) + 1 || this._end + 1) - 1
          }

          this._next =
            this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF
        }
      }
    ])

    return PDBStream
  })()

  function _createSuper$o(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$o()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$o() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$8 = chem.Complex,
    Element$8 = chem.Element,
    Helix$2 = chem.Helix,
    Sheet$2 = chem.Sheet,
    Strand$2 = chem.Strand,
    Bond$4 = chem.Bond,
    Molecule$7 = chem.Molecule
  var TAG_LENGTH = 6

  function nameToElement$1(name) {
    var veryLong = name.trim().length === 4
    return name.slice(0, veryLong ? 1 : 2).trim()
  }

  var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i
  var remarkParsers = {
    290: Remark290,
    350: Remark350
  }

  var PDBParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(PDBParser, _Parser)

    var _super = _createSuper$o(PDBParser)

    function PDBParser(data, options) {
      var _this

      _classCallCheck(this, PDBParser)

      _this = _super.call(this, data, options)
      _this._complex = null
      _this._chain = null
      _this._residue = null
      _this._sheet = null
      _this._serialAtomMap = null
      _this._modelId = 1
      _this._compaundFound = false
      _this._biomoleculeFound = false
      _this._allowedChainsIDs = null
      _this._lastMolId = -1
      _this._remarks = {}
      _this._remark = null
      _this._molecules = []
      _this._molecule = null
      _this._compndCurrToken = ''
      _this._options.fileType = 'pdb'
      return _this
    }

    _createClass(
      PDBParser,
      [
        {
          key: '_finalize',
          value: function _finalize() {
            this._fixBondsArray()

            this._fixChains()

            var remark290 = this._remarks[290]
            this._complex.symmetry = ___default['default'].isUndefined(
              remark290
            )
              ? []
              : remark290.matrices
            var remark350 = this._remarks[350]
            this._complex.units = this._complex.units.concat(
              ___default['default'].isUndefined(remark350)
                ? []
                : remark350.assemblies
            )

            this._finalizeMolecules()

            this._complex.finalize({
              needAutoBonding: true,
              detectAromaticLoops: this.settings.now.aromatic,
              enableEditing: this.settings.now.editing,
              serialAtomMap: this._serialAtomMap
            })
          }
        },
        {
          key: '_finalizeMolecules',
          value: function _finalizeMolecules() {
            var chainDict = {}
            var i
            var chains = this._complex._chains

            for (i = 0; i < chains.length; ++i) {
              var chainObj = chains[i]
              var chainName = chainObj._name
              chainDict[chainName] = chainObj
            }

            for (i = 0; i < this._molecules.length; i++) {
              var m = this._molecules[i]
              var residues = []

              for (var j = 0; j < m._chains.length; j++) {
                var name = m._chains[j]
                var chain = chainDict[name]
                residues = residues.concat(chain._residues.slice())
              }

              var molecule = new Molecule$7(this._complex, m._name, i + 1)
              molecule.residues = residues
              this._complex._molecules[i] = molecule
            }
          }
        },
        {
          key: '_fixChains',
          value: function _fixChains() {
            var idChainMap = {}
            var complex = this._complex

            for (var i = 0; i < complex._chains.length; i++) {
              var chain = complex._chains[i]
              idChainMap[chain._name.charCodeAt(0)] = chain
            }
          }
        },
        {
          key: '_fixBondsArray',
          value: function _fixBondsArray() {
            var serialAtomMap = (this._serialAtomMap = {})
            var complex = this._complex
            var atoms = complex._atoms

            for (var i = 0, ni = atoms.length; i < ni; ++i) {
              var atom = atoms[i]
              serialAtomMap[atom.serial] = atom
            }

            var bonds = complex._bonds
            var logger = this.logger

            for (var j = 0, nj = bonds.length; j < nj; ++j) {
              var bond = bonds[j]

              if (bond._right < bond._left) {
                logger.debug('_fixBondsArray: Logic error.')
              }

              bond._left = serialAtomMap[bond._left] || null
              bond._right = serialAtomMap[bond._right] || null
            }
          }
        },
        {
          key: '_parseATOM',
          value: function _parseATOM(stream) {
            if (this._modelId !== 1) {
              return
            }

            var het = stream.readCharCode(1) === 0x48
            var serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11)
            var name = stream.readString(13, 16)
            var altLoc = stream.readChar(17)
            var resName = stream.readString(18, 20).trim()
            var chainID = stream.readChar(22)
            var resSeq = stream.readInt(23, 26)
            var iCode = stream.readChar(27)
            var x = stream.readFloat(31, 38)
            var y = stream.readFloat(39, 46)
            var z = stream.readFloat(47, 54)
            var occupancy = stream.readFloat(55, 60)
            var tempFactor = stream.readFloat(61, 66)
            var element =
              stream.readString(77, 78).trim() || nameToElement$1(name)
            var charge = stream.readInt(79, 80) || 0

            if (this.settings.now.nowater) {
              if (resName === 'HOH' || resName === 'WAT') {
                return
              }
            }

            name = name.trim()
            var type = Element$8.getByName(element)
            var role = Element$8.Role[name]
            var chain = this._chain

            if (!chain || chain.getName() !== chainID) {
              this._chain = chain =
                this._complex.getChain(chainID) ||
                this._complex.addChain(chainID)
              this._residue = null
            }

            var residue = this._residue

            if (
              !residue ||
              residue.getSequence() !== resSeq ||
              residue.getICode() !== iCode
            ) {
              this._residue = residue = chain.addResidue(resName, resSeq, iCode)
            }

            var xyz = new THREE__namespace.Vector3(x, y, z)
            residue.addAtom(
              name,
              type,
              xyz,
              role,
              het,
              serial,
              altLoc,
              occupancy,
              tempFactor,
              charge
            )
          }
        },
        {
          key: '_parseENDMDL',
          value: function _parseENDMDL() {
            this._modelId += 1
          }
        },
        {
          key: '_parseCONECT',
          value: function _parseCONECT(stream) {
            var serial0 = stream.readInt(7, 11)
            var serial1 = stream.readInt(12, 16)
            var serial2 = stream.readInt(17, 21)
            var serial3 = stream.readInt(22, 26)
            var serial4 = stream.readInt(27, 31)
            var complex = this._complex

            if (serial1 && serial1 > serial0) {
              complex.addBond(
                serial0,
                serial1,
                0,
                Bond$4.BondType.UNKNOWN,
                true
              )
            }

            if (serial2 && serial2 > serial0) {
              complex.addBond(
                serial0,
                serial2,
                0,
                Bond$4.BondType.UNKNOWN,
                true
              )
            }

            if (serial3 && serial3 > serial0) {
              complex.addBond(
                serial0,
                serial3,
                0,
                Bond$4.BondType.UNKNOWN,
                true
              )
            }

            if (serial4 && serial4 > serial0) {
              complex.addBond(
                serial0,
                serial4,
                0,
                Bond$4.BondType.UNKNOWN,
                true
              )
            }
          }
        },
        {
          key: '_parseCOMPND',
          value: function _parseCOMPND(stream) {
            var str = stream.readString(11, 80)
            var tokenIdx = str.indexOf(':')
            this._compndCurrToken =
              tokenIdx > 0
                ? str.substring(0, tokenIdx).trim()
                : this._compndCurrToken

            if (this._compndCurrToken === 'MOL_ID') {
              this._molecule = {
                _index: '',
                _chains: []
              }
              this._molecule._index = parseInt(
                str.substring(tokenIdx + 1, str.indexOf(';')),
                10
              )

              this._molecules.push(this._molecule)
            } else if (
              this._compndCurrToken === 'MOLECULE' &&
              this._molecule != null
            ) {
              this._molecule._name = str
                .substring(tokenIdx + 1, str.indexOf(';'))
                .trim()
            } else if (
              this._compndCurrToken === 'CHAIN' &&
              this._molecule != null
            ) {
              var chainStr = str.substring(tokenIdx + 1, 80).trim()
              var lastChar = chainStr[chainStr.length - 1]

              if (lastChar === ';' || lastChar === ',') {
                chainStr = chainStr.slice(0, -1)
              }

              chainStr = chainStr.replace(/\s+/g, '')
              var chains = chainStr.split(',')
              this._molecule._chains = this._molecule._chains.concat(chains)
            }
          }
        },
        {
          key: '_parseREMARK',
          value: function _parseREMARK(stream) {
            var remarkNum = stream.readInt(8, 10)
            var remark = this._remarks[remarkNum]

            if (___default['default'].isUndefined(remark)) {
              var RemarkParser = remarkParsers[remarkNum]

              if (typeof RemarkParser === 'function') {
                this._remarks[remarkNum] = remark = new RemarkParser(
                  this._complex
                )
              }
            }

            if (!___default['default'].isUndefined(remark)) {
              remark.parse(stream)
            }
          }
        },
        {
          key: '_parseHELIX',
          value: function _parseHELIX(stream) {
            var _this2 = this

            var fields = [20, 22, 32, 34]

            this._parseSTRUCTURE(stream, fields, function (obj) {
              _this2._complex.addHelix(obj)

              _this2._complex.structures.push(obj)
            })
          }
        },
        {
          key: '_parseSHEET',
          value: function _parseSHEET(stream) {
            var _this3 = this

            var fields = [22, 23, 33, 34]

            this._parseSTRUCTURE(stream, fields, function (obj) {
              _this3._complex.addSheet(obj)
            })
          }
        },
        {
          key: '_parseSTRUCTURE',
          value: function _parseSTRUCTURE(stream, pars, adder) {
            var startId = 0
            var startIndex = 1
            var endId = 2
            var endIndex = 3
            var codeOfS = 0x53
            var serialNumber = stream.readInt(8, 10)
            var structureName = stream.readString(12, 14).trim()
            var comment = stream.readString(41, 70).trim()
            var helLength = stream.readInt(72, 76)
            var helixClass = stream.readInt(39, 40)
            var shWidth = stream.readInt(15, 16)
            var shCur = stream.readInt(42, 45)
            var shPrev = stream.readInt(57, 60)
            var startChainID = stream
              .readString(pars[startId], pars[endId] + 1)
              .charCodeAt(0)
            var endChainID = stream
              .readString(pars[endId], pars[endId] + 1)
              .charCodeAt(0)
            var startSequenceNumber = stream.readInt(
              pars[startIndex],
              pars[startIndex] + 3
            )
            var iCodeStr = stream.readString(
              pars[startIndex] + 4,
              pars[startIndex] + 4
            )
            var startICode = 0

            if (iCodeStr.length > 0) {
              startICode = iCodeStr.charCodeAt(0)
            }

            var endSequenceNumber = stream.readInt(
              pars[endIndex],
              pars[endIndex] + 3
            )
            iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4)
            var endICode = 0

            if (iCodeStr.length > 0) {
              endICode = iCodeStr.charCodeAt(0)
            }

            var obj
            var cs = this._sheet

            if (stream.readCharCode(1) === codeOfS) {
              if (cs !== null && cs.getName() !== structureName) {
                cs = null
                this._sheet = null
              }

              if (cs === null) {
                this._sheet = obj = new Sheet$2(structureName, shWidth)
                adder(obj)
              } else {
                obj = cs
              }

              var strand = new Strand$2(
                obj,
                this._complex.getUnifiedSerial(
                  startChainID,
                  startSequenceNumber,
                  startICode
                ),
                this._complex.getUnifiedSerial(
                  endChainID,
                  endSequenceNumber,
                  endICode
                ),
                helixClass,
                shCur,
                shPrev
              )
              obj.addStrand(strand)

              this._complex.structures.push(strand)
            } else {
              obj = new Helix$2(
                helixClass,
                this._complex.getUnifiedSerial(
                  startChainID,
                  startSequenceNumber,
                  startICode
                ),
                this._complex.getUnifiedSerial(
                  endChainID,
                  endSequenceNumber,
                  endICode
                ),
                serialNumber,
                structureName,
                comment,
                helLength
              )
              adder(obj)
            }
          }
        },
        {
          key: '_parseHEADER',
          value: function _parseHEADER(stream) {
            var metadata = this._complex.metadata
            metadata.classification = stream.readString(11, 50).trim()
            metadata.date = stream.readString(51, 59).trim()
            var id = stream.readString(63, 66).trim()
            metadata.id = id

            if (id) {
              this._complex.name = id
            }

            metadata.format = 'pdb'
          }
        },
        {
          key: '_parseTITLE',
          value: function _parseTITLE(stream) {
            var metadata = this._complex.metadata
            metadata.title = metadata.title || []
            var line = stream.readInt(9, 10) || 1
            metadata.title[line - 1] = stream.readString(11, 80).trim()
          }
        },
        {
          key: 'parseSync',
          value: function parseSync() {
            var stream = new PDBStream(this._data)
            var result = (this._complex = new Complex$8())

            while (!stream.end()) {
              var tag = stream.readString(1, TAG_LENGTH)
              var func = PDBParser.tagParsers[tag]

              if (typeof func === 'function') {
                func.call(this, stream)
              }

              stream.next()
            }

            this._finalize()

            this._serialAtomMap = null
            this._sheet = null
            this._residue = null
            this._chain = null
            this._complex = null

            if (result.getAtomCount() === 0) {
              throw new Error('The data does not contain valid atoms')
            }

            return result
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(data) {
            return (
              ___default['default'].isString(data) && pdbStartRegexp.test(data)
            )
          }
        }
      ]
    )

    return PDBParser
  })(Parser)

  _defineProperty(PDBParser, 'tagParsers', {
    HEADER: PDBParser.prototype._parseHEADER,
    'TITLE ': PDBParser.prototype._parseTITLE,
    'ATOM  ': PDBParser.prototype._parseATOM,
    HETATM: PDBParser.prototype._parseATOM,
    ENDMDL: PDBParser.prototype._parseENDMDL,
    CONECT: PDBParser.prototype._parseCONECT,
    COMPND: PDBParser.prototype._parseCOMPND,
    REMARK: PDBParser.prototype._parseREMARK,
    'HELIX ': PDBParser.prototype._parseHELIX,
    'SHEET ': PDBParser.prototype._parseSHEET,
    'ATOM 1': PDBParser.prototype._parseATOM,
    'ATOM 2': PDBParser.prototype._parseATOM,
    'ATOM 3': PDBParser.prototype._parseATOM,
    'ATOM 4': PDBParser.prototype._parseATOM,
    'ATOM 5': PDBParser.prototype._parseATOM,
    'ATOM 6': PDBParser.prototype._parseATOM,
    'ATOM 7': PDBParser.prototype._parseATOM,
    'ATOM 8': PDBParser.prototype._parseATOM,
    'ATOM 9': PDBParser.prototype._parseATOM
  })

  PDBParser.formats = ['pdb']
  PDBParser.extensions = ['.pdb', '.ent']

  function _createSuper$n(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$n()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$n() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$7 = chem.Complex,
    Element$7 = chem.Element,
    SGroup = chem.SGroup,
    Bond$3 = chem.Bond
  var cOrderCharCodes = {
    A: 0,
    S: 1,
    D: 2,
    T: 3
  }
  var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i

  var CMLParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(CMLParser, _Parser)

    var _super = _createSuper$n(CMLParser)

    function CMLParser(data, options) {
      var _this

      _classCallCheck(this, CMLParser)

      _this = _super.call(this, data, options)
      _this._complex = null
      _this._residue = null
      _this._serialAtomMap = null
      _this._modelId = 1
      _this._lastMolId = -1
      _this._readOnlyOneMolecule = false
      _this._options.fileType = 'cml'
      return _this
    }

    _createClass(
      CMLParser,
      [
        {
          key: '_rebuidBondIndexes',
          value: function _rebuidBondIndexes(atoms, bonds) {
            var count = atoms.length

            for (var i = 0; i < count; i++) {
              var atomId = atoms[i].id
              var countBonds = bonds.length

              for (var j = 0; j < countBonds; j++) {
                var idxs = bonds[j].atomRefs2.split(' ')

                if (idxs[0] === atomId) {
                  bonds[j].start = i
                }

                if (idxs[1] === atomId) {
                  bonds[j].end = i
                }
              }
            }
          }
        },
        {
          key: '_createSGroup',
          value: function _createSGroup(molecule, moleculeArr) {
            var newGroup = new SGroup(
              molecule.id,
              molecule.fieldData,
              new THREE__namespace.Vector3(
                parseFloat(molecule.x),
                parseFloat(molecule.y),
                0
              ),
              molecule.atomRefs,
              molecule
            )

            if (molecule.placement === 'Relative') {
              newGroup._center = new THREE__namespace.Vector3(0, 0, 0)
            }

            if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
              newGroup._charge = parseInt(molecule.fieldData, 10) || 0
            }

            if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
              newGroup._repeat = parseInt(molecule.fieldData, 10) || 1
            }

            moleculeArr.push(newGroup)
          }
        },
        {
          key: '_extractSGroup',
          value: function _extractSGroup(molecule, moleculeArr) {
            if (!Array.isArray(moleculeArr)) {
              moleculeArr = []
            }

            if (molecule) {
              if (Array.isArray(molecule)) {
                var count = molecule.length

                for (var i = 0; i < count; i++) {
                  if (molecule[i].molecule) {
                    moleculeArr = moleculeArr.concat(
                      this._extractSGroup(molecule[i].molecule)
                    )
                  }

                  this._createSGroup(molecule[i], moleculeArr)
                }
              } else {
                if (molecule.molecule) {
                  if (molecule.molecule) {
                    moleculeArr = moleculeArr.concat(
                      this._extractSGroup(molecule.molecule)
                    )
                  }
                }

                this._createSGroup(molecule, moleculeArr)
              }
            }

            return moleculeArr
          }
        },
        {
          key: '_extractSGroups',
          value: function _extractSGroups(molecule, atoms) {
            var moleculeArr = this._extractSGroup(molecule)

            var count = atoms.length
            var i
            var j

            for (i = 0; i < count; i++) {
              var atomId = atoms[i].id

              for (j = 0; j < moleculeArr.length; j++) {
                var firstAtomRef = moleculeArr[j]._atoms.split(' ')[0]

                if (firstAtomRef === atomId) {
                  if (!atoms[i].sgroupRef) {
                    atoms[i].sgroupRef = []
                  }

                  atoms[i].sgroupRef.push(moleculeArr[j])
                }
              }
            }

            var atomMap = {}
            var mapEntry = null
            var nLimon = 100000000
            var bLow = new THREE__namespace.Vector3(nLimon, nLimon, nLimon)
            var bHight = new THREE__namespace.Vector3(-nLimon, -nLimon, -nLimon)

            function cycleFuncInner(e) {
              mapEntry = atomMap[e]

              if (mapEntry) {
                moleculeArr[j]._atoms.push(mapEntry.a)
              }
            }

            function cycleFunc(e) {
              mapEntry = atomMap[e]

              if (mapEntry) {
                bLow.set(
                  Math.min(bLow.x, mapEntry.x),
                  Math.min(bLow.y, mapEntry.y),
                  Math.min(bLow.z, mapEntry.z)
                )
                bHight.set(
                  Math.max(bHight.x, mapEntry.x),
                  Math.max(bHight.y, mapEntry.y),
                  Math.max(bHight.z, mapEntry.z)
                )
                cycleFuncInner(e)
              }
            }

            for (i = 0; i < atoms.length; i++) {
              atomMap[atoms[i].id] = {}
              atomMap[atoms[i].id].x = atoms[i].x2

              if (atoms[i].x3) {
                atomMap[atoms[i].id].x = atoms[i].x3
              }

              atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x)
              atomMap[atoms[i].id].y = atoms[i].y2

              if (atoms[i].y3) {
                atomMap[atoms[i].id].y = atoms[i].y3
              }

              atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y)
              atomMap[atoms[i].id].z = '0.0'

              if (atoms[i].z3) {
                atomMap[atoms[i].id].z = atoms[i].z3
              }

              atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z)
              atomMap[atoms[i].id].a = atoms[i]
            }

            var atomsRef

            for (j = 0; j < moleculeArr.length; j++) {
              if (moleculeArr[j]._center !== null) {
                bLow.set(nLimon, nLimon, nLimon)
                bHight.set(-nLimon, -nLimon, -nLimon)
                atomsRef = moleculeArr[j]._atoms.split(' ')
                moleculeArr[j]._atoms = []
                atomsRef.forEach(cycleFunc)

                moleculeArr[j]._center.addVectors(bLow, bHight)

                moleculeArr[j]._center.multiplyScalar(0.5)
              } else {
                atomsRef = moleculeArr[j]._atoms.split(' ')
                moleculeArr[j]._atoms = []
                atomsRef.forEach(cycleFuncInner)
              }
            }

            atomMap = null
          }
        },
        {
          key: '_traverseData',
          value: function _traverseData(dom) {
            function isArray(o) {
              return Object.prototype.toString.apply(o) === '[object Array]'
            }

            function parseNode(xmlNode, result) {
              if (
                xmlNode.nodeName === '#text' &&
                xmlNode.nodeValue.trim() === ''
              ) {
                return
              }

              var jsonNode = {}
              jsonNode.xmlNode = xmlNode
              var existing = result[xmlNode.nodeName]

              if (existing) {
                if (!isArray(existing)) {
                  result[xmlNode.nodeName] = [existing, jsonNode]
                } else {
                  result[xmlNode.nodeName].push(jsonNode)
                }
              } else {
                result[xmlNode.nodeName] = jsonNode
              }

              var length
              var i

              if (xmlNode.attributes) {
                length = xmlNode.attributes.length

                for (i = 0; i < length; i++) {
                  var attribute = xmlNode.attributes[i]
                  jsonNode[attribute.nodeName] = attribute.nodeValue
                }
              }
              length = xmlNode.childNodes.length

              for (i = 0; i < length; i++) {
                parseNode(xmlNode.childNodes[i], jsonNode)
              }
            }

            var result = {}

            if (dom.childNodes.length) {
              parseNode(dom.childNodes[0], result)
            }

            return result
          }
        },
        {
          key: '_findSuitableMolecule',
          value: function _findSuitableMolecule(data, molSet) {
            for (var key in data) {
              if (key === 'xmlNode') {
                continue
              } else if (key === 'molecule') {
                if (data.molecule) {
                  if (data.molecule.atomArray && data.molecule.atomArray.atom) {
                    molSet.push(data)
                  }

                  if (Array.isArray(data.molecule)) {
                    for (var i = 0; i < data.molecule.length; i++) {
                      if (
                        data.molecule[i].atomArray &&
                        data.molecule[i].atomArray.atom
                      ) {
                        molSet.push({
                          molecule: data.molecule[i]
                        })
                      }
                    }
                  }
                }
              } else if (
                data[key] &&
                data[key] !== null &&
                _typeof(data[key]) === 'object'
              ) {
                this._findSuitableMolecule(data[key], molSet)
              }
            }
          }
        },
        {
          key: '_selectComponents',
          value: function _selectComponents(text) {
            var parser = new DOMParser()
            var doc = parser.parseFromString(text, 'application/xml')

            var traversedData = this._traverseData(doc)

            var rawData
            var self = this

            function prepareComponentCompound(data) {
              var atoms = []

              if (
                data.molecule &&
                data.molecule.atomArray &&
                data.molecule.atomArray.atom
              ) {
                if (!Array.isArray(data.molecule.atomArray.atom)) {
                  atoms.push(data.molecule.atomArray.atom)
                } else {
                  atoms = data.molecule.atomArray.atom
                }
              } else if (!data.molecule) {
                var ret = {}
                ret.atomLabels = null
                ret.labelsCount = 1
                return ret
              }

              if (data.molecule.molecule) {
                self._extractSGroups(data.molecule.molecule, atoms)
              }

              var atom
              var count = atoms.length

              for (var i = 0; i < count; i++) {
                atom = atoms[i]
                atom.edges = []
              }

              var localBond = []

              if (data.molecule.bondArray && data.molecule.bondArray.bond) {
                if (!Array.isArray(data.molecule.bondArray.bond)) {
                  localBond.push(data.molecule.bondArray.bond)
                } else {
                  localBond = data.molecule.bondArray.bond
                }
              }

              var bond
              count = localBond.length

              self._rebuidBondIndexes(atoms, localBond)

              function addCurrBond(index) {
                bond = localBond[index]
                atom = atoms[bond.start]

                if (!atom) {
                  return false
                }

                atom.edges.push(bond.end)
                atom = atoms[bond.end]

                if (!atom) {
                  return false
                }

                atom.edges.push(bond.start)
                return true
              }

              for (var _i = 0; _i < count; _i++) {
                if (!addCurrBond(_i)) {
                  continue
                }

                var orderAttr = bond.xmlNode.getAttribute('order')
                var tc = parseInt(orderAttr, 10)
                localBond[_i].order = 0
                localBond[_i].type = Bond$3.BondType.UNKNOWN

                if (tc > 1) {
                  localBond[_i].order = tc
                } else {
                  var order = cOrderCharCodes[orderAttr]

                  if (order !== undefined) {
                    localBond[_i].order = order

                    if (orderAttr === 'A') {
                      localBond[_i].type = Bond$3.BondType.AROMATIC
                    }
                  }
                }
              }

              count = atoms.length

              for (var _i2 = 0; _i2 < count; _i2++) {
                atom = atoms[_i2]
                atom.edges.sort()
              }

              var labels = self._breadWidthSearch(atoms, 0)

              var retStruct = {}
              retStruct.atoms = atoms
              retStruct.bonds = localBond
              retStruct.labels = labels.atomLabels
              retStruct.count = Math.min(1, labels.labelsCount)
              retStruct.curr = -1
              retStruct.originalCML = doc
              return retStruct
            }

            if (traversedData.cml) {
              rawData = traversedData.cml
            } else {
              rawData = traversedData
            }

            var retData = []
            var filteredData = []

            this._findSuitableMolecule(rawData, filteredData)

            if (this._readOnlyOneMolecule && filteredData.length > 1) {
              filteredData.splice(1, filteredData.length - 1)
            }

            filteredData.forEach(function (d) {
              var rd = prepareComponentCompound(d)

              if (rd.atoms.length > 0) {
                retData.push(rd)
              }
            })
            return retData
          }
        },
        {
          key: '_packLabel',
          value: function _packLabel(compId, molId) {
            var shift = 16
            return (molId << shift) + compId
          }
        },
        {
          key: '_unpackLabel',
          value: function _unpackLabel(l) {
            var shift = 16
            var mask = (1 << shift) - 1
            return {
              molId: l >>> shift,
              compId: l & mask
            }
          }
        },
        {
          key: '_breadWidthSearch',
          value: function _breadWidthSearch(atoms, molID) {
            var atomLabels = new Array(atoms.length)
            var id

            for (id = 0; id < atomLabels.length; id++) {
              atomLabels[id] = this._packLabel(0, molID)
            }

            var breadthQueue = []
            var componentID = 0
            var labeledAtoms = atoms.length

            while (labeledAtoms > 0) {
              componentID++
              var startID = -1

              for (id = 0; id < atomLabels.length; id++) {
                if (this._unpackLabel(atomLabels[id]).compId === 0) {
                  startID = id
                  break
                }
              }

              if (startID < 0) {
                break
              }

              breadthQueue.push(atoms[startID])
              atomLabels[startID] = this._packLabel(componentID, molID)
              labeledAtoms--

              while (breadthQueue.length > 0) {
                var curr = breadthQueue.shift()

                if (!curr) {
                  continue
                }

                for (var i = 0; i < curr.edges.length; i++) {
                  if (atomLabels[curr.edges[i]] !== componentID) {
                    breadthQueue.push(atoms[curr.edges[i]])
                    atomLabels[curr.edges[i]] = componentID
                    labeledAtoms--
                  }
                }
              }
            }

            var ret = {}
            ret.atomLabels = atomLabels
            ret.labelsCount = componentID
            return ret
          }
        },
        {
          key: '_parseBond',
          value: function _parseBond(eAtom, mainAtom, order, type) {
            if (eAtom >= 0) {
              var h = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)]

              this._complex.addBond(h[0], h[1], order, type, true)
            }
          }
        },
        {
          key: '_fixBondsArray',
          value: function _fixBondsArray() {
            var serialAtomMap = (this._serialAtomMap = {})
            var complex = this._complex
            var atoms = complex._atoms

            for (var i = 0, ni = atoms.length; i < ni; ++i) {
              var atom = atoms[i]
              serialAtomMap[atom.serial] = atom
            }

            var bonds = complex._bonds
            var logger = this.logger

            for (var j = 0, nj = bonds.length; j < nj; ++j) {
              var bond = bonds[j]

              if (bond._right < bond._left) {
                logger.debug('_fixBondsArray: Logic error.')
              }

              bond._left = serialAtomMap[bond._left] || null
              bond._right = serialAtomMap[bond._right] || null
            }
          }
        },
        {
          key: '_parseSet',
          value: function _parseSet(varData) {
            var complex = (this._complex = new Complex$7())
            var data = varData
            var currentLabel = data.curr
            var atoms = data.atoms,
              labels = data.labels
            var atom = null
            var i
            var j
            var count = atoms.length

            function addFunc(a) {
              a.xmlNodeRef = atom

              if (atom.x2) {
                atom.x3 = atom.x2
                delete atom.x2
              }

              if (atom.y2) {
                atom.y3 = atom.y2
                delete atom.y2
              }

              if (!atom.z3) {
                atom.z3 = '0.0'
              }

              atom.complexAtom = a
            }

            var chains = {}
            var reorder = []

            for (i = 0; i < count; i++) {
              reorder.push(i)
            }

            reorder.sort(function (a, b) {
              return labels[a] - labels[b]
            })

            for (i = 0; i < count; i++) {
              var atomCharge = 0
              var lLabel = labels[reorder[i]]

              if (
                this._unpackLabel(lLabel).molId ===
                this._unpackLabel(currentLabel).molId
              ) {
                atom = atoms[reorder[i]]
                var atomFullNameStruct = atom.elementType

                if (atom.sgroupRef) {
                  var countRef = atom.sgroupRef.length

                  for (var k = 0; k < countRef; ++k) {
                    complex._sgroups.push(atom.sgroupRef[k])
                  }
                }

                if (atom.x3 || atom.x2) {
                  var currAtomComp = this._unpackLabel(lLabel).compId

                  var chainID = ' '
                  var resSeq = currAtomComp
                  var iCode = ' '
                  var strLabel = currAtomComp.toString()

                  if (strLabel.length === 1) {
                    strLabel = '0'.concat(strLabel)
                  }

                  var resName = 'N'.concat(strLabel)
                  var chain = chains[chainID]

                  if (!chain || chain.getName() !== chainID) {
                    chains[chainID] = chain =
                      this._complex.getChain(chainID) ||
                      this._complex.addChain(chainID)
                    this._residue = null
                  }

                  var residue = this._residue

                  if (
                    !residue ||
                    residue.getSequence() !== resSeq ||
                    residue.getICode() !== iCode
                  ) {
                    this._residue = residue = chain.addResidue(
                      resName,
                      resSeq,
                      iCode
                    )
                  }

                  var xyz = null

                  if (atom.x3) {
                    xyz = new THREE__namespace.Vector3(
                      parseFloat(atom.x3),
                      parseFloat(atom.y3),
                      parseFloat(atom.z3)
                    )
                  } else if (atom.x2) {
                    xyz = new THREE__namespace.Vector3(
                      parseFloat(atom.x2),
                      parseFloat(atom.y2),
                      0
                    )
                  }

                  var element = Element$7.ByName[atom.elementType.toUpperCase()]

                  if (!element) {
                    element = JSON.parse(
                      JSON.stringify(
                        Element$7.ByName[
                          Object.keys(Element$7.ByName)[
                            Object.keys(Element$7.ByName).length - 1
                          ]
                        ]
                      )
                    )
                    element.number += 1
                    element.name = atom.elementType.toUpperCase()
                    element.fullName = 'Unknown'
                    Element$7.ByName[atom.elementType.toUpperCase()] = element
                  }

                  var atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10)
                  var added = residue.addAtom(
                    atomFullNameStruct,
                    element,
                    xyz,
                    Element$7.Role.SG,
                    true,
                    atomSerial,
                    ' ',
                    1.0,
                    0.0,
                    atomCharge
                  )

                  if (atom.hydrogenCount) {
                    added.hydrogenCount = parseInt(atom.hydrogenCount, 10)
                  }

                  if (atom.mrvValence) {
                    added.valence = parseInt(atom.mrvValence, 10)
                  }

                  addFunc(added)
                }
              }
            }

            chains = null

            for (i = 0; i < data.bonds.length; i++) {
              var cb = data.bonds[i]

              if (
                this._unpackLabel(labels[cb.start]).molId ===
                  this._unpackLabel(currentLabel).molId &&
                this._unpackLabel(labels[cb.end]).molId ===
                  this._unpackLabel(currentLabel).molId
              ) {
                atom = atoms[cb.start]

                if (!atom || !atoms[cb.end]) {
                  continue
                }

                this._parseBond(
                  parseInt(atom.id.replace(/[^0-9]/, ''), 10),
                  parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10),
                  cb.order,
                  cb.type
                )
              }
            }

            for (i = 0; i < this._complex.getSGroupCount(); i++) {
              var sGrp = this._complex.getSGroups()[i]

              for (j = 0; j < sGrp._atoms.length; j++) {
                sGrp._atoms[j] = sGrp._atoms[j].complexAtom
              }
            }

            for (i = 0; i < count; i++) {
              if (
                this._unpackLabel(labels[i]).molId ===
                this._unpackLabel(currentLabel).molId
              ) {
                atom = atoms[i]
                atom.complexAtom = null
                delete atom.complexAtom
              }
            }

            this._complex.originalCML = data.originalCML

            this._fixBondsArray()

            complex.finalize({
              needAutoBonding: false,
              detectAromaticLoops: this.settings.now.aromatic,
              enableEditing: this.settings.now.editing,
              serialAtomMap: this._serialAtomMap
            })
            this._serialAtomMap = null
            this._complex = null
            return complex
          }
        },
        {
          key: 'parseSync',
          value: function parseSync() {
            var complexes = []
            var self = this

            var moleculaSet = this._selectComponents(this._data)

            moleculaSet.forEach(function (molSet) {
              molSet.curr = 2

              if (molSet.count === 0) {
                molSet.count = 1
              }

              for (var i = 0; i < molSet.count; i++) {
                molSet.curr = i + 1
                complexes.push(self._parseSet(molSet, false))
              }
            })
            var totalAtomsParsed = 0
            complexes.forEach(function (c) {
              totalAtomsParsed += c.getAtomCount()
            })

            if (totalAtomsParsed <= 0) {
              throw new Error('The data does not contain valid atoms')
            }

            if (complexes.length > 1) {
              var joinedComplex = new Complex$7()
              joinedComplex.joinComplexes(complexes)
              joinedComplex.originalCML = complexes[0].originalCML
              return joinedComplex
            }

            if (complexes.length === 1) {
              return complexes[0]
            }

            return new Complex$7()
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(data) {
            return (
              ___default['default'].isString(data) && cmlStartRegexp.test(data)
            )
          }
        }
      ]
    )

    return CMLParser
  })(Parser)

  CMLParser.formats = ['cml']
  CMLParser.extensions = ['.cml']

  var mmtf = { exports: {} }

  ;(function (module, exports) {
    !(function (r, t) {
      t(exports)
    })(commonjsGlobal, function (r) {
      function t(r, t, n) {
        for (var e = (r.byteLength, 0), i = n.length; i > e; e++) {
          var o = n.charCodeAt(e)
          if (128 > o) r.setUint8(t++, ((o >>> 0) & 127) | 0)
          else if (2048 > o)
            r.setUint8(t++, ((o >>> 6) & 31) | 192),
              r.setUint8(t++, ((o >>> 0) & 63) | 128)
          else if (65536 > o)
            r.setUint8(t++, ((o >>> 12) & 15) | 224),
              r.setUint8(t++, ((o >>> 6) & 63) | 128),
              r.setUint8(t++, ((o >>> 0) & 63) | 128)
          else {
            if (!(1114112 > o)) throw new Error('bad codepoint ' + o)
            r.setUint8(t++, ((o >>> 18) & 7) | 240),
              r.setUint8(t++, ((o >>> 12) & 63) | 128),
              r.setUint8(t++, ((o >>> 6) & 63) | 128),
              r.setUint8(t++, ((o >>> 0) & 63) | 128)
          }
        }
      }
      function n(r) {
        for (var t = 0, n = 0, e = r.length; e > n; n++) {
          var i = r.charCodeAt(n)
          if (128 > i) t += 1
          else if (2048 > i) t += 2
          else if (65536 > i) t += 3
          else {
            if (!(1114112 > i)) throw new Error('bad codepoint ' + i)
            t += 4
          }
        }
        return t
      }
      function e(r, i, o) {
        var a = typeof r
        if ('string' === a) {
          var u = n(r)
          if (32 > u) return i.setUint8(o, 160 | u), t(i, o + 1, r), 1 + u
          if (256 > u)
            return (
              i.setUint8(o, 217), i.setUint8(o + 1, u), t(i, o + 2, r), 2 + u
            )
          if (65536 > u)
            return (
              i.setUint8(o, 218), i.setUint16(o + 1, u), t(i, o + 3, r), 3 + u
            )
          if (4294967296 > u)
            return (
              i.setUint8(o, 219), i.setUint32(o + 1, u), t(i, o + 5, r), 5 + u
            )
        }
        if (r instanceof Uint8Array) {
          var u = r.byteLength,
            s = new Uint8Array(i.buffer)
          if (256 > u)
            return (
              i.setUint8(o, 196), i.setUint8(o + 1, u), s.set(r, o + 2), 2 + u
            )
          if (65536 > u)
            return (
              i.setUint8(o, 197), i.setUint16(o + 1, u), s.set(r, o + 3), 3 + u
            )
          if (4294967296 > u)
            return (
              i.setUint8(o, 198), i.setUint32(o + 1, u), s.set(r, o + 5), 5 + u
            )
        }
        if ('number' === a) {
          if (!isFinite(r)) throw new Error('Number not finite: ' + r)
          if (Math.floor(r) !== r)
            return i.setUint8(o, 203), i.setFloat64(o + 1, r), 9
          if (r >= 0) {
            if (128 > r) return i.setUint8(o, r), 1
            if (256 > r) return i.setUint8(o, 204), i.setUint8(o + 1, r), 2
            if (65536 > r) return i.setUint8(o, 205), i.setUint16(o + 1, r), 3
            if (4294967296 > r)
              return i.setUint8(o, 206), i.setUint32(o + 1, r), 5
            throw new Error('Number too big 0x' + r.toString(16))
          }
          if (r >= -32) return i.setInt8(o, r), 1
          if (r >= -128) return i.setUint8(o, 208), i.setInt8(o + 1, r), 2
          if (r >= -32768) return i.setUint8(o, 209), i.setInt16(o + 1, r), 3
          if (r >= -2147483648)
            return i.setUint8(o, 210), i.setInt32(o + 1, r), 5
          throw new Error('Number too small -0x' + (-r).toString(16).substr(1))
        }
        if (null === r) return i.setUint8(o, 192), 1
        if ('boolean' === a) return i.setUint8(o, r ? 195 : 194), 1
        if ('object' === a) {
          var u,
            f = 0,
            c = Array.isArray(r)
          if (c) u = r.length
          else {
            var d = Object.keys(r)
            u = d.length
          }
          var f
          if (
            (16 > u
              ? (i.setUint8(o, u | (c ? 144 : 128)), (f = 1))
              : 65536 > u
              ? (i.setUint8(o, c ? 220 : 222), i.setUint16(o + 1, u), (f = 3))
              : 4294967296 > u &&
                (i.setUint8(o, c ? 221 : 223), i.setUint32(o + 1, u), (f = 5)),
            c)
          )
            for (var l = 0; u > l; l++) f += e(r[l], i, o + f)
          else
            for (var l = 0; u > l; l++) {
              var v = d[l]
              ;(f += e(v, i, o + f)), (f += e(r[v], i, o + f))
            }
          return f
        }
        throw new Error('Unknown type ' + a)
      }
      function i(r) {
        var t = typeof r
        if ('string' === t) {
          var e = n(r)
          if (32 > e) return 1 + e
          if (256 > e) return 2 + e
          if (65536 > e) return 3 + e
          if (4294967296 > e) return 5 + e
        }
        if (r instanceof Uint8Array) {
          var e = r.byteLength
          if (256 > e) return 2 + e
          if (65536 > e) return 3 + e
          if (4294967296 > e) return 5 + e
        }
        if ('number' === t) {
          if (Math.floor(r) !== r) return 9
          if (r >= 0) {
            if (128 > r) return 1
            if (256 > r) return 2
            if (65536 > r) return 3
            if (4294967296 > r) return 5
            throw new Error('Number too big 0x' + r.toString(16))
          }
          if (r >= -32) return 1
          if (r >= -128) return 2
          if (r >= -32768) return 3
          if (r >= -2147483648) return 5
          throw new Error('Number too small -0x' + r.toString(16).substr(1))
        }
        if ('boolean' === t || null === r) return 1
        if ('object' === t) {
          var e,
            o = 0
          if (Array.isArray(r)) {
            e = r.length
            for (var a = 0; e > a; a++) o += i(r[a])
          } else {
            var u = Object.keys(r)
            e = u.length
            for (var a = 0; e > a; a++) {
              var s = u[a]
              o += i(s) + i(r[s])
            }
          }
          if (16 > e) return 1 + o
          if (65536 > e) return 3 + o
          if (4294967296 > e) return 5 + o
          throw new Error('Array or object too long 0x' + e.toString(16))
        }
        throw new Error('Unknown type ' + t)
      }
      function o(r) {
        var t = new ArrayBuffer(i(r)),
          n = new DataView(t)
        return e(r, n, 0), new Uint8Array(t)
      }
      function a(r, t, n) {
        return t
          ? new r(t.buffer, t.byteOffset, t.byteLength / (n || 1))
          : void 0
      }
      function u(r) {
        return a(DataView, r)
      }
      function s(r) {
        return a(Uint8Array, r)
      }
      function f(r) {
        return a(Int8Array, r)
      }
      function c(r) {
        return a(Int32Array, r, 4)
      }
      function d(r) {
        return a(Float32Array, r, 4)
      }
      function l(r, t) {
        var n = r.length / 2
        t || (t = new Int16Array(n))
        for (var e = 0, i = 0; n > e; ++e, i += 2)
          t[e] = (r[i] << 8) ^ (r[i + 1] << 0)
        return t
      }
      function v(r, t) {
        var n = r.length
        t || (t = new Uint8Array(2 * n))
        for (var e = u(t), i = 0; n > i; ++i) e.setInt16(2 * i, r[i])
        return s(t)
      }
      function g(r, t) {
        var n = r.length / 4
        t || (t = new Int32Array(n))
        for (var e = 0, i = 0; n > e; ++e, i += 4)
          t[e] =
            (r[i] << 24) ^ (r[i + 1] << 16) ^ (r[i + 2] << 8) ^ (r[i + 3] << 0)
        return t
      }
      function L(r, t) {
        var n = r.length
        t || (t = new Uint8Array(4 * n))
        for (var e = u(t), i = 0; n > i; ++i) e.setInt32(4 * i, r[i])
        return s(t)
      }
      function h(r, t) {
        var n = r.length
        t || (t = new Float32Array(n / 4))
        for (
          var e = u(t), i = u(r), o = 0, a = 0, s = n / 4;
          s > o;
          ++o, a += 4
        )
          e.setFloat32(a, i.getFloat32(a), !0)
        return t
      }
      function y(r, t, n) {
        var e = r.length,
          i = 1 / t
        n || (n = new Float32Array(e))
        for (var o = 0; e > o; ++o) n[o] = r[o] * i
        return n
      }
      function m(r, t, n) {
        var e = r.length
        n || (n = new Int32Array(e))
        for (var i = 0; e > i; ++i) n[i] = Math.round(r[i] * t)
        return n
      }
      function p(r, t) {
        var n, e
        if (!t) {
          var i = 0
          for (n = 0, e = r.length; e > n; n += 2) i += r[n + 1]
          t = new r.constructor(i)
        }
        var o = 0
        for (n = 0, e = r.length; e > n; n += 2)
          for (var a = r[n], u = r[n + 1], s = 0; u > s; ++s) (t[o] = a), ++o
        return t
      }
      function U(r) {
        if (0 === r.length) return new Int32Array()
        var t,
          n,
          e = 2
        for (t = 1, n = r.length; n > t; ++t) r[t - 1] !== r[t] && (e += 2)
        var i = new Int32Array(e),
          o = 0,
          a = 1
        for (t = 1, n = r.length; n > t; ++t)
          r[t - 1] !== r[t]
            ? ((i[o] = r[t - 1]), (i[o + 1] = a), (a = 1), (o += 2))
            : ++a
        return (i[o] = r[r.length - 1]), (i[o + 1] = a), i
      }
      function b(r, t) {
        var n = r.length
        t || (t = new r.constructor(n)), n && (t[0] = r[0])
        for (var e = 1; n > e; ++e) t[e] = r[e] + t[e - 1]
        return t
      }
      function I(r, t) {
        var n = r.length
        t || (t = new r.constructor(n)), (t[0] = r[0])
        for (var e = 1; n > e; ++e) t[e] = r[e] - r[e - 1]
        return t
      }
      function w(r, t) {
        var n,
          e,
          i = r instanceof Int8Array ? 127 : 32767,
          o = -i - 1,
          a = r.length
        if (!t) {
          var u = 0
          for (n = 0; a > n; ++n) r[n] < i && r[n] > o && ++u
          t = new Int32Array(u)
        }
        for (n = 0, e = 0; a > n; ) {
          for (var s = 0; r[n] === i || r[n] === o; ) (s += r[n]), ++n
          ;(s += r[n]), ++n, (t[e] = s), ++e
        }
        return t
      }
      function C(r, t) {
        var n,
          e = t ? 127 : 32767,
          i = -e - 1,
          o = r.length,
          a = 0
        for (n = 0; o > n; ++n) {
          var u = r[n]
          0 === u
            ? ++a
            : (a +=
                u === e || u === i
                  ? 2
                  : u > 0
                  ? Math.ceil(u / e)
                  : Math.ceil(u / i))
        }
        var s = t ? new Int8Array(a) : new Int16Array(a),
          f = 0
        for (n = 0; o > n; ++n) {
          var u = r[n]
          if (u >= 0) for (; u >= e; ) (s[f] = e), ++f, (u -= e)
          else for (; i >= u; ) (s[f] = i), ++f, (u -= i)
          ;(s[f] = u), ++f
        }
        return s
      }
      function A(r, t) {
        return b(p(r), t)
      }
      function x(r) {
        return U(I(r))
      }
      function M(r, t, n) {
        return y(p(r, c(n)), t, n)
      }
      function F(r, t) {
        return U(m(r, t))
      }
      function S(r, t, n) {
        return y(b(r, c(n)), t, n)
      }
      function E(r, t, n) {
        return I(m(r, t), n)
      }
      function N(r, t, n) {
        return y(w(r, c(n)), t, n)
      }
      function O(r, t, n) {
        var e = w(r, c(n))
        return S(e, t, d(e))
      }
      function T(r, t, n) {
        return C(E(r, t), n)
      }
      function k(r) {
        var t = u(r),
          n = t.getInt32(0),
          e = t.getInt32(4),
          i = r.subarray(8, 12),
          r = r.subarray(12)
        return [n, r, e, i]
      }
      function j(r, t, n, e) {
        var i = new ArrayBuffer(12 + e.byteLength),
          o = new Uint8Array(i),
          a = new DataView(i)
        return (
          a.setInt32(0, r), a.setInt32(4, t), n && o.set(n, 8), o.set(e, 12), o
        )
      }
      function q(r) {
        var t = r.length,
          n = s(r)
        return j(2, t, void 0, n)
      }
      function D(r) {
        var t = r.length,
          n = L(r)
        return j(4, t, void 0, n)
      }
      function P(r, t) {
        var n = r.length / t,
          e = L([t]),
          i = s(r)
        return j(5, n, e, i)
      }
      function z(r) {
        var t = r.length,
          n = L(U(r))
        return j(6, t, void 0, n)
      }
      function B(r) {
        var t = r.length,
          n = L(x(r))
        return j(8, t, void 0, n)
      }
      function V(r, t) {
        var n = r.length,
          e = L([t]),
          i = L(F(r, t))
        return j(9, n, e, i)
      }
      function G(r, t) {
        var n = r.length,
          e = L([t]),
          i = v(T(r, t))
        return j(10, n, e, i)
      }
      function R(r) {
        var t = {}
        return (
          rr.forEach(function (n) {
            void 0 !== r[n] && (t[n] = r[n])
          }),
          r.bondAtomList && (t.bondAtomList = D(r.bondAtomList)),
          r.bondOrderList && (t.bondOrderList = q(r.bondOrderList)),
          (t.xCoordList = G(r.xCoordList, 1e3)),
          (t.yCoordList = G(r.yCoordList, 1e3)),
          (t.zCoordList = G(r.zCoordList, 1e3)),
          r.bFactorList && (t.bFactorList = G(r.bFactorList, 100)),
          r.atomIdList && (t.atomIdList = B(r.atomIdList)),
          r.altLocList && (t.altLocList = z(r.altLocList)),
          r.occupancyList && (t.occupancyList = V(r.occupancyList, 100)),
          (t.groupIdList = B(r.groupIdList)),
          (t.groupTypeList = D(r.groupTypeList)),
          r.secStructList && (t.secStructList = q(r.secStructList)),
          r.insCodeList && (t.insCodeList = z(r.insCodeList)),
          r.sequenceIndexList && (t.sequenceIndexList = B(r.sequenceIndexList)),
          (t.chainIdList = P(r.chainIdList, 4)),
          r.chainNameList && (t.chainNameList = P(r.chainNameList, 4)),
          t
        )
      }
      function H(r) {
        function t(r) {
          for (var t = {}, n = 0; r > n; n++) {
            var e = o()
            t[e] = o()
          }
          return t
        }
        function n(t) {
          var n = r.subarray(a, a + t)
          return (a += t), n
        }
        function e(t) {
          var n = r.subarray(a, a + t)
          a += t
          var e = 65535
          if (t > e) {
            for (var i = [], o = 0; o < n.length; o += e)
              i.push(String.fromCharCode.apply(null, n.subarray(o, o + e)))
            return i.join('')
          }
          return String.fromCharCode.apply(null, n)
        }
        function i(r) {
          for (var t = new Array(r), n = 0; r > n; n++) t[n] = o()
          return t
        }
        function o() {
          var o,
            s,
            f = r[a]
          if (0 === (128 & f)) return a++, f
          if (128 === (240 & f)) return (s = 15 & f), a++, t(s)
          if (144 === (240 & f)) return (s = 15 & f), a++, i(s)
          if (160 === (224 & f)) return (s = 31 & f), a++, e(s)
          if (224 === (224 & f)) return (o = u.getInt8(a)), a++, o
          switch (f) {
            case 192:
              return a++, null
            case 194:
              return a++, !1
            case 195:
              return a++, !0
            case 196:
              return (s = u.getUint8(a + 1)), (a += 2), n(s)
            case 197:
              return (s = u.getUint16(a + 1)), (a += 3), n(s)
            case 198:
              return (s = u.getUint32(a + 1)), (a += 5), n(s)
            case 202:
              return (o = u.getFloat32(a + 1)), (a += 5), o
            case 203:
              return (o = u.getFloat64(a + 1)), (a += 9), o
            case 204:
              return (o = r[a + 1]), (a += 2), o
            case 205:
              return (o = u.getUint16(a + 1)), (a += 3), o
            case 206:
              return (o = u.getUint32(a + 1)), (a += 5), o
            case 208:
              return (o = u.getInt8(a + 1)), (a += 2), o
            case 209:
              return (o = u.getInt16(a + 1)), (a += 3), o
            case 210:
              return (o = u.getInt32(a + 1)), (a += 5), o
            case 217:
              return (s = u.getUint8(a + 1)), (a += 2), e(s)
            case 218:
              return (s = u.getUint16(a + 1)), (a += 3), e(s)
            case 219:
              return (s = u.getUint32(a + 1)), (a += 5), e(s)
            case 220:
              return (s = u.getUint16(a + 1)), (a += 3), i(s)
            case 221:
              return (s = u.getUint32(a + 1)), (a += 5), i(s)
            case 222:
              return (s = u.getUint16(a + 1)), (a += 3), t(s)
            case 223:
              return (s = u.getUint32(a + 1)), (a += 5), t(s)
          }
          throw new Error('Unknown type 0x' + f.toString(16))
        }
        var a = 0,
          u = new DataView(r.buffer)
        return o()
      }
      function W(r, t, n, e) {
        switch (r) {
          case 1:
            return h(t)
          case 2:
            return f(t)
          case 3:
            return l(t)
          case 4:
            return g(t)
          case 5:
            return s(t)
          case 6:
            return p(g(t), new Uint8Array(n))
          case 7:
            return p(g(t))
          case 8:
            return A(g(t))
          case 9:
            return M(g(t), g(e)[0])
          case 10:
            return O(l(t), g(e)[0])
          case 11:
            return y(l(t), g(e)[0])
          case 12:
            return N(l(t), g(e)[0])
          case 13:
            return N(f(t), g(e)[0])
          case 14:
            return w(l(t))
          case 15:
            return w(f(t))
        }
      }
      function X(r, t) {
        t = t || {}
        var n = t.ignoreFields,
          e = {}
        return (
          nr.forEach(function (t) {
            var i = n ? -1 !== n.indexOf(t) : !1,
              o = r[t]
            i ||
              void 0 === o ||
              (o instanceof Uint8Array
                ? (e[t] = W.apply(null, k(o)))
                : (e[t] = o))
          }),
          e
        )
      }
      function J(r) {
        return String.fromCharCode.apply(null, r).replace(/\0/g, '')
      }
      function K(r, t, n) {
        n = n || {}
        var e,
          i,
          o,
          a,
          u,
          s,
          f = n.firstModelOnly,
          c = t.onModel,
          d = t.onChain,
          l = t.onGroup,
          v = t.onAtom,
          g = t.onBond,
          L = 0,
          h = 0,
          y = 0,
          m = 0,
          p = 0,
          U = -1,
          b = r.chainNameList,
          I = r.secStructList,
          w = r.insCodeList,
          C = r.sequenceIndexList,
          A = r.atomIdList,
          x = r.bFactorList,
          M = r.altLocList,
          F = r.occupancyList,
          S = r.bondAtomList,
          E = r.bondOrderList
        for (e = 0, i = r.chainsPerModel.length; i > e && !(f && L > 0); ++e) {
          var N = r.chainsPerModel[L]
          for (c && c({ chainCount: N, modelIndex: L }), o = 0; N > o; ++o) {
            var O = r.groupsPerChain[h]
            if (d) {
              var T = J(r.chainIdList.subarray(4 * h, 4 * h + 4)),
                k = null
              b && (k = J(b.subarray(4 * h, 4 * h + 4))),
                d({
                  groupCount: O,
                  chainIndex: h,
                  modelIndex: L,
                  chainId: T,
                  chainName: k
                })
            }
            for (a = 0; O > a; ++a) {
              var j = r.groupList[r.groupTypeList[y]],
                q = j.atomNameList.length
              if (l) {
                var D = null
                I && (D = I[y])
                var P = null
                r.insCodeList && (P = String.fromCharCode(w[y]))
                var z = null
                C && (z = C[y]),
                  l({
                    atomCount: q,
                    groupIndex: y,
                    chainIndex: h,
                    modelIndex: L,
                    groupId: r.groupIdList[y],
                    groupType: r.groupTypeList[y],
                    groupName: j.groupName,
                    singleLetterCode: j.singleLetterCode,
                    chemCompType: j.chemCompType,
                    secStruct: D,
                    insCode: P,
                    sequenceIndex: z
                  })
              }
              for (u = 0; q > u; ++u) {
                if (v) {
                  var B = null
                  A && (B = A[m])
                  var V = null
                  x && (V = x[m])
                  var G = null
                  M && (G = String.fromCharCode(M[m]))
                  var R = null
                  F && (R = F[m]),
                    v({
                      atomIndex: m,
                      groupIndex: y,
                      chainIndex: h,
                      modelIndex: L,
                      atomId: B,
                      element: j.elementList[u],
                      atomName: j.atomNameList[u],
                      formalCharge: j.formalChargeList[u],
                      xCoord: r.xCoordList[m],
                      yCoord: r.yCoordList[m],
                      zCoord: r.zCoordList[m],
                      bFactor: V,
                      altLoc: G,
                      occupancy: R
                    })
                }
                m += 1
              }
              if (g) {
                var H = j.bondAtomList
                for (u = 0, s = j.bondOrderList.length; s > u; ++u)
                  g({
                    atomIndex1: m - q + H[2 * u],
                    atomIndex2: m - q + H[2 * u + 1],
                    bondOrder: j.bondOrderList[u]
                  })
              }
              y += 1
            }
            h += 1
          }
          if (((p = U + 1), (U = m - 1), g && S))
            for (u = 0, s = S.length; s > u; u += 2) {
              var W = S[u],
                X = S[u + 1]
              ;((W >= p && U >= W) || (X >= p && U >= X)) &&
                g({
                  atomIndex1: W,
                  atomIndex2: X,
                  bondOrder: E ? E[u / 2] : null
                })
            }
          L += 1
        }
      }
      function Q(r) {
        return o(R(r))
      }
      function Y(r, t) {
        r instanceof ArrayBuffer && (r = new Uint8Array(r))
        var n
        return (n = r instanceof Uint8Array ? H(r) : r), X(n, t)
      }
      function Z(r, t, n, e) {
        function i() {
          try {
            var r = Y(o.response)
            n(r)
          } catch (t) {
            e(t)
          }
        }
        var o = new XMLHttpRequest()
        o.addEventListener('load', i, !0),
          o.addEventListener('error', e, !0),
          (o.responseType = 'arraybuffer'),
          o.open('GET', t + r.toUpperCase()),
          o.send()
      }
      function $(r, t, n) {
        Z(r, or, t, n)
      }
      function _(r, t, n) {
        Z(r, ar, t, n)
      }
      var rr = [
          'mmtfVersion',
          'mmtfProducer',
          'unitCell',
          'spaceGroup',
          'structureId',
          'title',
          'depositionDate',
          'releaseDate',
          'experimentalMethods',
          'resolution',
          'rFree',
          'rWork',
          'bioAssemblyList',
          'ncsOperatorList',
          'entityList',
          'groupList',
          'numBonds',
          'numAtoms',
          'numGroups',
          'numChains',
          'numModels',
          'groupsPerChain',
          'chainsPerModel'
        ],
        tr = [
          'xCoordList',
          'yCoordList',
          'zCoordList',
          'groupIdList',
          'groupTypeList',
          'chainIdList',
          'bFactorList',
          'atomIdList',
          'altLocList',
          'occupancyList',
          'secStructList',
          'insCodeList',
          'sequenceIndexList',
          'chainNameList',
          'bondAtomList',
          'bondOrderList'
        ],
        nr = rr.concat(tr),
        er = 'v1.1.0dev',
        ir = '//mmtf.rcsb.org/v1.0/',
        or = ir + 'full/',
        ar = ir + 'reduced/'
      ;(r.encode = Q),
        (r.decode = Y),
        (r.traverse = K),
        (r.fetch = $),
        (r.fetchReduced = _),
        (r.version = er),
        (r.fetchUrl = or),
        (r.fetchReducedUrl = ar),
        (r.encodeMsgpack = o),
        (r.encodeMmtf = R),
        (r.decodeMsgpack = H),
        (r.decodeMmtf = X)
    })
  })(mmtf, mmtf.exports)

  var MMTF = mmtf.exports

  function _createSuper$m(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$m()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$m() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$6 = chem.Complex,
    Chain$1 = chem.Chain,
    Atom$1 = chem.Atom,
    Element$6 = chem.Element,
    Helix$1 = chem.Helix,
    Sheet$1 = chem.Sheet,
    Strand$1 = chem.Strand,
    Bond$2 = chem.Bond,
    Assembly$1 = chem.Assembly,
    Molecule$6 = chem.Molecule

  var ArrayComparator = /*#__PURE__*/ (function () {
    function ArrayComparator(original) {
      _classCallCheck(this, ArrayComparator)

      this._original = Array.from(original)

      this._original.sort()

      this._sum = 0

      for (var i = 0; i < this._original.length; ++i) {
        this._sum += this._original[i]
      }
    }

    _createClass(ArrayComparator, [
      {
        key: 'compare',
        value: function compare(candidate) {
          var len = candidate.length

          if (len !== this._original.length) {
            return false
          }

          var sum = 0
          var i

          for (i = 0; i < len; ++i) {
            sum += candidate[i]
          }

          if (sum !== this._sum) {
            return false
          }

          var sorted = Array.from(candidate)
          sorted.sort()

          for (i = 0; i < len; ++i) {
            if (sorted[i] !== this._original[i]) {
              return false
            }
          }

          return true
        }
      }
    ])

    return ArrayComparator
  })()

  ArrayComparator.prototype.constructor = ArrayComparator
  var StructuralElementType = StructuralElement.Type
  var secStructToType = [
    StructuralElementType.HELIX_PI,
    StructuralElementType.BEND,
    StructuralElementType.HELIX_ALPHA,
    StructuralElementType.STRAND,
    StructuralElementType.HELIX_310,
    StructuralElementType.BRIDGE,
    StructuralElementType.TURN,
    StructuralElementType.COIL
  ]

  function getFirstByte(buf) {
    var bytes = new Uint8Array(buf, 0, 1)
    return bytes[0]
  }

  var MMTFParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(MMTFParser, _Parser)

    var _super = _createSuper$m(MMTFParser)

    function MMTFParser(data, options) {
      var _this

      _classCallCheck(this, MMTFParser)

      _this = _super.call(this, data, options)
      _this._options.fileType = 'mmtf'
      return _this
    }

    _createClass(
      MMTFParser,
      [
        {
          key: '_onModel',
          value: function _onModel(_modelData) {}
        },
        {
          key: '_onChain',
          value: function _onChain(chainData) {
            if (chainData.modelIndex !== 0) {
              return
            }

            var chain = new Chain$1(this._complex, chainData.chainName)
            this._complex._chains[chainData.chainIndex] = chain
            chain._index = chainData.chainIndex
          }
        },
        {
          key: '_onGroup',
          value: function _onGroup(groupData) {
            if (groupData.modelIndex !== 0) {
              return
            }

            if (this.settings.now.nowater) {
              if (
                groupData.groupName === 'HOH' ||
                groupData.groupName === 'WAT'
              ) {
                return
              }
            }

            var chain = this._complex._chains[groupData.chainIndex]
            var icode = !groupData.insCode.charCodeAt(0)
              ? ''
              : groupData.insCode
            var residue = chain.addResidue(
              groupData.groupName,
              groupData.groupId,
              icode
            )
            residue._index = groupData.groupIndex

            this._updateSecStructure(this._complex, residue, groupData)
          }
        },
        {
          key: '_onAtom',
          value: function _onAtom(atomData) {
            if (atomData.modelIndex !== 0) {
              return
            }

            var altLoc = !atomData.altLoc.charCodeAt(0) ? '' : atomData.altLoc
            var atom = new Atom$1(
              atomData.groupIndex,
              atomData.atomName,
              Element$6.getByName(atomData.element.toUpperCase()),
              new THREE__namespace.Vector3(
                atomData.xCoord,
                atomData.yCoord,
                atomData.zCoord
              ),
              Element$6.Role[atomData.atomName],
              false,
              atomData.atomId,
              altLoc,
              atomData.occupancy,
              atomData.bFactor,
              atomData.formalCharge
            )
            this._complex._atoms[atomData.atomIndex] = atom
            atom.index = atomData.atomIndex
            this._serialAtomMap[atomData.atomId] = atom
          }
        },
        {
          key: '_onBond',
          value: function _onBond(bondData) {
            var right = Math.max(bondData.atomIndex1, bondData.atomIndex2)

            if (right >= this._complex._atoms.length) {
              return
            }

            var left = Math.min(bondData.atomIndex1, bondData.atomIndex2)

            this._complex.addBond(
              this._complex._atoms[left],
              this._complex._atoms[right],
              bondData.bondOrder,
              Bond$2.BondType.UNKNOWN,
              true
            )
          }
        },
        {
          key: '_updateSecStructure',
          value: function _updateSecStructure(complex, residue, groupData) {
            var helixClasses = [3, -1, 1, -1, 5]

            if (
              !___default['default'].isUndefined(groupData) &&
              groupData.secStruct === this._ssType
            ) {
              residue._secondary = this._ssStruct

              if (this._ssStruct) {
                this._ssStruct.term = residue
              }

              return
            }

            if (!___default['default'].isUndefined(groupData)) {
              var type = secStructToType[groupData.secStruct]
              this._ssType = groupData.secStruct
              this._ssStart = residue
              var struct = null

              switch (this._ssType) {
                case -1:
                case 7:
                  break

                case 0:
                case 2:
                case 4:
                  struct = new Helix$1(
                    helixClasses[this._ssType],
                    residue,
                    residue,
                    0,
                    '',
                    '',
                    0
                  )

                  complex._helices.push(struct)

                  break

                case 3: {
                  var sheet = new Sheet$1('', 0)

                  complex._sheets.push(sheet)

                  struct = new Strand$1(sheet, residue, residue, 0, null, null)
                  break
                }

                default:
                  if (type !== undefined) {
                    struct = new StructuralElement(type, residue, residue)
                  }

                  break
              }

              this._ssStruct = struct
              residue._secondary = struct

              if (struct) {
                complex.structures.push(struct)
              }
            }
          }
        },
        {
          key: '_updateMolecules',
          value: function _updateMolecules(mmtfData) {
            var entities = mmtfData.entityList

            if (!entities) {
              return
            }

            var chainsInModel0 = mmtfData.chainsPerModel[0]

            for (var i = 0; i < entities.length; i++) {
              var entity = entities[i]
              var chains = entity.chainIndexList
              var residues = []

              for (var j = 0; j < chains.length; j++) {
                var chainIndex = chains[j]

                if (chainIndex >= chainsInModel0) {
                  continue
                }

                var chain = this._complex._chains[chainIndex]
                residues = residues.concat(chain._residues.slice())
              }

              var molecule = new Molecule$6(
                this._complex,
                entity.description,
                i + 1
              )
              molecule.residues = residues
              this._complex._molecules[i] = molecule
            }
          }
        },
        {
          key: '_traverse',
          value: function _traverse(mmtfData) {
            var self = this
            var metadata = this._complex.metadata
            metadata.id = mmtfData.structureId
            metadata.title = []
            metadata.title[0] = mmtfData.title
            metadata.date = mmtfData.releaseDate
            metadata.format = 'mmtf'
            var eventCallbacks = {
              onModel: function onModel(modelData) {
                self._onModel(modelData)
              },
              onChain: function onChain(chainData) {
                self._onChain(chainData)
              },
              onGroup: function onGroup(groupData) {
                self._onGroup(groupData)
              },
              onAtom: function onAtom(atomData) {
                self._onAtom(atomData)
              },
              onBond: function onBond(bondData) {
                self._onBond(bondData)
              }
            }
            this._ssType = -1
            this._ssStruct = null
            this._ssStart = null
            MMTF.traverse(mmtfData, eventCallbacks)

            this._updateSecStructure(this._complex)

            this._updateMolecules(mmtfData)
          }
        },
        {
          key: '_linkAtomsToResidues',
          value: function _linkAtomsToResidues() {
            for (var i = 0; i < this._complex._atoms.length; ++i) {
              var atom = this._complex._atoms[i]
              var residue = this._complex._residues[atom.residue]
              atom.residue = residue

              residue._atoms.push(atom)
            }
          }
        },
        {
          key: '_findSynonymousChains',
          value: function _findSynonymousChains() {
            var named = {}

            for (var i = 0; i < this._complex._chains.length; ++i) {
              var chain = this._complex._chains[i]
              var name = chain.getName()

              if (!named.hasOwnProperty(name)) {
                named[name] = []
              }

              named[name].push(chain._index)
            }

            return named
          }
        },
        {
          key: '_parseAssemblyInfo',
          value: function _parseAssemblyInfo(mmtfData) {
            var i
            var j
            var k
            var assemblies = []
            var logger = this.logger

            for (i = 0; i < mmtfData.bioAssemblyList.length; ++i) {
              var baInfo = mmtfData.bioAssemblyList[i]

              if (baInfo.transformList.length === 0) {
                continue
              }

              var chains = baInfo.transformList[0].chainIndexList
              var chainListCheck = new ArrayComparator(chains)
              var chainNames = {}

              for (j = 0; j < chains.length; ++j) {
                chainNames[this._complex._chains[chains[j]].getName()] = 1
              }

              var allChains = []
              var name = void 0

              for (name in chainNames) {
                if (chainNames.hasOwnProperty(name)) {
                  Array.prototype.push.apply(
                    allChains,
                    this._chainsByName[name]
                  )
                }
              }

              if (!chainListCheck.compare(allChains)) {
                logger.debug(
                  'MMTF: Assembly is missing some of the synonymous chains. Skipping...'
                )
              }

              var a = new Assembly$1(this._complex)

              for (name in chainNames) {
                if (chainNames.hasOwnProperty(name)) {
                  a.addChain(name)
                }
              }

              a.addMatrix(
                new THREE__namespace.Matrix4()
                  .fromArray(baInfo.transformList[0].matrix)
                  .transpose()
              )

              for (j = 1; j < baInfo.transformList.length; ++j) {
                var transform = baInfo.transformList[j]

                if (!chainListCheck.compare(transform.chainIndexList)) {
                  logger.debug(
                    'MMTF: Chain lists differ for different transforms in one assembly. Skipping...'
                  )
                  continue
                }

                var m = new THREE__namespace.Matrix4()
                  .fromArray(transform.matrix)
                  .transpose()

                for (k = 0; k < a.matrices.length; ++k) {
                  if (a.matrices[k].equals(m)) {
                    break
                  }
                }

                if (k === a.matrices.length) {
                  a.addMatrix(m)
                }
              }

              a.finalize()
              assemblies.push(a)
            }

            return assemblies
          }
        },
        {
          key: '_markHeteroAtoms',
          value: function _markHeteroAtoms(mmtfData) {
            var chainsInModel0 = mmtfData.chainsPerModel[0]

            for (var i = 0; i < mmtfData.entityList.length; ++i) {
              var entity = mmtfData.entityList[i]

              if (entity.type !== 'polymer') {
                for (var j = 0; j < entity.chainIndexList.length; ++j) {
                  var chainIndex = entity.chainIndexList[j]

                  if (chainIndex >= chainsInModel0) {
                    continue
                  }

                  var chain = this._complex._chains[chainIndex]

                  for (var k = 0; k < chain._residues.length; ++k) {
                    var res = chain._residues[k]

                    for (var m = 0; m < res._atoms.length; ++m) {
                      res._atoms[m].het = true
                    }
                  }
                }
              }
            }
          }
        },
        {
          key: '_joinSynonymousChains',
          value: function _joinSynonymousChains() {
            var i
            var j
            var primaryChainsArray = []
            var primaryChainsHash = {}

            for (i = 0; i < this._complex._chains.length; ++i) {
              var chain = this._complex._chains[i]
              var name = chain.getName()

              if (!primaryChainsHash.hasOwnProperty(name)) {
                primaryChainsHash[name] = chain
                chain._index = primaryChainsArray.length
                primaryChainsArray.push(chain)
                continue
              }

              var primary = primaryChainsHash[name]

              for (j = 0; j < chain._residues.length; ++j) {
                var residue = chain._residues[j]

                primary._residues.push(residue)

                residue._chain = primary
              }
            }

            this._complex._chains = primaryChainsArray
          }
        },
        {
          key: 'parseSync',
          value: function parseSync() {
            var mmtfData = MMTF.decode(this._data)
            this._complex = new Complex$6()
            this._serialAtomMap = {}

            this._traverse(mmtfData)

            this._linkAtomsToResidues()

            this._markHeteroAtoms(mmtfData)

            this._chainsByName = this._findSynonymousChains()
            Array.prototype.push.apply(
              this._complex.units,
              this._parseAssemblyInfo(mmtfData)
            )

            this._joinSynonymousChains()

            this._complex.finalize({
              needAutoBonding: false,
              detectAromaticLoops: this.settings.now.aromatic,
              enableEditing: this.settings.now.editing,
              serialAtomMap: this._serialAtomMap
            })

            return this._complex
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(data) {
            return (
              ___default['default'].isArrayBuffer(data) &&
              (getFirstByte(data) | 1) === 0xdf
            )
          }
        }
      ]
    )

    return MMTFParser
  })(Parser)

  MMTFParser.formats = ['mmtf']
  MMTFParser.extensions = ['.mmtf']
  MMTFParser.binary = true

  function _createSuper$l(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$l()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$l() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ParsingError = /*#__PURE__*/ (function (_Error) {
    _inherits(ParsingError, _Error)

    var _super = _createSuper$l(ParsingError)

    function ParsingError(message, line, column) {
      var _this

      _classCallCheck(this, ParsingError)

      _this = _super.call(
        this,
        'data:'.concat(line, ':').concat(column, ': ').concat(message)
      )

      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), ParsingError)
      }

      _this.name = 'ParsingError'
      _this.parseLine = line
      _this.parseColumn = column
      return _this
    }

    return _createClass(ParsingError)
  })(/*#__PURE__*/ _wrapNativeSuper(Error))

  function _isWhitespace(ch) {
    return ch === 32 || ch === 10 || ch === 13 || ch === 9
  }

  function _inlineIndexOf(ch0, str, idx) {
    var len = str.length
    var ch = -1

    while (idx < len) {
      ch = str.charCodeAt(idx)

      if (ch === ch0 || ch === 10) {
        break
      }

      ++idx
    }

    return ch === ch0 ? idx : -1
  }

  function readCIF(source) {
    var i = 0
    var j = 0
    var n = source.length
    var code = NaN
    var newline = true
    var line = 1
    var column = 1
    var begin
    var state = 0
    var result = {}
    var block = {}
    var keys = []
    var keysCount = 0
    var key = ''
    var values = []
    var valuesCount = 0
    var value

    function _parseValue() {
      var val

      if (
        (code === 46 || code === 63) &&
        (i + 1 >= n || _isWhitespace(source.charCodeAt(i + 1)))
      ) {
        ++column
        ++i
        return undefined
      }

      if (newline && code === 59) {
        j = i
        var lines = 0

        do {
          j = _inlineIndexOf(10, source, j + 1)

          if (j === -1) {
            throw new ParsingError(
              'Unterminated text block found',
              line,
              column
            )
          }

          ++lines
        } while ((j + 1 < n && source.charCodeAt(j + 1) !== code) || j + 1 >= n)

        val = source.substring(i + 1, j).replace(/\r/g, '')
        i = j + 2
        line += lines
        column = 1
        newline = false
        return val
      }

      if (code === 39 || code === 34) {
        j = i

        do {
          j = _inlineIndexOf(code, source, j + 1)

          if (j === -1) {
            throw new ParsingError(
              'Unterminated quoted string found',
              line,
              column
            )
          }
        } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)))

        val = source.substring(i + 1, j)
        column += j - i + 1
        i = j + 1
        return val
      }

      j = i

      while (j < n && !_isWhitespace(source.charCodeAt(j))) {
        ++j
      }

      val = source.substring(i, j)
      column += j - i
      i = j
      var num = Number(val)

      if (!Number.isNaN(num)) {
        return num
      }

      return val
    }

    function _storeKey(tag) {
      keys[keysCount++] = tag
    }

    function _storeValue(val) {
      var keyIndex = valuesCount % keysCount
      values[keyIndex].push(val)
      ++valuesCount
      return val
    }

    while (i <= n) {
      code = source.charCodeAt(i)

      if (code === 13);
      else if (code === 10) {
        newline = true
        ++line
        column = 1
      } else {
        if (code === 32 || code === 9);
        else if (code === 35) {
          i = _inlineIndexOf(10, source, i + 1)

          if (i === -1) {
            break
          } else {
            continue
          }
        } else if (state === 0) {
          if (
            (code === 68 || code === 100) &&
            source.substr(i + 1, 4).toLowerCase() === 'ata_'
          ) {
            j = i + 5
            begin = j

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j
            }

            column += j - i
            i = j

            if (begin < i) {
              result[source.substring(begin, i)] = block = {}
              state = 1
              continue
            } else {
              throw new ParsingError('Data block name missing', line, column)
            }
          } else if (Number.isNaN(code)) {
            break
          } else {
            throw new ParsingError(
              'Unexpected character in state '.concat(state),
              line,
              column
            )
          }
        } else if (state === 1) {
          if (
            (code === 68 || code === 100) &&
            source.substr(i + 1, 4).toLowerCase() === 'ata_'
          ) {
            state = 0
            continue
          } else if (code === 95) {
            j = i + 1
            begin = j

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j
            }

            column += j - i
            i = j

            if (begin < i) {
              key = source.substring(begin, i)
              state = 2
              continue
            } else {
              throw new ParsingError('Tag name missing', line, column)
            }
          } else if (
            (code === 76 || code === 108) &&
            source.substr(i + 1, 4).toLowerCase() === 'oop_'
          ) {
            i += 5
            column += 5

            if (i < n && !_isWhitespace(source.charCodeAt(i))) {
              throw new ParsingError(
                'Unexpected character in state '.concat(state),
                line,
                column
              )
            } else {
              keys = []
              keysCount = 0
              values = []
              valuesCount = 0
              state = 3
              continue
            }
          } else if (Number.isNaN(code)) {
            break
          } else {
            throw new ParsingError(
              'Unexpected character in state '.concat(state),
              line,
              column
            )
          }
        } else if (state === 2) {
          if (Number.isNaN(code)) {
            break
          }

          value = _parseValue()

          ___default['default'].set(block, key, value)

          state = 1
          continue
        } else if (state === 3) {
          if (code === 95) {
            j = i + 1
            begin = j

            while (j < n && !_isWhitespace(source.charCodeAt(j))) {
              ++j
            }

            column += j - i
            i = j

            if (begin < i) {
              _storeKey(source.substring(begin, i))

              continue
            } else {
              throw new ParsingError('Tag name missing', line, column)
            }
          } else {
            if (keysCount > 0) {
              for (var keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
                value = []
                values[keyIndex] = value

                ___default['default'].set(block, keys[keyIndex], value)
              }

              state = 4
              continue
            }

            throw new ParsingError(
              'Data tags are missing inside a loop',
              line,
              column
            )
          }
        } else if (state === 4) {
          if (
            (code === 68 || code === 100) &&
            source.substr(i + 1, 4).toLowerCase() === 'ata_'
          ) {
            state = 0
          } else if (code === 95) {
            state = 1
          } else if (
            (code === 76 || code === 108) &&
            source.substr(i + 1, 4).toLowerCase() === 'oop_'
          ) {
            state = 1
          } else if (Number.isNaN(code)) {
            state = 0
          } else {
            _storeValue(_parseValue())
          }

          continue
        } else {
          throw new ParsingError(
            'Unexpected internal state '.concat(state),
            line,
            column
          )
        }

        newline = false
        ++column
      }

      ++i
    }

    if (state === 2) {
      throw new ParsingError(
        'Unexpected end of file in state '.concat(state),
        line,
        column
      )
    }

    return result
  }

  function _createSuper$k(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$k()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$k() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$5 = chem.Complex,
    Element$5 = chem.Element,
    Helix = chem.Helix,
    Sheet = chem.Sheet,
    Strand = chem.Strand,
    Assembly = chem.Assembly,
    Molecule$5 = chem.Molecule
  var cRequiredAtomFields = [
    'auth_seq_id',
    'Cartn_x',
    'Cartn_y',
    'Cartn_z',
    'label_atom_id'
  ]
  var cSecondaryCoding = {
    helx: 'helix',
    turn: 'turn',
    strn: 'strand'
  }

  function getTypeFromId(string) {
    var typeId = /[A-Za-z]+/.exec(string)

    if (!typeId) {
      return null
    }

    return cSecondaryCoding[typeId[0].toLowerCase()]
  }

  function arrize(arrayLikeObject) {
    if (
      arrayLikeObject === null ||
      arrayLikeObject === undefined ||
      ___default['default'].isArray(arrayLikeObject)
    ) {
      return arrayLikeObject
    }

    return [arrayLikeObject]
  }

  function nameToElement(name) {
    var veryLong = name.trim().length === 4
    return name.slice(0, veryLong ? 1 : 2).trim()
  }

  var AtomDataError = /*#__PURE__*/ (function (_Error) {
    _inherits(AtomDataError, _Error)

    var _super = _createSuper$k(AtomDataError)

    function AtomDataError(message) {
      var _this

      _classCallCheck(this, AtomDataError)

      _this = _super.call(this)
      _this.name = 'AtomDataError'
      _this.message = message
      return _this
    }

    return _createClass(AtomDataError)
  })(/*#__PURE__*/ _wrapNativeSuper(Error))

  function _getOperations(operList) {
    if (!operList) {
      return null
    }

    var idc = arrize(operList.id)
    var matrix = operList.matrix,
      vector = operList.vector

    if (!idc || !matrix || !vector) {
      return null
    }

    var ops = []

    for (var i = 0, n = idc.length; i < n; ++i) {
      var mtx = new THREE__namespace.Matrix4()
      var elements = mtx.elements

      for (var row = 0; row < 3; ++row) {
        var matrixData = matrix[row + 1]
        elements[row] = arrize(matrixData[1])[i]
        elements[row + 4] = arrize(matrixData[2])[i]
        elements[row + 8] = arrize(matrixData[3])[i]
        elements[row + 12] = arrize(vector[row + 1])[i]
      }

      ops[idc[i]] = mtx
    }

    return ops
  }

  function _extractOperations(assemblyGen, opsDict) {
    assemblyGen = ___default['default'].isString(assemblyGen)
      ? assemblyGen
      : ''.concat(assemblyGen)
    var l = assemblyGen.replace(/\)\s*\(/g, '!').replace(/[()']/g, '')
    var groupStr = l.split('!')
    var gps = []

    for (var grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
      var gr = groupStr[grIdx].split(',')
      var gp = []
      var idx = 0

      for (var i = 0, n = gr.length; i < n; ++i) {
        var s = gr[i]

        if (s.includes('-')) {
          var es = s.split('-')
          var j = parseInt(es[0], 10)
          var m = parseInt(es[1], 10)

          for (; j <= m; ++j) {
            gp[idx++] = opsDict[j]
          }
        } else {
          gp[idx++] = opsDict[s]
        }
      }

      gps.push(gp)
    }

    var matrices = []
    var cnt = 0

    function traverse(level, mtx) {
      for (var ii = 0, nn = gps[level].length; ii < nn; ++ii) {
        var newMtx = mtx ? mtx.clone() : new THREE__namespace.Matrix4()
        newMtx.multiplyMatrices(gps[level][ii], newMtx)

        if (level === 0) {
          matrices[cnt++] = newMtx
        } else {
          traverse(level - 1, newMtx)
        }
      }
    }

    traverse(gps.length - 1)
    return matrices
  }

  var CIFParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(CIFParser, _Parser)

    var _super2 = _createSuper$k(CIFParser)

    function CIFParser(data, options) {
      var _this2

      _classCallCheck(this, CIFParser)

      _this2 = _super2.call(this, data, options)
      _this2.asymDict = {}
      _this2.molecules = []
      _this2._options.fileType = 'cif'
      return _this2
    }

    _createClass(
      CIFParser,
      [
        {
          key: 'parseSync',
          value: function parseSync() {
            this.logger.info('Parsing CIF file..')
            var data = readCIF(this._data)
            return this._toComplex(data)
          }
        },
        {
          key: '_toComplex',
          value: function _toComplex(cifData) {
            var complex = new Complex$5()
            var complexData = cifData[Object.keys(cifData)[0]]

            this._extractAtoms(complex, complexData)

            this._extractSecondary(complex, complexData)

            this._extractAssemblies(complex, complexData)

            this._extractMolecules(complex, complexData)

            this._extractMetadata(complex, complexData)

            complex.finalize({
              needAutoBonding: true,
              detectAromaticLoops: this.settings.now.aromatic,
              enableEditing: this.settings.now.editing
            })
            return complex
          }
        },
        {
          key: '_extractMetadata',
          value: function _extractMetadata(complex, complexData) {
            var metadata = complex.metadata
            metadata.id = complexData.entry.id
            metadata.classification = complexData.struct_keywords.pdbx_keywords
            var databaserev = complexData.database_PDB_rev
            metadata.date =
              databaserev && databaserev.date_original
                ? databaserev.date_original
                : ''
            metadata.format = 'cif'
            metadata.title = []
            metadata.title[0] = complexData.struct.title
          }
        },
        {
          key: '_extractMolecules',
          value: function _extractMolecules(complex, complexData) {
            var molData = complexData.entity
            var names = arrize(molData.pdbx_description)
            var count = names.length
            var i

            for (i = 0; i < count; i++) {
              if (this.molecules[i]) {
                this.molecules[i].name = names[i]
              } else {
                this.molecules[i] = {
                  name: names[i],
                  residues: []
                }
              }
            }

            var molecules = complex.getMolecules()

            for (i = 0; i < count; i++) {
              var molecule = this.molecules[i]
              molecules[i] = new Molecule$5(complex, molecule.name, i + 1)
              molecules[i].residues = molecule.residues
            }
          }
        },
        {
          key: '_extractAtoms',
          value: function _extractAtoms(complex, complexData) {
            var atomData = complexData.atom_site

            if (!atomData) {
              throw new AtomDataError(
                'CIF parsing error: atom_site is not specified!'
              )
            }

            for (var f = 0, n = cRequiredAtomFields.length; f < n; ++f) {
              if (!atomData[cRequiredAtomFields[f]]) {
                throw new AtomDataError(
                  'CIF parsing error: requires field '.concat(
                    cRequiredAtomFields[f],
                    ' not found!'
                  )
                )
              }
            }

            var asymDict = this.asymDict
            var resIdc = arrize(atomData.auth_seq_id)
            var x = arrize(atomData.Cartn_x)
            var y = arrize(atomData.Cartn_y)
            var z = arrize(atomData.Cartn_z)
            var names = arrize(atomData.label_atom_id)
            var count = names.length
            var group = arrize(atomData.group_PDB) || []
            var chainIdc = arrize(atomData.auth_asym_id) || []
            var chainLabelIdc = arrize(atomData.label_asym_id) || []
            var serials = arrize(atomData.id) || []
            var iCodes = arrize(atomData.pdbx_PDB_ins_code) || []
            var resNames = arrize(atomData.label_comp_id) || []
            var elements = arrize(atomData.type_symbol) || []
            var tempFactors = arrize(atomData.B_iso_or_equiv) || []
            var occupancies = arrize(atomData.occupancy) || []
            var charges = arrize(atomData.pdbx_formal_charge) || []
            var altLocs = arrize(atomData.label_alt_id) || []
            var models = arrize(atomData.pdbx_PDB_model_num) || []
            var molecules = arrize(atomData.label_entity_id) || []
            var chain = null
            var residue = null

            for (var i = 0; i < count; ++i) {
              var model = models[i] || 1

              if (model !== 1) {
                continue
              }

              var chainID = String(chainIdc[i] || ' ')

              if (!chain || chain.getName() !== chainID) {
                chain = complex.getChain(chainID) || complex.addChain(chainID)
              }

              asymDict[String(chainLabelIdc[i] || ' ')] = chainID
              var resSeq = resIdc[i]
              var iCode = String(iCodes[i] || ' ')
              var resName = String(resNames[i] || '')

              if (
                !residue ||
                residue.getSequence() !== resSeq ||
                residue.getICode() !== iCode
              ) {
                residue = chain.addResidue(resName, resSeq, iCode)
                var moleculeIdx = molecules[i] - 1
                var entity = this.molecules[moleculeIdx]

                if (!entity) {
                  this.molecules[moleculeIdx] = {
                    name: '',
                    residues: []
                  }
                  entity = this.molecules[moleculeIdx]
                }

                entity.residues.push(residue)
              }

              var name = names[i]
              var element = elements[i] || nameToElement(name)
              var type = Element$5.getByName(element)
              var role = Element$5.Role[name.trim()]
              var xyz = new THREE__namespace.Vector3(x[i], y[i], z[i])
              var het = group[i] === 'HETATM' || false
              var serial = serials[i] || i
              var tempFactor = tempFactors[i] || 0.0
              var occupancy = occupancies[i] || 0.0
              var altLoc = String(altLocs[i] || '')
              var charge = charges[i] || 0
              residue.addAtom(
                name,
                type,
                xyz,
                role,
                het,
                serial,
                altLoc,
                occupancy,
                tempFactor,
                charge
              )
            }
          }
        },
        {
          key: '_extractSecondary',
          value: function _extractSecondary(complex, complexData) {
            if (complexData.struct_conf) {
              this._extractConfs(complex, complexData.struct_conf)
            }

            if (complexData.struct_sheet_range) {
              this._extractSheets(complex, complexData.struct_sheet_range)
            }
          }
        },
        {
          key: '_extractSheets',
          value: function _extractSheets(complex, sheetData) {
            var asymDict = this.asymDict

            if (
              !sheetData.sheet_id ||
              !sheetData.id ||
              !sheetData.beg_label_seq_id ||
              !sheetData.end_label_seq_id ||
              !sheetData.beg_label_asym_id
            ) {
              return
            }

            var sheets = complex._sheets

            function getSheet(name) {
              var n = sheets.length

              for (var i = 0; i < n; ++i) {
                if (sheets[i]._name === name) {
                  return sheets[i]
                }
              }

              sheets[n] = new Sheet(name, 0)
              return sheets[n]
            }

            var sheetNames = arrize(sheetData.sheet_id)
            var strandNames = arrize(sheetData.id)
            var starts = arrize(sheetData.beg_auth_seq_id)
            var ends = arrize(sheetData.end_auth_seq_id)
            var chains = arrize(sheetData.beg_label_asym_id)
            var stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || []
            var endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || []

            for (var i = 0, n = strandNames.length; i < n; ++i) {
              var chain = complex.getChain(asymDict[chains[i]])
              var sheet = getSheet(sheetNames[i])
              var startIdx = starts[i]
              var endIdx = ends[i]
              var startICode = stICodes[i] || ' '
              var endICode = endICodes[i] || ' '
              var start = chain.findResidue(startIdx, startICode)
              var end = chain.findResidue(endIdx, endICode)

              if (!start || !end) {
                continue
              }

              var strand = new Strand(sheet, start[0], end[0], 0, null, null)
              var residues = chain.getResidues()

              for (var r = start[1]; r <= end[1]; ++r) {
                residues[r]._secondary = strand
              }

              sheet.addStrand(strand)
              complex.structures.push(strand)
            }
          }
        },
        {
          key: '_extractConfs',
          value: function _extractConfs(complex, helicesData) {
            var asymDict = this.asymDict

            if (
              !helicesData.conf_type_id ||
              !helicesData.beg_label_seq_id ||
              !helicesData.end_label_seq_id ||
              !helicesData.beg_label_asym_id
            ) {
              return
            }

            var types = arrize(helicesData.conf_type_id)
            var starts = arrize(helicesData.beg_auth_seq_id)
            var stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || []
            var ends = arrize(helicesData.end_auth_seq_id)
            var endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || []
            var comments = arrize(helicesData.details) || []
            var lengths = arrize(helicesData.pdbx_PDB_helix_length) || []
            var helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || []
            var names = arrize(helicesData.id) || []
            var chains = arrize(helicesData.beg_label_asym_id)

            for (var i = 0, n = types.length; i < n; ++i) {
              var type = getTypeFromId(types[i])

              if (!type) {
                continue
              }

              var name = names[i] || types[i]
              var chain = complex.getChain(asymDict[chains[i]])
              var startIdx = starts[i]
              var endIdx = ends[i]
              var startICode = stICodes[i] || ' '
              var endICode = endICodes[i] || ' '
              var start = chain.findResidue(startIdx, startICode)
              var end = chain.findResidue(endIdx, endICode)

              if (!start || !end) {
                continue
              }

              var comment = comments[i] || ''
              var length = lengths[i] || 0
              var helixClass = helixClasses[i] || ' '
              var struct = void 0

              if (type === 'helix') {
                var idx = complex._helices.length
                struct = new Helix(
                  helixClass,
                  start[0],
                  end[0],
                  idx,
                  name,
                  comment,
                  length
                )
                complex.addHelix(struct)
                complex.structures.push(struct)
              } else if (type === 'turn') {
                struct = new StructuralElement(
                  StructuralElement.Type.TURN,
                  start[0],
                  end[0]
                )
                complex.structures.push(struct)
              } else {
                struct = null
              }

              if (!struct) {
                continue
              }

              var residues = chain.getResidues()

              for (var r = start[1]; r <= end[1]; ++r) {
                residues[r]._secondary = struct
              }
            }
          }
        },
        {
          key: '_extractAssemblies',
          value: function _extractAssemblies(complex, complexData) {
            var asymDict = this.asymDict
            var asmGen = complexData.pdbx_struct_assembly_gen

            if (!asmGen) {
              return
            }

            var asmIdx = arrize(asmGen.assembly_id)
            var asmOper = arrize(asmGen.oper_expression)
            var asmList = arrize(asmGen.asym_id_list)

            if (!asmIdx || !asmOper || !asmList) {
              return
            }

            var operList = _getOperations(complexData.pdbx_struct_oper_list)

            if (!operList) {
              return
            }

            for (var i = 0, n = asmIdx.length; i < n; ++i) {
              var asm = new Assembly(complex)

              var assemblyOps = _extractOperations(asmOper[i], operList)

              var entries = asmList[i].split(',')

              for (var ii = 0, nn = entries.length; ii < nn; ++ii) {
                var chain = entries[ii].trim()

                if (chain.length > 0) {
                  asm.addChain(asymDict[chain])
                }
              }

              asm.matrices = assemblyOps
              complex.units.push(asm)
            }
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(data) {
            return (
              ___default['default'].isString(data) && /^\s*data_/i.test(data)
            )
          }
        }
      ]
    )

    return CIFParser
  })(Parser)

  CIFParser.formats = ['cif', 'mmcif']
  CIFParser.extensions = ['.cif', '.mmcif']

  var valueType = {
    singular: 0,
    vector: 1,
    array: 2,
    buffer: 3
  }

  var VolumeModel = /*#__PURE__*/ (function () {
    function VolumeModel() {
      _classCallCheck(this, VolumeModel)

      _defineProperty(this, '_xyz2crs', [])

      _defineProperty(this, '_origin', new THREE__namespace.Vector3(0, 0, 0))

      this._header = {}
      this._boxSize = new THREE__namespace.Vector3()
      this._boxStart = new THREE__namespace.Vector3()
      this._header.delta = {}
      this._header.extent = []
      this._header.nstart = []
      this._header.grid = []
      this._header.crs2xyz = []
      this._header.cellDims = new THREE__namespace.Vector3()
      this._header.angles = []
      this._header.origin = new THREE__namespace.Vector3(0, 0, 0)
      this._header.dmin = 0
      this._header.dmean = 0
      this._header.dmax = 0
    }

    _createClass(VolumeModel, [
      {
        key: '_typedCheck',
        value: function _typedCheck() {
          if (___default['default'].isTypedArray(this._buff)) {
            this._buff = this._buff.buffer
          } else if (!___default['default'].isArrayBuffer(this._buff)) {
            throw new TypeError('Expected ArrayBuffer or TypedArray')
          }
        }
      },
      {
        key: '_fillHeader',
        value: function _fillHeader(headerFormat, arrays) {
          for (var key in headerFormat) {
            if (headerFormat.hasOwnProperty(key)) {
              switch (headerFormat[key][0]) {
                case valueType.singular:
                  this._header[key] =
                    arrays[headerFormat[key][1]][headerFormat[key][2]]
                  break

                case valueType.array:
                  this._parseArray(
                    this._header[key],
                    arrays[headerFormat[key][1]],
                    headerFormat[key][2]
                  )

                  break

                case valueType.vector:
                  this._parseVector(
                    this._header[key],
                    arrays[headerFormat[key][1]],
                    headerFormat[key][2]
                  )

                  break

                case valueType.buffer:
                  this._header[key] = new Uint8Array(
                    arrays[headerFormat[key][1]],
                    [headerFormat[key][2]] * 4,
                    [headerFormat[key][3]] * 4
                  )
                  break
              }
            }
          }
        }
      },
      {
        key: '_parseVector',
        value: function _parseVector(vector, arr, pos) {
          var _ref = [arr[pos], arr[pos + 1], arr[pos + 2]]
          vector.x = _ref[0]
          vector.y = _ref[1]
          vector.z = _ref[2]
        }
      },
      {
        key: '_parseArray',
        value: function _parseArray(vector, arr, pos) {
          vector[0] = arr[pos]
          vector[1] = arr[pos + 1]
          vector[2] = arr[pos + 2]
        }
      },
      {
        key: '_parseHeader',
        value: function _parseHeader(_buffer) {}
      },
      {
        key: '_setAxisIndices',
        value: function _setAxisIndices() {}
      },
      {
        key: '_setOrigins',
        value: function _setOrigins() {}
      },
      {
        key: '_getAxis',
        value: function _getAxis() {
          var header = this._header
          var xScale = header.cellDims.x / header.grid[0]
          var yScale = header.cellDims.y / header.grid[1]
          var zScale = header.cellDims.z / header.grid[2]

          var _header$angles = _slicedToArray(header.angles, 3),
            alpha = _header$angles[0],
            beta = _header$angles[1],
            gamma = _header$angles[2]

          var z1 = Math.cos(beta)
          var z2 =
            (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) /
            Math.sin(gamma)
          var z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2)
          var xaxis = new THREE__namespace.Vector3(xScale, 0, 0)
          var yaxis = new THREE__namespace.Vector3(
            Math.cos(gamma) * yScale,
            Math.sin(gamma) * yScale,
            0
          )
          var zaxis = new THREE__namespace.Vector3(
            z1 * zScale,
            z2 * zScale,
            z3 * zScale
          )
          return [xaxis, yaxis, zaxis]
        }
      },
      {
        key: '_getXYZdim',
        value: function _getXYZdim() {
          return [
            this._header.extent[this._xyz2crs[0]],
            this._header.extent[this._xyz2crs[1]],
            this._header.extent[this._xyz2crs[2]]
          ]
        }
      },
      {
        key: '_getVolumeInfo',
        value: function _getVolumeInfo() {
          var volInfo = ___default['default'].pick(this._header, [
            'dmean',
            'dmin',
            'dmax',
            'sd',
            'delta'
          ])

          volInfo.obtuseAngle = this._header.angles.map(function (angle) {
            return Number(angle >= Math.PI / 2)
          })
          return volInfo
        }
      },
      {
        key: '_setBoxParams',
        value: function _setBoxParams(xaxis, yaxis, zaxis) {
          var _this = this

          var shiftX = 0
          var shiftY = 0

          var _this$_header$angles = _slicedToArray(this._header.angles, 3),
            alpha = _this$_header$angles[0],
            beta = _this$_header$angles[1],
            gamma = _this$_header$angles[2]

          if (gamma >= Math.PI / 2) {
            shiftX += Math.abs(yaxis.x)
          }

          if (beta >= Math.PI / 2) {
            shiftX += Math.abs(zaxis.x)
          }

          if (alpha >= Math.PI / 2) {
            shiftY += Math.abs(zaxis.y)
          }

          this._boxStart = new THREE__namespace.Vector3(
            this._origin.x - shiftX,
            this._origin.y - shiftY,
            this._origin.z
          )
          this._boxSize = new THREE__namespace.Vector3(
            Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x),
            Math.abs(yaxis.y) + Math.abs(zaxis.y),
            Math.abs(zaxis.z)
          )

          var delta = function delta(axe, proj) {
            return Math.abs(axe[proj]) / _this._boxSize[proj]
          }

          this._header.delta.x = delta(yaxis, 'x')
          this._header.delta.y = delta(zaxis, 'x')
          this._header.delta.z = delta(zaxis, 'y')
        }
      },
      {
        key: '_getXYZbox',
        value: function _getXYZbox() {
          return new THREE__namespace.Box3(
            this._boxStart.clone(),
            this._boxStart.clone().add(this._boxSize)
          )
        }
      },
      {
        key: '_toXYZData',
        value: function _toXYZData() {}
      },
      {
        key: 'parse',
        value: function parse(data) {
          this._parseHeader(data)

          this._setOrigins()

          return new Volume$2(
            Float32Array,
            this._getXYZdim(),
            this._getXYZbox(),
            1,
            this._toXYZData(),
            this._getVolumeInfo()
          )
        }
      }
    ])

    return VolumeModel
  })()

  function _createSuper$j(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$j()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$j() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var CCP4Header = {
    extent: [valueType.array, 'u32', 0],
    type: [valueType.singular, 'u32', 3],
    nstart: [valueType.array, 'i32', 4],
    grid: [valueType.array, 'u32', 7],
    cellDims: [valueType.vector, 'f32', 10],
    angles: [valueType.array, 'f32', 13],
    crs2xyz: [valueType.array, 'i32', 16],
    dmin: [valueType.singular, 'f32', 19],
    dmax: [valueType.singular, 'f32', 20],
    dmean: [valueType.singular, 'f32', 21],
    ispg: [valueType.singular, 'u32', 22],
    nsymbt: [valueType.singular, 'u32', 23],
    lksflg: [valueType.singular, 'u32', 24],
    customData: [valueType.buffer, 'buffer', 25, 9],
    origin: [valueType.vector, 'f32', 34],
    map: [valueType.buffer, 'buffer', 52, 1],
    machine: [valueType.singular, 'u32', 53],
    sd: [valueType.singular, 'f32', 54],
    nlabel: [valueType.singular, 'f32', 55],
    label: [valueType.buffer, 'buffer', 56, 200]
  }

  var Ccp4Model = /*#__PURE__*/ (function (_VolumeModel) {
    _inherits(Ccp4Model, _VolumeModel)

    var _super = _createSuper$j(Ccp4Model)

    function Ccp4Model() {
      _classCallCheck(this, Ccp4Model)

      return _super.apply(this, arguments)
    }

    _createClass(Ccp4Model, [
      {
        key: '_parseHeader',
        value: function _parseHeader(_buffer) {
          this._buff = _buffer

          this._typedCheck()

          var arrays = {}
          arrays.u32 = new Uint32Array(this._buff, 0, 56)
          arrays.i32 = new Int32Array(this._buff, 0, 56)
          arrays.f32 = new Float32Array(this._buff, 0, 56)
          arrays.buffer = this._buff
          var header = this._header

          this._fillHeader(CCP4Header, arrays)

          header.angles.forEach(function (angle, i, a) {
            a[i] *= Math.PI / 180.0
          })
        }
      },
      {
        key: '_setAxisIndices',
        value: function _setAxisIndices() {
          var header = this._header

          if (
            header.cellDims.x === 0.0 &&
            header.cellDims.y === 0.0 &&
            header.cellDims.z === 0.0
          ) {
            header.cellDims.set(1.0, 1.0, 1.0)
          }

          var crs2xyz = this._header.crs2xyz

          if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
            crs2xyz[0] = 1
            crs2xyz[1] = 2
            crs2xyz[2] = 3
          }

          var xyz2crs = this._xyz2crs
          xyz2crs[crs2xyz[0] - 1] = 0
          xyz2crs[crs2xyz[1] - 1] = 1
          xyz2crs[crs2xyz[2] - 1] = 2
        }
      },
      {
        key: '_setOrigins',
        value: function _setOrigins() {
          var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = _slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2]

          this._setAxisIndices()

          var header = this._header
          var xyz2crs = this._xyz2crs

          if (
            header.origin.x === 0.0 &&
            header.origin.y === 0.0 &&
            header.origin.z === 0.0
          ) {
            this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]])

            this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]])

            this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]])
          } else {
            this._origin = header.origin
          }

          xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1)
          yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1)
          zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1)

          if (header.type === 2) {
            this._data = new Float32Array(
              this._buff,
              1024 + header.nsymbt,
              header.extent[0] * header.extent[1] * header.extent[2]
            )
          } else {
            throw new Error('CCP4: Unsupported format '.concat(header.type))
          }

          this._setBoxParams(xaxis, yaxis, zaxis)
        }
      },
      {
        key: '_toXYZData',
        value: function _toXYZData() {
          var header = this._header
          var data = this._data
          var xyz2crs = this._xyz2crs
          var xyzData = new Float32Array(data.length)

          var dim = this._getXYZdim()

          var xSize = dim[0]
          var ySize = dim[1]
          var crsIdx = 0
          var coord = []
          var x
          var y
          var z

          for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
            for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
              for (
                coord[0] = 0;
                coord[0] < header.extent[0];
                coord[0]++, crsIdx++
              ) {
                x = coord[xyz2crs[0]]
                y = coord[xyz2crs[1]]
                z = coord[xyz2crs[2]]
                xyzData[x + xSize * (y + ySize * z)] = data[crsIdx]
              }
            }
          }

          return xyzData
        }
      }
    ])

    return Ccp4Model
  })(VolumeModel)

  var CCP4Parser = /*#__PURE__*/ (function (_Parser) {
    _inherits(CCP4Parser, _Parser)

    var _super2 = _createSuper$j(CCP4Parser)

    function CCP4Parser(data, options) {
      var _this

      _classCallCheck(this, CCP4Parser)

      _this = _super2.call(this, data, options)
      _this._options.fileType = 'ccp4'
      _this.model = new Ccp4Model()
      return _this
    }

    _createClass(
      CCP4Parser,
      [
        {
          key: 'parseSync',
          value: function parseSync() {
            return this.model.parse(this._data)
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(_data) {
            return false
          }
        }
      ]
    )

    return CCP4Parser
  })(Parser)

  CCP4Parser.formats = ['ccp4']
  CCP4Parser.extensions = ['.ccp4', '.map', '.mrc']
  CCP4Parser.binary = true

  function _createSuper$i(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$i()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$i() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$4 = chem.Complex,
    Element$4 = chem.Element,
    Molecule$4 = chem.Molecule

  var XYZParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(XYZParser, _Parser)

    var _super = _createSuper$i(XYZParser)

    function XYZParser(data, options) {
      var _this

      _classCallCheck(this, XYZParser)

      _this = _super.call(this, data, options)
      _this._complex = null
      _this._atomsInf = null
      _this._options.fileType = 'xyz'
      _this._fileName = options.name
      return _this
    }

    _createClass(
      XYZParser,
      [
        {
          key: '_parseToAtomsInf',
          value: function _parseToAtomsInf(source) {
            var endnAtoms = source.indexOf('\n')
            var nAtoms = parseInt(source.substring(0, endnAtoms), 10)
            var endComment = source.indexOf('\n', endnAtoms + 1)
            var comment = source.slice(endnAtoms + 1, endComment).trim()

            if (comment.length === 0) {
              comment = this._fileName
            }

            var startAtomsInf =
              endComment + source.substring(endComment).search(/\S/)
            this._atomsInf = source
              .substring(startAtomsInf)
              .split(/[\s,]*\n[\s,]*/)

            if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
              this._complex.error = {
                message: 'wrong number of atoms'
              }
              return
            }

            this._complex.metadata.format = 'xyz'
            this._complex.name = comment
          }
        },
        {
          key: '_parseAtomsInf',
          value: function _parseAtomsInf() {
            var het = true
            var altLoc = ' '
            var occupancy = 1
            var tempFactor = 1
            var charge = 0

            var chain = this._complex.addChain('A')

            var residue = chain.addResidue('UNK', 1, ' ')

            for (var i = 0; i < this._atomsInf.length - 1; i++) {
              var words = this._atomsInf[i].split(/[\s,]+/)

              if (words.length !== 4) {
                this._complex.error = {
                  message: 'missed parameters'
                }
                break
              }

              var serial = i + 1
              var name = words[0]
              var xyz = new THREE__namespace.Vector3(
                parseFloat(words[1]),
                parseFloat(words[2]),
                parseFloat(words[3])
              )
              var type = Element$4.getByName(name)
              var role = undefined
              residue.addAtom(
                name,
                type,
                xyz,
                role,
                het,
                serial,
                altLoc,
                occupancy,
                tempFactor,
                charge
              )
            }

            var molecule = new Molecule$4(this._complex, this._complex.name, 1)
            molecule.residues = residue
            this._complex._molecules[0] = molecule
          }
        },
        {
          key: 'parseSync',
          value: function parseSync() {
            var result = (this._complex = new Complex$4())

            this._parseToAtomsInf(this._data)

            this._parseAtomsInf()

            this._complex.finalize({
              needAutoBonding: true,
              detectAromaticLoops: this.settings.now.aromatic,
              enableEditing: this.settings.now.editing,
              serialAtomMap: this._serialAtomMap
            })

            this._complex = null
            this._atomsInf = null

            if (result.error) {
              throw new Error(result.error.message)
            }

            return result
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(data) {
            return (
              ___default['default'].isString(data) &&
              /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data)
            )
          }
        }
      ]
    )

    return XYZParser
  })(Parser)

  _defineProperty(XYZParser, 'formats', ['xyz'])

  _defineProperty(XYZParser, 'extensions', ['.xyz'])

  function _createSuper$h(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$h()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$h() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$3 = chem.Complex,
    Element$3 = chem.Element

  var PubChemParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(PubChemParser, _Parser)

    var _super = _createSuper$h(PubChemParser)

    function PubChemParser(data, options) {
      var _this

      _classCallCheck(this, PubChemParser)

      _this = _super.call(this, data, options)
      _this._options.fileType = 'pubchem+json'
      return _this
    }

    _createClass(
      PubChemParser,
      [
        {
          key: 'parseSync',
          value: function parseSync() {
            this.logger.info('Parsing PubChem JSON file...')
            return this._toComplex(JSON.parse(this._data))
          }
        },
        {
          key: '_toComplex',
          value: function _toComplex(jsonData) {
            var complex = new Complex$3()
            var complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0]

            if (complexData) {
              this._extractAtoms(complex, complexData)

              complex.finalize({
                needAutoBonding: false,
                detectAromaticLoops: this.settings.now.aromatic,
                enableEditing: this.settings.now.editing
              })
            }

            return complex
          }
        },
        {
          key: '_extractAtoms',
          value: function _extractAtoms(complex, complexData) {
            var aids = complexData.atoms && complexData.atoms.aid
            var elements = aids && complexData.atoms.element

            if (!elements || aids.length !== elements.length) {
              throw new Error('Unable to parse atom elements')
            }

            elements = ___default['default'].fromPairs(
              ___default['default'].zip(aids, elements)
            )
            var atoms = {}
            var coords = complexData.coords && complexData.coords[0]
            var model = coords && coords.conformers && coords.conformers[0]
            var xs = model && model.x
            var ys = model && model.y
            var zs = (model && model.z) || []
            aids = coords && coords.aid

            if (!aids || !xs || !ys) {
              throw new Error('Coordinates are not found in the file')
            }

            var chain = complex.addChain(' ')
            var residue = chain.addResidue('UNK', 1, ' ')

            for (var i = 0, n = aids.length; i < n; ++i) {
              var aid = aids[i]
              var element = Element$3.ByAtomicNumber[elements[aid]]
              var xyz = new THREE__namespace.Vector3(xs[i], ys[i], zs[i] || 0.0)
              atoms[aid] = residue.addAtom(
                element.name,
                element,
                xyz,
                undefined,
                true,
                aid,
                ' ',
                1.0,
                0.0,
                0
              )
            }

            var aids1 = complexData.bonds && complexData.bonds.aid1
            var aids2 = complexData.bonds && complexData.bonds.aid2
            var orders = (complexData.bonds && complexData.bonds.order) || []

            if (!aids1 || !aids2 || aids1.length !== aids2.length) {
              return
            }

            for (var j = 0, m = aids1.length; j < m; ++j) {
              complex.addBond(
                atoms[aids1[j]],
                atoms[aids2[j]],
                orders[j] || 1,
                0,
                true
              )
            }
          }
        }
      ],
      [
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(data) {
            return ___default['default'].isString(data) && data[0] === '{'
          }
        }
      ]
    )

    return PubChemParser
  })(Parser)

  PubChemParser.formats = ['pubchem', 'pubchem+json', 'pc']
  PubChemParser.extensions = ['.json']

  var SDFStream = /*#__PURE__*/ (function () {
    function SDFStream(data) {
      _classCallCheck(this, SDFStream)

      this._strings = data.split(/\r?\n|\r/)
      this._currentStart = 0
      this._currentStringIndx = 0
    }

    _createClass(SDFStream, [
      {
        key: 'setStart',
        value: function setStart(start) {
          if (start >= this._strings.length) {
            this._currentStart = this._strings.length - 1
            this._currentStringIndx = this._strings.length - 1
          } else {
            this._currentStart = start
            this._currentStringIndx = start
          }
        }
      },
      {
        key: 'getNextString',
        value: function getNextString() {
          return this._strings[++this._currentStringIndx]
        }
      },
      {
        key: 'getCurrentString',
        value: function getCurrentString() {
          return this._strings[this._currentStringIndx]
        }
      },
      {
        key: 'getStringFromStart',
        value: function getStringFromStart(numb) {
          this._currentStringIndx = this._currentStart + numb
          return this._strings[this._currentStart + numb]
        }
      },
      {
        key: 'findNextDataItem',
        value: function findNextDataItem() {
          var curStr = this.getNextString()
          var res = false

          while (
            !___default['default'].isUndefined(curStr) &&
            curStr.trim() !== '$$$$'
          ) {
            if (curStr.match(/>\s+<(.*)>/)) {
              res = true
              break
            }

            curStr = this.getNextString()
          }

          return res
        }
      },
      {
        key: 'findNextCompoundStart',
        value: function findNextCompoundStart() {
          var curStr = this.getCurrentString()

          while (
            !___default['default'].isUndefined(curStr) &&
            curStr.trim() !== '$$$$'
          ) {
            curStr = this.getNextString()
          }

          this.setStart(++this._currentStringIndx)
          return this.probablyHaveDataToParse()
        }
      },
      {
        key: 'probablyHaveDataToParse',
        value: function probablyHaveDataToParse() {
          return this._currentStringIndx < this._strings.length - 2
        }
      }
    ])

    return SDFStream
  })()

  function _createSuper$g(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$g()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$g() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$2 = chem.Complex,
    Element$2 = chem.Element,
    Bond$1 = chem.Bond,
    Molecule$3 = chem.Molecule
  var chargeMap = [0, 3, 2, 1, 0, -1, -2, -3]
  var orderMap$1 = [0, 1, 2, 3, 1, 1, 1, 2]
  var typeMap$1 = [
    Bond$1.BondType.UNKNOWN,
    Bond$1.BondType.COVALENT,
    Bond$1.BondType.COVALENT,
    Bond$1.BondType.COVALENT,
    Bond$1.BondType.AROMATIC,
    Bond$1.BondType.UNKNOWN,
    Bond$1.BondType.AROMATIC,
    Bond$1.BondType.AROMATIC
  ]
  var sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/
  var sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/
  var fileFormat = {
    SDF: 'sdf',
    MOL: 'mol'
  }
  var possibleNameTags = [
    'PUBCHEM_IUPAC_TRADITIONAL_NAME',
    /PUBCHEM_(.+)_NAME/,
    /(.+)name/,
    /(.+)NAME/
  ]
  var possibleIDTags = [
    'PUBCHEM_COMPOUND_CID',
    'id',
    'ID',
    /.*CID/,
    /.*ID/,
    /.*id/
  ]
  var possibleTitleTags = [
    'msg',
    'MSG',
    'message',
    'title',
    'description',
    'desc'
  ]
  var tagsNames = ['name', 'id', 'title']
  var tags = {
    name: possibleNameTags,
    id: possibleIDTags,
    title: possibleTitleTags
  }

  function buildChainID(index) {
    if (!index) {
      return 'A'
    }

    var codes = []

    while (index) {
      codes.push(65 + (index % 26))
      index = Math.trunc(index / 26)
    }

    if (codes.length > 1) {
      codes.reverse()
      codes[0] -= 1
    }

    return String.fromCharCode.apply(String, codes)
  }

  var SDFParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(SDFParser, _Parser)

    var _super = _createSuper$g(SDFParser)

    function SDFParser(data, options) {
      var _this

      _classCallCheck(this, SDFParser)

      _this = _super.call(this, data, options)
      _this._format = 'sdf'
      _this._complex = null
      _this._chain = null
      _this._residue = null
      _this._molecules = null
      _this._metadata = {}
      _this._metadata.molecules = []
      _this._currentMolProps = {}
      _this._compoundIndx = -1
      _this._assemblies = []
      _this._atomsParsed = 0
      _this._atomsIndexes = []
      return _this
    }

    _createClass(SDFParser, [
      {
        key: 'canProbablyParse',
        value: function canProbablyParse(data) {
          return (
            ___default['default'].isString(data) && sdfAndMolRegexp.test(data)
          )
        }
      },
      {
        key: '_parseHeader',
        value: function _parseHeader(stream) {
          var molecule = {}
          molecule.name = stream.getStringFromStart(0)
          var date = parseInt(
            stream.getStringFromStart(1).substr(10, 6).trim(),
            10
          )
          molecule.date = date.toString() || ''
          molecule.title = stream.getStringFromStart(2)

          this._metadata.molecules.push(molecule)
        }
      },
      {
        key: '_parseAtoms',
        value: function _parseAtoms(stream, atomsNum) {
          var curStr
          var serial = this._atomsParsed
          var chainID = buildChainID(this._compoundIndx)
          var resName = 'UNK'
          var resSeq = 1
          this._chain =
            this._complex.getChain(chainID) || this._complex.addChain(chainID)
          this._residue = this._chain.addResidue(resName, resSeq, ' ')

          for (var i = 0; i < atomsNum; i++) {
            curStr = stream.getNextString()
            serial++
            var x = parseFloat(curStr.substr(0, 10))
            var y = parseFloat(curStr.substr(10, 10))
            var z = parseFloat(curStr.substr(20, 10))
            var charge = chargeMap[parseInt(curStr.substr(36, 3), 10)]
            var xyz = new THREE__namespace.Vector3(x, y, z)
            var name = curStr.substr(31, 3).trim().toUpperCase()
            var type = Element$2.getByName(name)

            if (!this._atomsIndexes[name]) {
              this._atomsIndexes[name] = 0
            }

            this._atomsIndexes[name] += 1
            name += this._atomsIndexes[name]

            this._residue.addAtom(
              name,
              type,
              xyz,
              undefined,
              true,
              serial,
              ' ',
              1.0,
              0.0,
              charge
            )
          }
        }
      },
      {
        key: '_parseBonds',
        value: function _parseBonds(stream, bondsNum) {
          var curStr

          for (var i = 0; i < bondsNum; i++) {
            curStr = stream.getNextString()

            var atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed

            var atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed

            var bondType = parseInt(curStr.substr(6, 3), 10)

            if (atom1 > atom2) {
              var _ref = [atom2, atom1]
              atom1 = _ref[0]
              atom2 = _ref[1]
            }

            this._complex.addBond(
              atom1,
              atom2,
              orderMap$1[bondType] || 1,
              typeMap$1[bondType] || Bond$1.BondType.UNKNOWN,
              true
            )
          }
        }
      },
      {
        key: '_parseMOL',
        value: function _parseMOL(stream) {
          this._compoundIndx++

          this._parseHeader(stream)

          var countsLine = stream.getStringFromStart(3)
          var atomsNum = parseInt(countsLine.substr(0, 3), 10)
          var bondsNum = parseInt(countsLine.substr(3, 3), 10)

          this._parseAtoms(stream, atomsNum)

          this._parseBonds(stream, bondsNum)

          this._atomsParsed += atomsNum
          this._metadata.molecules[this._compoundIndx]._residues = []

          this._metadata.molecules[this._compoundIndx]._residues.push(
            this._residue
          )
        }
      },
      {
        key: '_parseDataItem',
        value: function _parseDataItem(stream) {
          var tag = stream.getCurrentString()
          var data = []
          var curStr = stream.getNextString()

          while (curStr.trim() !== '') {
            data.push(curStr)
            curStr = stream.getNextString()
          }

          if (data.length === 1) {
            var _data = data

            var _data2 = _slicedToArray(_data, 1)

            data = _data2[0]
          }

          this._currentMolProps[tag.replace(/[<>]/g, '').trim()] = data
        }
      },
      {
        key: '_parseCompound',
        value: function _parseCompound(stream) {
          this._parseMOL(stream)

          if (this._format === fileFormat.SDF) {
            this._currentMolProps = {}

            while (stream.findNextDataItem()) {
              this._parseDataItem(stream)
            }

            if (Object.keys(this._currentMolProps).length !== 0) {
              var molecule = this._metadata.molecules[this._compoundIndx]
              molecule.props = this._currentMolProps

              this._tryToUpdateMoleculeData(molecule)
            }
          }
        }
      },
      {
        key: '_fixBondsArray',
        value: function _fixBondsArray() {
          var serialAtomMap = this._serialAtomMap
          var complex = this._complex
          var bonds = complex._bonds

          for (var j = 0; j < bonds.length; j++) {
            var bond = bonds[j]

            if (bond._right < bond._left) {
              console.log('_fixBondsArray: Logic error.')
            }

            bond._left = serialAtomMap[bond._left] || null
            bond._right = serialAtomMap[bond._right] || null
          }
        }
      },
      {
        key: '_buildAssemblies',
        value: function _buildAssemblies() {
          var chains = this._complex._chains

          if (chains.length === 1) {
            return this._assemblies
          }

          for (var i = 0; i < chains.length; i++) {
            var assembly = new Assembly$3(this._complex)
            var matrix = new THREE__namespace.Matrix4()
            assembly.addMatrix(matrix)
            assembly.addChain(chains[i]._name)

            this._assemblies.push(assembly)
          }

          return this._assemblies
        }
      },
      {
        key: '_buildMolecules',
        value: function _buildMolecules() {
          this._complex._molecules = []
          var molecules = this._metadata.molecules

          for (var i = 0; i < molecules.length; i++) {
            var molecule = new Molecule$3(
              this._complex,
              molecules[i].name,
              i + 1
            )
            molecule.residues = molecules[i]._residues
            this._complex._molecules[i] = molecule
          }

          return this._complex._molecules
        }
      },
      {
        key: '_searchTag',
        value: function _searchTag(tag, props) {
          for (var i = 0; i < props.length; i++) {
            if (
              (tag instanceof RegExp && tag.test(props[i].tag)) ||
              tag === props[i].tag
            ) {
              return props[i].data
            }
          }

          return undefined
        }
      },
      {
        key: '_tryToFind',
        value: function _tryToFind(tagsList, props) {
          for (var j = 0; j < tagsList.length; j++) {
            var res = this._searchTag(tagsList[j], props)

            if (res) {
              return res
            }
          }

          return undefined
        }
      },
      {
        key: '_tryToUpdateMoleculeData',
        value: function _tryToUpdateMoleculeData(molecule) {
          var res = false

          for (var i = 0; i < tagsNames.length; i++) {
            var tagPossibleNames = tags[tagsNames[i]]

            var data = this._tryToFind(tagPossibleNames, molecule.props)

            if (data) {
              molecule[tagsNames[i]] = data
              res = true
            }
          }

          molecule.name = molecule.name || molecule.id

          if (molecule.name.match(/^\d+$/)) {
            molecule.name = 'CID: '.concat(molecule.name)
          }

          return res
        }
      },
      {
        key: '_finalizeMetadata',
        value: function _finalizeMetadata() {
          var molecules = this._metadata.molecules
          var metadata = this._complex.metadata
          var complex = this._complex

          if (molecules.length === 1) {
            complex.name = molecules[0].name
            metadata.title = molecules[0].title
            metadata.date = molecules[0].date
            metadata.properties = molecules[0].props
          } else if (molecules.length > 1) {
            metadata.molecules = []

            for (var i = 0; i < molecules.length; i++) {
              metadata.molecules.push({
                name: molecules[i].name,
                date: molecules[i].date,
                title: molecules[i].title,
                properties: molecules[i].props
              })
            }
          }
        }
      },
      {
        key: '_finalize',
        value: function _finalize() {
          var serialAtomMap = (this._serialAtomMap = {})
          var atoms = this._complex._atoms

          for (var i = 0; i < atoms.length; i++) {
            var atom = atoms[i]
            serialAtomMap[atom.serial] = atom
          }

          this._complex._finalizeBonds()

          this._fixBondsArray()

          this._finalizeMetadata()

          this._buildAssemblies()

          this._complex.units = this._complex.units.concat(this._assemblies)

          this._buildMolecules()

          this._complex.finalize({
            needAutoBonding: false,
            detectAromaticLoops: false,
            enableEditing: false,
            serialAtomMap: this._serialAtomMap
          })
        }
      },
      {
        key: 'defineFormat',
        value: function defineFormat(data) {
          var format

          if (sdfRegExp.test(data)) {
            format = fileFormat.SDF
          } else {
            format = fileFormat.MOL
          }

          return format
        }
      },
      {
        key: 'parseSync',
        value: function parseSync() {
          var result = (this._complex = new Complex$2())
          var stream = new SDFStream(this._data)
          this._format = this.defineFormat(this._data)
          result.metadata.format = this._format

          do {
            this._parseCompound(stream)
          } while (stream.findNextCompoundStart())

          this._finalize()

          return result
        }
      }
    ])

    return SDFParser
  })(Parser)
  SDFParser.formats = ['mol', 'sdf']
  SDFParser.extensions = ['.mol', '.sdf']

  function _createSuper$f(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$f()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$f() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var DSN6Header = {
    nstart: [valueType.array, 'i16', 0],
    extent: [valueType.array, 'i16', 3],
    grid: [valueType.array, 'i16', 6],
    cellDims: [valueType.vector, 'i16', 9],
    angles: [valueType.array, 'i16', 12],
    div: [valueType.singular, 'i16', 15],
    adder: [valueType.singular, 'i16', 16],
    scaleFactor: [valueType.singular, 'i16', 17]
  }

  var DSN6Model = /*#__PURE__*/ (function (_VolumeModel) {
    _inherits(DSN6Model, _VolumeModel)

    var _super = _createSuper$f(DSN6Model)

    function DSN6Model() {
      _classCallCheck(this, DSN6Model)

      return _super.apply(this, arguments)
    }

    _createClass(DSN6Model, [
      {
        key: '_parseHeader',
        value: function _parseHeader(_buffer) {
          this._buff = _buffer

          this._typedCheck()

          var arrays = {}
          arrays.i16 = new Int16Array(this._buff)

          if (arrays.i16[18] !== 100) {
            for (var i = 0, n = arrays.i16.length; i < n; ++i) {
              var val = arrays.i16[i]
              arrays.i16[i] = ((val & 0xff) << 8) | ((val >> 8) & 0xff)
            }
          }

          if (arrays.i16[18] !== 100) {
            throw new Error('DSN6: Incorrect format ')
          }

          var header = this._header

          this._fillHeader(DSN6Header, arrays)

          header.cellDims.multiplyScalar(1.0 / header.scaleFactor)
          header.angles.forEach(function (angle, i, a) {
            a[i] *= Math.PI / 180.0 / header.scaleFactor
          })
          header.div /= 100
        }
      },
      {
        key: '_setAxisIndices',
        value: function _setAxisIndices() {
          this._xyz2crs[0] = 0
          this._xyz2crs[1] = 1
          this._xyz2crs[2] = 2
        }
      },
      {
        key: '_setOrigins',
        value: function _setOrigins() {
          var header = this._header

          var _this$_getAxis = this._getAxis(),
            _this$_getAxis2 = _slicedToArray(_this$_getAxis, 3),
            xaxis = _this$_getAxis2[0],
            yaxis = _this$_getAxis2[1],
            zaxis = _this$_getAxis2[2]

          this._setAxisIndices()

          this._origin.addScaledVector(xaxis, header.nstart[0])

          this._origin.addScaledVector(yaxis, header.nstart[1])

          this._origin.addScaledVector(zaxis, header.nstart[2])

          xaxis.multiplyScalar(header.extent[0])
          yaxis.multiplyScalar(header.extent[1])
          zaxis.multiplyScalar(header.extent[2])

          this._setBoxParams(xaxis, yaxis, zaxis)
        }
      },
      {
        key: '_pointCalculate',
        value: function _pointCalculate(xyzData, byteBuffer, z, y, x, pos, i) {
          var header = this._header

          if (
            x < header.extent[0] &&
            y < header.extent[1] &&
            z < header.extent[2]
          ) {
            var idx = x + header.extent[0] * (y + header.extent[1] * z)
            xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div
            ++pos.counter
          } else {
            pos.counter += 8 - i
            return false
          }

          return true
        }
      },
      {
        key: '_blockCalculate',
        value: function _blockCalculate(
          xyzData,
          byteBuffer,
          zBlock,
          yBlock,
          xBlock,
          pos
        ) {
          for (var k = 0; k < 8; ++k) {
            var z = 8 * zBlock + k

            for (var j = 0; j < 8; ++j) {
              var y = 8 * yBlock + j
              var inRange = true
              var i = 0

              while (inRange && i < 8) {
                var x = 8 * xBlock + i
                inRange = this._pointCalculate(
                  xyzData,
                  byteBuffer,
                  z,
                  y,
                  x,
                  pos,
                  i
                )
                i++
              }
            }
          }
        }
      },
      {
        key: '_toXYZData',
        value: function _toXYZData() {
          var header = this._header
          var byteBuffer = new Uint8Array(this._buff)
          var xyzData = new Float32Array(
            header.extent[0] * header.extent[1] * header.extent[2]
          )
          var blocks = new THREE__namespace.Vector3(
            header.extent[0] / 8,
            header.extent[1] / 8,
            header.extent[2] / 8
          )
          var pos = {}
          pos.counter = 512

          for (var zBlock = 0; zBlock < blocks.z; ++zBlock) {
            for (var yBlock = 0; yBlock < blocks.y; ++yBlock) {
              for (var xBlock = 0; xBlock < blocks.x; ++xBlock) {
                this._blockCalculate(
                  xyzData,
                  byteBuffer,
                  zBlock,
                  yBlock,
                  xBlock,
                  pos
                )
              }
            }
          }

          this._calculateInfoParams(xyzData)

          return xyzData
        }
      },
      {
        key: '_calculateInfoParams',
        value: function _calculateInfoParams(xyzData) {
          this._header.dmean /= xyzData.length
          var dispersion = 0
          var minDensity = xyzData[0]
          var maxDensity = xyzData[0]

          for (var j = 0; j < xyzData.length; j++) {
            dispersion += Math.pow(this._header.dmean - xyzData[j], 2)

            if (xyzData[j] < minDensity) {
              minDensity = xyzData[j]
            }

            if (xyzData[j] > maxDensity) {
              maxDensity = xyzData[j]
            }
          }

          this._header.sd = Math.sqrt(dispersion / xyzData.length)
          this._header.dmax = maxDensity
          this._header.dmin = minDensity
        }
      }
    ])

    return DSN6Model
  })(VolumeModel)

  var DSN6Parser = /*#__PURE__*/ (function (_Parser) {
    _inherits(DSN6Parser, _Parser)

    var _super2 = _createSuper$f(DSN6Parser)

    function DSN6Parser(data, options) {
      var _this

      _classCallCheck(this, DSN6Parser)

      _this = _super2.call(this, data, options)
      _this._options.fileType = 'dsn6'
      _this.model = new DSN6Model()
      return _this
    }

    _createClass(
      DSN6Parser,
      [
        {
          key: 'parseSync',
          value: function parseSync() {
            return this.model.parse(this._data)
          }
        }
      ],
      [
        {
          key: 'canParse',
          value: function canParse(data, options) {
            if (!data) {
              return false
            }

            return (
              data instanceof ArrayBuffer &&
              Parser.checkDataTypeOptions(options, 'dsn6')
            )
          }
        },
        {
          key: 'canProbablyParse',
          value: function canProbablyParse(_data) {
            return false
          }
        }
      ]
    )

    return DSN6Parser
  })(Parser)

  DSN6Parser.formats = ['dsn6']
  DSN6Parser.extensions = ['.dsn6', '.omap']
  DSN6Parser.binary = true

  function _createSuper$e(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$e()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$e() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var GROReader = /*#__PURE__*/ (function (_PDBStream) {
    _inherits(GROReader, _PDBStream)

    var _super = _createSuper$e(GROReader)

    function GROReader(data) {
      var _this

      _classCallCheck(this, GROReader)

      _this = _super.call(this, data)
      _this._next = -1

      _this.next()

      return _this
    }

    _createClass(GROReader, [
      {
        key: 'getNext',
        value: function getNext() {
          return this._next
        }
      }
    ])

    return GROReader
  })(PDBStream)

  function _createSuper$d(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$d()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$d() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex$1 = chem.Complex,
    Element$1 = chem.Element,
    Molecule$2 = chem.Molecule

  var GROParser = /*#__PURE__*/ (function (_Parser) {
    _inherits(GROParser, _Parser)

    var _super = _createSuper$d(GROParser)

    function GROParser(data, options) {
      var _this

      _classCallCheck(this, GROParser)

      _this = _super.call(this, data, options)
      _this._time = null
      _this._numAtoms = null
      _this._residueNumber = null
      _this._residueName = ''
      _this._atomName = ''
      _this._atomNumber = null
      _this._atomPosition = []
      _this._atomVelocity = []
      _this._complex = null
      _this._molecules = []
      _this._molecule = null
      _this._options.filetype = 'gro'
      return _this
    }

    _createClass(GROParser, [
      {
        key: 'canProbablyParse',
        value: function canProbablyParse(data) {
          return (
            ___default['default'].isString(this._data) &&
            /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(
              data
            )
          )
        }
      },
      {
        key: '_parseTitle',
        value: function _parseTitle(line) {
          var metadata = this._complex.metadata
          metadata.id = line.readLine().trim()
          metadata.name = metadata.id.slice(
            metadata.id.lastIndexOf('\\') + 1,
            metadata.id.lastIndexOf('.')
          )
          metadata.format = 'gro'
        }
      },
      {
        key: '_parseNumberOfAtoms',
        value: function _parseNumberOfAtoms(line) {
          this._numAtoms = line.readInt(0, line.getNext())

          if (Number.isNaN(this._numAtoms)) {
            throw new Error(
              'Line 2 is not representing atom number. Consider checking input file'
            )
          }
        }
      },
      {
        key: '_parseAtom',
        value: function _parseAtom(line) {
          this._residueNumber = line.readInt(1, 5)
          this._residueName = line.readString(6, 10).trim()
          this._atomName = line.readString(11, 15).trim()
          this._atomNumber = line.readInt(16, 20)
          var positionX = line.readFloat(21, 28) * 10
          var positionY = line.readFloat(29, 36) * 10
          var positionZ = line.readFloat(37, 45) * 10

          if (
            Number.isNaN(positionX) ||
            Number.isNaN(positionY) ||
            Number.isNaN(positionZ)
          ) {
            this._complex.error = {
              message: 'Atom position is invalid in "'.concat(
                line.readLine(),
                '"'
              )
            }
            return
          }

          var type = Element$1.getByName(this._atomName[0])

          if (type.fullName === 'Unknown') {
            this._complex.error = {
              message: ''.concat(
                this._atomName[0],
                " hasn't been recognised as an atom name."
              )
            }
            return
          }

          var role = Element$1.Role[this._atomName]
          var chain = this._chain

          if (!chain) {
            this._chain = chain = this._complex.addChain('A')
          }

          var residue = this._residue

          if (!residue || residue.getSequence() !== this._residueNumber) {
            this._residue = residue = chain.addResidue(
              this._residueName,
              this._residueNumber,
              ' '
            )
          }

          this._atomPosition = new THREE__namespace.Vector3(
            positionX,
            positionY,
            positionZ
          )
          var het = true
          var altLoc = ' '
          var occupancy = 1
          var tempFactor = 1
          var charge = 0
          residue.addAtom(
            this._atomName,
            type,
            this._atomPosition,
            role,
            het,
            this._atomNumber,
            altLoc,
            occupancy,
            tempFactor,
            charge
          )
        }
      },
      {
        key: '_finalize',
        value: function _finalize() {
          var molecule = new Molecule$2(
            this._complex,
            this._complex.metadata.name,
            1
          )
          molecule.residues = this._chain._residues
          molecule._chains = this._chain
          this._complex._molecules[0] = molecule

          this._molecules.push(molecule)

          this._complex.finalize({
            needAutoBonding: true,
            detectAromaticLoops: this.settings.now.aromatic,
            enableEditing: this.settings.now.editing,
            serialAtomMap: this._serialAtomMap
          })
        }
      },
      {
        key: 'parseSync',
        value: function parseSync() {
          var result = (this._complex = new Complex$1())
          var reader = new GROReader(this._data)
          var counter = 0

          this._parseTitle(reader)

          reader.next()

          this._parseNumberOfAtoms(reader)

          reader.next()

          for (counter = 0; counter < this._numAtoms; ++counter) {
            if (!reader.end()) {
              this._parseAtom(reader)

              reader.next()
            } else break
          }

          if (counter < this._numAtoms) {
            this._complex.error = {
              message: 'File ended unexpectedly.'
            }
          }

          if (result.error) {
            throw new Error(result.error.message)
          }

          this._finalize()

          this._atomPosition = null
          this._complex = null
          this._molecules = null
          this._molecule = null
          return result
        }
      }
    ])

    return GROParser
  })(Parser)

  GROParser.formats = ['gro']
  GROParser.extensions = ['.gro']

  function _createSuper$c(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$c()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$c() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var Complex = chem.Complex,
    Element = chem.Element,
    Bond = chem.Bond,
    Molecule$1 = chem.Molecule
  var orderMap = {
    un: 0,
    1: 1,
    2: 2,
    3: 3,
    ar: 1,
    am: 1,
    nc: 0,
    du: 1
  }
  var typeMap = {
    un: Bond.BondType.UNKNOWN,
    1: Bond.BondType.COVALENT,
    2: Bond.BondType.COVALENT,
    3: Bond.BondType.COVALENT,
    ar: Bond.BondType.AROMATIC,
    am: Bond.BondType.COVALENT,
    nc: Bond.BondType.UNKNOWN,
    du: Bond.BondType.COVALENT
  }
  var resNumberRegex = /\d+$/
  var spacesRegex = /\s+/

  function splitToFields(str) {
    return str.trim().split(spacesRegex)
  }

  var MOL2Parser = /*#__PURE__*/ (function (_Parser) {
    _inherits(MOL2Parser, _Parser)

    var _super = _createSuper$c(MOL2Parser)

    function MOL2Parser(data, options) {
      var _this

      _classCallCheck(this, MOL2Parser)

      _this = _super.call(this, data, options)
      _this._complex = null
      _this._chain = null
      _this._residue = null
      _this._compoundIndx = -1
      _this._molecules = []
      _this._molecule = null
      _this._currPosIdx = 0
      _this._currStartIdx = 0
      _this._serialAtomMap = {}
      _this._options.fileType = 'mol2'
      return _this
    }

    _createClass(MOL2Parser, [
      {
        key: '_parseRawStrings',
        value: function _parseRawStrings(data) {
          return data.split(/\r?\n|\r/)
        }
      },
      {
        key: '_toStringFromStart',
        value: function _toStringFromStart(numb, MOL2Data) {
          var newPosIdx = this._currStartIdx + numb
          this._currPosIdx =
            newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx
        }
      },
      {
        key: '_toHeaderString',
        value: function _toHeaderString(header, MOL2Data) {
          this._toStringFromStart(0, MOL2Data)

          while (this._currPosIdx < MOL2Data.length) {
            if (MOL2Data[this._currPosIdx].match('@<TRIPOS>'.concat(header))) {
              return
            }

            this._currPosIdx++
          }

          this._toStringFromStart(0, MOL2Data)
        }
      },
      {
        key: '_toStringFromHeader',
        value: function _toStringFromHeader(header, numb, MOL2Data) {
          this._toHeaderString(header, MOL2Data)

          var newPosIdx = this._currPosIdx + numb

          if (
            MOL2Data[this._currPosIdx].match('@<TRIPOS>'.concat(header)) &&
            newPosIdx < MOL2Data.length
          ) {
            this._currPosIdx = newPosIdx
          }
        }
      },
      {
        key: '_setStart',
        value: function _setStart(startPos, MOL2Data) {
          if (startPos >= MOL2Data.length) {
            this._currStartIdx = this._currPosIdx = MOL2Data.length - 1
          } else {
            this._currStartIdx = this._currPosIdx = startPos
          }
        }
      },
      {
        key: '_probablyHaveDataToParse',
        value: function _probablyHaveDataToParse(MOL2Data) {
          return this._currPosIdx < MOL2Data.length - 2
        }
      },
      {
        key: '_findNextCompoundStart',
        value: function _findNextCompoundStart(MOL2Data) {
          while (
            this._currPosIdx < MOL2Data.length &&
            MOL2Data[this._currPosIdx].trim() !== '@<TRIPOS>MOLECULE>'
          ) {
            this._currPosIdx++
          }

          this._setStart(++this._currPosIdx, MOL2Data)

          return this._probablyHaveDataToParse(MOL2Data)
        }
      },
      {
        key: '_parseMolecule',
        value: function _parseMolecule(MOL2Data) {
          this._toHeaderString('MOLECULE', MOL2Data)

          var metadata = this._complex.metadata
          metadata.name = MOL2Data[++this._currPosIdx]
          metadata.format = 'mol2'
          this._molecule = {
            _index: '',
            _chains: []
          }
          this._molecule._index = this._compoundIndx + 1

          this._molecules.push(this._molecule)
        }
      },
      {
        key: '_parseAtoms',
        value: function _parseAtoms(atomsNum, MOL2Data) {
          this._toHeaderString('ATOM', MOL2Data)

          for (var i = 0; i < atomsNum; i++) {
            var parsedStr = splitToFields(MOL2Data[++this._currPosIdx])

            if (parsedStr.length < 6) {
              throw new Error(
                'MOL2 parsing error: Not enough information to create atom!'
              )
            }

            var atomId = parseInt(parsedStr[0], 10)
            var atomName = parsedStr[1]
            var x = parseFloat(parsedStr[2])
            var y = parseFloat(parsedStr[3])
            var z = parseFloat(parsedStr[4])
            var element = parsedStr[5].split('.')[0].toUpperCase()
            var charge = 0

            if (parsedStr.length >= 9) {
              charge = parseFloat(parsedStr[8]) || 0.0
            }

            var chain = this._chain

            if (!chain) {
              this._chain = chain =
                this._complex.getChain('A') || this._complex.addChain('A')
              this._residue = null
            }

            if (!this._setResidue(parsedStr)) {
              continue
            }

            var het = false
            var altLoc = ' '
            var occupancy = 1.0
            var tempFactor = 0.0
            var type = Element.getByName(element)
            var role = Element.Role[atomName]
            var xyz = new THREE__namespace.Vector3(x, y, z)

            this._residue.addAtom(
              atomName,
              type,
              xyz,
              role,
              het,
              atomId,
              altLoc,
              occupancy,
              tempFactor,
              charge
            )
          }
        }
      },
      {
        key: '_setResidue',
        value: function _setResidue(parsedStr) {
          var resSeq = 1
          var resName = 'UNK'

          if (parsedStr.length >= 7) {
            resSeq = parseInt(parsedStr[6], 10)
          }

          if (parsedStr.length >= 8 && parsedStr[7] !== '<0>') {
            resName = parsedStr[7].replace(resNumberRegex, '')
          }

          if (this.settings.now.nowater) {
            if (resName === 'HOH' || resName === 'WAT') {
              return false
            }
          }

          var residue = this._residue
          var chain = this._chain

          if (!residue || residue.getSequence() !== resSeq) {
            this._residue = chain.addResidue(resName, resSeq, 'A')
          }

          return true
        }
      },
      {
        key: '_parseBonds',
        value: function _parseBonds(bondsNum, MOL2Data) {
          this._toHeaderString('BOND', MOL2Data)

          for (var i = 0; i < bondsNum; i++) {
            var parsedStr = splitToFields(MOL2Data[++this._currPosIdx])

            if (parsedStr.length < 3) {
              throw new Error(
                'MOL2 parsing error: Missing information about bonds!'
              )
            }

            var originAtomId = parseInt(parsedStr[1], 10)
            var targetAtomId = parseInt(parsedStr[2], 10)
            var bondType = parsedStr[3]

            if (originAtomId > targetAtomId) {
              var _ref = [targetAtomId, originAtomId]
              originAtomId = _ref[0]
              targetAtomId = _ref[1]
            }

            this._complex.addBond(
              originAtomId,
              targetAtomId,
              orderMap[bondType] || 0,
              typeMap[bondType] || Bond.BondType.UNKNOWN,
              true
            )
          }
        }
      },
      {
        key: '_fixSerialAtoms',
        value: function _fixSerialAtoms() {
          var atoms = this._complex._atoms

          for (var i = 0; i < atoms.length; i++) {
            var atom = atoms[i]
            this._serialAtomMap[atom.serial] = atom
          }
        }
      },
      {
        key: '_fixBondsArray',
        value: function _fixBondsArray() {
          var serialAtomMap = this._serialAtomMap
          var complex = this._complex

          if (Object.keys(serialAtomMap).length === 0) {
            throw new Error('MOL2 parsing error: Missing atom information!')
          }

          var bonds = complex._bonds

          for (var j = 0; j < bonds.length; j++) {
            var bond = bonds[j]
            bond._left = serialAtomMap[bond._left] || null
            bond._right = serialAtomMap[bond._right] || null
          }
        }
      },
      {
        key: '_finalizeMolecules',
        value: function _finalizeMolecules() {
          var chain = this._complex._chains[0]
          this._complex._molecules = []

          for (var i = 0; i < this._molecules.length; i++) {
            var currMolecule = this._molecules[i]
            var molResidues = chain._residues
            var molecule = new Molecule$1(
              this._complex,
              currMolecule._name,
              i + 1
            )
            molecule.residues = molResidues
            this._complex._molecules[i] = molecule
          }
        }
      },
      {
        key: '_finalize',
        value: function _finalize() {
          this._complex._finalizeBonds()

          this._fixSerialAtoms()

          this._fixBondsArray()

          this._finalizeMolecules()

          this._complex.finalize({
            needAutoBonding: false,
            detectAromaticLoops: this.settings.now.aromatic,
            enableEditing: this.settings.now.editing,
            serialAtomMap: this._serialAtomMap
          })
        }
      },
      {
        key: '_parseCompound',
        value: function _parseCompound(MOL2Data) {
          this._compoundIndx++

          this._parseMolecule(MOL2Data)

          this._toStringFromHeader('MOLECULE', 2, MOL2Data)

          var parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex)

          var atomsNum = parsedStr[0]
          var bondsNum = parsedStr[1]

          this._parseAtoms(atomsNum, MOL2Data)

          this._parseBonds(bondsNum, MOL2Data)
        }
      },
      {
        key: 'parseSync',
        value: function parseSync() {
          var result = (this._complex = new Complex())

          var MOL2Data = this._parseRawStrings(this._data)

          do {
            this._parseCompound(MOL2Data)
          } while (this._findNextCompoundStart(MOL2Data))

          this._finalize()

          return result
        }
      }
    ])

    return MOL2Parser
  })(Parser)

  MOL2Parser.formats = ['mol2']
  MOL2Parser.extensions = ['.mol2', '.ml2', '.sy2']

  var parsers = new ParserList([
    PDBParser,
    CIFParser,
    MMTFParser,
    XYZParser,
    CMLParser,
    PubChemParser,
    SDFParser,
    CCP4Parser,
    DSN6Parser,
    GROParser,
    MOL2Parser
  ])

  function _createSuper$b(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$b()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$b() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var ExporterList = /*#__PURE__*/ (function (_EntityList) {
    _inherits(ExporterList, _EntityList)

    var _super = _createSuper$b(ExporterList)

    function ExporterList() {
      var someExporters =
        arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : []

      _classCallCheck(this, ExporterList)

      return _super.call(this, someExporters, ['formats'])
    }

    _createClass(ExporterList, [
      {
        key: 'find',
        value: function find(specs) {
          var list = []

          if (specs.format) {
            list = this._dict.formats[specs.format.toLowerCase()] || []
          }

          return _toConsumableArray(list)
        }
      }
    ])

    return ExporterList
  })(EntityList)

  var Exporter = /*#__PURE__*/ (function () {
    function Exporter(source, options) {
      _classCallCheck(this, Exporter)

      this._source = source
      this._options = options || {}
      this._abort = false
    }

    _createClass(Exporter, [
      {
        key: 'exportSync',
        value: function exportSync() {
          throw new Error('Exporting to this source is not implemented')
        }
      },
      {
        key: 'export',
        value: function _export() {
          var _this = this

          return new Promise(function (resolve, reject) {
            setTimeout(function () {
              try {
                if (_this._abort) {
                  return reject(new Error('Export aborted'))
                }

                return resolve(_this.exportSync())
              } catch (error) {
                return reject(error)
              }
            })
          })
        }
      },
      {
        key: 'abort',
        value: function abort() {
          this._abort = true
        }
      }
    ])

    return Exporter
  })()
  makeContextDependent(Exporter.prototype)

  var PDBResult = /*#__PURE__*/ (function () {
    function PDBResult() {
      _classCallCheck(this, PDBResult)

      this._resultArray = []
      this._currentStr = -1
      this._tag = null
      this._fixedNumeration = false
      this._numeration = false
      this._tagStrNum = 0
    }

    _createClass(PDBResult, [
      {
        key: 'getResult',
        value: function getResult() {
          this.writeString('\n', 81, 81)
          return this._resultArray.join('')
        }
      },
      {
        key: '_currentStrLength',
        value: function _currentStrLength() {
          var curStr = this._resultArray[this._currentStr]
          return curStr ? curStr.length : 0
        }
      },
      {
        key: 'newTag',
        value: function newTag(tag, numeration) {
          if (!tag) {
            this._tag = null
          } else {
            this._tag = tag
          }

          if (!___default['default'].isUndefined(numeration)) {
            if (___default['default'].isNumber(numeration)) {
              this._tagStrNum = numeration
              this._numeration = true
              this._fixedNumeration = true
            } else if (___default['default'].isBoolean(numeration)) {
              this._tagStrNum = 0
              this._numeration = numeration
              this._fixedNumeration = false
            }
          } else {
            this._numeration = false
            this._fixedNumeration = false
            this._tagStrNum = 0
          }
        }
      },
      {
        key: 'newString',
        value: function newString(tag) {
          this.writeString('\n', 81, 81)
          this._currentStr++

          this._resultArray.push('')

          if (tag) {
            this.writeString(tag, 1, 6)
          } else if (this._tag) {
            this.writeString(this._tag, 1, 6)
          }

          if (this._numeration) {
            if (!this._fixedNumeration) {
              this._tagStrNum++
            }

            if (this._tagStrNum !== 1) {
              this.writeString(this._tagStrNum.toString(), 10, 8)
            }
          }
        }
      },
      {
        key: 'writeEntireString',
        value: function writeEntireString(string, maxStrPos, concat) {
          if (!maxStrPos) {
            maxStrPos = 81
          }

          for (var j = 0; j < string.length; j++) {
            if (
              this._currentStrLength() === maxStrPos &&
              j !== string.length - 1
            ) {
              this.newString()

              if (concat) {
                this.writeString(concat.tag, concat.begin, concat.end)
              }
            }

            if (string[j] === '\n') {
              this.newString()
            } else {
              this.writeString(string[j])
            }
          }
        }
      },
      {
        key: 'writeString',
        value: function writeString(string, begin, end) {
          var curStr = this._resultArray[this._currentStr]
          var str
          var curStrLength = curStr ? curStr.length : 0

          if (___default['default'].isUndefined(string)) {
            return
          }

          if (!___default['default'].isNumber(begin)) {
            begin = curStrLength + 1
          }

          if (!___default['default'].isNumber(end)) {
            end = curStrLength + string.length
          }

          if (!___default['default'].isString(string)) {
            str = string.toString()
          } else {
            str = string
          }

          var finish = begin < end ? end : begin
          var start = begin < end ? begin : end

          if (str.length > Math.abs(begin - end) + 1) {
            str = str.substr(0, Math.abs(begin - end + 1))
          }

          if (start > curStrLength + 1) {
            this._resultArray[this._currentStr] += ' '.repeat(
              start - curStrLength - 1
            )
          } else if (start <= curStrLength) {
            var cStr = this._resultArray[this._currentStr]
            this._resultArray[this._currentStr] = cStr.slice(0, start - 1)
          }

          if (end < begin) {
            var len = begin - end + 1
            str = ' '.repeat(len - str.length) + str
          }

          if (start === 11 && this._numeration && this._tagStrNum !== 1) {
            str = ' '.concat(str)
          }

          this._resultArray[this._currentStr] += str
          curStr = this._resultArray[this._currentStr]

          if (finish > curStr.length) {
            this._resultArray[this._currentStr] += ' '.repeat(
              finish - curStr.length
            )
          }
        }
      },
      {
        key: 'writeBondsArray',
        value: function writeBondsArray(bonds, atom) {
          var bondsArrays = this._getSubArrays(bonds, 4)

          for (var k = 0; k < bondsArrays.length; k++) {
            this.newString()
            this.writeString(atom.serial, 11, 7)

            for (var j = 0; j < bondsArrays[k].length; j++) {
              var serial =
                bondsArrays[k][j]._left.serial === atom.serial
                  ? bondsArrays[k][j]._right.serial
                  : bondsArrays[k][j]._left.serial
              this.writeString(serial, 16 + 5 * j, 12 + 5 * j)
            }
          }
        }
      },
      {
        key: '_getSubArrays',
        value: function _getSubArrays(arr, subArraySize) {
          var subArrays = []

          for (var i = 0; i < arr.length; i += subArraySize) {
            subArrays.push(arr.slice(i, i + subArraySize))
          }

          return subArrays
        }
      },
      {
        key: 'writeMatrix',
        value: function writeMatrix(matrix, matrixIndx, tag) {
          for (var j = 0; j < 3; j++) {
            this.newString()
            this.writeString(tag, 14, 18)
            this.writeString((j + 1).toString(), 19, 19)
            this.writeString(matrixIndx.toString(), 23, 20)

            for (var k = 0; k < 3; k++) {
              var _numb = parseFloat(matrix.elements[j * 4 + k]).toFixed(6)

              this.writeString(_numb.toString(), 33 + k * 10, 24 + k * 10)
            }

            var numb = parseFloat(matrix.elements[j * 4 + 3]).toFixed(5)
            this.writeString(numb.toString(), 68, 55)
          }
        }
      },
      {
        key: 'writeMatrices',
        value: function writeMatrices(matrices, string) {
          if (!matrices) {
            return
          }

          var matrix = new THREE.Matrix4()

          for (var j = 0; j < matrices.length; j++) {
            matrix.copy(matrices[j]).transpose()
            this.writeMatrix(matrix, j + 1, string)
          }
        }
      }
    ])

    return PDBResult
  })()

  function _createSuper$a(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$a()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$a() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var PDBExporter = /*#__PURE__*/ (function (_Exporter) {
    _inherits(PDBExporter, _Exporter)

    var _super = _createSuper$a(PDBExporter)

    function PDBExporter(source, options) {
      var _this

      _classCallCheck(this, PDBExporter)

      _this = _super.call(this, source, options)
      _this._tags = [
        'HEADER',
        'TITLE',
        'COMPND',
        'REMARK',
        'HELIX',
        'SHEET',
        'ATOM and HETATM',
        'CONECT'
      ]
      _this._result = null
      _this._tagExtractors = {
        HEADER: _this._extractHEADER,
        TITLE: _this._extractTITLE,
        'ATOM and HETATM': _this._extractATOM,
        CONECT: _this._extractCONECT,
        COMPND: _this._extractCOMPND,
        REMARK: _this._extractREMARK,
        HELIX: _this._extractHELIX,
        SHEET: _this._extractSHEET
      }
      _this._stringForRemark350 =
        'COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\n' +
        'BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\n' +
        'MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\n' +
        'GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\n' +
        'CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.'
      _this._stringForRemark290 =
        'CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\n' +
        'THE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\n' +
        'RECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\n' +
        'RELATED MOLECULES.'
      return _this
    }

    _createClass(PDBExporter, [
      {
        key: 'exportSync',
        value: function exportSync() {
          var result = new PDBResult()

          if (!this._source) {
            return this._result
          }

          for (var i = 0; i < this._tags.length; i++) {
            var tag = this._tags[i]
            var func = this._tagExtractors[tag]

            if (typeof func === 'function') {
              func.call(this, result)
            }
          }

          this._result = result.getResult()
          return this._result
        }
      },
      {
        key: '_extractHEADER',
        value: function _extractHEADER(result) {
          if (!this._source.metadata) {
            return
          }

          var metadata = this._source.metadata
          result.newTag('HEADER')
          result.newString()

          if (metadata.classification) {
            result.writeString(metadata.classification, 11, 50)
          }

          if (metadata.date) {
            result.writeString(metadata.date, 51, 59)
          }

          if (metadata.id) {
            result.writeString(metadata.id, 63, 66)
          }
        }
      },
      {
        key: '_extractTITLE',
        value: function _extractTITLE(result) {
          if (!this._source.metadata) {
            return
          }

          var metadata = this._source.metadata

          if (!metadata.title) {
            return
          }

          result.newTag('TITLE', true)

          for (var i = 0; i < metadata.title.length; i++) {
            result.newString()
            result.writeString(metadata.title[i], 11, 80)
          }
        }
      },
      {
        key: '_extractCONECT',
        value: function _extractCONECT(result) {
          if (!this._source._atoms) {
            return
          }

          var atoms = this._source._atoms
          result.newTag('CONECT')

          for (var i = 0; i < atoms.length; i++) {
            var fixedBonds = atoms[i].bonds.filter(function (bond) {
              return bond._fixed
            })

            if (fixedBonds.length !== 0) {
              result.writeBondsArray(fixedBonds.reverse(), atoms[i])
            }
          }
        }
      },
      {
        key: '_extractSHEET',
        value: function _extractSHEET(result) {
          if (!this._source._sheets) {
            return
          }

          result.newTag('SHEET')
          var sheets = this._source._sheets

          for (var i = 0; i < sheets.length; i++) {
            if (sheets[i]._strands) {
              var strands = sheets[i]._strands

              for (var j = 0; j < strands.length; j++) {
                result.newString()
                result.writeString(j + 1, 10, 8)
                result.writeString(sheets[i]._name, 14, 12)
                result.writeString(strands.length, 16, 15)
                result.writeString(strands[j].init._type._name, 18, 20)
                result.writeString(strands[j].init._chain._name, 22, 22)
                result.writeString(strands[j].init._sequence, 26, 23)
                result.writeString(strands[j].init._icode, 27, 27)
                result.writeString(strands[j].term._type._name, 29, 31)
                result.writeString(strands[j].init._chain._name, 33, 33)
                result.writeString(strands[j].term._sequence, 37, 34)
                result.writeString(strands[j].term._icode, 38, 38)
                result.writeString(strands[j].sense, 40, 39)
              }
            }
          }
        }
      },
      {
        key: '_extractHELIX',
        value: function _extractHELIX(result) {
          if (!this._source._helices) {
            return
          }

          result.newTag('HELIX')
          var helices = this._source._helices

          for (var i = 0; i < helices.length; i++) {
            var helix = helices[i]

            var helixClass = ___default['default'].invert(typeByPDBHelixClass)

            result.newString()
            result.writeString(helix.serial, 10, 8)
            result.writeString(helix.name, 14, 12)
            result.writeString(helix.init._type._name, 16, 18)
            result.writeString(helix.init._chain._name, 20, 20)
            result.writeString(helix.init._sequence, 25, 22)
            result.writeString(helix.init._icode, 26, 26)
            result.writeString(helix.term._type._name, 28, 30)
            result.writeString(helix.term._chain._name, 32, 32)
            result.writeString(helix.term._sequence, 37, 34)
            result.writeString(helix.term._icode, 38, 38)
            result.writeString(helixClass[helix.type], 40, 39)
            result.writeString(helix.comment, 41, 70)
            result.writeString(helix.length, 76, 72)
          }
        }
      },
      {
        key: '_extractATOM',
        value: function _extractATOM(result) {
          if (!this._source._atoms) {
            return
          }

          var atoms = this._source._atoms

          for (var i = 0; i < atoms.length; i++) {
            var tag = atoms[i].het ? 'HETATM' : 'ATOM'
            result.newString(tag)
            var startIndx =
              atoms[i].element.name.length > 1 || atoms[i].name.length > 3
                ? 13
                : 14
            result.writeString(atoms[i].serial, 11, 7)
            result.writeString(atoms[i].name, startIndx, 16)
            result.writeString(String.fromCharCode(atoms[i].location), 17, 17)
            result.writeString(atoms[i].residue._type._name, 20, 18)
            result.writeString(atoms[i].residue._chain._name, 22, 22)
            result.writeString(atoms[i].residue._sequence, 26, 23)
            result.writeString(atoms[i].residue._icode, 27, 27)
            result.writeString(atoms[i].position.x.toFixed(3), 38, 31)
            result.writeString(atoms[i].position.y.toFixed(3), 46, 39)
            result.writeString(atoms[i].position.z.toFixed(3), 54, 47)
            result.writeString(atoms[i].occupancy.toFixed(2), 60, 55)
            result.writeString(atoms[i].temperature.toFixed(2), 66, 61)
            result.writeString(atoms[i].element.name, 78, 77)

            if (atoms[i].charge) {
              result.writeString(atoms[i].charge, 79, 80)
            }
          }
        }
      },
      {
        key: '_extractCOMPND',
        value: function _extractCOMPND(result) {
          if (!this._source._molecules) {
            return
          }

          var molecules = this._source._molecules
          result.newTag('COMPND', true)

          for (var i = 0; i < molecules.length; i++) {
            var chains = this._getMoleculeChains(molecules[i])

            result.newString()
            result.writeString(
              'MOL_ID: '.concat(molecules[i].index, ';'),
              11,
              80
            )
            result.newString()
            result.writeString(
              'MOLECULE: '.concat(molecules[i].name, ';'),
              11,
              80
            )
            result.newString()
            result.writeString('CHAIN: ', 11, 18)
            var chainsString = ''.concat(chains.join(', '), ';')
            result.writeEntireString(chainsString, 81)
          }
        }
      },
      {
        key: '_extractREMARK',
        value: function _extractREMARK(result) {
          this._Remark290(result)

          this._Remark350(result)
        }
      },
      {
        key: '_Remark290',
        value: function _Remark290(result) {
          if (!this._source.symmetry) {
            return
          }

          if (this._source.symmetry.length !== 0) {
            var matrices = this._source.symmetry
            result.newTag('REMARK', 290)
            result.newString()
            result.newString()
            result.writeEntireString(this._stringForRemark290)
            result.writeMatrices(matrices, 'SMTRY')
            result.newString()
            result.newString()
            result.writeString('REMARK: NULL', 11, 80)
          }
        }
      },
      {
        key: '_Remark350',
        value: function _Remark350(result) {
          if (!this._source.units) {
            return
          }

          var units = this._source.units
          var biomolIndx = 0
          result.newTag('REMARK', 350)
          result.newString()
          result.newString()
          result.writeEntireString(this._stringForRemark350)
          var assemblies = units.filter(function (unit) {
            return unit instanceof Assembly$3
          })

          for (var i = 0; i < assemblies.length; i++) {
            result.newString()
            result.newString()
            biomolIndx++
            result.writeString('BIOMOLECULE: '.concat(biomolIndx), 11, 80)
            var chains = assemblies[i].chains.join(', ')
            result.newString()
            result.writeString('APPLY THE FOLLOWING TO CHAINS: ')
            result.writeEntireString(chains, 69, {
              tag: 'AND CHAINS: ',
              begin: 31,
              end: 42
            })
            var matrices = assemblies[i].matrices
            result.writeMatrices(matrices, 'BIOMT')
          }
        }
      },
      {
        key: '_getMoleculeChains',
        value: function _getMoleculeChains(molecule) {
          function getChainName(residue) {
            return residue._chain._name
          }

          var chainNames = molecule.residues.map(getChainName)
          return chainNames.filter(function (item, pos) {
            return chainNames.indexOf(item) === pos
          })
        }
      }
    ])

    return PDBExporter
  })(Exporter)
  PDBExporter.formats = ['pdb']
  PDBExporter.SourceClass = Complex$9

  var FBX_POS_SIZE = 3
  var FBX_NORM_SIZE = 3
  var FBX_COL_SIZE = 4

  function copyFbxPoint3(src, srcIdx, dst, dstIdx) {
    dst[dstIdx] = src[srcIdx]
    dst[dstIdx + 1] = src[srcIdx + 1]
    dst[dstIdx + 2] = src[srcIdx + 2]
  }

  function copyFbxPoint4(src, srcIdx, dst, dstIdx, value) {
    dst[dstIdx] = src[srcIdx]
    dst[dstIdx + 1] = src[srcIdx + 1]
    dst[dstIdx + 2] = src[srcIdx + 2]
    dst[dstIdx + 3] = value
  }

  var vector4 = new THREE__namespace.Vector4()

  function copyTransformedPoint3(src, srcIdx, dst, dstIdx, opts) {
    vector4.set(src[srcIdx], src[srcIdx + 1], src[srcIdx + 2], opts.w)
    vector4.applyMatrix4(opts.matrix)
    dst[dstIdx] = vector4.x
    dst[dstIdx + 1] = vector4.y
    dst[dstIdx + 2] = vector4.z
  }

  function setSubArray(src, dst, count, copyFunctor, functorOpts) {
    if (
      (dst.array.length - dst.start) / dst.stride < count ||
      (src.array.length - src.start) / src.stride < count
    ) {
      return
    }

    if (src.stride === dst.stride) {
      dst.array.set(src.array, dst.start)
    } else {
      var idx = dst.start
      var arridx = src.start

      for (var i = 0; i < count; ++i, idx += dst.stride, arridx += src.stride) {
        copyFunctor(src.array, arridx, dst.array, idx, functorOpts)
      }
    }
  }

  var FBXModel = /*#__PURE__*/ (function () {
    function FBXModel() {
      _classCallCheck(this, FBXModel)

      this.positions = null
      this.normals = null
      this.colors = null
      this.indices = null
      this.lastPos = 0
      this.lastNorm = 0
      this.lastCol = 0
      this.lastIdx = 0
    }

    _createClass(FBXModel, [
      {
        key: 'init',
        value: function init(vertsCount, indsCount) {
          this.positions = new Float32Array(vertsCount * FBX_POS_SIZE)
          this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE)
          this.colors = new Float32Array(vertsCount * FBX_COL_SIZE)
          this.indices = new Int32Array(indsCount)
        }
      },
      {
        key: 'setPositions',
        value: function setPositions(array, start, count, stride) {
          var src = {
            array: array,
            start: start,
            stride: stride
          }
          var dst = {
            array: this.positions,
            start: this.lastPos,
            stride: FBX_POS_SIZE
          }
          setSubArray(src, dst, count, copyFbxPoint3)
          this.lastPos += count * FBX_POS_SIZE
        }
      },
      {
        key: 'setTransformedPositions',
        value: function setTransformedPositions(
          array,
          start,
          count,
          stride,
          matrix
        ) {
          var idx = this.lastPos
          var arrIdx = start
          var opts = {
            matrix: matrix,
            w: 1
          }

          for (
            var i = 0;
            i < count;
            ++i, arrIdx += stride, idx += FBX_POS_SIZE
          ) {
            copyTransformedPoint3(array, arrIdx, this.positions, idx, opts)
          }

          this.lastPos += count * FBX_POS_SIZE
        }
      },
      {
        key: 'setNormals',
        value: function setNormals(array, start, count, stride) {
          var src = {
            array: array,
            start: start,
            stride: stride
          }
          var dst = {
            array: this.normals,
            start: this.lastNorm,
            stride: FBX_NORM_SIZE
          }
          setSubArray(src, dst, count, copyFbxPoint3)
          this.lastNorm += count * FBX_NORM_SIZE
        }
      },
      {
        key: 'setTransformedNormals',
        value: function setTransformedNormals(
          array,
          start,
          count,
          stride,
          matrix
        ) {
          var idx = this.lastNorm
          var arrIdx = start
          var opts = {
            matrix: matrix,
            w: 0
          }

          for (
            var i = 0;
            i < count;
            ++i, arrIdx += stride, idx += FBX_NORM_SIZE
          ) {
            copyTransformedPoint3(array, arrIdx, this.normals, idx, opts)
          }

          this.lastNorm += count * FBX_NORM_SIZE
        }
      },
      {
        key: 'setColors',
        value: function setColors(array, start, count, stride) {
          var src = {
            array: array,
            start: start,
            stride: stride
          }
          var dst = {
            array: this.colors,
            start: this.lastCol,
            stride: FBX_COL_SIZE
          }
          setSubArray(src, dst, count, copyFbxPoint4, 1)
          this.lastCol += count * FBX_COL_SIZE
        }
      },
      {
        key: 'setIndices',
        value: function setIndices(array, start, count) {
          this.indices.set(array, this.lastIdx)
          this.lastIdx += count
        }
      },
      {
        key: 'setShiftedIndices',
        value: function setShiftedIndices(array, count, shift) {
          var shifted = array.map(function (x) {
            return x + shift
          })
          this.setIndices(shifted, 0, count)
        }
      },
      {
        key: 'getVerticesNumber',
        value: function getVerticesNumber() {
          return this.lastPos / FBX_POS_SIZE
        }
      },
      {
        key: 'addInstance',
        value: function addInstance(matrix, geo) {
          var currentCount = this.getVerticesNumber()
          this.setShiftedIndices(geo.indices, geo.indices.length, currentCount)
          var size = geo.itemSize
          this.setTransformedPositions(
            geo.positions,
            0,
            geo.vertsCount,
            size.position,
            matrix
          )
          this.setTransformedNormals(
            geo.normals,
            0,
            geo.vertsCount,
            size.normal,
            matrix
          )
          this.setColors(geo.colors, 0, geo.vertsCount, size.color)
        }
      }
    ])

    return FBXModel
  })()

  var FBXGeometry = /*#__PURE__*/ (function () {
    function FBXGeometry() {
      _classCallCheck(this, FBXGeometry)

      this.positions = null
      this.normals = null
      this.colors = null
      this.indices = null
      this.vertsCount = 0
      this.itemSize = null
    }

    _createClass(FBXGeometry, [
      {
        key: 'init',
        value: function init(geo, _info) {
          var attributes = geo.attributes
          this.itemSize = {
            position: attributes.position.itemSize,
            normal: attributes.normal.itemSize,
            color: attributes.color.itemSize
          }
        }
      }
    ])

    return FBXGeometry
  })()

  function _createSuper$9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$9()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$9() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var FBX1CGeometry = /*#__PURE__*/ (function (_FBXGeometry) {
    _inherits(FBX1CGeometry, _FBXGeometry)

    var _super = _createSuper$9(FBX1CGeometry)

    function FBX1CGeometry() {
      _classCallCheck(this, FBX1CGeometry)

      return _super.apply(this, arguments)
    }

    _createClass(FBX1CGeometry, [
      {
        key: 'init',
        value: function init(geo, _info) {
          _get(_getPrototypeOf(FBX1CGeometry.prototype), 'init', this).call(
            this,
            geo,
            _info
          )

          var _geo$attributes = geo.attributes,
            position = _geo$attributes.position,
            normal = _geo$attributes.normal,
            index = geo.index
          this.vertsCount = position.count
          this.positions = position.array
          this.normals = normal.array
          this.colors = new Float32Array(this.vertsCount * this.itemSize.color)
          this.indices = index.array
        }
      },
      {
        key: 'setColors',
        value: function setColors(color) {
          var offset = 0

          for (
            var i = 0, l = this.colors.length, cl = this.itemSize.color;
            i < l;
            i += cl
          ) {
            this.colors[offset++] = color.r
            this.colors[offset++] = color.g
            this.colors[offset++] = color.b
          }
        }
      }
    ])

    return FBX1CGeometry
  })(FBXGeometry)

  function _createSuper$8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$8()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$8() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var FBX2CCylinder = /*#__PURE__*/ (function (_FBXGeometry) {
    _inherits(FBX2CCylinder, _FBXGeometry)

    var _super = _createSuper$8(FBX2CCylinder)

    function FBX2CCylinder() {
      var _this

      _classCallCheck(this, FBX2CCylinder)

      _this = _super.call(this)
      _this._cutRawStart = 0
      _this._cutRawEnd = 0
      _this._facesPerSlice = 0
      return _this
    }

    _createClass(FBX2CCylinder, [
      {
        key: 'init',
        value: function init(geo, info) {
          _get(_getPrototypeOf(FBX2CCylinder.prototype), 'init', this).call(
            this,
            geo,
            info
          )

          var position = geo.attributes.position,
            index = geo.index
          this.vertsCount = position.count + info.addPerCylinder
          this._facesPerSlice = info.addPerCylinder
          this.positions = new Float32Array(this.vertsCount * position.itemSize)
          this.normals = new Float32Array(
            this.vertsCount * this.itemSize.normal
          )
          this.colors = new Float32Array(this.vertsCount * this.itemSize.color)

          this._extendVertices(geo, info)

          this.indices = new Uint32Array(index.count)

          this._extendIndices(geo, info)
        }
      },
      {
        key: '_extendVertices',
        value: function _extendVertices(geo, info) {
          var position = geo.attributes.position
          var normal = geo.attributes.normal
          var geoParams = geo.getGeoParams()
          var cutRaw = 1
          this._cutRawStart = cutRaw * geoParams.radialSegments
          this._cutRawEnd = this._cutRawStart + info.addPerCylinder
          {
            var temp = position.array.slice(
              0,
              this._cutRawEnd * position.itemSize
            )
            this.positions.set(temp, 0)
            temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize)
            this.normals.set(temp, 0)
          }
          {
            var _temp = position.array.slice(
              this._cutRawStart * position.itemSize,
              position.array.length
            )

            this.positions.set(_temp, this._cutRawEnd * position.itemSize)
            _temp = normal.array.slice(
              this._cutRawStart * normal.itemSize,
              normal.array.length
            )
            this.normals.set(_temp, this._cutRawEnd * normal.itemSize)
          }
        }
      },
      {
        key: '_extendIndices',
        value: function _extendIndices(geo, info) {
          var index = geo.index
          var indicesPerQuad = 6
          var startToShift = info.addPerCylinder * indicesPerQuad
          var shift = info.addPerCylinder
          var shifted = index.array.slice(startToShift, index.count)
          shifted = shifted.map(function (x) {
            return x + shift
          })
          this.indices.set(index.array, 0)
          this.indices.set(shifted, startToShift)
        }
      },
      {
        key: '_setColorRange',
        value: function _setColorRange(start, end, array, color) {
          var colorSize = color.length

          for (var i = start; i < end; i += colorSize) {
            array.set(color, i)
          }
        }
      },
      {
        key: 'setColors',
        value: function setColors(color1, color2) {
          var colorSize = this.itemSize.color
          var part1End = this._cutRawEnd * colorSize
          var part2End = part1End * 2

          this._setColorRange(0, part1End, this.colors, color1.toArray())

          this._setColorRange(part1End, part2End, this.colors, color2.toArray())

          if (part2End < this.colors.length) {
            var capSize = (this._facesPerSlice + 1) * colorSize
            var cap1End = part2End + capSize

            this._setColorRange(
              part2End,
              cap1End,
              this.colors,
              color2.toArray()
            )

            var cap2End = cap1End + capSize

            this._setColorRange(cap1End, cap2End, this.colors, color1.toArray())
          }
        }
      }
    ])

    return FBX2CCylinder
  })(FBXGeometry)

  var FBXInfoExtractor = /*#__PURE__*/ (function () {
    function FBXInfoExtractor() {
      _classCallCheck(this, FBXInfoExtractor)

      this._materials = []
      this._models = []
    }

    _createClass(FBXInfoExtractor, [
      {
        key: 'process',
        value: function process(data) {
          this._extractModelsAndMaterials(data)

          var models = this._flattenModels()

          return {
            name: data.name,
            models: models,
            materials: this._materials
          }
        }
      },
      {
        key: '_extractModelsAndMaterials',
        value: function _extractModelsAndMaterials(data) {
          var _this = this

          var layersOfInterest = new THREE__namespace.Layers()
          layersOfInterest.set(gfxutils.LAYERS.DEFAULT)
          layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT)
          data.traverse(function (object) {
            if (
              object instanceof THREE__namespace.Mesh &&
              object.layers.test(layersOfInterest) &&
              _this.checkExportAbility(object)
            ) {
              if (object.geometry.type === 'InstancedBufferGeometry') {
                _this._collectInstancedGeoInfo(object)
              } else {
                _this._collectGeoInfo(object)
              }
            }
          })
        }
      },
      {
        key: '_reworkIndices',
        value: function _reworkIndices(indices) {
          var faceSize = 3

          for (var i = faceSize - 1; i < indices.length; i += faceSize) {
            indices[i] *= -1
            indices[i]--
          }
        }
      },
      {
        key: '_flattenModels',
        value: function _flattenModels() {
          var overallVertsCount = 0

          function shift(x) {
            return x + overallVertsCount
          }

          var combined = []

          for (var i = 0, n = this._models.length; i < n; i++) {
            var models = this._models[i]
            var indices = []
            var positions = []
            var normals = []
            var colors = []
            overallVertsCount = 0

            for (var j = 0; j < models.length; j++) {
              var m = models[j]
              indices.push(m.indices.map(shift))
              overallVertsCount += m.getVerticesNumber()
              positions.push(m.positions)
              normals.push(m.normals)
              colors.push(m.colors)
            }

            indices = utils.mergeTypedArraysUnsafe(indices)

            this._reworkIndices(indices)

            positions = utils.mergeTypedArraysUnsafe(positions)
            normals = utils.mergeTypedArraysUnsafe(normals)
            colors = utils.mergeTypedArraysUnsafe(colors)
            combined.push({
              indices: indices,
              positions: positions,
              normals: normals,
              colors: colors,
              verticesCount: overallVertsCount
            })
          }

          return combined
        }
      },
      {
        key: 'checkExportAbility',
        value: function checkExportAbility(mesh) {
          if (mesh.geometry.attributes.position.count === 0) {
            return false
          }

          if (mesh instanceof ZSpriteMesh) {
            logger.warn(
              "Currently we cannot export 'sprites' modes, like BS, WV, LC. Please turn of settings 'zSprites' and try again"
            )
            return false
          }

          if (mesh instanceof ThickLineMesh) {
            logger.warn('Currently we cannot export Lines mode')
            return false
          }

          return true
        }
      },
      {
        key: '_collectGeoInfo',
        value: function _collectGeoInfo(mesh) {
          var _mesh$geometry = mesh.geometry,
            _mesh$geometry$attrib = _mesh$geometry.attributes,
            position = _mesh$geometry$attrib.position,
            color = _mesh$geometry$attrib.color,
            normal = _mesh$geometry$attrib.normal,
            index = _mesh$geometry.index,
            matrix = mesh.matrix
          var model = new FBXModel()
          var vertCount = position.count
          model.init(vertCount, index.count)

          if (matrix.isIdentity()) {
            model.setPositions(position.array, 0, vertCount, position.itemSize)
            model.setNormals(normal.array, 0, vertCount, normal.itemSize)
          } else {
            model.setTransformedPositions(
              position.array,
              0,
              vertCount,
              position.itemSize,
              matrix
            )
            model.setTransformedNormals(
              normal.array,
              0,
              vertCount,
              normal.itemSize,
              matrix
            )
          }

          model.setColors(color.array, 0, vertCount, color.itemSize)
          model.setIndices(index.array, 0, index.count)

          var material = this._collectMaterialInfo(mesh)

          this._addToPool(model, material)
        }
      },
      {
        key: '_collectSpheresInfo',
        value: function _collectSpheresInfo(mesh) {
          var _mesh$geometry2 = mesh.geometry,
            _mesh$geometry2$attri = _mesh$geometry2.attributes,
            position = _mesh$geometry2$attri.position,
            color = _mesh$geometry2$attri.color,
            index = _mesh$geometry2.index,
            matrix = mesh.matrix
          var model = new FBXModel()
          var instCount = mesh.geometry.instanceCount
          var vertCount = position.count
          var indsCount = index.count
          model.init(instCount * vertCount, instCount * indsCount)
          var geo = new FBX1CGeometry()
          geo.init(mesh.geometry)
          var instMatrix = new THREE__namespace.Matrix4()
          var objMatrix = new THREE__namespace.Matrix4()
          var sphereColor = new THREE__namespace.Color()

          for (
            var instanceIndex = 0;
            instanceIndex < instCount;
            ++instanceIndex
          ) {
            var colorIdx = instanceIndex * color.itemSize
            sphereColor.fromArray(color.array, colorIdx)
            geo.setColors(sphereColor)

            this._getSphereInstanceMatrix(
              mesh.geometry,
              instanceIndex,
              instMatrix
            )

            objMatrix.multiplyMatrices(matrix, instMatrix)
            model.addInstance(objMatrix, geo)
          }

          var material = this._collectMaterialInfo(mesh)

          this._addToPool(model, material)
        }
      },
      {
        key: '_collectCylindersInfo',
        value: function _collectCylindersInfo(mesh) {
          var _mesh$geometry3 = mesh.geometry,
            _mesh$geometry3$attri = _mesh$geometry3.attributes,
            position = _mesh$geometry3$attri.position,
            color = _mesh$geometry3$attri.color,
            color2 = _mesh$geometry3$attri.color2,
            index = _mesh$geometry3.index,
            matrix = mesh.matrix
          var model = new FBXModel()
          var instCount = mesh.geometry.instanceCount
          var oneCCylinder = new FBX1CGeometry()
          oneCCylinder.init(mesh.geometry)

          var splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry)

          var twoCCylinder = null

          if (splittingInfo.needToSplit > 0) {
            twoCCylinder = new FBX2CCylinder()
            twoCCylinder.init(mesh.geometry, splittingInfo)
          }

          var additionalVertsCount =
            splittingInfo.addPerCylinder * splittingInfo.needToSplit
          var vertCount = position.count
          var indsCount = index.count
          model.init(
            instCount * vertCount + additionalVertsCount,
            instCount * indsCount
          )
          var instMatrix = new THREE__namespace.Matrix4()
          var objMatrix = new THREE__namespace.Matrix4()
          var colorStart = new THREE__namespace.Color()
          var colorEnd = new THREE__namespace.Color()
          var geo = {}

          for (
            var instanceIndex = 0;
            instanceIndex < instCount;
            ++instanceIndex
          ) {
            var colorIdx = instanceIndex * color.itemSize

            if (splittingInfo.is2Colored[instanceIndex]) {
              colorStart.fromArray(color2.array, colorIdx)
              colorEnd.fromArray(color.array, colorIdx)

              if (twoCCylinder) {
                twoCCylinder.setColors(colorStart, colorEnd)
                geo = twoCCylinder
              }
            } else {
              colorStart.fromArray(color.array, colorIdx)
              oneCCylinder.setColors(colorStart)
              geo = oneCCylinder
            }

            this._getCylinderInstanceMatrix(
              mesh.geometry,
              instanceIndex,
              instMatrix
            )

            objMatrix.multiplyMatrices(matrix, instMatrix)
            model.addInstance(objMatrix, geo)
          }

          var material = this._collectMaterialInfo(mesh)

          this._addToPool(model, material)
        }
      },
      {
        key: '_addToPool',
        value: function _addToPool(model, material) {
          var materialIdx = this._checkExistingMaterial(material)

          if (materialIdx < 0) {
            this._models.push([model])

            this._materials.push(material)
          } else {
            var models = this._models[materialIdx]
            models.push(model)
          }
        }
      },
      {
        key: '_checkExistingMaterial',
        value: function _checkExistingMaterial(material) {
          return ___default['default'].findIndex(this._materials, function (m) {
            return ___default['default'].isEqual(m, material)
          })
        }
      },
      {
        key: '_gatherCylindersColoringInfo',
        value: function _gatherCylindersColoringInfo(geo) {
          var instCount = geo.instanceCount
          var color1 = geo.attributes.color.array
          var color2 = geo.attributes.color2.array
          var stride = geo.attributes.color.itemSize
          var is2Colored = new Array(instCount)
          var needToSplit = 0
          var colIdx = 0

          for (var i = 0; i < instCount; i++, colIdx += stride) {
            var differs =
              Math.abs(color1[colIdx] - color2[colIdx]) > 0.0000001 ||
              Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 0.0000001 ||
              Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 0.0000001
            is2Colored[i] = differs
            needToSplit += differs
          }

          var geoParams = geo.getGeoParams()
          var addPerCylinder = geoParams.radialSegments
          return {
            is2Colored: is2Colored,
            needToSplit: needToSplit,
            addPerCylinder: addPerCylinder
          }
        }
      },
      {
        key: '_collectInstancedGeoInfo',
        value: function _collectInstancedGeoInfo(mesh) {
          if (mesh.geometry instanceof InstancedSpheresGeometry) {
            this._collectSpheresInfo(mesh)
          } else if (mesh.geometry instanceof Instanced2CCylindersGeometry) {
            this._collectCylindersInfo(mesh)
          }
        }
      },
      {
        key: '_collectMaterialInfo',
        value: function _collectMaterialInfo(mesh) {
          var uberOptions = mesh.material.uberOptions
          return {
            diffuse: uberOptions.diffuse.toArray(),
            opacity: uberOptions.opacity,
            shininess: uberOptions.shininess,
            specular: uberOptions.specular.toArray()
          }
        }
      },
      {
        key: '_getCylinderInstanceMatrix',
        value: function _getCylinderInstanceMatrix(geo, instIdx, matrix) {
          var matVector1 = geo.attributes.matVector1.array
          var matVector2 = geo.attributes.matVector2.array
          var matVector3 = geo.attributes.matVector3.array
          var idxOffset = instIdx * 4
          matrix.set(
            matVector1[idxOffset],
            matVector1[idxOffset + 1],
            matVector1[idxOffset + 2],
            matVector1[idxOffset + 3],
            matVector2[idxOffset],
            matVector2[idxOffset + 1],
            matVector2[idxOffset + 2],
            matVector2[idxOffset + 3],
            matVector3[idxOffset],
            matVector3[idxOffset + 1],
            matVector3[idxOffset + 2],
            matVector3[idxOffset + 3],
            0,
            0,
            0,
            1
          )
        }
      },
      {
        key: '_getSphereInstanceMatrix',
        value: function _getSphereInstanceMatrix(geo, instIdx, matrix) {
          var offset = geo.attributes.offset
          var idx = instIdx * offset.itemSize
          var x = offset.array[idx]
          var y = offset.array[idx + 1]
          var z = offset.array[idx + 2]
          var scale = offset.array[idx + 3]
          matrix.set(scale, 0, 0, x, 0, scale, 0, y, 0, 0, scale, z, 0, 0, 0, 1)
        }
      }
    ])

    return FBXInfoExtractor
  })()

  var defaultDefinitions =
    '\nDefinitions:  {\n  Version: 100\n  Count: 3\n  ObjectType: "Model" {\n    Count: 1\n  }\n  ObjectType: "Geometry" {\n    Count: 1\n  }\n  ObjectType: "Material" {\n    Count: 1\n  }\n  ObjectType: "Pose" {\n    Count: 1\n  }\n  ObjectType: "GlobalSettings" {\n    Count: 1\n  }\n} '
  var defaultProperties =
    'Properties60: {\n      Property: "QuaternionInterpolate", "bool", "",0\n      Property: "Visibility", "Visibility", "A",1\n      Property: "Lcl Translation", "Lcl Translation", "A",0.000000000000000,0.000000000000000,-1789.238037109375000\n      Property: "Lcl Rotation", "Lcl Rotation", "A",0.000009334667643,-0.000000000000000,0.000000000000000\n      Property: "Lcl Scaling", "Lcl Scaling", "A",1.000000000000000,1.000000000000000,1.000000000000000\n      Property: "RotationOffset", "Vector3D", "",0,0,0\n      Property: "RotationPivot", "Vector3D", "",0,0,0\n      Property: "ScalingOffset", "Vector3D", "",0,0,0\n      Property: "ScalingPivot", "Vector3D", "",0,0,0\n      Property: "TranslationActive", "bool", "",0\n      Property: "TranslationMin", "Vector3D", "",0,0,0\n      Property: "TranslationMax", "Vector3D", "",0,0,0\n      Property: "TranslationMinX", "bool", "",0\n      Property: "TranslationMinY", "bool", "",0\n      Property: "TranslationMinZ", "bool", "",0\n      Property: "TranslationMaxX", "bool", "",0\n      Property: "TranslationMaxY", "bool", "",0\n      Property: "TranslationMaxZ", "bool", "",0\n      Property: "RotationOrder", "enum", "",0\n      Property: "RotationSpaceForLimitOnly", "bool", "",0\n      Property: "AxisLen", "double", "",10\n      Property: "PreRotation", "Vector3D", "",0,0,0\n      Property: "PostRotation", "Vector3D", "",0,0,0\n      Property: "RotationActive", "bool", "",0\n      Property: "RotationMin", "Vector3D", "",0,0,0\n      Property: "RotationMax", "Vector3D", "",0,0,0\n      Property: "RotationMinX", "bool", "",0\n      Property: "RotationMinY", "bool", "",0\n      Property: "RotationMinZ", "bool", "",0\n      Property: "RotationMaxX", "bool", "",0\n      Property: "RotationMaxY", "bool", "",0\n      Property: "RotationMaxZ", "bool", "",0\n      Property: "RotationStiffnessX", "double", "",0\n      Property: "RotationStiffnessY", "double", "",0\n      Property: "RotationStiffnessZ", "double", "",0\n      Property: "MinDampRangeX", "double", "",0\n      Property: "MinDampRangeY", "double", "",0\n      Property: "MinDampRangeZ", "double", "",0\n      Property: "MaxDampRangeX", "double", "",0\n      Property: "MaxDampRangeY", "double", "",0\n      Property: "MaxDampRangeZ", "double", "",0\n      Property: "MinDampStrengthX", "double", "",0\n      Property: "MinDampStrengthY", "double", "",0\n      Property: "MinDampStrengthZ", "double", "",0\n      Property: "MaxDampStrengthX", "double", "",0\n      Property: "MaxDampStrengthY", "double", "",0\n      Property: "MaxDampStrengthZ", "double", "",0\n      Property: "PreferedAngleX", "double", "",0\n      Property: "PreferedAngleY", "double", "",0\n      Property: "PreferedAngleZ", "double", "",0\n      Property: "InheritType", "enum", "",0\n      Property: "ScalingActive", "bool", "",0\n      Property: "ScalingMin", "Vector3D", "",1,1,1\n      Property: "ScalingMax", "Vector3D", "",1,1,1\n      Property: "ScalingMinX", "bool", "",0\n      Property: "ScalingMinY", "bool", "",0\n      Property: "ScalingMinZ", "bool", "",0\n      Property: "ScalingMaxX", "bool", "",0\n      Property: "ScalingMaxY", "bool", "",0\n      Property: "ScalingMaxZ", "bool", "",0\n      Property: "GeometricTranslation", "Vector3D", "",0,0,0\n      Property: "GeometricRotation", "Vector3D", "",0,0,0\n      Property: "GeometricScaling", "Vector3D", "",1,1,1\n      Property: "LookAtProperty", "object", ""\n      Property: "UpVectorProperty", "object", ""\n      Property: "Show", "bool", "",1\n      Property: "NegativePercentShapeSupport", "bool", "",1\n      Property: "DefaultAttributeIndex", "int", "",0\n      Property: "Color", "Color", "A+",0,0,0\n      Property: "Size", "double", "",100\n      Property: "Look", "enum", "",1\n    }'
  var defaultMaterialLayer =
    '\n    LayerElementMaterial: 0 {\n      Version: 101\n      Name: ""\n      MappingInformationType: "AllSame"\n      ReferenceInformationType: "Direct"\n      Materials: 0\n    }'
  var defaultLayerBlock =
    '\n    Layer: 0 {\n      Version: 100\n      LayerElement:  {\n        Type: "LayerElementNormal"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: "LayerElementColor"\n        TypedIndex: 0\n      }\n      LayerElement:  {\n        Type: "LayerElementMaterial"\n        TypedIndex: 0\n      }\n    }'
  var globalSettings =
    'GlobalSettings: {\n    Version: 1000\n    Properties60:  {\n      Property: "UpAxis", "int", "",1\n      Property: "UpAxisSign", "int", "",1\n      Property: "FrontAxis", "int", "",2\n      Property: "FrontAxisSign", "int", "",1\n      Property: "CoordAxis", "int", "",0\n      Property: "CoordAxisSign", "int", "",1\n      Property: "UnitScaleFactor", "double", "",1\n    }\n  }'

  var FBXResult = /*#__PURE__*/ (function () {
    function FBXResult() {
      _classCallCheck(this, FBXResult)

      this._resultArray = []
      this._info = null
    }

    _createClass(FBXResult, [
      {
        key: 'getResult',
        value: function getResult(info) {
          this._info = info

          this._resultArray.push(this._writeHeader())

          this._resultArray.push(this._writeDefinitions())

          this._resultArray.push(
            this._writeObjects(info.models, info.materials)
          )

          this._resultArray.push(this._writeRelations())

          this._resultArray.push(this._writeConnections())

          this._info = null
          return this._resultArray.join('')
        }
      },
      {
        key: '_writeHeader',
        value: function _writeHeader() {
          var FBXHeaderVersion = 1003
          var FBXVersion = 6100
          var date = new Date()
          var timeStampVersion = 1000
          var creator = 'Miew FBX Exporter v'.concat(this._info.version)
          return '; FBX 6.1.0 project file\n; Created by '
            .concat(
              creator,
              ' Copyright (c) 2015-2020 EPAM Systems, Inc.\n; For support please contact miew@epam.com\n; ----------------------------------------------------\n\nFBXHeaderExtension:  {\n  FBXHeaderVersion: '
            )
            .concat(FBXHeaderVersion, '\n  FBXVersion: ')
            .concat(FBXVersion, '\n  CreationTimeStamp:  {\n    Version: ')
            .concat(timeStampVersion, '\n    Year: ')
            .concat(date.getFullYear(), '\n    Month: ')
            .concat(date.getMonth() + 1, ' \n    Day: ')
            .concat(date.getDate(), '\n    Hour: ')
            .concat(date.getHours(), '\n    Minute: ')
            .concat(date.getMinutes(), '\n    Second: ')
            .concat(date.getSeconds(), '\n    Millisecond: ')
            .concat(date.getMilliseconds(), '\n  }\n  Creator: "')
            .concat(
              creator,
              '"\n  OtherFlags:  {\n    FlagPLE: 0\n  }\n}\nCreationTime: "'
            )
            .concat(date, '"\nCreator: "')
            .concat(creator, '"  \n')
        }
      },
      {
        key: '_writeDefinitions',
        value: function _writeDefinitions() {
          return '\n; Object definitions\n;------------------------------------------------------------------\n\n'.concat(
            defaultDefinitions,
            '\n'
          )
        }
      },
      {
        key: '_models',
        value: function _models() {
          var modelVersion = 232
          var allModels = ''
          var models = this._info.models

          for (var i = 0; i < models.length; ++i) {
            var model = models[i]
            var vertCount = model.verticesCount
            allModels += '\n  Model: "Model::'
              .concat(this._info.name, '_')
              .concat(i, '", "Mesh" {\n    Version: ')
              .concat(modelVersion, ' \n    ')
              .concat(defaultProperties, '\n    ')
              .concat(
                this._verticesIndices(model.positions, model.indices),
                '\n    '
              )
              .concat(this._normalLayer(model.normals), ' \n    ')
              .concat(this._colorLayer(model.colors, vertCount), ' \n    ')
              .concat(defaultMaterialLayer, '  \n    ')
              .concat(defaultLayerBlock, '\n  }')
          }

          return allModels
        }
      },
      {
        key: '_materials',
        value: function _materials() {
          var materialVersion = 102
          var allMaterials = ''
          var materials = this._info.materials

          for (var i = 0; i < materials.length; ++i) {
            var material = materials[i]
            allMaterials += '\n  Material: "Material::'
              .concat(this._info.name, '_')
              .concat(i, '_default", "" {\n    Version: ')
              .concat(
                materialVersion,
                '\n    ShadingModel: "lambert"\n    MultiLayer: 0\n    '
              )
              .concat(this._materialProperties(material), '\n  }')
          }

          return allMaterials
        }
      },
      {
        key: '_writeObjects',
        value: function _writeObjects() {
          return '\n; Object properties\n;------------------------------------------------------------------\n\nObjects:  {\n  '
            .concat(this._models(), '\n  ')
            .concat(this._materials(), '\n  ')
            .concat(globalSettings, '\n}\n')
        }
      },
      {
        key: '_writeRelations',
        value: function _writeRelations() {
          var modelsList = ''

          for (var i = 0; i < this._info.models.length; ++i) {
            modelsList += '\n  Model: "Model::'
              .concat(this._info.name, '_')
              .concat(i, '", "Mesh" {\n  }')
          }

          var materialList = ''

          for (var _i = 0; _i < this._info.materials.length; ++_i) {
            materialList += '\n  Material: "Material::'
              .concat(this._info.name, '_')
              .concat(_i, '_default", "" {\n  }')
          }

          return '\n; Object relations\n;------------------------------------------------------------------\n\nRelations:  {\n  '
            .concat(
              modelsList,
              '\n  Model: "Model::Producer Perspective", "Camera" {\n  }\n  Model: "Model::Producer Top", "Camera" {\n  }\n  Model: "Model::Producer Bottom", "Camera" {\n  }\n  Model: "Model::Producer Front", "Camera" {\n  }\n  Model: "Model::Producer Back", "Camera" {\n  }\n  Model: "Model::Producer Right", "Camera" {\n  }\n  Model: "Model::Producer Left", "Camera" {\n  }\n  Model: "Model::Camera Switcher", "CameraSwitcher" {\n  }\n  '
            )
            .concat(materialList, '\n}')
        }
      },
      {
        key: '_writeConnections',
        value: function _writeConnections() {
          var modelsList = ''
          var name = this._info.name

          for (var i = 0; i < this._info.models.length; ++i) {
            modelsList += '\n  Connect: "OO", "Model::'
              .concat(name, '_')
              .concat(i, '", "Model::Scene"')
          }

          var materialList = ''

          for (var _i2 = 0; _i2 < this._info.materials.length; ++_i2) {
            materialList += '\n  Connect: "OO", "Material::'
              .concat(name, '_')
              .concat(_i2, '_default", "Model::')
              .concat(name, '_')
              .concat(_i2, '"')
          }

          return '\n; Object connections\n;------------------------------------------------------------------\n\nConnections:  {\n  '
            .concat(modelsList, '\n  ')
            .concat(materialList, '\n}')
        }
      },
      {
        key: '_floatArrayToString',
        value: function _floatArrayToString(array) {
          var str = []

          for (var i = 0; i < array.length; ++i) {
            str[i] = array[i].toFixed(6)
          }

          return str.join(',')
        }
      },
      {
        key: '_colorLayer',
        value: function _colorLayer(colorArray, vertCount) {
          var layerElementColorNumber = 0
          var layerElementColorVersion = 101
          var layerElementColorName = ''

          var colorsStr = this._floatArrayToString(colorArray)

          var colorIndices = _toConsumableArray(Array(vertCount).keys())

          return '\n    LayerElementColor: '
            .concat(layerElementColorNumber, ' {\n      Version: ')
            .concat(layerElementColorVersion, '\n      Name: "')
            .concat(
              layerElementColorName,
              '"\n      MappingInformationType: "ByVertice"\n      ReferenceInformationType: "Direct"\n      Colors: '
            )
            .concat(colorsStr, '\n      ColorIndex: ')
            .concat(colorIndices, '\n    }')
        }
      },
      {
        key: '_normalLayer',
        value: function _normalLayer(normalArray) {
          var layerElementNormalNumber = 0
          var layerElementNormalVersion = 101
          var layerElementNormalName = ''

          var normalsStr = this._floatArrayToString(normalArray)

          return '\n    LayerElementNormal: '
            .concat(layerElementNormalNumber, ' {\n      Version: ')
            .concat(layerElementNormalVersion, '\n      Name: "')
            .concat(
              layerElementNormalName,
              '"\n      MappingInformationType: "ByVertice"\n      ReferenceInformationType: "Direct" \n      Normals: '
            )
            .concat(normalsStr, '\n    }')
        }
      },
      {
        key: '_verticesIndices',
        value: function _verticesIndices(positions, indices) {
          var multiLayer = 0
          var multiTake = 1
          var shading = 'Y'
          var culling = 'CullingOff'
          var geometryVersion = 124

          var vertStr = this._floatArrayToString(positions)

          return 'MultiLayer: '
            .concat(multiLayer, '\n    MultiTake: ')
            .concat(multiTake, '\n    Shading: ')
            .concat(shading, '\n    Culling: "')
            .concat(culling, '"\n    Vertices: ')
            .concat(vertStr, '\n    PolygonVertexIndex: ')
            .concat(indices, '\n    GeometryVersion: ')
            .concat(geometryVersion)
        }
      },
      {
        key: '_materialProperties',
        value: function _materialProperties(material) {
          return 'Properties60:  {\n      Property: "ShadingModel", "KString", "", "Lambert"\n      Property: "MultiLayer", "bool", "",0\n      Property: "EmissiveColor", "ColorRGB", "",0,0,0\n      Property: "EmissiveFactor", "double", "",0.0000\n      Property: "AmbientColor", "ColorRGB", "",1,1,1\n      Property: "AmbientFactor", "double", "",0.0000\n      Property: "DiffuseColor", "ColorRGB", "",'
            .concat(
              material.diffuse,
              '\n      Property: "DiffuseFactor", "double", "",1.0000\n      Property: "Bump", "Vector3D", "",0,0,0\n      Property: "TransparentColor", "ColorRGB", "",1,1,1\n      Property: "TransparencyFactor", "double", "",0.0000\n      Property: "SpecularColor", "ColorRGB", "",'
            )
            .concat(
              material.specular,
              '\n      Property: "SpecularFactor", "double", "",1.0000\n      Property: "ShininessExponent", "double", "",'
            )
            .concat(
              material.shininess,
              '\n      Property: "ReflectionColor", "ColorRGB", "",0,0,0\n      Property: "ReflectionFactor", "double", "",1\n      Property: "Ambient", "ColorRGB", "",1,1,1\n      Property: "Diffuse", "ColorRGB", "",'
            )
            .concat(
              material.diffuse,
              '\n      Property: "Specular", "ColorRGB", "",'
            )
            .concat(
              material.specular,
              '\n      Property: "Shininess", "double", "",'
            )
            .concat(
              material.shininess,
              '\n      Property: "Opacity", "double", "",'
            )
            .concat(
              material.opacity,
              '\n      Property: "Reflectivity", "double", "",0\n    }'
            )
        }
      }
    ])

    return FBXResult
  })()

  function _createSuper$7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$7()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$7() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var FBXExporter = /*#__PURE__*/ (function (_Exporter) {
    _inherits(FBXExporter, _Exporter)

    var _super = _createSuper$7(FBXExporter)

    function FBXExporter(source, options) {
      var _this

      _classCallCheck(this, FBXExporter)

      _this = _super.call(this, source, options)
      _this._data = source
      _this._version = options.miewVersion || '0.0-UNSPECIFIED'
      _this._extractor = new FBXInfoExtractor()
      return _this
    }

    _createClass(FBXExporter, [
      {
        key: 'exportSync',
        value: function exportSync() {
          var result = new FBXResult()

          if (!this._source) {
            return this._result
          }

          var info = this._extractor.process(this._data)

          info.version = this._version
          this._result = result.getResult(info)
          return this._result
        }
      }
    ])

    return FBXExporter
  })(Exporter)
  FBXExporter.formats = ['fbx']
  FBXExporter.SourceClass = ComplexVisual

  var exporters = new ExporterList([PDBExporter, FBXExporter])

  var io = {
    loaders: loaders,
    parsers: parsers,
    exporters: exporters
  }

  var tempColor = new THREE__namespace.Color()

  var CSS2DRenderer = /*#__PURE__*/ (function () {
    function CSS2DRenderer() {
      _classCallCheck(this, CSS2DRenderer)

      this._width = 0
      this._height = 0
      this._widthHalf = 0
      this._heightHalf = 0
      this._vector = new THREE__namespace.Vector3()
      this._viewMatrix = new THREE__namespace.Matrix4()
      this._projectionMatrix = new THREE__namespace.Matrix4()
      this._domElement = document.createElement('div')
      this._domElement.style.overflow = 'hidden'
      this._domElement.style.position = 'absolute'
      this._domElement.style.top = '0'
      this._domElement.style.zIndex = '0'
      this._domElement.style.pointerEvents = 'none'
    }

    _createClass(CSS2DRenderer, [
      {
        key: 'getElement',
        value: function getElement() {
          return this._domElement
        }
      },
      {
        key: 'reset',
        value: function reset() {
          var myNode = this.getElement()

          while (myNode.firstChild) {
            myNode.removeChild(myNode.firstChild)
          }
        }
      },
      {
        key: 'setSize',
        value: function setSize(width, height) {
          this._width = width
          this._height = height
          this._widthHalf = this._width / 2
          this._heightHalf = this._height / 2
          this._domElement.style.width = ''.concat(width, 'px')
          this._domElement.style.height = ''.concat(height, 'px')
        }
      },
      {
        key: '_renderObject',
        value: function _renderObject(object, camera, scene) {
          function lerpColorAsHex(a, b, t) {
            tempColor.setHex(a)
            tempColor.lerp(b, t)
            return '#'.concat(tempColor.getHexString())
          }

          function colorAsHex(a) {
            tempColor.setHex(a)
            return '#'.concat(tempColor.getHexString())
          }

          if (object instanceof CSS2DObject) {
            this._vector.setFromMatrixPosition(object.matrixWorld)

            if (
              object.userData !== undefined &&
              object.userData.offset !== undefined
            ) {
              var localOffset = new THREE__namespace.Vector3(
                object.userData.offset.x,
                object.userData.offset.y,
                0
              )

              this._vector.add(
                localOffset.multiplyScalar(
                  object.matrixWorld.getMaxScaleOnAxis()
                )
              )
            }

            this._vector.applyMatrix4(this._viewMatrix)

            var visibility =
              this._vector.z > -camera.near ? 'hidden' : 'visible'
            var zIndex =
              (10000 * (camera.far - -this._vector.z)) /
              (camera.far - camera.near)
            var element = object.getElement()

            if (typeof scene.fog === 'undefined') {
              element.style.color = colorAsHex(object.userData.color)

              if (object.userData.background !== 'transparent') {
                element.style.background = colorAsHex(
                  object.userData.background
                )
              }
            } else {
              var fogFactor = THREE__namespace.MathUtils.smoothstep(
                -this._vector.z,
                scene.fog.near,
                scene.fog.far
              )
              element.style.color = lerpColorAsHex(
                object.userData.color,
                scene.fog.color,
                fogFactor
              )

              if (object.userData.background !== 'transparent') {
                element.style.background = lerpColorAsHex(
                  object.userData.background,
                  scene.fog.color,
                  fogFactor
                )
              }
            }

            this._vector.applyMatrix4(this._projectionMatrix)

            var style = ''
              .concat(
                object.userData !== {}
                  ? object.userData.translation
                  : 'translate(-50%, -50%) ',
                'translate('
              )
              .concat(this._vector.x * this._widthHalf + this._widthHalf, 'px,')
              .concat(
                -this._vector.y * this._heightHalf + this._heightHalf,
                'px)'
              )
            element.style.visibility = visibility
            element.style.WebkitTransform = style
            element.style.MozTransform = style
            element.style.oTransform = style
            element.style.transform = style
            element.style.zIndex = Number(zIndex).toFixed(0)

            if (element.parentNode !== this._domElement) {
              this._domElement.appendChild(element)
            }
          }

          for (var i = 0, l = object.children.length; i < l; i++) {
            this._renderObject(object.children[i], camera, scene)
          }
        }
      },
      {
        key: 'render',
        value: function render(scene, camera) {
          scene.updateMatrixWorld()

          if (camera.parent === null) {
            camera.updateMatrixWorld()
          }

          camera.matrixWorldInverse.copy(camera.matrixWorld).invert()

          this._viewMatrix.copy(camera.matrixWorldInverse)

          this._projectionMatrix.copy(camera.projectionMatrix)

          this._renderObject(scene, camera, scene)
        }
      }
    ])

    return CSS2DRenderer
  })()

  var VK_LEFT = 37
  var VK_UP = 38
  var VK_RIGHT = 39
  var VK_DOWN = 40
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    TRANSLATE: 1,
    SCALE: 2,
    TRANSLATE_PIVOT: 3
  }
  var FULL_STOP_THRESHOLD = 0.1
  var quaternion = new THREE__namespace.Quaternion()
  var matrix4 = new THREE__namespace.Matrix4()

  function ObjectHandler(objects, camera, pivot, options) {
    this.objects = objects

    var _objects = _slicedToArray(objects, 1)

    this.object = _objects[0]
    this.camera = camera
    this.pivot = pivot
    this.axis = new THREE__namespace.Vector3(0, 0, 1)
    this.options = options
    this.lastRotation = {
      axis: new THREE__namespace.Vector3(),
      angle: 0.0
    }
  }

  ObjectHandler.prototype._rotate = (function () {
    var p = new THREE__namespace.Vector3()
    var q = new THREE__namespace.Quaternion()
    var s = new THREE__namespace.Vector3()
    var m = new THREE__namespace.Matrix4()
    return function (quat) {
      var zeroPivot =
        this.pivot.x === 0.0 && this.pivot.y === 0.0 && this.pivot.z === 0.0
      m.copy(this.object.matrix)

      if (zeroPivot) {
        m.multiply(matrix4.makeRotationFromQuaternion(quat))
      } else {
        m.multiply(
          matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z)
        )
        m.multiply(matrix4.makeRotationFromQuaternion(quat))
        m.multiply(
          matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z)
        )
      }

      m.decompose(p, q, s)

      if (!zeroPivot) {
        for (var i = 0; i < this.objects.length; ++i) {
          this.objects[i].position.copy(p)
        }
      }

      for (var j = 0; j < this.objects.length; ++j) {
        this.objects[j].quaternion.copy(q)
        this.objects[j].updateMatrix()
      }
    }
  })()

  ObjectHandler.prototype.setObjects = function (objects) {
    this.objects = objects

    var _objects2 = _slicedToArray(objects, 1)

    this.object = _objects2[0]
  }

  ObjectHandler.prototype.rotate = (function () {
    var rot = {
      axis: new THREE__namespace.Vector3(),
      angle: 0.0
    }
    return function (quat, mousePrevPos, mouseCurPos, aboutAxis) {
      this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis)
      quat.setFromAxisAngle(rot.axis, rot.angle)

      if (rot.angle) {
        this._rotate(quat)
      }

      this.lastRotation = rot
    }
  })()

  ObjectHandler.prototype.translate = (function () {
    var dir = new THREE__namespace.Vector3()
    var pivot = new THREE__namespace.Vector3()
    return function (delta) {
      dir.set(
        delta.x / this.camera.projectionMatrix.elements[0],
        delta.y / this.camera.projectionMatrix.elements[5],
        0
      )
      var dist = dir.length()
      dir.normalize()
      dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert())
      pivot.copy(this.pivot)
      this.object.localToWorld(pivot)
      dist *= Math.abs(pivot.z - this.camera.position.z)
      dist /= this.object.matrixWorld.getMaxScaleOnAxis()

      for (var i = 0; i < this.objects.length; ++i) {
        this.objects[i].translateOnAxis(dir, dist)
      }
    }
  })()

  ObjectHandler.prototype.update = (function () {
    var axis = new THREE__namespace.Vector3()
    return function (timeSinceLastUpdate, timeSinceMove) {
      if (settings$1.now.autoRotation !== 0.0) {
        if (
          settings$1.now.autoRotationAxisFixed ||
          this.lastRotation.axis.length() === 0.0
        ) {
          axis
            .set(0, 1, 0)
            .transformDirection(matrix4.copy(this.object.matrixWorld).invert())
        } else {
          axis.copy(this.lastRotation.axis)
        }

        this._rotate(
          quaternion.setFromAxisAngle(
            axis,
            settings$1.now.autoRotation * timeSinceLastUpdate
          )
        )

        return true
      }

      if (this.options.intertia && this.lastRotation.angle) {
        var angle =
          this.lastRotation.angle *
          Math.pow(
            1.0 - this.options.dynamicDampingFactor,
            40.0 * timeSinceMove
          )

        if (Math.abs(angle) <= this.options.intertiaThreshold) {
          this.lastRotation.angle = 0.0
        } else {
          this._rotate(
            quaternion.setFromAxisAngle(this.lastRotation.axis, angle)
          )

          return true
        }
      }

      return false
    }
  })()

  ObjectHandler.prototype.stop = function () {
    this.lastRotation.angle = 0.0
  }

  ObjectHandler.prototype.mouse2rotation = (function () {
    var center = new THREE__namespace.Vector3()
    var eye = new THREE__namespace.Vector3()
    var eyeDirection = new THREE__namespace.Vector3()
    var cameraUpDirection = new THREE__namespace.Vector3()
    var cameraSidewaysDirection = new THREE__namespace.Vector3()
    var moveDirection = new THREE__namespace.Vector3()
    var mouseDelta = new THREE__namespace.Vector2()
    return function (rot, mousePrev, mouseCur, aboutAxis) {
      if (aboutAxis) {
        rot.axis.copy(this.axis)
        rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y)
      } else {
        mouseDelta.subVectors(mouseCur, mousePrev)
        var angle = mouseDelta.length()

        if (angle === 0.0) {
          return
        }

        center.copy(this.pivot)
        this.object.localToWorld(center)
        eye.subVectors(this.camera.position, center)
        eyeDirection.copy(eye).normalize()
        cameraUpDirection.copy(this.camera.up).normalize()
        cameraSidewaysDirection
          .crossVectors(cameraUpDirection, eyeDirection)
          .normalize()
        cameraUpDirection.setLength(mouseDelta.y)
        cameraSidewaysDirection.setLength(mouseDelta.x)
        moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection))
        rot.axis.crossVectors(moveDirection, eye)
        rot.angle = -angle * this.options.rotateFactor
      }

      rot.axis.transformDirection(
        matrix4.copy(this.object.matrixWorld).invert()
      )

      if (rot.angle < 0.0) {
        rot.axis.negate()
        rot.angle = -rot.angle
      }
    }
  })()

  function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
    EventDispatcher.call(this)
    var self = this
    this.object = object
    this.objectPivot = objectPivot
    this.camera = camera
    this.domElement = typeof domElement !== 'undefined' ? domElement : document
    this.getAltObj = getAltObj
    this.enabled = true
    this.hotkeysEnabled = true
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    }
    this.options = {
      rotateFactor: Math.PI,
      axisRotateFactor: 4 * Math.PI,
      intertia: true,
      dynamicDampingFactor: 0.1,
      intertiaThreshold: 1e-3
    }
    this._state = STATE.NONE
    this._mousePrevPos = new THREE__namespace.Vector2()
    this._mouseCurPos = new THREE__namespace.Vector2()
    this._mainObj = new ObjectHandler(
      [this.object],
      this.camera,
      new THREE__namespace.Vector3(0, 0, 0),
      this.options
    )
    this._altObj = new ObjectHandler(
      [this.object],
      this.camera,
      new THREE__namespace.Vector3(0, 0, 0),
      this.options
    )
    this._affectedObj = this._mainObj
    this._isAltObjFreeRotationAllowed = true
    this._isTranslationAllowed = true
    this._isKeysTranslatingObj = false
    this._pressedKeys = []
    this._clock = new Timer()

    this._clock.start()

    this._lastUpdateTime = this._clock.getElapsedTime()
    this._listeners = [
      {
        obj: self.domElement,
        type: 'mousedown',
        handler: function handler(e) {
          self.mousedown(e)
        }
      },
      {
        obj: self.domElement,
        type: 'mouseup',
        handler: function handler(e) {
          self.mouseup(e)
        }
      },
      {
        obj: self.domElement,
        type: 'mousemove',
        handler: function handler(e) {
          self.mousemove(e)
        }
      },
      {
        obj: self.domElement,
        type: 'mousewheel',
        handler: function handler(e) {
          self.mousewheel(e)
        }
      },
      {
        obj: self.domElement,
        type: 'DOMMouseScroll',
        handler: function handler(e) {
          self.mousewheel(e)
        }
      },
      {
        obj: self.domElement,
        type: 'mouseout',
        handler: function handler(e) {
          self.mouseup(e)
        }
      },
      {
        obj: self.domElement,
        type: 'touchstart',
        handler: function handler(e) {
          self.touchstartend(e)
        }
      },
      {
        obj: self.domElement,
        type: 'touchend',
        handler: function handler(e) {
          self.touchstartend(e)
        }
      },
      {
        obj: self.domElement,
        type: 'touchmove',
        handler: function handler(e) {
          self.touchmove(e)
        }
      },
      {
        obj: self.getKeyBindObject(),
        type: 'keydown',
        handler: function handler(e) {
          self.keydownup(e)
        }
      },
      {
        obj: self.getKeyBindObject(),
        type: 'keyup',
        handler: function handler(e) {
          self.keydownup(e)
        }
      },
      {
        obj: window,
        type: 'resize',
        handler: function handler() {
          self.handleResize()
        }
      },
      {
        obj: window,
        type: 'blur',
        handler: function handler() {
          self.resetKeys()
        }
      },
      {
        obj: self.domElement,
        type: 'contextmenu',
        handler: function handler(e) {
          self.contextmenu(e)
        }
      }
    ]

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i]
      l.obj.addEventListener(l.type, l.handler)
    }

    this.handleResize()
    this.resetKeys()
    this.update()
  }

  ObjectControls.prototype = Object.create(EventDispatcher.prototype)
  ObjectControls.prototype.constructor = ObjectControls

  ObjectControls.prototype.resetKeys = function () {
    this._pressedKeys[VK_LEFT] = false
    this._pressedKeys[VK_UP] = false
    this._pressedKeys[VK_RIGHT] = false
    this._pressedKeys[VK_DOWN] = false
  }

  ObjectControls.prototype.contextmenu = function (e) {
    e.stopPropagation()
    e.preventDefault()
  }

  ObjectControls.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0
      this.screen.top = 0
      this.screen.width = window.innerWidth
      this.screen.height = window.innerHeight
    } else {
      var box = this.domElement.getBoundingClientRect()
      var d = this.domElement.ownerDocument.documentElement
      this.screen.left = box.left + window.pageXOffset - d.clientLeft
      this.screen.top = box.top + window.pageYOffset - d.clientTop
      this.screen.width = box.width
      this.screen.height = box.height
    }
  }

  ObjectControls.prototype.enable = function (enable) {
    this.enabled = enable
  }

  ObjectControls.prototype.enableHotkeys = function (enable) {
    this.hotkeysEnabled = enable
  }

  ObjectControls.prototype.allowTranslation = function (allow) {
    this._isTranslationAllowed = allow
  }

  ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
    this._isAltObjFreeRotationAllowed = allow
  }

  ObjectControls.prototype.keysTranslateObj = function (on) {
    this._isKeysTranslatingObj = on
  }

  ObjectControls.prototype.isEditingAltObj = function () {
    return (
      (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) &&
      this._affectedObj === this._altObj
    )
  }

  ObjectControls.prototype.convertMouseToOnCircle = function (
    coords,
    pageX,
    pageY
  ) {
    var screenSize = Math.min(this.screen.width, this.screen.height)

    if (screenSize === 0) {
      coords.set(0, 0)
      return
    }

    coords.set(
      (pageX - this.screen.width * 0.5 - this.screen.left) / screenSize,
      (0.5 * this.screen.height + this.screen.top - pageY) / screenSize
    )
  }

  ObjectControls.prototype.convertMouseToViewport = function (
    coords,
    pageX,
    pageY
  ) {
    if (this.screen.width === 0 || this.screen.height === 0) {
      coords.set(0, 0)
      return
    }

    coords.set(
      (2.0 * (pageX - this.screen.width * 0.5 - this.screen.left)) /
        this.screen.width,
      (2.0 * (0.5 * this.screen.height + this.screen.top - pageY)) /
        this.screen.height
    )
  }

  ObjectControls.prototype.stop = function () {
    this._mainObj.stop()

    this._altObj.stop()
  }

  ObjectControls.prototype.rotateByMouse = (function () {
    var quat = new THREE__namespace.Quaternion()
    return function (aboutZAxis) {
      this._affectedObj.rotate(
        quat,
        this._mousePrevPos,
        this._mouseCurPos,
        aboutZAxis
      )

      this.dispatchEvent({
        type: 'change',
        action: 'rotate',
        quaternion: quat
      })
    }
  })()

  ObjectControls.prototype.rotate = function (quat) {
    this.object.quaternion.multiply(quat)
    this.dispatchEvent({
      type: 'change',
      action: 'rotate',
      quaternion: quat
    })
  }

  ObjectControls.prototype.getOrientation = function () {
    return this.object.quaternion
  }

  ObjectControls.prototype.setOrientation = function (quat) {
    this.object.quaternion.copy(quat)
  }

  ObjectControls.prototype.translate = (function () {
    var delta = new THREE__namespace.Vector2()
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos)

      this._affectedObj.translate(delta)

      this.dispatchEvent({
        type: 'change',
        action: 'translate'
      })
    }
  })()

  ObjectControls.prototype.getScale = function () {
    return this.object.scale.x
  }

  ObjectControls.prototype.setScale = function (scale) {
    this.object.scale.set(scale, scale, scale)
  }

  ObjectControls.prototype.scale = function (factor) {
    if (factor <= 0) {
      return
    }

    this.setScale(this.object.scale.x * factor)
    this.dispatchEvent({
      type: 'change',
      action: 'zoom',
      factor: factor
    })
  }

  ObjectControls.prototype.update = (function () {
    var shift = new THREE__namespace.Vector2()
    return function () {
      var curTime = this._clock.getElapsedTime()

      var timeSinceLastUpdate = curTime - this._lastUpdateTime

      if (this._state === STATE.NONE) {
        var timeSinceMove = curTime - this._lastMouseMoveTime

        if (
          this._mainObj.update(timeSinceLastUpdate, timeSinceMove) ||
          this._altObj.update(timeSinceLastUpdate, timeSinceMove)
        ) {
          this.dispatchEvent({
            type: 'change',
            action: 'auto'
          })
        }
      }

      if (this._isKeysTranslatingObj) {
        var speedX =
          Number(this._pressedKeys[VK_RIGHT]) -
          Number(this._pressedKeys[VK_LEFT])
        var speedY =
          Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN])

        if (speedX !== 0.0 || speedY !== 0.0) {
          var delta = timeSinceLastUpdate
          var altObj = this.getAltObj()

          if (altObj.objects.length > 0) {
            this._altObj.setObjects(altObj.objects)

            this._altObj.pivot = altObj.pivot

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone()
            } else {
              this._altObj.axis.set(0, 0, 1)
            }

            shift.set(delta * speedX, delta * speedY)

            this._altObj.translate(shift)

            this.dispatchEvent({
              type: 'change',
              action: 'translate'
            })
          }
        }
      }

      this._lastUpdateTime = curTime
    }
  })()

  ObjectControls.prototype.reset = function () {
    this._state = STATE.NONE
    this.object.quaternion.copy(quaternion.set(0, 0, 0, 1))
  }

  ObjectControls.prototype.mousedown = function (event) {
    if (this.enabled === false || this._state !== STATE.NONE) {
      return
    }

    event.preventDefault()
    event.stopPropagation()

    if (this._state === STATE.NONE) {
      if (event.button === 0) {
        this._affectedObj.stop()

        var workWithAltObj = false

        if (event.altKey) {
          var altObj = this.getAltObj()
          workWithAltObj = altObj.objects.length > 0

          if (workWithAltObj) {
            this._altObj.setObjects(altObj.objects)

            this._altObj.pivot = altObj.pivot

            if ('axis' in altObj) {
              this._altObj.axis = altObj.axis.clone()
            } else {
              this._altObj.axis.set(0, 0, 1)
            }
          }
        }

        this._affectedObj = workWithAltObj ? this._altObj : this._mainObj
        this._state =
          workWithAltObj && event.ctrlKey && this._isTranslationAllowed
            ? STATE.TRANSLATE
            : STATE.ROTATE
      } else if (event.button === 2) {
        this._state = STATE.TRANSLATE_PIVOT
      }
    }

    if (this._state === STATE.ROTATE) {
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY)

      this._mousePrevPos.copy(this._mouseCurPos)
    }

    if (
      this._state === STATE.TRANSLATE ||
      this._state === STATE.TRANSLATE_PIVOT
    ) {
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY)

      this._mousePrevPos.copy(this._mouseCurPos)
    }
  }

  ObjectControls.prototype.mousemove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return
    }

    event.preventDefault()
    event.stopPropagation()

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos)

        this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY)
        this.rotateByMouse(
          (event.altKey && !this._isAltObjFreeRotationAllowed) || event.shiftKey
        )
        this._lastMouseMoveTime = this._clock.getElapsedTime()
        break

      case STATE.TRANSLATE:
        this._mousePrevPos.copy(this._mouseCurPos)

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY)
        this.translate()
        break

      case STATE.TRANSLATE_PIVOT:
        this._mousePrevPos.copy(this._mouseCurPos)

        this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY)
        this.translatePivotByMouse()
        break
    }
  }

  ObjectControls.prototype.mousewheel = function (event) {
    if (
      this.enabled === false ||
      !settings$1.now.zooming ||
      this._state !== STATE.NONE ||
      event.shiftKey
    ) {
      return
    }

    event.preventDefault()
    var delta = 0

    if (event.wheelDelta) {
      delta = event.wheelDelta / 40
    } else if (event.detail) {
      delta = -event.detail / 3
    }

    var factor = 1.0 + delta * 0.05
    factor = Math.max(factor, 0.01)
    this.scale(factor)
  }

  ObjectControls.prototype.mouseup = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return
    }

    event.preventDefault()
    event.stopPropagation()
    this._state = STATE.NONE

    if (
      this._clock.getElapsedTime() - this._lastMouseMoveTime >
      FULL_STOP_THRESHOLD
    ) {
      this._affectedObj.stop()
    }
  }

  ObjectControls.prototype.touchstartend = function (event) {
    if (this.enabled === false) {
      return
    }

    event.preventDefault()
    event.stopPropagation()

    switch (event.touches.length) {
      case 1:
        this._state = STATE.ROTATE
        this.convertMouseToOnCircle(
          this._mouseCurPos,
          event.touches[0].pageX,
          event.touches[0].pageY
        )

        this._mousePrevPos.copy(this._mouseCurPos)

        break

      case 2: {
        this._mainObj.stop()

        this._altObj.stop()

        this._state = STATE.SCALE
        var dx = event.touches[0].pageX - event.touches[1].pageX
        var dy = event.touches[0].pageY - event.touches[1].pageY
        this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(
          dx * dx + dy * dy
        )
        this._scaleStart = this.object.scale.x
        break
      }

      default:
        this._state = STATE.NONE
    }
  }

  ObjectControls.prototype.touchmove = function (event) {
    if (this.enabled === false || this._state === STATE.NONE) {
      return
    }

    event.preventDefault()
    event.stopPropagation()

    switch (this._state) {
      case STATE.ROTATE:
        this._mousePrevPos.copy(this._mouseCurPos)

        this.convertMouseToOnCircle(
          this._mouseCurPos,
          event.touches[0].pageX,
          event.touches[0].pageY
        )
        this.rotateByMouse(false)
        this._lastMouseMoveTime = this._clock.getElapsedTime()
        break

      case STATE.SCALE:
        if (settings$1.now.zooming) {
          var dx = event.touches[0].pageX - event.touches[1].pageX
          var dy = event.touches[0].pageY - event.touches[1].pageY
          this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy)
          var newScale =
            (this._scaleStart * this._touchDistanceCur) /
            this._touchDistanceStart
          var factor = newScale / this.object.scale.x
          this.scale(factor)
        }

        break
    }
  }

  ObjectControls.prototype.keydownup = function (event) {
    if (this.enabled === false || this.hotkeysEnabled === false) {
      return
    }

    switch (event.keyCode) {
      case VK_LEFT:
      case VK_UP:
      case VK_RIGHT:
      case VK_DOWN:
        this._pressedKeys[event.keyCode] = event.type === 'keydown'
        event.preventDefault()
        event.stopPropagation()
        break
    }
  }

  ObjectControls.prototype.getKeyBindObject = function () {
    return window.top
  }

  ObjectControls.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i]
      l.obj.removeEventListener(l.type, l.handler)
    }
  }

  ObjectControls.prototype.translatePivotByMouse = (function () {
    var delta = new THREE__namespace.Vector2()
    return function () {
      delta.subVectors(this._mouseCurPos, this._mousePrevPos)
      this.translatePivotInWorld(
        settings$1.now.translationSpeed * delta.x,
        settings$1.now.translationSpeed * delta.y,
        0
      )
    }
  })()

  ObjectControls.prototype.translatePivotInWorld = function (x, y, z) {
    var pos = this.objectPivot.position
    pos.applyMatrix4(this.object.matrixWorld)
    pos.setX(pos.x + x)
    pos.setY(pos.y + y)
    pos.setZ(pos.z + z)
    pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert())
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    })
  }

  ObjectControls.prototype.translatePivot = function (x, y, z) {
    var pos = this.objectPivot.position
    pos.setX(pos.x + x)
    pos.setY(pos.y + y)
    pos.setZ(pos.z + z)
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    })
  }

  ObjectControls.prototype.setPivot = function (newPivot) {
    this.objectPivot.position.copy(newPivot)
    this.dispatchEvent({
      type: 'change',
      action: 'translatePivot'
    })
  }

  function Picker(gfxObj, camera, domElement) {
    EventDispatcher.call(this)
    var self = this
    this.gfxObj = gfxObj
    this.camera = camera
    this.domElement = typeof domElement !== 'undefined' ? domElement : document
    this.screen = {
      left: 0,
      top: 0,
      width: 0,
      height: 0
    }
    this._lastMousePos = new THREE__namespace.Vector2(0, 0)
    this._mouseTotalDist = 0.0
    this._lastClickBeginTime = -1000.0
    this._lastClickPos = new THREE__namespace.Vector2(0, 0)
    this._clickBeginTime = 0.0
    this._clock = new Timer()

    this._clock.start()

    this._listeners = [
      {
        obj: self.domElement,
        type: 'mousedown',
        handler: function handler(e) {
          self.mousedown(e)
        }
      },
      {
        obj: self.domElement,
        type: 'mouseup',
        handler: function handler(e) {
          self.mouseup(e)
        }
      },
      {
        obj: self.domElement,
        type: 'mousemove',
        handler: function handler(e) {
          self.mousemove(e)
        }
      },
      {
        obj: self.domElement,
        type: 'touchstart',
        handler: function handler(e) {
          self.touchstart(e)
        }
      },
      {
        obj: self.domElement,
        type: 'touchend',
        handler: function handler(e) {
          self.touchend(e)
        }
      },
      {
        obj: window,
        type: 'resize',
        handler: function handler() {
          self.handleResize()
        }
      }
    ]

    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i]
      l.obj.addEventListener(l.type, l.handler)
    }

    this.handleResize()
  }

  Picker.prototype = Object.create(EventDispatcher.prototype)
  Picker.prototype.constructor = Picker

  Picker.prototype.reset = function () {
    this.picked = {}
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    })
  }

  Picker.prototype.handleResize = function () {
    if (this.domElement === document) {
      this.screen.left = 0
      this.screen.top = 0
      this.screen.width = window.innerWidth
      this.screen.height = window.innerHeight
    } else {
      var box = this.domElement.getBoundingClientRect()
      var d = this.domElement.ownerDocument.documentElement
      this.screen.left = box.left + window.pageXOffset - d.clientLeft
      this.screen.top = box.top + window.pageYOffset - d.clientTop
      this.screen.width = box.width
      this.screen.height = box.height
    }
  }

  Picker.prototype.pickObject = function (screenPos) {
    if (!this.gfxObj) {
      this.picked = {}
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      })
      return
    }

    var gfxObj = this.gfxObj
    var rayCaster = new THREE__namespace.Raycaster()
    rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld)
    rayCaster.ray.direction
      .set(screenPos.x, screenPos.y, 0.5)
      .unproject(this.camera)
      .sub(rayCaster.ray.origin)
      .normalize()
    var clipPlane =
      settings$1.now.draft.clipPlane && this.clipPlaneValue
        ? this.clipPlaneValue
        : Infinity
    var fogFarPlane =
      settings$1.now.fog && this.fogFarValue ? this.fogFarValue : Infinity
    var point = rayCaster.intersectVisibleObject(
      gfxObj,
      this.camera,
      clipPlane,
      fogFarPlane
    )

    if (!point) {
      this.picked = {}
      this.dispatchEvent({
        type: 'newpick',
        obj: {}
      })
      return
    }

    var picked = {}

    if (point.residue || point.atom) {
      var residue = point.residue || point.atom.residue

      if (settings$1.now.pick === 'chain') {
        picked = {
          chain: residue.getChain()
        }
      } else if (settings$1.now.pick === 'molecule') {
        picked = {
          molecule: residue.getMolecule()
        }
      } else if (point.residue || settings$1.now.pick === 'residue') {
        picked = {
          residue: residue
        }
      } else if (point.atom) {
        picked = {
          atom: point.atom
        }
      }
    }

    this.picked = picked
    this.dispatchEvent({
      type: 'newpick',
      obj: picked
    })
  }

  Picker.prototype.getMouseInViewport = function (pageX, pageY) {
    return new THREE__namespace.Vector2(
      ((pageX - this.screen.left) / this.screen.width) * 2 - 1,
      (-(pageY - this.screen.top) / this.screen.height) * 2 + 1
    )
  }

  Picker.prototype.mousedown = function (event) {
    event.preventDefault()
    event.stopPropagation()

    if (event.button === 0) {
      this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY)
      this._mouseTotalDist = 0.0
      this._clickBeginTime = this._clock.getElapsedTime()
    }
  }

  Picker.prototype.mousemove = function (event) {
    event.preventDefault()
    event.stopPropagation()
    var pos = this.getMouseInViewport(event.pageX, event.pageY)
    this._mouseTotalDist += pos.sub(this._lastMousePos).length()
  }

  Picker.prototype.mouseup = function (event) {
    var self = this
    event.preventDefault()
    event.stopPropagation()

    if (event.button === 0) {
      if (this._mouseTotalDist < 0.01) {
        var curTime = this._clock.getElapsedTime()

        var curPos = this.getMouseInViewport(event.pageX, event.pageY)
        var timeSinceLastClickBegin = curTime - this._lastClickBeginTime

        if (timeSinceLastClickBegin < 0.7) {
          var clickDist = new THREE__namespace.Vector2().subVectors(
            curPos,
            this._lastClickPos
          )

          if (clickDist.length() < 0.01) {
            this.dispatchEvent({
              type: 'dblclick',
              obj: this.picked
            })
            this._lastClickPos = curPos
            this._lastClickBeginTime = -1000
            return
          }
        }

        setTimeout(function () {
          self.pickObject(curPos)
        }, 0)
        this._lastClickPos = curPos
        this._lastClickBeginTime = this._clickBeginTime
      }
    }
  }

  Picker.prototype.touchstart = function (event) {
    event.preventDefault()
    event.stopPropagation()

    if (event.touches.length === 1) {
      this._lastTouchdownPos = this.getMouseInViewport(
        event.touches[0].pageX,
        event.touches[0].pageY
      )
    }
  }

  Picker.prototype.touchend = function (event) {
    var self = this
    event.preventDefault()
    event.stopPropagation()

    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var pos = this.getMouseInViewport(
        event.changedTouches[0].pageX,
        event.changedTouches[0].pageY
      )
      var dist = pos.sub(this._lastTouchdownPos).length()

      if (dist < 0.01) {
        setTimeout(function () {
          self.pickObject(self._lastTouchdownPos)
        }, 0)
      }
    }
  }

  Picker.prototype.dispose = function () {
    for (var i = 0; i < this._listeners.length; i++) {
      var l = this._listeners[i]
      l.obj.removeEventListener(l.type, l.handler)
    }
  }

  var Axes = /*#__PURE__*/ (function () {
    function Axes(target, targetCamera) {
      _classCallCheck(this, Axes)

      this._target = target
      this._targetCamera = targetCamera
      this._camera = new THREE__namespace.PerspectiveCamera(
        targetCamera.fov,
        targetCamera.aspect,
        1,
        100
      )
      this._object = new THREE__namespace.AxesHelper(1)
      this._scene = new THREE__namespace.Scene()

      this._scene.add(this._object)

      this._full = new THREE__namespace.Vector2()

      this._update()
    }

    _createClass(Axes, [
      {
        key: '_update',
        value: function _update() {
          var fov = this._targetCamera.fov
          var camera = this._camera
          camera.aspect = this._targetCamera.aspect
          camera.setMinimalFov(fov)
          camera.setDistanceToFit(1.0, fov)
          camera.updateProjectionMatrix()

          this._object.quaternion.copy(this._target.quaternion)
        }
      },
      {
        key: 'render',
        value: function render(renderer) {
          this._update()

          renderer.getSize(this._full)
          var width = this._full.width * 0.25
          var height = this._full.height * 0.25
          var autoClear = renderer.autoClear
          renderer.autoClear = false
          renderer.setViewport(0.0, 0.0, width, height)
          renderer.clear(false, true, false)
          renderer.render(this._scene, this._camera)
          renderer.setViewport(0, 0, this._full.width, this._full.height)
          renderer.autoClear = autoClear
        }
      }
    ])

    return Axes
  })()

  var cDataOffset = 12
  var cFirstMask = 0x0fffff00
  var cFirstShift = 8
  var cSecMask1 = 0x000000ff
  var cSecShift1 = 12
  var cSecMask2 = 0xfff00000
  var cSecShift2 = 20
  var cThirdMask = 0x000fffff
  var cStrMask = 0xf0000000
  var cStrShift = 28
  var c219 = 1 << 19
  var c220 = 1 << 20
  var cHelixIdx = 1
  var cSheetIdx = 2
  var secTypes = ['helix', 'strand']
  var cSecNames = ['fs', 'ps', 'ns', 'us']

  function _createSecondary(strArray, complex) {
    var residues = complex._residues
    var nRes = residues.length
    var resid = new Uint8Array(nRes)
    var atoms = complex._atoms

    for (var i = 0, n = strArray.length; i < n; ++i) {
      var atom = atoms[i]
      resid[atom.residue._index] = strArray[i]
    }

    var secondary = []
    var rIdx = 0

    while (rIdx < nRes) {
      if (resid[rIdx] !== 0) {
        var start = rIdx
        var val = resid[rIdx]

        while (
          rIdx < nRes - 1 &&
          resid[rIdx + 1] === val &&
          residues[rIdx].isConnected(residues[rIdx + 1])
        ) {
          ++rIdx
        }

        secondary.push({
          start: start,
          end: rIdx,
          type: secTypes[val - 1]
        })
      }

      ++rIdx
    }

    return secondary
  }

  function fromUInt20ToInt20(uint20) {
    return uint20 >= c219 ? uint20 - c220 : uint20
  }

  var FrameInfo = /*#__PURE__*/ (function () {
    function FrameInfo(complex, payload, callbacks) {
      _classCallCheck(this, FrameInfo)

      this._complex = complex
      this._secondary = null
      this.isLoading = false
      this._framesRange = {
        start: 0,
        end: -1
      }
      this.frameIsReady = false
      this._buffer = null
      this._frameRequest = null
      this._callbacks = callbacks

      if (typeof payload === 'function') {
        this._framesRequestLength = 1
        this._downloadDataFn = payload
      } else {
        this.parseBinaryData(payload, true)
      }

      this.reset()
      this.setFrame(0)
    }

    _createClass(FrameInfo, [
      {
        key: '_prepareBuffer',
        value: function _prepareBuffer(framesStart, framesEnd) {
          if (framesStart === undefined || framesStart === null) {
            framesStart = 0
          }

          if (framesEnd === undefined || framesEnd === null) {
            framesEnd = framesStart + this._framesRequestLength
          }

          if (this._framesCount !== undefined) {
            framesEnd = Math.min(this._framesCount - 1, framesEnd)
          }

          if (this._downloadDataFn) {
            var self = this

            var onDone = function onDone(data) {
              self.isLoading = false

              if (
                self._callbacks &&
                typeof self._callbacks.onLoadStatusChanged === 'function'
              ) {
                self._callbacks.onLoadStatusChanged()
              }

              self._buffer = {
                data: data,
                state: 'ready',
                start: framesStart,
                end: framesEnd
              }

              if (self._frameRequest !== null) {
                var idx = self._frameRequest
                self._frameRequest = null
                self.setFrame(idx)
              }
            }

            var onFail = function onFail() {
              self.isLoading = false

              if (
                self._callbacks &&
                typeof self._callbacks.onError === 'function'
              ) {
                self._callbacks.onError('Streaming failed')
              }
            }

            if (!this._buffer) {
              this._buffer = {}
            }

            this._buffer.state = 'downloading'
            this.isLoading = true

            if (
              self._callbacks &&
              typeof self._callbacks.onLoadStatusChanged === 'function'
            ) {
              self._callbacks.onLoadStatusChanged()
            }

            this._downloadDataFn(
              {
                start: framesStart,
                end: framesEnd + 1
              },
              onDone,
              onFail
            )
          }
        }
      },
      {
        key: '_parseBuffer',
        value: function _parseBuffer() {
          if (this._buffer && this._buffer.state === 'ready') {
            this._framesRange = {
              start: this._buffer.start,
              end: this._buffer.end
            }
            this.parseBinaryData(this._buffer.data, false)

            var _bufferRequestStart = (this._buffer.end + 1) % this._framesCount

            if (_bufferRequestStart >= this._framesCount) {
              _bufferRequestStart = 0
            }

            this._buffer = {
              state: 'none'
            }

            this._prepareBuffer(
              _bufferRequestStart,
              _bufferRequestStart + this._framesRequestLength
            )

            if (this._frameRequest !== null) {
              var idx = this._frameRequest
              this._frameRequest = null
              this.setFrame(idx)
            }
          }
        }
      },
      {
        key: 'parseBinaryData',
        value: function parseBinaryData(arrayBuffer) {
          var dataView = new DataView(arrayBuffer)
          var offset = 0
          var atomsCount = dataView.getUint32(offset, true)
          offset += 4
          var framesCount = dataView.getUint32(offset, true)
          this._framesCount = framesCount
          this._framesRange.end =
            this._framesRange.end > 0
              ? Math.min(this._framesRange.end, framesCount - 1)
              : framesCount - 1
          offset += 4
          this._atomsCount = atomsCount
          var maxSize = 1024 * 1024
          this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8))
          var chunkedFramesCount =
            this._framesRange.end - this._framesRange.start + 1

          if (
            atomsCount !== this._complex._atoms.length ||
            arrayBuffer.byteLength !==
              cDataOffset + chunkedFramesCount * atomsCount * 8
          ) {
            throw new Error()
          }

          var complex = this._complex
          var timeStep = dataView.getUint32(offset, true)
          var iName = 0

          while (timeStep > 1000 && iName < cSecNames.length - 1) {
            timeStep /= 1000
            ++iName
          }

          this._timeStep = ''
            .concat(timeStep.toString(), ' ')
            .concat(cSecNames[iName])
          offset += 4
          var secondary = []
          var posData = new Float32Array(chunkedFramesCount * atomsCount * 3)
          var coordIdx = 0
          var secondaryArr = new Int8Array(atomsCount)

          for (var j = 0; j < chunkedFramesCount; ++j) {
            for (var i = 0; i < atomsCount; ++i) {
              var hiWord = dataView.getUint32(offset, true)
              offset += 4
              var loWord = dataView.getUint32(offset, true)
              offset += 4
              var str = (loWord & cStrMask) >>> cStrShift
              var x = fromUInt20ToInt20(
                ((loWord & cFirstMask) >>> cFirstShift) >> 0
              )
              var y = fromUInt20ToInt20(
                (((loWord & cSecMask1) << cSecShift1) |
                  ((hiWord & cSecMask2) >>> cSecShift2)) >>
                  0
              )
              var z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0)
              secondaryArr[i] = 0

              if (str > 0 && str < 4) {
                secondaryArr[i] = cHelixIdx
              } else if (str === 4) {
                secondaryArr[i] = cSheetIdx
              }

              posData[coordIdx++] = x / 100
              posData[coordIdx++] = y / 100
              posData[coordIdx++] = z / 100
            }

            secondary.push(_createSecondary(secondaryArr, complex))
          }

          this._secondaryData = secondary
          this._data = posData
        }
      },
      {
        key: 'nextFrame',
        value: function nextFrame() {
          this.setFrame((this._currFrame + 1) % this._framesCount)
        }
      },
      {
        key: 'needsColorUpdate',
        value: function needsColorUpdate(colorer) {
          return colorer instanceof SecondaryStructureColorer
        }
      },
      {
        key: 'getAtomColor',
        value: function getAtomColor(colorer, atom) {
          return colorer.getResidueColor(
            this._residues[atom.residue._index],
            this._complex
          )
        }
      },
      {
        key: 'getResidueColor',
        value: function getResidueColor(colorer, residue) {
          return colorer.getResidueColor(
            this._residues[residue._index],
            this._complex
          )
        }
      },
      {
        key: '_updateSecondary',
        value: function _updateSecondary() {
          var i
          var myResidues = this._residues
          var n = myResidues.length

          for (i = 0; i < n; ++i) {
            myResidues[i]._secondary = null
          }

          var sec =
            this._secondaryData[this._currFrame - this._framesRange.start]

          for (i = 0, n = sec.length; i < n; ++i) {
            var oldSec = sec[i]
            var start = oldSec.start,
              end = oldSec.end
            var nSec = {
              _start: myResidues[start],
              _end: myResidues[end],
              type: oldSec.type,
              generic: oldSec.generic
            }

            for (var j = start; j <= end; ++j) {
              myResidues[j]._secondary = nSec
            }
          }
        }
      },
      {
        key: 'reset',
        value: function reset() {
          var compRes = this._complex._residues
          var n = compRes.length
          this._residues = new Array(n)
          var myResidues = this._residues

          var getSec = function getSec() {
            return this._secondary
          }

          for (var i = 0; i < n; ++i) {
            myResidues[i] = {
              _type: compRes[i]._type,
              _isValid: compRes[i]._isValid,
              _controlPoint: null,
              _wingVector: null,
              _secondary: null,
              getSecondary: getSec
            }
          }
        }
      },
      {
        key: 'setFrame',
        value: function setFrame(frameIdx) {
          this.frameIsReady = false

          if (
            frameIdx >= this._framesRange.start &&
            frameIdx <= this._framesRange.end
          ) {
            this._currFrame = frameIdx
            this._cachedResidues = false

            this._updateSecondary()

            this.frameIsReady = true
          } else {
            this._frameRequest = frameIdx

            if (!this._buffer) {
              this._prepareBuffer(frameIdx)
            } else {
              var self = this

              switch (this._buffer.state) {
                case 'none':
                  this._prepareBuffer(frameIdx)

                  break

                case 'ready':
                  self._parseBuffer()

                  break
              }
            }
          }
        }
      },
      {
        key: 'disableEvents',
        value: function disableEvents() {
          this._callbacks = null
        }
      },
      {
        key: 'getAtomPos',
        value: function getAtomPos(atomIdx) {
          var vec = FrameInfo._vec
          var self = this
          var data = self._data
          var idx =
            (self._atomsCount * (self._currFrame - self._framesRange.start) +
              atomIdx) *
            3
          vec.set(data[idx], data[idx + 1], data[idx + 2])
          return vec
        }
      },
      {
        key: 'getResidues',
        value: function getResidues() {
          if (this._cachedResidues) {
            return this._residues
          }

          this._complex.updateToFrame(this)

          return this._residues
        }
      }
    ])

    return FrameInfo
  })()

  _defineProperty(FrameInfo, '_vec', new THREE__namespace.Vector3())

  var SceneObject = /*#__PURE__*/ (function () {
    function SceneObject(params, opts) {
      _classCallCheck(this, SceneObject)

      if (this.constructor === SceneObject) {
        throw new Error('Can not instantiate abstract class!')
      }

      this.params = params
      this.opts = ___default['default'].merge(
        utils.deriveDeep(settings$1.now.objects[this.type], true),
        opts
      )
      this.needsRebuild = false
      this._mesh = null
      this.id = null
    }

    _createClass(SceneObject, [
      {
        key: 'identify',
        value: function identify() {
          var result = {
            type: this.type,
            params: this.params
          }
          var diff = utils.objectsDiff(this.opts, settings$1.now.modes[this.id])

          if (!___default['default'].isEmpty(diff)) {
            result.opts = diff
          }

          return result
        }
      },
      {
        key: 'toString',
        value: function toString() {
          var paramsStr = 'o='
            .concat(this.type, ',')
            .concat(this.params.join(','))
          var optsStr = utils.compareOptionsWithDefaults(
            this.opts,
            settings$1.defaults.objects[this.type]
          )
          return paramsStr + optsStr
        }
      },
      {
        key: 'getGeometry',
        value: function getGeometry() {
          return this._mesh
        }
      },
      {
        key: 'destroy',
        value: function destroy() {
          if (this._mesh) {
            gfxutils.destroyObject(this._mesh)
          }
        }
      }
    ])

    return SceneObject
  })()

  SceneObject.prototype.type = '__'

  function _createSuper$6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$6()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$6() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var LinesObj = /*#__PURE__*/ (function (_SceneObject) {
    _inherits(LinesObj, _SceneObject)

    var _super = _createSuper$6(LinesObj)

    function LinesObj(params, opts) {
      var _this

      _classCallCheck(this, LinesObj)

      _this = _super.call(this, params, opts)

      if (params.length < 2) {
        throw new Error('Wrong number of argumets on line object creation!')
      }

      var _params = _slicedToArray(params, 2)

      _this._id1 = _params[0]
      _this._id2 = _params[1]
      return _this
    }

    _createClass(LinesObj, [
      {
        key: '_getAtomFromName',
        value: function _getAtomFromName(complex, atomId) {
          var err =
            " - Wrong atom format it must be '#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME' (e.g. 'A.38.CO1')"
          var atom1 = complex.getAtomByFullname(atomId)

          if (!atom1) {
            throw new Error(atomId + err)
          }

          return atom1
        }
      },
      {
        key: 'build',
        value: function build(complex) {
          var geom = new THREE__namespace.BufferGeometry()
          this._atom1 = this._getAtomFromName(complex, this._id1)
          this._atom2 = this._getAtomFromName(complex, this._id2)
          var p1 = this._atom1.position
          var p2 = this._atom2.position
          var vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z])
          geom.setAttribute(
            'position',
            new THREE__namespace.BufferAttribute(vertices, 3)
          )
          geom.computeBoundingBox()
          var material = new UberMaterial()
          material.setValues({
            lights: false,
            overrideColor: true,
            dashedLine: true,
            fogTransparent: settings$1.now.bg.transparent
          })
          this._line = new meshes.Line(geom, material)

          this._line.computeLineDistances()

          this._line.material.setUberOptions({
            fixedColor: new THREE__namespace.Color(this.opts.color),
            dashedLineSize: this.opts.dashSize,
            dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
          })

          this._line.material.updateUniforms()

          this._line.raycast = function (_raycaster, _intersects) {}

          this._mesh = this._line
          var transforms = complex.getTransforms()

          if (transforms.length > 0) {
            this._mesh = new THREE__namespace.Group()

            this._mesh.add(this._line)

            meshutils.applyTransformsToMeshes(this._mesh, transforms)
          }
        }
      },
      {
        key: 'updateToFrame',
        value: function updateToFrame(frameData) {
          if (!this._atom1 || !this._atom2 || !this._line) {
            return
          }

          var geo = this._line.geometry
          geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index))
          geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index))

          this._line.computeLineDistances()

          geo.computeBoundingSphere()
          geo.verticesNeedUpdate = true
        }
      }
    ])

    return LinesObj
  })(SceneObject)

  LinesObj.prototype.constructor = LinesObj
  LinesObj.prototype.type = 'line'

  var fragmentShader$5 =
    'precision highp float;\r\n\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nuniform vec2 thickness;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = thickness / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n'

  function _createSuper$5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$5()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$5() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var OutlineMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(OutlineMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$5(OutlineMaterial)

    function OutlineMaterial(params) {
      var _this

      _classCallCheck(this, OutlineMaterial)

      _this = _super.call(this, params)
      var settings = {
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcDepthTex: {
            type: 't',
            value: null
          },
          srcTexSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(512, 512)
          },
          color: {
            type: 'v3',
            value: null
          },
          threshold: {
            type: 'f',
            value: null
          },
          opacity: {
            type: 'f',
            value: 1.0
          },
          thickness: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1, 1)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$5,
        transparent: true,
        depthTest: false,
        depthWrite: false
      }

      _this.setValues(settings)

      return _this
    }

    _createClass(OutlineMaterial, [
      {
        key: 'copy',
        value: function copy(source) {
          _get(_getPrototypeOf(OutlineMaterial.prototype), 'copy', this).call(
            this,
            source
          )

          this.depth = source.depth
        }
      },
      {
        key: 'setValues',
        value: function setValues(values) {
          if (typeof values === 'undefined') {
            return
          }

          _get(
            _getPrototypeOf(OutlineMaterial.prototype),
            'setValues',
            this
          ).call(this, values)

          var defines = {}

          if (this.depth) {
            defines.DEPTH_OUTLINE = 1
          }

          this.defines = defines
        }
      }
    ])

    return OutlineMaterial
  })(THREE__namespace.RawShaderMaterial)

  OutlineMaterial.prototype.depth = false

  var fragmentShader$4 =
    "precision highp float;\r\n\r\n// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r\n  // visibly, thus we decided to leave calculation here for better readability.\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n"

  function _createSuper$4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$4()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$4() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var FXAAMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(FXAAMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$4(FXAAMaterial)

    function FXAAMaterial(params) {
      var _this

      _classCallCheck(this, FXAAMaterial)

      _this = _super.call(this, params)

      _this.setValues({
        uniforms: {
          srcTex: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          bgColor: {
            type: 'c',
            value: new THREE__namespace.Color(0xffffff)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$4,
        transparent: false,
        depthTest: false,
        depthWrite: false
      })

      _this.setValues(params)

      return _this
    }

    _createClass(FXAAMaterial, [
      {
        key: 'copy',
        value: function copy(source) {
          _get(_getPrototypeOf(FXAAMaterial.prototype), 'copy', this).call(
            this,
            source
          )

          this.depth = source.depth
        }
      },
      {
        key: 'setValues',
        value: function setValues(values) {
          if (typeof values === 'undefined') {
            return
          }

          _get(_getPrototypeOf(FXAAMaterial.prototype), 'setValues', this).call(
            this,
            values
          )

          var defines = {}

          if (this.bgTransparent) {
            defines.BG_TRANSPARENT = 1
          }

          this.defines = defines
        }
      }
    ])

    return FXAAMaterial
  })(THREE__namespace.RawShaderMaterial)

  FXAAMaterial.prototype.bgTransparent = false

  var fragmentShader$3 =
    "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 32\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  vec4 normalData = texture2D(normalTexture, vUv);\r\n  // return for background fragments (their normals are zero vectors)\r\n  if (length(normalData.rgb) < EPSILON) {\r\n    // 0.0 in alpha component means that it is background fragment\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r\n  // normalData.a store 1.0 if normal was build for frontfaced surface\r\n  // and 0.0 in other case\r\n  if (normalData.a < EPSILON) {\r\n    normal *= -1.0;\r\n  }\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n"

  function _createSuper$3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$3()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$3() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var _samplesKernel = [
    new THREE__namespace.Vector3(0.295184, 0.077723, 0.068429),
    new THREE__namespace.Vector3(-0.271976, -0.365221, 0.838363),
    new THREE__namespace.Vector3(0.547713, 0.467576, 0.488515),
    new THREE__namespace.Vector3(0.662808, -0.031733, 0.584758),
    new THREE__namespace.Vector3(-0.025717, 0.218955, 0.657094),
    new THREE__namespace.Vector3(-0.310153, -0.365223, 0.370701),
    new THREE__namespace.Vector3(-0.101407, -0.006313, 0.747665),
    new THREE__namespace.Vector3(-0.769138, 0.360399, 0.086847),
    new THREE__namespace.Vector3(-0.271988, -0.27514, 0.905353),
    new THREE__namespace.Vector3(0.09674, -0.566901, 0.700151),
    new THREE__namespace.Vector3(0.562872, -0.735136, 0.094647),
    new THREE__namespace.Vector3(0.379877, 0.359278, 0.190061),
    new THREE__namespace.Vector3(0.519064, -0.023055, 0.405068),
    new THREE__namespace.Vector3(-0.301036, 0.114696, 0.088885),
    new THREE__namespace.Vector3(-0.282922, 0.598305, 0.487214),
    new THREE__namespace.Vector3(-0.181859, 0.25167, 0.679702),
    new THREE__namespace.Vector3(-0.191463, -0.635818, 0.512919),
    new THREE__namespace.Vector3(-0.293655, 0.427423, 0.078921),
    new THREE__namespace.Vector3(-0.267983, 0.680534, 0.13288),
    new THREE__namespace.Vector3(0.139611, 0.319637, 0.477439),
    new THREE__namespace.Vector3(-0.352086, 0.31104, 0.653913),
    new THREE__namespace.Vector3(0.321032, 0.805279, 0.487345),
    new THREE__namespace.Vector3(0.073516, 0.820734, 0.414183),
    new THREE__namespace.Vector3(-0.155324, 0.589983, 0.41146),
    new THREE__namespace.Vector3(0.335976, 0.170782, 0.527627),
    new THREE__namespace.Vector3(0.46346, -0.355658, 0.167689),
    new THREE__namespace.Vector3(0.222654, 0.59655, 0.769406),
    new THREE__namespace.Vector3(0.922138, -0.04207, 0.147555),
    new THREE__namespace.Vector3(-0.72705, -0.329192, 0.369826),
    new THREE__namespace.Vector3(-0.090731, 0.53382, 0.463767),
    new THREE__namespace.Vector3(-0.323457, -0.876559, 0.238524),
    new THREE__namespace.Vector3(-0.663277, -0.372384, 0.342856)
  ]

  var AOMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(AOMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$3(AOMaterial)

    function AOMaterial() {
      var _this

      _classCallCheck(this, AOMaterial)

      _this = _super.call(this)

      _this.setValues({
        uniforms: {
          noiseTexture: {
            type: 't',
            value: noise.noiseTexture
          },
          noiseTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(
              1.0 / noise.noiseWidth,
              1.0 / noise.noiseHeight
            )
          },
          diffuseTexture: {
            type: 't',
            value: null
          },
          normalTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          camNearFar: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0, 10.0)
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE__namespace.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          samplesKernel: {
            type: 'v3v',
            value: _samplesKernel
          },
          kernelRadius: {
            type: 'f',
            value: 1.0
          },
          depthThreshold: {
            type: 'f',
            value: 1.0
          },
          factor: {
            type: 'f',
            value: 1.0
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$3,
        transparent: false,
        depthTest: false,
        depthWrite: false
      })

      return _this
    }

    return _createClass(AOMaterial)
  })(THREE__namespace.RawShaderMaterial)

  var fragmentShader$2 =
    'precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = res;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb = res.rgb / weightSum;\r\n  gl_FragColor = res;\r\n}\r\n'

  function _createSuper$2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$2()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$2() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var _kernelOffsets$1 = [-2.0, -1.0, 0.0, 1.0, 2.0]

  var AOHorBlurMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(AOHorBlurMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$2(AOHorBlurMaterial)

    function AOHorBlurMaterial() {
      var _this

      _classCallCheck(this, AOHorBlurMaterial)

      _this = _super.call(this)

      _this.setValues({
        uniforms: {
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets$1
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$2,
        transparent: false,
        depthTest: false,
        depthWrite: false
      })

      return _this
    }

    return _createClass(AOHorBlurMaterial)
  })(THREE__namespace.RawShaderMaterial)

  var fragmentShader$1 =
    "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nuniform mat4  projMatrix;\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\n#ifdef USE_FOG\r\n  uniform vec2 fogNearFar;\r\n  uniform vec4 fogColor;\r\n#endif\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n  projPos.y * tanHalfFOV * abs(viewPos.z)\r\n  );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = color;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb /= weightSum;\r\n\r\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r\n    // Add fog to the result value\r\n    // Proper way to get an image with fog and ao requires formula:\r\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r\n    // We have:  AO, fogFactor, fogColor,\r\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r\n    //                                                                where molecule has been already drawn with fog)\r\n    // Transform:\r\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\r\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r\n  #else\r\n    gl_FragColor.rgb = color.rgb * res.rgb;\r\n  #endif\r\n  gl_FragColor.a = color.a;\r\n}\r\n"

  function _createSuper$1(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }
  var _kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0]

  var AOVertBlurWithBlendMaterial = /*#__PURE__*/ (function (
    _THREE$RawShaderMater
  ) {
    _inherits(AOVertBlurWithBlendMaterial, _THREE$RawShaderMater)

    var _super = _createSuper$1(AOVertBlurWithBlendMaterial)

    function AOVertBlurWithBlendMaterial(params) {
      var _this

      _classCallCheck(this, AOVertBlurWithBlendMaterial)

      _this = _super.call(this, params)

      _this.setValues({
        uniforms: {
          diffuseTexture: {
            type: 't',
            value: null
          },
          depthTexture: {
            type: 't',
            value: null
          },
          srcTexelSize: {
            type: 'v2',
            value: new THREE__namespace.Vector2(1.0 / 512.0, 1.0 / 512.0)
          },
          aoMap: {
            type: 't',
            value: null
          },
          samplesOffsets: {
            type: 'fv1',
            value: _kernelOffsets
          },
          projMatrix: {
            type: 'mat4',
            value: new THREE__namespace.Matrix4()
          },
          aspectRatio: {
            type: 'f',
            value: 0.0
          },
          tanHalfFOV: {
            type: 'f',
            value: 0.0
          },
          fogNearFar: {
            type: 'v2',
            value: new THREE__namespace.Vector2(100.0, 100.0)
          },
          fogColor: {
            type: 'v4',
            value: new THREE__namespace.Vector4(0.0, 0.5, 0.0, 1.0)
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader$1,
        transparent: false,
        depthTest: false,
        depthWrite: false
      })

      _this.setValues(params)

      return _this
    }

    _createClass(AOVertBlurWithBlendMaterial, [
      {
        key: 'setValues',
        value: function setValues(values) {
          if (typeof values === 'undefined') {
            return
          }

          _get(
            _getPrototypeOf(AOVertBlurWithBlendMaterial.prototype),
            'setValues',
            this
          ).call(this, values)

          var defines = {}

          if (this.useFog) {
            defines.USE_FOG = 1
          }

          if (this.fogTransparent) {
            defines.FOG_TRANSPARENT = 1
          }

          this.defines = defines
        }
      }
    ])

    return AOVertBlurWithBlendMaterial
  })(THREE__namespace.RawShaderMaterial)

  AOVertBlurWithBlendMaterial.prototype.useFog = true
  AOVertBlurWithBlendMaterial.prototype.fogTransparent = false

  var fragmentShader =
    'precision highp float;\r\n\r\nuniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n'

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct()
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor
        result = Reflect.construct(Super, arguments, NewTarget)
      } else {
        result = Super.apply(this, arguments)
      }
      return _possibleConstructorReturn(this, result)
    }
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === 'undefined' || !Reflect.construct) return false
    if (Reflect.construct.sham) return false
    if (typeof Proxy === 'function') return true
    try {
      Boolean.prototype.valueOf.call(
        Reflect.construct(Boolean, [], function () {})
      )
      return true
    } catch (e) {
      return false
    }
  }

  var AnaglyphMaterial = /*#__PURE__*/ (function (_THREE$RawShaderMater) {
    _inherits(AnaglyphMaterial, _THREE$RawShaderMater)

    var _super = _createSuper(AnaglyphMaterial)

    function AnaglyphMaterial() {
      var _this

      _classCallCheck(this, AnaglyphMaterial)

      _this = _super.call(this)
      var settings = {
        uniforms: {
          srcL: {
            type: 't',
            value: null
          },
          srcR: {
            type: 't',
            value: null
          }
        },
        vertexShader: vertexScreenQuadShader,
        fragmentShader: fragmentShader,
        transparent: false,
        depthTest: false,
        depthWrite: false
      }

      _this.setValues(settings)

      return _this
    }

    return _createClass(AnaglyphMaterial)
  })(THREE__namespace.RawShaderMaterial)

  var View = /*#__PURE__*/ (function () {
    function View() {
      _classCallCheck(this, View)

      this.position = new THREE__namespace.Vector3(0, 0, 0)
      this.scale = 1
      this.orientation = new THREE__namespace.Quaternion(0, 0, 0, 1)
    }

    _createClass(View, [
      {
        key: 'set',
        value: function set(position, scale, orientation) {
          this.position = position
          this.scale = scale
          this.orientation = orientation
        }
      }
    ])

    return View
  })()

  var _transitionTime = 1.5

  var ViewInterpolator = /*#__PURE__*/ (function () {
    function ViewInterpolator() {
      _classCallCheck(this, ViewInterpolator)
    }

    _createClass(ViewInterpolator, [
      {
        key: 'setup',
        value: function setup(startView, endView) {
          this._startTime = undefined
          this._endTime = undefined
          this._isPaused = false
          this._srcView = startView
          this._dstView = endView
          this._isMoving = false
        }
      },
      {
        key: 'isMoving',
        value: function isMoving() {
          return this._isMoving
        }
      },
      {
        key: 'wasStarted',
        value: function wasStarted() {
          return (
            typeof this._startTime !== 'undefined' &&
            typeof this._endTime !== 'undefined'
          )
        }
      },
      {
        key: 'start',
        value: function start() {
          this._startTime = Date.now()
          var transTime = settings$1.now.interpolateViews
            ? _transitionTime * 1000
            : 0
          this._endTime = this._startTime + transTime
          this._isMoving = true
        }
      },
      {
        key: 'getCurrentView',
        value: function getCurrentView() {
          if (
            typeof this._srcView === 'undefined' ||
            typeof this._dstView === 'undefined' ||
            !this._isMoving ||
            !this.wasStarted()
          ) {
            return {
              success: false
            }
          }

          var view = this.createView()
          var time = Date.now()

          if (time > this._endTime) {
            view = this._dstView
            this.reset()
            return {
              success: true,
              view: view
            }
          }

          var factor =
            (time - this._startTime) / (this._endTime - this._startTime)
          view.position.copy(this._srcView.position)
          view.position.lerp(this._dstView.position, factor)
          view.scale =
            (1 - factor) * this._srcView.scale + factor * this._dstView.scale
          view.orientation.copy(this._srcView.orientation)
          view.orientation.slerp(this._dstView.orientation, factor)
          return {
            success: true,
            view: view
          }
        }
      },
      {
        key: 'reset',
        value: function reset() {
          this._startTime = this._endTime = 0
          this._isMoving = false
        }
      },
      {
        key: 'pause',
        value: function pause() {
          if (!this._isPaused) {
            this.setup(this.getCurrentView().view, this._dstView)
            this._isPaused = true
          }
        }
      },
      {
        key: 'resume',
        value: function resume() {
          this._isPaused = false
        }
      },
      {
        key: 'createView',
        value: function createView() {
          return new View()
        }
      }
    ])

    return ViewInterpolator
  })()

  var MAX_COOKIE_LEN = 4000
  var COUNT_SUFFIX = 'Cnt'

  function _chunkString(string, chunkLen) {
    var l = string.length
    var chunks = []

    for (var c = 0, lc = 0; lc < l; c++, lc += chunkLen) {
      chunks[c] = string.slice(lc, lc + chunkLen)
    }

    return chunks
  }

  function Cookies(context, opts) {
    this.context = context
    this._opts = ___default['default'].merge(
      {
        path: '/'
      },
      opts
    )
  }

  makeContextDependent(Cookies.prototype)

  Cookies.prototype.removeCookie = function (key) {
    var cntKey = this._toCount(key)

    var cntVal = this._getSimpleCookie(cntKey)

    if (!cntVal) {
      this._removeSimpleCookie(key)

      return
    }

    this._removeSimpleCookie(cntKey)

    cntVal = parseInt(cntVal, 10)

    for (var i = 0; i < cntVal; ++i) {
      this._removeSimpleCookie(key + i)
    }
  }

  Cookies.prototype.setCookie = function (key, value) {
    this.removeCookie(key)
    value = encodeURIComponent(value)

    var values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1)

    var cntVal = values.length

    if (cntVal === 1) {
      this._setSimpleCookie(key, value)

      return
    }

    var cntKey = this._toCount(key)

    this._setSimpleCookie(cntKey, cntVal.toString())

    for (var i = 0; i < cntVal; ++i) {
      this._setSimpleCookie(key + i, values[i])
    }
  }

  Cookies.prototype.getCookie = function (key) {
    var cntKey = this._toCount(key)

    var cntVal = this._getSimpleCookie(cntKey)

    if (!cntVal) {
      return this._getSimpleCookie(key)
    }

    cntVal = parseInt(cntVal, 10)
    var value = []

    for (var i = 0; i < cntVal; ++i) {
      value[i] = this._getSimpleCookie(key + i)
    }

    return value.join('')
  }

  Cookies.prototype._toCount = function (key) {
    return key + COUNT_SUFFIX
  }

  Cookies.prototype._removeSimpleCookie = function (key) {
    document.cookie = ''.concat(
      key,
      '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;'
    )
  }

  Cookies.prototype._getExpirationDate = function () {
    var today = new Date()
    var EXP_PERIOD_YEARS = 10
    today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS)
    return today
  }

  Cookies.prototype._setSimpleCookie = function (key, value) {
    document.cookie = ''
      .concat(key, '=')
      .concat(value, ';expires=')
      .concat(this._getExpirationDate().toUTCString(), ';path=')
      .concat(this._opts.path)
  }

  Cookies.prototype._getSimpleCookie = function (key) {
    var matches = document.cookie.match(
      new RegExp('(?:^|; )'.concat(key, '=([^;]*)'))
    )
    return matches ? decodeURIComponent(matches[1]) : ''
  }

  Cookies.prototype._exists = function (key) {
    return document.cookie.match(new RegExp('(?:^|; )'.concat(key, '=([^;]*)')))
  }

  function createWebVRButton(webVRPoC) {
    function showEnterVR(button) {
      button.style.display = ''
      button.style.cursor = 'pointer'
      button.style.left = 'calc(50% - 50px)'
      button.style.width = '100px'
      button.textContent = 'ENTER VR'
      var currentSession = null

      function onSessionEnded() {
        currentSession.removeEventListener('end', onSessionEnded)
        button.textContent = 'ENTER VR'
        currentSession = null
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded)

        webVRPoC._gfx.renderer.xr.setReferenceSpaceType('local')

        webVRPoC._gfx.renderer.xr.setSession(session)

        button.textContent = 'EXIT VR'
        currentSession = session
      }

      button.onmouseenter = function () {
        button.style.opacity = '1.0'
      }

      button.onmouseleave = function () {
        button.style.opacity = '0.5'
      }

      button.onclick = function () {
        if (currentSession === null) {
          var sessionInit = {
            optionalFeatures: ['local-floor', 'bounded-floor']
          }
          navigator.xr
            .requestSession('immersive-vr', sessionInit)
            .then(onSessionStarted)
          webVRPoC.moveSceneBehindHeadset()
        } else {
          currentSession.end()
        }
      }
    }

    function showWebXRNotFound(button) {
      button.style.display = ''
      button.style.cursor = 'auto'
      button.style.left = 'calc(50% - 75px)'
      button.style.width = '150px'
      button.textContent = 'VR NOT FOUND'
      button.onmouseenter = null
      button.onmouseleave = null
      button.onclick = null
    }

    function stylizeElement(element) {
      element.style.position = 'absolute'
      element.style.bottom = '20px'
      element.style.padding = '12px 6px'
      element.style.border = '1px solid #fff'
      element.style.borderRadius = '4px'
      element.style.background = 'transparent'
      element.style.color = '#fff'
      element.style.font = 'normal 13px sans-serif'
      element.style.textAlign = 'center'
      element.style.opacity = '0.5'
      element.style.outline = 'none'
      element.style.zIndex = '999'
    }

    if ('xr' in navigator) {
      var button = document.createElement('button')
      button.style.display = 'none'
      stylizeElement(button)
      navigator.xr
        .isSessionSupported('immersive-vr')
        .then(function (supported) {
          return supported ? showEnterVR(button) : showWebXRNotFound(button)
        })
      return button
    }

    var message = document.createElement('a')
    message.href = 'https://webvr.info'
    message.innerHTML = 'WEBXR NOT SUPPORTED'
    message.style.left = 'calc(50% - 90px)'
    message.style.width = '180px'
    message.style.textDecoration = 'none'
    stylizeElement(message)
    return message
  }

  var WebVRPoC = /*#__PURE__*/ (function () {
    function WebVRPoC(onToggle) {
      _classCallCheck(this, WebVRPoC)

      this._mainCamera = new THREE__namespace.PerspectiveCamera()
      this._button = null
      this._onToggle = onToggle
      this._molContainer = new gfxutils.RCGroup()
      this._user = new gfxutils.RCGroup()
      this._scalingPivot = new THREE__namespace.Object3D()

      this._user.add(this._scalingPivot)

      this._controller1 = null
      this._controller2 = null
      this._pressedGripsCounter = 0
      this._distance = 0
      this._gfx = null
    }

    _createClass(WebVRPoC, [
      {
        key: 'startScalingByControllers',
        value: function startScalingByControllers() {
          this._distance = this._controller1.position.distanceTo(
            this._controller2.position
          )
          gfxutils.getMiddlePoint(
            this._controller1.position,
            this._controller2.position,
            this._scalingPivot.position
          )

          this._scalingPivot.scale.set(1, 1, 1)

          this._scalingPivot.updateMatrix()

          this._scalingPivot.updateMatrixWorld()

          this._scalingPivot.addSavingWorldTransform(this._molContainer)
        }
      },
      {
        key: 'stopScalingByControllers',
        value: function stopScalingByControllers() {
          this._gfx.scene.addSavingWorldTransform(this._molContainer)
        }
      },
      {
        key: 'handleGripsDown',
        value: function handleGripsDown(event) {
          this._pressedGripsCounter++

          if (this._pressedGripsCounter === 2) {
            this.startScalingByControllers()
          } else if (this._pressedGripsCounter === 1) {
            event.target.addSavingWorldTransform(this._molContainer)
          }
        }
      },
      {
        key: 'handleGripsUp',
        value: function handleGripsUp(event) {
          this._pressedGripsCounter--

          if (this._pressedGripsCounter === 1) {
            this.stopScalingByControllers()
            var anotherController =
              event.target === this._controller1
                ? this._controller2
                : this._controller1
            anotherController.addSavingWorldTransform(this._molContainer)
          } else if (this._pressedGripsCounter === 0) {
            this._gfx.scene.addSavingWorldTransform(this._molContainer)
          }
        }
      },
      {
        key: 'enable',
        value: function enable(gfx) {
          if (!gfx) {
            logger.warn("WebVR couldn't be enabled, because gfx is not defined")
            return
          }

          this._gfx = gfx
          var renderer = gfx.renderer,
            camera = gfx.camera

          if (!renderer) {
            throw new Error('No renderer is available to toggle WebVR')
          }

          if (!camera) {
            throw new Error('No camera is available to toggle WebVR')
          }

          renderer.xr.enabled = true

          if (!this._button) {
            this._button = createWebVRButton(this)
            document.body.appendChild(this._button)
          } else {
            this._button.style.display = 'block'
          }

          this._mainFog = settings$1.now.fog
          settings$1.set('fog', false)

          this._plugVRNodesIntoScene(gfx, renderer)

          this._setControllersListeners()

          if (this._onToggle) {
            this._onToggle(true)
          }
        }
      },
      {
        key: '_plugVRNodesIntoScene',
        value: function _plugVRNodesIntoScene(gfx, renderer) {
          this._mainCamera.copy(gfx.camera)

          gfx.scene.add(this._user)
          gfx.scene.add(this._molContainer)

          this._molContainer.add(gfx.root)

          this._controller1 = renderer.xr.getController(0)
          this._controller2 = renderer.xr.getController(1)

          var mesh = this._createControllerMesh()

          this._controller1.add(mesh)

          this._controller2.add(mesh.clone())

          this._user.add(this._controller1)

          this._user.add(this._controller2)
        }
      },
      {
        key: '_setControllersListeners',
        value: function _setControllersListeners() {
          var _this = this

          this._controller1.addEventListener('selectstart', function (event) {
            _this.handleGripsDown(event)
          })

          this._controller1.addEventListener('selectend', function (event) {
            _this.handleGripsUp(event)
          })

          this._controller2.addEventListener('selectstart', function (event) {
            _this.handleGripsDown(event)
          })

          this._controller2.addEventListener('selectend', function (event) {
            _this.handleGripsUp(event)
          })

          this._controller1.addEventListener('squeezestart', function (event) {
            _this.handleGripsDown(event)
          })

          this._controller1.addEventListener('squeezeend', function (event) {
            _this.handleGripsUp(event)
          })

          this._controller2.addEventListener('squeezestart', function (event) {
            _this.handleGripsDown(event)
          })

          this._controller2.addEventListener('squeezeend', function (event) {
            _this.handleGripsUp(event)
          })
        }
      },
      {
        key: 'disable',
        value: function disable() {
          if (!this._gfx) {
            return
          }

          var _this$_gfx = this._gfx,
            renderer = _this$_gfx.renderer,
            camera = _this$_gfx.camera

          if (!renderer) {
            throw new Error('No renderer is available to toggle WebVR')
          }

          renderer.setAnimationLoop(null)
          var session = renderer.xr.getSession()

          if (session) {
            session.end()
          }

          renderer.xr.enabled = false

          if (this._button) {
            this._button.style.display = 'none'
          }

          settings$1.set('fog', this._mainFog)

          this._unplugVRNodesFromScene(camera)

          if (this._onToggle) {
            this._onToggle(false)
          }
        }
      },
      {
        key: '_unplugVRNodesFromScene',
        value: function _unplugVRNodesFromScene(camera) {
          if (this._mainCamera && camera) {
            camera.copy(this._mainCamera)
          }

          var root = this._molContainer.children[0]

          if (root) {
            this._gfx.scene.add(root)
          }

          this._molContainer.parent.remove(this._molContainer)

          if (this._user) {
            this._gfx.scene.remove(this._user)
          }

          this._molContainer = null
          this._user = null
          this._scalingPivot = null
          this._user = null
          this._controller1 = null
          this._controller2 = null
        }
      },
      {
        key: '_createControllerMesh',
        value: function _createControllerMesh() {
          var geometry = new THREE__namespace.CylinderGeometry(0.04, 0.04, 0.3)
          var material = new UberMaterial()
          material.setValues({
            lights: false,
            overrideColor: true
          })
          material.setUberOptions({
            fixedColor: new THREE__namespace.Color(0x4444ff)
          })
          material.updateUniforms()
          var cylinder = new THREE__namespace.Mesh(geometry, material)
          cylinder.rotateX(-Math.PI / 2)
          return cylinder
        }
      },
      {
        key: 'updateMoleculeScale',
        value: function updateMoleculeScale() {
          if (!this._controller1 || !this._controller2) {
            return
          }

          var self = this

          if (self._pressedGripsCounter === 2) {
            gfxutils.getMiddlePoint(
              self._controller1.position,
              self._controller2.position,
              self._scalingPivot.position
            )

            var dist = self._controller1.position.distanceTo(
              self._controller2.position
            )

            var scaler = dist / self._distance

            self._scalingPivot.scale.multiplyScalar(scaler)

            self._distance = dist
          }
        }
      },
      {
        key: 'moveSceneBehindHeadset',
        value: function moveSceneBehindHeadset() {
          var gfx = this._gfx
          var camera = gfx.camera
          var container = this._molContainer
          container.matrix.identity()
          container.position.set(0, 0, -4.0)
          container.updateMatrix()
          container.matrixWorld.multiplyMatrices(
            camera.matrixWorld,
            container.matrix
          )
          gfx.scene.addSavingWorldTransform(container)

          if (this._onToggle) {
            this._onToggle(true)
          }
        }
      },
      {
        key: 'getCanvas',
        value: function getCanvas() {
          var gfx = this._gfx
          return gfx && gfx.renderer ? gfx.renderer.domElement : null
        }
      }
    ])

    return WebVRPoC
  })()

  var fragmentScreenQuadFromDistTex =
    'precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform vec3 aberration;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  \r\n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r\n  gl_FragColor.a = 1.0;\r\n}'

  var selectors$1 = chem.selectors,
    Atom = chem.Atom,
    Residue = chem.Residue,
    Chain = chem.Chain,
    Molecule = chem.Molecule
  var EDIT_MODE = {
    COMPLEX: 0,
    COMPONENT: 1,
    FRAGMENT: 2
  }
  var LOADER_NOT_FOUND = 'Could not find suitable loader for this source'
  var PARSER_NOT_FOUND = 'Could not find suitable parser for this source'
  var createElement = utils.createElement

  function updateFogRange(fog, center, radius) {
    fog.near = center - radius * settings$1.now.fogNearFactor
    fog.far = center + radius * settings$1.now.fogFarFactor
  }

  function removeExtension(fileName) {
    var dot = fileName.lastIndexOf('.')

    if (dot >= 0) {
      fileName = fileName.substr(0, dot)
    }

    return fileName
  }

  function hasValidResidues(complex) {
    var hasValidRes = false
    complex.forEachComponent(function (component) {
      component.forEachResidue(function (residue) {
        if (residue._isValid) {
          hasValidRes = true
        }
      })
    })
    return hasValidRes
  }

  function reportProgress(log, action, percent) {
    var TOTAL_PERCENT = 100

    if (percent !== undefined) {
      log.debug(
        ''
          .concat(action, '... ')
          .concat(Math.floor(percent * TOTAL_PERCENT), '%')
      )
    } else {
      log.debug(''.concat(action, '...'))
    }
  }

  function chooseFogColor() {
    return settings$1.now.fogColorEnable
      ? settings$1.now.fogColor
      : settings$1.now.bg.color
  }

  function Miew(opts) {
    EventDispatcher.call(this)
    this._opts = ___default['default'].merge(
      {
        settingsCookie: 'settings',
        cookiePath: '/'
      },
      opts
    )
    this._gfx = null
    this._interpolator = new ViewInterpolator()
    this._container =
      (opts && opts.container) ||
      document.getElementById('miew-container') ||
      ___default['default'].head(
        document.getElementsByClassName('miew-container')
      ) ||
      document.body
    this._containerRoot = this._container
    this._running = false
    this._halting = false
    this._building = false
    this._needRender = true
    this._hotKeysEnabled = true
    this.settings = settings$1
    var log = logger
    log.console = false
    log.level = 'info'
    this.logger = log
    this._cookies = new Cookies(this)
    this.restoreSettings()

    if (opts && opts.settings) {
      this.settings.set(opts.settings)
    }

    this._spinner = null
    this._loading = []
    this._animInterval = null
    this._visuals = {}
    this._curVisualName = null
    this._objects = []
    this._sourceWindow = null
    this.reset()

    if (this._repr) {
      log.debug(
        'Selected '
          .concat(this._repr.mode.name, ' mode with ')
          .concat(this._repr.colorer.name, ' colorer.')
      )
    }

    var self = this
    Miew.registeredPlugins.forEach(function (plugin) {
      plugin.call(self)
    })

    this._initOnSettingsChanged()
  }

  Miew.prototype = Object.create(EventDispatcher.prototype)
  Miew.prototype.constructor = Miew

  Miew.prototype.getMaxRepresentationCount = function () {
    return ComplexVisual.NUM_REPRESENTATION_BITS
  }

  function _setContainerContents(container, element) {
    var parent = container

    while (parent.firstChild) {
      parent.removeChild(parent.firstChild)
    }

    parent.appendChild(element)
  }

  Miew.prototype._updateShadowCamera = (function () {
    var shadowMatrix = new THREE__namespace.Matrix4()
    var direction = new THREE__namespace.Vector3()
    var OBB = {
      center: new THREE__namespace.Vector3(),
      halfSize: new THREE__namespace.Vector3()
    }
    return function () {
      this._gfx.scene.updateMatrixWorld()

      for (var i = 0; i < this._gfx.scene.children.length; i++) {
        if (this._gfx.scene.children[i].type === 'DirectionalLight') {
          var light = this._gfx.scene.children[i]
          shadowMatrix.copy(light.shadow.camera.matrixWorldInverse)
          this.getOBB(shadowMatrix, OBB)
          direction.subVectors(light.target.position, light.position)
          light.position.subVectors(OBB.center, direction)
          light.target.position.copy(OBB.center)
          light.shadow.bias = 0.09
          light.shadow.camera.bottom = -OBB.halfSize.y
          light.shadow.camera.top = OBB.halfSize.y
          light.shadow.camera.right = OBB.halfSize.x
          light.shadow.camera.left = -OBB.halfSize.x
          light.shadow.camera.near = direction.length() - OBB.halfSize.z
          light.shadow.camera.far = direction.length() + OBB.halfSize.z
          light.shadow.camera.updateProjectionMatrix()
        }
      }
    }
  })()

  Miew.prototype.init = function () {
    var container = this._container
    var elem = utils.createElement('div', {
      class: 'miew-canvas'
    })

    _setContainerContents(container, elem)

    this._container = elem
    var frag = document.createDocumentFragment()
    frag.appendChild(
      (this._msgMode = createElement(
        'div',
        {
          class: 'mode-message overlay'
        },
        createElement('p', {}, 'COMPONENT EDIT MODE')
      ))
    )
    frag.appendChild(
      (this._msgAtomInfo = createElement(
        'div',
        {
          class: 'atom-info overlay'
        },
        createElement('p', {}, '')
      ))
    )
    container.appendChild(frag)

    if (this._gfx !== null) {
      return true
    }

    var self = this

    this._showMessage('Viewer is being initialized...')

    try {
      this._initGfx()

      this._initListeners()

      this._spinner = new Spinner({
        lines: 13,
        length: 28,
        width: 14,
        radius: 42,
        color: '#fff',
        zIndex: 700
      })
      window.top.addEventListener('keydown', function (event) {
        self._onKeyDown(event)
      })
      window.top.addEventListener('keyup', function (event) {
        self._onKeyUp(event)
      })
      this._objectControls = new ObjectControls(
        this._gfx.root,
        this._gfx.pivot,
        this._gfx.camera,
        this._gfx.renderer.domElement,
        function () {
          return self._getAltObj()
        }
      )

      this._objectControls.addEventListener('change', function (e) {
        if (settings$1.now.shadow.on) {
          self._updateShadowCamera()
        }

        switch (e.action) {
          case 'rotate':
            self.dispatchEvent({
              type: 'rotate',
              quaternion: e.quaternion
            })
            break

          case 'zoom':
            self.dispatchEvent({
              type: 'zoom',
              factor: e.factor
            })
            break

          default:
            self.dispatchEvent({
              type: e.action
            })
        }

        self.dispatchEvent({
          type: 'transform'
        })
        self._needRender = true
      })

      var gfx = this._gfx
      this._picker = new Picker(gfx.root, gfx.camera, gfx.renderer.domElement)

      this._picker.addEventListener('newpick', function (event) {
        self._onPick(event)
      })

      this._picker.addEventListener('dblclick', function (event) {
        self.center(event)
      })
    } catch (error) {
      if (
        error.name === 'TypeError' &&
        error.message === "Cannot read property 'getExtension' of null"
      ) {
        this._showMessage('Could not create WebGL context.')
      } else if (error.message.search(/webgl/i) > 1) {
        this._showMessage(error.message)
      } else {
        this._showMessage('Viewer initialization failed.')

        throw error
      }

      return false
    }

    var file = this._opts && this._opts.load

    if (file) {
      var type = this._opts && this._opts.type
      this.load(file, {
        fileType: type,
        keepRepsInfo: true
      })
    }

    return true
  }

  Miew.prototype.term = function () {
    this._showMessage('Viewer has been terminated.')

    this._loading.forEach(function (job) {
      job.cancel()
    })

    this._loading.length = 0
    this.halt()
    this._gfx = null
  }

  Miew.prototype._showMessage = function (msg) {
    var element = document.createElement('div')
    element.setAttribute('class', 'miew-message')
    element
      .appendChild(document.createElement('p'))
      .appendChild(document.createTextNode(msg))

    _setContainerContents(this._container, element)
  }

  Miew.prototype._showCanvas = function () {
    _setContainerContents(this._container, this._gfx.renderer.domElement)
  }

  Miew.prototype._requestAnimationFrame = function (callback) {
    var xr = this._gfx.renderer.xr

    if (xr && xr.enabled) {
      this._gfx.renderer.setAnimationLoop(callback)

      return
    }

    requestAnimationFrame(callback)
  }

  function arezSpritesSupported(context) {
    return context.getExtension('EXT_frag_depth')
  }

  function isAOSupported(context) {
    return (
      context.getExtension('WEBGL_depth_texture') &&
      context.getExtension('WEBGL_draw_buffers')
    )
  }

  Miew.prototype._initGfx = function () {
    var gfx = {
      width: this._container.clientWidth,
      height: this._container.clientHeight
    }
    var webGLOptions = {
      preserveDrawingBuffer: true,
      alpha: true,
      premultipliedAlpha: false
    }

    if (settings$1.now.antialias) {
      webGLOptions.antialias = true
    }

    gfx.renderer2d = new CSS2DRenderer()
    gfx.renderer = new THREE__namespace.WebGL1Renderer(webGLOptions)
    gfx.renderer.shadowMap.enabled = settings$1.now.shadow.on
    gfx.renderer.shadowMap.autoUpdate = false
    gfx.renderer.shadowMap.type = THREE__namespace.PCFShadowMap
    capabilities.init(gfx.renderer)

    if (!arezSpritesSupported(gfx.renderer.getContext())) {
      settings$1.set('zSprites', false)
    }

    if (!isAOSupported(gfx.renderer.getContext())) {
      settings$1.set('ao', false)
    }

    gfx.renderer.autoClear = false
    gfx.renderer.setPixelRatio(window.devicePixelRatio)
    gfx.renderer.setSize(gfx.width, gfx.height)
    gfx.renderer.setClearColor(
      settings$1.now.bg.color,
      Number(!settings$1.now.bg.transparent)
    )
    gfx.renderer.clearColor()
    gfx.renderer2d.setSize(gfx.width, gfx.height)
    gfx.camera = new THREE__namespace.PerspectiveCamera(
      settings$1.now.camFov,
      gfx.width / gfx.height,
      settings$1.now.camNear,
      settings$1.now.camFar
    )
    gfx.camera.setMinimalFov(settings$1.now.camFov)
    gfx.camera.position.z = settings$1.now.camDistance
    gfx.camera.updateProjectionMatrix()
    gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT)
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME)
    gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE)
    gfx.stereoCam = new THREE__namespace.StereoCamera()
    gfx.scene = new THREE__namespace.Scene()
    var color = chooseFogColor()
    gfx.scene.fog = new THREE__namespace.Fog(
      color,
      settings$1.now.camNear,
      settings$1.now.camFar
    )
    gfx.root = new gfxutils.RCGroup()
    gfx.scene.add(gfx.root)
    gfx.pivot = new gfxutils.RCGroup()
    gfx.root.add(gfx.pivot)
    gfx.selectionScene = new THREE__namespace.Scene()
    gfx.selectionRoot = new THREE__namespace.Group()
    gfx.selectionRoot.matrixAutoUpdate = false
    gfx.selectionScene.add(gfx.selectionRoot)
    gfx.selectionPivot = new THREE__namespace.Group()
    gfx.selectionPivot.matrixAutoUpdate = false
    gfx.selectionRoot.add(gfx.selectionPivot)
    var light12 = new THREE__namespace.DirectionalLight(0xffffff, 0.45)
    light12.position.set(0, 0.414, 1)
    light12.layers.enable(gfxutils.LAYERS.TRANSPARENT)
    light12.castShadow = true
    light12.shadow.bias = 0.09
    light12.shadow.radius = settings$1.now.shadow.radius
    light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP)
    var pixelRatio = gfx.renderer.getPixelRatio()
    var shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio
    light12.shadow.mapSize.width = shadowMapSize
    light12.shadow.mapSize.height = shadowMapSize
    light12.target.position.set(0.0, 0.0, 0.0)
    gfx.scene.add(light12)
    gfx.scene.add(light12.target)
    var light3 = new THREE__namespace.AmbientLight(0x666666)
    light3.layers.enable(gfxutils.LAYERS.TRANSPARENT)
    gfx.scene.add(light3)
    gfx.axes = new Axes(gfx.root, gfx.camera)
    var deviceWidth = gfx.width * pixelRatio
    var deviceHeight = gfx.height * pixelRatio
    gfx.offscreenBuf = new THREE__namespace.WebGLRenderTarget(
      deviceWidth,
      deviceHeight,
      {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.NearestFilter,
        format: THREE__namespace.RGBAFormat,
        depthBuffer: true
      }
    )

    if (gfx.renderer.getContext().getExtension('WEBGL_depth_texture')) {
      gfx.offscreenBuf.depthTexture = new THREE__namespace.DepthTexture()
      gfx.offscreenBuf.depthTexture.type = THREE__namespace.UnsignedShortType
    }

    gfx.offscreenBuf2 = new THREE__namespace.WebGLRenderTarget(
      deviceWidth,
      deviceHeight,
      {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        depthBuffer: false
      }
    )
    gfx.offscreenBuf3 = new THREE__namespace.WebGLRenderTarget(
      deviceWidth,
      deviceHeight,
      {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        depthBuffer: false
      }
    )
    gfx.offscreenBuf4 = new THREE__namespace.WebGLRenderTarget(
      deviceWidth,
      deviceHeight,
      {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        depthBuffer: false
      }
    )
    gfx.volBFTex = gfx.offscreenBuf3
    gfx.volFFTex = gfx.offscreenBuf4
    gfx.volWFFTex = gfx.offscreenBuf

    if (gfx.renderer.getContext().getExtension('OES_texture_float')) {
      gfx.offscreenBuf5 = new THREE__namespace.WebGLRenderTarget(
        deviceWidth,
        deviceHeight,
        {
          minFilter: THREE__namespace.LinearFilter,
          magFilter: THREE__namespace.LinearFilter,
          format: THREE__namespace.RGBAFormat,
          type: THREE__namespace.FloatType,
          depthBuffer: false
        }
      )
      gfx.offscreenBuf6 = new THREE__namespace.WebGLRenderTarget(
        deviceWidth,
        deviceHeight,
        {
          minFilter: THREE__namespace.LinearFilter,
          magFilter: THREE__namespace.LinearFilter,
          format: THREE__namespace.RGBAFormat,
          type: THREE__namespace.FloatType,
          depthBuffer: false
        }
      )
      gfx.offscreenBuf7 = new THREE__namespace.WebGLRenderTarget(
        deviceWidth,
        deviceHeight,
        {
          minFilter: THREE__namespace.LinearFilter,
          magFilter: THREE__namespace.LinearFilter,
          format: THREE__namespace.RGBAFormat,
          type: THREE__namespace.FloatType,
          depthBuffer: true
        }
      )
      gfx.volBFTex = gfx.offscreenBuf5
      gfx.volFFTex = gfx.offscreenBuf6
      gfx.volWFFTex = gfx.offscreenBuf7
    } else {
      this.logger.warn("Device doesn't support OES_texture_float extension")
    }

    gfx.stereoBufL = new THREE__namespace.WebGLRenderTarget(
      deviceWidth,
      deviceHeight,
      {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        depthBuffer: false
      }
    )
    gfx.stereoBufR = new THREE__namespace.WebGLRenderTarget(
      deviceWidth,
      deviceHeight,
      {
        minFilter: THREE__namespace.LinearFilter,
        magFilter: THREE__namespace.LinearFilter,
        format: THREE__namespace.RGBAFormat,
        depthBuffer: false
      }
    )
    this._gfx = gfx

    this._showCanvas()

    this._embedWebXR(settings$1.now.stereo === 'WEBVR')

    this._container.appendChild(gfx.renderer2d.getElement())

    var stats = new Stats()
    stats.domElement.style.position = 'absolute'
    stats.domElement.style.right = '0'
    stats.domElement.style.bottom = '0'

    this._container.appendChild(stats.domElement)

    this._fps = stats

    this._fps.show(settings$1.now.fps)
  }

  Miew.prototype._initListeners = function () {
    var self = this
    window.addEventListener('resize', function () {
      self._onResize()
    })
  }

  Miew.prototype._makeUniqueVisualName = function (baseName) {
    if (!baseName) {
      return Math.random().toString()
    }

    var name = baseName
    var suffix = 1

    while (this._visuals.hasOwnProperty(name)) {
      name = ''.concat(baseName, ' (').concat(suffix.toString(), ')')
      suffix++
    }

    return name
  }

  Miew.prototype._addVisual = function (visual) {
    if (!visual) {
      return null
    }

    var name = this._makeUniqueVisualName(visual.name)

    visual.name = name
    this._visuals[name] = visual

    this._gfx.pivot.add(visual)

    if (visual.getSelectionGeo) {
      this._gfx.selectionPivot.add(visual.getSelectionGeo())
    }

    return name
  }

  Miew.prototype._removeVisual = function (visual) {
    var name = ''
    var obj = null

    if (visual instanceof Visual) {
      name = visual.name
      obj = visual
    } else if (typeof visual === 'string') {
      name = visual
      obj = this._visuals[name]
    }

    if (
      !obj ||
      !this._visuals.hasOwnProperty(name) ||
      this._visuals[name] !== obj
    ) {
      return
    }

    if (name === this._curVisualName) {
      this._curVisualName = undefined
    }

    delete this._visuals[name]
    obj.release()
    this._needRender = true
  }

  Miew.prototype._forEachVisual = function (callback) {
    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        callback(this._visuals[name])
      }
    }
  }

  Miew.prototype._releaseAllVisuals = function () {
    if (!this._gfx || !this._gfx.pivot) {
      return
    }

    for (var name in this._visuals) {
      if (this._visuals.hasOwnProperty(name)) {
        this._visuals[name].release()
      }
    }

    this._visuals = {}
  }

  Miew.prototype._forEachComplexVisual = function (callback) {
    if (!this._gfx || !this._gfx.pivot) {
      return
    }

    for (var name in this._visuals) {
      if (
        this._visuals.hasOwnProperty(name) &&
        this._visuals[name] instanceof ComplexVisual
      ) {
        callback(this._visuals[name])
      }
    }
  }

  Miew.prototype._getComplexVisual = function (name) {
    name = name || this._curVisualName
    var any = null
    var named = null

    this._forEachComplexVisual(function (visual) {
      any = visual

      if (visual.name === name) {
        named = visual
      }
    })

    return named || any
  }

  Miew.prototype._getVolumeVisual = function () {
    var any = null

    this._forEachVisual(function (visual) {
      if (visual instanceof VolumeVisual) {
        any = visual
      }
    })

    return any
  }

  Miew.prototype._getVisualForComplex = function (complex) {
    if (!complex) {
      return null
    }

    var found = null

    this._forEachComplexVisual(function (visual) {
      if (visual.getComplex() === complex) {
        found = visual
      }
    })

    return found
  }

  Miew.prototype.getVisuals = function () {
    return Object.keys(this._visuals)
  }

  Miew.prototype.getComplexVisualsCount = function () {
    var count = 0

    this._forEachComplexVisual(function () {
      return count++
    })

    return count
  }

  Miew.prototype.getCurrentVisual = function () {
    return this._curVisualName
  }

  Miew.prototype.setCurrentVisual = function (name) {
    if (!this._visuals[name]) {
      return
    }

    this._curVisualName = name
  }

  Miew.prototype.run = function () {
    var _this = this

    if (!this._running) {
      this._running = true

      if (this._halting) {
        this._halting = false
        return
      }

      this._objectControls.enable(true)

      this._interpolator.resume()

      this._requestAnimationFrame(function () {
        return _this._onTick()
      })
    }
  }

  Miew.prototype.halt = function () {
    if (this._running) {
      this._discardComponentEdit()

      this._discardFragmentEdit()

      this._objectControls.enable(false)

      this._interpolator.pause()

      this._halting = true
    }
  }

  Miew.prototype.enableHotKeys = function (enabled) {
    this._hotKeysEnabled = enabled

    this._objectControls.enableHotkeys(enabled)
  }

  Miew.prototype._onResize = function () {
    this._needRender = true
    var gfx = this._gfx
    gfx.width = this._container.clientWidth
    gfx.height = this._container.clientHeight
    gfx.camera.aspect = gfx.width / gfx.height
    gfx.camera.setMinimalFov(settings$1.now.camFov)
    gfx.camera.updateProjectionMatrix()
    gfx.renderer.setSize(gfx.width, gfx.height)
    gfx.renderer2d.setSize(gfx.width, gfx.height)
    this.dispatchEvent({
      type: 'resize'
    })
  }

  Miew.prototype._resizeOffscreenBuffers = function (width, height, stereo) {
    var gfx = this._gfx
    stereo = stereo || 'NONE'
    var isAnaglyph = stereo === 'NONE' || stereo === 'ANAGLYPH'
    var multi = isAnaglyph ? 1 : 0.5
    gfx.offscreenBuf.setSize(multi * width, height)
    gfx.offscreenBuf2.setSize(multi * width, height)
    gfx.offscreenBuf3.setSize(multi * width, height)
    gfx.offscreenBuf4.setSize(multi * width, height)

    if (gfx.offscreenBuf5) {
      gfx.offscreenBuf5.setSize(multi * width, height)
    }

    if (gfx.offscreenBuf6) {
      gfx.offscreenBuf6.setSize(multi * width, height)
    }

    if (gfx.offscreenBuf7) {
      gfx.offscreenBuf7.setSize(multi * width, height)
    }

    if (isAnaglyph) {
      gfx.stereoBufL.setSize(width, height)
      gfx.stereoBufR.setSize(width, height)
    }
  }

  Miew.prototype._onTick = function () {
    var _this2 = this

    if (this._halting) {
      this._running = false
      this._halting = false
      return
    }

    this._fps.update()

    this._requestAnimationFrame(function () {
      return _this2._onTick()
    })

    this._onUpdate()

    if (this._needRender) {
      this._onRender()

      this._needRender =
        !settings$1.now.suspendRender || settings$1.now.stereo === 'WEBVR'
    }
  }

  Miew.prototype._getBSphereRadius = function () {
    var radius = 0

    this._forEachVisual(function (visual) {
      radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius)
    })

    return radius * this._objectControls.getScale()
  }

  Miew.prototype.getOBB = (function () {
    var _bSphereForOneVisual = new THREE__namespace.Sphere()

    var _bBoxForOneVisual = new THREE__namespace.Box3()

    var _bBox = new THREE__namespace.Box3()

    var _invMatrix = new THREE__namespace.Matrix4()

    var _points = [
      new THREE__namespace.Vector3(),
      new THREE__namespace.Vector3(),
      new THREE__namespace.Vector3(),
      new THREE__namespace.Vector3()
    ]
    return function (matrix, OBB) {
      _bBox.makeEmpty()

      this._forEachVisual(function (visual) {
        _bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere)

        _bSphereForOneVisual
          .applyMatrix4(visual.matrixWorld)
          .applyMatrix4(matrix)

        _bSphereForOneVisual.getBoundingBox(_bBoxForOneVisual)

        _bBox.union(_bBoxForOneVisual)
      })

      _bBox.getCenter(OBB.center)

      _invMatrix.copy(matrix).invert()

      OBB.center.applyMatrix4(_invMatrix)
      var min = _bBox.min
      var max = _bBox.max

      _points[0].set(min.x, min.y, min.z)

      _points[1].set(max.x, min.y, min.z)

      _points[2].set(min.x, max.y, min.z)

      _points[3].set(min.x, min.y, max.z)

      for (var i = 0, l = _points.length; i < l; i++) {
        _points[i].applyMatrix4(_invMatrix)
      }

      OBB.halfSize
        .set(
          Math.abs(_points[0].x - _points[1].x),
          Math.abs(_points[0].y - _points[2].y),
          Math.abs(_points[0].z - _points[3].z)
        )
        .multiplyScalar(0.5)
    }
  })()

  Miew.prototype._updateFog = function () {
    var gfx = this._gfx

    if (settings$1.now.fog) {
      if (typeof gfx.scene.fog === 'undefined' || gfx.scene.fog === null) {
        var color = chooseFogColor()
        gfx.scene.fog = new THREE__namespace.Fog(color)

        this._setUberMaterialValues({
          fog: settings$1.now.fog
        })
      }

      updateFogRange(
        gfx.scene.fog,
        gfx.camera.position.z,
        this._getBSphereRadius()
      )
    } else if (gfx.scene.fog) {
      gfx.scene.fog = undefined

      this._setUberMaterialValues({
        fog: settings$1.now.fog
      })
    }
  }

  Miew.prototype._onUpdate = function () {
    if (
      this.isScriptingCommandAvailable !== undefined &&
      this.isScriptingCommandAvailable() &&
      !this._building
    ) {
      this.callNextCmd()
    }

    this._objectControls.update()

    this._forEachComplexVisual(function (visual) {
      visual.getComplex().update()
    })

    if (
      settings$1.now.autobuild &&
      !this._loading.length &&
      !this._building &&
      this._needRebuild()
    ) {
      this.rebuild()
    }

    if (!this._loading.length && !this._building && !this._needRebuild()) {
      this._updateView()
    }

    this._updateFog()

    if (this._gfx.renderer.xr.enabled) {
      this.webVR.updateMoleculeScale()
    }
  }

  Miew.prototype._onRender = function () {
    var gfx = this._gfx
    gfx.scene.updateMatrixWorld()
    gfx.camera.updateMatrixWorld()

    this._clipPlaneUpdateValue(this._getBSphereRadius())

    this._fogFarUpdateValue()

    gfx.renderer.setRenderTarget(null)
    gfx.renderer.clear()

    this._renderFrame(settings$1.now.stereo)
  }

  Miew.prototype._renderFrame = (function () {
    var _anaglyphMat = new AnaglyphMaterial()

    var _size = new THREE__namespace.Vector2()

    return function (stereo) {
      var gfx = this._gfx
      var renderer = gfx.renderer
      renderer.getSize(_size)

      if (stereo !== 'NONE') {
        gfx.camera.focus = gfx.camera.position.z
        gfx.stereoCam.aspect = 1.0

        if (stereo === 'ANAGLYPH') {
          gfx.stereoCam.update(gfx.camera)
        } else {
          gfx.stereoCam.updateHalfSized(gfx.camera, settings$1.now.camFov)
        }
      }

      var pixelRatio = gfx.renderer.getPixelRatio()

      this._resizeOffscreenBuffers(
        _size.width * pixelRatio,
        _size.height * pixelRatio,
        stereo
      )

      this._renderShadowMap()

      switch (stereo) {
        case 'WEBVR':
        case 'NONE':
          this._renderScene(gfx.camera, false)

          break

        case 'SIMPLE':
        case 'DISTORTED':
          renderer.setScissorTest(true)
          renderer.setScissor(0, 0, _size.width / 2, _size.height)
          renderer.setViewport(0, 0, _size.width / 2, _size.height)

          this._renderScene(this._gfx.stereoCam.cameraL, stereo === 'DISTORTED')

          renderer.setScissor(_size.width / 2, 0, _size.width / 2, _size.height)
          renderer.setViewport(
            _size.width / 2,
            0,
            _size.width / 2,
            _size.height
          )

          this._renderScene(this._gfx.stereoCam.cameraR, stereo === 'DISTORTED')

          renderer.setScissorTest(false)
          break

        case 'ANAGLYPH':
          this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL)

          this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR)

          renderer.setRenderTarget(null)
          _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture
          _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture
          gfx.renderer.renderScreenQuad(_anaglyphMat)
          break
      }

      gfx.renderer2d.render(gfx.scene, gfx.camera)

      if (settings$1.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
        gfx.axes.render(renderer)
      }
    }
  })()

  Miew.prototype._onBgColorChanged = function () {
    var gfx = this._gfx
    var color = chooseFogColor()

    if (gfx) {
      if (gfx.scene.fog) {
        gfx.scene.fog.color.set(color)
      }

      gfx.renderer.setClearColor(
        settings$1.now.bg.color,
        Number(!settings$1.now.bg.transparent)
      )
    }

    this._needRender = true
  }

  Miew.prototype._onFogColorChanged = function () {
    var gfx = this._gfx
    var color = chooseFogColor()

    if (gfx && gfx.scene.fog) {
      gfx.scene.fog.color.set(color)
    }

    this._needRender = true
  }

  Miew.prototype._setUberMaterialValues = function (values) {
    this._gfx.root.traverse(function (obj) {
      if (
        (obj instanceof THREE__namespace.Mesh ||
          obj instanceof THREE__namespace.LineSegments ||
          obj instanceof THREE__namespace.Line) &&
        obj.material instanceof UberMaterial
      ) {
        obj.material.setValues(values)
        obj.material.needsUpdate = true
      }
    })
  }

  Miew.prototype._enableMRT = function (on, renderBuffer, textureBuffer) {
    var gfx = this._gfx
    var gl = gfx.renderer.getContext()
    var ext = gl.getExtension('WEBGL_draw_buffers')
    var properties = gfx.renderer.properties

    if (!on) {
      ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null])
      return
    }

    gfx.renderer.setRenderTarget(textureBuffer)

    var tx8 = properties.get(textureBuffer.texture).__webglTexture

    gl.bindTexture(gl.TEXTURE_2D, tx8)
    gfx.renderer.setRenderTarget(renderBuffer)

    var fb = properties.get(renderBuffer).__webglFramebuffer

    var tx = properties.get(renderBuffer.texture).__webglTexture

    gl.bindFramebuffer(gl.FRAMEBUFFER, fb)
    fb.width = renderBuffer.width
    fb.height = renderBuffer.height
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      tx,
      0
    )
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      ext.COLOR_ATTACHMENT1_WEBGL,
      gl.TEXTURE_2D,
      tx8,
      0
    )
    ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL])
  }

  Miew.prototype._renderScene = (function () {
    return function (camera, distortion, target) {
      distortion = distortion || false
      target = target || null
      var gfx = this._gfx
      gfx.renderer.setClearColor(
        settings$1.now.bg.color,
        Number(!settings$1.now.bg.transparent)
      )
      gfx.renderer.setRenderTarget(target)
      gfx.renderer.clear()

      if (gfx.renderer.xr.enabled) {
        gfx.renderer.render(gfx.scene, camera)
        return
      }

      gfx.renderer.setClearColor(0x000000, 0.0)
      gfx.renderer.setRenderTarget(gfx.offscreenBuf4)
      gfx.renderer.clearColor()
      gfx.renderer.setClearColor(
        settings$1.now.bg.color,
        Number(!settings$1.now.bg.transparent)
      )
      gfx.renderer.setRenderTarget(gfx.offscreenBuf)
      gfx.renderer.clear()
      var bHaveComplexes = this._getComplexVisual() !== null

      var volumeVisual = this._getVolumeVisual()

      var ssao = bHaveComplexes && settings$1.now.ao

      if (ssao) {
        this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4)
      }

      if (settings$1.now.transparency === 'prepass') {
        this._renderWithPrepassTransparency(camera, gfx.offscreenBuf)
      } else if (settings$1.now.transparency === 'standard') {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf)
        gfx.renderer.render(gfx.scene, camera)
      }

      if (ssao) {
        this._enableMRT(false, null, null)
      }

      var outline = bHaveComplexes && settings$1.now.outline.on
      var fxaa = bHaveComplexes && settings$1.now.fxaa
      var volume =
        volumeVisual !== null && volumeVisual.getMesh().material != null
      var dstBuffer =
        ssao || outline || volume || fxaa || distortion
          ? gfx.offscreenBuf2
          : target
      var srcBuffer = gfx.offscreenBuf

      if (ssao) {
        this._performAO(
          srcBuffer,
          gfx.offscreenBuf4,
          gfx.offscreenBuf.depthTexture,
          dstBuffer,
          gfx.offscreenBuf3,
          gfx.offscreenBuf2
        )

        if (!fxaa && !distortion && !volume && !outline) {
          srcBuffer = dstBuffer
          dstBuffer = target
          gfx.renderer.setRenderTarget(dstBuffer)
          gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0)
        }
      } else {
        gfx.renderer.setRenderTarget(dstBuffer)
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0)
      }

      if (outline) {
        srcBuffer = dstBuffer
        dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target

        if (srcBuffer != null) {
          this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer)
        }
      }

      this._renderSelection(camera, gfx.offscreenBuf, dstBuffer)

      if (volume) {
        gfx.renderer.setRenderTarget(gfx.offscreenBuf)
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0)
        dstBuffer = gfx.offscreenBuf

        this._renderVolume(
          volumeVisual,
          camera,
          dstBuffer,
          gfx.volBFTex,
          gfx.volFFTex,
          gfx.volWFFTex
        )

        if (!fxaa && !distortion) {
          gfx.renderer.setRenderTarget(target)
          gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0)
        }
      }

      srcBuffer = dstBuffer

      if (fxaa) {
        dstBuffer = distortion ? gfx.offscreenBuf4 : target

        this._performFXAA(srcBuffer, dstBuffer)

        srcBuffer = dstBuffer
      }

      if (distortion) {
        dstBuffer = target

        this._performDistortion(srcBuffer, dstBuffer, true)
      }
    }
  })()

  Miew.prototype._performDistortion = (function () {
    var _scene = new THREE__namespace.Scene()

    var _camera = new THREE__namespace.OrthographicCamera(
      -1.0,
      1.0,
      1.0,
      -1.0,
      -500,
      1000
    )

    var _material = new THREE__namespace.RawShaderMaterial({
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        aberration: {
          type: 'fv3',
          value: new THREE__namespace.Vector3(1.0)
        }
      },
      vertexShader: vertexScreenQuadShader,
      fragmentShader: fragmentScreenQuadFromDistTex,
      transparent: false,
      depthTest: false,
      depthWrite: false
    })

    var _geo = gfxutils.buildDistorionMesh(
      10,
      10,
      settings$1.now.debug.stereoBarrel
    )

    _scene.add(new meshes.Mesh(_geo, _material))

    return function (srcBuffer, targetBuffer, mesh) {
      this._gfx.renderer.setRenderTarget(targetBuffer)

      this._gfx.renderer.clear()

      if (mesh) {
        _material.uniforms.srcTex.value = srcBuffer.texture

        _material.uniforms.aberration.value.set(0.995, 1.0, 1.01)

        this._gfx.renderer.render(_scene, _camera)
      } else {
        this._gfx.renderer.renderScreenQuadFromTexWithDistortion(
          srcBuffer,
          settings$1.now.debug.stereoBarrel
        )
      }
    }
  })()

  Miew.prototype._renderOutline = (function () {
    var _outlineMaterial = new OutlineMaterial({
      depth: true
    })

    return function (camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
      var self = this
      var gfx = self._gfx
      _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture
      _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture

      _outlineMaterial.uniforms.srcTexSize.value.set(
        srcDepthBuffer.width,
        srcDepthBuffer.height
      )

      _outlineMaterial.uniforms.color.value = new THREE__namespace.Color(
        settings$1.now.outline.color
      )
      _outlineMaterial.uniforms.threshold.value =
        settings$1.now.outline.threshold
      _outlineMaterial.uniforms.thickness.value = new THREE__namespace.Vector2(
        settings$1.now.outline.thickness,
        settings$1.now.outline.thickness
      )
      gfx.renderer.setRenderTarget(targetBuffer)
      gfx.renderer.renderScreenQuad(_outlineMaterial)
    }
  })()

  Miew.prototype._renderShadowMap = (function () {
    var pars = {
      minFilter: THREE__namespace.NearestFilter,
      magFilter: THREE__namespace.NearestFilter,
      format: THREE__namespace.RGBAFormat
    }
    return function () {
      if (!settings$1.now.shadow.on) {
        return
      }

      var gfx = this._gfx
      var currentRenderTarget = gfx.renderer.getRenderTarget()
      var activeCubeFace = gfx.renderer.getActiveCubeFace()
      var activeMipmapLevel = gfx.renderer.getActiveMipmapLevel()
      var _state = gfx.renderer.state

      _state.setBlending(THREE__namespace.NoBlending)

      _state.buffers.color.setClear(1, 1, 1, 1)

      _state.buffers.depth.setTest(true)

      _state.setScissorTest(false)

      for (var i = 0; i < gfx.scene.children.length; i++) {
        if (gfx.scene.children[i].type === 'DirectionalLight') {
          var light = gfx.scene.children[i]

          if (light.shadow.map == null) {
            light.shadow.map = new THREE__namespace.WebGLRenderTarget(
              light.shadow.mapSize.width,
              light.shadow.mapSize.height,
              pars
            )
            light.shadow.camera.updateProjectionMatrix()
          }

          light.shadow.updateMatrices(light)
          gfx.renderer.setRenderTarget(light.shadow.map)
          gfx.renderer.clear()
          gfx.renderer.render(gfx.scene, light.shadow.camera)
        }
      }

      gfx.renderer.setRenderTarget(
        currentRenderTarget,
        activeCubeFace,
        activeMipmapLevel
      )
    }
  })()

  Miew.prototype._hasSelectionToRender = function () {
    var selPivot = this._gfx.selectionPivot

    for (var i = 0; i < selPivot.children.length; i++) {
      var selPivotChild = selPivot.children[i]

      if (selPivotChild.children.length > 0) {
        return true
      }
    }

    return false
  }

  Miew.prototype._renderSelection = (function () {
    var _outlineMaterial = new OutlineMaterial()

    return function (camera, srcBuffer, targetBuffer) {
      var self = this
      var gfx = self._gfx
      gfx.renderer.setClearColor('black', 0)
      gfx.renderer.setRenderTarget(srcBuffer)
      gfx.renderer.clear(true, false, false)

      if (self._hasSelectionToRender()) {
        gfx.selectionRoot.matrix = gfx.root.matrix
        gfx.selectionPivot.matrix = gfx.pivot.matrix
        gfx.renderer.render(gfx.selectionScene, camera)
      } else {
        gfx.renderer.renderDummyQuad()
      }

      gfx.renderer.setRenderTarget(targetBuffer)
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6)
      _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture

      _outlineMaterial.uniforms.srcTexSize.value.set(
        srcBuffer.width,
        srcBuffer.height
      )

      gfx.renderer.renderScreenQuad(_outlineMaterial)
    }
  })()

  Miew.prototype._checkVolumeRenderingSupport = function (renderTarget) {
    if (!renderTarget) {
      return false
    }

    var gfx = this._gfx
    var oldRT = gfx.renderer.getRenderTarget()
    gfx.renderer.setRenderTarget(renderTarget)
    var context = gfx.renderer.getContext()
    var result = context.checkFramebufferStatus(context.FRAMEBUFFER)
    gfx.renderer.setRenderTarget(oldRT)

    if (result !== context.FRAMEBUFFER_COMPLETE) {
      this.logger.warn("Device doesn't support electron density rendering")
      return false
    }

    return true
  }

  Miew.prototype._renderVolume = (function () {
    var volumeBFMat = new VolumeMaterial$1.BackFacePosMaterial()
    var volumeFFMat = new VolumeMaterial$1.FrontFacePosMaterial()
    var cubeOffsetMat = new THREE__namespace.Matrix4().makeTranslation(
      0.5,
      0.5,
      0.5
    )
    var world2colorMat = new THREE__namespace.Matrix4()
    var volumeRenderingSupported
    return function (volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
      var gfx = this._gfx

      if (typeof volumeRenderingSupported === 'undefined') {
        volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1)
      }

      if (!volumeRenderingSupported) {
        return
      }

      var mesh = volumeVisual.getMesh()
      mesh.rebuild(gfx.camera)
      gfx.renderer.setClearColor('black', 0)
      gfx.renderer.setRenderTarget(tmpBuf1)
      gfx.renderer.clear()
      gfx.renderer.setRenderTarget(tmpBuf2)
      gfx.renderer.clear()
      gfx.renderer.setRenderTarget(tmpBuf3)
      gfx.renderer.clear()
      gfx.renderer.setRenderTarget(tmpBuf1)
      camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE)
      gfx.renderer.render(gfx.scene, camera)
      camera.layers.set(gfxutils.LAYERS.VOLUME)
      gfx.scene.overrideMaterial = volumeBFMat
      gfx.renderer.render(gfx.scene, camera)
      gfx.renderer.setRenderTarget(tmpBuf2)
      camera.layers.set(gfxutils.LAYERS.VOLUME)
      gfx.scene.overrideMaterial = volumeFFMat
      gfx.renderer.render(gfx.scene, camera)
      gfx.scene.overrideMaterial = null
      camera.layers.set(gfxutils.LAYERS.DEFAULT)
      world2colorMat.copy(mesh.matrixWorld).invert()
      UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(
        cubeOffsetMat,
        world2colorMat
      )
      camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION)
      gfx.renderer.setRenderTarget(tmpBuf3)
      gfx.renderer.render(gfx.scene, camera)
      var vm = mesh.material
      vm.uniforms._BFRight.value = tmpBuf1.texture
      vm.uniforms._FFRight.value = tmpBuf2.texture
      vm.uniforms._WFFRight.value = tmpBuf3.texture
      camera.layers.set(gfxutils.LAYERS.VOLUME)
      gfx.renderer.setRenderTarget(dstBuf)
      gfx.renderer.render(gfx.scene, camera)
      camera.layers.set(gfxutils.LAYERS.DEFAULT)
    }
  })()

  Miew.prototype._renderWithPrepassTransparency = (function () {
    return function (camera, targetBuffer) {
      var gfx = this._gfx
      gfx.renderer.setRenderTarget(targetBuffer)
      camera.layers.set(gfxutils.LAYERS.DEFAULT)
      gfx.renderer.render(gfx.scene, camera)
      camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT)
      gfx.renderer.getContext().colorMask(false, false, false, false)
      gfx.renderer.render(gfx.scene, camera)
      gfx.renderer.getContext().colorMask(true, true, true, true)
      camera.layers.set(gfxutils.LAYERS.TRANSPARENT)
      gfx.renderer.render(gfx.scene, camera)
      camera.layers.set(gfxutils.LAYERS.DEFAULT)
    }
  })()

  Miew.prototype._performFXAA = (function () {
    var _fxaaMaterial = new FXAAMaterial()

    return function (srcBuffer, targetBuffer) {
      if (
        typeof srcBuffer === 'undefined' ||
        typeof targetBuffer === 'undefined'
      ) {
        return
      }

      var gfx = this._gfx
      gfx.renderer.setClearColor(
        settings$1.now.bg.color,
        Number(!settings$1.now.bg.transparent)
      )
      gfx.renderer.setRenderTarget(targetBuffer)
      gfx.renderer.clear()
      _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture

      _fxaaMaterial.uniforms.srcTexelSize.value.set(
        1.0 / srcBuffer.width,
        1.0 / srcBuffer.height
      )

      _fxaaMaterial.uniforms.bgColor.value.set(settings$1.now.bg.color)

      if (_fxaaMaterial.bgTransparent !== settings$1.now.bg.transparent) {
        _fxaaMaterial.setValues({
          bgTransparent: settings$1.now.bg.transparent
        })

        _fxaaMaterial.needsUpdate = true
      }

      gfx.renderer.renderScreenQuad(_fxaaMaterial)
    }
  })()

  Miew.prototype._performAO = (function () {
    var _aoMaterial = new AOMaterial()

    var _horBlurMaterial = new AOHorBlurMaterial()

    var _vertBlurMaterial = new AOVertBlurWithBlendMaterial()

    var _scale = new THREE__namespace.Vector3()

    return function (
      srcColorBuffer,
      normalBuffer,
      srcDepthTexture,
      targetBuffer,
      tempBuffer,
      tempBuffer1
    ) {
      if (
        !srcColorBuffer ||
        !normalBuffer ||
        !srcDepthTexture ||
        !targetBuffer ||
        !tempBuffer ||
        !tempBuffer1
      ) {
        return
      }

      var gfx = this._gfx
      var tanHalfFOV = Math.tan(
        THREE__namespace.MathUtils.DEG2RAD * 0.5 * gfx.camera.fov
      )
      _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture
      _aoMaterial.uniforms.depthTexture.value = srcDepthTexture
      _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture

      _aoMaterial.uniforms.srcTexelSize.value.set(
        1.0 / srcColorBuffer.width,
        1.0 / srcColorBuffer.height
      )

      _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far)

      _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix
      _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect
      _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV
      gfx.root.matrix.extractScale(_scale)
      _aoMaterial.uniforms.kernelRadius.value =
        settings$1.now.debug.ssaoKernelRadius * _scale.x
      _aoMaterial.uniforms.depthThreshold.value = 2.0 * this._getBSphereRadius()
      _aoMaterial.uniforms.factor.value = settings$1.now.debug.ssaoFactor
      gfx.renderer.setRenderTarget(tempBuffer1)
      gfx.renderer.renderScreenQuad(_aoMaterial)
      _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture

      _horBlurMaterial.uniforms.srcTexelSize.value.set(
        1.0 / tempBuffer1.width,
        1.0 / tempBuffer1.height
      )

      _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture
      gfx.renderer.setRenderTarget(tempBuffer)
      gfx.renderer.renderScreenQuad(_horBlurMaterial)
      _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture
      _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture

      _vertBlurMaterial.uniforms.srcTexelSize.value.set(
        1.0 / tempBuffer.width,
        1.0 / tempBuffer.height
      )

      _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture
      _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix
      _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect
      _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV
      var fog = gfx.scene.fog

      if (fog) {
        _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far)

        _vertBlurMaterial.uniforms.fogColor.value.set(
          fog.color.r,
          fog.color.g,
          fog.color.b,
          settings$1.now.fogAlpha
        )
      }

      if (
        _vertBlurMaterial.useFog !== settings$1.now.fog ||
        _vertBlurMaterial.fogTransparent !== settings$1.now.bg.transparent
      ) {
        _vertBlurMaterial.setValues({
          useFog: settings$1.now.fog,
          fogTransparent: settings$1.now.bg.transparent
        })

        _vertBlurMaterial.needsUpdate = true
      }

      gfx.renderer.setRenderTarget(targetBuffer)
      gfx.renderer.renderScreenQuad(_vertBlurMaterial)
    }
  })()

  Miew.prototype.reset = function () {
    if (this._picker) {
      this._picker.reset()
    }

    this._lastPick = null

    this._releaseAllVisuals()

    this._setEditMode(EDIT_MODE.COMPLEX)

    this._resetObjects()

    if (this._gfx) {
      gfxutils.clearTree(this._gfx.pivot)

      this._gfx.renderer2d.reset()
    }

    this.setNeedRender()
  }

  Miew.prototype._resetScene = function () {
    this._objectControls.reset()

    this._objectControls.allowTranslation(true)

    this._objectControls.allowAltObjFreeRotation(true)

    this.resetReps()
    this.resetPivot()
    this.rebuildAll()
  }

  Miew.prototype.resetView = function () {
    if (this._picker) {
      this._picker.reset()
    }

    this._setEditMode(EDIT_MODE.COMPLEX)

    this._resetScene()

    this._forEachComplexVisual(function (visual) {
      visual.updateSelectionMask({})
      visual.rebuildSelectionGeometry()
    })
  }

  Miew.prototype._export = function (format) {
    var TheExporter = ___default['default'].head(
      io.exporters.find({
        format: format
      })
    )

    if (!TheExporter) {
      this.logger.error('Could not find suitable exporter for this source')
      return Promise.reject(
        new Error('Could not find suitable exporter for this source')
      )
    }

    this.dispatchEvent({
      type: 'exporting'
    })

    if (this._visuals[this._curVisualName] instanceof ComplexVisual) {
      var dataSource = null

      if (TheExporter.SourceClass === ComplexVisual) {
        dataSource = this._visuals[this._curVisualName]
      } else if (TheExporter.SourceClass === Complex$9) {
        dataSource = this._visuals[this._curVisualName]._complex
      }

      var exporter = new TheExporter(dataSource, {
        miewVersion: Miew.VERSION
      })
      return exporter.export().then(function (data) {
        return data
      })
    }

    if (this._visuals[this._curVisualName] instanceof VolumeVisual) {
      return Promise.reject(
        new Error('Sorry, exporter for volume data not implemented yet')
      )
    }

    return Promise.reject(new Error('Unexpected format of data'))
  }

  var rePdbId = /^(?:(pdb|cif|mmtf|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i
  var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i
  var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i

  function resolveSourceShortcut(source, opts) {
    if (!___default['default'].isString(source)) {
      return source
    }

    var matchesPdbId = rePdbId.exec(source)

    if (matchesPdbId) {
      var _matchesPdbId = _slicedToArray(matchesPdbId, 3),
        _matchesPdbId$ = _matchesPdbId[1],
        format = _matchesPdbId$ === void 0 ? 'pdb' : _matchesPdbId$,
        id = _matchesPdbId[2]

      format = format.toLowerCase()
      id = id.toUpperCase()

      switch (format) {
        case 'pdb':
          source = 'https://files.rcsb.org/download/'.concat(id, '.pdb')
          break

        case 'cif':
          source = 'https://files.rcsb.org/download/'.concat(id, '.cif')
          break

        case 'mmtf':
          source = 'https://mmtf.rcsb.org/v1.0/full/'.concat(id)
          break

        case 'ccp4':
          source = 'https://www.ebi.ac.uk/pdbe/coordinates/files/'.concat(
            id.toLowerCase(),
            '.ccp4'
          )
          break

        case 'dsn6':
          source = 'https://edmaps.rcsb.org/maps/'.concat(
            id.toLowerCase(),
            '_2fofc.dsn6'
          )
          break

        default:
          throw new Error('Unexpected data format shortcut')
      }

      opts.fileType = format
      opts.fileName = ''.concat(id, '.').concat(format)
      opts.sourceType = 'url'
      return source
    }

    var matchesPubchem = rePubchem.exec(source)

    if (matchesPubchem) {
      var compound = matchesPubchem[1].toLowerCase()
      source =
        'https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/'.concat(
          compound,
          '/JSON?record_type=3d'
        )
      opts.fileType = 'pubchem'
      opts.fileName = ''.concat(compound, '.json')
      opts.sourceType = 'url'
      return source
    }

    if (opts.sourceType === 'url' || opts.sourceType === undefined) {
      opts.sourceType = 'url'

      if (!reUrlScheme.test(source)) {
        source = utils.resolveURL(source)
      }
    }

    return source
  }

  function updateBinaryMode(opts) {
    var binary = opts.binary

    if (opts.fileType !== undefined) {
      var TheParser = ___default['default'].head(
        io.parsers.find({
          format: opts.fileType
        })
      )

      if (TheParser) {
        binary = TheParser.binary || false
      } else {
        throw new Error('Could not find suitable parser for this format')
      }
    }

    if (binary === undefined && opts.fileExt !== undefined) {
      var _TheParser = ___default['default'].head(
        io.parsers.find({
          ext: opts.fileExt
        })
      )

      if (_TheParser) {
        binary = _TheParser.binary || false
      }
    }

    if (opts.fileExt !== undefined && opts.fileExt.toLowerCase() === '.man') {
      opts.binary = true
      opts.animation = true
    }

    if (binary !== undefined) {
      if (opts.binary !== undefined && opts.binary !== binary) {
        opts.context.logger.warn('Overriding incorrect binary mode')
      }
    }

    opts.binary = binary || false
  }

  function _fetchData(source, opts, job) {
    return new Promise(function (resolve) {
      if (job.shouldCancel()) {
        throw new Error('Operation cancelled')
      }

      job.notify({
        type: 'fetching'
      })
      source = resolveSourceShortcut(source, opts)

      var TheLoader = ___default['default'].head(
        io.loaders.find({
          type: opts.sourceType,
          source: source
        })
      )

      if (!TheLoader) {
        throw new Error(LOADER_NOT_FOUND)
      }

      var fileName = opts.fileName || TheLoader.extractName(source)

      if (fileName) {
        var _utils$splitFileName = utils.splitFileName(fileName),
          _utils$splitFileName2 = _slicedToArray(_utils$splitFileName, 2),
          name = _utils$splitFileName2[0],
          fileExt = _utils$splitFileName2[1]

        ___default['default'].defaults(opts, {
          name: name,
          fileExt: fileExt,
          fileName: fileName
        })
      }

      updateBinaryMode(opts)

      var newOptions = ___default['default'].get(opts, 'preset.expression')

      if (!___default['default'].isUndefined(newOptions)) {
        newOptions = JSON.parse(newOptions)

        if (newOptions && newOptions.settings) {
          var keys = ['singleUnit']

          for (
            var keyIndex = 0, keyCount = keys.length;
            keyIndex < keyCount;
            ++keyIndex
          ) {
            var key = keys[keyIndex]

            var value = ___default['default'].get(newOptions.settings, key)

            if (!___default['default'].isUndefined(value)) {
              settings$1.set(key, value)
            }
          }
        }
      }

      var loader = new TheLoader(source, opts)
      loader.context = opts.context
      job.addEventListener('cancel', function () {
        return loader.abort()
      })
      loader.addEventListener('progress', function (event) {
        if (event.lengthComputable && event.total > 0) {
          reportProgress(loader.logger, 'Fetching', event.loaded / event.total)
        } else {
          reportProgress(loader.logger, 'Fetching')
        }
      })
      console.time('fetch')
      var promise = loader
        .load()
        .then(function (data) {
          console.timeEnd('fetch')
          opts.context.logger.info('Fetching finished')
          job.notify({
            type: 'fetchingDone',
            data: data
          })
          return data
        })
        .catch(function (error) {
          console.timeEnd('fetch')
          opts.context.logger.debug(error.message)

          if (error.stack) {
            opts.context.logger.debug(error.stack)
          }

          opts.context.logger.error('Fetching failed')
          job.notify({
            type: 'fetchingDone',
            error: error
          })
          throw error
        })
      resolve(promise)
    })
  }

  function _parseData(data, opts, job) {
    if (job.shouldCancel()) {
      return Promise.reject(new Error('Operation cancelled'))
    }

    job.notify({
      type: 'parsing'
    })

    var TheParser = ___default['default'].head(
      io.parsers.find({
        format: opts.fileType,
        ext: opts.fileExt,
        data: data
      })
    )

    if (!TheParser) {
      return Promise.reject(new Error('Could not find suitable parser'))
    }

    var parser = new TheParser(data, opts)
    parser.context = opts.context
    job.addEventListener('cancel', function () {
      return parser.abort()
    })
    console.time('parse')
    return parser
      .parse()
      .then(function (dataSet) {
        console.timeEnd('parse')
        job.notify({
          type: 'parsingDone',
          data: dataSet
        })
        return dataSet
      })
      .catch(function (error) {
        console.timeEnd('parse')
        opts.error = error
        opts.context.logger.debug(error.message)

        if (error.stack) {
          opts.context.logger.debug(error.stack)
        }

        opts.context.logger.error('Parsing failed')
        job.notify({
          type: 'parsingDone',
          error: error
        })
        throw error
      })
  }

  Miew.prototype.load = function (source, opts) {
    var _this3 = this

    opts = ___default['default'].merge({}, opts, {
      context: this
    })

    if (!this.settings.now.use.multiFile) {
      if (this._loading.length) {
        this._loading.forEach(function (job) {
          job.cancel()
        })

        this._loading.length = 0
      }

      if (!opts.animation) {
        this.reset(true)
      }
    }

    this._interpolator.reset()

    this.dispatchEvent({
      type: 'loading',
      options: opts,
      source: source
    })
    var job = new JobHandle()

    this._loading.push(job)

    job.addEventListener('notification', function (e) {
      _this3.dispatchEvent(e.slaveEvent)
    })

    this._spinner.spin(this._container)

    var onLoadEnd = function onLoadEnd(anything) {
      var jobIndex = _this3._loading.indexOf(job)

      if (jobIndex !== -1) {
        _this3._loading.splice(jobIndex, 1)
      }

      _this3._spinner.stop()

      _this3._refreshTitle()

      job.notify({
        type: 'loadingDone',
        anything: anything
      })
      return anything
    }

    return _fetchData(source, opts, job)
      .then(function (data) {
        return _parseData(data, opts, job)
      })
      .then(function (object) {
        var name = _this3._onLoad(object, opts)

        return onLoadEnd(name)
      })
      .catch(function (err) {
        _this3.logger.error('Could not load data')

        _this3.logger.debug(err)

        throw onLoadEnd(err)
      })
  }

  Miew.prototype.unload = function (name) {
    this._removeVisual(name || this.getCurrentVisual())

    this.resetPivot()

    if (settings$1.now.shadow.on) {
      this._updateShadowCamera()
    }
  }

  Miew.prototype._startAnimation = function (fileData) {
    this._stopAnimation()

    var self = this

    var visual = this._getComplexVisual()

    if (visual === null) {
      this.logger.error('Unable to start animation - no molecule is loaded.')
      return
    }

    try {
      this._frameInfo = new FrameInfo(visual.getComplex(), fileData, {
        onLoadStatusChanged: function onLoadStatusChanged() {
          self.dispatchEvent({
            type: 'mdPlayerStateChanged',
            state: {
              isPlaying: self._isAnimating,
              isLoading: self._frameInfo ? self._frameInfo.isLoading : true
            }
          })
        },
        onError: function onError(message) {
          self._stopAnimation()

          self.logger.error(message)
        }
      })
    } catch (e) {
      this.logger.error('Animation file does not fit to current complex!')
      return
    }

    this._continueAnimation()
  }

  Miew.prototype._pauseAnimation = function () {
    if (this._animInterval === null) {
      return
    }

    this._isAnimating = false
    clearInterval(this._animInterval)
    this._animInterval = null

    if (this._frameInfo) {
      this.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: this._isAnimating,
          isLoading: this._frameInfo.isLoading
        }
      })
    }
  }

  Miew.prototype._continueAnimation = function () {
    this._isAnimating = true
    var minFrameTime = 1000 / settings$1.now.maxfps
    minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime
    var self = this
    var pivot = self._gfx.pivot

    var visual = this._getComplexVisual()

    if (visual) {
      visual.resetSelectionMask()
      visual.rebuildSelectionGeometry()
      this._msgAtomInfo.style.opacity = 0.0
    }

    this._animInterval = setInterval(function () {
      self.dispatchEvent({
        type: 'mdPlayerStateChanged',
        state: {
          isPlaying: self._isAnimating,
          isLoading: self._frameInfo.isLoading
        }
      })

      if (self._frameInfo.frameIsReady) {
        pivot.updateToFrame(self._frameInfo)

        self._updateObjsToFrame(self._frameInfo)

        self._refreshTitle(
          ' Frame '
            .concat(self._frameInfo._currFrame, ' of ')
            .concat(self._frameInfo._framesCount, ' time interval - ')
            .concat(self._frameInfo._timeStep)
        )

        try {
          self._frameInfo.nextFrame()
        } catch (e) {
          self.logger.error('Error during animation')

          self._stopAnimation()

          return
        }

        self._needRender = true
      }
    }, minFrameTime)
  }

  Miew.prototype._stopAnimation = function () {
    if (this._animInterval === null) {
      return
    }

    clearInterval(this._animInterval)

    this._frameInfo.disableEvents()

    this._frameInfo = null
    this._animInterval = null
    this.dispatchEvent({
      type: 'mdPlayerStateChanged',
      state: null
    })
  }

  Miew.prototype._onLoad = function (dataSource, opts) {
    var gfx = this._gfx
    var visualName = null

    if (opts.animation) {
      this._refreshTitle()

      this._startAnimation(dataSource)

      return null
    }

    this._stopAnimation()

    if (!opts || !opts.keepRepsInfo) {
      this._opts.reps = null
      this._opts._objects = null
    }

    if (dataSource.id === 'Complex') {
      var complex = dataSource

      if (opts.fileName) {
        complex.name =
          complex.name || removeExtension(opts.fileName).toUpperCase()
      } else if (opts.amberFileName) {
        complex.name =
          complex.name || removeExtension(opts.amberFileName).toUpperCase()
      } else {
        complex.name = 'Dynamic '.concat(opts.fileType, ' molecule')
      }

      visualName = this._addVisual(new ComplexVisual(complex.name, complex))
      this._curVisualName = visualName
      var desc = this.info()
      this.logger.info(
        'Parsed '
          .concat(opts.fileName, ' (')
          .concat(desc.atoms, ' atoms, ')
          .concat(desc.bonds, ' bonds, ')
          .concat(desc.residues, ' residues, ')
          .concat(desc.chains, ' chains).')
      )

      if (___default['default'].isNumber(this._opts.unit)) {
        complex.setCurrentUnit(this._opts.unit)
      }

      if (opts.preset);
      else if (settings$1.now.autoPreset) {
        switch (opts.fileType) {
          case 'cml':
            this.resetReps('small')
            break

          case 'pdb':
          case 'mmtf':
          case 'cif':
            if (hasValidResidues(complex)) {
              this.resetReps('macro')
            } else {
              this.resetReps('small')
            }

            break

          default:
            this.resetReps('default')
            break
        }
      } else {
        this.resetReps('default')
      }
    } else if (dataSource.id === 'Volume') {
      this.resetEd()
      visualName = this._onLoadEd(dataSource)
    }

    gfx.camera.updateProjectionMatrix()

    this._updateFog()

    gfx.root.resetTransform()
    this.resetPivot()

    this._objectControls.setScale(
      settings$1.now.radiusToFit / this._getBSphereRadius()
    )

    this._resetObjects()

    if (settings$1.now.autoResolution) {
      this._tweakResolution()
    }

    if (settings$1.now.shadow.on) {
      this._updateShadowCamera()
    }

    if (this._opts.view) {
      this.view(this._opts.view)
      delete this._opts.view
    }

    this._refreshTitle()

    return visualName
  }

  Miew.prototype.resetEd = function () {
    if (this._edLoader) {
      this._edLoader.abort()

      this._edLoader = null
    }

    this._removeVisual(this._getVolumeVisual())

    this._needRender = true
  }

  Miew.prototype.loadEd = function (source) {
    var _this4 = this

    this.resetEd()

    var TheLoader = ___default['default'].head(
      io.loaders.find({
        source: source
      })
    )

    if (!TheLoader) {
      this.logger.error(LOADER_NOT_FOUND)
      return Promise.reject(new Error(LOADER_NOT_FOUND))
    }

    var loader = (this._edLoader = new TheLoader(source, {
      binary: true
    }))
    loader.context = this
    return loader
      .load()
      .then(function (data) {
        var TheParser = ___default['default'].head(
          io.parsers.find({
            format: 'ccp4'
          })
        )

        if (!TheParser) {
          throw new Error(PARSER_NOT_FOUND)
        }

        var parser = new TheParser(data)
        parser.context = _this4
        return parser.parse().then(function (dataSource) {
          _this4._onLoadEd(dataSource)
        })
      })
      .catch(function (error) {
        _this4.logger.error('Could not load ED data')

        _this4.logger.debug(error)
      })
  }

  Miew.prototype._onLoadEd = function (dataSource) {
    dataSource.normalize()
    var volumeVisual = new VolumeVisual('volume', dataSource)
    volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME)

    var visualName = this._addVisual(volumeVisual)

    this._needRender = true
    return visualName
  }

  Miew.prototype._needRebuild = function () {
    var needsRebuild = false

    this._forEachComplexVisual(function (visual) {
      needsRebuild = needsRebuild || visual.needsRebuild()
    })

    return needsRebuild
  }

  Miew.prototype._rebuildObjects = function () {
    var self = this
    var gfx = this._gfx
    var i
    var n
    var toRemove = []

    for (i = 0; i < gfx.pivot.children.length; ++i) {
      var child = gfx.pivot.children[i]

      if (!(child instanceof Visual)) {
        toRemove.push(child)
      }
    }

    for (i = 0; i < toRemove.length; ++i) {
      toRemove[i].parent.remove(toRemove[i])
    }

    setTimeout(function () {
      var objList = self._objects

      for (i = 0, n = objList.length; i < n; ++i) {
        var obj = objList[i]

        if (obj.needsRebuild) {
          obj.build()
        }

        if (obj.getGeometry()) {
          gfx.pivot.add(obj.getGeometry())
        }
      }
    }, 10)
  }

  Miew.prototype.changeUnit = function (unitIdx, name) {
    var visual = this._getComplexVisual(name)

    if (!visual) {
      throw new Error('There is no complex to change!')
    }

    function currentUnitInfo() {
      var unit = visual ? visual.getComplex().getCurrentUnit() : 0
      var type = unit > 0 ? 'Bio molecule '.concat(unit) : 'Asymmetric unit'
      return 'Current unit: '.concat(unit, ' (').concat(type, ')')
    }

    if (unitIdx === undefined) {
      return currentUnitInfo()
    }

    if (___default['default'].isString(unitIdx)) {
      unitIdx = Math.max(parseInt(unitIdx, 10), 0)
    }

    if (visual.getComplex().setCurrentUnit(unitIdx)) {
      this._resetScene()

      this._updateInfoPanel()
    }

    return currentUnitInfo()
  }

  Miew.prototype.rebuild = function () {
    var _this5 = this

    if (this._building) {
      this.logger.warn('Miew.rebuild(): already building!')
      return
    }

    this._building = true
    this.dispatchEvent({
      type: 'rebuilding'
    })

    this._rebuildObjects()

    this._gfx.renderer2d.reset()

    var rebuildActions = []

    this._forEachComplexVisual(function (visual) {
      if (visual.needsRebuild()) {
        rebuildActions.push(
          visual.rebuild().then(function () {
            return new Promise(function (resolve) {
              visual.rebuildSelectionGeometry()
              resolve()
            })
          })
        )
      }
    })

    var self = this

    this._spinner.spin(this._container)

    Promise.all(rebuildActions).then(function () {
      self._spinner.stop()

      self._needRender = true

      self._refreshTitle()

      _this5.dispatchEvent({
        type: 'buildingDone'
      })

      self._building = false
    })
  }

  Miew.prototype.rebuildAll = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setNeedsRebuild()
    })
  }

  Miew.prototype._refreshTitle = function (appendix) {
    var title
    appendix = appendix === undefined ? '' : appendix

    var visual = this._getComplexVisual()

    if (visual) {
      title = visual.getComplex().name
      var rep = visual.repGet(visual.repCurrent())
      title += rep ? ' \u2013 '.concat(rep.mode.name, ' Mode') : ''
    } else {
      title = Object.keys(this._visuals).length > 0 ? 'Unknown' : 'No Data'
    }

    title += appendix
    this.dispatchEvent({
      type: 'titleChanged',
      data: title
    })
  }

  Miew.prototype.setNeedRender = function () {
    this._needRender = true
  }

  Miew.prototype._extractRepresentation = function () {
    var _this6 = this

    var changed = []

    this._forEachComplexVisual(function (visual) {
      if (visual.getSelectionCount() === 0) {
        return
      }

      var selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit())
      var defPreset = settings$1.now.presets.default
      var res = visual.repAdd({
        selector: selector,
        mode: defPreset[0].mode.id,
        colorer: defPreset[0].colorer.id,
        material: defPreset[0].material.id
      })

      if (!res) {
        if (visual.repCount() === ComplexVisual.NUM_REPRESENTATION_BITS) {
          _this6.logger.warn(
            'Number of representations is limited to '.concat(
              ComplexVisual.NUM_REPRESENTATION_BITS
            )
          )
        }

        return
      }

      _this6.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      })

      visual.repCurrent(res.index)
      changed.push(visual.name)
    })

    if (changed.length > 0) {
      this.logger.report(
        'New representation from selection for complexes: '.concat(
          changed.join(', ')
        )
      )
    }
  }

  Miew.prototype._setReps = function (reps) {
    reps = reps || (this._opts && this._opts.reps) || []

    this._forEachComplexVisual(function (visual) {
      return visual.resetReps(reps)
    })
  }

  Miew.prototype.applyPreset = function (preset) {
    var presets = settings$1.now.presets
    var presList = [
      preset || settings$1.defaults.preset,
      settings$1.defaults.preset,
      Object.keys(presets)[0]
    ]
    var reps = null

    for (var i = 0; !reps && i < presList.length; ++i) {
      settings$1.set('preset', presList[i])
      reps = presets[settings$1.now.preset]

      if (!reps) {
        this.logger.warn('Unknown preset "'.concat(settings$1.now.preset, '"'))
      }
    }

    this._setReps(reps)
  }

  Miew.prototype.resetReps = function (preset) {
    var reps = this._opts && this._opts.reps

    if (reps) {
      this._setReps(reps)
    } else {
      this.applyPreset(preset)
    }
  }

  Miew.prototype.repCount = function (name) {
    var visual = this._getComplexVisual(name)

    return visual ? visual.repCount() : 0
  }

  Miew.prototype.repCurrent = function (index, name) {
    var visual = this._getComplexVisual(name)

    var newIdx = visual ? visual.repCurrent(index) : -1

    if (index && newIdx !== index) {
      this.logger.warn(
        'Representation '.concat(
          index,
          ' was not found. Current rep remains unchanged.'
        )
      )
    }

    return newIdx
  }

  Miew.prototype.rep = function (index, rep) {
    var visual = this._getComplexVisual('')

    if (!visual) {
      return null
    }

    var res = visual.rep(index, rep)

    if (res.status === 'created') {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: visual.name
      })
    } else if (res.status === 'changed') {
      this.dispatchEvent({
        type: 'repChanged',
        index: res.index,
        name: visual.name
      })
    }

    return res.desc
  }

  Miew.prototype.repGet = function (index, name) {
    var visual = this._getComplexVisual(name)

    return visual ? visual.repGet(index) : null
  }

  Miew.prototype.repAdd = function (rep, name) {
    var visual = this._getComplexVisual(name)

    if (!visual) {
      return -1
    }

    var res = visual.repAdd(rep)

    if (res) {
      this.dispatchEvent({
        type: 'repAdded',
        index: res.index,
        name: name
      })
      return res.index
    }

    return -1
  }

  Miew.prototype.repRemove = function (index, name) {
    var visual = this._getComplexVisual(name)

    if (!visual) {
      return
    }

    visual.repRemove(index)
    this.dispatchEvent({
      type: 'repRemoved',
      index: index,
      name: name
    })
  }

  Miew.prototype.repHide = function (index, hide, name) {
    this._needRender = true

    var visual = this._getComplexVisual(name)

    return visual ? visual.repHide(index, hide) : null
  }

  Miew.prototype._setEditMode = function (mode) {
    this._editMode = mode
    var elem = this._msgMode

    if (elem) {
      elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0.0 : 1.0

      if (mode !== EDIT_MODE.COMPLEX) {
        var t = elem.getElementsByTagName('p')[0]
        t.innerHTML =
          mode === EDIT_MODE.COMPONENT
            ? 'COMPONENT EDIT MODE'
            : 'FRAGMENT EDIT MODE'
      }
    }

    this.dispatchEvent({
      type: 'editModeChanged',
      data: mode === EDIT_MODE.COMPLEX
    })
  }

  Miew.prototype._enterComponentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return
    }

    var editors = []

    this._forEachComplexVisual(function (visual) {
      var editor = visual.beginComponentEdit()

      if (editor) {
        editors.push(editor)
      }
    })

    if (editors === []) {
      return
    }

    this._editors = editors
    this.logger.info('COMPONENT EDIT MODE -- ON')

    this._setEditMode(EDIT_MODE.COMPONENT)

    this._objectControls.keysTranslateObj(true)
  }

  Miew.prototype._applyComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return
    }

    this._objectControls.stop()

    this._objectControls.keysTranslateObj(false)

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply()
    }

    this._editors = []
    this.logger.info('COMPONENT EDIT MODE -- OFF (applied)')

    this._setEditMode(EDIT_MODE.COMPLEX)

    this.rebuildAll()
  }

  Miew.prototype._discardComponentEdit = function () {
    if (this._editMode !== EDIT_MODE.COMPONENT) {
      return
    }

    this._objectControls.stop()

    this._objectControls.keysTranslateObj(false)

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard()
    }

    this._editors = []
    this.logger.info('COMPONENT EDIT MODE -- OFF (discarded)')

    this._setEditMode(EDIT_MODE.COMPLEX)

    this._needRender = true
    this.rebuildAll()
  }

  Miew.prototype._enterFragmentEditMode = function () {
    if (this._editMode !== EDIT_MODE.COMPLEX) {
      return
    }

    var selectedVisuals = []

    this._forEachComplexVisual(function (visual) {
      if (visual instanceof ComplexVisual && visual.getSelectionCount() > 0) {
        selectedVisuals.push(visual)
      }
    })

    if (selectedVisuals.length !== 1) {
      return
    }

    var editor = selectedVisuals[0].beginFragmentEdit()

    if (!editor) {
      return
    }

    this._editors = [editor]
    this.logger.info('FRAGMENT EDIT MODE -- ON (single bond)')

    this._setEditMode(EDIT_MODE.FRAGMENT)

    this._objectControls.allowTranslation(false)

    this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed())

    this._needRender = true
  }

  Miew.prototype._applyFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return
    }

    this._objectControls.stop()

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].apply()
    }

    this._editors = []
    this.logger.info('FRAGMENT EDIT MODE -- OFF (applied)')

    this._setEditMode(EDIT_MODE.COMPLEX)

    this._objectControls.allowTranslation(true)

    this._objectControls.allowAltObjFreeRotation(true)

    this.rebuildAll()
  }

  Miew.prototype._discardFragmentEdit = function () {
    if (this._editMode !== EDIT_MODE.FRAGMENT) {
      return
    }

    this._objectControls.stop()

    for (var i = 0; i < this._editors.length; ++i) {
      this._editors[i].discard()
    }

    this._editors = []
    this.logger.info('FRAGMENT EDIT MODE -- OFF (discarded)')

    this._setEditMode(EDIT_MODE.COMPLEX)

    this._objectControls.allowTranslation(true)

    this._objectControls.allowAltObjFreeRotation(true)

    this._needRender = true
  }

  Miew.prototype._onPick = function (event) {
    if (!settings$1.now.picking) {
      return
    }

    if (this._animInterval !== null) {
      return
    }

    if (this._editMode === EDIT_MODE.FRAGMENT) {
      return
    }

    if (this._objectControls.isEditingAltObj()) {
      return
    }

    var complex = null

    if (event.obj.atom) {
      complex = event.obj.atom.residue.getChain().getComplex()
      this._lastPick = event.obj.atom
    } else if (event.obj.residue) {
      complex = event.obj.residue.getChain().getComplex()
      this._lastPick = event.obj.residue
    } else if (event.obj.chain) {
      complex = event.obj.chain.getComplex()
      this._lastPick = event.obj.chain
    } else if (event.obj.molecule) {
      complex = event.obj.molecule.complex
      this._lastPick = event.obj.molecule
    } else {
      this._lastPick = null
    }

    function _updateSelection(visual) {
      visual.updateSelectionMask(event.obj)
      visual.rebuildSelectionGeometry()
    }

    if (complex) {
      var visual = this._getVisualForComplex(complex)

      if (visual) {
        _updateSelection(visual)

        this._needRender = true
      }
    } else {
      this._forEachComplexVisual(_updateSelection)

      this._needRender = true
    }

    this._updateInfoPanel()

    this.dispatchEvent(event)
  }

  Miew.prototype._onKeyDown = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return
    }

    switch (event.keyCode) {
      case 'C'.charCodeAt(0):
        if (settings$1.now.editing) {
          this._enterComponentEditMode()
        }

        break

      case 'F'.charCodeAt(0):
        if (settings$1.now.editing) {
          this._enterFragmentEditMode()
        }

        break

      case 'A'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._applyComponentEdit()

            break

          case EDIT_MODE.FRAGMENT:
            this._applyFragmentEdit()

            break
        }

        break

      case 'D'.charCodeAt(0):
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._discardComponentEdit()

            break

          case EDIT_MODE.FRAGMENT:
            this._discardFragmentEdit()

            break
        }

        break

      case 'S'.charCodeAt(0):
        event.preventDefault()
        event.stopPropagation()
        settings$1.set('ao', !settings$1.now.ao)
        this._needRender = true
        break

      case 107:
        event.preventDefault()
        event.stopPropagation()

        this._forEachComplexVisual(function (visual) {
          visual.expandSelection()
          visual.rebuildSelectionGeometry()
        })

        this._updateInfoPanel()

        this._needRender = true
        break

      case 109:
        event.preventDefault()
        event.stopPropagation()

        this._forEachComplexVisual(function (visual) {
          visual.shrinkSelection()
          visual.rebuildSelectionGeometry()
        })

        this._updateInfoPanel()

        this._needRender = true
        break
    }
  }

  Miew.prototype._onKeyUp = function (event) {
    if (!this._running || !this._hotKeysEnabled) {
      return
    }

    if (event.keyCode === 'X'.charCodeAt(0)) {
      this._extractRepresentation()
    }
  }

  Miew.prototype._updateInfoPanel = function () {
    var info = this._msgAtomInfo.getElementsByTagName('p')[0]

    var atom
    var residue
    var count = 0

    this._forEachComplexVisual(function (visual) {
      count += visual.getSelectionCount()
    })

    while (info.firstChild) {
      info.removeChild(info.firstChild)
    }

    if (count === 0) {
      this._msgAtomInfo.style.opacity = 0.0
      return
    }

    var firstLine = ''
      .concat(String(count), ' atom')
      .concat(count !== 1 ? 's' : '', ' selected')

    if (this._lastPick !== null) {
      firstLine += ', the last pick:'
    }

    var secondLine = ''
    var aName = ''
    var coordLine = ''

    if (this._lastPick instanceof Atom) {
      atom = this._lastPick
      residue = atom.residue
      aName = atom.name
      var location =
        atom.location !== 32 ? String.fromCharCode(atom.location) : ''
      secondLine = ''
        .concat(atom.element.fullName, ' #')
        .concat(atom.serial)
        .concat(location, ':       ')
        .concat(residue._chain._name, '.')
        .concat(residue._type._name)
        .concat(residue._sequence)
        .concat(residue._icode.trim(), '.')
      secondLine += aName
      coordLine = 'Coord: ('
        .concat(atom.position.x.toFixed(2).toString(), ',     ')
        .concat(atom.position.y.toFixed(2).toString(), ',     ')
        .concat(atom.position.z.toFixed(2).toString(), ')')
    } else if (this._lastPick instanceof Residue) {
      residue = this._lastPick
      secondLine = ''
        .concat(residue._type._fullName, ':       ')
        .concat(residue._chain._name, '.')
        .concat(residue._type._name)
        .concat(residue._sequence)
        .concat(residue._icode.trim())
    } else if (this._lastPick instanceof Chain) {
      secondLine = 'chain '.concat(this._lastPick._name)
    } else if (this._lastPick instanceof Molecule) {
      secondLine = 'molecule '.concat(this._lastPick._name)
    }

    info.appendChild(document.createTextNode(firstLine))

    if (secondLine !== '') {
      info.appendChild(document.createElement('br'))
      info.appendChild(document.createTextNode(secondLine))
    }

    if (coordLine !== '') {
      info.appendChild(document.createElement('br'))
      info.appendChild(document.createTextNode(coordLine))
    }

    this._msgAtomInfo.style.opacity = 1.0
  }

  Miew.prototype._getAltObj = function () {
    if (this._editors) {
      var altObj = null

      for (var i = 0; i < this._editors.length; ++i) {
        var nextAltObj = this._editors[i].getAltObj()

        if (nextAltObj.objects.length > 0) {
          if (altObj) {
            altObj = null
            break
          }

          altObj = nextAltObj
        }
      }

      if (altObj) {
        return altObj
      }
    }

    return {
      objects: [],
      pivot: new THREE__namespace.Vector3(0, 0, 0)
    }
  }

  Miew.prototype.resetPivot = (function () {
    var boundingBox = new THREE__namespace.Box3()
    var center = new THREE__namespace.Vector3()
    return function () {
      boundingBox.makeEmpty()

      this._forEachVisual(function (visual) {
        boundingBox.union(visual.getBoundaries().boundingBox)
      })

      boundingBox.getCenter(center)

      this._objectControls.setPivot(center.negate())

      this.dispatchEvent({
        type: 'transform'
      })
    }
  })()

  Miew.prototype.setPivotResidue = (function () {
    var center = new THREE__namespace.Vector3()
    return function (residue) {
      var visual = this._getVisualForComplex(residue.getChain().getComplex())

      if (!visual) {
        return
      }

      if (residue._controlPoint) {
        center.copy(residue._controlPoint)
      } else {
        var x = 0
        var y = 0
        var z = 0
        var amount = residue._atoms.length

        for (var i = 0; i < amount; ++i) {
          var p = residue._atoms[i].position
          x += p.x / amount
          y += p.y / amount
          z += p.z / amount
        }

        center.set(x, y, z)
      }

      center.applyMatrix4(visual.matrix).negate()

      this._objectControls.setPivot(center)

      this.dispatchEvent({
        type: 'transform'
      })
    }
  })()

  Miew.prototype.setPivotAtom = (function () {
    var center = new THREE__namespace.Vector3()
    return function (atom) {
      var visual = this._getVisualForComplex(
        atom.residue.getChain().getComplex()
      )

      if (!visual) {
        return
      }

      center.copy(atom.position)
      center.applyMatrix4(visual.matrix).negate()

      this._objectControls.setPivot(center)

      this.dispatchEvent({
        type: 'transform'
      })
    }
  })()

  Miew.prototype.getSelectionCenter = (function () {
    var _centerInVisual = new THREE__namespace.Vector3(0.0, 0.0, 0.0)

    return function (center, includesAtom, selector) {
      center.set(0.0, 0.0, 0.0)
      var count = 0

      this._forEachComplexVisual(function (visual) {
        if (
          visual.getSelectionCenter(
            _centerInVisual,
            includesAtom,
            selector || visual.getSelectionBit()
          )
        ) {
          center.add(_centerInVisual)
          count++
        }
      })

      if (count === 0) {
        return false
      }

      center.divideScalar(count)
      center.negate()
      return true
    }
  })()

  Miew.prototype.setPivotSubset = (function () {
    var _center = new THREE__namespace.Vector3(0.0, 0.0, 0.0)

    function _includesInCurSelection(atom, selectionBit) {
      return atom.mask & (1 << selectionBit)
    }

    function _includesInSelector(atom, selector) {
      return selector.selector.includesAtom(atom)
    }

    return function (selector) {
      var includesAtom = selector
        ? _includesInSelector
        : _includesInCurSelection

      if (this.getSelectionCenter(_center, includesAtom, selector)) {
        this._objectControls.setPivot(_center)

        this.dispatchEvent({
          type: 'transform'
        })
      } else {
        this.logger.warn('selection is empty. Center operation not performed')
      }
    }
  })()

  Miew.prototype.screenshot = function (width, height) {
    var gfx = this._gfx
    var deviceWidth = gfx.renderer.domElement.width
    var deviceHeight = gfx.renderer.domElement.height

    function fov2Tan(fov) {
      return Math.tan(THREE__namespace.MathUtils.degToRad(0.5 * fov))
    }

    function tan2Fov(tan) {
      return THREE__namespace.MathUtils.radToDeg(Math.atan(tan)) * 2.0
    }

    function getDataURL() {
      var dataURL
      var currBrowser = utils.getBrowser()

      if (currBrowser === utils.browserType.SAFARI) {
        var canvas = document.createElement('canvas')
        var canvasContext = canvas.getContext('2d')
        canvas.width = width === undefined ? deviceWidth : width
        canvas.height = height === undefined ? deviceHeight : height
        canvasContext.drawImage(
          gfx.renderer.domElement,
          0,
          0,
          canvas.width,
          canvas.height
        )
        dataURL = canvas.toDataURL('image/png')
      } else {
        dataURL = gfx.renderer.domElement.toDataURL('image/png')
      }

      return dataURL
    }

    height = height || width
    var screenshotURI

    if (
      (width === undefined && height === undefined) ||
      (width === deviceWidth && height === deviceHeight)
    ) {
      screenshotURI = getDataURL()
    } else {
      var originalAspect = gfx.camera.aspect
      var originalFov = gfx.camera.fov
      var originalTanFov2 = fov2Tan(gfx.camera.fov)
      var areaOfInterestSize = Math.min(gfx.width, gfx.height)
      var areaOfInterestTanFov2 =
        (originalTanFov2 * areaOfInterestSize) / gfx.height
      var shotAspect = width / height
      gfx.renderer.setPixelRatio(1)
      gfx.camera.aspect = shotAspect
      gfx.camera.fov = tan2Fov(
        areaOfInterestTanFov2 / Math.min(shotAspect, 1.0)
      )
      gfx.camera.updateProjectionMatrix()
      gfx.renderer.setDrawingBufferSize(width, height, 1)

      this._renderFrame(settings$1.now.stereo)

      screenshotURI = getDataURL()
      gfx.renderer.setPixelRatio(window.devicePixelRatio)
      gfx.camera.aspect = originalAspect
      gfx.camera.fov = originalFov
      gfx.camera.updateProjectionMatrix()
      gfx.renderer.setDrawingBufferSize(
        gfx.width,
        gfx.height,
        window.devicePixelRatio
      )
      this._needRender = true
    }

    return screenshotURI
  }

  Miew.prototype.screenshotSave = function (filename, width, height) {
    var uri = this.screenshot(width, height)
    utils.shotDownload(uri, filename)
  }

  Miew.prototype.save = function (opts) {
    var _this7 = this

    this._export(opts.fileType)
      .then(function (dataString) {
        var filename = _this7._visuals[_this7._curVisualName]._complex.name
        utils.download(dataString, filename, opts.fileType)

        _this7._refreshTitle()

        _this7.dispatchEvent({
          type: 'exportingDone'
        })
      })
      .catch(function (error) {
        _this7.logger.error('Could not export data')

        _this7.logger.debug(error)

        _this7._refreshTitle()

        _this7.dispatchEvent({
          type: 'exportingDone',
          error: error
        })
      })
  }

  Miew.prototype._tweakResolution = function () {
    var maxPerf = [
      ['poor', 100],
      ['low', 500],
      ['medium', 1000],
      ['high', 5000],
      ['ultra', Number.MAX_VALUE]
    ]
    var atomCount = 0

    this._forEachComplexVisual(function (visual) {
      atomCount += visual.getComplex().getAtomCount()
    })

    if (atomCount > 0) {
      var performance = (this._gfxScore * 10e5) / atomCount

      for (var i = 0; i < maxPerf.length; ++i) {
        if (performance < maxPerf[i][1]) {
          this._autoChangeResolution(maxPerf[i][0])

          break
        }
      }
    }
  }

  Miew.prototype._autoChangeResolution = function (resolution) {
    if (resolution !== settings$1.now.resolution) {
      this.logger.report(
        'Your rendering resolution was changed to "'.concat(
          resolution,
          '" for best performance.'
        )
      )
    }

    settings$1.now.resolution = resolution
  }

  Miew.prototype.saveSettings = function () {
    this._cookies.setCookie(
      this._opts.settingsCookie,
      JSON.stringify(this.settings.getDiffs(true))
    )
  }

  Miew.prototype.restoreSettings = function () {
    try {
      var cookie = this._cookies.getCookie(this._opts.settingsCookie)

      var diffs = cookie ? JSON.parse(cookie) : {}
      this.settings.applyDiffs(diffs, true)
    } catch (e) {
      this.logger.error('Cookies parse error: '.concat(e.message))
    }
  }

  Miew.prototype.resetSettings = function () {
    this.settings.reset()
  }

  Miew.prototype.setOptions = function (opts) {
    if (typeof opts === 'string') {
      opts = Miew.options.fromAttr(opts)
    }

    if (opts.reps) {
      this._opts.reps = null
    }

    ___default['default'].merge(this._opts, opts)

    if (opts.settings) {
      this.set(opts.settings)
    }

    this._opts._objects = opts._objects

    this._resetObjects()

    if (opts.load) {
      this.load(opts.load, {
        fileType: opts.type
      })
    }

    if (opts.preset) {
      settings$1.now.preset = opts.preset
    }

    if (opts.reps) {
      this.resetReps(opts.preset)
    }

    if (this._opts.view) {
      this.view(this._opts.view)
      delete this._opts.view
    }

    var visual = this._getComplexVisual()

    if (visual) {
      visual.getComplex().resetCurrentUnit()

      if (___default['default'].isNumber(opts.unit)) {
        visual.getComplex().setCurrentUnit(opts.unit)
      }

      this.resetView()
      this.rebuildAll()
    }
  }

  Miew.prototype.info = function (name) {
    var visual = this._getComplexVisual(name)

    if (!visual) {
      return {}
    }

    var complex = visual.getComplex()
    var metadata = complex.metadata
    return {
      id: metadata.id || complex.name || 'UNKNOWN',
      title: (metadata.title && metadata.title.join(' ')) || 'UNKNOWN DATA',
      atoms: complex.getAtomCount(),
      bonds: complex.getBondCount(),
      residues: complex.getResidueCount(),
      chains: complex.getChainCount()
    }
  }

  Miew.prototype.addObject = function (objData, bThrow) {
    var Ctor = null

    if (objData.type === LinesObj.prototype.type) {
      Ctor = LinesObj
    }

    if (Ctor === null) {
      throw new Error('Unknown scene object type - '.concat(objData.type))
    }

    try {
      var newObj = new Ctor(objData.params, objData.opts)

      this._addSceneObject(newObj)
    } catch (error) {
      if (!bThrow) {
        this.logger.debug(
          'Error during scene object creation: '.concat(error.message)
        )
      } else {
        throw error
      }
    }

    this._needRender = true
  }

  Miew.prototype._addSceneObject = function (sceneObject) {
    var visual = this._getComplexVisual()

    if (sceneObject.build && visual) {
      sceneObject.build(visual.getComplex())

      this._gfx.pivot.add(sceneObject.getGeometry())
    }

    var objects = this._objects
    objects[objects.length] = sceneObject
  }

  Miew.prototype._updateObjsToFrame = function (frameData) {
    var objs = this._objects

    for (var i = 0, n = objs.length; i < n; ++i) {
      if (objs[i].updateToFrame) {
        objs[i].updateToFrame(frameData)
      }
    }
  }

  Miew.prototype._resetObjects = function () {
    var objs = this._opts._objects
    this._objects = []

    if (objs) {
      for (var i = 0, n = objs.length; i < n; ++i) {
        this.addObject(objs[i], false)
      }
    }
  }

  Miew.prototype.removeObject = function (index) {
    var obj = this._objects[index]

    if (!obj) {
      throw new Error(
        'Scene object with index '.concat(index, ' does not exist')
      )
    }

    obj.destroy()

    this._objects.splice(index, 1)

    this._needRender = true
  }

  Miew.prototype.getURL = function (opts) {
    return options$1.toURL(
      this.getState(
        ___default['default'].defaults(opts, {
          compact: true,
          settings: false,
          view: false
        })
      )
    )
  }

  Miew.prototype.getScript = function (opts) {
    return options$1.toScript(
      this.getState(
        ___default['default'].defaults(opts, {
          compact: true,
          settings: true,
          view: true
        })
      )
    )
  }

  Miew.prototype._compareReps = function (complexVisual, compareWithDefaults) {
    var ans = {}
    var repCount = 0

    if (complexVisual) {
      repCount = complexVisual.repCount()
    }

    var currPreset = settings$1.defaults.presets[settings$1.now.preset]
    var compare = compareWithDefaults

    if (currPreset === undefined || currPreset.length > repCount) {
      compare = false
      ans.preset = 'empty'
    } else if (settings$1.now.preset !== settings$1.defaults.preset) {
      ans.preset = settings$1.now.preset
    }

    var repsDiff = []
    var emptyReps = true

    for (var i = 0, n = repCount; i < n; ++i) {
      repsDiff[i] = complexVisual
        .repGet(i)
        .compare(compare ? currPreset[i] : null)

      if (!___default['default'].isEmpty(repsDiff[i])) {
        emptyReps = false
      }
    }

    if (!emptyReps) {
      ans.reps = repsDiff
    }

    return ans
  }

  Miew.prototype.getState = function (opts) {
    var state = {}
    opts = ___default['default'].defaults(opts, {
      compact: true,
      settings: false,
      view: false
    })

    var visual = this._getComplexVisual()

    if (visual !== null) {
      var complex = visual.getComplex()
      var metadata = complex.metadata

      if (metadata.id) {
        var format = metadata.format ? ''.concat(metadata.format, ':') : ''
        state.load = format + metadata.id
      }

      var unit = complex.getCurrentUnit()

      if (unit !== 1) {
        state.unit = unit
      }
    }

    var repsInfo = this._compareReps(visual, opts.compact)

    if (repsInfo.preset) {
      state.preset = repsInfo.preset
    }

    if (repsInfo.reps) {
      state.reps = repsInfo.reps
    }

    var objects = this._objects
    var objectsState = []

    for (var i = 0, n = objects.length; i < n; ++i) {
      objectsState[i] = objects[i].identify()
    }

    if (objects.length > 0) {
      state._objects = objectsState
    }

    if (opts.view) {
      state.view = this.view()
    }

    if (opts.settings) {
      var diff = this.settings.getDiffs(false)

      if (!___default['default'].isEmpty(diff)) {
        state.settings = diff
      }
    }

    return state
  }

  Miew.prototype.get = function (param, value) {
    return settings$1.get(param, value)
  }

  Miew.prototype._clipPlaneUpdateValue = function (radius) {
    var clipPlaneValue = Math.max(
      this._gfx.camera.position.z -
        radius * settings$1.now.draft.clipPlaneFactor,
      settings$1.now.camNear
    )
    var opts = {
      clipPlaneValue: clipPlaneValue
    }

    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions(opts)
    })

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i]

      if (obj._line) {
        obj._line.material.setUberOptions(opts)
      }
    }

    if (this._picker !== null) {
      this._picker.clipPlaneValue = clipPlaneValue
    }
  }

  Miew.prototype._fogFarUpdateValue = function () {
    if (this._picker !== null) {
      if (this._gfx.scene.fog) {
        this._picker.fogFarValue = this._gfx.scene.fog.far
      } else {
        this._picker.fogFarValue = undefined
      }
    }
  }

  Miew.prototype._updateShadowmapMeshes = function (process) {
    this._forEachComplexVisual(function (visual) {
      var reprList = visual._reprList

      for (var i = 0, n = reprList.length; i < n; ++i) {
        var repr = reprList[i]
        process(repr.geo, repr.material)
      }
    })
  }

  Miew.prototype._updateMaterials = function (values) {
    var needTraverse =
      arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false
    var process =
      arguments.length > 2 && arguments[2] !== undefined
        ? arguments[2]
        : undefined

    this._forEachComplexVisual(function (visual) {
      return visual.setMaterialValues(values, needTraverse, process)
    })

    for (var i = 0, n = this._objects.length; i < n; ++i) {
      var obj = this._objects[i]

      if (obj._line) {
        obj._line.material.setValues(values)

        obj._line.material.needsUpdate = true
      }
    }
  }

  Miew.prototype._fogAlphaChanged = function () {
    this._forEachComplexVisual(function (visual) {
      visual.setUberOptions({
        fogAlpha: settings$1.now.fogAlpha
      })
    })
  }

  Miew.prototype._embedWebXR = function () {
    var _this8 = this

    if (settings$1.now.stereo !== 'WEBVR') {
      if (this.webVR) {
        this.webVR.disable()
      }

      this.webVR = null
      return
    }

    if (!this.webVR) {
      this.webVR = new WebVRPoC(function () {
        _this8._requestAnimationFrame(function () {
          return _this8._onTick()
        })

        _this8._needRender = true

        _this8._onResize()
      })
    }

    this.webVR.enable(this._gfx)
  }

  Miew.prototype._initOnSettingsChanged = function () {
    var _this9 = this

    var on = function on(props, func) {
      props = ___default['default'].isArray(props) ? props : [props]
      props.forEach(function (prop) {
        _this9.settings.addEventListener('change:'.concat(prop), func)
      })
    }

    on('modes.VD.frame', function () {
      var volume = _this9._getVolumeVisual()

      if (volume === null) return
      volume.showFrame(settings$1.now.modes.VD.frame)
      _this9._needRender = true
    })
    on('modes.VD.isoMode', function () {
      var volume = _this9._getVolumeVisual()

      if (volume === null) return
      volume.getMesh().material.updateDefines()
      _this9._needRender = true
    })
    on('bg.color', function () {
      _this9._onBgColorChanged()
    })
    on('ao', function () {
      if (
        settings$1.now.ao &&
        !isAOSupported(_this9._gfx.renderer.getContext())
      ) {
        _this9.logger.warn('Your device or browser does not support ao')

        settings$1.set('ao', false)
      } else {
        var values = {
          normalsToGBuffer: settings$1.now.ao
        }

        _this9._setUberMaterialValues(values)
      }
    })
    on('zSprites', function () {
      if (
        settings$1.now.zSprites &&
        !arezSpritesSupported(_this9._gfx.renderer.getContext())
      ) {
        _this9.logger.warn('Your device or browser does not support zSprites')

        settings$1.set('zSprites', false)
      }

      _this9.rebuildAll()
    })
    on('fogColor', function () {
      _this9._onFogColorChanged()
    })
    on('fogColorEnable', function () {
      _this9._onFogColorChanged()
    })
    on('bg.transparent', function (evt) {
      var gfx = _this9._gfx

      if (gfx) {
        gfx.renderer.setClearColor(
          settings$1.now.bg.color,
          Number(!settings$1.now.bg.transparent)
        )
      }

      _this9._updateMaterials({
        fogTransparent: evt.value
      })

      _this9.rebuildAll()
    })
    on('draft.clipPlane', function (evt) {
      _this9._updateMaterials({
        clipPlane: evt.value
      })

      _this9.rebuildAll()
    })
    on('shadow.on', function (evt) {
      var values = {
        shadowmap: evt.value,
        shadowmapType: settings$1.now.shadow.type
      }
      var gfx = _this9._gfx

      if (gfx) {
        gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap)
      }

      _this9._updateMaterials(values, true)

      if (values.shadowmap) {
        _this9._updateShadowCamera()

        _this9._updateShadowmapMeshes(meshutils.createShadowmapMaterial)
      } else {
        _this9._updateShadowmapMeshes(meshutils.removeShadowmapMaterial)
      }

      _this9._needRender = true
    })
    on('shadow.type', function (evt) {
      if (settings$1.now.shadow.on) {
        _this9._updateMaterials(
          {
            shadowmapType: evt.value
          },
          true
        )

        _this9._needRender = true
      }
    })
    on('shadow.radius', function (evt) {
      for (var i = 0; i < _this9._gfx.scene.children.length; i++) {
        if (_this9._gfx.scene.children[i].shadow !== undefined) {
          var light = _this9._gfx.scene.children[i]
          light.shadow.radius = evt.value
          _this9._needRender = true
        }
      }
    })
    on('fps', function () {
      _this9._fps.show(settings$1.now.fps)
    })
    on(['fog', 'fogNearFactor', 'fogFarFactor'], function () {
      _this9._updateFog()

      _this9._needRender = true
    })
    on('fogAlpha', function () {
      var fogAlpha = settings$1.now.fogAlpha

      if (fogAlpha < 0 || fogAlpha > 1) {
        _this9.logger.warn('fogAlpha must belong range [0,1]')
      }

      _this9._fogAlphaChanged()

      _this9._needRender = true
    })
    on('autoResolution', function (evt) {
      if (evt.value && !_this9._gfxScore) {
        _this9.logger.warn(
          'Benchmarks are missed, autoresolution will not work! ' +
            'Autoresolution should be set during miew startup.'
        )
      }
    })
    on('stereo', function () {
      _this9._embedWebXR(settings$1.now.stereo === 'WEBVR')

      _this9._needRender = true
    })
    on(['transparency', 'palette'], function () {
      _this9.rebuildAll()
    })
    on('resolution', function () {
      _this9.rebuildAll()

      var volume = _this9._getVolumeVisual()

      if (volume) {
        volume.getMesh().material.updateDefines()
        _this9._needRender = true
      }
    })
    on(
      [
        'axes',
        'fxaa',
        'ao',
        'outline.on',
        'outline.color',
        'outline.threshold',
        'outline.thickness'
      ],
      function () {
        _this9._needRender = true
      }
    )
  }

  Miew.prototype.set = function (params, value) {
    settings$1.set(params, value)
  }

  Miew.prototype.select = function (expression, append) {
    var visual = this._getComplexVisual()

    if (!visual) {
      return
    }

    var sel = expression

    if (___default['default'].isString(expression)) {
      sel = selectors$1.parse(expression).selector
    }

    visual.select(sel, append)
    this._lastPick = null

    this._updateInfoPanel()

    this._needRender = true
  }

  var VIEW_VERSION = '1'

  Miew.prototype.view = function (expression) {
    var self = this
    var pivot = this._gfx.pivot
    var transform = []
    var eulerOrder = 'ZXY'

    function encode() {
      var pos = pivot.position
      var scale = self._objectControls.getScale() / settings$1.now.radiusToFit
      var euler = new THREE__namespace.Euler()
      euler.setFromQuaternion(self._objectControls.getOrientation(), eulerOrder)
      transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z]
      return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array)
    }

    function decode() {
      if (expression.length === 40) {
        expression = '0'.concat(expression)
      }

      var version = expression[0]
      transform = utils.arrayFromBase64(expression.substr(1), Float32Array)

      if (version !== VIEW_VERSION) {
        if (version === '0') {
          transform[3] /= 8.0
        } else {
          self.logger.warn(
            'Encoded view version mismatch, stored as '
              .concat(version, ' vs ')
              .concat(VIEW_VERSION, ' expected')
          )
          return
        }
      }

      var interpolator = self._interpolator
      var srcView = interpolator.createView()
      srcView.position.copy(pivot.position)
      srcView.scale = self._objectControls.getScale()
      srcView.orientation.copy(self._objectControls.getOrientation())
      var dstView = interpolator.createView()
      dstView.position.set(transform[0], transform[1], transform[2])

      if (self._getComplexVisual()) {
        dstView.position.sub(self._getComplexVisual().position)
      }

      dstView.scale = transform[3]
      dstView.orientation.setFromEuler(
        new THREE__namespace.Euler(
          transform[4],
          transform[5],
          transform[6],
          eulerOrder
        )
      )
      interpolator.setup(srcView, dstView)
    }

    if (typeof expression === 'undefined') {
      return encode()
    }

    decode()
    return expression
  }

  Miew.prototype._updateView = function () {
    var self = this
    var pivot = this._gfx.pivot
    var interpolator = this._interpolator

    if (!interpolator.wasStarted()) {
      interpolator.start()
    }

    if (!interpolator.isMoving()) {
      return
    }

    var res = interpolator.getCurrentView()

    if (res.success) {
      var curr = res.view
      pivot.position.copy(curr.position)

      self._objectControls.setScale(curr.scale * settings$1.now.radiusToFit)

      self._objectControls.setOrientation(curr.orientation)

      this.dispatchEvent({
        type: 'transform'
      })
      self._needRender = true
    }
  }

  Miew.prototype.translate = function (x, y, z) {
    this._objectControls.translatePivot(x, y, z)

    this.dispatchEvent({
      type: 'transform'
    })
    this._needRender = true
  }

  Miew.prototype.rotate = function (x, y, z) {
    this._objectControls.rotate(
      new THREE__namespace.Quaternion().setFromEuler(
        new THREE__namespace.Euler(x, y, z, 'XYZ')
      )
    )

    this.dispatchEvent({
      type: 'transform'
    })
    this._needRender = true
  }

  Miew.prototype.scale = function (factor) {
    if (factor <= 0) {
      throw new RangeError('Scale should be greater than zero')
    }

    this._objectControls.scale(factor)

    this.dispatchEvent({
      type: 'transform'
    })
    this._needRender = true
  }

  Miew.prototype.center = function (selector) {
    if (selector === undefined) {
      this.setPivotSubset()
      this._needRender = true
      return
    }

    if (
      selector.obj !== undefined &&
      ('atom' in selector.obj || 'residue' in selector.obj)
    ) {
      if ('atom' in selector.obj) {
        this.setPivotAtom(selector.obj.atom)
      } else {
        this.setPivotResidue(selector.obj.residue)
      }

      this._needRender = true
      return
    }

    if (selector.obj === undefined && selector !== '') {
      var sel = selectors$1.parse(selector)

      if (sel.error === undefined) {
        this.setPivotSubset(sel)
        this._needRender = true
        return
      }
    }

    this.resetPivot()
    this._needRender = true
  }

  Miew.prototype.within = function (selector, radius) {
    var visual = this._getComplexVisual()

    if (!visual) {
      return selectors$1.None()
    }

    if (selector instanceof String) {
      selector = selectors$1.parse(selector)
    }

    var res = visual.within(selector, radius)

    if (res) {
      visual.rebuildSelectionGeometry()
      this._needRender = true
    }

    return res
  }

  Miew.prototype.projected = function (fullAtomName, complexName) {
    var visual = this._getComplexVisual(complexName)

    if (!visual) {
      return false
    }

    var atom = visual.getComplex().getAtomByFullname(fullAtomName)

    if (atom === null) {
      return false
    }

    var pos = atom.position.clone()

    this._gfx.pivot.updateMatrixWorldRecursive()

    this._gfx.camera.updateMatrixWorldRecursive()

    this._gfx.pivot.localToWorld(pos)

    pos.project(this._gfx.camera)
    return {
      x: (pos.x + 1.0) * 0.5 * this._gfx.width,
      y: (1.0 - pos.y) * 0.5 * this._gfx.height
    }
  }

  Miew.prototype.dssp = function (complexName) {
    var visual = this._getComplexVisual(complexName)

    if (!visual) {
      return
    }

    visual.getComplex().dssp()

    visual._reprList.forEach(function (rep) {
      if (rep.mode.id === 'CA' || rep.colorer.id === 'SS') {
        rep.needsRebuild = true
      }
    })
  }

  Miew.prototype.exportCML = function () {
    var self = this

    function extractRotation(m) {
      var xAxis = new THREE__namespace.Vector3()
      var yAxis = new THREE__namespace.Vector3()
      var zAxis = new THREE__namespace.Vector3()
      m.extractBasis(xAxis, yAxis, zAxis)
      xAxis.normalize()
      yAxis.normalize()
      zAxis.normalize()
      var retMat = new THREE__namespace.Matrix4()
      retMat.identity()
      retMat.makeBasis(xAxis, yAxis, zAxis)
      return retMat
    }

    function updateCMLData(complex) {
      var root = self._gfx.root
      var mat = extractRotation(root.matrixWorld)
      var v4 = new THREE__namespace.Vector4(0, 0, 0, 0)
      var vCenter = new THREE__namespace.Vector4(0, 0, 0, 0)
      var xml = null
      var ap = null
      complex.forEachAtom(function (atom) {
        if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
          xml = atom.xmlNodeRef.xmlNode
          ap = atom.position
          v4.set(ap.x, ap.y, ap.z, 1.0)
          v4.applyMatrix4(mat)
          xml.setAttribute('x3', v4.x.toString())
          xml.setAttribute('y3', v4.y.toString())
          xml.setAttribute('z3', v4.z.toString())
          xml.removeAttribute('x2')
          xml.removeAttribute('y2')
        }
      })
      complex.forEachSGroup(function (sGroup) {
        if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
          xml = sGroup.xmlNodeRef.xmlNode
          ap = sGroup.getPosition()
          v4.set(ap.x, ap.y, ap.z, 1.0)
          var cp = sGroup.getCentralPoint()

          if (cp === null) {
            v4.applyMatrix4(mat)
          } else {
            vCenter.set(cp.x, cp.y, cp.z, 0.0)
            v4.add(vCenter)
            v4.applyMatrix4(mat)
            vCenter.set(cp.x, cp.y, cp.z, 1.0)
            vCenter.applyMatrix4(mat)
            v4.sub(vCenter)
          }

          xml.setAttribute('x', v4.x.toString())
          xml.setAttribute('y', v4.y.toString())
          xml.setAttribute('z', v4.z.toString())
        }
      })
    }

    var visual = self._getComplexVisual()

    var complex = visual ? visual.getComplex() : null

    if (complex && complex.originalCML) {
      updateCMLData(complex)
      var oSerializer = new XMLSerializer()
      return oSerializer.serializeToString(complex.originalCML)
    }

    return null
  }

  Miew.prototype.motm = function () {
    settings$1.set({
      fogColorEnable: true,
      fogColor: 0x000000,
      outline: {
        on: true,
        threshold: 0.01
      },
      bg: {
        color: 0xffffff
      }
    })

    this._forEachComplexVisual(function (visual) {
      var rep = []
      var complex = visual.getComplex()
      var palette = palettes$1.get(settings$1.now.palette)

      for (var i = 0; i < complex.getChainCount(); i++) {
        var curChainName = complex._chains[i]._name
        var curChainColor = palette.getChainColor(curChainName)
        rep[i] = {
          selector: 'chain '.concat(curChainName),
          mode: 'VW',
          colorer: [
            'CB',
            {
              color: curChainColor,
              factor: 0.9
            }
          ],
          material: 'FL'
        }
      }

      visual.resetReps(rep)
    })
  }

  Miew.prototype.VERSION = '0.9.0+20211216.160330.c86743d-mod'

  ___default['default'].assign(Miew, {
    VERSION: Miew.prototype.VERSION,
    registeredPlugins: [],
    chem: chem,
    io: io,
    modes: modes$1,
    colorers: colorers$1,
    materials: materials$1,
    palettes: palettes$1,
    options: options$1,
    settings: settings$1,
    utils: utils,
    gfx: {
      Representation: Representation
    },
    thirdParty: {
      lodash: ___default['default'],
      three: THREE__namespace
    }
  })

  var parser = (function () {
    var o = function (k, v, o, l) {
        for (o = o || {}, l = k.length; l--; o[k[l]] = v);
        return o
      },
      $V0 = [1, 60],
      $V1 = [1, 62],
      $V2 = [1, 63],
      $V3 = [1, 65],
      $V4 = [1, 66],
      $V5 = [1, 67],
      $V6 = [1, 68],
      $V7 = [1, 69],
      $V8 = [1, 80],
      $V9 = [1, 72],
      $Va = [1, 73],
      $Vb = [1, 74],
      $Vc = [1, 75],
      $Vd = [1, 99],
      $Ve = [1, 76],
      $Vf = [1, 100],
      $Vg = [1, 79],
      $Vh = [1, 51],
      $Vi = [1, 81],
      $Vj = [1, 82],
      $Vk = [1, 84],
      $Vl = [1, 83],
      $Vm = [1, 85],
      $Vn = [1, 96],
      $Vo = [1, 97],
      $Vp = [1, 98],
      $Vq = [1, 86],
      $Vr = [1, 87],
      $Vs = [1, 64],
      $Vt = [1, 70],
      $Vu = [1, 71],
      $Vv = [1, 77],
      $Vw = [1, 78],
      $Vx = [1, 53],
      $Vy = [1, 54],
      $Vz = [1, 55],
      $VA = [1, 61],
      $VB = [1, 88],
      $VC = [1, 89],
      $VD = [1, 90],
      $VE = [1, 91],
      $VF = [1, 92],
      $VG = [1, 93],
      $VH = [1, 94],
      $VI = [1, 95],
      $VJ = [1, 101],
      $VK = [1, 102],
      $VL = [1, 103],
      $VM = [1, 104],
      $VN = [1, 105],
      $VO = [1, 56],
      $VP = [1, 57],
      $VQ = [1, 58],
      $VR = [1, 59],
      $VS = [1, 115],
      $VT = [1, 111],
      $VU = [1, 114],
      $VV = [1, 112],
      $VW = [1, 113],
      $VX = [1, 118],
      $VY = [1, 117],
      $VZ = [1, 134],
      $V_ = [1, 149],
      $V$ = [1, 150],
      $V01 = [1, 157],
      $V11 = [
        5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35,
        37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70,
        72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
        96, 97, 98, 99, 101
      ],
      $V21 = [
        5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35,
        37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70,
        71, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
        95, 96, 97, 98, 99, 101
      ],
      $V31 = [
        5, 6, 7, 9, 13, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 37, 38,
        41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 82,
        83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95
      ],
      $V41 = [5, 70, 72],
      $V51 = [5, 74],
      $V61 = [71, 101]
    var parser = {
      trace: function trace() {},
      yy: {},
      symbols_: {
        error: 2,
        Program: 3,
        Command: 4,
        EOF: 5,
        RESET: 6,
        BUILD: 7,
        ALL: 8,
        HELP: 9,
        Path: 10,
        MOTM: 11,
        OneArgCommand: 12,
        GET: 13,
        STRING: 14,
        SET: 15,
        Value: 16,
        SET_SAVE: 17,
        SET_RESTORE: 18,
        SET_RESET: 19,
        PRESET: 20,
        AddRepresentation: 21,
        EditRepresentation: 22,
        REMOVE: 23,
        RepresentationReference: 24,
        HIDE: 25,
        SHOW: 26,
        LIST: 27,
        EXPAND_KEY: 28,
        SELECTOR_KEY: 29,
        SELECT: 30,
        AS: 31,
        WordAll: 32,
        SELECTOR: 33,
        WITHIN: 34,
        NUMBER: 35,
        OF: 36,
        MATERIAL: 37,
        IDENTIFIER: 38,
        ModeCMD: 39,
        ColorCMD: 40,
        VIEW: 41,
        BASE_64: 42,
        UNIT: 43,
        DSSP: 44,
        SCALE: 45,
        ROTATE: 46,
        AxesList: 47,
        TRANSLATE: 48,
        CENTER: 49,
        GetURLBranch: 50,
        Screenshot: 51,
        LINE: 52,
        ArgList: 53,
        LISTOBJ: 54,
        REMOVEOBJ: 55,
        URL: 56,
        VIEW_KEY: 57,
        SCREENSHOT: 58,
        LOAD: 59,
        Url: 60,
        FILE_KEY: 61,
        ADD: 62,
        Description: 63,
        REP: 64,
        MODE: 65,
        COLOR: 66,
        Descriptor: 67,
        RepresentationOwnProperty: 68,
        RepresentationOwnPropertyOpts: 69,
        DESC_KEY: 70,
        '=': 71,
        DESC_KEY_OPTS: 72,
        AxesArg: 73,
        DESC_KEY_AXES: 74,
        Arg: 75,
        PathWoDescKey: 76,
        HEX: 77,
        BOOL: 78,
        Word: 79,
        CommandSetWoDESC_KEY: 80,
        DescKeys: 81,
        CLEAR: 82,
        FILE_LIST: 83,
        FILE_REGISTER: 84,
        FILE_DELETE: 85,
        PRESET_ADD: 86,
        PRESET_DELETE: 87,
        PRESET_UPDATE: 88,
        PRESET_RENAME: 89,
        PRESET_OPEN: 90,
        CREATE_SCENARIO: 91,
        RESET_SCENARIO: 92,
        DELETE_SCENARIO: 93,
        ADD_SCENARIO_ITEM: 94,
        LIST_SCENARIO: 95,
        PDB_KEY: 96,
        DELAY_KEY: 97,
        PRST_KEY: 98,
        DESCRIPTION_KEY: 99,
        CommandSet: 100,
        '.': 101,
        PresetPath: 102,
        '/': 103,
        HexOrNumber: 104,
        $accept: 0,
        $end: 1
      },
      terminals_: {
        2: 'error',
        5: 'EOF',
        6: 'RESET',
        7: 'BUILD',
        8: 'ALL',
        9: 'HELP',
        11: 'MOTM',
        13: 'GET',
        14: 'STRING',
        15: 'SET',
        17: 'SET_SAVE',
        18: 'SET_RESTORE',
        19: 'SET_RESET',
        20: 'PRESET',
        23: 'REMOVE',
        25: 'HIDE',
        26: 'SHOW',
        27: 'LIST',
        28: 'EXPAND_KEY',
        29: 'SELECTOR_KEY',
        30: 'SELECT',
        31: 'AS',
        33: 'SELECTOR',
        34: 'WITHIN',
        35: 'NUMBER',
        36: 'OF',
        37: 'MATERIAL',
        38: 'IDENTIFIER',
        41: 'VIEW',
        42: 'BASE_64',
        43: 'UNIT',
        44: 'DSSP',
        45: 'SCALE',
        46: 'ROTATE',
        48: 'TRANSLATE',
        49: 'CENTER',
        52: 'LINE',
        54: 'LISTOBJ',
        55: 'REMOVEOBJ',
        56: 'URL',
        57: 'VIEW_KEY',
        58: 'SCREENSHOT',
        59: 'LOAD',
        61: 'FILE_KEY',
        62: 'ADD',
        64: 'REP',
        65: 'MODE',
        66: 'COLOR',
        70: 'DESC_KEY',
        71: '=',
        72: 'DESC_KEY_OPTS',
        74: 'DESC_KEY_AXES',
        77: 'HEX',
        78: 'BOOL',
        82: 'CLEAR',
        83: 'FILE_LIST',
        84: 'FILE_REGISTER',
        85: 'FILE_DELETE',
        86: 'PRESET_ADD',
        87: 'PRESET_DELETE',
        88: 'PRESET_UPDATE',
        89: 'PRESET_RENAME',
        90: 'PRESET_OPEN',
        91: 'CREATE_SCENARIO',
        92: 'RESET_SCENARIO',
        93: 'DELETE_SCENARIO',
        94: 'ADD_SCENARIO_ITEM',
        95: 'LIST_SCENARIO',
        96: 'PDB_KEY',
        97: 'DELAY_KEY',
        98: 'PRST_KEY',
        99: 'DESCRIPTION_KEY',
        101: '.',
        103: '/'
      },
      productions_: [
        0,
        [3, 2],
        [3, 1],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 3],
        [4, 3],
        [4, 1],
        [4, 1],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 4],
        [4, 2],
        [4, 6],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 2],
        [4, 2],
        [4, 1],
        [4, 2],
        [4, 1],
        [4, 1],
        [4, 3],
        [4, 3],
        [4, 4],
        [4, 4],
        [4, 1],
        [4, 2],
        [50, 1],
        [50, 2],
        [50, 2],
        [50, 3],
        [50, 3],
        [51, 1],
        [51, 2],
        [51, 3],
        [12, 2],
        [12, 2],
        [12, 2],
        [21, 1],
        [21, 2],
        [21, 2],
        [21, 3],
        [22, 2],
        [22, 3],
        [39, 2],
        [39, 3],
        [40, 2],
        [40, 3],
        [24, 1],
        [24, 1],
        [63, 1],
        [63, 2],
        [63, 3],
        [63, 4],
        [67, 1],
        [67, 1],
        [67, 2],
        [68, 3],
        [69, 3],
        [47, 1],
        [47, 2],
        [73, 2],
        [53, 1],
        [53, 2],
        [75, 3],
        [16, 1],
        [16, 1],
        [16, 1],
        [16, 1],
        [16, 1],
        [79, 1],
        [79, 1],
        [32, 1],
        [32, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [80, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [81, 1],
        [100, 1],
        [100, 1],
        [76, 1],
        [76, 3],
        [76, 3],
        [10, 1],
        [10, 1],
        [10, 3],
        [10, 3],
        [10, 3],
        [60, 1],
        [102, 1],
        [102, 3],
        [104, 1],
        [104, 1]
      ],
      performAction: function anonymous(
        yytext,
        yyleng,
        yylineno,
        yy,
        yystate,
        $$,
        _$
      ) {
        var $0 = $$.length - 1
        switch (yystate) {
          case 1:
            return $$[$0 - 1]
          case 3:
            this.$ = yy.miew.reset(false)
            yy.ClearContext()
            yy.miew.resetReps('empty')
            break
          case 4:
            this.$ = yy.miew.rebuild()
            break
          case 5:
            this.$ = yy.miew.rebuildAll()
            yy.miew.rebuild()
            break
          case 6:
            this.$ = yy.echo(yy.utils.help().toString())
            break
          case 7:
            this.$ = yy.echo(yy.utils.help($$[$0]).toString())
            break
          case 8:
            this.$ = yy.miew.motm()
            break
          case 10:
          case 11:
            this.$ = yy.utils.propagateProp($$[$0])
            yy.echo(yy.miew.get($$[$0]).toString())
            break
          case 12:
          case 13:
            this.$ = yy.miew.set(
              $$[$0 - 1],
              yy.utils.propagateProp($$[$0 - 1], $$[$0])
            )
            break
          case 14:
            this.$ = yy.miew.saveSettings()
            break
          case 15:
            this.$ = yy.miew.restoreSettings()
            break
          case 16:
            this.$ = yy.miew.resetSettings()
            break
          case 17:
            this.$ = yy.miew.resetReps()
            break
          case 18:
            this.$ = yy.miew.applyPreset($$[$0])
            break
          case 21:
            this.$ = yy.miew.repRemove($$[$0])
            yy.representations.remove($$[$0])
            break
          case 22:
            this.$ = yy.miew.repHide($$[$0])
            break
          case 23:
            this.$ = yy.miew.repHide($$[$0], false)
            break
          case 24:
            this.$ = yy.echo(
              yy.utils.listRep(yy.miew, yy.representations, $$[$0], '-e')
            )
            break
          case 25:
            this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations))
            break
          case 26:
            this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]))
            break
          case 27:
            this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context))
            break
          case 28:
            this.$ = yy.miew.select(
              yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0], true)
            )
            break
          case 29:
            this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg(
              $$[$0 - 3].toLowerCase(),
              $$[$0 - 2],
              true
            )
            yy.miew.select(yy.Context[$$[$0].toLowerCase()])
            break
          case 30:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              selector: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0])
            })
            break
          case 31:
            this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(
              yy.utils.checkArg('select', $$[$0 - 2], true),
              Number($$[$0 - 4])
            )
            break
          case 32:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              material: yy.utils.checkArg(
                $$[$0 - 1].toLowerCase(),
                $$[$0].toUpperCase()
              )
            })
            break
          case 35:
            this.$ = yy.echo(yy.miew.view())
            break
          case 36:
          case 37:
            this.$ = yy.miew.view($$[$0])
            break
          case 38:
            this.$ = yy.echo(yy.miew.changeUnit())
            break
          case 39:
            this.$ = yy.echo(yy.miew.changeUnit($$[$0]))
            break
          case 40:
            this.$ = yy.miew.dssp()
            break
          case 41:
            this.$ = yy.miew.scale($$[$0])
            break
          case 42:
            for (var i = 0, n = $$[$0].length; i < n; i++) {
              yy.miew.rotate(
                ($$[$0][i]['x'] * Math.PI) / 180.0,
                ($$[$0][i]['y'] * Math.PI) / 180.0,
                ($$[$0][i]['z'] * Math.PI) / 180.0
              )
            }
            break
          case 43:
            for (var i = 0, n = $$[$0].length; i < n; i++) {
              yy.miew.translate(
                $$[$0][i]['x'] || 0,
                $$[$0][i]['y'] || 0,
                $$[$0][i]['z'] || 0
              )
            }
            break
          case 44:
            this.$ = yy.miew.center()
            break
          case 45:
            this.$ = yy.miew.center($$[$0])
            break
          case 48:
          case 49:
            this.$ = yy.miew.addObject(
              { type: 'line', params: [$$[$0 - 1], $$[$0]] },
              true
            )
            break
          case 50:
          case 51:
            this.$ = yy.miew.addObject(
              {
                type: 'line',
                params: [$$[$0 - 2], $$[$0 - 1]],
                opts: $$[$0].toJSO(yy.utils, 'objects', 'line')
              },
              true
            )
            break
          case 52:
            this.$ = yy.echo(yy.utils.listObjs(yy.miew))
            break
          case 53:
            this.$ = yy.miew.removeObject($$[$0])
            break
          case 54:
            this.$ = yy.echo(yy.miew.getURL({ view: false, settings: false }))
            break
          case 55:
            this.$ = yy.echo(yy.miew.getURL({ view: false, settings: true }))
            break
          case 56:
            this.$ = yy.echo(yy.miew.getURL({ view: true, settings: false }))
            break
          case 57:
          case 58:
            this.$ = yy.echo(yy.miew.getURL({ view: true, settings: true }))
            break
          case 59:
            this.$ = yy.miew.screenshotSave()
            break
          case 60:
            this.$ = yy.miew.screenshotSave('', Number($$[$0]))
            break
          case 61:
            this.$ = yy.miew.screenshotSave(
              '',
              Number($$[$0 - 1]),
              Number($$[$0])
            )
            break
          case 62:
          case 63:
          case 64:
            this.$ = yy.utils.load(yy.miew, $$[$0])
            yy.representations.clear()
            break
          case 65:
            this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()))
            break
          case 66:
            this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()))
            break
          case 67:
            this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])))
            break
          case 68:
            this.$ = yy.echo(
              yy.representations.add($$[$0 - 1], yy.miew.repAdd($$[$0]))
            )
            break
          case 69:
            this.$ = yy.miew.rep($$[$0])
            yy.miew.repCurrent($$[$0])
            break
          case 70:
            this.$ = yy.miew.rep($$[$0 - 1], $$[$0])
            yy.miew.repCurrent($$[$0 - 1])
            break
          case 71:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              mode: yy.utils.checkArg(
                $$[$0 - 1].toLowerCase(),
                $$[$0].toUpperCase()
              )
            })
            break
          case 72:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              mode: new Array(
                yy.utils.checkArg(
                  $$[$0 - 2].toLowerCase(),
                  $$[$0 - 1].toUpperCase()
                ),
                $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase())
              )
            })
            break
          case 73:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              colorer: yy.utils.checkArg(
                $$[$0 - 1].toLowerCase(),
                $$[$0].toUpperCase()
              )
            })
            break
          case 74:
            this.$ = yy.miew.rep(yy.miew.repCurrent(), {
              colorer: new Array(
                yy.utils.checkArg(
                  $$[$0 - 2].toLowerCase(),
                  $$[$0 - 1].toUpperCase()
                ),
                $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase())
              )
            })
            break
          case 75:
            this.$ = Number(yy.representations.get($$[$0]))
            break
          case 76:
          case 92:
            this.$ = Number($$[$0])
            break
          case 77:
            this.$ = $$[$0]
            break
          case 78:
            this.$ = yy._.assign($$[$0 - 1], $$[$0])
            break
          case 79:
            this.$ = yy._.assign($$[$0 - 2], $$[$0 - 1], $$[$0])
            break
          case 80:
            this.$ = yy._.assign($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0])
            break
          case 81:
          case 82:
            this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val)
            break
          case 83:
            this.$ = yy.CreateObjectPair(
              $$[$0 - 1].key,
              new Array(
                $$[$0 - 1].val,
                $$[$0].toJSO(yy.utils, $$[$0 - 1].key, $$[$0 - 1].val)
              )
            )
            break
          case 84:
          case 85:
            this.$ = Object.create({
              key: yy.keyRemap($$[$0 - 2]),
              val: yy.utils.checkArg($$[$0 - 2], $$[$0])
            })
            break
          case 86:
            this.$ = [$$[$0]]
            break
          case 87:
            this.$ = $$[$0 - 1].concat($$[$0])
            break
          case 88:
            this.$ = yy.CreateObjectPair(
              $$[$0 - 1].toLowerCase(),
              Number($$[$0])
            )
            break
          case 89:
            this.$ = new yy.ArgList($$[$0])
            break
          case 90:
            this.$ = $$[$0 - 1].append($$[$0])
            break
          case 91:
            this.$ = new yy.Arg($$[$0 - 2], $$[$0])
            break
          case 93:
            this.$ = parseInt($$[$0])
            break
          case 94:
            this.$ = JSON.parse($$[$0])
            break
          case 95:
          case 96:
            this.$ = String($$[$0])
            break
          case 157:
          case 158:
          case 161:
          case 162:
          case 163:
            this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0]
            break
          case 166:
            this.$ = $$[$0 - 2] = $$[$0 - 2] + $$[$0 - 1] + $$[$0]
            break
        }
      },
      table: [
        {
          3: 1,
          4: 2,
          5: [1, 3],
          6: [1, 4],
          7: [1, 5],
          9: [1, 6],
          11: [1, 7],
          12: 8,
          13: [1, 9],
          15: [1, 10],
          17: [1, 11],
          18: [1, 12],
          19: [1, 13],
          20: [1, 14],
          21: 15,
          22: 16,
          23: [1, 17],
          25: [1, 18],
          26: [1, 19],
          27: [1, 20],
          30: [1, 21],
          33: [1, 22],
          34: [1, 23],
          37: [1, 24],
          39: 25,
          40: 26,
          41: [1, 27],
          43: [1, 28],
          44: [1, 29],
          45: [1, 30],
          46: [1, 31],
          48: [1, 32],
          49: [1, 33],
          50: 34,
          51: 35,
          52: [1, 36],
          54: [1, 37],
          55: [1, 38],
          56: [1, 44],
          58: [1, 45],
          59: [1, 39],
          62: [1, 40],
          64: [1, 41],
          65: [1, 42],
          66: [1, 43]
        },
        { 1: [3] },
        { 5: [1, 46] },
        { 1: [2, 2] },
        { 5: [2, 3] },
        { 5: [2, 4], 8: [1, 47] },
        {
          5: [2, 6],
          6: $V0,
          7: $V1,
          9: $V2,
          10: 48,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 8] },
        { 5: [2, 9] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 106,
          13: $V3,
          14: [1, 107],
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 108,
          13: $V3,
          14: [1, 109],
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 14] },
        { 5: [2, 15] },
        { 5: [2, 16] },
        { 5: [2, 17], 14: $VS, 16: 110, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 5: [2, 19] },
        { 5: [2, 20] },
        { 24: 116, 35: $VX, 38: $VY },
        { 24: 119, 35: $VX, 38: $VY },
        { 24: 120, 35: $VX, 38: $VY },
        { 5: [2, 25], 24: 121, 28: [1, 122], 29: [1, 123], 35: $VX, 38: $VY },
        { 14: [1, 124] },
        { 14: [1, 125] },
        { 35: [1, 126] },
        { 38: [1, 127] },
        { 5: [2, 33] },
        { 5: [2, 34] },
        { 5: [2, 35], 14: [1, 128], 42: [1, 129] },
        { 5: [2, 38], 35: [1, 130] },
        { 5: [2, 40] },
        { 35: [1, 131] },
        { 47: 132, 73: 133, 74: $VZ },
        { 47: 135, 73: 133, 74: $VZ },
        { 5: [2, 44], 14: [1, 136] },
        { 5: [2, 46] },
        { 5: [2, 47] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 138,
          13: $V3,
          14: [1, 137],
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 52] },
        { 35: [1, 139] },
        { 14: [1, 143], 38: [1, 141], 60: 140, 61: [1, 142] },
        {
          5: [2, 65],
          38: [1, 144],
          63: 145,
          67: 146,
          68: 147,
          69: 148,
          70: $V_,
          72: $V$
        },
        { 24: 151, 35: $VX, 38: $VY },
        { 38: [1, 152] },
        { 38: [1, 153] },
        { 5: [2, 54], 29: [1, 154], 57: [1, 155] },
        { 5: [2, 59], 35: [1, 156] },
        { 1: [2, 1] },
        { 5: [2, 5] },
        { 5: [2, 7], 101: $V01 },
        o($V11, [2, 159]),
        o($V11, [2, 160]),
        o($V21, [2, 97]),
        o($V21, [2, 98]),
        o($V11, [2, 147]),
        o($V11, [2, 148]),
        o($V11, [2, 149]),
        o($V11, [2, 150]),
        o($V11, [2, 151]),
        o($V11, [2, 152]),
        o($V11, [2, 153]),
        o($V21, [2, 101]),
        o($V21, [2, 102]),
        o($V21, [2, 103]),
        o($V21, [2, 104]),
        o($V21, [2, 105]),
        o($V21, [2, 106]),
        o($V21, [2, 107]),
        o($V21, [2, 108]),
        o($V21, [2, 109]),
        o($V21, [2, 110]),
        o($V21, [2, 111]),
        o($V21, [2, 112]),
        o($V21, [2, 113]),
        o($V21, [2, 114]),
        o($V21, [2, 115]),
        o($V21, [2, 116]),
        o($V21, [2, 117]),
        o($V21, [2, 118]),
        o($V21, [2, 119]),
        o($V21, [2, 120]),
        o($V21, [2, 121]),
        o($V21, [2, 122]),
        o($V21, [2, 123]),
        o($V21, [2, 124]),
        o($V21, [2, 125]),
        o($V21, [2, 126]),
        o($V21, [2, 127]),
        o($V21, [2, 128]),
        o($V21, [2, 129]),
        o($V21, [2, 130]),
        o($V21, [2, 131]),
        o($V21, [2, 132]),
        o($V21, [2, 133]),
        o($V21, [2, 134]),
        o($V21, [2, 135]),
        o($V21, [2, 136]),
        o($V21, [2, 137]),
        o($V21, [2, 138]),
        o($V21, [2, 139]),
        o($V21, [2, 140]),
        o($V21, [2, 141]),
        o($V21, [2, 142]),
        o($V21, [2, 143]),
        o($V21, [2, 144]),
        o($V21, [2, 145]),
        o($V21, [2, 146]),
        { 5: [2, 10], 101: $V01 },
        { 5: [2, 11] },
        { 14: $VS, 16: 158, 35: $VT, 38: $VU, 77: $VV, 78: $VW, 101: $V01 },
        { 14: $VS, 16: 159, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 5: [2, 18] },
        o($V31, [2, 92]),
        o($V31, [2, 93]),
        o($V31, [2, 94]),
        o($V31, [2, 95]),
        o($V31, [2, 96]),
        { 5: [2, 21] },
        o($V41, [2, 75]),
        o($V41, [2, 76]),
        { 5: [2, 22] },
        { 5: [2, 23] },
        { 5: [2, 24] },
        { 5: [2, 26] },
        { 5: [2, 27] },
        { 5: [2, 28], 31: [1, 160] },
        { 5: [2, 30] },
        { 36: [1, 161] },
        { 5: [2, 32] },
        { 5: [2, 36] },
        { 5: [2, 37] },
        { 5: [2, 39] },
        { 5: [2, 41] },
        { 5: [2, 42], 73: 162, 74: $VZ },
        o($V51, [2, 86]),
        { 35: [1, 163] },
        { 5: [2, 43], 73: 162, 74: $VZ },
        { 5: [2, 45] },
        { 14: [1, 164] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          10: 165,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 49,
          80: 52,
          81: 50,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR,
          101: $V01
        },
        { 5: [2, 53] },
        { 5: [2, 62] },
        { 5: [2, 63] },
        { 5: [2, 64] },
        { 5: [2, 164] },
        { 5: [2, 66], 63: 166, 67: 146, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        { 5: [2, 67] },
        { 5: [2, 77], 67: 167, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        o($V41, [2, 81]),
        o($V41, [2, 82], {
          80: 52,
          53: 168,
          75: 169,
          76: 170,
          79: 171,
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        }),
        { 71: [1, 172] },
        { 71: [1, 173] },
        { 5: [2, 69], 63: 174, 67: 146, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        {
          5: [2, 71],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 175,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 73],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 176,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        { 5: [2, 55], 57: [1, 177] },
        { 5: [2, 56], 29: [1, 178] },
        { 5: [2, 60], 35: [1, 179] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          35: [1, 181],
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 180,
          80: 52,
          81: 182,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 12] },
        { 5: [2, 13] },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          32: 183,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 184,
          80: 52,
          81: 185,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 14: [1, 186] },
        o($V51, [2, 87]),
        o($V51, [2, 88]),
        {
          5: [2, 48],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 187,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 49],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          53: 188,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 169,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          101: $V01
        },
        { 5: [2, 68] },
        { 5: [2, 78], 67: 189, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        o($V41, [2, 83], {
          80: 52,
          76: 170,
          79: 171,
          75: 190,
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        }),
        o($V31, [2, 89]),
        { 71: [1, 191], 101: [1, 192] },
        o($V61, [2, 156]),
        { 14: $VS, 16: 193, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 14: $VS, 16: 194, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        { 5: [2, 70] },
        {
          5: [2, 72],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 74],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        { 5: [2, 57] },
        { 5: [2, 58] },
        { 5: [2, 61] },
        o($V11, [2, 161]),
        o($V11, [2, 162]),
        o($V11, [2, 163]),
        { 5: [2, 29] },
        { 5: [2, 99] },
        { 5: [2, 100] },
        { 31: [1, 195] },
        {
          5: [2, 50],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        {
          5: [2, 51],
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          75: 190,
          76: 170,
          79: 171,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        { 5: [2, 79], 67: 196, 68: 147, 69: 148, 70: $V_, 72: $V$ },
        o($V31, [2, 90]),
        { 14: $VS, 16: 197, 35: $VT, 38: $VU, 77: $VV, 78: $VW },
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          33: $Ve,
          34: $Vf,
          35: [1, 199],
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          79: 198,
          80: 52,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN
        },
        o($V41, [2, 84]),
        o($V31, [2, 85]),
        {
          6: $V0,
          7: $V1,
          9: $V2,
          13: $V3,
          15: $V4,
          17: $V5,
          18: $V6,
          19: $V7,
          20: $V8,
          23: $V9,
          25: $Va,
          26: $Vb,
          27: $Vc,
          30: $Vd,
          32: 200,
          33: $Ve,
          34: $Vf,
          37: $Vg,
          38: $Vh,
          41: $Vi,
          43: $Vj,
          45: $Vk,
          46: $Vl,
          49: $Vm,
          52: $Vn,
          54: $Vo,
          55: $Vp,
          56: $Vq,
          58: $Vr,
          59: $Vs,
          62: $Vt,
          64: $Vu,
          65: $Vv,
          66: $Vw,
          70: $Vx,
          72: $Vy,
          74: $Vz,
          79: 184,
          80: 52,
          81: 185,
          82: $VA,
          83: $VB,
          84: $VC,
          85: $VD,
          86: $VE,
          87: $VF,
          88: $VG,
          89: $VH,
          90: $VI,
          91: $VJ,
          92: $VK,
          93: $VL,
          94: $VM,
          95: $VN,
          96: $VO,
          97: $VP,
          98: $VQ,
          99: $VR
        },
        { 5: [2, 80] },
        o($V31, [2, 91]),
        o($V61, [2, 157]),
        o($V61, [2, 158]),
        { 5: [2, 31] }
      ],
      defaultActions: {
        3: [2, 2],
        4: [2, 3],
        7: [2, 8],
        8: [2, 9],
        11: [2, 14],
        12: [2, 15],
        13: [2, 16],
        15: [2, 19],
        16: [2, 20],
        25: [2, 33],
        26: [2, 34],
        29: [2, 40],
        34: [2, 46],
        35: [2, 47],
        37: [2, 52],
        46: [2, 1],
        47: [2, 5],
        107: [2, 11],
        110: [2, 18],
        116: [2, 21],
        119: [2, 22],
        120: [2, 23],
        121: [2, 24],
        122: [2, 26],
        123: [2, 27],
        125: [2, 30],
        127: [2, 32],
        128: [2, 36],
        129: [2, 37],
        130: [2, 39],
        131: [2, 41],
        136: [2, 45],
        139: [2, 53],
        140: [2, 62],
        141: [2, 63],
        142: [2, 64],
        143: [2, 164],
        145: [2, 67],
        158: [2, 12],
        159: [2, 13],
        166: [2, 68],
        174: [2, 70],
        177: [2, 57],
        178: [2, 58],
        179: [2, 61],
        183: [2, 29],
        184: [2, 99],
        185: [2, 100],
        196: [2, 80],
        200: [2, 31]
      },
      parseError: function parseError(str, hash) {
        if (hash.recoverable) {
          this.trace(str)
        } else {
          var error = new Error(str)
          error.hash = hash
          throw error
        }
      },
      parse: function parse(input) {
        var self = this,
          stack = [0],
          tstack = [],
          vstack = [null],
          lstack = [],
          table = this.table,
          yytext = '',
          yylineno = 0,
          yyleng = 0,
          TERROR = 2,
          EOF = 1
        var args = lstack.slice.call(arguments, 1)
        var lexer = Object.create(this.lexer)
        var sharedState = { yy: {} }
        for (var k in this.yy) {
          if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k]
          }
        }
        lexer.setInput(input, sharedState.yy)
        sharedState.yy.lexer = lexer
        sharedState.yy.parser = this
        if (typeof lexer.yylloc == 'undefined') {
          lexer.yylloc = {}
        }
        var yyloc = lexer.yylloc
        lstack.push(yyloc)
        var ranges = lexer.options && lexer.options.ranges
        if (typeof sharedState.yy.parseError === 'function') {
          this.parseError = sharedState.yy.parseError
        } else {
          this.parseError = Object.getPrototypeOf(this).parseError
        }
        function lex() {
          var token
          token = tstack.pop() || lexer.lex() || EOF
          if (typeof token !== 'number') {
            if (token instanceof Array) {
              tstack = token
              token = tstack.pop()
            }
            token = self.symbols_[token] || token
          }
          return token
        }
        var symbol,
          state,
          action,
          r,
          yyval = {},
          p,
          len,
          newState,
          expected
        while (true) {
          state = stack[stack.length - 1]
          if (this.defaultActions[state]) {
            action = this.defaultActions[state]
          } else {
            if (symbol === null || typeof symbol == 'undefined') {
              symbol = lex()
            }
            action = table[state] && table[state][symbol]
          }
          if (typeof action === 'undefined' || !action.length || !action[0]) {
            var errStr = ''
            expected = []
            for (p in table[state]) {
              if (this.terminals_[p] && p > TERROR) {
                expected.push("'" + this.terminals_[p] + "'")
              }
            }
            if (lexer.showPosition) {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ':\n' +
                lexer.showPosition() +
                '\nExpecting ' +
                expected.join(', ') +
                ", got '" +
                (this.terminals_[symbol] || symbol) +
                "'"
            } else {
              errStr =
                'Parse error on line ' +
                (yylineno + 1) +
                ': Unexpected ' +
                (symbol == EOF
                  ? 'end of input'
                  : "'" + (this.terminals_[symbol] || symbol) + "'")
            }
            this.parseError(errStr, {
              text: lexer.match,
              token: this.terminals_[symbol] || symbol,
              line: lexer.yylineno,
              loc: yyloc,
              expected: expected
            })
          }
          if (action[0] instanceof Array && action.length > 1) {
            throw new Error(
              'Parse Error: multiple actions possible at state: ' +
                state +
                ', token: ' +
                symbol
            )
          }
          switch (action[0]) {
            case 1:
              stack.push(symbol)
              vstack.push(lexer.yytext)
              lstack.push(lexer.yylloc)
              stack.push(action[1])
              symbol = null
              {
                yyleng = lexer.yyleng
                yytext = lexer.yytext
                yylineno = lexer.yylineno
                yyloc = lexer.yylloc
              }
              break
            case 2:
              len = this.productions_[action[1]][1]
              yyval.$ = vstack[vstack.length - len]
              yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
              }
              if (ranges) {
                yyval._$.range = [
                  lstack[lstack.length - (len || 1)].range[0],
                  lstack[lstack.length - 1].range[1]
                ]
              }
              r = this.performAction.apply(
                yyval,
                [
                  yytext,
                  yyleng,
                  yylineno,
                  sharedState.yy,
                  action[1],
                  vstack,
                  lstack
                ].concat(args)
              )
              if (typeof r !== 'undefined') {
                return r
              }
              if (len) {
                stack = stack.slice(0, -1 * len * 2)
                vstack = vstack.slice(0, -1 * len)
                lstack = lstack.slice(0, -1 * len)
              }
              stack.push(this.productions_[action[1]][0])
              vstack.push(yyval.$)
              lstack.push(yyval._$)
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]]
              stack.push(newState)
              break
            case 3:
              return true
          }
        }
        return true
      }
    }
    var lexer = (function () {
      var lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (this.yy.parser) {
            this.yy.parser.parseError(str, hash)
          } else {
            throw new Error(str)
          }
        },
        setInput: function (input, yy) {
          this.yy = yy || this.yy || {}
          this._input = input
          this._more = this._backtrack = this.done = false
          this.yylineno = this.yyleng = 0
          this.yytext = this.matched = this.match = ''
          this.conditionStack = ['INITIAL']
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }
          if (this.options.ranges) {
            this.yylloc.range = [0, 0]
          }
          this.offset = 0
          return this
        },
        input: function () {
          var ch = this._input[0]
          this.yytext += ch
          this.yyleng++
          this.offset++
          this.match += ch
          this.matched += ch
          var lines = ch.match(/(?:\r\n?|\n).*/g)
          if (lines) {
            this.yylineno++
            this.yylloc.last_line++
          } else {
            this.yylloc.last_column++
          }
          if (this.options.ranges) {
            this.yylloc.range[1]++
          }
          this._input = this._input.slice(1)
          return ch
        },
        unput: function (ch) {
          var len = ch.length
          var lines = ch.split(/(?:\r\n?|\n)/g)
          this._input = ch + this._input
          this.yytext = this.yytext.substr(0, this.yytext.length - len)
          this.offset -= len
          var oldLines = this.match.split(/(?:\r\n?|\n)/g)
          this.match = this.match.substr(0, this.match.length - 1)
          this.matched = this.matched.substr(0, this.matched.length - 1)
          if (lines.length - 1) {
            this.yylineno -= lines.length - 1
          }
          var r = this.yylloc.range
          this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines
              ? (lines.length === oldLines.length
                  ? this.yylloc.first_column
                  : 0) +
                oldLines[oldLines.length - lines.length].length -
                lines[0].length
              : this.yylloc.first_column - len
          }
          if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len]
          }
          this.yyleng = this.yytext.length
          return this
        },
        more: function () {
          this._more = true
          return this
        },
        reject: function () {
          if (this.options.backtrack_lexer) {
            this._backtrack = true
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno
              }
            )
          }
          return this
        },
        less: function (n) {
          this.unput(this.match.slice(n))
        },
        pastInput: function () {
          var past = this.matched.substr(
            0,
            this.matched.length - this.match.length
          )
          return (
            (past.length > 20 ? '...' : '') +
            past.substr(-20).replace(/\n/g, '')
          )
        },
        upcomingInput: function () {
          var next = this.match
          if (next.length < 20) {
            next += this._input.substr(0, 20 - next.length)
          }
          return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(
            /\n/g,
            ''
          )
        },
        showPosition: function () {
          var pre = this.pastInput()
          var c = new Array(pre.length + 1).join('-')
          return pre + this.upcomingInput() + '\n' + c + '^'
        },
        test_match: function (match, indexed_rule) {
          var token, lines, backup
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            }
            if (this.options.ranges) {
              backup.yylloc.range = this.yylloc.range.slice(0)
            }
          }
          lines = match[0].match(/(?:\r\n?|\n).*/g)
          if (lines) {
            this.yylineno += lines.length
          }
          this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines
              ? lines[lines.length - 1].length -
                lines[lines.length - 1].match(/\r?\n?/)[0].length
              : this.yylloc.last_column + match[0].length
          }
          this.yytext += match[0]
          this.match += match[0]
          this.matches = match
          this.yyleng = this.yytext.length
          if (this.options.ranges) {
            this.yylloc.range = [this.offset, (this.offset += this.yyleng)]
          }
          this._more = false
          this._backtrack = false
          this._input = this._input.slice(match[0].length)
          this.matched += match[0]
          token = this.performAction.call(
            this,
            this.yy,
            this,
            indexed_rule,
            this.conditionStack[this.conditionStack.length - 1]
          )
          if (this.done && this._input) {
            this.done = false
          }
          if (token) {
            return token
          } else if (this._backtrack) {
            for (var k in backup) {
              this[k] = backup[k]
            }
            return false
          }
          return false
        },
        next: function () {
          if (this.done) {
            return this.EOF
          }
          if (!this._input) {
            this.done = true
          }
          var token, match, tempMatch, index
          if (!this._more) {
            this.yytext = ''
            this.match = ''
          }
          var rules = this._currentRules()
          for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]])
            if (
              tempMatch &&
              (!match || tempMatch[0].length > match[0].length)
            ) {
              match = tempMatch
              index = i
              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rules[i])
                if (token !== false) {
                  return token
                } else if (this._backtrack) {
                  match = false
                  continue
                } else {
                  return false
                }
              } else if (!this.options.flex) {
                break
              }
            }
          }
          if (match) {
            token = this.test_match(match, rules[index])
            if (token !== false) {
              return token
            }
            return false
          }
          if (this._input === '') {
            return this.EOF
          } else {
            return this.parseError(
              'Lexical error on line ' +
                (this.yylineno + 1) +
                '. Unrecognized text.\n' +
                this.showPosition(),
              {
                text: '',
                token: null,
                line: this.yylineno
              }
            )
          }
        },
        lex: function lex() {
          var r = this.next()
          if (r) {
            return r
          } else {
            return this.lex()
          }
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition)
        },
        popState: function popState() {
          var n = this.conditionStack.length - 1
          if (n > 0) {
            return this.conditionStack.pop()
          } else {
            return this.conditionStack[0]
          }
        },
        _currentRules: function _currentRules() {
          if (
            this.conditionStack.length &&
            this.conditionStack[this.conditionStack.length - 1]
          ) {
            return this.conditions[
              this.conditionStack[this.conditionStack.length - 1]
            ].rules
          } else {
            return this.conditions['INITIAL'].rules
          }
        },
        topState: function topState(n) {
          n = this.conditionStack.length - 1 - Math.abs(n || 0)
          if (n >= 0) {
            return this.conditionStack[n]
          } else {
            return 'INITIAL'
          }
        },
        pushState: function pushState(condition) {
          this.begin(condition)
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length
        },
        options: { 'case-insensitive': true },
        performAction: function anonymous(
          yy,
          yy_,
          $avoiding_name_collisions,
          YY_START
        ) {
          switch ($avoiding_name_collisions) {
            case 0:
              break
            case 1:
              return ''
            case 2:
              return ''
            case 3:
              return 42
            case 4:
              return 35
            case 5:
              return 77
            case 6:
              return 78
            case 7:
              return 78
            case 8:
              return 8
            case 9:
              return 6
            case 10:
              return 82
            case 11:
              return 7
            case 12:
              return 9
            case 13:
              return 59
            case 14:
              return 13
            case 15:
              return 15
            case 16:
              return 17
            case 17:
              return 18
            case 18:
              return 19
            case 19:
              return 20
            case 20:
              return 11
            case 21:
              return 62
            case 22:
              return 64
            case 23:
              return 23
            case 24:
              return 25
            case 25:
              return 26
            case 26:
              return 27
            case 27:
              return 30
            case 28:
              return 34
            case 29:
              return 33
            case 30:
              return 65
            case 31:
              return 66
            case 32:
              return 37
            case 33:
              return 41
            case 34:
              return 43
            case 35:
              return 52
            case 36:
              return 54
            case 37:
              return 55
            case 38:
              return 46
            case 39:
              return 48
            case 40:
              return 45
            case 41:
              return 49
            case 42:
              return 56
            case 43:
              return 58
            case 44:
              return 44
            case 45:
              return 83
            case 46:
              return 84
            case 47:
              return 85
            case 48:
              return 86
            case 49:
              return 87
            case 50:
              return 88
            case 51:
              return 89
            case 52:
              return 90
            case 53:
              return 91
            case 54:
              return 92
            case 55:
              return 93
            case 56:
              return 94
            case 57:
              return 95
            case 58:
              return 70
            case 59:
              return 70
            case 60:
              return 72
            case 61:
              return 72
            case 62:
              return 74
            case 63:
              return 74
            case 64:
              return 74
            case 65:
              return 31
            case 66:
              return 36
            case 67:
              return 96
            case 68:
              return 97
            case 69:
              return 98
            case 70:
              return 99
            case 71:
              yy_.yytext = yy.utils.unquoteString(yy_.yytext)
              return 14
            case 72:
              return 38
            case 73:
              return 5
            case 74:
              return 101
            case 75:
              return 103
            case 76:
              return '\\'
            case 77:
              return 28
            case 78:
              return 61
            case 79:
              return 29
            case 80:
              return 57
            case 81:
              return 71
          }
        },
        rules: [
          /^(?:\s+)/i,
          /^(?:[#].*)/i,
          /^(?:\/\/.*)/i,
          /^(?:([_A-Z0-9\/\+]+==))/i,
          /^(?:-?[0-9]+(\.[0-9]+)?\b)/i,
          /^(?:0[xX][0-9A-F]+\b)/i,
          /^(?:false\b)/i,
          /^(?:true\b)/i,
          /^(?:all\b)/i,
          /^(?:reset\b)/i,
          /^(?:clear\b)/i,
          /^(?:build\b)/i,
          /^(?:help\b)/i,
          /^(?:load\b)/i,
          /^(?:get\b)/i,
          /^(?:set\b)/i,
          /^(?:set_save\b)/i,
          /^(?:set_restore\b)/i,
          /^(?:set_reset\b)/i,
          /^(?:preset\b)/i,
          /^(?:motm\b)/i,
          /^(?:add\b)/i,
          /^(?:rep\b)/i,
          /^(?:remove\b)/i,
          /^(?:hide\b)/i,
          /^(?:show\b)/i,
          /^(?:list\b)/i,
          /^(?:select\b)/i,
          /^(?:within\b)/i,
          /^(?:selector\b)/i,
          /^(?:mode\b)/i,
          /^(?:color\b)/i,
          /^(?:material\b)/i,
          /^(?:view\b)/i,
          /^(?:unit\b)/i,
          /^(?:line\b)/i,
          /^(?:listobj\b)/i,
          /^(?:removeobj\b)/i,
          /^(?:rotate\b)/i,
          /^(?:translate\b)/i,
          /^(?:scale\b)/i,
          /^(?:center\b)/i,
          /^(?:url\b)/i,
          /^(?:screenshot\b)/i,
          /^(?:dssp\b)/i,
          /^(?:file_list\b)/i,
          /^(?:file_register\b)/i,
          /^(?:file_delete\b)/i,
          /^(?:preset_add\b)/i,
          /^(?:preset_delete\b)/i,
          /^(?:preset_update\b)/i,
          /^(?:preset_rename\b)/i,
          /^(?:preset_open\b)/i,
          /^(?:create_scenario\b)/i,
          /^(?:reset_scenario\b)/i,
          /^(?:delete_scenario\b)/i,
          /^(?:add_scenario_item\b)/i,
          /^(?:list_scenario\b)/i,
          /^(?:s\b)/i,
          /^(?:mt\b)/i,
          /^(?:m\b)/i,
          /^(?:c\b)/i,
          /^(?:x\b)/i,
          /^(?:y\b)/i,
          /^(?:z\b)/i,
          /^(?:as\b)/i,
          /^(?:of\b)/i,
          /^(?:pdb\b)/i,
          /^(?:delay\b)/i,
          /^(?:prst\b)/i,
          /^(?:desc\b)/i,
          /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,
          /^(?:([_A-Z0-9]+))/i,
          /^(?:$)/i,
          /^(?:\.)/i,
          /^(?:\/)/i,
          /^(?:\\)/i,
          /^(?:-e\b)/i,
          /^(?:-f\b)/i,
          /^(?:-s\b)/i,
          /^(?:-v\b)/i,
          /^(?:=)/i
        ],
        conditions: {
          INITIAL: {
            rules: [
              0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
              19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
              35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
              51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
              67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81
            ],
            inclusive: true
          }
        }
      }
      return lexer
    })()
    parser.lexer = lexer
    function Parser() {
      this.yy = {}
    }
    Parser.prototype = parser
    parser.Parser = Parser
    return new Parser()
  })()
  var MiewCLIParser = { parser: parser }

  var modeIdDesc = {
    $help: [
      'Rendering mode shortcut',
      '    BS - balls and sticks mode',
      '    LN - lines mode',
      '    LC - licorice mode',
      '    VW - van der waals mode',
      '    TR - trace mode',
      '    TU - tube mode',
      '    CA - cartoon mode',
      '    SA - isosurface mode',
      '    QS - quick surface mode',
      '    SE - solvent excluded mode',
      '    TX - text mode'
    ],
    BS: {
      $help: [
        '   Balls and sticks',
        '      aromrad = <number> #aromatic radius',
        '      atom = <number>    #atom radius',
        '      bond = <number>    #bond radius',
        '      multibond = <bool> #use multibond',
        '      showarom = <bool>  #show aromatic',
        '      space = <number>   #space value\n'
      ]
    },
    CA: {
      $help: [
        '   Cartoon',
        '      arrow = <number>   #arrow size',
        '      depth = <number>   #depth of surface',
        '      heightSegmentsRatio = <number>',
        '      radius = <number>  #tube radius',
        '      tension = <number> #',
        '      width = <number>  #secondary width\n'
      ]
    },
    LN: {
      $help: [
        '   Lines',
        '      atom = <number>    #atom radius',
        '      chunkarom = <number>',
        '      multibond = <bool> #use multibond',
        '      showarom = <bool>  #show aromatic',
        '      offsarom = <number>\n'
      ]
    },
    LC: {
      $help: [
        '   Licorice',
        '      aromrad = <number> #aromatic radius',
        '      bond = <number>    #bond radius',
        '      multibond = <bool> #use multibond',
        '      showarom = <bool>  #show aromatic',
        '      space = <number>   #space value\n'
      ]
    },
    VW: {
      $help: ['   Van der Waals', '      nothing\n']
    },
    TR: {
      $help: ['   Trace', '      radius = <number>  #tube radius\n']
    },
    TU: {
      $help: [
        '   Tube',
        '      heightSegmentsRatio = <number>',
        '      radius = <number>  #tube radius',
        '      tension = <number> \n'
      ]
    },
    SA: {
      $help: ['   Surface', '      zClip = <bool> #clip z plane\n']
    },
    QS: {
      $help: [
        '   Quick surface',
        '      isoValue = <number>',
        '      scale = <number>',
        '      wireframe = <bool>',
        '      zClip = <bool> #clip z plane\n'
      ]
    },
    SE: {
      $help: [
        '   Solvent excluded surface',
        '      zClip = <bool> #clip z plane\n'
      ]
    },
    TX: {
      $help: [
        '   Text mode',
        '      template = <format string> string that can include "{{ id }}"',
        '          it will be replaced by value, id can be one of next:',
        '          serial, name, type, sequence, residue, chain, hetatm, water\n',
        '      horizontalAlign = <string> {"left", "right", "center"}',
        '      verticalAlign = <string> {"top", "bottom", "middle"}',
        '      dx = <number> #offset along x',
        '      dy = <number> #offset along y',
        '      dz = <number> #offset along z',
        '      fg = <string> #text color modificator',
        '           could be keyword, named color or hex',
        '      fg = <string> #back color modificator',
        '           could be keyword, named color or hex',
        '      showBg = <bool> #if set show background',
        '           plate under text'
      ]
    }
  }
  var colorDesc = {
    $help: [
      'Coloring mode shortcut',
      '    EL - color by element',
      '    CH - color by chain',
      '    SQ - color by sequence',
      '    RT - color by residue type',
      '    SS - color by secondary structure',
      '    UN - uniform'
    ],
    UN: {
      $help: [
        'Parameters of coloring modes customization',
        '   Uniform',
        '      color = <number|color> #RGB->HEX->dec\n'
      ],
      color: {
        $help: Object.keys(palettes$1.get(settings$1.now.palette).namedColors)
          .sort()
          .join('\n')
      }
    }
  }
  var materialDesc = {
    $help: [
      'Material shortcut',
      '    DF - diffuse',
      '    TR - transparent',
      '    SF - soft plastic',
      '    PL - glossy plastic',
      '    ME - metal',
      '    GL - glass'
    ]
  }
  var addRepDesc = {
    $help: [
      'Short (packed) representation description as a set of variables',
      '    s=<EXPRESSION>',
      '        selector property',
      '    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]',
      '        render mode property',
      '    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]',
      '        color mode property',
      '    mt=<MATERIAL_ID>',
      '        material property'
    ],
    s: {
      $help:
        'Selection expression string as it is in menu->representations->selection'
    },
    m: modeIdDesc,
    c: colorDesc,
    mt: materialDesc
  }
  var setGetParameterDesc = {
    $help: [
      'Parameters of rendering modes customization: modes',
      'Parameters of colorer customization: colorers',
      'Autobuild: autobuild = (<number>|<bool>)'
    ],
    modes: modeIdDesc,
    colorers: colorDesc
  }
  var help = {
    $help: [
      'help (<cmd name>| <path to property>)',
      'You can get detailed information about command options',
      '   using "help cmd.opt.opt.[...]"\n',
      '   you can use one line comments',
      '   everything started from (#|//) will be skipped',
      '   Example: >build //some comment\n',
      'List of available commands:'
    ],
    reset: {
      $help: [
        'Reload current object, delete all representations',
        '    Nothing will work until load new object'
      ]
    },
    load: {
      $help: [
        'load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])',
        '    Load new pdb object from selected source'
      ],
      PDBID: {
        $help: 'pdb id in remote molecule database'
      },
      URL: {
        $help: 'url to source file'
      },
      f: {
        $help: [
          'open file system dialog to fetch local file',
          'optionally you can determine trajectory file',
          'via URL for *.top model'
        ]
      }
    },
    clear: {
      $help: 'No args. Clear terminal'
    },
    add: {
      $help: [
        'add [<REP_NAME>] [<DESCRIPTION>]',
        '    Add new item to representation set with',
        '    default or <DESCRIPTION> params'
      ],
      REP_NAME: {
        $help: 'Identifier string [_,a-z,A-Z,0-9] can not start from digit'
      },
      DESCRIPTION: addRepDesc
    },
    rep: {
      $help: [
        'rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]',
        '    set current representation by name or index',
        '    edit current representation by <DESCRIPTION>'
      ],
      REP_NAME: {
        $help: [
          'Identifier string [_,a-z,A-Z,0-9] can not start from digit',
          'Must be declared before'
        ]
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      },
      DESCRIPTION: addRepDesc
    },
    remove: {
      $help: [
        'remove (<REP_NAME>|<REP_INDEX>)',
        'Remove representation by name or index'
      ],
      REP_NAME: {
        $help: [
          'Identifier string [_,a-z,A-Z,0-9] can not start from digit',
          'Must be declared before'
        ]
      },
      REP_INDEX: {
        $help: 'Index of available representation'
      }
    },
    selector: {
      $help: [
        'selector <EXPRESSION>',
        '   set selector from EXPRESSION to current representation'
      ],
      EXPRESSION: {
        $help:
          'Selection expression string as it is in menu->representations->selection'
      }
    },
    mode: {
      $help: [
        'mode <MODE_ID> [<PARAMETER>=<VALUE>...]',
        '   set rendering mode and apply parameters to current representation'
      ],
      MODE_ID: modeIdDesc
    },
    color: {
      $help: [
        'color <COLORER_ID> [<PARAMETER>=<VALUE>...]',
        '   set colorer and apply parameters to current representation'
      ],
      COLORER_ID: colorDesc
    },
    material: {
      $help: [
        'material <MATERIAL_ID>',
        '   set material to current representation'
      ],
      MATERIAL_ID: materialDesc
    },
    build: {
      $help: 'build help str',
      add: {
        $help: 'build.add',
        new: {
          $help: [
            'add.new',
            'add.new new line 1',
            'add.new new line 2',
            'add.new new line 3'
          ]
        }
      },
      del: {
        $help: 'build.del'
      }
    },
    list: {
      $help: [
        'list [-e|-s|<REP_NAME>|<REP_INDEX>]',
        'Print representations if no args print list of representations',
        '    -e expand list and show all representations',
        '    -s show all user-registered selectors',
        '    <REP_NAME>|<REP_INDEX> show only current representation'
      ]
    },
    hide: {
      $help: [
        'hide (<REP_NAME>|<REP_INDEX>)',
        'Hide representation referenced in args'
      ]
    },
    show: {
      $help: [
        'show (<REP_NAME>|<REP_INDEX>)',
        'Show representation referenced in args'
      ]
    },
    get: {
      $help: [
        'get <PARAMETER>',
        'Print <PARAMETER> value',
        '    <PARAMETER> - path to option use get.PARAMETER to get more info'
      ],
      PARAMETER: setGetParameterDesc
    },
    set: {
      $help: [
        'set <PARAMETER> <VALUE>',
        'Set <PARAMETER> with <VALUE>',
        '    <PARAMETER> - path to option use set.PARAMETER to get more info'
      ],
      PARAMETER: setGetParameterDesc
    },
    set_save: {
      $help: ['set_save', 'Save current settings to cookie']
    },
    set_restore: {
      $help: ['set_restore', 'Load and apply settings from cookie']
    },
    set_reset: {
      $help: ['set_reset', 'Reset current settings to the defaults']
    },
    preset: {
      $help: [
        'preset [<PRESET>]',
        'Reset current representation or set preset to <PRESET>'
      ],
      PRESET: {
        $help: ['default', 'wire', 'small', 'macro']
      }
    },
    unit: {
      $help: [
        'unit [<unit_id>]',
        'Change current biological structure view. Zero <unit_id> value means asymmetric unit,',
        'positive values set an assembly with corresponding number.',
        'Being called with no parameters command prints current unit information.'
      ]
    },
    view: {
      $help: [
        'view [<ENCODED_VIEW>]',
        'Get current encoded view or set if ENCODED_VIEW placed as argument'
      ],
      ENCODED_VIEW: {
        $help: ['encoded view matrix string (binary code)']
      }
    },
    rotate: {
      $help: [
        'rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...',
        'Rotate scene'
      ]
    },
    scale: {
      $help: ['scale <SCALE>', 'Scale scene']
    },
    select: {
      $help: [
        'select <SELECTOR_STRING> [as <SELECTOR_NAME>]',
        'Select atoms using selector defined in SELECTOR_STRING',
        '    and if SELECTOR_NAME is defined register it in viewer',
        '    you can use it later as a complex selector'
      ]
    },
    within: {
      $help: [
        'within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>',
        'Build within named selector',
        '    DISTANCE        <number>',
        '    SELECTOR_STRING <string(selection language)>',
        '    SELECTOR_NAME   <identifier>'
      ]
    },
    url: {
      $help: [
        'url [-s] [-v]',
        'Report URL encoded scene',
        '    if -s set that include settings in the URL',
        '    if -v set that include view in the URL'
      ]
    },
    screenshot: {
      $help: [
        'screenshot [<WIDTH> [<HEIGHT>]]',
        'Make a screenshot of the scene',
        '    WIDTH  <number> in pixels',
        '    HEIGHT <number> in pixels, equal to WIDTH by default'
      ]
    },
    line: {
      $help: [
        'line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]',
        'Draw dashed line between two specified atoms'
      ]
    },
    removeobj: {
      $help: [
        'removeobj <id>',
        'Remove scene object by its index. Indices could be obtained by <listobj> command'
      ]
    },
    listobj: {
      $help: ['listobj', 'Display the list of all existing scene objects']
    }
  }

  var selectors = Miew.chem.selectors,
    modes = Miew.modes,
    colorers = Miew.colorers,
    materials = Miew.materials,
    palettes = Miew.palettes,
    options = Miew.options,
    settings = Miew.settings

  function None() {}

  var NULL = (function () {
    var obj = new None()
    return function () {
      return obj
    }
  })()

  var RepresentationMap = /*#__PURE__*/ (function () {
    function RepresentationMap() {
      _classCallCheck(this, RepresentationMap)

      this.representationMap = {}
      this.representationID = {}
    }

    _createClass(RepresentationMap, [
      {
        key: 'get',
        value: function get(strId) {
          return (
            this.representationMap[strId] ||
            this.representationID[strId] ||
            '<no name>'
          )
        }
      },
      {
        key: 'add',
        value: function add(strId, index) {
          if (strId === -1) {
            return 'Can not create representation: there is no data'
          }

          if (index !== undefined) {
            if (!this.representationMap.hasOwnProperty(strId)) {
              this.representationMap[strId.toString()] = index
              this.representationID[index] = strId.toString()
            } else {
              return 'This name has already existed, registered without name'
            }
          }

          return 'Representation '.concat(strId, ' successfully added')
        }
      },
      {
        key: 'remove',
        value: function remove(index) {
          if (index && this.representationID.hasOwnProperty(index)) {
            delete this.representationMap[this.representationID[index]]
            delete this.representationID[index]
          }

          var sortedKeys = Object.keys(this.representationID).sort()

          for (var i in sortedKeys) {
            if (sortedKeys.hasOwnProperty(i)) {
              var id = sortedKeys[i]

              if (id > index) {
                this.representationID[id - 1] = this.representationID[id]
                this.representationMap[this.representationID[id]] -= 1
                delete this.representationID[id]
              }
            }
          }
        }
      },
      {
        key: 'clear',
        value: function clear() {
          this.representationMap = {}
          this.representationID = {}
        }
      }
    ])

    return RepresentationMap
  })()

  var representationsStorage = new RepresentationMap()

  function keyRemap(key) {
    var keys = {
      s: 'selector',
      m: 'mode',
      c: 'colorer',
      mt: 'material',
      mode: 'modes',
      color: 'colorers',
      colorer: 'colorers',
      select: 'selector',
      material: 'materials',
      selector: 'selector'
    }
    var ans = keys[key]
    return ans === undefined ? key : ans
  }

  var CLIUtils = /*#__PURE__*/ (function () {
    function CLIUtils() {
      _classCallCheck(this, CLIUtils)
    }

    _createClass(CLIUtils, [
      {
        key: 'list',
        value: function list(miew, repMap, key) {
          var ret = ''

          if (miew && repMap !== undefined) {
            if (key === undefined || key === '-e') {
              var count = miew.repCount()

              for (var i = 0; i < count; i++) {
                ret += this.listRep(miew, repMap, i, key)
              }
            }
          }

          return ret
        }
      },
      {
        key: 'listRep',
        value: function listRep(miew, repMap, repIndex, key) {
          var ret = ''
          var rep = miew.repGet(repIndex)

          if (!rep) {
            logger.warn('Rep '.concat(repIndex, ' does not exist!'))
            return ret
          }

          var index = repIndex
          var repName = repMap.get(index)
          var mode = rep.mode,
            colorer = rep.colorer
          var selectionStr = rep.selectorString
          var material = rep.materialPreset
          ret += '#'
            .concat(index, ' : ')
            .concat(mode.name)
            .concat(repName === '<no name>' ? '' : ', '.concat(repName), '\n')

          if (key !== undefined) {
            ret += '    selection : "'.concat(selectionStr, '"\n')
            ret += '    mode      : ('
              .concat(mode.id, '), ')
              .concat(mode.name, '\n')
            ret += '    colorer   : ('
              .concat(colorer.id, '), ')
              .concat(colorer.name, '\n')
            ret += '    material  : ('
              .concat(material.id, '), ')
              .concat(material.name, '\n')
          }

          return ret
        }
      },
      {
        key: 'listSelector',
        value: function listSelector(miew, context) {
          var ret = ''

          for (var k in context) {
            if (context.hasOwnProperty(k)) {
              ret += ''.concat(k, ' : "').concat(context[k], '"\n')
            }
          }

          return ret
        }
      },
      {
        key: 'listObjs',
        value: function listObjs(miew) {
          var objs = miew._objects

          if (!objs || !Array.isArray(objs) || objs.length === 0) {
            return 'There are no objects on the scene'
          }

          var strList = []

          for (var i = 0, n = objs.length; i < n; ++i) {
            strList[i] = ''.concat(i, ': ').concat(objs[i].toString())
          }

          return strList.join('\n')
        }
      },
      {
        key: 'joinHelpStr',
        value: function joinHelpStr(helpData) {
          if (helpData instanceof Array) {
            return helpData.join('\n')
          }

          return helpData
        }
      },
      {
        key: 'help',
        value: function help$1(path) {
          if (___default['default'].isUndefined(path)) {
            return ''
              .concat(this.joinHelpStr(help.$help), '\n')
              .concat(
                ___default['default']
                  .slice(
                    ___default['default'].sortBy(
                      ___default['default'].keys(help)
                    ),
                    1
                  )
                  .join(', '),
                '\n'
              )
          }

          var helpItem = ___default['default'].get(help, path)

          return ___default['default'].isUndefined(helpItem)
            ? this.help()
            : ''.concat(this.joinHelpStr(helpItem.$help), '\n')
        }
      },
      {
        key: 'load',
        value: function load(miew, arg) {
          if (miew === undefined || arg === undefined || arg === '-f') {
            return
          }

          miew.awaitWhileCMDisInProcess()

          var finish = function finish() {
            return miew.finishAwaitingCMDInProcess()
          }

          miew.load(arg).then(finish, finish)
        }
      },
      {
        key: 'checkArg',
        value: function checkArg(key, arg, modificate) {
          if (key !== undefined && arg !== undefined) {
            if (keyRemap(key) === 'selector') {
              var res = selectors.parse(arg)

              if (res.error !== undefined) {
                var selExc = {
                  message: res.error
                }
                throw selExc
              }

              if (modificate !== undefined && modificate) {
                return res.selector
              }

              return arg
            }

            var modificators = {
              colorers: colorers,
              modes: modes,
              materials: materials
            }
            var modificator = key
            var temp

            while (modificator !== temp) {
              temp = modificator
              modificator = keyRemap(temp)
            }

            if (modificators[modificator].get(arg) === undefined) {
              var exc = {
                message: ''
                  .concat(arg, ' is not existed in ')
                  .concat(modificator)
              }
              throw exc
            }

            return arg
          }

          return NULL
        }
      },
      {
        key: 'propagateProp',
        value: function propagateProp(path, arg) {
          if (path !== undefined) {
            var argExc = {}

            var adapter =
              options.adapters[
                _typeof(___default['default'].get(settings.defaults, path))
              ]

            if (adapter === undefined) {
              var pathExc = {
                message: ''.concat(path, ' is not existed')
              }
              throw pathExc
            }

            if (
              (path.endsWith('.color') ||
                path.endsWith('.baseColor') ||
                path.endsWith('.EL.carbon')) &&
              typeof arg !== 'number'
            ) {
              arg = palettes.get(settings.now.palette).getNamedColor(arg)
            }

            if (path.endsWith('.fg') || path.endsWith('.bg')) {
              if (typeof arg !== 'number') {
                var val = palettes
                  .get(settings.now.palette)
                  .getNamedColor(arg, true)

                if (val !== undefined) {
                  arg = '0x'.concat(val.toString(16))
                }
              } else {
                arg = '0x'.concat(arg.toString(16))
              }
            }

            if (path.endsWith('.template')) {
              arg = arg.replace(/\\n/g, '\n')
            }

            if (
              arg !== undefined &&
              adapter(arg) !== arg &&
              adapter(arg) !== arg > 0
            ) {
              argExc = {
                message: ''
                  .concat(path, ' must be a "')
                  .concat(
                    _typeof(___default['default'].get(settings.defaults, path)),
                    '"'
                  )
              }
              throw argExc
            }
          }

          return arg
        }
      },
      {
        key: 'unquoteString',
        value: function unquoteString(value) {
          return utils.unquoteString(value)
        }
      }
    ])

    return CLIUtils
  })()

  var utilFunctions = new CLIUtils()

  function CreateObjectPair(a, b) {
    var obj = {}
    obj[a] = b
    return obj
  }

  function ArgList(arg) {
    if (arg instanceof this.constructor) {
      return arg
    }

    if (arg instanceof Array) {
      this._values = arg.slice(0)
    } else if (arg) {
      this._values = [arg]
    } else {
      this._values = []
    }
  }

  ArgList.prototype.append = function (value) {
    var values = this._values
    values[values.length] = value
    return this
  }

  ArgList.prototype.remove = function (value) {
    var values = this._values
    var index = values.indexOf(value)

    if (index >= 0) {
      values.splice(index, 1)
    }

    return this
  }

  ArgList.prototype.toJSO = function (cliUtils, cmd, arg) {
    var res = {}
    var list = this._values

    for (var i = 0, n = list.length; i < n; ++i) {
      ___default['default'].set(
        res,
        list[i].id,
        cliUtils.propagateProp(
          ''.concat(keyRemap(cmd), '.').concat(arg, '.').concat(list[i].id),
          list[i].val
        )
      )
    }

    return res
  }

  function Arg(_id, _val) {
    this.id = _id
    this.val = _val
  }

  var cliutils = Object.create({})
  cliutils.Arg = Arg
  cliutils.ArgList = ArgList
  cliutils.miew = null
  cliutils.echo = null
  cliutils.representations = representationsStorage
  cliutils.utils = utilFunctions
  cliutils._ = ___default['default']
  cliutils.CreateObjectPair = CreateObjectPair
  cliutils.keyRemap = keyRemap
  cliutils.Context = selectors.Context
  cliutils.ClearContext = selectors.ClearContext
  cliutils.NULL = NULL

  cliutils.notimplemented = function () {
    return this.NULL
  }

  Miew.prototype.script = function (script, _printCallback, _errorCallback) {
    MiewCLIParser.parser.yy.miew = this
    MiewCLIParser.parser.yy.echo = _printCallback
    MiewCLIParser.parser.yy.error = _errorCallback

    if (this.cmdQueue === undefined) {
      this.cmdQueue = []
    }

    if (this.commandInAction === undefined) {
      this.commandInAction = false
    }

    this.cmdQueue = this.cmdQueue.concat(script.split('\n'))
  }

  Miew.prototype.awaitWhileCMDisInProcess = function () {
    this.commandInAction = true
  }

  Miew.prototype.finishAwaitingCMDInProcess = function () {
    this.commandInAction = false
  }

  Miew.prototype.isScriptingCommandAvailable = function () {
    return (
      this.commandInAction !== undefined &&
      !this.commandInAction &&
      this.cmdQueue !== undefined &&
      this.cmdQueue.length > 0
    )
  }

  Miew.prototype.callNextCmd = function () {
    if (this.isScriptingCommandAvailable()) {
      var cmd = this.cmdQueue.shift()
      var res = {}
      res.success = false

      try {
        MiewCLIParser.parser.parse(cmd)
        res.success = true
      } catch (e) {
        res.error = e.message
        MiewCLIParser.parser.yy.error(res.error)
        this.finishAwaitingCMDInProcess()
      }

      return res
    }

    return ''
  }

  MiewCLIParser.parser.yy = cliutils
  MiewCLIParser.parser.yy.parseError = MiewCLIParser.parser.parseError

  return Miew
})
//# sourceMappingURL=Miew.js.map
