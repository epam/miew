/*! Miew - 3D Molecular Viewer v0.11.0 Copyright (c) 2015-2024 EPAM Systems, Inc. */
import * as __WEBPACK_EXTERNAL_MODULE_lodash__ from "lodash";
import * as __WEBPACK_EXTERNAL_MODULE_three__ from "three";
/******/ var __webpack_modules__ = ({

/***/ 89:
/***/ ((module) => {

/* eslint-disable */
// DO NOT EDIT! Automatically generated from .jison
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = function () {
  var o = function (k, v, o, l) {
      for (o = o || {}, l = k.length; l--; o[k[l]] = v);
      return o;
    },
    $V0 = [1, 60],
    $V1 = [1, 62],
    $V2 = [1, 63],
    $V3 = [1, 65],
    $V4 = [1, 66],
    $V5 = [1, 67],
    $V6 = [1, 68],
    $V7 = [1, 69],
    $V8 = [1, 80],
    $V9 = [1, 72],
    $Va = [1, 73],
    $Vb = [1, 74],
    $Vc = [1, 75],
    $Vd = [1, 99],
    $Ve = [1, 76],
    $Vf = [1, 100],
    $Vg = [1, 79],
    $Vh = [1, 51],
    $Vi = [1, 81],
    $Vj = [1, 82],
    $Vk = [1, 84],
    $Vl = [1, 83],
    $Vm = [1, 85],
    $Vn = [1, 96],
    $Vo = [1, 97],
    $Vp = [1, 98],
    $Vq = [1, 86],
    $Vr = [1, 87],
    $Vs = [1, 64],
    $Vt = [1, 70],
    $Vu = [1, 71],
    $Vv = [1, 77],
    $Vw = [1, 78],
    $Vx = [1, 53],
    $Vy = [1, 54],
    $Vz = [1, 55],
    $VA = [1, 61],
    $VB = [1, 88],
    $VC = [1, 89],
    $VD = [1, 90],
    $VE = [1, 91],
    $VF = [1, 92],
    $VG = [1, 93],
    $VH = [1, 94],
    $VI = [1, 95],
    $VJ = [1, 101],
    $VK = [1, 102],
    $VL = [1, 103],
    $VM = [1, 104],
    $VN = [1, 105],
    $VO = [1, 56],
    $VP = [1, 57],
    $VQ = [1, 58],
    $VR = [1, 59],
    $VS = [1, 115],
    $VT = [1, 111],
    $VU = [1, 114],
    $VV = [1, 112],
    $VW = [1, 113],
    $VX = [1, 118],
    $VY = [1, 117],
    $VZ = [1, 134],
    $V_ = [1, 149],
    $V$ = [1, 150],
    $V01 = [1, 157],
    $V11 = [5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101],
    $V21 = [5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 71, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101],
    $V31 = [5, 6, 7, 9, 13, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95],
    $V41 = [5, 70, 72],
    $V51 = [5, 74],
    $V61 = [71, 101];
  var parser = {
    trace: function trace() {},
    yy: {},
    symbols_: {
      "error": 2,
      "Program": 3,
      "Command": 4,
      "EOF": 5,
      "RESET": 6,
      "BUILD": 7,
      "ALL": 8,
      "HELP": 9,
      "Path": 10,
      "MOTM": 11,
      "OneArgCommand": 12,
      "GET": 13,
      "STRING": 14,
      "SET": 15,
      "Value": 16,
      "SET_SAVE": 17,
      "SET_RESTORE": 18,
      "SET_RESET": 19,
      "PRESET": 20,
      "AddRepresentation": 21,
      "EditRepresentation": 22,
      "REMOVE": 23,
      "RepresentationReference": 24,
      "HIDE": 25,
      "SHOW": 26,
      "LIST": 27,
      "EXPAND_KEY": 28,
      "SELECTOR_KEY": 29,
      "SELECT": 30,
      "AS": 31,
      "WordAll": 32,
      "SELECTOR": 33,
      "WITHIN": 34,
      "NUMBER": 35,
      "OF": 36,
      "MATERIAL": 37,
      "IDENTIFIER": 38,
      "ModeCMD": 39,
      "ColorCMD": 40,
      "VIEW": 41,
      "BASE_64": 42,
      "UNIT": 43,
      "DSSP": 44,
      "SCALE": 45,
      "ROTATE": 46,
      "AxesList": 47,
      "TRANSLATE": 48,
      "CENTER": 49,
      "GetURLBranch": 50,
      "Screenshot": 51,
      "LINE": 52,
      "ArgList": 53,
      "LISTOBJ": 54,
      "REMOVEOBJ": 55,
      "URL": 56,
      "VIEW_KEY": 57,
      "SCREENSHOT": 58,
      "LOAD": 59,
      "Url": 60,
      "FILE_KEY": 61,
      "ADD": 62,
      "Description": 63,
      "REP": 64,
      "MODE": 65,
      "COLOR": 66,
      "Descriptor": 67,
      "RepresentationOwnProperty": 68,
      "RepresentationOwnPropertyOpts": 69,
      "DESC_KEY": 70,
      "=": 71,
      "DESC_KEY_OPTS": 72,
      "AxesArg": 73,
      "DESC_KEY_AXES": 74,
      "Arg": 75,
      "PathWoDescKey": 76,
      "HEX": 77,
      "BOOL": 78,
      "Word": 79,
      "CommandSetWoDESC_KEY": 80,
      "DescKeys": 81,
      "CLEAR": 82,
      "FILE_LIST": 83,
      "FILE_REGISTER": 84,
      "FILE_DELETE": 85,
      "PRESET_ADD": 86,
      "PRESET_DELETE": 87,
      "PRESET_UPDATE": 88,
      "PRESET_RENAME": 89,
      "PRESET_OPEN": 90,
      "CREATE_SCENARIO": 91,
      "RESET_SCENARIO": 92,
      "DELETE_SCENARIO": 93,
      "ADD_SCENARIO_ITEM": 94,
      "LIST_SCENARIO": 95,
      "PDB_KEY": 96,
      "DELAY_KEY": 97,
      "PRST_KEY": 98,
      "DESCRIPTION_KEY": 99,
      "CommandSet": 100,
      ".": 101,
      "PresetPath": 102,
      "/": 103,
      "HexOrNumber": 104,
      "$accept": 0,
      "$end": 1
    },
    terminals_: {
      2: "error",
      5: "EOF",
      6: "RESET",
      7: "BUILD",
      8: "ALL",
      9: "HELP",
      11: "MOTM",
      13: "GET",
      14: "STRING",
      15: "SET",
      17: "SET_SAVE",
      18: "SET_RESTORE",
      19: "SET_RESET",
      20: "PRESET",
      23: "REMOVE",
      25: "HIDE",
      26: "SHOW",
      27: "LIST",
      28: "EXPAND_KEY",
      29: "SELECTOR_KEY",
      30: "SELECT",
      31: "AS",
      33: "SELECTOR",
      34: "WITHIN",
      35: "NUMBER",
      36: "OF",
      37: "MATERIAL",
      38: "IDENTIFIER",
      41: "VIEW",
      42: "BASE_64",
      43: "UNIT",
      44: "DSSP",
      45: "SCALE",
      46: "ROTATE",
      48: "TRANSLATE",
      49: "CENTER",
      52: "LINE",
      54: "LISTOBJ",
      55: "REMOVEOBJ",
      56: "URL",
      57: "VIEW_KEY",
      58: "SCREENSHOT",
      59: "LOAD",
      61: "FILE_KEY",
      62: "ADD",
      64: "REP",
      65: "MODE",
      66: "COLOR",
      70: "DESC_KEY",
      71: "=",
      72: "DESC_KEY_OPTS",
      74: "DESC_KEY_AXES",
      77: "HEX",
      78: "BOOL",
      82: "CLEAR",
      83: "FILE_LIST",
      84: "FILE_REGISTER",
      85: "FILE_DELETE",
      86: "PRESET_ADD",
      87: "PRESET_DELETE",
      88: "PRESET_UPDATE",
      89: "PRESET_RENAME",
      90: "PRESET_OPEN",
      91: "CREATE_SCENARIO",
      92: "RESET_SCENARIO",
      93: "DELETE_SCENARIO",
      94: "ADD_SCENARIO_ITEM",
      95: "LIST_SCENARIO",
      96: "PDB_KEY",
      97: "DELAY_KEY",
      98: "PRST_KEY",
      99: "DESCRIPTION_KEY",
      101: ".",
      103: "/"
    },
    productions_: [0, [3, 2], [3, 1], [4, 1], [4, 1], [4, 2], [4, 1], [4, 2], [4, 1], [4, 1], [4, 2], [4, 2], [4, 3], [4, 3], [4, 1], [4, 1], [4, 1], [4, 1], [4, 2], [4, 1], [4, 1], [4, 2], [4, 2], [4, 2], [4, 2], [4, 1], [4, 2], [4, 2], [4, 2], [4, 4], [4, 2], [4, 6], [4, 2], [4, 1], [4, 1], [4, 1], [4, 2], [4, 2], [4, 1], [4, 2], [4, 1], [4, 2], [4, 2], [4, 2], [4, 1], [4, 2], [4, 1], [4, 1], [4, 3], [4, 3], [4, 4], [4, 4], [4, 1], [4, 2], [50, 1], [50, 2], [50, 2], [50, 3], [50, 3], [51, 1], [51, 2], [51, 3], [12, 2], [12, 2], [12, 2], [21, 1], [21, 2], [21, 2], [21, 3], [22, 2], [22, 3], [39, 2], [39, 3], [40, 2], [40, 3], [24, 1], [24, 1], [63, 1], [63, 2], [63, 3], [63, 4], [67, 1], [67, 1], [67, 2], [68, 3], [69, 3], [47, 1], [47, 2], [73, 2], [53, 1], [53, 2], [75, 3], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [79, 1], [79, 1], [32, 1], [32, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [100, 1], [100, 1], [76, 1], [76, 3], [76, 3], [10, 1], [10, 1], [10, 3], [10, 3], [10, 3], [60, 1], [102, 1], [102, 3], [104, 1], [104, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
      /* this == yyval */

      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
          break;
        case 3:
          this.$ = yy.miew.reset(false);
          yy.ClearContext();
          yy.miew.resetReps("empty");
          break;
        case 4:
          this.$ = yy.miew.rebuild();
          break;
        case 5:
          this.$ = yy.miew.rebuildAll();
          yy.miew.rebuild();
          break;
        case 6:
          this.$ = yy.echo(yy.utils.help().toString());
          break;
        case 7:
          this.$ = yy.echo(yy.utils.help($$[$0]).toString());
          break;
        case 8:
          this.$ = yy.miew.motm();
          break;
        case 10:
        case 11:
          this.$ = yy.utils.propagateProp($$[$0]);
          yy.echo(yy.miew.get($$[$0]).toString());
          break;
        case 12:
        case 13:
          this.$ = yy.miew.set($$[$0 - 1], yy.utils.propagateProp($$[$0 - 1], $$[$0]));
          ;
          break;
        case 14:
          this.$ = yy.miew.saveSettings();
          ;
          break;
        case 15:
          this.$ = yy.miew.restoreSettings();
          ;
          break;
        case 16:
          this.$ = yy.miew.resetSettings();
          ;
          break;
        case 17:
          this.$ = yy.miew.resetReps();
          break;
        case 18:
          this.$ = yy.miew.applyPreset($$[$0]);
          break;
        case 21:
          this.$ = yy.miew.repRemove($$[$0]);
          yy.representations.remove($$[$0]);
          break;
        case 22:
          this.$ = yy.miew.repHide($$[$0]);
          break;
        case 23:
          this.$ = yy.miew.repHide($$[$0], false);
          break;
        case 24:
          this.$ = yy.echo(yy.utils.listRep(yy.miew, yy.representations, $$[$0], '-e'));
          break;
        case 25:
          this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
          break;
        case 26:
          this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
          break;
        case 27:
          this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
          break;
        case 28:
          this.$ = yy.miew.select(yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0], true));
          break;
        case 29:
          this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg($$[$0 - 3].toLowerCase(), $$[$0 - 2], true);
          yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
          break;
        case 30:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            selector: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0])
          });
          break;
        case 31:
          this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(yy.utils.checkArg("select", $$[$0 - 2], true), Number($$[$0 - 4]));
          break;
        case 32:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            material: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
          });
          break;
        case 35:
          this.$ = yy.echo(yy.miew.view());
          break;
        case 36:
        case 37:
          this.$ = yy.miew.view($$[$0]);
          break;
        case 38:
          this.$ = yy.echo(yy.miew.changeUnit());
          break;
        case 39:
          this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
          break;
        case 40:
          this.$ = yy.miew.dssp();
          break;
        case 41:
          this.$ = yy.miew.scale($$[$0]);
          break;
        case 42:
          for (var i = 0, n = $$[$0].length; i < n; i++) {
            yy.miew.rotate($$[$0][i]['x'] * Math.PI / 180.0, $$[$0][i]['y'] * Math.PI / 180.0, $$[$0][i]['z'] * Math.PI / 180.0);
          }
          break;
        case 43:
          for (var i = 0, n = $$[$0].length; i < n; i++) {
            yy.miew.translate($$[$0][i]['x'] || 0, $$[$0][i]['y'] || 0, $$[$0][i]['z'] || 0);
          }
          break;
        case 44:
          this.$ = yy.miew.center();
          break;
        case 45:
          this.$ = yy.miew.center($$[$0]);
          break;
        case 48:
        case 49:
          this.$ = yy.miew.addObject({
            type: 'line',
            params: [$$[$0 - 1], $$[$0]]
          }, true);
          break;
        case 50:
        case 51:
          this.$ = yy.miew.addObject({
            type: 'line',
            params: [$$[$0 - 2], $$[$0 - 1]],
            opts: $$[$0].toJSO(yy.utils, 'objects', 'line')
          }, true);
          break;
        case 52:
          this.$ = yy.echo(yy.utils.listObjs(yy.miew));
          break;
        case 53:
          this.$ = yy.miew.removeObject($$[$0]);
          break;
        case 54:
          this.$ = yy.echo(yy.miew.getURL({
            view: false,
            settings: false
          }));
          break;
        case 55:
          this.$ = yy.echo(yy.miew.getURL({
            view: false,
            settings: true
          }));
          break;
        case 56:
          this.$ = yy.echo(yy.miew.getURL({
            view: true,
            settings: false
          }));
          break;
        case 57:
        case 58:
          this.$ = yy.echo(yy.miew.getURL({
            view: true,
            settings: true
          }));
          break;
        case 59:
          this.$ = yy.miew.screenshotSave();
          break;
        case 60:
          this.$ = yy.miew.screenshotSave('', Number($$[$0]));
          break;
        case 61:
          this.$ = yy.miew.screenshotSave('', Number($$[$0 - 1]), Number($$[$0]));
          break;
        case 62:
        case 63:
        case 64:
          this.$ = yy.utils.load(yy.miew, $$[$0]);
          yy.representations.clear();
          break;
        case 65:
          this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
          break;
        case 66:
          this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
          break;
        case 67:
          this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
          break;
        case 68:
          this.$ = yy.echo(yy.representations.add($$[$0 - 1], yy.miew.repAdd($$[$0])));
          break;
        case 69:
          this.$ = yy.miew.rep($$[$0]);
          yy.miew.repCurrent($$[$0]);
          break;
        case 70:
          this.$ = yy.miew.rep($$[$0 - 1], $$[$0]);
          yy.miew.repCurrent($$[$0 - 1]);
          break;
        case 71:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            mode: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
          });
          break;
        case 72:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            mode: new Array(yy.utils.checkArg($$[$0 - 2].toLowerCase(), $$[$0 - 1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase()))
          });
          break;
        case 73:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            colorer: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
          });
          break;
        case 74:
          this.$ = yy.miew.rep(yy.miew.repCurrent(), {
            colorer: new Array(yy.utils.checkArg($$[$0 - 2].toLowerCase(), $$[$0 - 1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase()))
          });
          break;
        case 75:
          this.$ = Number(yy.representations.get($$[$0]));
          break;
        case 76:
        case 92:
          this.$ = Number($$[$0]);
          break;
        case 77:
          this.$ = $$[$0];
          break;
        case 78:
          this.$ = yy._.assign($$[$0 - 1], $$[$0]);
          break;
        case 79:
          this.$ = yy._.assign($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 80:
          this.$ = yy._.assign($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 81:
        case 82:
          this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
          break;
        case 83:
          this.$ = yy.CreateObjectPair($$[$0 - 1].key, new Array($$[$0 - 1].val, $$[$0].toJSO(yy.utils, $$[$0 - 1].key, $$[$0 - 1].val)));
          break;
        case 84:
        case 85:
          this.$ = Object.create({
            'key': yy.keyRemap($$[$0 - 2]),
            'val': yy.utils.checkArg($$[$0 - 2], $$[$0])
          });
          break;
        case 86:
          this.$ = [$$[$0]];
          break;
        case 87:
          this.$ = $$[$0 - 1].concat($$[$0]);
          break;
        case 88:
          this.$ = yy.CreateObjectPair($$[$0 - 1].toLowerCase(), Number($$[$0]));
          break;
        case 89:
          this.$ = new yy.ArgList($$[$0]);
          break;
        case 90:
          this.$ = $$[$0 - 1].append($$[$0]);
          break;
        case 91:
          this.$ = new yy.Arg($$[$0 - 2], $$[$0]);
          break;
        case 93:
          this.$ = parseInt($$[$0]);
          break;
        case 94:
          this.$ = JSON.parse($$[$0]);
          break;
        case 95:
        case 96:
          this.$ = String($$[$0]);
          break;
        case 157:
        case 158:
        case 161:
        case 162:
        case 163:
          this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0]; //cause of could be color word in path;
          break;
        case 166:
          this.$ = $$[$0 - 2] = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
          break;
      }
    },
    table: [{
      3: 1,
      4: 2,
      5: [1, 3],
      6: [1, 4],
      7: [1, 5],
      9: [1, 6],
      11: [1, 7],
      12: 8,
      13: [1, 9],
      15: [1, 10],
      17: [1, 11],
      18: [1, 12],
      19: [1, 13],
      20: [1, 14],
      21: 15,
      22: 16,
      23: [1, 17],
      25: [1, 18],
      26: [1, 19],
      27: [1, 20],
      30: [1, 21],
      33: [1, 22],
      34: [1, 23],
      37: [1, 24],
      39: 25,
      40: 26,
      41: [1, 27],
      43: [1, 28],
      44: [1, 29],
      45: [1, 30],
      46: [1, 31],
      48: [1, 32],
      49: [1, 33],
      50: 34,
      51: 35,
      52: [1, 36],
      54: [1, 37],
      55: [1, 38],
      56: [1, 44],
      58: [1, 45],
      59: [1, 39],
      62: [1, 40],
      64: [1, 41],
      65: [1, 42],
      66: [1, 43]
    }, {
      1: [3]
    }, {
      5: [1, 46]
    }, {
      1: [2, 2]
    }, {
      5: [2, 3]
    }, {
      5: [2, 4],
      8: [1, 47]
    }, {
      5: [2, 6],
      6: $V0,
      7: $V1,
      9: $V2,
      10: 48,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 8]
    }, {
      5: [2, 9]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 106,
      13: $V3,
      14: [1, 107],
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 108,
      13: $V3,
      14: [1, 109],
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 14]
    }, {
      5: [2, 15]
    }, {
      5: [2, 16]
    }, {
      5: [2, 17],
      14: $VS,
      16: 110,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      5: [2, 19]
    }, {
      5: [2, 20]
    }, {
      24: 116,
      35: $VX,
      38: $VY
    }, {
      24: 119,
      35: $VX,
      38: $VY
    }, {
      24: 120,
      35: $VX,
      38: $VY
    }, {
      5: [2, 25],
      24: 121,
      28: [1, 122],
      29: [1, 123],
      35: $VX,
      38: $VY
    }, {
      14: [1, 124]
    }, {
      14: [1, 125]
    }, {
      35: [1, 126]
    }, {
      38: [1, 127]
    }, {
      5: [2, 33]
    }, {
      5: [2, 34]
    }, {
      5: [2, 35],
      14: [1, 128],
      42: [1, 129]
    }, {
      5: [2, 38],
      35: [1, 130]
    }, {
      5: [2, 40]
    }, {
      35: [1, 131]
    }, {
      47: 132,
      73: 133,
      74: $VZ
    }, {
      47: 135,
      73: 133,
      74: $VZ
    }, {
      5: [2, 44],
      14: [1, 136]
    }, {
      5: [2, 46]
    }, {
      5: [2, 47]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 138,
      13: $V3,
      14: [1, 137],
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 52]
    }, {
      35: [1, 139]
    }, {
      14: [1, 143],
      38: [1, 141],
      60: 140,
      61: [1, 142]
    }, {
      5: [2, 65],
      38: [1, 144],
      63: 145,
      67: 146,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, {
      24: 151,
      35: $VX,
      38: $VY
    }, {
      38: [1, 152]
    }, {
      38: [1, 153]
    }, {
      5: [2, 54],
      29: [1, 154],
      57: [1, 155]
    }, {
      5: [2, 59],
      35: [1, 156]
    }, {
      1: [2, 1]
    }, {
      5: [2, 5]
    }, {
      5: [2, 7],
      101: $V01
    }, o($V11, [2, 159]), o($V11, [2, 160]), o($V21, [2, 97]), o($V21, [2, 98]), o($V11, [2, 147]), o($V11, [2, 148]), o($V11, [2, 149]), o($V11, [2, 150]), o($V11, [2, 151]), o($V11, [2, 152]), o($V11, [2, 153]), o($V21, [2, 101]), o($V21, [2, 102]), o($V21, [2, 103]), o($V21, [2, 104]), o($V21, [2, 105]), o($V21, [2, 106]), o($V21, [2, 107]), o($V21, [2, 108]), o($V21, [2, 109]), o($V21, [2, 110]), o($V21, [2, 111]), o($V21, [2, 112]), o($V21, [2, 113]), o($V21, [2, 114]), o($V21, [2, 115]), o($V21, [2, 116]), o($V21, [2, 117]), o($V21, [2, 118]), o($V21, [2, 119]), o($V21, [2, 120]), o($V21, [2, 121]), o($V21, [2, 122]), o($V21, [2, 123]), o($V21, [2, 124]), o($V21, [2, 125]), o($V21, [2, 126]), o($V21, [2, 127]), o($V21, [2, 128]), o($V21, [2, 129]), o($V21, [2, 130]), o($V21, [2, 131]), o($V21, [2, 132]), o($V21, [2, 133]), o($V21, [2, 134]), o($V21, [2, 135]), o($V21, [2, 136]), o($V21, [2, 137]), o($V21, [2, 138]), o($V21, [2, 139]), o($V21, [2, 140]), o($V21, [2, 141]), o($V21, [2, 142]), o($V21, [2, 143]), o($V21, [2, 144]), o($V21, [2, 145]), o($V21, [2, 146]), {
      5: [2, 10],
      101: $V01
    }, {
      5: [2, 11]
    }, {
      14: $VS,
      16: 158,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW,
      101: $V01
    }, {
      14: $VS,
      16: 159,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      5: [2, 18]
    }, o($V31, [2, 92]), o($V31, [2, 93]), o($V31, [2, 94]), o($V31, [2, 95]), o($V31, [2, 96]), {
      5: [2, 21]
    }, o($V41, [2, 75]), o($V41, [2, 76]), {
      5: [2, 22]
    }, {
      5: [2, 23]
    }, {
      5: [2, 24]
    }, {
      5: [2, 26]
    }, {
      5: [2, 27]
    }, {
      5: [2, 28],
      31: [1, 160]
    }, {
      5: [2, 30]
    }, {
      36: [1, 161]
    }, {
      5: [2, 32]
    }, {
      5: [2, 36]
    }, {
      5: [2, 37]
    }, {
      5: [2, 39]
    }, {
      5: [2, 41]
    }, {
      5: [2, 42],
      73: 162,
      74: $VZ
    }, o($V51, [2, 86]), {
      35: [1, 163]
    }, {
      5: [2, 43],
      73: 162,
      74: $VZ
    }, {
      5: [2, 45]
    }, {
      14: [1, 164]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      10: 165,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 49,
      80: 52,
      81: 50,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR,
      101: $V01
    }, {
      5: [2, 53]
    }, {
      5: [2, 62]
    }, {
      5: [2, 63]
    }, {
      5: [2, 64]
    }, {
      5: [2, 164]
    }, {
      5: [2, 66],
      63: 166,
      67: 146,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, {
      5: [2, 67]
    }, {
      5: [2, 77],
      67: 167,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, o($V41, [2, 81]), o($V41, [2, 82], {
      80: 52,
      53: 168,
      75: 169,
      76: 170,
      79: 171,
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }), {
      71: [1, 172]
    }, {
      71: [1, 173]
    }, {
      5: [2, 69],
      63: 174,
      67: 146,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, {
      5: [2, 71],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 175,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 73],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 176,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 55],
      57: [1, 177]
    }, {
      5: [2, 56],
      29: [1, 178]
    }, {
      5: [2, 60],
      35: [1, 179]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      35: [1, 181],
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 180,
      80: 52,
      81: 182,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 12]
    }, {
      5: [2, 13]
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      32: 183,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 184,
      80: 52,
      81: 185,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      14: [1, 186]
    }, o($V51, [2, 87]), o($V51, [2, 88]), {
      5: [2, 48],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 187,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 49],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      53: 188,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 169,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      101: $V01
    }, {
      5: [2, 68]
    }, {
      5: [2, 78],
      67: 189,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, o($V41, [2, 83], {
      80: 52,
      76: 170,
      79: 171,
      75: 190,
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }), o($V31, [2, 89]), {
      71: [1, 191],
      101: [1, 192]
    }, o($V61, [2, 156]), {
      14: $VS,
      16: 193,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      14: $VS,
      16: 194,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      5: [2, 70]
    }, {
      5: [2, 72],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 74],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 57]
    }, {
      5: [2, 58]
    }, {
      5: [2, 61]
    }, o($V11, [2, 161]), o($V11, [2, 162]), o($V11, [2, 163]), {
      5: [2, 29]
    }, {
      5: [2, 99]
    }, {
      5: [2, 100]
    }, {
      31: [1, 195]
    }, {
      5: [2, 50],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 51],
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      75: 190,
      76: 170,
      79: 171,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, {
      5: [2, 79],
      67: 196,
      68: 147,
      69: 148,
      70: $V_,
      72: $V$
    }, o($V31, [2, 90]), {
      14: $VS,
      16: 197,
      35: $VT,
      38: $VU,
      77: $VV,
      78: $VW
    }, {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      33: $Ve,
      34: $Vf,
      35: [1, 199],
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      79: 198,
      80: 52,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN
    }, o($V41, [2, 84]), o($V31, [2, 85]), {
      6: $V0,
      7: $V1,
      9: $V2,
      13: $V3,
      15: $V4,
      17: $V5,
      18: $V6,
      19: $V7,
      20: $V8,
      23: $V9,
      25: $Va,
      26: $Vb,
      27: $Vc,
      30: $Vd,
      32: 200,
      33: $Ve,
      34: $Vf,
      37: $Vg,
      38: $Vh,
      41: $Vi,
      43: $Vj,
      45: $Vk,
      46: $Vl,
      49: $Vm,
      52: $Vn,
      54: $Vo,
      55: $Vp,
      56: $Vq,
      58: $Vr,
      59: $Vs,
      62: $Vt,
      64: $Vu,
      65: $Vv,
      66: $Vw,
      70: $Vx,
      72: $Vy,
      74: $Vz,
      79: 184,
      80: 52,
      81: 185,
      82: $VA,
      83: $VB,
      84: $VC,
      85: $VD,
      86: $VE,
      87: $VF,
      88: $VG,
      89: $VH,
      90: $VI,
      91: $VJ,
      92: $VK,
      93: $VL,
      94: $VM,
      95: $VN,
      96: $VO,
      97: $VP,
      98: $VQ,
      99: $VR
    }, {
      5: [2, 80]
    }, o($V31, [2, 91]), o($V61, [2, 157]), o($V61, [2, 158]), {
      5: [2, 31]
    }],
    defaultActions: {
      3: [2, 2],
      4: [2, 3],
      7: [2, 8],
      8: [2, 9],
      11: [2, 14],
      12: [2, 15],
      13: [2, 16],
      15: [2, 19],
      16: [2, 20],
      25: [2, 33],
      26: [2, 34],
      29: [2, 40],
      34: [2, 46],
      35: [2, 47],
      37: [2, 52],
      46: [2, 1],
      47: [2, 5],
      107: [2, 11],
      110: [2, 18],
      116: [2, 21],
      119: [2, 22],
      120: [2, 23],
      121: [2, 24],
      122: [2, 26],
      123: [2, 27],
      125: [2, 30],
      127: [2, 32],
      128: [2, 36],
      129: [2, 37],
      130: [2, 39],
      131: [2, 41],
      136: [2, 45],
      139: [2, 53],
      140: [2, 62],
      141: [2, 63],
      142: [2, 64],
      143: [2, 164],
      145: [2, 67],
      158: [2, 12],
      159: [2, 13],
      166: [2, 68],
      174: [2, 70],
      177: [2, 57],
      178: [2, 58],
      179: [2, 61],
      183: [2, 29],
      184: [2, 99],
      185: [2, 100],
      196: [2, 80],
      200: [2, 31]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this,
        stack = [0],
        tstack = [],
        vstack = [null],
        lstack = [],
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = {
        yy: {}
      };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      function lex() {
        var token;
        token = tstack.pop() || lexer.lex() || EOF;
        if (typeof token !== 'number') {
          if (token instanceof Array) {
            tstack = token;
            token = tstack.pop();
          }
          token = self.symbols_[token] || token;
        }
        return token;
      }
      var symbol,
        preErrorSymbol,
        state,
        action,
        a,
        r,
        yyval = {},
        p,
        len,
        newState,
        expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
          var errStr = '';
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push('\'' + this.terminals_[p] + '\'');
            }
          }
          if (lexer.showPosition) {
            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
          } else {
            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
          }
          this.parseError(errStr, {
            text: lexer.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer.yylineno,
            loc: yyloc,
            expected: expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer.yyleng;
              yytext = lexer.yytext;
              yylineno = lexer.yylineno;
              yyloc = lexer.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
            if (typeof r !== 'undefined') {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };

  /* generated by jison-lex 0.3.4 */
  var lexer = function () {
    var lexer = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function () {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function () {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function (n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function (match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          // save context
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          // recover context
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
      },
      // return next match in input
      next: function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = '';
          this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue; // rule action called reject() implying a rule MISmatch.
              } else {
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {
        "case-insensitive": true
      },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            /* ignore whitespace */
            break;
          case 1:
            return '';
            break;
          case 2:
            return '';
            break;
          case 3:
            return 42;
            break;
          case 4:
            return 35;
            break;
          case 5:
            return 77;
            break;
          case 6:
            return 78;
            break;
          case 7:
            return 78;
            break;
          case 8:
            return 8;
            break;
          case 9:
            return 6;
            break;
          case 10:
            return 82;
            break;
          case 11:
            return 7;
            break;
          case 12:
            return 9;
            break;
          case 13:
            return 59;
            break;
          case 14:
            return 13;
            break;
          case 15:
            return 15;
            break;
          case 16:
            return 17;
            break;
          case 17:
            return 18;
            break;
          case 18:
            return 19;
            break;
          case 19:
            return 20;
            break;
          case 20:
            return 11;
            break;
          case 21:
            return 62;
            break;
          case 22:
            return 64;
            break;
          case 23:
            return 23;
            break;
          case 24:
            return 25;
            break;
          case 25:
            return 26;
            break;
          case 26:
            return 27;
            break;
          case 27:
            return 30;
            break;
          case 28:
            return 34;
            break;
          case 29:
            return 33;
            break;
          case 30:
            return 65;
            break;
          case 31:
            return 66;
            break;
          case 32:
            return 37;
            break;
          case 33:
            return 41;
            break;
          case 34:
            return 43;
            break;
          case 35:
            return 52;
            break;
          case 36:
            return 54;
            break;
          case 37:
            return 55;
            break;
          case 38:
            return 46;
            break;
          case 39:
            return 48;
            break;
          case 40:
            return 45;
            break;
          case 41:
            return 49;
            break;
          case 42:
            return 56;
            break;
          case 43:
            return 58;
            break;
          case 44:
            return 44;
            break;
          case 45:
            return 83;
            break;
          case 46:
            return 84;
            break;
          case 47:
            return 85;
            break;
          case 48:
            return 86;
            break;
          case 49:
            return 87;
            break;
          case 50:
            return 88;
            break;
          case 51:
            return 89;
            break;
          case 52:
            return 90;
            break;
          case 53:
            return 91;
            break;
          case 54:
            return 92;
            break;
          case 55:
            return 93;
            break;
          case 56:
            return 94;
            break;
          case 57:
            return 95;
            break;
          case 58:
            return 70;
            break;
          case 59:
            return 70;
            break;
          case 60:
            return 72;
            break;
          case 61:
            return 72;
            break;
          case 62:
            return 74;
            break;
          case 63:
            return 74;
            break;
          case 64:
            return 74;
            break;
          case 65:
            return 31;
            break;
          case 66:
            return 36;
            break;
          case 67:
            return 96;
            break;
          case 68:
            return 97;
            break;
          case 69:
            return 98;
            break;
          case 70:
            return 99;
            break;
          case 71:
            yy_.yytext = yy.utils.unquoteString(yy_.yytext);
            return 14;
            break;
          case 72:
            return 38;
            break;
          case 73:
            return 5;
            break;
          case 74:
            return 101;
            break;
          case 75:
            return 103;
            break;
          case 76:
            return '\\';
            break;
          case 77:
            return 28;
            break;
          case 78:
            return 61;
            break;
          case 79:
            return 29;
            break;
          case 80:
            return 57;
            break;
          case 81:
            return 71;
            break;
        }
      },
      rules: [/^(?:\s+)/i, /^(?:[#].*)/i, /^(?:\/\/.*)/i, /^(?:([_A-Z0-9\/\+]+==))/i, /^(?:-?[0-9]+(\.[0-9]+)?\b)/i, /^(?:0[xX][0-9A-F]+\b)/i, /^(?:false\b)/i, /^(?:true\b)/i, /^(?:all\b)/i, /^(?:reset\b)/i, /^(?:clear\b)/i, /^(?:build\b)/i, /^(?:help\b)/i, /^(?:load\b)/i, /^(?:get\b)/i, /^(?:set\b)/i, /^(?:set_save\b)/i, /^(?:set_restore\b)/i, /^(?:set_reset\b)/i, /^(?:preset\b)/i, /^(?:motm\b)/i, /^(?:add\b)/i, /^(?:rep\b)/i, /^(?:remove\b)/i, /^(?:hide\b)/i, /^(?:show\b)/i, /^(?:list\b)/i, /^(?:select\b)/i, /^(?:within\b)/i, /^(?:selector\b)/i, /^(?:mode\b)/i, /^(?:color\b)/i, /^(?:material\b)/i, /^(?:view\b)/i, /^(?:unit\b)/i, /^(?:line\b)/i, /^(?:listobj\b)/i, /^(?:removeobj\b)/i, /^(?:rotate\b)/i, /^(?:translate\b)/i, /^(?:scale\b)/i, /^(?:center\b)/i, /^(?:url\b)/i, /^(?:screenshot\b)/i, /^(?:dssp\b)/i, /^(?:file_list\b)/i, /^(?:file_register\b)/i, /^(?:file_delete\b)/i, /^(?:preset_add\b)/i, /^(?:preset_delete\b)/i, /^(?:preset_update\b)/i, /^(?:preset_rename\b)/i, /^(?:preset_open\b)/i, /^(?:create_scenario\b)/i, /^(?:reset_scenario\b)/i, /^(?:delete_scenario\b)/i, /^(?:add_scenario_item\b)/i, /^(?:list_scenario\b)/i, /^(?:s\b)/i, /^(?:mt\b)/i, /^(?:m\b)/i, /^(?:c\b)/i, /^(?:x\b)/i, /^(?:y\b)/i, /^(?:z\b)/i, /^(?:as\b)/i, /^(?:of\b)/i, /^(?:pdb\b)/i, /^(?:delay\b)/i, /^(?:prst\b)/i, /^(?:desc\b)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:\.)/i, /^(?:\/)/i, /^(?:\\)/i, /^(?:-e\b)/i, /^(?:-f\b)/i, /^(?:-s\b)/i, /^(?:-v\b)/i, /^(?:=)/i],
      conditions: {
        "INITIAL": {
          "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81],
          "inclusive": true
        }
      }
    };
    return lexer;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();
module.exports = {
  parser: parser
};

/***/ }),

/***/ 99:
/***/ ((module) => {

/* eslint-disable */
// DO NOT EDIT! Automatically generated from .jison
/* parser generated by jison 0.4.18 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = function () {
  var o = function (k, v, o, l) {
      for (o = o || {}, l = k.length; l--; o[k[l]] = v);
      return o;
    },
    $V0 = [1, 4],
    $V1 = [1, 5],
    $V2 = [1, 6],
    $V3 = [1, 7],
    $V4 = [1, 8],
    $V5 = [1, 9],
    $V6 = [1, 11],
    $V7 = [1, 12],
    $V8 = [5, 7, 8, 11],
    $V9 = [1, 17],
    $Va = [1, 22],
    $Vb = [1, 20],
    $Vc = [1, 21],
    $Vd = [5, 7, 8, 11, 19];
  var parser = {
    trace: function trace() {},
    yy: {},
    symbols_: {
      "error": 2,
      "Program": 3,
      "Expression": 4,
      "EOF": 5,
      "Selector": 6,
      "OR": 7,
      "AND": 8,
      "NOT": 9,
      "(": 10,
      ")": 11,
      "SELECTOR": 12,
      "NAMED_SELECTOR": 13,
      "SELECTOR_RANGED": 14,
      "RangeList": 15,
      "SELECTOR_NAMED": 16,
      "NameList": 17,
      "Range": 18,
      ",": 19,
      "NUMBER": 20,
      ":": 21,
      "Name": 22,
      "IDENTIFIER": 23,
      "STRING": 24,
      "$accept": 0,
      "$end": 1
    },
    terminals_: {
      2: "error",
      5: "EOF",
      7: "OR",
      8: "AND",
      9: "NOT",
      10: "(",
      11: ")",
      12: "SELECTOR",
      13: "NAMED_SELECTOR",
      14: "SELECTOR_RANGED",
      16: "SELECTOR_NAMED",
      19: ",",
      20: "NUMBER",
      21: ":",
      23: "IDENTIFIER",
      24: "STRING"
    },
    productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
      /* this == yyval */

      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
          break;
        case 3:
          this.$ = yy.keyword('or')($$[$0 - 2], $$[$0]);
          break;
        case 4:
          this.$ = yy.keyword('and')($$[$0 - 2], $$[$0]);
          break;
        case 5:
          this.$ = yy.keyword('not')($$[$0]);
          break;
        case 6:
          this.$ = $$[$0 - 1];
          break;
        case 7:
          this.$ = yy.keyword($$[$0])();
          break;
        case 8:
          this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
          break;
        case 9:
        case 10:
          this.$ = yy.keyword($$[$0 - 1])($$[$0]);
          break;
        case 11:
          this.$ = new yy.RangeList($$[$0]);
          break;
        case 12:
        case 16:
          this.$ = $$[$0 - 2].append($$[$0]);
          break;
        case 13:
          this.$ = new yy.Range(Number($$[$0]));
          break;
        case 14:
          this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
          break;
        case 15:
          this.$ = new yy.ValueList($$[$0]);
          break;
      }
    },
    table: [{
      3: 1,
      4: 2,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, {
      1: [3]
    }, {
      5: [1, 10],
      7: $V6,
      8: $V7
    }, o($V8, [2, 2]), {
      4: 13,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, {
      4: 14,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, o($V8, [2, 7]), o($V8, [2, 8]), {
      15: 15,
      18: 16,
      20: $V9
    }, {
      17: 18,
      20: $Va,
      22: 19,
      23: $Vb,
      24: $Vc
    }, {
      1: [2, 1]
    }, {
      4: 23,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, {
      4: 24,
      6: 3,
      9: $V0,
      10: $V1,
      12: $V2,
      13: $V3,
      14: $V4,
      16: $V5
    }, o($V8, [2, 5]), {
      7: $V6,
      8: $V7,
      11: [1, 25]
    }, o($V8, [2, 9], {
      19: [1, 26]
    }), o($Vd, [2, 11]), o($Vd, [2, 13], {
      21: [1, 27]
    }), o($V8, [2, 10], {
      19: [1, 28]
    }), o($Vd, [2, 15]), o($Vd, [2, 17]), o($Vd, [2, 18]), o($Vd, [2, 19]), o([5, 7, 11], [2, 3], {
      8: $V7
    }), o($V8, [2, 4]), o($V8, [2, 6]), {
      18: 29,
      20: $V9
    }, {
      20: [1, 30]
    }, {
      20: $Va,
      22: 31,
      23: $Vb,
      24: $Vc
    }, o($Vd, [2, 12]), o($Vd, [2, 14]), o($Vd, [2, 16])],
    defaultActions: {
      10: [2, 1]
    },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse(input) {
      var self = this,
        stack = [0],
        tstack = [],
        vstack = [null],
        lstack = [],
        table = this.table,
        yytext = '',
        yylineno = 0,
        yyleng = 0,
        recovering = 0,
        TERROR = 2,
        EOF = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer = Object.create(this.lexer);
      var sharedState = {
        yy: {}
      };
      for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
          sharedState.yy[k] = this.yy[k];
        }
      }
      lexer.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer;
      sharedState.yy.parser = this;
      if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
      }
      var yyloc = lexer.yylloc;
      lstack.push(yyloc);
      var ranges = lexer.options && lexer.options.ranges;
      if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
      }
      function lex() {
        var token;
        token = tstack.pop() || lexer.lex() || EOF;
        if (typeof token !== 'number') {
          if (token instanceof Array) {
            tstack = token;
            token = tstack.pop();
          }
          token = self.symbols_[token] || token;
        }
        return token;
      }
      var symbol,
        preErrorSymbol,
        state,
        action,
        a,
        r,
        yyval = {},
        p,
        len,
        newState,
        expected;
      while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol === null || typeof symbol == 'undefined') {
            symbol = lex();
          }
          action = table[state] && table[state][symbol];
        }
        if (typeof action === 'undefined' || !action.length || !action[0]) {
          var errStr = '';
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push('\'' + this.terminals_[p] + '\'');
            }
          }
          if (lexer.showPosition) {
            errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
          } else {
            errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
          }
          this.parseError(errStr, {
            text: lexer.match,
            token: this.terminals_[symbol] || symbol,
            line: lexer.yylineno,
            loc: yyloc,
            expected: expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
          case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
              yyleng = lexer.yyleng;
              yytext = lexer.yytext;
              yylineno = lexer.yylineno;
              yyloc = lexer.yylloc;
              if (recovering > 0) {
                recovering--;
              }
            } else {
              symbol = preErrorSymbol;
              preErrorSymbol = null;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
            }
            r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
            if (typeof r !== 'undefined') {
              return r;
            }
            if (len) {
              stack = stack.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };

  /* generated by jison-lex 0.3.4 */
  var lexer = function () {
    var lexer = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      // resets the lexer, sets new input
      setInput: function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      // consumes and returns one char from the input
      input: function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      // unshifts one char (or a string) into the input
      unput: function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      // When called from action, caches matched text and appends it on next action
      more: function () {
        this._more = true;
        return this;
      },
      // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
      reject: function () {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      // retain first n characters of the match
      less: function (n) {
        this.unput(this.match.slice(n));
      },
      // displays already matched input, i.e. for error messages
      pastInput: function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
      },
      // displays upcoming input, i.e. for error messages
      upcomingInput: function () {
        var next = this.match;
        if (next.length < 20) {
          next += this._input.substr(0, 20 - next.length);
        }
        return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
      },
      // displays the character position where the lexing error occurred, i.e. for error messages
      showPosition: function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
      },
      // test the lexed token: return FALSE when not a match, otherwise return token
      test_match: function (match, indexed_rule) {
        var token, lines, backup;
        if (this.options.backtrack_lexer) {
          // save context
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token) {
          return token;
        } else if (this._backtrack) {
          // recover context
          for (var k in backup) {
            this[k] = backup[k];
          }
          return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
      },
      // return next match in input
      next: function () {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token, match, tempMatch, index;
        if (!this._more) {
          this.yytext = '';
          this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index = i;
            if (this.options.backtrack_lexer) {
              token = this.test_match(tempMatch, rules[i]);
              if (token !== false) {
                return token;
              } else if (this._backtrack) {
                match = false;
                continue; // rule action called reject() implying a rule MISmatch.
              } else {
                // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token = this.test_match(match, rules[index]);
          if (token !== false) {
            return token;
          }
          // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      // return next match that has a token
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      // pop the previously active lexer condition state off the condition stack
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      // produce the lexer rule set which is active for the currently active lexer condition state
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      // alias for begin(condition)
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      // return the number of states currently on the stack
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {
        "case-insensitive": true
      },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        var YYSTATE = YY_START;
        switch ($avoiding_name_collisions) {
          case 0:
            /* skip whitespace */
            break;
          case 1:
            return 20;
            break;
          case 2:
            return 7;
            break;
          case 3:
            return 8;
            break;
          case 4:
            return 9;
            break;
          case 5:
            return 12;
            break;
          case 6:
            return 16;
            break;
          case 7:
            return 14;
            break;
          case 8:
            return 10;
            break;
          case 9:
            return 11;
            break;
          case 10:
            return 19;
            break;
          case 11:
            return 21;
            break;
          case 12:
            return '<=';
            break;
          case 13:
            return '>=';
            break;
          case 14:
            return '<';
            break;
          case 15:
            return '>';
            break;
          case 16:
            yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
            return 24;
            break;
          case 17:
            return 13;
            break;
          case 18:
            return 23;
            break;
          case 19:
            return 5;
            break;
          case 20:
            return 'INVALID';
            break;
        }
      },
      rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
      conditions: {
        "INITIAL": {
          "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
          "inclusive": true
        }
      }
    };
    return lexer;
  }();
  parser.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser;
  parser.Parser = Parser;
  return new Parser();
}();
module.exports = {
  parser: parser
};

/***/ }),

/***/ 690:
/***/ (function(__unused_webpack_module, exports) {

/*
Smooth.js version 0.1.7

Turn arrays into smooth functions.

Copyright 2012 Spencer Cohen
Licensed under MIT license (see "Smooth.js MIT license.txt")
*/

/*Constants (these are accessible by Smooth.WHATEVER in user space)
*/

(function () {
  var AbstractInterpolator,
    CubicInterpolator,
    Enum,
    LinearInterpolator,
    NearestInterpolator,
    PI,
    SincFilterInterpolator,
    Smooth,
    clipClamp,
    clipMirror,
    clipPeriodic,
    defaultConfig,
    getColumn,
    getType,
    isValidNumber,
    k,
    makeLanczosWindow,
    makeScaledFunction,
    makeSincKernel,
    normalizeScaleTo,
    shallowCopy,
    sin,
    sinc,
    v,
    validateNumber,
    validateVector,
    __hasProp = Object.prototype.hasOwnProperty,
    __extends = function (child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key)) child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    };
  Enum = {
    /*Interpolation methods
    */
    METHOD_NEAREST: 'nearest',
    METHOD_LINEAR: 'linear',
    METHOD_CUBIC: 'cubic',
    METHOD_LANCZOS: 'lanczos',
    METHOD_SINC: 'sinc',
    /*Input clipping modes
    */
    CLIP_CLAMP: 'clamp',
    CLIP_ZERO: 'zero',
    CLIP_PERIODIC: 'periodic',
    CLIP_MIRROR: 'mirror',
    /* Constants for control over the cubic interpolation tension
    */
    CUBIC_TENSION_DEFAULT: 0,
    CUBIC_TENSION_CATMULL_ROM: 0
  };
  defaultConfig = {
    method: Enum.METHOD_CUBIC,
    cubicTension: Enum.CUBIC_TENSION_DEFAULT,
    clip: Enum.CLIP_CLAMP,
    scaleTo: 0,
    sincFilterSize: 2,
    sincWindow: void 0
  };

  /*Index clipping functions
  */

  clipClamp = function (i, n) {
    return Math.max(0, Math.min(i, n - 1));
  };
  clipPeriodic = function (i, n) {
    i = i % n;
    if (i < 0) i += n;
    return i;
  };
  clipMirror = function (i, n) {
    var period;
    period = 2 * (n - 1);
    i = clipPeriodic(i, period);
    if (i > n - 1) i = period - i;
    return i;
  };

  /*
  Abstract scalar interpolation class which provides common functionality for all interpolators
  
  Subclasses must override interpolate().
  */

  AbstractInterpolator = function () {
    function AbstractInterpolator(array, config) {
      this.array = array.slice(0);
      this.length = this.array.length;
      if (!(this.clipHelper = {
        clamp: this.clipHelperClamp,
        zero: this.clipHelperZero,
        periodic: this.clipHelperPeriodic,
        mirror: this.clipHelperMirror
      }[config.clip])) {
        throw "Invalid clip: " + config.clip;
      }
    }
    AbstractInterpolator.prototype.getClippedInput = function (i) {
      if (0 <= i && i < this.length) {
        return this.array[i];
      } else {
        return this.clipHelper(i);
      }
    };
    AbstractInterpolator.prototype.clipHelperClamp = function (i) {
      return this.array[clipClamp(i, this.length)];
    };
    AbstractInterpolator.prototype.clipHelperZero = function (i) {
      return 0;
    };
    AbstractInterpolator.prototype.clipHelperPeriodic = function (i) {
      return this.array[clipPeriodic(i, this.length)];
    };
    AbstractInterpolator.prototype.clipHelperMirror = function (i) {
      return this.array[clipMirror(i, this.length)];
    };
    AbstractInterpolator.prototype.interpolate = function (t) {
      throw 'Subclasses of AbstractInterpolator must override the interpolate() method.';
    };
    return AbstractInterpolator;
  }();
  NearestInterpolator = function (_super) {
    __extends(NearestInterpolator, _super);
    function NearestInterpolator() {
      NearestInterpolator.__super__.constructor.apply(this, arguments);
    }
    NearestInterpolator.prototype.interpolate = function (t) {
      return this.getClippedInput(Math.round(t));
    };
    return NearestInterpolator;
  }(AbstractInterpolator);
  LinearInterpolator = function (_super) {
    __extends(LinearInterpolator, _super);
    function LinearInterpolator() {
      LinearInterpolator.__super__.constructor.apply(this, arguments);
    }
    LinearInterpolator.prototype.interpolate = function (t) {
      var k;
      k = Math.floor(t);
      t -= k;
      return (1 - t) * this.getClippedInput(k) + t * this.getClippedInput(k + 1);
    };
    return LinearInterpolator;
  }(AbstractInterpolator);
  CubicInterpolator = function (_super) {
    __extends(CubicInterpolator, _super);
    function CubicInterpolator(array, config) {
      this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
      CubicInterpolator.__super__.constructor.apply(this, arguments);
    }
    CubicInterpolator.prototype.getTangent = function (k) {
      return this.tangentFactor * (this.getClippedInput(k + 1) - this.getClippedInput(k - 1)) / 2;
    };
    CubicInterpolator.prototype.interpolate = function (t) {
      var k, m, p, t2, t3;
      k = Math.floor(t);
      m = [this.getTangent(k), this.getTangent(k + 1)];
      p = [this.getClippedInput(k), this.getClippedInput(k + 1)];
      t -= k;
      t2 = t * t;
      t3 = t * t2;
      return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
    };
    return CubicInterpolator;
  }(AbstractInterpolator);
  sin = Math.sin, PI = Math.PI;
  sinc = function (x) {
    if (x === 0) {
      return 1;
    } else {
      return sin(PI * x) / (PI * x);
    }
  };
  makeLanczosWindow = function (a) {
    return function (x) {
      return sinc(x / a);
    };
  };
  makeSincKernel = function (window) {
    return function (x) {
      return sinc(x) * window(x);
    };
  };
  SincFilterInterpolator = function (_super) {
    __extends(SincFilterInterpolator, _super);
    function SincFilterInterpolator(array, config) {
      SincFilterInterpolator.__super__.constructor.apply(this, arguments);
      this.a = config.sincFilterSize;
      if (!config.sincWindow) throw 'No sincWindow provided';
      this.kernel = makeSincKernel(config.sincWindow);
    }
    SincFilterInterpolator.prototype.interpolate = function (t) {
      var k, n, sum, _ref, _ref2;
      k = Math.floor(t);
      sum = 0;
      for (n = _ref = k - this.a + 1, _ref2 = k + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
        sum += this.kernel(t - n) * this.getClippedInput(n);
      }
      return sum;
    };
    return SincFilterInterpolator;
  }(AbstractInterpolator);
  getColumn = function (arr, i) {
    var row, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      row = arr[_i];
      _results.push(row[i]);
    }
    return _results;
  };
  makeScaledFunction = function (f, baseScale, scaleRange) {
    var scaleFactor, translation;
    if (scaleRange.join === '0,1') {
      return f;
    } else {
      scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
      translation = scaleRange[0];
      return function (t) {
        return f(scaleFactor * (t - translation));
      };
    }
  };
  getType = function (x) {
    return Object.prototype.toString.call(x).slice('[object '.length, -1);
  };
  validateNumber = function (n) {
    if (isNaN(n)) throw 'NaN in Smooth() input';
    if (getType(n) !== 'Number') throw 'Non-number in Smooth() input';
    if (!isFinite(n)) throw 'Infinity in Smooth() input';
  };
  validateVector = function (v, dimension) {
    var n, _i, _len;
    if (getType(v) !== 'Array') throw 'Non-vector in Smooth() input';
    if (v.length !== dimension) throw 'Inconsistent dimension in Smooth() input';
    for (_i = 0, _len = v.length; _i < _len; _i++) {
      n = v[_i];
      validateNumber(n);
    }
  };
  isValidNumber = function (n) {
    return getType(n) === 'Number' && isFinite(n) && !isNaN(n);
  };
  normalizeScaleTo = function (s) {
    var invalidErr;
    invalidErr = "scaleTo param must be number or array of two numbers";
    switch (getType(s)) {
      case 'Number':
        if (!isValidNumber(s)) throw invalidErr;
        s = [0, s];
        break;
      case 'Array':
        if (s.length !== 2) throw invalidErr;
        if (!(isValidNumber(s[0]) && isValidNumber(s[1]))) throw invalidErr;
        break;
      default:
        throw invalidErr;
    }
    return s;
  };
  shallowCopy = function (obj) {
    var copy, k, v;
    copy = {};
    for (k in obj) {
      if (!__hasProp.call(obj, k)) continue;
      v = obj[k];
      copy[k] = v;
    }
    return copy;
  };
  Smooth = function (arr, config) {
    var baseDomainEnd, dimension, i, interpolator, interpolatorClass, interpolators, k, n, properties, smoothFunc, v;
    if (config == null) config = {};
    properties = {};
    config = shallowCopy(config);
    properties.config = shallowCopy(config);
    if (config.scaleTo == null) config.scaleTo = config.period;
    if (config.sincFilterSize == null) {
      config.sincFilterSize = config.lanczosFilterSize;
    }
    for (k in defaultConfig) {
      if (!__hasProp.call(defaultConfig, k)) continue;
      v = defaultConfig[k];
      if (config[k] == null) config[k] = v;
    }
    if (!(interpolatorClass = {
      nearest: NearestInterpolator,
      linear: LinearInterpolator,
      cubic: CubicInterpolator,
      lanczos: SincFilterInterpolator,
      sinc: SincFilterInterpolator
    }[config.method])) {
      throw "Invalid method: " + config.method;
    }
    if (config.method === 'lanczos') {
      config.sincWindow = makeLanczosWindow(config.sincFilterSize);
    }
    if (arr.length < 2) throw 'Array must have at least two elements';
    properties.count = arr.length;
    smoothFunc = function () {
      var _i, _j, _len, _len2;
      switch (getType(arr[0])) {
        case 'Number':
          properties.dimension = 'scalar';
          if (Smooth.deepValidation) {
            for (_i = 0, _len = arr.length; _i < _len; _i++) {
              n = arr[_i];
              validateNumber(n);
            }
          }
          interpolator = new interpolatorClass(arr, config);
          return function (t) {
            return interpolator.interpolate(t);
          };
        case 'Array':
          properties.dimension = dimension = arr[0].length;
          if (!dimension) throw 'Vectors must be non-empty';
          if (Smooth.deepValidation) {
            for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
              v = arr[_j];
              validateVector(v, dimension);
            }
          }
          interpolators = function () {
            var _results;
            _results = [];
            for (i = 0; 0 <= dimension ? i < dimension : i > dimension; 0 <= dimension ? i++ : i--) {
              _results.push(new interpolatorClass(getColumn(arr, i), config));
            }
            return _results;
          }();
          return function (t) {
            var interpolator, _k, _len3, _results;
            _results = [];
            for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
              interpolator = interpolators[_k];
              _results.push(interpolator.interpolate(t));
            }
            return _results;
          };
        default:
          throw "Invalid element type: " + getType(arr[0]);
      }
    }();
    if (config.clip === 'periodic') {
      baseDomainEnd = arr.length;
    } else {
      baseDomainEnd = arr.length - 1;
    }
    config.scaleTo || (config.scaleTo = baseDomainEnd);
    properties.domain = normalizeScaleTo(config.scaleTo);
    smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
    properties.domain.sort();
    /*copy properties
    */
    for (k in properties) {
      if (!__hasProp.call(properties, k)) continue;
      v = properties[k];
      smoothFunc[k] = v;
    }
    return smoothFunc;
  };
  for (k in Enum) {
    if (!__hasProp.call(Enum, k)) continue;
    v = Enum[k];
    Smooth[k] = v;
  }
  Smooth.deepValidation = true;
  ( true && exports !== null ? exports : window).Smooth = Smooth;
}).call(this);

/***/ }),

/***/ 660:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!function (r, t) {
  if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
}(this, function (r) {
  "use strict";

  function t(r, t, n) {
    for (var e = (r.byteLength, 0), i = n.length; i > e; e++) {
      var o = n.charCodeAt(e);
      if (128 > o) r.setUint8(t++, o >>> 0 & 127 | 0);else if (2048 > o) r.setUint8(t++, o >>> 6 & 31 | 192), r.setUint8(t++, o >>> 0 & 63 | 128);else if (65536 > o) r.setUint8(t++, o >>> 12 & 15 | 224), r.setUint8(t++, o >>> 6 & 63 | 128), r.setUint8(t++, o >>> 0 & 63 | 128);else {
        if (!(1114112 > o)) throw new Error("bad codepoint " + o);
        r.setUint8(t++, o >>> 18 & 7 | 240), r.setUint8(t++, o >>> 12 & 63 | 128), r.setUint8(t++, o >>> 6 & 63 | 128), r.setUint8(t++, o >>> 0 & 63 | 128);
      }
    }
  }
  function n(r) {
    for (var t = 0, n = 0, e = r.length; e > n; n++) {
      var i = r.charCodeAt(n);
      if (128 > i) t += 1;else if (2048 > i) t += 2;else if (65536 > i) t += 3;else {
        if (!(1114112 > i)) throw new Error("bad codepoint " + i);
        t += 4;
      }
    }
    return t;
  }
  function e(r, i, o) {
    var a = typeof r;
    if ("string" === a) {
      var u = n(r);
      if (32 > u) return i.setUint8(o, 160 | u), t(i, o + 1, r), 1 + u;
      if (256 > u) return i.setUint8(o, 217), i.setUint8(o + 1, u), t(i, o + 2, r), 2 + u;
      if (65536 > u) return i.setUint8(o, 218), i.setUint16(o + 1, u), t(i, o + 3, r), 3 + u;
      if (4294967296 > u) return i.setUint8(o, 219), i.setUint32(o + 1, u), t(i, o + 5, r), 5 + u;
    }
    if (r instanceof Uint8Array) {
      var u = r.byteLength,
        s = new Uint8Array(i.buffer);
      if (256 > u) return i.setUint8(o, 196), i.setUint8(o + 1, u), s.set(r, o + 2), 2 + u;
      if (65536 > u) return i.setUint8(o, 197), i.setUint16(o + 1, u), s.set(r, o + 3), 3 + u;
      if (4294967296 > u) return i.setUint8(o, 198), i.setUint32(o + 1, u), s.set(r, o + 5), 5 + u;
    }
    if ("number" === a) {
      if (!isFinite(r)) throw new Error("Number not finite: " + r);
      if (Math.floor(r) !== r) return i.setUint8(o, 203), i.setFloat64(o + 1, r), 9;
      if (r >= 0) {
        if (128 > r) return i.setUint8(o, r), 1;
        if (256 > r) return i.setUint8(o, 204), i.setUint8(o + 1, r), 2;
        if (65536 > r) return i.setUint8(o, 205), i.setUint16(o + 1, r), 3;
        if (4294967296 > r) return i.setUint8(o, 206), i.setUint32(o + 1, r), 5;
        throw new Error("Number too big 0x" + r.toString(16));
      }
      if (r >= -32) return i.setInt8(o, r), 1;
      if (r >= -128) return i.setUint8(o, 208), i.setInt8(o + 1, r), 2;
      if (r >= -32768) return i.setUint8(o, 209), i.setInt16(o + 1, r), 3;
      if (r >= -2147483648) return i.setUint8(o, 210), i.setInt32(o + 1, r), 5;
      throw new Error("Number too small -0x" + (-r).toString(16).substr(1));
    }
    if (null === r) return i.setUint8(o, 192), 1;
    if ("boolean" === a) return i.setUint8(o, r ? 195 : 194), 1;
    if ("object" === a) {
      var u,
        f = 0,
        c = Array.isArray(r);
      if (c) u = r.length;else {
        var d = Object.keys(r);
        u = d.length;
      }
      var f;
      if (16 > u ? (i.setUint8(o, u | (c ? 144 : 128)), f = 1) : 65536 > u ? (i.setUint8(o, c ? 220 : 222), i.setUint16(o + 1, u), f = 3) : 4294967296 > u && (i.setUint8(o, c ? 221 : 223), i.setUint32(o + 1, u), f = 5), c) for (var l = 0; u > l; l++) f += e(r[l], i, o + f);else for (var l = 0; u > l; l++) {
        var v = d[l];
        f += e(v, i, o + f), f += e(r[v], i, o + f);
      }
      return f;
    }
    throw new Error("Unknown type " + a);
  }
  function i(r) {
    var t = typeof r;
    if ("string" === t) {
      var e = n(r);
      if (32 > e) return 1 + e;
      if (256 > e) return 2 + e;
      if (65536 > e) return 3 + e;
      if (4294967296 > e) return 5 + e;
    }
    if (r instanceof Uint8Array) {
      var e = r.byteLength;
      if (256 > e) return 2 + e;
      if (65536 > e) return 3 + e;
      if (4294967296 > e) return 5 + e;
    }
    if ("number" === t) {
      if (Math.floor(r) !== r) return 9;
      if (r >= 0) {
        if (128 > r) return 1;
        if (256 > r) return 2;
        if (65536 > r) return 3;
        if (4294967296 > r) return 5;
        throw new Error("Number too big 0x" + r.toString(16));
      }
      if (r >= -32) return 1;
      if (r >= -128) return 2;
      if (r >= -32768) return 3;
      if (r >= -2147483648) return 5;
      throw new Error("Number too small -0x" + r.toString(16).substr(1));
    }
    if ("boolean" === t || null === r) return 1;
    if ("object" === t) {
      var e,
        o = 0;
      if (Array.isArray(r)) {
        e = r.length;
        for (var a = 0; e > a; a++) o += i(r[a]);
      } else {
        var u = Object.keys(r);
        e = u.length;
        for (var a = 0; e > a; a++) {
          var s = u[a];
          o += i(s) + i(r[s]);
        }
      }
      if (16 > e) return 1 + o;
      if (65536 > e) return 3 + o;
      if (4294967296 > e) return 5 + o;
      throw new Error("Array or object too long 0x" + e.toString(16));
    }
    throw new Error("Unknown type " + t);
  }
  function o(r) {
    var t = new ArrayBuffer(i(r)),
      n = new DataView(t);
    return e(r, n, 0), new Uint8Array(t);
  }
  function a(r, t, n) {
    return t ? new r(t.buffer, t.byteOffset, t.byteLength / (n || 1)) : void 0;
  }
  function u(r) {
    return a(DataView, r);
  }
  function s(r) {
    return a(Uint8Array, r);
  }
  function f(r) {
    return a(Int8Array, r);
  }
  function c(r) {
    return a(Int32Array, r, 4);
  }
  function d(r) {
    return a(Float32Array, r, 4);
  }
  function l(r, t) {
    var n = r.length / 2;
    t || (t = new Int16Array(n));
    for (var e = 0, i = 0; n > e; ++e, i += 2) t[e] = r[i] << 8 ^ r[i + 1] << 0;
    return t;
  }
  function v(r, t) {
    var n = r.length;
    t || (t = new Uint8Array(2 * n));
    for (var e = u(t), i = 0; n > i; ++i) e.setInt16(2 * i, r[i]);
    return s(t);
  }
  function g(r, t) {
    var n = r.length / 4;
    t || (t = new Int32Array(n));
    for (var e = 0, i = 0; n > e; ++e, i += 4) t[e] = r[i] << 24 ^ r[i + 1] << 16 ^ r[i + 2] << 8 ^ r[i + 3] << 0;
    return t;
  }
  function L(r, t) {
    var n = r.length;
    t || (t = new Uint8Array(4 * n));
    for (var e = u(t), i = 0; n > i; ++i) e.setInt32(4 * i, r[i]);
    return s(t);
  }
  function h(r, t) {
    var n = r.length;
    t || (t = new Float32Array(n / 4));
    for (var e = u(t), i = u(r), o = 0, a = 0, s = n / 4; s > o; ++o, a += 4) e.setFloat32(a, i.getFloat32(a), !0);
    return t;
  }
  function y(r, t, n) {
    var e = r.length,
      i = 1 / t;
    n || (n = new Float32Array(e));
    for (var o = 0; e > o; ++o) n[o] = r[o] * i;
    return n;
  }
  function m(r, t, n) {
    var e = r.length;
    n || (n = new Int32Array(e));
    for (var i = 0; e > i; ++i) n[i] = Math.round(r[i] * t);
    return n;
  }
  function p(r, t) {
    var n, e;
    if (!t) {
      var i = 0;
      for (n = 0, e = r.length; e > n; n += 2) i += r[n + 1];
      t = new r.constructor(i);
    }
    var o = 0;
    for (n = 0, e = r.length; e > n; n += 2) for (var a = r[n], u = r[n + 1], s = 0; u > s; ++s) t[o] = a, ++o;
    return t;
  }
  function U(r) {
    if (0 === r.length) return new Int32Array();
    var t,
      n,
      e = 2;
    for (t = 1, n = r.length; n > t; ++t) r[t - 1] !== r[t] && (e += 2);
    var i = new Int32Array(e),
      o = 0,
      a = 1;
    for (t = 1, n = r.length; n > t; ++t) r[t - 1] !== r[t] ? (i[o] = r[t - 1], i[o + 1] = a, a = 1, o += 2) : ++a;
    return i[o] = r[r.length - 1], i[o + 1] = a, i;
  }
  function b(r, t) {
    var n = r.length;
    t || (t = new r.constructor(n)), n && (t[0] = r[0]);
    for (var e = 1; n > e; ++e) t[e] = r[e] + t[e - 1];
    return t;
  }
  function I(r, t) {
    var n = r.length;
    t || (t = new r.constructor(n)), t[0] = r[0];
    for (var e = 1; n > e; ++e) t[e] = r[e] - r[e - 1];
    return t;
  }
  function w(r, t) {
    var n,
      e,
      i = r instanceof Int8Array ? 127 : 32767,
      o = -i - 1,
      a = r.length;
    if (!t) {
      var u = 0;
      for (n = 0; a > n; ++n) r[n] < i && r[n] > o && ++u;
      t = new Int32Array(u);
    }
    for (n = 0, e = 0; a > n;) {
      for (var s = 0; r[n] === i || r[n] === o;) s += r[n], ++n;
      s += r[n], ++n, t[e] = s, ++e;
    }
    return t;
  }
  function C(r, t) {
    var n,
      e = t ? 127 : 32767,
      i = -e - 1,
      o = r.length,
      a = 0;
    for (n = 0; o > n; ++n) {
      var u = r[n];
      0 === u ? ++a : a += u === e || u === i ? 2 : u > 0 ? Math.ceil(u / e) : Math.ceil(u / i);
    }
    var s = t ? new Int8Array(a) : new Int16Array(a),
      f = 0;
    for (n = 0; o > n; ++n) {
      var u = r[n];
      if (u >= 0) for (; u >= e;) s[f] = e, ++f, u -= e;else for (; i >= u;) s[f] = i, ++f, u -= i;
      s[f] = u, ++f;
    }
    return s;
  }
  function A(r, t) {
    return b(p(r), t);
  }
  function x(r) {
    return U(I(r));
  }
  function M(r, t, n) {
    return y(p(r, c(n)), t, n);
  }
  function F(r, t) {
    return U(m(r, t));
  }
  function S(r, t, n) {
    return y(b(r, c(n)), t, n);
  }
  function E(r, t, n) {
    return I(m(r, t), n);
  }
  function N(r, t, n) {
    return y(w(r, c(n)), t, n);
  }
  function O(r, t, n) {
    var e = w(r, c(n));
    return S(e, t, d(e));
  }
  function T(r, t, n) {
    return C(E(r, t), n);
  }
  function k(r) {
    var t = u(r),
      n = t.getInt32(0),
      e = t.getInt32(4),
      i = r.subarray(8, 12),
      r = r.subarray(12);
    return [n, r, e, i];
  }
  function j(r, t, n, e) {
    var i = new ArrayBuffer(12 + e.byteLength),
      o = new Uint8Array(i),
      a = new DataView(i);
    return a.setInt32(0, r), a.setInt32(4, t), n && o.set(n, 8), o.set(e, 12), o;
  }
  function q(r) {
    var t = r.length,
      n = s(r);
    return j(2, t, void 0, n);
  }
  function D(r) {
    var t = r.length,
      n = L(r);
    return j(4, t, void 0, n);
  }
  function P(r, t) {
    var n = r.length / t,
      e = L([t]),
      i = s(r);
    return j(5, n, e, i);
  }
  function z(r) {
    var t = r.length,
      n = L(U(r));
    return j(6, t, void 0, n);
  }
  function B(r) {
    var t = r.length,
      n = L(x(r));
    return j(8, t, void 0, n);
  }
  function V(r, t) {
    var n = r.length,
      e = L([t]),
      i = L(F(r, t));
    return j(9, n, e, i);
  }
  function G(r, t) {
    var n = r.length,
      e = L([t]),
      i = v(T(r, t));
    return j(10, n, e, i);
  }
  function R(r) {
    var t = {};
    return rr.forEach(function (n) {
      void 0 !== r[n] && (t[n] = r[n]);
    }), r.bondAtomList && (t.bondAtomList = D(r.bondAtomList)), r.bondOrderList && (t.bondOrderList = q(r.bondOrderList)), t.xCoordList = G(r.xCoordList, 1e3), t.yCoordList = G(r.yCoordList, 1e3), t.zCoordList = G(r.zCoordList, 1e3), r.bFactorList && (t.bFactorList = G(r.bFactorList, 100)), r.atomIdList && (t.atomIdList = B(r.atomIdList)), r.altLocList && (t.altLocList = z(r.altLocList)), r.occupancyList && (t.occupancyList = V(r.occupancyList, 100)), t.groupIdList = B(r.groupIdList), t.groupTypeList = D(r.groupTypeList), r.secStructList && (t.secStructList = q(r.secStructList, 1)), r.insCodeList && (t.insCodeList = z(r.insCodeList)), r.sequenceIndexList && (t.sequenceIndexList = B(r.sequenceIndexList)), t.chainIdList = P(r.chainIdList, 4), r.chainNameList && (t.chainNameList = P(r.chainNameList, 4)), t;
  }
  function H(r) {
    function t(r) {
      for (var t = {}, n = 0; r > n; n++) {
        var e = o();
        t[e] = o();
      }
      return t;
    }
    function n(t) {
      var n = r.subarray(a, a + t);
      return a += t, n;
    }
    function e(t) {
      var n = r.subarray(a, a + t);
      a += t;
      var e = 65535;
      if (t > e) {
        for (var i = [], o = 0; o < n.length; o += e) i.push(String.fromCharCode.apply(null, n.subarray(o, o + e)));
        return i.join("");
      }
      return String.fromCharCode.apply(null, n);
    }
    function i(r) {
      for (var t = new Array(r), n = 0; r > n; n++) t[n] = o();
      return t;
    }
    function o() {
      var o,
        s,
        f = r[a];
      if (0 === (128 & f)) return a++, f;
      if (128 === (240 & f)) return s = 15 & f, a++, t(s);
      if (144 === (240 & f)) return s = 15 & f, a++, i(s);
      if (160 === (224 & f)) return s = 31 & f, a++, e(s);
      if (224 === (224 & f)) return o = u.getInt8(a), a++, o;
      switch (f) {
        case 192:
          return a++, null;
        case 194:
          return a++, !1;
        case 195:
          return a++, !0;
        case 196:
          return s = u.getUint8(a + 1), a += 2, n(s);
        case 197:
          return s = u.getUint16(a + 1), a += 3, n(s);
        case 198:
          return s = u.getUint32(a + 1), a += 5, n(s);
        case 202:
          return o = u.getFloat32(a + 1), a += 5, o;
        case 203:
          return o = u.getFloat64(a + 1), a += 9, o;
        case 204:
          return o = r[a + 1], a += 2, o;
        case 205:
          return o = u.getUint16(a + 1), a += 3, o;
        case 206:
          return o = u.getUint32(a + 1), a += 5, o;
        case 208:
          return o = u.getInt8(a + 1), a += 2, o;
        case 209:
          return o = u.getInt16(a + 1), a += 3, o;
        case 210:
          return o = u.getInt32(a + 1), a += 5, o;
        case 217:
          return s = u.getUint8(a + 1), a += 2, e(s);
        case 218:
          return s = u.getUint16(a + 1), a += 3, e(s);
        case 219:
          return s = u.getUint32(a + 1), a += 5, e(s);
        case 220:
          return s = u.getUint16(a + 1), a += 3, i(s);
        case 221:
          return s = u.getUint32(a + 1), a += 5, i(s);
        case 222:
          return s = u.getUint16(a + 1), a += 3, t(s);
        case 223:
          return s = u.getUint32(a + 1), a += 5, t(s);
      }
      throw new Error("Unknown type 0x" + f.toString(16));
    }
    var a = 0,
      u = new DataView(r.buffer);
    return o();
  }
  function W(r, t, n, e) {
    switch (r) {
      case 1:
        return h(t);
      case 2:
        return f(t);
      case 3:
        return l(t);
      case 4:
        return g(t);
      case 5:
        return s(t);
      case 6:
        return p(g(t), new Uint8Array(n));
      case 7:
        return p(g(t));
      case 8:
        return A(g(t));
      case 9:
        return M(g(t), g(e)[0]);
      case 10:
        return O(l(t), g(e)[0]);
      case 11:
        return y(l(t), g(e)[0]);
      case 12:
        return N(l(t), g(e)[0]);
      case 13:
        return N(f(t), g(e)[0]);
      case 14:
        return w(l(t));
      case 15:
        return w(f(t));
    }
  }
  function X(r, t) {
    t = t || {};
    var n = t.ignoreFields,
      e = {};
    return nr.forEach(function (t) {
      var i = n ? -1 !== n.indexOf(t) : !1,
        o = r[t];
      i || void 0 === o || (o instanceof Uint8Array ? e[t] = W.apply(null, k(o)) : e[t] = o);
    }), e;
  }
  function J(r) {
    return String.fromCharCode.apply(null, r).replace(/\0/g, "");
  }
  function K(r, t, n) {
    n = n || {};
    var e,
      i,
      o,
      a,
      u,
      s,
      f = n.firstModelOnly,
      c = t.onModel,
      d = t.onChain,
      l = t.onGroup,
      v = t.onAtom,
      g = t.onBond,
      L = 0,
      h = 0,
      y = 0,
      m = 0,
      p = 0,
      U = -1,
      b = r.chainNameList,
      I = r.secStructList,
      w = r.insCodeList,
      C = r.sequenceIndexList,
      A = r.atomIdList,
      x = r.bFactorList,
      M = r.altLocList,
      F = r.occupancyList,
      S = r.bondAtomList,
      E = r.bondOrderList;
    for (e = 0, i = r.chainsPerModel.length; i > e && !(f && L > 0); ++e) {
      var N = r.chainsPerModel[L];
      for (c && c({
        chainCount: N,
        modelIndex: L
      }), o = 0; N > o; ++o) {
        var O = r.groupsPerChain[h];
        if (d) {
          var T = J(r.chainIdList.subarray(4 * h, 4 * h + 4)),
            k = null;
          b && (k = J(b.subarray(4 * h, 4 * h + 4))), d({
            groupCount: O,
            chainIndex: h,
            modelIndex: L,
            chainId: T,
            chainName: k
          });
        }
        for (a = 0; O > a; ++a) {
          var j = r.groupList[r.groupTypeList[y]],
            q = j.atomNameList.length;
          if (l) {
            var D = null;
            I && (D = I[y]);
            var P = null;
            r.insCodeList && (P = String.fromCharCode(w[y]));
            var z = null;
            C && (z = C[y]), l({
              atomCount: q,
              groupIndex: y,
              chainIndex: h,
              modelIndex: L,
              groupId: r.groupIdList[y],
              groupType: r.groupTypeList[y],
              groupName: j.groupName,
              singleLetterCode: j.singleLetterCode,
              chemCompType: j.chemCompType,
              secStruct: D,
              insCode: P,
              sequenceIndex: z
            });
          }
          for (u = 0; q > u; ++u) {
            if (v) {
              var B = null;
              A && (B = A[m]);
              var V = null;
              x && (V = x[m]);
              var G = null;
              M && (G = String.fromCharCode(M[m]));
              var R = null;
              F && (R = F[m]), v({
                atomIndex: m,
                groupIndex: y,
                chainIndex: h,
                modelIndex: L,
                atomId: B,
                element: j.elementList[u],
                atomName: j.atomNameList[u],
                formalCharge: j.formalChargeList[u],
                xCoord: r.xCoordList[m],
                yCoord: r.yCoordList[m],
                zCoord: r.zCoordList[m],
                bFactor: V,
                altLoc: G,
                occupancy: R
              });
            }
            m += 1;
          }
          if (g) {
            var H = j.bondAtomList;
            for (u = 0, s = j.bondOrderList.length; s > u; ++u) g({
              atomIndex1: m - q + H[2 * u],
              atomIndex2: m - q + H[2 * u + 1],
              bondOrder: j.bondOrderList[u]
            });
          }
          y += 1;
        }
        h += 1;
      }
      if (p = U + 1, U = m - 1, g && S) for (u = 0, s = S.length; s > u; u += 2) {
        var W = S[u],
          X = S[u + 1];
        (W >= p && U >= W || X >= p && U >= X) && g({
          atomIndex1: W,
          atomIndex2: X,
          bondOrder: E ? E[u / 2] : null
        });
      }
      L += 1;
    }
  }
  function Q(r) {
    return o(R(r));
  }
  function Y(r, t) {
    r instanceof ArrayBuffer && (r = new Uint8Array(r));
    var n;
    return n = r instanceof Uint8Array ? H(r) : r, X(n, t);
  }
  function Z(r, t, n, e) {
    function i() {
      try {
        var r = Y(o.response);
        n(r);
      } catch (t) {
        e(t);
      }
    }
    var o = new XMLHttpRequest();
    o.addEventListener("load", i, !0), o.addEventListener("error", e, !0), o.responseType = "arraybuffer", o.open("GET", t + r.toUpperCase()), o.send();
  }
  function $(r, t, n) {
    Z(r, or, t, n);
  }
  function _(r, t, n) {
    Z(r, ar, t, n);
  }
  var rr = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"],
    tr = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"],
    nr = rr.concat(tr),
    er = "v1.1.0dev",
    ir = "//mmtf.rcsb.org/v1.0/",
    or = ir + "full/",
    ar = ir + "reduced/";
  r.encode = Q, r.decode = Y, r.traverse = K, r.fetch = $, r.fetchReduced = _, r.version = er, r.fetchUrl = or, r.fetchReducedUrl = ar, r.encodeMsgpack = o, r.encodeMmtf = R, r.decodeMsgpack = H, r.decodeMmtf = X;
});

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ src)
});

;// CONCATENATED MODULE: external {"module":"lodash","commonjs":"lodash","commonjs2":"lodash","amd":"lodash","root":"_"}
var x = (y) => {
	var x = {}; __webpack_require__.d(x, y); return x
} 
var y = (x) => (() => (x))
const external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject = x({ ["default"]: () => (__WEBPACK_EXTERNAL_MODULE_lodash__["default"]) });
;// CONCATENATED MODULE: external {"module":"three","commonjs":"three","commonjs2":"three","amd":"three","root":"THREE"}
const external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject = __WEBPACK_EXTERNAL_MODULE_three__;
;// CONCATENATED MODULE: ../../node_modules/spin.js/spin.js
var __assign = undefined && undefined.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var defaults = {
  lines: 12,
  length: 7,
  width: 5,
  radius: 10,
  scale: 1.0,
  corners: 1,
  color: '#000',
  fadeColor: 'transparent',
  animation: 'spinner-line-fade-default',
  rotate: 0,
  direction: 1,
  speed: 1,
  zIndex: 2e9,
  className: 'spinner',
  top: '50%',
  left: '50%',
  shadow: '0 0 1px transparent',
  // prevent aliased lines
  position: 'absolute'
};
var Spinner = /** @class */function () {
  function Spinner(opts) {
    if (opts === void 0) {
      opts = {};
    }
    this.opts = __assign(__assign({}, defaults), opts);
  }
  /**
   * Adds the spinner to the given target element. If this instance is already
   * spinning, it is automatically removed from its previous target by calling
   * stop() internally.
   */
  Spinner.prototype.spin = function (target) {
    this.stop();
    this.el = document.createElement('div');
    this.el.className = this.opts.className;
    this.el.setAttribute('role', 'progressbar');
    this.el.style.position = this.opts.position;
    this.el.style.width = "0";
    this.el.style.zIndex = this.opts.zIndex.toString();
    this.el.style.left = this.opts.left;
    this.el.style.top = this.opts.top;
    this.el.style.transform = "scale(".concat(this.opts.scale, ")");
    if (target) {
      target.insertBefore(this.el, target.firstChild || null);
    }
    drawLines(this.el, this.opts);
    return this;
  };
  /**
   * Stops and removes the Spinner.
   * Stopped spinners may be reused by calling spin() again.
   */
  Spinner.prototype.stop = function () {
    if (this.el) {
      if (this.el.parentNode) {
        this.el.parentNode.removeChild(this.el);
      }
      this.el = undefined;
    }
    return this;
  };
  return Spinner;
}();

/**
 * Returns the line color from the given string or array.
 */
function getColor(color, idx) {
  return typeof color == 'string' ? color : color[idx % color.length];
}
/**
 * Internal method that draws the individual lines.
 */
function drawLines(el, opts) {
  var borderRadius = Math.round(opts.corners * opts.width * 500) / 1000 + 'px';
  var shadow = 'none';
  if (opts.shadow === true) {
    shadow = '0 2px 4px #000'; // default shadow
  } else if (typeof opts.shadow === 'string') {
    shadow = opts.shadow;
  }
  var shadows = parseBoxShadow(shadow);
  for (var i = 0; i < opts.lines; i++) {
    var degrees = ~~(360 / opts.lines * i + opts.rotate);
    var backgroundLine = document.createElement('div');
    backgroundLine.style.position = 'absolute';
    backgroundLine.style.top = "".concat(-opts.width / 2, "px");
    backgroundLine.style.width = opts.length + opts.width + 'px';
    backgroundLine.style.height = opts.width + 'px';
    backgroundLine.style.background = getColor(opts.fadeColor, i);
    backgroundLine.style.borderRadius = borderRadius;
    backgroundLine.style.transformOrigin = 'left';
    backgroundLine.style.transform = "rotate(".concat(degrees, "deg) translateX(").concat(opts.radius, "px)");
    var delay = i * opts.direction / opts.lines / opts.speed;
    delay -= 1 / opts.speed; // so initial animation state will include trail
    var line = document.createElement('div');
    line.style.width = '100%';
    line.style.height = '100%';
    line.style.background = getColor(opts.color, i);
    line.style.borderRadius = borderRadius;
    line.style.boxShadow = normalizeShadow(shadows, degrees);
    line.style.animation = "".concat(1 / opts.speed, "s linear ").concat(delay, "s infinite ").concat(opts.animation);
    backgroundLine.appendChild(line);
    el.appendChild(backgroundLine);
  }
}
function parseBoxShadow(boxShadow) {
  var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
  var shadows = [];
  for (var _i = 0, _a = boxShadow.split(','); _i < _a.length; _i++) {
    var shadow = _a[_i];
    var matches = shadow.match(regex);
    if (matches === null) {
      continue; // invalid syntax
    }
    var x = +matches[2];
    var y = +matches[5];
    var xUnits = matches[4];
    var yUnits = matches[7];
    if (x === 0 && !xUnits) {
      xUnits = yUnits;
    }
    if (y === 0 && !yUnits) {
      yUnits = xUnits;
    }
    if (xUnits !== yUnits) {
      continue; // units must match to use as coordinates
    }
    shadows.push({
      prefix: matches[1] || '',
      // could have value of 'inset' or undefined
      x: x,
      y: y,
      xUnits: xUnits,
      yUnits: yUnits,
      end: matches[8]
    });
  }
  return shadows;
}
/**
 * Modify box-shadow x/y offsets to counteract rotation
 */
function normalizeShadow(shadows, degrees) {
  var normalized = [];
  for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
    var shadow = shadows_1[_i];
    var xy = convertOffset(shadow.x, shadow.y, degrees);
    normalized.push(shadow.prefix + xy[0] + shadow.xUnits + ' ' + xy[1] + shadow.yUnits + shadow.end);
  }
  return normalized.join(', ');
}
function convertOffset(x, y, degrees) {
  var radians = degrees * Math.PI / 180;
  var sin = Math.sin(radians);
  var cos = Math.cos(radians);
  return [Math.round((x * cos + y * sin) * 1000) / 1000, Math.round((-x * sin + y * cos) * 1000) / 1000];
}
;// CONCATENATED MODULE: ./src/Timer.js
//----------------------------------------------------------------------------
// Timer

class Timer {
  constructor() {
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = Timer.now();
    this.oldTime = this.startTime;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
  }
  getElapsedTime() {
    this.update();
    return this.elapsedTime;
  }
  update() {
    let delta = 0;
    if (this.running) {
      const newTime = Timer.now();
      delta = 0.001 * (newTime - this.oldTime);
      this.oldTime = newTime;
      this.elapsedTime += delta;
    }
    return delta;
  }
}
Timer.now = function () {
  const p = typeof window !== 'undefined' && window.performance;
  return p && p.now ? p.now.bind(p) : Date.now;
}();
;// CONCATENATED MODULE: ./src/gfx/Stats.js

const {
  now
} = Timer;
function createElement(tag, id, css) {
  const element = document.createElement(tag);
  element.id = id;
  element.style.cssText = css;
  return element;
}
class Stats {
  constructor() {
    this.domElement = createElement('div', 'stats', 'padding:8px');
    this._text = createElement('p', 'fps', 'margin:0;color:silver;font-size:large');
    this.domElement.appendChild(this._text);
    this._startTime = now();
    this._prevTime = this._startTime;
    this._deltas = new Array(20);
    this._index = 0;
    this._total = 0.0;
    this._count = 0;
  }
  end() {
    const time = now();
    const delta = time - this._startTime;
    if (this._count < this._deltas.length) {
      this._count++;
    } else {
      this._total -= this._deltas[this._index];
    }
    this._total += delta;
    this._deltas[this._index] = delta;
    this._index = (this._index + 1) % this._deltas.length;
    this.ms = this._total / this._count;
    this.fps = 1000 / this.ms;
    if (time > this._prevTime + 1000) {
      this._text.textContent = this.fps.toPrecision(2);
      this._prevTime = time;
    }
    return time;
  }
  update() {
    this._startTime = this.end();
  }
  show(on) {
    if (on === undefined) {
      on = true;
    }
    this.domElement.style.display = on ? 'block' : 'none';
  }
}
/* harmony default export */ const gfx_Stats = (Stats);
;// CONCATENATED MODULE: ./src/utils/EventDispatcher.js
/**
 * This class introduces the simplest event system.
 */


function isUndefOrEqual(param, value) {
  return !param || param === value;
}

/**
 * Creates empty dispatcher.
 *
 * @exports EventDispatcher
 * @constructor
 */
function EventDispatcher() {
  this._handlers = {};
}

/**
 * Binds callback on specific event type. Optional `context` parameter
 * could be used as 'this' for the `callback`.
 * @param {string}   type       Event name.
 * @param {function} callback   Callback function.
 * @param {Object}   [context] 'This' object for the callback.
 */
EventDispatcher.prototype.addEventListener = function (type, callback, context) {
  let handlers = this._handlers[type];
  if (!handlers) {
    this._handlers[type] = [];
    handlers = this._handlers[type];
  }
  const params = [callback, context];
  function _checkPar(par) {
    return par[0] === params[0] && par[1] === params[1];
  }
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].find(handlers, _checkPar) === undefined) {
    handlers.push(params);
  }
};

/**
 * Removes a previously-bound callback function from an object.
 * If no `context` is specified, all versions of the `callback` with different
 * contexts will be removed.
 * If no `callback` is specified, all callbacks of the `type` will be removed.
 * If no `type` is specified, callbacks for all events will be removed.
 * @param {?string}  [type]      Event type.
 * @param {function} [callback]  Callback function.
 * @param {Object}   [context]  'This' object for the callback.
 */
EventDispatcher.prototype.removeEventListener = function (type, callback, context) {
  const self = this;
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forEach(self._handlers, (handler, ev) => {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].remove(handler, values => isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self));
  });
  this._handlers = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].omitBy(self._handlers, handler => handler.length === 0);
};

/**
 * Makes all the callbacks for the specific `event` to trigger.
 * @param {Object} event      Event.
 * @param {string} event.type Type of the event.
 */
EventDispatcher.prototype.dispatchEvent = function (event) {
  const self = this;
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forEach(this._handlers[event.type], callback => {
    const context = callback[1] || self;
    callback[0].apply(context, [event]);
  });
};
/* harmony default export */ const utils_EventDispatcher = (EventDispatcher);
;// CONCATENATED MODULE: ./src/utils/logger.js
/**
 * This module contains class for logging.
 * Returns an instance of a logger that have already been created.
 * Allows users to log messages for five different levels,
 * enable console output and catch signal on each message.
 */


const priorities = {
  debug: 0,
  info: 1,
  report: 2,
  warn: 3,
  error: 4
};

/**
 * Create new Logger.
 *
 * @exports Logger
 * @extends EventDispatcher
 * @constructor
 */
function Logger() {
  utils_EventDispatcher.call(this);
  /** Boolean flag that toggles output to browser console.
   * @type {boolean}
   */
  this.console = false;
  this._priority = priorities.warn;
}
Logger.prototype = Object.create(utils_EventDispatcher.prototype);
Logger.prototype.constructor = Logger;

/**
 * Create new clean instance of the logger.
 * @returns {Logger}
 */
Logger.prototype.instantiate = function () {
  return new Logger();
};
function verify(number) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(number)) {
    throw new Error('Wrong log level specified!');
  }
  return number;
}

/**
 * @property {string} current threshold for signals and console output.
 * @name Logger#level
 */
Object.defineProperty(Logger.prototype, 'level', {
  get() {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].findKey(priorities, value => value === this._priority);
  },
  set(level) {
    this._priority = verify(priorities[level]);
  }
});

/**
 * Returns the list of all possible level values.
 * @returns {Array}
 */
Logger.prototype.levels = function () {
  return Object.keys(priorities);
};

/**
 * Add new message with specified level.
 * @param {string} level - level of the message, must be one of the
 * {'debug' | 'info' | 'report' | 'warn' | 'error'}
 * @param {string} message
 */
Logger.prototype.message = function (level, message) {
  const priority = verify(priorities[level]);
  this._message(priority, message);
};

/**
 * Shortcut for message('debug', ...);
 * @param message
 */
Logger.prototype.debug = function (message) {
  this._message(priorities.debug, message);
};

/**
 * Shortcut for message('info', ...);
 * @param message
 */
Logger.prototype.info = function (message) {
  this._message(priorities.info, message);
};

/**
 * Shortcut for message('report', ...);
 * @param message
 */
Logger.prototype.report = function (message) {
  this._message(priorities.report, message);
};

/**
 * Shortcut for message('warn', ...);
 * @param message
 */
Logger.prototype.warn = function (message) {
  this._message(priorities.warn, message);
};

/**
 * Shortcut for message('error', ...);
 * @param message
 */
Logger.prototype.error = function (message) {
  this._message(priorities.error, message);
};

/**
 * Add new message with specified priority.
 * @param {number} priority - priority of the message
 * @param {string} message
 * @private
 */
Logger.prototype._message = function (priority, message) {
  if (priority < this._priority) {
    return;
  }
  const level = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].findKey(priorities, value => value === priority);
  message = String(message);
  if (this.console) {
    const output = `miew:${level}: ${message}`;
    if (level === 'error') {
      console.error(output); // NOSONAR
    } else if (level === 'warn') {
      console.warn(output); // NOSONAR
    } else {
      console.log(output); // NOSONAR
    }
  }
  this.dispatchEvent({
    type: 'message',
    level,
    message
  });
};
/* harmony default export */ const logger = (new Logger());
;// CONCATENATED MODULE: ./src/utils.js


const browserType = {
  DEFAULT: 0,
  SAFARI: 1
};
//----------------------------------------------------------------------------
// Query string

/**
 * Escape only dangerous chars in a query string component, use a plus instead of a space.
 *
 * [RFC 3986](https://tools.ietf.org/html/rfc3986) allows the following chars in the query (see 3.4):
 *
 *       A-Z a-z 0-9 - _ . ~ ! $ & ' ( ) * + , ; = : @ / ?
 *
 * For query string elements we need to escape ampersand, equal sign, and plus,
 * but encodeURIComponent() function encodes anything except for the following:
 *
 *       A-Z a-z 0-9 - _ . ~ ! ' ( ) *
 *
 * @param {string} text - key or value to encode
 * @param {string} excludeExp - regexp for symbols to exclude from encoding
 * @returns {string} encoded string
 */
function encodeQueryComponent(text, excludeExp) {
  const encode = code => String.fromCharCode(parseInt(code.substr(1), 16));
  return encodeURIComponent(text).replace(excludeExp, encode).replace(/%20/g, '+');
}

/**
 * Unescape dangerous chars in a query string component.
 *
 * @param {string} text - encoded key or value
 * @returns {string} decoded string
 * @see {@link encodeQueryComponent}
 */
function decodeQueryComponent(text) {
  return decodeURIComponent(text.replace(/\+/g, ' '));
}

/**
 * Parse URL and extract an array of parameters.
 * @param {string?} url - URL or query string to parse
 * @returns {Array} array of (key, value) pairs.
 */
function getUrlParameters(url) {
  url = url || window.location.search;
  const query = url.substring(url.indexOf('?') + 1);
  const search = /([^&=]+)=?([^&]*)/g;
  const result = [];
  let match;
  while ((match = search.exec(query)) !== null) {
    // eslint-disable-line no-cond-assign
    result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
  }
  return result;
}

/**
 * Parse URL and extract an array of parameters as a hash.
 * @param {string?} url - URL or query string to parse
 * @returns {Object}
 */
function getUrlParametersAsDict(url) {
  const result = {};
  const a = getUrlParameters(url);
  for (let i = 0; i < a.length; ++i) {
    const [key, value] = a[i];
    result[key] = value;
  }
  return result;
}
function resolveURL(str) {
  if (typeof URL !== 'undefined') {
    try {
      if (typeof window !== 'undefined') {
        return new URL(str, window.location).href;
      }
      return new URL(str).href;
    } catch (error) {
      // IE 11 has a URL object with no constructor available so just try a different approach instead
    }
  }
  if (typeof document !== 'undefined') {
    const anchor = document.createElement('a');
    anchor.href = str;
    return anchor.href;
  }
  return str;
}

/**
 * Generates regular expression object that includes all symbols
 * listed in the argument
 * @param symbolStr {string} - String containing characters list.
 * @returns {RegExp} - Regular expression.
 */
function generateRegExp(symbolStr) {
  const symbolList = [];
  for (let i = 0, n = symbolStr.length; i < n; ++i) {
    symbolList[symbolList.length] = symbolStr[i].charCodeAt(0).toString(16);
  }
  const listStr = symbolList.join('|');
  return new RegExp(`%(?:${listStr})`, 'gi');
}

//----------------------------------------------------------------------------
// Create HTML element

function utils_createElement(tag, attrs, content) {
  const element = document.createElement(tag);
  let i;
  let n;
  if (attrs) {
    const keys = Object.keys(attrs);
    for (i = 0, n = keys.length; i < n; ++i) {
      const key = keys[i];
      element.setAttribute(key, attrs[key]);
    }
  }
  if (content) {
    if (!(content instanceof Array)) {
      content = [content];
    }
    for (i = 0, n = content.length; i < n; ++i) {
      const child = content[i];
      if (typeof child === 'string') {
        element.appendChild(document.createTextNode(child));
      } else if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    }
  }
  return element;
}

//----------------------------------------------------------------------------
// Easy inheritance

/**
 * Derive the class from the base.
 * @param cls {function} - Class (constructor) to derive.
 * @param base {function} - Class (constructor) to derive from.
 * @param members {object=} - Optional instance members to add.
 * @param statics {object=} - Optional static class members to add.
 * @returns {function} Original class.
 */
function deriveClass(cls, base, members, statics) {
  cls.prototype = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(Object.create(base.prototype), {
    constructor: cls
  }, members);
  if (statics) {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(cls, statics);
  }
  return cls;
}

//----------------------------------------------------------------------------
// Deep prototyping

function deriveDeep(obj, needZeroOwnProperties) {
  let res = obj;
  let i;
  let n;
  if (obj instanceof Array) {
    res = new Array(obj.length);
    for (i = 0, n = obj.length; i < n; ++i) {
      res[i] = deriveDeep(obj[i]);
    }
  } else if (obj instanceof Object) {
    res = Object.create(obj);
    const keys = Object.keys(obj);
    for (i = 0, n = keys.length; i < n; ++i) {
      const key = keys[i];
      const value = obj[key];
      const copy = deriveDeep(value);
      if (copy !== value) {
        res[key] = copy;
      }
    }
    if (needZeroOwnProperties && Object.keys(res).length > 0) {
      res = Object.create(res);
    }
  }
  return res;
}

//----------------------------------------------------------------------------
// Colors

function hexColor(color) {
  const hex = `0000000${color.toString(16)}`.substr(-6);
  return `#${hex}`;
}

//----------------------------------------------------------------------------
// Debug tracing

function DebugTracer(namespace) {
  let enabled = false;
  this.enable = function (on) {
    enabled = on;
  };
  let indent = 0;
  const methods = Object.keys(namespace);
  function wrap(method_, name_) {
    return function () {
      const spaces = DebugTracer.spaces.substr(0, indent * 2);
      if (enabled) {
        logger.debug(`${spaces + name_} {`);
      }
      indent++;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const result = method_.apply(this, args); // eslint-disable-line no-invalid-this
      indent--;
      if (enabled) {
        logger.debug(`${spaces}} // ${name_}`);
      }
      return result;
    };
  }
  for (let i = 0, n = methods.length; i < n; ++i) {
    const name = methods[i];
    const method = namespace[name];
    if (method instanceof Function && name !== 'constructor') {
      namespace[name] = wrap(method, name);
    }
  }
}
DebugTracer.spaces = '                                                                                          ';
class OutOfMemoryError extends Error {
  constructor(message) {
    super();
    this.name = 'OutOfMemoryError';
    this.message = message;
  }
}
function allocateTyped(TypedArrayName, size) {
  let result = null;
  try {
    result = new TypedArrayName(size);
  } catch (e) {
    if (e instanceof RangeError) {
      throw new OutOfMemoryError(e.message);
    } else {
      throw e;
    }
  }
  return result;
}

//----------------------------------------------------------------------------
// Float array conversion

function bytesToBase64( /** ArrayBuffer */buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
}
function bytesFromBase64( /** string */str) {
  const binary = window.atob(str);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < bytes.length; ++i) {
    bytes[i] = binary[i].charCodeAt(0);
  }
  return bytes.buffer;
}
function arrayToBase64( /** number[] */array, /** function */TypedArrayClass) {
  return bytesToBase64(new TypedArrayClass(array).buffer);
}
function arrayFromBase64( /** string */str, /** function */TypedArrayClass) {
  return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
}

// NOTE: this is 1-level comparison
function compareOptionsWithDefaults(opts, defOpts) {
  const optsStr = [];
  if (defOpts && opts) {
    const keys = Object.keys(opts);
    for (let p = 0; p < keys.length; ++p) {
      const key = keys[p];
      const value = opts[key];
      // TODO add processing for tree structure
      if (!(value instanceof Object) && typeof defOpts[key] !== 'undefined' && defOpts[key] !== value) {
        optsStr.push(`${key}:${value}`);
      }
    }
    if (optsStr.length > 0) {
      return `!${optsStr.join()}`;
    }
  }
  return '';
}
function isAlmostPlainObject(o) {
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isPlainObject(o)) {
    return true;
  }
  const proto = o && Object.getPrototypeOf(o);
  return !!proto && !proto.hasOwnProperty('constructor') && isAlmostPlainObject(proto);
}

/**
 * Build an object that contains properties (and subproperties) of `src` different from those
 * in `dst`. Objects are parsed recursively, other values (including arrays) are compared for
 * equality using `_.isEqual()`.
 * @param {!object} src - a new object to compare, may contain changed or new properties
 * @param {!object} dst - an old reference object
 */
function objectsDiff(src, dst) {
  const diff = {};
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forIn(src, (srcValue, key) => {
    const dstValue = dst[key];
    if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
      const deepDiff = objectsDiff(srcValue, dstValue);
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(deepDiff)) {
        diff[key] = deepDiff;
      }
    } else if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(srcValue, dstValue)) {
      diff[key] = srcValue;
    }
  });
  return diff;
}
function forInRecursive(object, callback) {
  function iterateThrough(obj, prefix) {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forIn(obj, (value, key) => {
      const newPref = prefix + (prefix.length > 0 ? '.' : '');
      if (value instanceof Object) {
        iterateThrough(value, newPref + key);
      } else if (value !== undefined) {
        callback(value, newPref + key);
      }
    });
  }
  iterateThrough(object, '');
}
function enquoteString(value) {
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(value)) {
    return `"${value.replace(/"/g, '\\"')}"`;
  }
  return value;
}
function unquoteString(value) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(value)) {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"') {
    value = value.slice(1, value.length - 1);
    return value.replace(/\\"/g, '"');
  }
  if (value[0] === "'" && value[value.length - 1] === "'") {
    value = value.slice(1, value.length - 1);
    return value.replace(/\\'/g, "'");
  }
  throw new SyntaxError('Incorrect string format, can\'t unqute it');
}
function getFileExtension(fileName) {
  return fileName.slice(Math.max(0, fileName.lastIndexOf('.')) || Infinity);
}
function splitFileName(fileName) {
  const ext = getFileExtension(fileName);
  const name = fileName.slice(0, fileName.length - ext.length);
  return [name, ext];
}
function dataUrlToBlob(url) {
  const parts = url.split(/[:;,]/);
  const partsCount = parts.length;
  if (partsCount >= 3 && parts[partsCount - 2] === 'base64') {
    return new Blob([bytesFromBase64(parts[partsCount - 1])]);
  }
  return null;
}
function getBrowser() {
  if (navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') === -1 && navigator.userAgent.indexOf('FxiOS') === -1) {
    return browserType.SAFARI;
  }
  return browserType.DEFAULT;
}
function shotOpen(url) {
  if (typeof window !== 'undefined') {
    window.open().document.write(`<body style="margin:0"><img src="${url}" /></body>`);
  }
}
function shotDownload(dataUrl, filename) {
  if (!dataUrl || dataUrl.substr(0, 5) !== 'data:') {
    return;
  }
  if (!filename) {
    filename = ['screenshot-', +new Date(), '.png'].join('');
  }
  if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
  } else if (typeof document !== 'undefined') {
    const link = document.createElement('a');
    link.download = filename;
    link.innerHTML = 'download';
    link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}
function download(data, filename, type) {
  const blobData = new Blob([data]);
  if (!filename) {
    filename = ['data', +new Date()].join('');
  }
  if (!type) {
    filename += blobData.type || '.bin';
  } else {
    filename += `.${type}`;
  }
  if (typeof window !== 'undefined' && window.navigator && window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(blobData, filename);
  } else if (typeof document !== 'undefined') {
    const link = document.createElement('a');
    link.download = filename;
    link.innerHTML = 'download';
    link.href = window.URL.createObjectURL(blobData);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}
function copySubArrays(src, dst, indices, itemSize) {
  for (let i = 0, n = indices.length; i < n; ++i) {
    for (let j = 0; j < itemSize; ++j) {
      dst[i * itemSize + j] = src[indices[i] * itemSize + j];
    }
  }
}
function shallowCloneNode(node) {
  const newNode = node.cloneNode(true);
  newNode.worldPos = node.worldPos;
  // .style property is readonly, so "newNode.style = node.style;" won't work (and we don't need it, right?)
  return newNode;
}
const unquotedStringRE = /^[a-zA-Z0-9_]*$/;
const enquoteHelper = ['"', '', '"'];

// verify and correct if needed selctor identifier
function correctSelectorIdentifier(value) {
  if (unquotedStringRE.test(value)) {
    return value;
  }
  // quote incorrect identifier
  enquoteHelper[1] = value;
  return enquoteHelper.join('');
}

/**
 * Concatenates two TypedArray. Doesn't check null refs o type equality
 * Attention! It must be use very rarely because requires memory reallocation every time. Use MergeTypedArraysUnsafe to
 * unite array of subarrays.
 * @param{TypedArray} first  - destination array
 * @param{TypedArray} second - source array
 * @returns{TypedArray} resulting concatenated array
 */
function concatTypedArraysUnsafe(first, second) {
  const result = new first.constructor(first.length + second.length);
  result.set(first);
  result.set(second, first.length);
  return result;
}

/**
 * Merges array of TypedArray into TypedArray. Doesn't check null refs o type equality
 * @param{array} array  - source array of subarrays
 * @returns{TypedArray} resulting merged array
 */
function mergeTypedArraysUnsafe(array) {
  if (array.length <= 0) {
    return null;
  }
  // count the size
  const size = array.reduce((acc, cur) => acc + cur.length, 0);
  // create combined array
  const result = new array[0].constructor(size);
  for (let i = 0, start = 0; i < array.length; i++) {
    const count = array[i].length;
    result.set(array[i], start);
    start += count;
  }
  return result;
}

//----------------------------------------------------------------------------
// Exports

/* harmony default export */ const utils = ({
  browserType,
  encodeQueryComponent,
  decodeQueryComponent,
  getUrlParameters,
  getUrlParametersAsDict,
  resolveURL,
  generateRegExp,
  createElement: utils_createElement,
  deriveClass,
  deriveDeep,
  hexColor,
  DebugTracer,
  OutOfMemoryError,
  allocateTyped,
  bytesFromBase64,
  bytesToBase64,
  arrayFromBase64,
  arrayToBase64,
  compareOptionsWithDefaults,
  objectsDiff,
  forInRecursive,
  enquoteString,
  unquoteString,
  getBrowser,
  shotOpen,
  shotDownload,
  copySubArrays,
  shallowCloneNode,
  correctSelectorIdentifier,
  getFileExtension,
  splitFileName,
  download,
  concatTypedArraysUnsafe,
  mergeTypedArraysUnsafe
});
;// CONCATENATED MODULE: ./src/utils/JobHandle.js

class JobHandle extends utils_EventDispatcher {
  constructor() {
    super();
    this._shouldCancel = false;
  }
  cancel() {
    this._shouldCancel = true;
    this.dispatchEvent({
      type: 'cancel'
    });
  }
  shouldCancel() {
    return this._shouldCancel;
  }

  // slaves use this to notify master about their events
  // master routes these notifications to a single event slot
  notify(event) {
    this.dispatchEvent({
      type: 'notification',
      slaveEvent: event
    });
  }
}
;// CONCATENATED MODULE: ./src/settings.js



const VERSION = 0;

//----------------------------------------------------------------------------
// DEFAULT SETTINGS
//----------------------------------------------------------------------------

/**
 * Polygonal complexity settings.
 *
 * @typedef PolyComplexity
 * @property {number} poor
 * @property {number} low
 * @property {number} medium
 * @property {number} high
 * @property {number} ultra
 */

/**
 * @alias SettingsObject
 * @namespace
 */
const settings_defaults = {
  /**
   * Default options for all available modes.
   * Use {@link Mode.id} as a dictionary key to access mode options.
   *
   * Usually you don't need to override these settings. You may specify mode options as a parameter during
   * {@link Mode} construction.
   *
   * @memberof SettingsObject#
   * @type {Object.<string, object>}
   *
   * @property {LinesModeOptions} LN - Lines mode options.
   * @property {LicoriceModeOptions} LC - Licorice mode options.
   * @property {BallsAndSticksModeOptions} BS - Balls and Sticks mode options.
   * @property {VanDerWaalsModeOptions} VW - Van der Waals mode options.
   * @property {TraceModeOptions} TR - Trace mode options.
   * @property {TubeModeOptions} TU - Tube mode options.
   * @property {CartoonModeOptions} CA - Cartoon mode options.
   * @property {QuickSurfaceModeOptions} QS - Contact Surface mode options.
   * @property {IsoSurfaceSASModeOptions} SA - Solvent Accessible Surface mode options.
   * @property {IsoSurfaceSESModeOptions} SE - Solvent Excluded Surface mode options.
   * @property {ContactSurfaceModeOptions} CS - Contact Surface mode options.
   * @property {TextModeOptions} TX - Text mode options.
   * @property {VolumeDensityModeOptions} VD - Volume Density mode options.
   */
  modes: {
    //----------------------------------------------------------------------------
    // BALLS AND STICKS
    //----------------------------------------------------------------------------

    /**
     * Balls and Sticks mode options.
     *
     * @typedef BallsAndSticksModeOptions
     *
     * @property {number} atom - Sphere radius as a fraction of Van der Waals atom radius.
     * @property {number} bond - Cylinder radius in angstroms.
     * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
     *   available space.
     * @property {boolean} multibond - Toggles rendering of multiple ordered bonds.
     * @property {number} aromrad - Minor radius of a torus for aromatic loops.
     * @property {boolean} showarom - Toggles rendering of aromatic loops.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    BS: {
      atom: 0.23,
      bond: 0.15,
      space: 0.5,
      multibond: true,
      aromrad: 0.1,
      showarom: true,
      polyComplexity: {
        poor: 3,
        low: 4,
        medium: 6,
        high: 12,
        ultra: 32
      }
    },
    //----------------------------------------------------------------------------
    // VAN DER WAALS
    //----------------------------------------------------------------------------

    /**
     * Van der Waals mode options.
     *
     * @typedef VanDerWaalsModeOptions
     *
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    VW: {
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 8,
        high: 16,
        ultra: 32
      }
    },
    //----------------------------------------------------------------------------
    // LINES
    //----------------------------------------------------------------------------

    /**
     * Lines mode options.
     *
     * @typedef LinesModeOptions
     *
     * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
     * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
     * @property {number} offsarom - Offset between bonds and aromatic cycle.
     * @property {number} chunkarom - Number of pieces in a-loop arc, corresponding to atom.
     * @property {number} atom - Collision radius for atoms picking.
     * @property {number} lineWidth - Line width in pixels (not used in thin lines).
     */
    LN: {
      multibond: true,
      showarom: true,
      offsarom: 0.2,
      chunkarom: 10,
      atom: 0.23,
      lineWidth: 2
    },
    //----------------------------------------------------------------------------
    // LICORICE
    //----------------------------------------------------------------------------

    /**
     * Licorice mode options.
     *
     * @typedef LicoriceModeOptions
     *
     * @property {number} bond - Bond cylinder radius.
     * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
     *   available space.
     * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
     * @property {number} aromrad - Minor radius of a torus for aromatic loops.
     * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
     * @property {PolyComplexity} polyComplexity - Poly complexity values for render modes.
     */
    LC: {
      bond: 0.20,
      space: 0.0,
      multibond: true,
      aromrad: 0.1,
      showarom: true,
      polyComplexity: {
        poor: 3,
        low: 4,
        medium: 6,
        high: 12,
        ultra: 32
      }
    },
    //----------------------------------------------------------------------------
    // SURFACE SAS
    //----------------------------------------------------------------------------

    /**
     * Solvent Accessible Surface mode options.
     *
     * @typedef IsoSurfaceSASModeOptions
     *
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {number} probeRadius - Radius of the probe.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    SA: {
      zClip: false,
      probeRadius: 1.5,
      subset: '',
      wireframe: false,
      polyComplexity: {
        poor: 6,
        low: 8,
        medium: 16,
        high: 30,
        ultra: 60
      }
    },
    //----------------------------------------------------------------------------
    // SURFACE SES
    //----------------------------------------------------------------------------

    /**
     * Solvent Excluded Surface mode options.
     *
     * @typedef IsoSurfaceSESModeOptions
     *
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {number} probeRadius - Radius of the probe.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    SE: {
      zClip: false,
      probeRadius: 1.5,
      subset: '',
      wireframe: false,
      polyComplexity: {
        poor: 6,
        low: 8,
        medium: 16,
        high: 30,
        ultra: 60
      }
    },
    //----------------------------------------------------------------------------
    // QUICK SURFACE
    //----------------------------------------------------------------------------

    /**
     * Quick Surface mode options.
     *
     * @typedef QuickSurfaceModeOptions
     *
     * @property {number} isoValue - Isovalue of the surface to extract.
     * @property {number} scale - Radius scale for the surface being built.
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} gaussLim - Gauss lim for coloring the bigger the value, the smoother our colors are.
     * @property {PolyComplexity} gridSpacing - Poly complexity values for render modes. In this case the value
     *   corresponds to the grid density.
     */
    QS: {
      isoValue: 0.5,
      gaussLim: {
        poor: 1.5,
        low: 2.0,
        medium: 2.5,
        high: 3.0,
        ultra: 4.0
      },
      scale: 1.0,
      wireframe: false,
      gridSpacing: {
        poor: 2,
        low: 1.5,
        medium: 1,
        high: 0.5,
        ultra: 0.25
      },
      subset: '',
      zClip: false
    },
    //----------------------------------------------------------------------------
    // CONTACT SURFACE
    //----------------------------------------------------------------------------

    /**
     * Contact Surface mode options.
     *
     * @typedef ContactSurfaceModeOptions
     *
     * @property {number} isoValue - Isovalue of the surface to extract.
     * @property {number} probeRadius - Probe radius.
     * @property {number} probePositions
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} polyComplexity - Radius scale for the surface being built.
     *   Poly complexity values for render modes. In this case the value corresponds to the grid density.
     */
    CS: {
      probeRadius: 1.4,
      isoValue: 1.5,
      wireframe: false,
      probePositions: 30,
      polyComplexity: {
        poor: 0.5,
        low: 1.0,
        medium: 1.5,
        high: 1.75,
        ultra: 2.0
      },
      subset: '',
      zClip: false
    },
    //----------------------------------------------------------------------------
    // TRACE
    //----------------------------------------------------------------------------

    /**
     * Trace mode options.
     *
     * @typedef TraceModeOptions
     *
     * @property {number} radius - Cylinder radius.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    TR: {
      radius: 0.30,
      polyComplexity: {
        poor: 12,
        low: 16,
        medium: 32,
        high: 64,
        ultra: 64
      }
    },
    //----------------------------------------------------------------------------
    // TUBE
    //----------------------------------------------------------------------------

    /**
     * Tube mode options.
     *
     * @typedef TubeModeOptions
     *
     * @property {number} radius - Cylinder radius.
     * @property {number} tension - Tension for interpolation.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
     */
    TU: {
      radius: 0.30,
      heightSegmentsRatio: 1.5,
      tension: -0.7,
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 10,
        high: 18,
        ultra: 34
      }
    },
    //----------------------------------------------------------------------------
    // CARTOON
    //----------------------------------------------------------------------------

    /**
     * Cartoon mode options.
     *
     * @typedef CartoonModeOptions
     *
     * @property {number} radius - Standard tube radius.
     * @property {number} depth - Height of the secondary structure ribbon.
     * @property {number} tension - Tension for interpolation.
     * @proprety {object} ss - Secondary structure parameters.
     * @proprety {object} ss.helix - Options for helices render.
     * @proprety {number} ss.helix.width - Width of the secondary structure ribbon.
     * @proprety {number} ss.helix.arrow - Secondary structure's arrow width.
     * @proprety {object} ss.strand - Options for strands render.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     * polyComplexity must be even for producing symmetric arrows.
     * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
     */
    CA: {
      radius: 0.30,
      depth: 0.25,
      ss: {
        helix: {
          width: 1.0,
          arrow: 2.0
        },
        strand: {
          width: 1.0,
          arrow: 2.0
        }
      },
      heightSegmentsRatio: 1.5,
      tension: -0.7,
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 10,
        high: 18,
        ultra: 34
      }
    },
    //----------------------------------------------------------------------------
    // TEXT
    //----------------------------------------------------------------------------

    /**
     * Text mode options.
     *
     * @typedef TextModeOptions
     *
     * @property {string} template - Format string for building output text.
     * @property {string} horizontalAlign - Text alignment ('left', 'right', 'center').
     * @property {string} verticalAlign - Vertical text box alignment ('top', 'bottom', 'middle').
     * @property {number} dx - Text offset x in angstroms.
     * @property {number} dy - Text offset y in angstroms.
     * @property {number} dz - Text offset z in angstroms.
     * @property {string} fg - Color rule for foreground.
     * @property {string} bg - Color rule for background.
     * @property {boolean} showBg - Flag, that toggles background rendering.
     *
     */
    TX: {
      template: '{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}',
      horizontalAlign: 'center',
      verticalAlign: 'middle',
      dx: 0,
      dy: 0,
      dz: 1,
      fg: 'none',
      bg: '0x202020',
      showBg: true
    },
    //----------------------------------------------------------------------------
    // VOLUME DENSITY
    //----------------------------------------------------------------------------

    /**
     * Volume density mode options.
     *
     * @typedef VolumeDensityModeOptions
     *
     * @property {number} kSigma - Noise threshold coefficient.
     * @property {boolean} frame - flag, that turns on box frame painting.
     * @property {boolean} isoMode - flag, that turns on IsoSurface mode instead of Volume Rendering.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    VD: {
      kSigma: 1.0,
      kSigmaMed: 2.0,
      kSigmaMax: 4.0,
      frame: true,
      isoMode: false,
      polyComplexity: {
        poor: 2,
        low: 3,
        medium: 4,
        high: 8,
        ultra: 10
      }
    }
  },
  /**
   * Default options for all available colorers.
   * Use {@link Colorer.id} as a dictionary key to access colorer options.
   *
   * Usually you don't need to override these settings. You may specify colorer options as a parameter during
   * {@link Colorer} construction.
   *
   * Not all colorers have options.
   *
   * @memberof SettingsObject#
   * @type {Object.<string, object>}
   *
   * @property {ElementColorerOptions} EL - Element colorer options.
   * @property {SequenceColorerOptions} SQ - Sequence colorer options.
   * @property {MoleculeColorerOptions} MO - Molecule colorer options.
   * @property {UniformColorerOptions} UN - Uniform colorer options.
   * @property {ConditionalColorerOptions} CO - Conditional colorer options.
   * @property {TemperatureColorerOptions} TM - Temperature colorer options.
   * @property {OccupancyColorerOptions} OC - Occupancy colorer options.
   * @property {HydrophobicityColorerOptions} HY - Hydrophobicity colorer options.
   */
  colorers: {
    /**
     * Element colorer options.
     *
     * @typedef ElementColorerOptions
     *
     * @property {number} carbon - Carbon color or -1 to use default.
     */
    EL: {
      carbon: -1
    },
    /**
     * Uniform colorer options.
     *
     * @typedef UniformColorerOptions
     *
     * @property {number} color - Single color to paint with.
     */
    UN: {
      color: 0xFFFFFF
    },
    /**
     * Conditional colorer options.
     *
     * @typedef ConditionalColorerOptions
     *
     * @property {string} subset - Selector string.
     * @property {number} color - Color of selected atoms.
     * @property {number} baseColor - Color of other atoms.
     */
    CO: {
      subset: 'charged',
      color: 0xFF0000,
      baseColor: 0xFFFFFF
    },
    /**
     * Carbon colorer options.
     *
     * @typedef CarbonColorerOptions
     *
     * @property {number} color - Single color to paint carbons
     * @property {number} factor - Color factor for not carbon atoms.
     */
    CB: {
      color: 0x909090,
      factor: 0.6
    },
    /**
     * Sequence colorer options.
     *
     * @typedef SequenceColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    SQ: {
      gradient: 'rainbow'
    },
    /**
     * Temperature colorer options.
     *
     * @typedef TemperatureColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     * @property {number} min - Minimal temperature.
     * @property {number} max - Maximal temperature.
     */
    TM: {
      gradient: 'temp',
      min: 5,
      max: 40
    },
    /**
     * Occupancy colorer options.
     *
     * @typedef OccupancyColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    OC: {
      gradient: 'reds'
    },
    /**
     * Hydrophobicity colorer options.
     *
     * @typedef HydrophobicityColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    HY: {
      gradient: 'blue-red'
    },
    /**
     * Molecule colorer options.
     *
     * @typedef MoleculeColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    MO: {
      gradient: 'rainbow'
    }
  },
  /*
   * Use antialiasing in WebGL.
   * @type {boolean}
   */
  antialias: true,
  /*
   * Camera field of view in degrees.
   * @type {number}
   */
  camFov: 45.0,
  /*
   * Camera near plane distance.
   * @type {number}
   */
  camNear: 0.5,
  /*
   * Camera far plane distance.
   * @type {number}
   */
  camFar: 100.0,
  camDistance: 2.5,
  radiusToFit: 1.0,
  /**
   * @type {number}
   * @instance
   */
  fogNearFactor: 0.5,
  // [0, 1]

  /**
   * @type {number}
   * @instance
   */
  fogFarFactor: 1,
  // [0, 1]
  fogAlpha: 1.0,
  fogColor: 0x000000,
  fogColorEnable: false,
  /**
   * Palette used for molecule coloring.
   * @type {string}
   */
  palette: 'JM',
  /*
   * Geometry resolution.
   * @type {string}
   */
  resolution: 'medium',
  autoResolution: false /* true */,

  autoPreset: true,
  preset: 'default',
  // TODO: remove 'preset' from settings, implement autodetection

  presets: {
    // Default
    default: [{
      mode: 'BS',
      colorer: 'EL',
      selector: 'all',
      material: 'SF'
    }],
    empty: [],
    // Wireframe
    wire: [{
      mode: 'LN',
      colorer: 'EL',
      selector: 'all',
      material: 'SF'
    }],
    // Small molecules
    small: [{
      mode: 'BS',
      colorer: 'EL',
      selector: 'all',
      material: 'SF'
    }],
    // Proteins, nucleic acids etc.
    macro: [{
      mode: 'CA',
      colorer: 'SS',
      selector: 'not hetatm',
      material: 'SF'
    }, {
      mode: 'BS',
      colorer: 'EL',
      selector: 'hetatm and not water',
      material: 'SF'
    }]
  },
  objects: {
    line: {
      color: 0xFFFFFFFF,
      dashSize: 0.3,
      gapSize: 0.05
    }
  },
  //----------------------------------------------------------------------------

  bg: {
    color: 0x202020,
    transparent: false
  },
  draft: {
    clipPlane: false,
    clipPlaneFactor: 0.5,
    clipPlaneSpeed: 0.00003
  },
  /*
     * Separate group for plugins.
     * Each plugin handles its field by itself.
     */
  plugins: {},
  /**
   * @type {boolean}
   * @instance
   */
  axes: true,
  /**
   * @type {boolean}
   * @instance
   */
  fog: true,
  /**
   * @type {boolean}
   * @instance
   */
  fps: true,
  /**
   * Switch using of z-sprites for sphere and cylinder geometry
   * @type {boolean}
   * @instance
   */
  zSprites: true,
  isoSurfaceFakeOpacity: true,
  /**
   * @type {boolean}
   * @instance
   */
  suspendRender: true,
  nowater: false,
  /**
   * @type {boolean}
   * @instance
   */
  autobuild: true,
  /**
   * Anti-aliasing.
   * @type {boolean}
   * @instance
   */
  fxaa: true,
  /**
   * Outline depths
   * @type {boolean}
   * @instance
   */
  outline: {
    on: false,
    color: 0x000000,
    threshold: 0.1,
    thickness: 1
  },
  /**
   * Ambient Occlusion special effect.
   * @type {boolean}
   * @instance
   */
  ao: false,
  /**
   * Shadows options.
   *
   * @property {boolean} shadowMap - enable/disable.
   * @property {string} basic/percentage-closer filtering/non-uniform randomizing pcf.
   * @property {number} radius for percentage-closer filtering.
   */
  shadow: {
    on: false,
    type: 'random' /* basic, pcf, random */,
    radius: 1.0
  },
  /**
   * Auto-rotation with constant speed.
   * @type {number}
   * @instance
   */
  autoRotation: 0.0,
  /**
   * Set maximum fps for animation.
   * @type {number}
   * @instance
   */
  maxfps: 30,
  /**
   * Set fbx output precision.
   * @type {number}
   * @instance
   */
  fbxprec: 4,
  /**
   * Auto-rotation axis.
   *
   * - true:  complex auto-rotation is about vertical axis
   * - false: rotation axis is defined by last user rotation
   *
   * @type {boolean}
   * @instance
   */
  autoRotationAxisFixed: true,
  /**
   * Enable zooming with mouse wheel or pinch gesture.
   * @type {boolean}
   * @instance
   */
  zooming: true,
  /**
   * Enable picking atoms & residues with left mouse button or touch.
   * @type {boolean}
   * @instance
   */
  picking: true,
  /**
   * Set picking mode ('atom', 'residue', 'chain', 'molecule').
   * @type {string}
   * @instance
   */
  pick: 'atom',
  /**
   * Make "component" and "fragment" editing modes available.
   * @type {boolean}
   * @instance
   */
  editing: false,
  /**
   * Detect aromatic loops.
   * @type {boolean}
   * @instance
   */
  aromatic: false,
  /**
   * Load only one biological unit from all those described in PDB file.
   * @type {boolean}
   * @instance
   */
  singleUnit: true,
  /**
   * Set stereo mode ('NONE', 'SIMPLE', 'DISTORTED', 'ANAGLYPH', 'WEBVR').
   * @type {string}
   * @instance
   */
  stereo: 'NONE',
  /**
   * Enable smooth transition between views
   * @type {boolean}
   * @instance
   */
  interpolateViews: true,
  /**
   * Set transparency mode ('standard', 'prepass').
   * @type {string}
   * @instance
   */
  transparency: 'prepass',
  /**
   * Mouse translation speed.
   * @type {number}
   * @instance
   */
  translationSpeed: 2,
  debug: {
    example: 3.5,
    text: 'hello!',
    good: true,
    ssaoKernelRadius: 0.7,
    ssaoFactor: 0.7,
    stereoBarrel: 0.25
  },
  use: {
    multiFile: false
  }
};

//----------------------------------------------------------------------------
// SETTINGS CLASS
//----------------------------------------------------------------------------

function Settings() {
  utils_EventDispatcher.call(this);
  this.old = null;
  this.now = {};
  this._changed = {};
  this.reset();
}
utils.deriveClass(Settings, utils_EventDispatcher, {
  defaults: settings_defaults,
  set(path, value) {
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(path)) {
      const oldValue = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(this.now, path);
      if (oldValue !== value) {
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(this.now, path, value);
        this._notifyChange(path, value);
      }
    } else {
      const diff = utils.objectsDiff(path, this.now);
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(this.now, diff);
        this._notifyChanges(diff);
      }
    }
  },
  get(path, defaultValue) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(this.now, path, defaultValue);
  },
  reset() {
    const diff = utils.objectsDiff(settings_defaults, this.now);
    this.now = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(settings_defaults);
    this.old = null;
    this._notifyChanges(diff);
    this._changed = {};
  },
  checkpoint() {
    this.old = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(this.now);
    this._changed = {};
  },
  _notifyChange(path, value) {
    this._changed[path] = true;
    this.dispatchEvent({
      type: `change:${path}`,
      value
    });
  },
  _notifyChanges(diff) {
    utils.forInRecursive(diff, (deepValue, deepPath) => {
      this._notifyChange(deepPath, deepValue);
    });
  },
  changed() {
    if (!this.old) {
      return [];
    }
    const {
      old,
      now
    } = this;
    const keys = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].filter(Object.keys(this._changed), key => external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(old, key) !== external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(now, key));
    return keys;
  },
  applyDiffs(diffs) {
    if (diffs.hasOwnProperty('VERSION') && diffs.VERSION !== VERSION) {
      throw new Error('Settings version does not match!');
    }
    // VERSION shouldn't be presented inside settings structure
    delete diffs.VERSION;
    this.reset();
    this.set(diffs);
  },
  getDiffs(versioned) {
    const diffs = utils.objectsDiff(this.now, settings_defaults);
    if (versioned) {
      diffs.VERSION = VERSION;
    }
    return diffs;
  },
  setPluginOpts(plugin, opts) {
    settings_defaults.plugins[plugin] = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(opts);
    this.now.plugins[plugin] = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(opts);
  }
});
/* harmony default export */ const settings = (new Settings());
;// CONCATENATED MODULE: ./src/options.js




let repIndex = 0;
function asBoolean(value) {
  return !(!value || value === '0' || external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(value) && value.toLowerCase() === 'false');
}
const adapters = {
  string: String,
  number: Number,
  boolean: asBoolean
};

// Level 1 assignment symbol
const cL1Ass = '=';
const cOptsSep = '!';
// Level 2 (options) assignment symbol
const cL2Ass = ':';
// Level 2 (options) separator symbol
const cLSep = ',';
const cCommonIgnoreSymbols = '$;@/?';
/**
 * We may (and should) leave as is for better readability:
 *
 *        $ , ; : @ / ?
 */
/**
 * Generate regular expression for symbols excluded for first level encryption
 */
function getLevel1ExcludedExpr() {
  const cLevel1Ignores = ':,';
  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
}

/**
 * Generate regular expression for symbols excluded for first level encryption
 * (options, etc, ..)
 */
function getLevel2ExcludedExpr() {
  const cLevel2Ignores = ' ';
  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
}
const cL1ExclExpr = getLevel1ExcludedExpr();
function encodeQueryComponentL1(value) {
  return utils.encodeQueryComponent(value, cL1ExclExpr);
}
const cL2ExclExpr = getLevel2ExcludedExpr();
function encodeQueryComponentL2(value) {
  return utils.encodeQueryComponent(value, cL2ExclExpr);
}
function ensureRepList(opts) {
  let {
    reps
  } = opts;
  if (!reps) {
    const {
      presets
    } = settings.now;
    let preset = opts.preset || settings.now.preset;
    reps = presets[preset];
    if (!reps) {
      logger.warn(`Unknown preset "${preset}"`);
      [preset] = Object.keys(presets);
      reps = presets[preset]; // fall back to any preset
    }
    opts.preset = preset;
    opts.reps = utils.deriveDeep(reps, true);
  }
}
function ensureRepAssign(opts, prop, value) {
  ensureRepList(opts);
  const rep = opts.reps[repIndex];
  // prop specified twice therefore start new rep by cloning the current
  if (rep.hasOwnProperty(prop)) {
    repIndex = opts.reps.length;
    opts.reps[repIndex] = utils.deriveDeep(rep, true);
  }
  if (value !== undefined) {
    opts.reps[repIndex][prop] = value;
  }
}
function addObject(opts, params, options) {
  if (opts._objects === undefined) {
    opts._objects = [];
  }
  const [type, newOpts] = options;
  const newObj = {
    type,
    params
  };
  if (newOpts !== undefined) {
    newObj.opts = newOpts;
  }
  opts._objects[opts._objects.length] = newObj;
}
function parseParams(str, params) {
  const sep = str.indexOf(',');
  if (sep >= 0) {
    params.push(str.substr(sep + 1).split(','));
    return str.substr(0, sep);
  }
  // keep this untouched if no params were extracted
  return str;
}
function extractArgs(input, defaultsDict, params) {
  if (input) {
    const bang = input.indexOf(cOptsSep);
    const inputVal = parseParams(input.substr(0, bang >= 0 ? bang : undefined), params);
    if (bang >= 0) {
      const args = input.substr(bang + 1).split(cLSep);
      input = inputVal;
      if (defaultsDict) {
        const defaults = defaultsDict[input];
        const opts = utils.deriveDeep(defaults, true);
        args.forEach(arg => {
          const pair = arg.split(cL2Ass, 2);
          const key = decodeURIComponent(pair[0]);
          const value = decodeURIComponent(pair[1]);
          const adapter = adapters[typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(defaults, key)];
          if (adapter) {
            external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(opts, key, adapter(value));
          } else {
            logger.warn(`Unknown argument "${key}" for option "${input}"`);
          }
        });
        if (Object.keys(opts).length > 0) {
          input = [input, opts];
        }
      }
    } else {
      input = inputVal;
    }
  }
  return input;
}
const actions = {
  l: 'load',
  load: String,
  t: 'type',
  type: String,
  v: 'view',
  view: String,
  u: 'unit',
  unit: Number,
  menu: asBoolean,
  // Commands

  o: 'object',
  object(value, opts) {
    const params = [];
    let options = extractArgs(value, settings.defaults.objects, params);
    if (!Array.isArray(options)) {
      options = [options];
    }
    addObject(opts, params[0], options);
  },
  p: 'preset',
  preset(value, opts) {
    opts.preset = value;
    opts.reps = null;
    ensureRepList(opts);
  },
  r: 'rep',
  rep(value, opts) {
    ensureRepList(opts);
    repIndex = Number(value);
    // clamp the index to one greater than the last
    repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length;
    // create a new rep if it is adjacent to the existing ones
    if (repIndex === opts.reps.length) {
      // if there is no rep to derive from, derive from the first rep of the default
      opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings.defaults.presets.default[0], true);
    }
  },
  s: 'select',
  select(value, opts) {
    ensureRepAssign(opts, 'selector', value);
  },
  m: 'mode',
  mode(value, opts) {
    ensureRepAssign(opts, 'mode', extractArgs(value, settings.defaults.modes));
  },
  c: 'color',
  color(value, opts) {
    ensureRepAssign(opts, 'colorer', extractArgs(value, settings.defaults.colorers));
  },
  mt: 'material',
  material(value, opts) {
    ensureRepAssign(opts, 'material', extractArgs(value, settings.defaults.materials));
  },
  dup(value, opts) {
    ensureRepList(opts);
    const {
      reps
    } = opts;
    const rep = reps[repIndex];
    repIndex = reps.length;
    reps[repIndex] = utils.deriveDeep(rep, true);
  },
  // Settings shortcuts

  ar: 'autoResolution'
};
function _fromArray(entries) {
  repIndex = 0;
  const opts = {};
  for (let i = 0, n = entries.length; i < n; ++i) {
    const /** string[] */entry = entries[i];
    let /** string? */key = entry[0];
    const /** string? */value = entry[1];
    let /** function|string? */action = actions[key];

    // unwind shortcuts and aliases
    while (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(action)) {
      key = action;
      action = actions[key];
    }

    // either set a property or use specialized parser
    if (!action) {
      const adapter = adapters[typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(settings.defaults, key)];
      if (adapter) {
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(opts, `settings.${key}`, adapter(value));
      } else {
        logger.warn(`Unknown option "${key}"`);
      }
    } else if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(action)) {
      const result = action(value, opts);
      if (result !== undefined) {
        opts[key] = result;
      }
    }
  }
  return opts;
}
function fromAttr(attr) {
  return _fromArray(utils.getUrlParameters(`?${attr || ''}`));
}
function fromURL(url) {
  return _fromArray(utils.getUrlParameters(url));
}
function _processOptsForURL(opts) {
  const str = [];
  let i = 0;
  utils.forInRecursive(opts, (value, key) => {
    str[i++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
  });
  return str.join(cLSep);
}
function _processArgsForURL(args) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(args)) {
    return args;
  }
  if (args.length < 2) {
    return args[0];
  }
  return `${args[0]}${cOptsSep}${_processOptsForURL(args[1])}`;
}
function _processObjForURL(objOpts) {
  if (!objOpts || !objOpts.type) {
    return undefined;
  }
  let res = objOpts.type;
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(objOpts.params) && objOpts.params.length > 0) {
    res += `,${objOpts.params.join(',')}`;
  }
  if (objOpts.opts) {
    res += cOptsSep + _processOptsForURL(objOpts.opts);
  }
  return res;
}
function toURL(opts) {
  const stringList = [];
  let idx = 0;
  function checkAndAdd(prefix, value) {
    if (value !== null && value !== undefined) {
      stringList[idx++] = encodeQueryComponentL1(prefix) + cL1Ass + encodeQueryComponentL1(value);
    }
  }
  function addReps(repList) {
    if (!repList) {
      return;
    }
    for (let i = 0, n = repList.length; i < n; ++i) {
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(repList[i])) {
        continue;
      }
      checkAndAdd('r', i);
      checkAndAdd('s', repList[i].selector);
      checkAndAdd('m', _processArgsForURL(repList[i].mode));
      checkAndAdd('c', _processArgsForURL(repList[i].colorer));
      checkAndAdd('mt', _processArgsForURL(repList[i].material));
    }
  }
  function addObjects(objList) {
    if (!objList) {
      return;
    }
    for (let i = 0, n = objList.length; i < n; ++i) {
      checkAndAdd('o', _processObjForURL(objList[i]));
    }
  }
  checkAndAdd('l', opts.load);
  checkAndAdd('u', opts.unit);
  checkAndAdd('p', opts.preset);
  addReps(opts.reps);
  addObjects(opts._objects);
  checkAndAdd('v', opts.view);
  utils.forInRecursive(opts.settings, (value, key) => {
    // I heard these lines in the whispers of the Gods
    // Handle preset setting in reps
    if (key === 'preset') {
      return;
    }
    checkAndAdd(key, value);
  });
  let url = '';
  if (typeof window !== 'undefined') {
    const {
      location
    } = window;
    url = `${location.protocol}//${location.host}${location.pathname}`;
  }
  if (stringList.length > 0) {
    url += `?${stringList.join('&')}`;
  }
  return url;
}
function _processOptsForScript(opts) {
  const str = [];
  let i = 0;
  utils.forInRecursive(opts, (value, key) => {
    str[i++] = `${key}=${utils.enquoteString(value)}`;
  });
  return str.join(' ');
}
function _processArgsForScript(args) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(args)) {
    return args;
  }
  if (args.length < 2) {
    return args[0];
  }
  return `${args[0]} ${_processOptsForScript(args[1])}`;
}
function _processObjForScript(objOpts) {
  if (!objOpts || !objOpts.type) {
    return undefined;
  }
  let res = objOpts.type;
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(objOpts.params) && objOpts.params.length > 0) {
    res += ` ${objOpts.params.map(utils.enquoteString).join(' ')}`;
  }
  if (objOpts.opts) {
    res += ` ${_processOptsForScript(objOpts.opts)}`;
  }
  return res;
}
function _processRepsForScript(rep, index) {
  const repString = [];
  let strIdx = 0;
  function localAdd(prefix, value) {
    if (value !== null && value !== undefined) {
      repString[strIdx++] = prefix + value;
    }
  }
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(rep)) {
    return null;
  }
  localAdd('', index);
  localAdd('s=', utils.enquoteString(rep.selector));
  localAdd('m=', _processArgsForScript(rep.mode));
  localAdd('c=', _processArgsForScript(rep.colorer));
  localAdd('mt=', _processArgsForScript(rep.material));
  return repString.join(' ');
}
function toScript(opts) {
  const commandsList = [];
  let idx = 0;
  function checkAndAdd(command, value, saveQuotes) {
    if (value !== null && value !== undefined) {
      const quote = typeof value === 'string' && saveQuotes ? '"' : '';
      commandsList[idx++] = `${command} ${quote}${value}${quote}`.trim();
    }
  }
  function addReps(repList) {
    if (!repList) {
      return;
    }
    for (let i = 0, n = repList.length; i < n; ++i) {
      checkAndAdd('rep', _processRepsForScript(repList[i], i));
    }
  }
  function addObjects(objList) {
    if (!objList) {
      return;
    }
    for (let i = 0, n = objList.length; i < n; ++i) {
      checkAndAdd('', _processObjForScript(objList[i]));
    }
  }
  checkAndAdd('set', 'autobuild false');
  checkAndAdd('load', opts.load, true);
  checkAndAdd('unit', opts.unit);
  checkAndAdd('preset', opts.preset);
  addReps(opts.reps);
  addObjects(opts._objects);
  utils.forInRecursive(opts.settings, (value, key) => {
    // I heard these lines in the whispers of the Gods
    // Handle preset setting in reps
    if (key === 'preset') {
      return;
    }
    checkAndAdd(`set ${key}`, value, true);
  });
  checkAndAdd('view', opts.view);
  checkAndAdd('set', 'autobuild true');
  return commandsList.join('\n');
}
/* harmony default export */ const options = ({
  fromURL,
  fromAttr,
  adapters,
  toURL,
  toScript
});
;// CONCATENATED MODULE: ./src/chem/Atom.js
/**
 * Atom measurements.
 *
 * @param {Residue} residue    - (required) Residue containing the atom
 * @param {string} name        - (required) Name, unique in the residue
 * @param {Element} type       - (required) Chemical element reference
 * @param {THREE.Vector3} position - Registered coordinates
 *
 * @param {number} role        - Role of atom inside monomer: Lead and wing are particularity interesting
 * @param {boolean} het        - Non-standard residue indicator
 *
 * @param {number} serial      - Serial number, unique in the model
 * @param {string} location    - Alternative location indicator (usually space or A-Z)
 * @param {number} occupancy   - Occupancy percentage, from 0 to 1
 * @param {number} temperature - Temperature
 * @param {number} charge      - Charge
 *
 * @exports Atom
 * @constructor
 */

class Atom {
  constructor(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
    this.index = -1;
    this.residue = residue;
    this.name = name;
    this.element = type;
    this.position = position;
    this.role = role;
    this.mask = 1 | 0;
    this.het = het;
    this.serial = serial;
    this.location = (location || ' ').charCodeAt(0);
    this.occupancy = occupancy || 1;
    this.temperature = temperature;
    this.charge = charge;
    this.hydrogenCount = -1; // explicitly invalid
    this.radicalCount = 0;
    this.valence = -1; // explicitly invalid

    this.bonds = [];
    this.flags = 0x0000;
    if (type.name === 'H') {
      this.flags |= Atom.Flags.HYDROGEN;
    } else if (type.name === 'C') {
      this.flags |= Atom.Flags.CARBON;
    }
  }
  isHet() {
    return this.het;
  }
  isHydrogen() {
    return this.element.number === 1;
  }
  getVisualName() {
    const {
      name
    } = this;
    if (name.length > 0) {
      return name;
    }
    return this.element.name.trim();
  }
  forEachBond(process) {
    const {
      bonds
    } = this;
    for (let i = 0, n = bonds.length; i < n; ++i) {
      process(bonds[i]);
    }
  }
  getFullName() {
    let name = '';
    if (this.residue !== null) {
      if (this.residue._chain !== null) {
        name += `${this.residue._chain.getName()}.`;
      }
      name += `${this.residue._sequence}.`;
    }
    name += this.name;
    return name;
  }

  /**
   * Enumeration of atom flag values.
   *
   * @enum {number}
   * @readonly
   */
  static Flags = {
    CARBON: 0x0001,
    // OXYGEN: 0x0002,
    // NITROGEN: 0x0004,
    HYDROGEN: 0x0008,
    /** Non-polar hydrogen (it is also a HYDROGEN) */
    NONPOLARH: 0x1008
  };
}
/* harmony default export */ const chem_Atom = (Atom);
;// CONCATENATED MODULE: ./src/chem/Element.js
class Element {
  constructor(number, name, fullName, weight, radius, radiusBonding, hValency) {
    this.number = number;
    this.name = name;
    this.fullName = fullName;
    this.weight = weight;
    this.radius = radius;
    this.radiusBonding = radiusBonding;
    this.hydrogenValency = hValency;
  }
  static Constants = {
    /* eslint-disable no-magic-numbers */
    U1: 1,
    Lead: 2,
    U2: 3,
    Wing: 4,
    U18: 18
    /* eslint-enable no-magic-numbers */
  };
  static Role = (() => ({
    /* eslint-disable no-magic-numbers */
    N: Element.Constants.U1,
    CA: Element.Constants.Lead,
    C: Element.Constants.U2,
    O: Element.Constants.Wing,
    SG: Element.Constants.U18
    /* eslint-enable no-magic-numbers */
  }))();

  // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
  static ByAtomicNumber = (() => [/* eslint-disable no-magic-numbers */
  null, new Element(1, 'H', 'Hydrogen', 1.008, 1.2, 0.23, [1]), new Element(2, 'HE', 'Helium', 4.003, 1.4, 0.93, [0]), new Element(3, 'LI', 'Lithium', 6.941, 1.82, 0.68, [1]), new Element(4, 'BE', 'Beryllium', 9.012, 1.7, 0.35, [2]), new Element(5, 'B', 'Boron', 10.81, 2.08, 0.83, [3]), new Element(6, 'C', 'Carbon', 12.011, 1.95, 0.68, [4]), new Element(7, 'N', 'Nitrogen', 14.007, 1.85, 0.68, [3, 5]), new Element(8, 'O', 'Oxygen', 15.999, 1.7, 0.68, [2, 4]), new Element(9, 'F', 'Fluorine', 18.998, 1.73, 0.64, [1]), new Element(10, 'NE', 'Neon', 20.18, 1.54, 1.12, [0]), new Element(11, 'NA', 'Sodium', 22.99, 2.27, 0.97, [1]), new Element(12, 'MG', 'Magnesium', 24.305, 1.73, 1.1, [2]), new Element(13, 'AL', 'Aluminum', 26.981, 2.05, 1.35, [3]), new Element(14, 'SI', 'Silicon', 28.086, 2.1, 1.2, [4]), new Element(15, 'P', 'Phosphorus', 30.974, 2.08, 0.75, [3, 5]), new Element(16, 'S', 'Sulfur', 32.07, 2, 1.02, [2, 4, 6]), new Element(17, 'CL', 'Chlorine', 35.453, 1.97, 0.99, [1, 3, 5, 7]), new Element(18, 'AR', 'Argon', 39.948, 1.88, 1.57, [0]), new Element(19, 'K', 'Potassium', 39.1, 2.75, 1.33, [1]), new Element(20, 'CA', 'Calcium', 40.08, 1.973, 0.99, [2]), new Element(21, 'SC', 'Scandium', 44.956, 1.7, 1.44, [0]), new Element(22, 'TI', 'Titanium', 47.88, 1.7, 1.47, [0]), new Element(23, 'V', 'Vanadium', 50.941, 1.7, 1.33, [0]), new Element(24, 'CR', 'Chromium', 52, 1.7, 1.35, [0]), new Element(25, 'MN', 'Manganese', 54.938, 1.7, 1.35, [0]), new Element(26, 'FE', 'Iron', 55.847, 1.7, 1.34, [0]), new Element(27, 'CO', 'Cobalt', 58.93, 1.7, 1.33, [0]), new Element(28, 'NI', 'Nickel', 58.69, 1.63, 1.5, [0]), new Element(29, 'CU', 'Copper', 63.55, 1.4, 1.52, [0]), new Element(30, 'ZN', 'Zinc', 65.39, 1.39, 1.45, [0]), new Element(31, 'GA', 'Gallium', 69.72, 1.87, 1.22, [3]), new Element(32, 'GE', 'Germanium', 72.61, 1.7, 1.17, [4]), new Element(33, 'AS', 'Arsenic', 74.92, 1.85, 1.21, [3, 5]), new Element(34, 'SE', 'Selenium', 78.96, 1.9, 1.22, [2, 4, 6]), new Element(35, 'BR', 'Bromine', 79.9, 2.1, 1.21, [1, 3, 5, 7]), new Element(36, 'KR', 'Krypton', 83.8, 2.02, 1.91, [0]), new Element(37, 'RB', 'Rubidium', 85.47, 1.7, 1.47, [1]), new Element(38, 'SR', 'Strontium', 87.62, 1.7, 1.12, [2]), new Element(39, 'Y', 'Yttrium', 88.91, 1.7, 1.78, [0]), new Element(40, 'ZR', 'Zirconium', 91.22, 1.7, 1.56, [0]), new Element(41, 'NB', 'Niobium', 92.91, 1.7, 1.48, [0]), new Element(42, 'MO', 'Molybdenum', 95.94, 1.7, 1.47, [0]), new Element(43, 'TC', 'Technetium', 98.91, 1.7, 1.35, [0]), new Element(44, 'RU', 'Ruthenium', 101.07, 1.7, 1.4, [0]), new Element(45, 'RH', 'Rhodium', 102.91, 1.7, 1.45, [0]), new Element(46, 'PD', 'Palladium', 106.42, 1.63, 1.5, [0]), new Element(47, 'AG', 'Silver', 107.87, 1.72, 1.59, [0]), new Element(48, 'CD', 'Cadmium', 112.41, 1.58, 1.69, [0]), new Element(49, 'IN', 'Indium', 114.82, 1.93, 1.63, [3]), new Element(50, 'SN', 'Tin', 118.71, 2.17, 1.46, [2, 4]), new Element(51, 'SB', 'Antimony', 121.75, 2.2, 1.46, [3, 5]), new Element(52, 'TE', 'Tellurium', 127.6, 2.06, 1.47, [2, 4, 6]), new Element(53, 'I', 'Iodine', 126.91, 2.15, 1.4, [1, 3, 5, 7]), new Element(54, 'XE', 'Xenon', 131.29, 2.16, 1.98, [0]), new Element(55, 'CS', 'Cesium', 132.91, 1.7, 1.67, [1]), new Element(56, 'BA', 'Barium', 137.33, 1.7, 1.34, [2]), new Element(57, 'LA', 'Lanthanum', 138.91, 1.7, 1.87, [0]), new Element(58, 'CE', 'Cerium', 140.12, 1.7, 1.83, [0]), new Element(59, 'PR', 'Praseodymium', 140.91, 1.7, 1.82, [0]), new Element(60, 'ND', 'Neodymium', 144.24, 1.7, 1.81, [0]), new Element(61, 'PM', 'Promethium', 144.9, 1.7, 1.8, [0]), new Element(62, 'SM', 'Samarium', 150.36, 1.7, 1.8, [0]), new Element(63, 'EU', 'Europium', 151.96, 1.7, 1.99, [0]), new Element(64, 'GD', 'Gadolinium', 157.25, 1.7, 1.79, [0]), new Element(65, 'TB', 'Terbium', 158.93, 1.7, 1.76, [0]), new Element(66, 'DY', 'Dysprosium', 162.5, 1.7, 1.75, [0]), new Element(67, 'HO', 'Holmium', 164.93, 1.7, 1.74, [0]), new Element(68, 'ER', 'Erbium', 167.26, 1.7, 1.73, [0]), new Element(69, 'TM', 'Thulium', 168.93, 1.7, 1.72, [0]), new Element(70, 'YB', 'Ytterbium', 173.04, 1.7, 1.94, [0]), new Element(71, 'LU', 'Lutetium', 174.97, 1.7, 1.72, [0]), new Element(72, 'HF', 'Hafnium', 178.49, 1.7, 1.57, [0]), new Element(73, 'TA', 'Tantalum', 180.95, 1.7, 1.43, [0]), new Element(74, 'W', 'Tungsten', 183.85, 1.7, 1.37, [0]), new Element(75, 'RE', 'Rhenium', 186.21, 1.7, 1.35, [0]), new Element(76, 'OS', 'Osmium', 190.2, 1.7, 1.37, [0]), new Element(77, 'IR', 'Iridium', 192.22, 1.7, 1.32, [0]), new Element(78, 'PT', 'Platinum', 195.08, 1.72, 1.5, [0]), new Element(79, 'AU', 'Gold', 196.97, 1.66, 1.5, [0]), new Element(80, 'HG', 'Mercury', 200.59, 1.55, 1.7, [0]), new Element(81, 'TL', 'Thallium', 204.38, 1.96, 1.55, [1, 3]), new Element(82, 'PB', 'Lead', 207.2, 2.02, 1.54, [2, 4]), new Element(83, 'BI', 'Bismuth', 208.98, 1.7, 1.54, [3, 5]), new Element(84, 'PO', 'Polonium', 210, 1.7, 1.68, [2, 4, 6]), new Element(85, 'AT', 'Astatine', 210, 1.7, 1.7, [1, 3, 5, 7]), new Element(86, 'RN', 'Radon', 222, 1.7, 2.4, [0]), new Element(87, 'FR', 'Francium', 223, 1.7, 2, [1]), new Element(88, 'RA', 'Radium', 226.03, 1.7, 1.9, [2]), new Element(89, 'AC', 'Actinium', 227.03, 1.7, 1.88, [0]), new Element(90, 'TH', 'Thorium', 232.04, 1.7, 1.79, [0]), new Element(91, 'PA', 'Protactinium', 231.04, 1.7, 1.61, [0]), new Element(92, 'U', 'Uranium', 238.03, 1.86, 1.58, [0]), new Element(93, 'NP', 'Neptunium', 237.05, 1.7, 1.55, [0]), new Element(94, 'PU', 'Plutonium', 239.1, 1.7, 1.53, [0]), new Element(95, 'AM', 'Americium', 243.1, 1.7, 1.51, [0]), new Element(96, 'CM', 'Curium', 247.1, 1.7, 1.5, [0]), new Element(97, 'BK', 'Berkelium', 247.1, 1.7, 1.5, [0]), new Element(98, 'CF', 'Californium', 252.1, 1.7, 1.5, [0]), new Element(99, 'ES', 'Einsteinium', 252.1, 1.7, 1.5, [0]), new Element(100, 'FM', 'Fermium', 257.1, 1.7, 1.5, [0]), new Element(101, 'MD', 'Mendelevium', 256.1, 1.7, 1.5, [0]), new Element(102, 'NO', 'Nobelium', 259.1, 1.7, 1.5, [0]), new Element(103, 'LR', 'Lawrencium', 260.1, 1.7, 1.5, [0]), new Element(104, 'RF', 'Rutherfordium', 261, 1.7, 1.6, [0]), new Element(105, 'DB', 'Dubnium', 262, 1.7, 1.6, [0]), new Element(106, 'SG', 'Seaborgium', 263, 1.7, 1.6, [0]), new Element(107, 'BH', 'Bohrium', 262, 1.7, 1.6, [0]), new Element(108, 'HS', 'Hassium', 265, 1.7, 1.6, [0]), new Element(109, 'MT', 'Meitnerium', 268, 1.7, 1.6, [0])
  /* eslint-enable no-magic-numbers */])();

  // DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
  static ByName = (() => ({
    // Duplicate atomic numbers (isotopes)
    /* eslint-disable no-magic-numbers */
    D: new Element(1, 'D', 'Deuterium', 2.014, 1.2, 0.23, [1]),
    T: new Element(1, 'T', 'Tritium', 3.016, 1.2, 0.23, [1])
    /* eslint-enable no-magic-numbers */

    // All regular elements will be added later, automatically
  }))();
}
(function () {
  const byAtomicNumber = Element.ByAtomicNumber;
  const byName = Element.ByName;
  for (let i = 0, n = byAtomicNumber.length; i < n; ++i) {
    const element = byAtomicNumber[i];
    if (element) {
      byName[element.name] = element;
    }
  }
})();

// find atom type by chemical element (or create if missing)
Element.getByName = function (element) {
  let type = Element.ByName[element];
  if (!type) {
    type = Element.ByName[element] = new Element(0, element, 'Unknown', 0, 1.0, 0.01, [0]);
  }
  return type;
};
/* harmony default export */ const chem_Element = (Element);
;// CONCATENATED MODULE: ./src/chem/Bond.js
const cBondTypes = {
  /** Was generated manually */
  UNKNOWN: 0,
  /** Simple covalent bond */
  COVALENT: 1,
  /** Aromatic bond */
  AROMATIC: 2
};
function getAtomPos(atom) {
  return atom.position;
}

/**
 * Bond between atoms.
 *
 * @param {Atom} left     - The first atom.
 * @param {Atom} right    - The second atom.
 * @param {number} order - Order of current bond.
 * @param {number} type - Bond type.
 * @param {boolean} fixed - Indicator of a pre-specified connection (in contrast with guessed one).
 *
 * @exports Bond
 * @constructor
 */
class Bond {
  constructor(left, right, order, type, fixed) {
    this._left = left;
    this._right = right;
    this._fixed = fixed;
    this._index = -1;
    if (left > right) {
      throw new Error('In a bond atom indices must be in increasing order');
    }
    this._order = order;
    this._type = type;
  }
  getLeft() {
    return this._left;
  }
  getRight() {
    return this._right;
  }
  getOrder() {
    return this._order;
  }
  calcLength() {
    return this._left.position.distanceTo(this._right.position);
  }
  _forEachNeighbour(currAtom, process) {
    const {
      bonds
    } = currAtom;
    for (let i = 0, n = bonds.length; i < n; ++i) {
      process(bonds[i]._left !== currAtom ? bonds[i]._left : bonds[i]._right);
    }
  }
  forEachLevelOne(process) {
    const left = this._left;
    const right = this._right;
    this._forEachNeighbour(left, atom => {
      if (atom === right) {
        return;
      }
      process(atom);
    });
    this._forEachNeighbour(right, atom => {
      if (atom === left) {
        return;
      }
      process(atom);
    });
  }
  forEachLevelTwo(process) {
    // TODO refactor this piece of an art?
    const left = this._left;
    const right = this._right;
    const self = this;
    self._forEachNeighbour(left, atom => {
      if (atom === right) {
        return;
      }
      self._forEachNeighbour(atom, l2Atom => {
        if (l2Atom === left) {
          return;
        }
        process(l2Atom);
      });
    });
    self._forEachNeighbour(right, atom => {
      if (atom === left) {
        return;
      }
      self._forEachNeighbour(atom, l2Atom => {
        if (l2Atom === right) {
          return;
        }
        process(l2Atom);
      });
    });
  }
  _fixDir(refPoint, currDir, posGetter) {
    // count atoms to the right and to the left of the current plane
    let rightCount = 0;
    let leftCount = 0;
    const tmpVec = refPoint.clone();
    function checkDir(atom) {
      tmpVec.copy(posGetter(atom));
      tmpVec.sub(refPoint);
      const dotProd = currDir.dot(tmpVec);
      if (dotProd > 0) {
        ++rightCount;
      } else {
        ++leftCount;
      }
    }
    function checkCarbon(atom) {
      if (atom.element.name === 'C') {
        checkDir(atom);
      }
    }
    // count all atoms to the left and right of our plane, start from level 1 and carbons
    const stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];
    for (let stageId = 0; stageId < stages.length; ++stageId) {
      stages[stageId][0].call(this, stages[stageId][1]);
      if (leftCount > rightCount) {
        return currDir.multiplyScalar(-1);
      }
      if (leftCount < rightCount) {
        return currDir;
      }
    }
    return currDir;
  }
  calcNormalDir(posGetter) {
    const left = this._left;
    const right = this._right;
    let first = left;
    let second = right;
    posGetter = posGetter === undefined ? getAtomPos : posGetter;
    if (left.bonds.length > right.bonds.length) {
      first = right;
      second = left;
    }
    let third = first;
    let maxNeibs = 0;
    const {
      bonds
    } = second;
    for (let i = 0, n = bonds.length; i < n; ++i) {
      let another = bonds[i]._left;
      if (bonds[i]._left === second) {
        another = bonds[i]._right;
      }
      if (another.bonds.length > maxNeibs && another !== first) {
        third = another;
        maxNeibs = another.bonds.length;
      }
    }
    const secondPos = posGetter(second);
    const firstV = posGetter(first).clone().sub(secondPos);
    const secondV = posGetter(third).clone().sub(secondPos);
    secondV.crossVectors(firstV, secondV);
    if (secondV.lengthSq() < 0.0001) {
      secondV.set(0, 1, 0);
    }
    firstV.normalize();
    secondV.normalize();
    firstV.crossVectors(secondV, firstV);
    if (firstV.lengthSq() < 0.0001) {
      firstV.set(0, 1, 0);
    }
    firstV.normalize();
    return this._fixDir(secondPos, firstV, posGetter);
  }
  static BondType = (() => cBondTypes)();
}
Bond.prototype.BondType = cBondTypes;
/* harmony default export */ const chem_Bond = (Bond);
;// CONCATENATED MODULE: ./src/chem/Residue.js



const cNucleicControlNames = ['C3\'', 'C3*', 'P', 'H5T', 'H3T'];
const cNucleicWing1Names = ['OP1', 'O1P'];
const cNucleicWing2Names = ['OP2', 'O2P'];
const cCylinderSource = ['C3\'', 'C3*', 'C1', 'C1\'', 'C1*', 'P'];
const cCylinderTarget = [{
  types: ['A', 'DA', 'G', 'DG'],
  atoms: ['N1']
}, {
  types: ['C', 'DC'],
  atoms: ['N3']
}, {
  types: ['T', 'DT', 'U', 'DU'],
  atoms: ['O4']
}];

/**
 * Residue instance.
 *
 * @param {Chain} chain      - Chain this residue belongs to.
 * @param {ResidueType} type - Generic residue instance type.
 * @param {number} sequence  - Sequence ID.
 * @param {string} icode     - One character insertion code (usually space or A-Z).
 *
 * @exports Residue
 * @constructor
 */
class Residue {
  constructor(chain, type, sequence, icode) {
    this._chain = chain;
    this._component = null;
    this._type = type;
    this._sequence = sequence;
    this._icode = icode;
    this._mask = 1 | 0;
    this._index = -1;
    this._atoms = [];
    this._secondary = null;
    this._firstAtom = null;
    this._leadAtom = null;
    this._wingAtom = null;
    this._lastAtom = null;
    this._controlPoint = null;
    this._midPoint = null;
    this._wingVector = null;
    this._cylinders = null;
    this._isValid = true;
    this._het = false;
    this._molecule = null;
    this.temperature = null;
    this.occupancy = null;
  }

  // Getters and setters
  getChain() {
    return this._chain;
  }
  getMolecule() {
    return this._molecule;
  }
  getType() {
    return this._type;
  }
  getSequence() {
    return this._sequence;
  }
  getSecondary() {
    return this._secondary;
  }
  getICode() {
    return this._icode;
  }

  // Other methods

  addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
    const atom = new chem_Atom(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    const complex = this._chain.getComplex();
    complex.addAtom(atom);
    this._atoms.push(atom);
    this._het = this._het || het;
    return atom;
  }
  getAtomCount() {
    return this._atoms.length;
  }
  forEachAtom(process) {
    const atoms = this._atoms;
    for (let i = 0, n = atoms.length; i < n; ++i) {
      if (process(atoms[i])) {
        break;
      }
    }
  }
  _findAtomByName(name) {
    let res = null;
    this.forEachAtom(atom => {
      if (atom.name === name) {
        res = atom;
        return true;
      }
      return false;
    });
    return res;
  }
  _findFirstAtomInList(names) {
    let res = null;
    for (let i = 0; i < names.length; ++i) {
      res = this._findAtomByName(names[i]);
      if (res !== null) {
        return res;
      }
    }
    return res;
  }
  collectMask() {
    let mask = 0xffffffff;
    const atoms = this._atoms;
    for (let i = 0, n = atoms.length; i < n; ++i) {
      mask &= atoms[i].mask;
    }
    this._mask = mask;
  }
  getCylinderTargetList() {
    const type = this._type._name;
    for (let i = 0, n = cCylinderTarget.length; i < n; ++i) {
      for (let j = 0, m = cCylinderTarget[i].types.length; j < m; ++j) {
        if (type === cCylinderTarget[i].types[j]) {
          return cCylinderTarget[i].atoms;
        }
      }
    }
    return null;
  }
  _detectLeadWing(dst, next, getAtomPosition) {
    const leadAtom = this._findFirstAtomInList(cNucleicControlNames);
    let wingStart = this._findFirstAtomInList(cNucleicWing1Names);
    let wingEnd = this._findFirstAtomInList(cNucleicWing2Names);
    if (wingStart === null && next !== null) {
      wingStart = next._findFirstAtomInList(cNucleicWing1Names);
    }
    if (wingEnd === null && next !== null) {
      wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
    }
    if (leadAtom === null || wingStart === null || wingEnd === null) {
      return;
    }
    dst._leadAtom = leadAtom;
    dst._controlPoint = getAtomPosition(leadAtom);
    dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
    dst._isValid = true;
    const cylSource = this._findFirstAtomInList(cCylinderSource);
    const targetList = this.getCylinderTargetList();
    const cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;
    if (cylSource === null || cylTarget === null) {
      return;
    }
    dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
  }
  calcWing(prevLeadPos, currLeadPos, prevWingPos, prevWing) {
    const vectorA = currLeadPos.clone().sub(prevLeadPos);
    const vectorB = prevLeadPos.clone().sub(prevWingPos);
    vectorB.crossVectors(vectorA, vectorB);
    vectorB.crossVectors(vectorA, vectorB).normalize();
    if (prevWing !== null && prevWing.length() > 0.0001) {
      const needToNegate = vectorB.length() > 0.0001 && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2;
      if (needToNegate) {
        vectorB.negate();
      }
    }
    return vectorB;
  }
  _innerFinalize(prevRes, prev, nextRes, dst, chainAsNucleic, getAtomPosition) {
    const bFirstInChain = prev === null;
    const lp = getAtomPosition(this._leadAtom);
    const currLeadPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(lp.x, lp.y, lp.z);
    if (chainAsNucleic) {
      this._detectLeadWing(dst, nextRes, getAtomPosition);
      return;
    }
    if (bFirstInChain) {
      // for first one in chain
      dst._midPoint = getAtomPosition(this._firstAtom).clone();
    } else {
      const prevLeadPos = prev._controlPoint; // lead point of previous monomer
      dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
      dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
    }
    dst._controlPoint = currLeadPos;
  }
  _finalize2(prev, next, asNucleic) {
    // Should be called AFTER first finalize
    this._innerFinalize(prev, prev, next, this, asNucleic, atom => atom.position);
  }
  isConnected(anotherResidue) {
    if (this._chain !== anotherResidue._chain) {
      return false;
    }
    if (this === anotherResidue) {
      return true;
    }
    let res = false;
    this.forEachAtom(atom => {
      const {
        bonds
      } = atom;
      for (let i = 0, n = bonds.length; i < n; ++i) {
        const bond = bonds[i];
        if (bond._left.residue === anotherResidue || bond._right.residue === anotherResidue) {
          res = true;
          return true;
        }
      }
      return false;
    });
    return res;
  }
  _finalize() {
    const self = this;
    [this._firstAtom] = this._atoms;
    this._lastAtom = this._atoms[this._atoms.length - 1];
    this._leadAtom = null;
    this._wingAtom = null;
    let tempCount = 0;
    let temperature = 0; // average temperature
    let occupCount = 0;
    let occupancy = 0; // average occupancy
    this.forEachAtom(a => {
      if (self._leadAtom === null) {
        if (a.role === chem_Element.Constants.Lead) {
          self._leadAtom = a;
        }
      }
      if (self._wingAtom === null) {
        if (a.role === chem_Element.Constants.Wing) {
          self._wingAtom = a;
        }
      }
      if (a.temperature) {
        temperature += a.temperature;
        tempCount++;
      }
      if (a.occupancy) {
        occupancy += a.occupancy;
        occupCount++;
      }
      return self._leadAtom !== null && self._wingAtom !== null;
    });
    if (tempCount > 0) {
      this.temperature = temperature / tempCount;
    }
    if (occupCount > 0) {
      this.occupancy = occupancy / occupCount;
    }

    // Still try to make monomer look valid
    if (this._leadAtom === null || this._wingAtom === null) {
      this._isValid = false;
    }
    if (this._leadAtom === null) {
      this._leadAtom = this._firstAtom;
    }
    if (this._wingAtom === null) {
      this._wingAtom = this._lastAtom;
    }
  }
}
/* harmony default export */ const chem_Residue = (Residue);
;// CONCATENATED MODULE: ./src/chem/ResidueType.js
/**
 * Residue type.
 *
 * Predefined acid or created with HET, HETNAM, etc.
 *
 * @param {string} name            - Short name, either standard (ALA, MET, etc.) or non-standard one.
 * @param {string} fullName        - Full residue name.
 * @param {string} letterCode      - 1-letter symbol.
 *
 * @exports ResidueType
 * @constructor
 */
class ResidueType {
  constructor(name, fullName, letterCode) {
    this._name = name;
    this._fullName = fullName;
    this.letterCode = letterCode;
    this.flags = 0x0000;
  }
  getName() {
    return this._name;
  }

  // DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
  static StandardTypes = (() => ({
    /* eslint-disable no-magic-numbers */
    ALA: new ResidueType('ALA', 'Alanine', 'A'),
    ARG: new ResidueType('ARG', 'Arginine', 'R'),
    ASN: new ResidueType('ASN', 'Asparagine', 'N'),
    ASP: new ResidueType('ASP', 'Aspartic Acid', 'D'),
    CYS: new ResidueType('CYS', 'Cysteine', 'C'),
    GLN: new ResidueType('GLN', 'Glutamine', 'Q'),
    GLU: new ResidueType('GLU', 'Glutamic Acid', 'E'),
    GLY: new ResidueType('GLY', 'Glycine', 'G'),
    HIS: new ResidueType('HIS', 'Histidine', 'H'),
    ILE: new ResidueType('ILE', 'Isoleucine', 'I'),
    LEU: new ResidueType('LEU', 'Leucine', 'L'),
    LYS: new ResidueType('LYS', 'Lysine', 'K'),
    MET: new ResidueType('MET', 'Methionine', 'M'),
    PHE: new ResidueType('PHE', 'Phenylalanine', 'F'),
    PRO: new ResidueType('PRO', 'Proline', 'P'),
    PYL: new ResidueType('PYL', 'Pyrrolysine', 'O'),
    SEC: new ResidueType('SEC', 'Selenocysteine', 'U'),
    SER: new ResidueType('SER', 'Serine', 'S'),
    THR: new ResidueType('THR', 'Threonine', 'T'),
    TRP: new ResidueType('TRP', 'Tryptophan', 'W'),
    TYR: new ResidueType('TYR', 'Tyrosine', 'Y'),
    VAL: new ResidueType('VAL', 'Valine', 'V'),
    A: new ResidueType('A', 'Adenine', 'A'),
    C: new ResidueType('C', 'Cytosine', 'C'),
    G: new ResidueType('G', 'Guanine', 'G'),
    I: new ResidueType('I', 'Inosine', 'I'),
    T: new ResidueType('T', 'Thymine', 'T'),
    U: new ResidueType('U', 'Uracil', 'U'),
    DA: new ResidueType('DA', 'Adenine', 'A'),
    DC: new ResidueType('DC', 'Cytosine', 'C'),
    DG: new ResidueType('DG', 'Guanine', 'G'),
    DI: new ResidueType('DI', 'Inosine', 'I'),
    DT: new ResidueType('DT', 'Thymine', 'T'),
    DU: new ResidueType('DU', 'Uracil', 'U'),
    '+A': new ResidueType('+A', 'Adenine', 'A'),
    '+C': new ResidueType('+C', 'Cytosine', 'C'),
    '+G': new ResidueType('+G', 'Guanine', 'G'),
    '+I': new ResidueType('+I', 'Inosine', 'I'),
    '+T': new ResidueType('+T', 'Thymine', 'T'),
    '+U': new ResidueType('+U', 'Uracil', 'U'),
    WAT: new ResidueType('WAT', 'Water', ''),
    H2O: new ResidueType('H2O', 'Water', ''),
    HOH: new ResidueType('HOH', 'Water', ''),
    DOD: new ResidueType('DOD', 'Water', ''),
    UNK: new ResidueType('UNK', 'Unknown', ''),
    UNL: new ResidueType('UNL', 'Unknown Ligand', '')
    /* eslint-enable no-magic-numbers */
  }))();

  /**
   * Enumeration of residue flag values.
   *
   * @enum {number}
   * @readonly
   */
  static Flags = {
    // Amino acids
    /** Amino acid residue */
    PROTEIN: 0x0001,
    /** Basic amino acid residue */
    BASIC: 0x0002,
    /** Acidic amino acid residue */
    ACIDIC: 0x0004,
    /** Polar uncharged side chain amino acid residue */
    POLAR: 0x0008,
    /** Non-polar hydrophobic side chain amino acid residue */
    NONPOLAR: 0x0010,
    /** Aromatic amino acid residue */
    AROMATIC: 0x0020,
    // Nucleic acids

    /** Nucleic residue */
    NUCLEIC: 0x0100,
    /** Purine nucleic residue */
    PURINE: 0x0200,
    /** Pyrimidine nucleic residue */
    PYRIMIDINE: 0x0400,
    /** DNA */
    DNA: 0x0800,
    /** RNA */
    RNA: 0x1000,
    /** Water */
    WATER: 0x10000
  };
}

// Flag combinations
function _addFlag(flag, list) {
  for (let i = 0, n = list.length; i < n; ++i) {
    const res = ResidueType.StandardTypes[list[i]];
    if (res) {
      res.flags |= flag;
    }
  }
}
const {
  Flags
} = ResidueType;
_addFlag(Flags.WATER, ['WAT', 'H2O', 'HOH', 'DOD']);
_addFlag(Flags.PROTEIN, ['ALA', 'ARG', 'ASN', 'ASP', 'CYS', 'GLY', 'GLU', 'GLN', 'HIS', 'ILE', 'LEU', 'LYS', 'MET', 'PHE', 'PRO', 'PYL', 'SEC', 'SER', 'THR', 'TRP', 'TYR', 'VAL']);
_addFlag(Flags.BASIC, ['ARG', 'HIS', 'LYS']);
_addFlag(Flags.ACIDIC, ['ASP', 'GLU']);
_addFlag(Flags.POLAR, ['ASN', 'CYS', 'GLN', 'SER', 'THR', 'TYR']);
_addFlag(Flags.NONPOLAR, ['ALA', 'ILE', 'LEU', 'MET', 'PHE', 'PRO', 'TRP', 'VAL', 'GLY']);
_addFlag(Flags.AROMATIC, ['PHE', 'TRP', 'TYR']);
_addFlag(Flags.NUCLEIC, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I', 'C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);
_addFlag(Flags.PURINE, ['A', 'G', 'I', 'DA', 'DG', 'DI', '+A', '+G', '+I']);
_addFlag(Flags.PYRIMIDINE, ['C', 'T', 'U', 'DC', 'DT', 'DU', '+C', '+T', '+U']);
_addFlag(Flags.DNA, ['DA', 'DG', 'DI', 'DC', 'DT', 'DU']);
_addFlag(Flags.RNA, ['A', 'G', 'I', 'C', 'T', 'U']);
// Table of kdHydrophobicity
const hydro = {
  ILE: 4.5,
  VAL: 4.2,
  LEU: 3.8,
  PHE: 2.8,
  CYS: 2.5,
  MET: 1.9,
  ALA: 1.8,
  GLY: -0.4,
  THR: -0.7,
  SER: -0.8,
  TRP: -0.9,
  TYR: -1.3,
  PRO: -1.6,
  HIS: -3.2,
  GLU: -3.5,
  GLN: -3.5,
  ASP: -3.5,
  ASN: -3.5,
  LYS: -3.9,
  ARG: -4.5
};
function _addParam(param, list) {
  const keys = Object.keys(list);
  for (let i = 0, n = keys.length; i < n; ++i) {
    const key = keys[i];
    const value = list[key];
    ResidueType.StandardTypes[key][param] = value;
  }
}
_addParam('hydrophobicity', hydro);
/* harmony default export */ const chem_ResidueType = (ResidueType);
;// CONCATENATED MODULE: ./src/chem/Chain.js




/**
 * Residues in chain are either amino acid either nucleic acid (and water)
 * There might be some modified/mutated residues, which type could not be determined by their name (nucleic or amino); In this
 * case firstly program definites the chain type (by well-known residues) and then definites modified/mutated residues
 */
const ChainType = {
  UNKNOWN: 0,
  PROTEIN: 1,
  NUCLEIC: 2
};

/**
 * Residue chain.
 *
 * @param {Complex} complex - Molecular complex this chain belongs to.
 * @param {string} name - One character identifier (usually space, A-Z, 0-9, or a-z).
 *
 * @exports Chain
 * @constructor
 */
class Chain {
  constructor(complex, name) {
    this._complex = complex;
    this._name = name;
    this._mask = 1 | 0;
    this._index = -1;
    this._residues = [];
    this.minSequence = Number.POSITIVE_INFINITY;
    this.maxSequence = Number.NEGATIVE_INFINITY;
  }
  getComplex() {
    return this._complex;
  }
  getName() {
    return this._name;
  }
  getResidues() {
    return this._residues;
  }
  _determineType() {
    const residues = this._residues;
    const {
      PROTEIN,
      NUCLEIC
    } = chem_ResidueType.Flags;
    this.type = ChainType.UNKNOWN;
    for (let i = 0, n = residues.length; i < n; ++i) {
      const {
        flags
      } = residues[i]._type;
      if ((flags & NUCLEIC) !== 0) {
        this.type = ChainType.NUCLEIC;
        break;
      } else if ((flags & PROTEIN) !== 0) {
        this.type = ChainType.PROTEIN;
        break;
      }
    }
  }

  /**
   * Finds thre residue with specified sequence number and inserion code
   * @param {Number} seqNum sequence number
   * @param {string} iCode insertion code
   * @returns {*} Residue or null if not found
   */
  findResidue(seqNum, iCode) {
    const residues = this._residues;
    for (let i = 0, n = residues.length; i < n; ++i) {
      const res = residues[i];
      if (res._sequence === seqNum && res._icode === iCode) {
        return [res, i];
      }
    }
    return null;
  }
  _finalize() {
    this._determineType();
    const residues = this._residues;
    let prev = null;
    for (let i = 0, n = residues.length; i < n; ++i) {
      const next = i + 1 < n ? residues[i + 1] : null;
      const curr = residues[i];
      // TODO: skip invalid residues
      if (true /* curr._isValid */) {
        // eslint-disable-line no-constant-condition
        curr._finalize2(prev, next, this.type === ChainType.NUCLEIC);
        prev = curr;
      }
    }

    // fix very first wing
    if (residues.length > 1 && residues[1]._wingVector) {
      const p = residues[1]._wingVector;
      residues[0]._wingVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(p.x, p.y, p.z);
    } else if (residues.length > 0) {
      residues[0]._wingVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0);
    }
  }
  updateToFrame(frameData) {
    const residues = this._residues;
    let prev = null;
    let prevData = null;
    const frameRes = frameData._residues;
    const n = residues.length;
    function getAtomPos(atom) {
      return frameData.getAtomPos(atom.index);
    }
    for (let i = 0; i < n; ++i) {
      const curr = residues[i];
      const currData = frameRes[curr._index];
      const nextRes = i + 1 < n ? residues[i + 1] : null;
      curr._innerFinalize(prev, prevData, nextRes, currData, this.type === ChainType.NUCLEIC, getAtomPos);
      prev = curr;
      prevData = currData;
    }
    frameRes[residues[0]._index]._wingVector = n > 1 ? frameRes[residues[1]._index]._wingVector : new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0);
  }

  /**
   * Create a new residue.
   *
   * @param {string} name - Residue name.
   * @param {number} sequence - Residue sequence number.
   * @param {string} iCode - Insertion code.
   * @returns {Residue} - Newly created residue instance.
   */
  addResidue(name, sequence, iCode) {
    let type = this._complex.getResidueType(name);
    if (type === null) {
      type = this._complex.addResidueType(name);
    }
    const residue = new chem_Residue(this, type, sequence, iCode);
    this._complex.addResidue(residue);
    this._residues.push(residue);
    if (type.flags & (chem_ResidueType.Flags.NUCLEIC | chem_ResidueType.Flags.PROTEIN)) {
      if (this.maxSequence < sequence) {
        this.maxSequence = sequence;
      }
      if (this.minSequence > sequence) {
        this.minSequence = sequence;
      }
    }
    return residue;
  }
  getResidueCount() {
    return this._residues.length;
  }
  forEachResidue(process) {
    const residues = this._residues;
    for (let i = 0, n = residues.length; i < n; ++i) {
      process(residues[i]);
    }
  }
  collectMask() {
    let mask = 0xffffffff;
    const residues = this._residues;
    for (let i = 0, n = residues.length; i < n; ++i) {
      mask &= residues[i]._mask;
    }
    this._mask = mask;
  }
}
/* harmony default export */ const chem_Chain = (Chain);
;// CONCATENATED MODULE: ./src/chem/StructuralElement.js


/** An element of protein secondary structure. */
class StructuralElement {
  /**
   * Create a secondary structural element of the specified type.
   *
   * @param {StructuralElement.Type} type Secondary structure type.
   * @param {Residue} init Initial residue.
   * @param {Residue} term Terminal residue.
   */
  constructor(type, init, term) {
    /**
     * Secondary structure type.
     * @type {StructuralElement.Type}
     */
    this.type = type;
    /**
     * Generic secondary structure type.
     * @type {StructuralElement.Generic}
     */
    this.generic = StructuralElement.genericByType[this.type] || 'loop';
    /**
     * Initial residue.
     * @type Residue
     */
    this.init = init;
    /**
     * Terminal residue.
     * @type Residue
     */
    this.term = term;
  }

  /**
   * An internal method for making a final pass over the complex to set all required references.
   *
   * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
   * Just copying it as-is right now and hoping for the best.
   *
   * @param {object} serialAtomMap A dictionary of atoms
   * @param {object} residueHash A dictionary of hashed residues to check.
   * @param {Complex} complex The molecular complex this element belongs to.
   */
  _finalize(serialAtomMap, residueHash, complex) {
    if (this.init instanceof chem_Residue && this.term instanceof chem_Residue) {
      return;
    }

    // Link all intermediate residues to this structural element
    const start = complex.splitUnifiedSerial(this.init);
    const end = complex.splitUnifiedSerial(this.term);
    for (let chainId = start.chain; chainId <= end.chain; chainId++) {
      for (let serialId = start.serial; serialId <= end.serial; serialId++) {
        for (let {
          iCode
        } = start; iCode <= end.iCode; iCode++) {
          const hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);
          if (residueHash[hashCode]) {
            residueHash[hashCode]._secondary = this;
          }
        }
      }
    }

    // Replace unfined serials by objects
    this.init = residueHash[this.init];
    this.term = residueHash[this.term];
  }
}

/**
 * Specific type of a secondary structural element.
 * @enum {string}
 * @see StructuralElement.Generic
 */
StructuralElement.Type = {
  /** A strand of a [beta-sheet](https://en.wikipedia.org/wiki/Beta_sheet). */
  STRAND: 'E',
  /** An isolated beta-bridge (too small for a beta-sheet). */
  BRIDGE: 'B',
  /** A [3/10 helix](https://en.wikipedia.org/wiki/310_helix) (hydrogen bonding is 3 residues apart). */
  HELIX_310: 'G',
  /** An [alpha-helix](https://en.wikipedia.org/wiki/Alpha_helix) (hydrogen bonding is 4 residues apart). */
  HELIX_ALPHA: 'H',
  /** A [pi-helix](https://en.wikipedia.org/wiki/Pi_helix) (hydrogen bonding is 5 residues apart). */
  HELIX_PI: 'I',
  /** A generic helix of unspecified bonding distance. */
  HELIX: 'X',
  /** An isolated 3/10-like helical turn. */
  TURN_310: '3',
  /** An isolated alpha-like helical turn. */
  TURN_ALPHA: '4',
  /** An isolated pi-like helical turn. */
  TURN_PI: '5',
  /** An isolated helical [turn](https://en.wikipedia.org/wiki/Turn_(biochemistry)) of unspecified bonding distance. */
  TURN: 'T',
  /** A bend (a region of high curvature). */
  BEND: 'S',
  /** Just a protein section with no particular conformation. */
  COIL: 'C'
};

/**
 * Generic type of a secondary structural element.
 * @enum {string}
 * @see StructuralElement.Type
 */
StructuralElement.Generic = {
  /** A strand of a sheet. */
  STRAND: 'strand',
  /** A helix. */
  HELIX: 'helix',
  /** Just a protein section with no particular conformation. */
  LOOP: 'loop'
};
const StructuralElementType = StructuralElement.Type;
const StructuralElementGeneric = StructuralElement.Generic;

/**
 * A mapping from specific types to generic ones.
 * @type {Object<StructuralElement.Type, StructuralElement.Generic>}
 */
StructuralElement.genericByType = {
  [StructuralElementType.STRAND]: StructuralElementGeneric.STRAND,
  [StructuralElementType.HELIX_310]: StructuralElementGeneric.HELIX,
  [StructuralElementType.HELIX_ALPHA]: StructuralElementGeneric.HELIX,
  [StructuralElementType.HELIX_PI]: StructuralElementGeneric.HELIX,
  [StructuralElementType.HELIX]: StructuralElementGeneric.HELIX
};
/* harmony default export */ const chem_StructuralElement = (StructuralElement);
;// CONCATENATED MODULE: ./src/chem/Helix.js

const Helix_StructuralElementType = chem_StructuralElement.Type;
const typeByPDBHelixClass = {
  1: Helix_StructuralElementType.HELIX_ALPHA,
  3: Helix_StructuralElementType.HELIX_PI,
  5: Helix_StructuralElementType.HELIX_310
};

/**
 * Helical secondary structure of a protein.
 * @extends StructuralElement
 */
class Helix extends chem_StructuralElement {
  /**
   * Create a helix.
   *
   * @param {number} helixClass A helix class according to the
   *   [PDB Format](http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX).
   * @param {Residue} init Initial residue.
   * @param {Residue} term Terminal residue.
   * @param {number} serial Serial number of the helix (see PDB Format).
   * @param {string} name Helix identifier (see PDB Format).
   * @param {string} comment Comment about this helix (see PDB Format).
   * @param {number} length Length of this helix, in residues (see PDB Format).
   */
  constructor(helixClass, init, term, serial, name, comment, length) {
    super(typeByPDBHelixClass[helixClass] || chem_StructuralElement.Type.HELIX, init, term);

    /**
     * Serial number of the helix (see PDB Format).
     * @type {number}
     */
    this.serial = serial;
    /**
     * Helix identifier (see PDB Format).
     * @type {string}
     */
    this.name = name;
    /**
     * Comment about this helix (see PDB Format).
     * @type {string}
     */
    this.comment = comment;
    /**
     * Length of this helix, in residues (see PDB Format).
     * @type {number}
     */
    this.length = length;
  }
}
/* harmony default export */ const chem_Helix = (Helix);
;// CONCATENATED MODULE: ./src/chem/Strand.js


/**
 * A single strand of a sheet in a protein secondary structure.
 * @extends StructuralElement
 */
class Strand extends chem_StructuralElement {
  /**
   * Create a strand.
   *
   * @param {Sheet} sheet Parent sheet this strand belongs to.
   * @param {Residue} init Initial residue.
   * @param {Residue} term Terminal residue.
   * @param {number} sense Sense of strand with respect to previous strand in the sheet.
   *   - 0 if the first strand,
   *   - 1 if parallel, and
   *   - -1 if anti-parallel.
   * @param {Atom} atomCur Atom in current strand (see PDB Format).
   * @param {Atom} atomPrev Atom in previous strand (see PDB Format).
   */
  constructor(sheet, init, term, sense, atomCur, atomPrev) {
    super(chem_StructuralElement.Type.STRAND, init, term);

    /**
     * Parent sheet this strand belongs to.
     * @type {Sheet}
     */
    this.sheet = sheet;
    /**
     * Sense of strand with respect to previous strand in the sheet.
     * - 0 if the first strand,
     * - 1 if parallel, and
     * - -1 if anti-parallel.
     * @type {number}
     */
    this.sense = sense;
    /**
     * Atom in current strand (see PDB Format).
     * @type {Atom}
     */
    this.atomCur = atomCur;
    /**
     * Atom in previous strand (see PDB Format).
     * @type {Atom}
     */
    this.atomPrev = atomPrev;
  }

  /**
   * An internal method for making a final pass over the complex to set all required references.
   *
   * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
   * Just copying it as-is right now and hoping for the best.
   *
   * @param {object} serialAtomMap A dictionary of atoms
   * @param {object} residueHash A dictionary of hashed residues to check.
   * @param {Complex} complex The molecular complex this element belongs to.
   *
   * @override
   */
  _finalize(serialAtomMap, residueHash, complex) {
    super._finalize(serialAtomMap, residueHash, complex);
    let as = this.atomCur;
    if (as !== null && !Number.isNaN(as)) {
      this.atomCur = serialAtomMap[as];
    }
    as = this.atomPrev;
    if (as !== null && !Number.isNaN(as)) {
      this.atomPrev = serialAtomMap[as];
    }
  }
}
/* harmony default export */ const chem_Strand = (Strand);
;// CONCATENATED MODULE: ./src/chem/Sheet.js


/**
 * Sheet secondary structure of a protein.
 *
 * @param {string} name -
 * @param {number} width -
 *
 * @exports Sheet
 * @constructor
 */
class Sheet {
  constructor(name, width) {
    this._name = name;
    this._width = width;
    this._strands = [];
  }

  // Getters and setters
  getName() {
    return this._name;
  }
  getWidth() {
    return this._width;
  }
  addStrand(strand) {
    this._strands.push(strand);
    this._width = this._strands.length;
  }
  addEmptyStrand() {
    this._strands.push(new chem_Strand(null, null, null, null, null, null));
  }
  _finalize(serialAtomMap, residueHash, complex) {
    const s = this._strands;
    for (let i = 0, n = s.length; i < n; ++i) {
      s[i]._finalize(serialAtomMap, residueHash, complex);
    }
    if (!this._width) {
      this._width = s.length;
    }
    if (s.length !== this._width) {
      throw new Error(`Sheet ${this._name} is inconsistent.`);
    }
  }
}
/* harmony default export */ const chem_Sheet = (Sheet);
;// CONCATENATED MODULE: ./src/chem/SGroup.js


/**
 * Atom measurements.
 *
 * @param {string} id              - SGroup id
 * @param {string} name            - Name of the group
 * @param {THREE.Vector3} position - Registered coordinates
 * @param {array} atoms            - Atoms group consists of
 * @param {object} saveNode        - XML node from file for saving
 *
 * @exports SGroup
 * @constructor
 */
class SGroup {
  constructor(id, name, position, atoms, saveNode) {
    this._id = id;
    this._name = name;
    this._position = position || new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._atoms = atoms || [];
    this._charge = 0; // default group charge
    this._repeat = 1; // how many times group repeated: always > 0
    this._center = null;
    this.xmlNodeRef = saveNode || null;
  }

  /**
   * Get atom full name.
   * @returns {string} Atom full name.
   */
  getName() {
    return this._name;
  }
  getPosition() {
    return this._position;
  }
  getCentralPoint() {
    return this._center;
  }
  _rebuildSGroupOnAtomChange() {
    const nLimon = 100000000;
    if (this._center === null) {
      return; // nothing to do if we are not relative
    }
    const bLow = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(nLimon, nLimon, nLimon);
    const bHight = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-nLimon, -nLimon, -nLimon);
    for (let j = 0, n = this._atoms.length; j < n; j++) {
      const aPos = this._atoms[j].position;
      bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
      bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
    }
    this._center.addVectors(bLow, bHight);
    this._center.multiplyScalar(0.5);
  }
}
/* harmony default export */ const chem_SGroup = (SGroup);
// EXTERNAL MODULE: ./src/utils/SelectionParser.js
var SelectionParser = __webpack_require__(99);
;// CONCATENATED MODULE: ./src/chem/selectors/selectArgs.js


//----------------------------------------------------------------------------
class Range {
  constructor(min, max) {
    this.min = min;
    this.max = typeof max === 'undefined' ? min : max;
  }
  includes(value) {
    return this.min <= value && value <= this.max;
  }
  toString() {
    const {
      min,
      max
    } = this;
    return min === max ? String(min) : [min, max].join(':');
  }
  toJSON() {
    return [this.min, this.max];
  }
}

// ////////////////////////////////////////////////////////////////////////////

class List {
  constructor(arg) {
    if (arg instanceof this.constructor) {
      // delegate construction to a different class
      // eslint-disable-next-line no-constructor-return
      return arg;
    }
    if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }
  append(value) {
    const values = this._values;
    values[values.length] = value;
    return this;
  }
  remove(value) {
    const values = this._values;
    const index = values.indexOf(value);
    if (index >= 0) {
      values.splice(index, 1);
    }
    return this;
  }
  toString() {
    return this._values.join(',');
  }
  toJSON() {
    const values = this._values;
    const result = [];
    for (let i = 0, n = values.length; i < n; ++i) {
      const value = values[i];
      result[i] = value.toJSON ? value.toJSON() : value;
    }
    return result;
  }
}

//----------------------------------------------------------------------------

class RangeList extends List {
  includes(value) {
    const list = this._values;
    for (let i = 0, n = list.length; i < n; ++i) {
      if (list[i].includes(value)) {
        return true;
      }
    }
    return false;
  }
}

//----------------------------------------------------------------------------

const valuesArray = [];
class ValueList extends List {
  constructor(arg, upperOnly) {
    const list = super(arg);
    if (upperOnly) {
      this.upperOnly = true;
      const values = list._values;
      for (let i = 0, n = values.length; i < n; ++i) {
        const value = values[i];
        if (typeof value === 'string') {
          values[i] = value.toUpperCase();
        }
      }
    } else {
      this.upperOnly = false;
    }
    // return constructed object
    // eslint-disable-next-line no-constructor-return
    return list;
  }
  includes(value) {
    // we do not convert to upper case here for perfomance reasons
    // if list is upper case only, value must be converted before it is sent up to  here
    return this._values.indexOf(value) !== -1;
  }
  toString() {
    // Quote values that are not correct identifiers
    const values = this._values;
    valuesArray.length = 0;
    for (let i = 0, n = values.length; i < n; ++i) {
      valuesArray[i] = utils.correctSelectorIdentifier(String(values[i]));
    }
    return valuesArray.join(',');
  }
  _validate(value) {
    return this.upperOnly && typeof value === 'string' ? value.toUpperCase() : value;
  }
  append(value) {
    super.append(this._validate(value));
    return this;
  }
  remove(value) {
    super.remove(this._validate(value));
    return this;
  }
}

;// CONCATENATED MODULE: ./src/chem/selectors/selectorsBase.js


/** Base class for atom selectors. */
class Selector {
  toString() {
    return this.keyword;
  }
  toJSON() {
    return [this.name];
  }
}
Selector.prototype.name = 'Error';
Selector.prototype.keyword = 'error';

/** Base class for list-based atom selectors. */
class ListSelector extends Selector {
  constructor(list) {
    super();
    this.list = list;
  }
  toString() {
    return `${this.keyword} ${this.list}`;
  }
  toJSON() {
    return [this.name, this.list.toJSON()];
  }
}
class RangeListSelector extends ListSelector {
  constructor(arg) {
    super(new RangeList(arg));
  }
}
class ValueListSelector extends ListSelector {
  constructor(arg, caseSensitive) {
    super(new ValueList(arg, !caseSensitive));
  }
}
class NoneSelector extends Selector {
  includesAtom(_atom) {
    return false;
  }
}
NoneSelector.prototype.name = 'None';
NoneSelector.prototype.keyword = 'none';
class AllSelector extends Selector {
  includesAtom(_atom) {
    return true;
  }
}
AllSelector.prototype.name = 'All';
AllSelector.prototype.keyword = 'all';

;// CONCATENATED MODULE: ./src/chem/selectors/selectOps.js


//----------------------------------------------------------------------------
// Operators
//----------------------------------------------------------------------------
const none = new NoneSelector();
class PrefixOperator extends Selector {
  constructor(rhs) {
    super();
    this.rhs = rhs || none;
  }
  toString() {
    const rhs = this.rhs.priority && this.rhs.priority > this.priority ? `(${this.rhs})` : this.rhs;
    return `${this.keyword} ${rhs}`;
  }
  toJSON() {
    return [this.name, this.rhs.toJSON()];
  }
}
PrefixOperator.prototype.priority = 1;
class InfixOperator extends Selector {
  constructor(lhs, rhs) {
    super();
    this.lhs = lhs || none;
    this.rhs = rhs || none;
  }
  toString() {
    const lhs = this.lhs.priority && this.lhs.priority > this.priority ? `(${this.lhs})` : this.lhs;
    const rhs = this.rhs.priority && this.rhs.priority > this.priority ? `(${this.rhs})` : this.rhs;
    return `${lhs} ${this.keyword} ${rhs}`;
  }
  toJSON() {
    return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
  }
}
InfixOperator.prototype.priority = 1000;

;// CONCATENATED MODULE: ./src/chem/selectors.js






const keywords = {};

//----------------------------------------------------------------------------
// Named selectors
//----------------------------------------------------------------------------

function defineSelector(name, SelectorClass) {
  const keyword = name.toLowerCase();
  SelectorClass.prototype.keyword = keyword;
  SelectorClass.prototype.name = name;
  const factory = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new SelectorClass(...args);
  };
  factory.SelectorClass = SelectorClass;
  keywords[keyword] = factory;
  return SelectorClass;
}
defineSelector('Serial', class SerialSelector extends RangeListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.serial);
  }
});
defineSelector('Name', class NameSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.name);
  }
});
defineSelector('AltLoc', class AltLocSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(String.fromCharCode(atom.location));
  }
});
defineSelector('Elem', class ElemSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.element.name);
  }
});
defineSelector('Residue', class ResidueSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.residue._type._name);
  }
});
defineSelector('Sequence', class SequenceSelector extends RangeListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.residue._sequence);
  }
});
defineSelector('ICode', class ICodeSelector extends ValueListSelector {
  constructor(arg) {
    super(arg, true);
  }
  includesAtom(atom) {
    return this.list.includes(atom.residue._icode);
  }
});
defineSelector('ResIdx', class ResIdxSelector extends RangeListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.residue._index);
  }
});
defineSelector('Chain', class ChainSelector extends ValueListSelector {
  constructor(arg) {
    super(arg, true);
  }
  includesAtom(atom) {
    return this.list.includes(atom.residue._chain._name);
  }
});
defineSelector('Hetatm', class HetatmSelector extends Selector {
  includesAtom(atom) {
    return atom.het;
  }
});
defineSelector('PolarH', class PolarHSelector extends Selector {
  includesAtom(atom) {
    return (atom.flags & chem_Atom.Flags.NONPOLARH) === chem_Atom.Flags.HYDROGEN;
  }
});
defineSelector('NonPolarH', class NonPolarHSelector extends Selector {
  includesAtom(atom) {
    return (atom.flags & chem_Atom.Flags.NONPOLARH) === chem_Atom.Flags.NONPOLARH;
  }
});
defineSelector('All', AllSelector);
defineSelector('None', NoneSelector);
const NULL_SELECTOR = keywords.none();

//----------------------------------------------------------------------------
// Named operators
//----------------------------------------------------------------------------

function defineOperator(name, priority, OperatorClass) {
  OperatorClass.prototype.priority = priority;
  return defineSelector(name, OperatorClass);
}
defineOperator('Not', 1, class NotOperator extends PrefixOperator {
  includesAtom(atom) {
    return !this.rhs.includesAtom(atom);
  }
});
defineOperator('And', 2, class AndOperator extends InfixOperator {
  includesAtom(atom) {
    return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
  }
});
defineOperator('Or', 3, class OrOperator extends InfixOperator {
  includesAtom(atom) {
    return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
  }
});

//----------------------------------------------------------------------------
// Flag selectors
//----------------------------------------------------------------------------

function byResidueTypeFlag(flag, name) {
  return defineSelector(name, class extends Selector {
    includesAtom(atom) {
      return (atom.residue._type.flags & flag) !== 0;
    }
  });
}
byResidueTypeFlag(chem_ResidueType.Flags.PROTEIN, 'Protein');
byResidueTypeFlag(chem_ResidueType.Flags.BASIC, 'Basic');
byResidueTypeFlag(chem_ResidueType.Flags.ACIDIC, 'Acidic');
byResidueTypeFlag(chem_ResidueType.Flags.BASIC | chem_ResidueType.Flags.ACIDIC, 'Charged');
byResidueTypeFlag(chem_ResidueType.Flags.POLAR, 'Polar');
byResidueTypeFlag(chem_ResidueType.Flags.NONPOLAR, 'NonPolar');
byResidueTypeFlag(chem_ResidueType.Flags.AROMATIC, 'Aromatic');
byResidueTypeFlag(chem_ResidueType.Flags.NUCLEIC, 'Nucleic');
byResidueTypeFlag(chem_ResidueType.Flags.PURINE, 'Purine');
byResidueTypeFlag(chem_ResidueType.Flags.PYRIMIDINE, 'Pyrimidine');
byResidueTypeFlag(chem_ResidueType.Flags.WATER, 'Water');

//----------------------------------------------------------------------------
const selectors = Object.create(keywords);
selectors.Selector = Selector;
selectors.RangeListSelector = RangeListSelector;
selectors.ValueListSelector = ValueListSelector;
selectors.Range = Range;
selectors.RangeList = RangeList;
selectors.ValueList = ValueList;
selectors.PrefixOperator = PrefixOperator;
selectors.InfixOperator = InfixOperator;
selectors.Context = Object.create({});
selectors.GetSelector = function (key) {
  if (!selectors.Context.hasOwnProperty(key)) {
    const exc = {
      message: `selector ${key} is not registered`
    };
    throw exc;
  }
  return selectors.Context[key] || NULL_SELECTOR;
};
selectors.ClearContext = function () {
  Object.keys(selectors.Context).forEach(k => {
    delete selectors.Context[k];
  });
};
selectors.keyword = function (key) {
  return keywords[key.toLowerCase()] || keywords.none;
};
selectors.parse = function (str) {
  const res = {};
  try {
    res.selector = SelectionParser.parser.parse(str);
  } catch (e) {
    res.selector = NULL_SELECTOR;
    res.error = e.message;
  }
  return res;
};
SelectionParser.parser.yy = selectors;
SelectionParser.parser.yy.parseError = SelectionParser.parser.parseError; // workaround for incorrect JISON parser generator for AMD module

/* harmony default export */ const chem_selectors = (selectors);
;// CONCATENATED MODULE: ./src/chem/BiologicalUnit.js



/**
 * Basic biological unit class.
 *
 * @exports BiologicalUnit
 * @constructor
 */
class BiologicalUnit {
  constructor(complex) {
    this._complex = complex;
    this._selector = chem_selectors.keyword('All')();
    this._boundaries = {
      boundingBox: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(),
      boundingSphere: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere()
    };
  }
  computeBoundaries() {
    const atoms = this._complex._atoms;
    const n = atoms.length;
    const selector = this._selector;
    const {
      boundingBox
    } = this._boundaries;
    boundingBox.makeEmpty();
    if (n === 1) {
      boundingBox.expandByPoint(atoms[0].position);
      const bbc = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      boundingBox.getCenter(bbc);
      const s = 2 * atoms[0].element.radius;
      boundingBox.setFromCenterAndSize(bbc, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(s, s, s));
    } else {
      for (let i = 0; i < n; ++i) {
        if (selector.includesAtom(atoms[i])) {
          boundingBox.expandByPoint(atoms[i].position);
        }
      }
    }

    // Build bounding sphere
    let radiusSquared = 0.0;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    boundingBox.getCenter(center);
    if (n === 1) {
      this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
    } else {
      for (let i = 0; i < n; ++i) {
        if (!selector.includesAtom(atoms[i])) {
          continue;
        }
        const pos = atoms[i].position;
        const lengthSquared = center.distanceToSquared(pos);
        if (radiusSquared < lengthSquared) {
          radiusSquared = lengthSquared;
        }
      }
      this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
    }
  }
  getTransforms() {
    return [];
  }
  getSelector() {
    return this._selector;
  }
  getBoundaries() {
    return this._boundaries;
  }
  finalize() {}
}
/* harmony default export */ const chem_BiologicalUnit = (BiologicalUnit);
;// CONCATENATED MODULE: ./src/chem/Assembly.js




/**
 * Biological assembly.
 *
 * @exports Assembly
 * @constructor
 */

class Assembly extends chem_BiologicalUnit {
  constructor(complex) {
    super(complex);
    this.chains = [];
    this.matrices = [];
  }
  computeBoundaries() {
    super.computeBoundaries();
    // fix up the boundaries
    const {
      matrices
    } = this;
    const oldCenter = this._boundaries.boundingSphere.center;
    const oldRad = this._boundaries.boundingSphere.radius;
    const boundingBox = this._boundaries.boundingBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
    boundingBox.makeEmpty();
    for (let i = 0, n = matrices.length; i < n; ++i) {
      boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i]));
    }
    const newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    boundingBox.getCenter(center);
    this._boundaries.boundingSphere = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere().set(center, newRad);
    boundingBox.max.addScalar(oldRad);
    boundingBox.min.subScalar(oldRad);
  }

  /**
   * Mark a chain as belonging to this biological assembly.
   * @param {string} chain - chain identifier, usually a single letter
   */
  addChain(chain) {
    this.chains[this.chains.length] = chain;
  }

  /**
   * Add a transformation matrix.
   * @param {THREE.Matrix4} matrix - transformation matrix
   */
  addMatrix(matrix) {
    this.matrices[this.matrices.length] = matrix;
  }
  getTransforms() {
    return this.matrices;
  }
  finalize() {
    if (this.chains.length > 0) {
      this._selector = chem_selectors.keyword('Chain')(this.chains);
    } else {
      this._selector = chem_selectors.keyword('None')();
    }
  }
}
/* harmony default export */ const chem_Assembly = (Assembly);
;// CONCATENATED MODULE: ./src/chem/Component.js
/**
 * This class represents connected component as a part of a complex.
 * WARNING! The whole component entity is build under the assumption that residues
 * are placed in the chains and complex in ascending order of indices
 *
 * @param {Complex} complex - Molecular complex this chain belongs to.
 *
 * @exports Component
 * @constructor
 */
class Component {
  constructor(complex) {
    this._complex = complex;
    this._index = -1;
    this._residueIndices = [];
    this._cycles = [];
    this._subDivs = [];
    this._residueCount = 0;
  }
  getResidues() {
    return this._complex._residues;
  }
  getResidueCount() {
    return this._residueCount;
  }
  forEachResidue(process) {
    const residues = this._complex._residues;
    const resIdc = this._residueIndices;
    for (let idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
      for (let idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
        process(residues[idx]);
      }
    }
  }
  setSubDivs(subDivs) {
    this._subDivs = subDivs;
    let curr = 0;
    const resIdc = [];
    let resCnt = 0;
    for (let i = 0, n = subDivs.length; i < n; ++i) {
      if (i === n - 1 || subDivs[i].end + 1 !== subDivs[i + 1].start) {
        const {
          start
        } = subDivs[curr];
        const {
          end
        } = subDivs[i];
        resIdc[resIdc.length] = {
          start,
          end
        };
        resCnt += end - start + 1;
        curr = i + 1;
      }
    }
    this._residueIndices = resIdc;
    this._residueCount = resCnt;
  }
  getComplex() {
    return this._complex;
  }
  forEachBond(process) {
    const bonds = this._complex._bonds;
    for (let i = 0, n = bonds.length; i < n; ++i) {
      const bond = bonds[i];
      if (bond._left.residue._component === this) {
        process(bond);
      }
    }
  }
  update() {
    this.forEachCycle(cycle => {
      cycle.update();
    });
  }
  forEachAtom(process) {
    this.forEachResidue(residue => {
      residue.forEachAtom(process);
    });
  }
  addCycle(cycle) {
    this._cycles.push(cycle);
  }
  forEachCycle(process) {
    const cycles = this._cycles;
    for (let i = 0, n = cycles.length; i < n; ++i) {
      process(cycles[i]);
    }
  }
  markResidues() {
    const self = this;
    self.forEachResidue(residue => {
      residue._component = self;
    });
  }
  _forEachSubChain(mask, process) {
    const residues = this._complex._residues;
    const subs = this._subDivs;
    for (let i = 0, n = subs.length; i < n; ++i) {
      for (let idx = subs[i].start, last = subs[i].end; idx <= last; ++idx) {
        const currRes = residues[idx];
        if (mask & currRes._mask && currRes._isValid) {
          let end = idx + 1;
          for (; end <= last; ++end) {
            const endRes = residues[end];
            if (!(mask & endRes._mask && endRes._isValid)) {
              break;
            }
          }
          process(i, idx, end - 1);
          idx = end;
        }
      }
    }
  }
  getMaskedSequences(mask) {
    const subs = [];
    let idx = 0;
    this._forEachSubChain(mask, (_subIdx, start, end) => {
      subs[idx++] = {
        start,
        end
      };
    });
    return subs;
  }
  getMaskedSubdivSequences(mask) {
    const subs = [];
    let currIdx = -1;
    let lastSubIdx = -1;
    const subDivs = this._subDivs;
    this._forEachSubChain(mask, (subIdx, start, end) => {
      if (lastSubIdx !== subIdx) {
        ++currIdx;
        subs[currIdx] = {
          arr: [],
          boundaries: subDivs[subIdx]
        };
        lastSubIdx = subIdx;
      }
      subs[currIdx].arr[subs[currIdx].arr.length] = {
        start,
        end
      };
    });
    return subs;
  }
}
/* harmony default export */ const chem_Component = (Component);
;// CONCATENATED MODULE: ./src/chem/AtomPairs.js

const cMaxPairsForHashCode = 32;
const cHashTableSize = 1024 * 1024;
const cNumbersPerPair = 4;
const cMaxNeighbours = 14;
const cInvalidVal = -1;
// 89237 is a large simple number, can be used for pseudo random hash code create
const cBigPrime = 89237;
class AtomPairs {
  constructor(maxPairsEstimate) {
    this.numPairs = 0;
    this.numMaxPairs = maxPairsEstimate;
    this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);
    for (let i = 0; i < maxPairsEstimate * cNumbersPerPair; i++) {
      this.intBuffer[i] = cInvalidVal;
    }
    this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);
    for (let i = 0; i < cHashTableSize * cMaxPairsForHashCode; i++) {
      this.hashBuffer[i] = cInvalidVal;
    }
  }

  /**
   * Destroy all pairs memory
   */
  destroy() {
    this.intBuffer = null;
    this.hashBuffer = null;
  }

  /**
   * Add pair of atoms to collection
   * @param {number} indexA - Index of the 1st vertex.
   * @param {number} indexB - Index of the 2nd vertex.
   */
  addPair(indexA, indexB) {
    const ia = indexA < indexB ? indexA : indexB;
    const ib = indexA > indexB ? indexA : indexB;
    const codeToAdd = ia + (ib << cMaxNeighbours);
    const hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
    let j = hashCode * cMaxPairsForHashCode;
    let apI = 0;
    for (; apI < cMaxPairsForHashCode; apI++) {
      const code = this.hashBuffer[j + apI];
      if (code === cInvalidVal) {
        break;
      }
      if (code === codeToAdd) {
        return false;
      }
    }
    // add this new hash code
    if (apI >= cMaxPairsForHashCode) {
      throw new Error('addPair: increase cMaxPairsForHashCode');
    }
    this.hashBuffer[j + apI] = codeToAdd;

    // actually add
    if (this.numPairs >= this.numMaxPairs) {
      throw new Error('addPair: increase num pairs');
    }
    j = this.numPairs * cNumbersPerPair;
    this.intBuffer[j] = ia;
    this.intBuffer[j + 1] = ib;
    this.intBuffer[j + 2] = codeToAdd;
    this.numPairs++;
    return true;
  }
}
/* harmony default export */ const chem_AtomPairs = (AtomPairs);
;// CONCATENATED MODULE: ./src/chem/AutoBond.js


const cProfileBondBuilder = false;
const cEstBondsMultiplier = 4;
const cSpaceCode = 32;
const cBondTolerance = 0.45;
const cVMDTolerance = 0.6;
const cBondRadInJMOL = true;
const cEpsilon = 0.001;

/**
 * Get radius used for building bonds.
 *
 * @param {Atom} atom - Atom object.
 * @returns {number} special value for bonding radius for this atom
 */
function _getBondingRadius(atom) {
  const {
    element
  } = atom;
  if (element) {
    return element.radiusBonding;
  }
  throw new Error('_getBondingRadius: Logic error.');
}
function _isAtomEligible(atom) {
  // build for all non-hetatm and for hetatm without bonds
  return !atom.isHet() || atom.bonds && atom.bonds.length === 0;
}

/**
 * Bond between atoms.
 *
 * @param {Complex} complex molecular complex

 * @exports AutoBond
 * @constructor
 */
class AutoBond {
  constructor(complex) {
    this._complex = complex;
    this._maxRad = 1.8;
    const bBox = this._complex.getDefaultBoundaries().boundingBox;
    this._vBoxMin = bBox.min.clone();
    this._vBoxMax = bBox.max.clone();
    this._pairCollection = null;
  }

  /**
   * Add existing pairs of connectors (from pdb file after its reading)
   * @returns {number} 0
   */
  _addExistingPairs() {
    const atoms = this._complex.getAtoms();
    const numAtoms = atoms.length;
    let aInd = 0;
    const collection = this._pairCollection;
    for (; aInd < numAtoms; aInd++) {
      const {
        bonds
      } = atoms[aInd];
      const numBondsForAtom = bonds.length;
      for (let bInd = 0; bInd < numBondsForAtom; bInd++) {
        const bond = bonds[bInd];
        const indTo = bond._left.index;
        if (indTo === aInd) {
          collection.addPair(aInd, bond._right.index);
        }
      } // for (b) all bonds in atom
    } // for (a)
    return 0;
  }
  _findPairs() {
    const vw = this._complex.getVoxelWorld();
    if (vw === null) {
      return;
    }
    const atoms = this._complex._atoms;
    const atomsNum = atoms.length;
    const self = this;
    let rA;
    let isHydrogenA;
    let posA;
    let locationA;
    let atomA;
    const processAtom = function (atomB) {
      if (isHydrogenA && atomB.isHydrogen()) {
        return;
      }
      const locationB = atomB.location;
      if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
        return;
      }
      const dist2 = posA.distanceToSquared(atomB.position);
      const rB = atomB.element.radiusBonding;
      const maxAcceptable = cBondRadInJMOL ? rA + rB + cBondTolerance : cVMDTolerance * (rA + rB);
      if (dist2 > maxAcceptable * maxAcceptable) {
        return;
      }
      if (dist2 < cEpsilon) {
        return;
      }
      self._pairCollection.addPair(atomA.index, atomB.index);
    };
    for (let i = 0; i < atomsNum; ++i) {
      atomA = atoms[i];
      if (!_isAtomEligible(atomA)) {
        continue;
      }
      rA = atomA.element.radiusBonding;
      isHydrogenA = atomA.isHydrogen();
      posA = atomA.position;
      locationA = atomA.location;
      vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
    }
  }
  _addPairs() {
    const atoms = this._complex._atoms;
    for (let i = 0, k = 0; i < this._pairCollection.numPairs; i++, k += 4) {
      const iA = this._pairCollection.intBuffer[k];
      const iB = this._pairCollection.intBuffer[k + 1];
      this._addPair(atoms[iA], atoms[iB]);
    }
  }
  _addPair(atomA, atomB) {
    const bondsA = atomA.bonds;
    const indexA = atomA.index;
    const indexB = atomB.index;
    for (let j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
      const bond = bondsA[j];
      if (bond._left.index === indexB || bond._right.index === indexB) {
        return;
      }
    }
    const left = indexA < indexB ? atomA : atomB;
    const right = indexA < indexB ? atomB : atomA;
    const newBond = this._complex.addBond(left, right, 0, chem_Bond.BondType.UNKNOWN, false);
    bondsA.push(newBond);
    atomB.bonds.push(newBond);
  }
  build() {
    if (cProfileBondBuilder) {
      console.time('Bonds Builder');
    }
    this._buildInner();
    if (cProfileBondBuilder) {
      console.timeEnd('Bonds Builder');
    }
  }
  _buildInner() {
    const atoms = this._complex._atoms;
    if (atoms.length < 2) {
      return;
    }
    if (atoms[0].index < 0) {
      throw new Error('AutoBond: Atoms in complex were not indexed.');
    }
    this._calcBoundingBox();
    this._pairCollection = new chem_AtomPairs(atoms.length * cEstBondsMultiplier);
    this._addExistingPairs();
    this._findPairs();
    this._addPairs();
  }
  _calcBoundingBox() {
    const atoms = this._complex._atoms;
    const nAtoms = atoms.length;
    let maxRad = _getBondingRadius(atoms[0]);
    for (let i = 1; i < nAtoms; ++i) {
      maxRad = Math.max(maxRad, _getBondingRadius(atoms[i]));
    }
    this._vBoxMax.addScalar(maxRad);
    this._vBoxMin.addScalar(-maxRad);
    this._maxRad = maxRad * 1.2;
  }
  destroy() {
    if (this._pairCollection) {
      this._pairCollection.destroy();
    }
  }
}
/* harmony default export */ const chem_AutoBond = (AutoBond);
;// CONCATENATED MODULE: ./src/chem/AromaticLoopsMarker.js



const cCrossThresh = 0.1;
const cAromaticType = chem_Bond.BondType.AROMATIC;
const cAromaticAtoms = [chem_Element.ByName.C.number, chem_Element.ByName.N.number
// Element.ByName.O.number,
// Element.ByName.S.number,
];

/** Conditions for bonds:
   *   - Cross product with each subsequent bond to add is collinear and point to the same direction
   *   - Each pair of a adjacent bonds belong to not more than one cycle
   *   - If there is more than one candidates we try them in ascending order of angle values
   */

const _coDirVectors = function () {
  const v1Tmp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const v2Tmp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const cp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (v1, v2) {
    v1Tmp.copy(v1).normalize();
    v2Tmp.copy(v2).normalize();
    cp.crossVectors(v1Tmp, v2Tmp);
    if (cp.length() > cCrossThresh) {
      return false;
    }
    // zero vector in out terms must be collinear to any
    return v1Tmp.dot(v2Tmp) >= 0;
  };
}();
function _insertAscending(arr, val) {
  let idx = 0;
  while (idx < arr.length && arr[idx] < val) {
    ++idx;
  }
  arr.splice(idx, 0, val);
}
function _anotherAtom(bond, currAtom) {
  return bond._left === currAtom ? bond._right : bond._left;
}
function _cosBetween(v1, v2) {
  const theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
  return external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.clamp(theta, -1, 1);
}
function _markAromatic(bond) {
  bond._type = cAromaticType;
}
class Cycle {
  constructor(atomsList) {
    this.atoms = atomsList;
    this.update();
  }
  update() {
    const {
      atoms
    } = this;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const nA = atoms.length;
    for (let j = 0; j < nA; ++j) {
      center.add(atoms[j].position);
    }
    center.multiplyScalar(1.0 / nA);
    this.center = center;
    this.radius = center.distanceTo(atoms[0].position.clone().lerp(atoms[1].position, 0.5));
  }
  forEachBond(process) {
    const {
      atoms
    } = this;
    const nA = atoms.length;
    let currAtom = atoms[0];
    let nextAtom;
    function checkBond(bond) {
      if (bond._left === nextAtom || bond._right === nextAtom) {
        process(bond);
      }
    }
    for (let i = 0; i < nA; ++i) {
      nextAtom = atoms[(i + 1) % nA];
      currAtom.forEachBond(checkBond);
      currAtom = nextAtom;
    }
  }
}
function _isAromatic(bond) {
  return bond._type === cAromaticType;
}
function _isPossibleAromatic(bond) {
  if (bond.type === cAromaticType) {
    return true;
  }
  const rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
  const leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
  return rightIdx !== -1 && leftIdx !== -1;
}
function _checkCycleSimple(cycle) {
  return cycle.length > 3;
}
function _checkCycleComplex(cycle) {
  console.assert(cycle.length > 2);
  return true;
}
class AromaticLoopsMarker {
  constructor(complex) {
    this._complex = complex;
    const bondsData = new Array(complex._bonds.length);
    const bondMarks = new Array(complex._bonds.length);
    for (let i = 0, n = bondsData.length; i < n; ++i) {
      bondsData[i] = [];
      bondMarks[i] = false;
    }
    this._bondsData = bondsData;
    this._bondMarks = bondMarks;
    this._resetCycles();
  }
  _resetCycles() {
    this._cycles = [];
    this._currIdx = -1;
  }
  _haveSameCycle(bondsData, bond1, bond2) {
    const arr1 = bondsData[bond1._index];
    const arr2 = bondsData[bond2._index];
    const n1 = arr1.length;
    const n2 = arr2.length;
    let i1 = 0;
    let i2 = 0;
    while (i1 < n1 && i2 < n2) {
      if (arr1[i1] === arr2[i2]) {
        return true;
      }
      if (arr1[i1] > arr2[i2]) {
        ++i2;
      } else {
        ++i1;
      }
    }
    return false;
  }
  _tryBond(prevBond, currRight, currDir) {
    const bondsOrder = [];
    const bondsData = this._bondsData;
    const currLeft = _anotherAtom(prevBond, currRight);
    const currVec = currRight.position.clone().sub(currLeft.position);
    const startAtomRef = this._currStart;
    const self = this;
    const bondMarks = this._bondMarks;
    let checkAromatic = this._checkBond;
    bondMarks[prevBond._index] = true;
    checkAromatic = checkAromatic === undefined ? _isAromatic : checkAromatic;
    currRight.forEachBond(newBond => {
      if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self._haveSameCycle(bondsData, prevBond, newBond)) {
        return;
      }
      const anotherAtom = _anotherAtom(newBond, currRight);
      const anotherVec = anotherAtom.position.clone().sub(currRight.position);
      const val = anotherAtom === startAtomRef ? -2.0 : 1 - _cosBetween(currVec, anotherVec);
      const newDir = anotherVec.cross(currVec);
      if (!_coDirVectors(newDir, currDir)) {
        return;
      }
      let idx = 0;
      while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
        ++idx;
      }
      bondsOrder.splice(idx, 0, {
        bond: newBond,
        val,
        dir: newDir
      });
    });
    for (let i = 0, n = bondsOrder.length; i < n; ++i) {
      const {
        bond
      } = bondsOrder[i];
      const newRight = bond._left === currRight ? bond._right : bond._left;
      if (newRight === startAtomRef) {
        ++this._currIdx;
        this._cycles.push([currRight]);
        bondMarks[prevBond._index] = false;
        return true;
      }
      if (this._tryBond(bond, newRight, bondsOrder[i].dir)) {
        _insertAscending(bondsData[bond._index], this._currIdx);
        this._cycles[this._currIdx].push(currRight);
        bondMarks[prevBond._index] = false;
        return true;
      }
    }
    bondMarks[prevBond._index] = false;
    return false;
  }
  _startCycle(bond) {
    // start from left to right
    this._currStart = bond._left;
    if (this._tryBond(bond, bond._right, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())) {
      _insertAscending(this._bondsData[bond._index], this._currIdx);
      this._cycles[this._currIdx].push(bond._left);
    }
  }
  _findLoops(checkBond, checkCycle) {
    this._checkBond = checkBond;
    const complex = this._complex;
    const self = this;
    complex.forEachComponent(component => {
      self._resetCycles();
      component.forEachBond(bond => {
        if (checkBond(bond)) {
          self._startCycle(bond);
        }
      });
      const cycles = self._cycles;
      for (let i = 0, n = cycles.length; i < n; ++i) {
        const cycle = cycles[i];
        if (!checkCycle(cycle)) {
          continue;
        }
        const newCycle = new Cycle(cycle);
        newCycle.forEachBond(_markAromatic);
        component.addCycle(newCycle);
      }
    });
  }
  markCycles() {
    this._findLoops(_isAromatic, _checkCycleSimple);
  }
  detectCycles() {
    this._findLoops(_isPossibleAromatic, _checkCycleComplex);
  }
}
/* harmony default export */ const chem_AromaticLoopsMarker = (AromaticLoopsMarker);
;// CONCATENATED MODULE: ./src/chem/VoxelWorld.js



/**
 * Calculate min & max radius of a sphere slice between zMin & zMax
 *
 * @param {Vector3} center - center of the sphere
 * @param {number} radius  - sphere radius
 * @param {number} zMin - lower bound of the slice
 * @param {number} zMax - upper bound of the slice
 */
function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
  const dzMin = zMin - center.z;
  const dzMax = zMax - center.z;
  const rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0.0));
  const rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0.0));
  const rMin = Math.min(rzMin, rzMax);
  let rMax;
  if (zMin <= center.z && zMax >= center.z) {
    // sphere's main diameter is inside slice
    rMax = radius;
  } else {
    rMax = Math.max(rzMin, rzMax);
  }
  return [rMin, rMax];
}

/**
 * Calculate min & max radius of a circle slice between yMin & yMax.
 *
 * To maintain analogy with _getSphereSliceRadiusRange we call radius what in fact is
 * half-width (along X axis) of the slice, i.e. 1D-sphere radius.
 *
 * @param {Vector3} center - center of the circle (z can be ignored)
 * @param {number} radius  - circle radius
 * @param {number} yMin - lower bound of the slice
 * @param {number} yMax - upper bound of the slice
 * @returns {Array} - array of two numbers (min & max radius, or half-width)
 */
function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
  const dyMin = yMin - center.y;
  const dyMax = yMax - center.y;
  const ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0.0));
  const ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0.0));
  const rMin = Math.min(ryMin, ryMax);
  let rMax;
  if (yMin <= center.y && yMax >= center.y) {
    // slice's main diameter is inside slice
    rMax = radius;
  } else {
    rMax = Math.max(ryMin, ryMax);
  }
  return [rMin, rMax];
}

/**
 * VoxelWorld constructor
 *
 * @param {Box3} box - bounding box of the volume to be partitioned
 * @param {Vector3} vCellSizeHint - target voxel size (actual voxel size may differ from this)
 */
class VoxelWorld {
  constructor(box, vCellSizeHint) {
    this._box = box.clone();
    const size = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    box.getSize(size);
    this._count = size.clone().divide(vCellSizeHint).floor().max(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 1, 1));
    this._last = this._count.clone().subScalar(1);
    this._cellSize = size.clone().divide(this._count);
    this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
    this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize));

    // array of voxels, each element contains index of first atom in voxel
    const numVoxels = this._count.x * this._count.y * this._count.z;
    this._voxels = utils.allocateTyped(Int32Array, numVoxels);
    for (let i = 0; i < numVoxels; ++i) {
      this._voxels[i] = -1;
    }

    // array of atoms that stores multiple single-linked lists
    // two elements for each atom: Atom ref, index of next atom (in this array
    this._atoms = [];
  }

  /**
   * Add all atoms from a complex to voxel world
   *
   * @param {Complex} complex - complex
   */
  addAtoms(complex) {
    const self = this;
    let idx = this._atoms.length;

    // resize array of atoms
    this._atoms.length += 2 * complex.getAtomCount();
    complex.forEachAtom(atom => {
      // find which voxel contains this atom
      const voxelIdx = self._findVoxel(atom.position);

      // push current atom to the head of voxel's atom list
      self._atoms[idx] = atom;
      self._atoms[idx + 1] = self._voxels[voxelIdx];
      self._voxels[voxelIdx] = idx;
      idx += 2;
    });
  }

  /**
   * Get voxel that contains specified 3D point (we use clamp at the edges)
   *
   * @param {Vector3} point - a point in 3D
   * @returns {number} - index of voxel
   */
  static _zero = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0))();
  static _voxel = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  _findVoxel(point) {
    const zero = VoxelWorld._zero;
    const voxel = VoxelWorld._voxel;
    voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
    return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
  }

  /**
   * Call a function for each atom in voxel
   *
   * @param {number} voxel - index of voxel
   * @param {function(Atom)} process - function to call
   */
  _forEachAtomInVoxel(voxel, process) {
    for (let i = this._voxels[voxel]; i >= 0; i = this._atoms[i + 1]) {
      process(this._atoms[i]);
    }
  }

  /**
   * Call a function for each voxel that is touched by given sphere. Callback also takes flag
   * isInside specifying whether voxel lies inside the sphere entirely.
   *
   * @param {Vector3} center - center of the sphere
   * @param {number} radius  - sphere radius
   * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
   */

  static _xRange = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2())();
  static _yRange = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2())();
  static _zRange = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2())();
  _forEachVoxelWithinRadius(center, radius, process) {
    const xRange = VoxelWorld._xRange;
    const yRange = VoxelWorld._yRange;
    const zRange = VoxelWorld._zRange;

    // switch to a faster method unless cell size is much smaller than sphere radius
    if (radius / this._cellInnerR < 10) {
      this._forEachVoxelWithinRadiusSimple(center, radius, process);
      return;
    }
    let rRangeXY;
    let rRangeX;
    let xVal;
    let yVal;
    let zVal;
    let isInsideX;
    let isInsideY;
    let isInsideZ;
    zRange.set(center.z - radius, center.z + radius);
    zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);
    for (let z = zRange.x; z <= zRange.y; ++z) {
      zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
      isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;
      rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);
      yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
      yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);
      for (let y = yRange.x; y <= yRange.y; ++y) {
        yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
        isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];
        rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);
        xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
        xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);
        for (let {
          x
        } = xRange; x <= xRange.y; ++x) {
          xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
          isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];
          process(x + this._count.x * (y + this._count.y * z), isInsideX && isInsideY && isInsideZ);
        }
      }
    }
  }

  /**
   * Call a function for each voxel that is touched by given sphere. Callback also takes flag
   * isInside specifying whether voxel lies inside the sphere entirely.
   * This is a version of method that doesn't try to "calculate" what voxels fall inside radius
   * but instead just checks all voxels inside sphere's bounding box. This should be faster
   * unless cell size is much smaller than sphere radius.
   *
   * @param {Vector3} center - center of the sphere
   * @param {number} radius  - sphere radius
   * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
   */

  static _vCenter = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  _forEachVoxelWithinRadiusSimple(center, radius, process) {
    const xRange = VoxelWorld._xRange;
    const yRange = VoxelWorld._yRange;
    const zRange = VoxelWorld._zRange;
    const vCenter = VoxelWorld._vCenter;
    const distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
    let distInside2 = -1.0;
    if (radius > this._cellOuterR) {
      distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
    }

    // calculate bounding box for the sphere
    xRange.set(center.x - radius, center.x + radius);
    xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
    xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
    xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);
    yRange.set(center.y - radius, center.y + radius);
    yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
    yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
    yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);
    zRange.set(center.z - radius, center.z + radius);
    zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
    zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
    zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);
    for (let z = zRange.x; z <= zRange.y; ++z) {
      const zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
      vCenter.z = 0.5 * (zVal[0] + zVal[1]);
      for (let y = yRange.x; y <= yRange.y; ++y) {
        const yVal = [this._box.min.y + y * this._cellSize.y, this._box.min.y + (y + 1) * this._cellSize.y];
        vCenter.y = 0.5 * (yVal[0] + yVal[1]);
        for (let {
          x
        } = xRange; x <= xRange.y; ++x) {
          const xVal = [this._box.min.x + x * this._cellSize.x, this._box.min.x + (x + 1) * this._cellSize.x];
          vCenter.x = 0.5 * (xVal[0] + xVal[1]);
          const d2 = center.distanceToSquared(vCenter);
          if (d2 <= distTouch2) {
            process(x + this._count.x * (y + this._count.y * z), d2 <= distInside2);
          }
        }
      }
    }
  }

  /**
   * Call a function for each atom within given sphere
   *
   * @param {Vector3} center - center of the sphere
   * @param {number} radius  - sphere radius
   * @param {function(Atom)} process - function to call
   */
  forEachAtomWithinRadius(center, radius, process) {
    const self = this;
    const r2 = radius * radius;
    self._forEachVoxelWithinRadius(center, radius, (voxel, isInside) => {
      if (isInside) {
        self._forEachAtomInVoxel(voxel, process);
      } else {
        self._forEachAtomInVoxel(voxel, atom => {
          if (center.distanceToSquared(atom.position) <= r2) {
            process(atom);
          }
        });
      }
    });
  }

  /**
   * Call a function for each atom of given complex within given distance from group of atoms defined by mask
   *
   * @param {Complex} complex - complex
   * @param {number} mask - bit mask
   * @param {number} dist - distance
   * @param {function(Atom)} process - function to call
   */
  forEachAtomWithinDistFromMasked(complex, mask, dist, process) {
    this._forEachAtomWithinDistFromGroup(atomProc => {
      complex.forEachAtom(atom => {
        if ((atom.mask & mask) !== 0) {
          atomProc(atom);
        }
      });
    }, dist, process);
  }

  /**
   * Call a function for each atom of given complex within given distance from group of atoms defined by selector
   *
   * @param {Complex} complex - complex
   * @param {number} selector - selector
   * @param {number} dist - distance
   * @param {function(Atom)} process - function to call
   */
  forEachAtomWithinDistFromSelected(complex, selector, dist, process) {
    this._forEachAtomWithinDistFromGroup(atomProc => {
      complex.forEachAtom(atom => {
        if (selector.includesAtom(atom)) {
          atomProc(atom);
        }
      });
    }, dist, process);
  }

  /**
   * Call a function for each atom of given complex within given distance from group of atoms
   *
   * @param {function} forEachAtom - enumerator of atoms in the group
   * @param {number} dist - distance
   * @param {function(Atom)} process - function to call
   */
  _forEachAtomWithinDistFromGroup(forEachAtom, dist, process) {
    const self = this;
    const r2 = dist * dist;
    const voxels = [];
    const atoms = [];
    let idx = 0;

    // build "within radius" atom list for each voxel
    forEachAtom(atom => {
      self._forEachVoxelWithinRadius(atom.position, dist, (voxel, isInside) => {
        if (isInside) {
          // this voxel is inside circle -- no check will be required
          voxels[voxel] = -1;
        } else if (typeof voxels[voxel] === 'undefined') {
          // this voxel isn't covered yet -- start building list of atoms
          atoms.push(atom);
          atoms.push(-1);
          voxels[voxel] = idx;
          idx += 2;
        } else if (voxels[voxel] !== -1) {
          // this voxel has a list of atoms required for distance check -- add atom to the list
          atoms.push(atom);
          atoms.push(voxels[voxel]);
          voxels[voxel] = idx;
          idx += 2;
        }
      });
    });
    let voxel;
    const processIfWithin = function (atom) {
      if (typeof voxels[voxel] === 'undefined') {
        return;
      }
      idx = voxels[voxel];
      if (idx === -1) {
        // this voxel is fully covered
        process(atom);
        return;
      }

      // check distance to each atom within radius from this voxel
      for (; idx >= 0; idx = atoms[idx + 1]) {
        if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
          process(atom);
          break;
        }
      }
    };

    // for each marked voxel
    for (voxel in voxels) {
      if (voxels.hasOwnProperty(voxel)) {
        self._forEachAtomInVoxel(voxel, processIfWithin);
      }
    }
  }
}
/* harmony default export */ const chem_VoxelWorld = (VoxelWorld);
;// CONCATENATED MODULE: ./src/chem/HBondInfo.js


const MINIMAL_DISTANCE = 0.5;
const MIN_HBOND_ENERGY = -9.9;
const MAX_HBOND_ENERGY = -0.5;
const COUPLING_CONSTANT = -27.888; // = -332 * 0.42 * 0.2
const MAX_COUPLING_DISTANCE = 5.0; // how far is the closest atom of a potential partner residue from CA atom
const MAX_RESIDUES_THRESHOLD = 1000;
class HBondInfo {
  constructor(complex) {
    this._complex = complex;
    this._hbonds = []; // array of bond info for each residue
    if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
      this._buildVW(); // optimized version using voxel grid
    } else {
      this._build(); // test all pairs of residues
    }
  }
  isBond(from, to) {
    if (this._hbonds[from]) {
      const [acc0, acc1] = this._hbonds[from].acceptor;
      if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
        return true;
      }
      if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
        return true;
      }
    }
    return false;
  }
  _build() {
    const self = this;
    for (let i = 0; i < this._complex._residues.length - 1; ++i) {
      const ri = this._complex._residues[i];
      if ((ri.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
        continue;
      }

      // get predecessor in chain
      let preri = null;
      if (i > 0 && this._complex._residues[i - 1].getType().flags & chem_ResidueType.Flags.PROTEIN && ri._sequence === this._complex._residues[i - 1]._sequence + 1) {
        preri = this._complex._residues[i - 1];
      }
      for (let j = i + 1; j < this._complex._residues.length; ++j) {
        const rj = this._complex._residues[j];
        if ((rj.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
          continue;
        }

        // get predecessor in chain
        let prerj = null;
        if (this._complex._residues[j - 1].getType().flags & chem_ResidueType.Flags.PROTEIN && rj._sequence === this._complex._residues[j - 1]._sequence + 1) {
          prerj = this._complex._residues[j - 1];
        }
        self._calcHBondEnergy(preri, ri, rj);
        if (j !== i + 1) {
          self._calcHBondEnergy(prerj, rj, ri);
        }
      }
    }
  }
  _buildVW() {
    const self = this;
    const residues = this._complex._residues;
    let ri;
    let preri;
    const vw = this._complex.getVoxelWorld();
    if (vw === null) {
      return;
    }
    const pairs = new chem_AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);
    function processAtom(atom) {
      const rj = atom.residue;
      if (rj._index === ri._index) {
        return;
      }
      if ((rj.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
        return;
      }
      if (!pairs.addPair(ri._index, rj._index)) {
        // we've seen this pair
        return;
      }

      // get predecessor in chain
      let prerj = rj._index > 0 ? residues[rj._index - 1] : null;
      if (prerj && ((prerj.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
        prerj = null;
      }
      self._calcHBondEnergy(preri, ri, rj);
      if (rj._index !== ri._index + 1) {
        self._calcHBondEnergy(prerj, rj, ri);
      }
    }
    for (let i = 0; i < residues.length - 1; ++i) {
      ri = residues[i];
      if ((ri.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
        continue;
      }

      // get predecessor in chain
      preri = i > 0 ? residues[i - 1] : null;
      if (preri && ((preri.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
        preri = null;
      }
      vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
    }
  }
  _residueGetCAlpha(res) {
    for (let i = 0; i < res._atoms.length; ++i) {
      const {
        name
      } = res._atoms[i];
      if (name === 'CA' || name === 'C1') {
        return res._atoms[i].position;
      }
    }
    return null;
  }
  _residueGetCO(res) {
    let c = null;
    let o = null;
    res.forEachAtom(a => {
      if (a.name === 'C') {
        c = a.position;
      } else if (a.name === 'O') {
        o = a.position;
      }
    });
    return [c, o];
  }

  // TODO Support hydrogen defined in complex
  _residueGetNH(prev, res) {
    const [c, o] = this._residueGetCO(prev);
    let n;
    res.forEachAtom(a => {
      if (a.name === 'N') {
        n = a.position;
      }
    });
    if (c && o && n) {
      // calculate hydrogen position
      const h = c.clone();
      h.sub(o);
      h.multiplyScalar(1.0 / h.length());
      h.add(n);
      return [n, h];
    }
    return [null, null];
  }
  _calcHBondEnergy(predonor, donor, acceptor) {
    let result = 0;
    if (predonor === null) {
      return result;
    }
    if (donor.getType().getName() !== 'PRO') {
      const [n, h] = this._residueGetNH(predonor, donor);
      const [c, o] = this._residueGetCO(acceptor);
      if (n === null || h === null || c === null || o === null) {
        return result;
      }
      const distanceHO = h.distanceTo(o);
      const distanceHC = h.distanceTo(c);
      const distanceNC = n.distanceTo(c);
      const distanceNO = n.distanceTo(o);
      if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
        result = MIN_HBOND_ENERGY;
      } else {
        result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
      }

      // DSSP compatibility mode:
      result = Math.round(result * 1000) / 1000;
      if (result < MIN_HBOND_ENERGY) {
        result = MIN_HBOND_ENERGY;
      }
    }

    // update donor
    if (typeof this._hbonds[donor._index] === 'undefined') {
      this._hbonds[donor._index] = {
        donor: [],
        acceptor: []
      };
    }
    const donorInfo = this._hbonds[donor._index];
    if (donorInfo.acceptor.length < 2) {
      donorInfo.acceptor.push({
        residue: acceptor._index,
        energy: result
      });
    }
    if (donorInfo.acceptor.length > 1) {
      if (result < donorInfo.acceptor[0].energy) {
        donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
        donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
        donorInfo.acceptor[0].residue = acceptor._index;
        donorInfo.acceptor[0].energy = result;
      } else if (result < donorInfo.acceptor[1].energy) {
        donorInfo.acceptor[1].residue = acceptor._index;
        donorInfo.acceptor[1].energy = result;
      }
    }

    // update acceptor
    if (typeof this._hbonds[acceptor._index] === 'undefined') {
      this._hbonds[acceptor._index] = {
        donor: [],
        acceptor: []
      };
    }
    const accInfo = this._hbonds[acceptor._index];
    if (accInfo.donor.length < 2) {
      accInfo.donor.push({
        residue: donor._index,
        energy: result
      });
    }
    if (accInfo.donor.length > 1) {
      if (result < accInfo.donor[0].energy) {
        accInfo.donor[1].residue = accInfo.donor[0].residue;
        accInfo.donor[1].energy = accInfo.donor[0].energy;
        accInfo.donor[0].residue = donor._index;
        accInfo.donor[0].energy = result;
      } else if (result < accInfo.donor[1].energy) {
        accInfo.donor[1].residue = donor._index;
        accInfo.donor[1].energy = result;
      }
    }
    return result;
  }
}
;// CONCATENATED MODULE: ./src/chem/SecondaryStructureMap.js


const BridgeType = Object.freeze({
  NO_BRIDGE: 0,
  PARALLEL: 1,
  ANTI_PARALLEL: 2
});
const HelixFlag = Object.freeze({
  START: 1,
  MIDDLE: 2,
  END: 3,
  START_AND_END: 4
});
const StructureType = Object.freeze({
  STRAND: 'E',
  BRIDGE: 'B',
  HELIX_310: 'G',
  HELIX_ALPHA: 'H',
  HELIX_PI: 'I',
  TURN: 'T',
  BEND: 'S',
  LOOP: ' '
});
class SecondaryStructureMap {
  constructor(complex) {
    this._complex = complex;
    this._build();
  }
  _build() {
    const self = this;
    this._hbonds = new HBondInfo(this._complex);
    this._ss = []; // DSSP map by residue

    // auxilliary data
    this._sheet = [];
    this._betaPartners = [];
    this._bend = [];
    for (let i = 0; i < this._complex.getResidues().length; ++i) {
      this._betaPartners[i] = [];
    }
    this._helixFlags = [];
    this._helixFlags[3] = [];
    this._helixFlags[4] = [];
    this._helixFlags[5] = [];

    // calculate peptide chain lengths
    this._chainLengths = [];
    for (let i = 0; i < this._complex._chains.length; ++i) {
      const chain = this._complex._chains[i].getResidues();
      let len = 0;
      for (; len < chain.length; ++len) {
        if ((chain[len].getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
          break;
        }
      }
      this._chainLengths[i] = len;
    }
    this._buildBetaSheets();
    for (let i = 0; i < this._complex._chains.length; ++i) {
      self._buildAlphaHelices(this._complex._chains[i].getResidues(), this._chainLengths[i], false);
    }
  }
  _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
    // Helix and Turn
    for (let stride = 3; stride <= 5; ++stride) {
      if (inResidues.length < stride) {
        break;
      }
      for (let i = 0; i + stride < chainLength; ++i) {
        if (this._hbonds.isBond(inResidues[i + stride]._index, inResidues[i]._index)
        /* && NoChainBreak(res[i], res[i + stride]) */) {
          this._helixFlags[stride][inResidues[i + stride]._index] = HelixFlag.END;
          for (let j = i + 1; j < i + stride; ++j) {
            if (typeof this._helixFlags[stride][inResidues[j]._index] === 'undefined') {
              this._helixFlags[stride][inResidues[j]._index] = HelixFlag.MIDDLE;
            }
          }
          if (this._helixFlags[stride][inResidues[i]._index] === HelixFlag.END) {
            this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START_AND_END;
          } else {
            this._helixFlags[stride][inResidues[i]._index] = HelixFlag.START;
          }
        }
      }
    }
    for (let i = 2; i < chainLength - 2; ++i) {
      const kappa = this._kappa(inResidues[i - 2], inResidues[i], inResidues[i + 2]);
      this._bend[inResidues[i]._index] = kappa !== 360 && kappa > 70;
    }
    for (let i = 1; i + 4 < chainLength; ++i) {
      if (this._isHelixStart(inResidues[i]._index, 4) && this._isHelixStart(inResidues[i - 1]._index, 4)) {
        for (let j = i; j <= i + 3; ++j) {
          this._ss[inResidues[j]._index] = StructureType.HELIX_ALPHA;
        }
      }
    }
    for (let i = 1; i + 3 < chainLength; ++i) {
      if (this._isHelixStart(inResidues[i]._index, 3) && this._isHelixStart(inResidues[i - 1]._index, 3)) {
        let empty = true;
        for (let j = i; empty && j <= i + 2; ++j) {
          empty = typeof this._ss[inResidues[j]._index] === 'undefined' || this._ss[inResidues[j]._index] === StructureType.HELIX_310;
        }
        if (empty) {
          for (let j = i; j <= i + 2; ++j) {
            this._ss[inResidues[j]._index] = StructureType.HELIX_310;
          }
        }
      }
    }
    for (let i = 1; i + 5 < chainLength; ++i) {
      if (this._isHelixStart(inResidues[i]._index, 5) && this._isHelixStart(inResidues[i - 1]._index, 5)) {
        let empty = true;
        for (let j = i; empty && j <= i + 4; ++j) {
          empty = typeof this._ss[inResidues[j]._index] === 'undefined' || this._ss[inResidues[j]._index] === StructureType.HELIX_PI || inPreferPiHelices && this._ss[inResidues[j]._index] === StructureType.HELIX_ALPHA;
        }
        if (empty) {
          for (let j = i; j <= i + 4; ++j) {
            this._ss[inResidues[j]._index] = StructureType.HELIX_PI;
          }
        }
      }
    }
    for (let i = 1; i + 1 < chainLength; ++i) {
      if (typeof this._ss[inResidues[i]._index] === 'undefined') {
        let isTurn = false;
        for (let stride = 3; stride <= 5 && !isTurn; ++stride) {
          for (let k = 1; k < stride && !isTurn; ++k) {
            isTurn = i >= k && this._isHelixStart(inResidues[i - k]._index, stride);
          }
        }
        if (isTurn) {
          this._ss[inResidues[i]._index] = StructureType.TURN;
        } else if (this._bend[inResidues[i]._index]) {
          this._ss[inResidues[i]._index] = StructureType.BEND;
        }
      }
    }
  }
  _residueGetCAlpha(res) {
    for (let i = 0; i < res._atoms.length; ++i) {
      const {
        name
      } = res._atoms[i];
      if (name === 'CA' || name === 'C1') {
        return res._atoms[i].position;
      }
    }
    return null;
  }
  _cosinusAngle(p1, p2, p3, p4) {
    const v12 = p1.clone().sub(p2);
    const v34 = p3.clone().sub(p4);
    let result = 0;
    const x = v12.dot(v12) * v34.dot(v34);
    if (x > 0) {
      result = v12.dot(v34) / Math.sqrt(x);
    }
    return result;
  }
  _kappa(prevPrev, res, nextNext) {
    const curCA = this._residueGetCAlpha(res);
    const ppCA = this._residueGetCAlpha(prevPrev);
    const nnCA = this._residueGetCAlpha(nextNext);
    if (curCA === null || ppCA === null || nnCA === null) {
      return 180;
    }
    const ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);
    const skap = Math.sqrt(1 - ckap * ckap);
    return Math.atan2(skap, ckap) * 180 / Math.PI;
  }
  _isHelixStart(res, stride) {
    return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
  }
  _buildBetaSheets() {
    // find bridges
    // check each chain against each other chain, and against itself
    const bridges = [];
    for (let a = 0; a < this._complex._chains.length; ++a) {
      const lenA = this._chainLengths[a];
      if (lenA <= 4) {
        continue;
      }
      const chainA = this._complex._chains[a].getResidues();
      for (let b = a; b < this._complex._chains.length; ++b) {
        const lenB = this._chainLengths[b];
        if (lenB <= 4) {
          continue;
        }
        const chainB = this._complex._chains[b].getResidues();
        for (let i = 1; i + 1 < lenA; ++i) {
          const ri = chainA[i];
          let j = 1;
          if (b === a) {
            j = i + 3; // check for self-bridges forward down the chain
          }
          for (; j + 1 < lenB; ++j) {
            const rj = chainB[j];
            const type = this._testBridge(chainA, i, chainB, j);
            if (type === BridgeType.NO_BRIDGE) {
              continue;
            }

            // there is a bridge, try to attach it to previously found sequence
            let found = false;
            for (const bridge of bridges) {
              if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
                continue;
              }
              if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
                bridge.i.push(ri._index);
                bridge.j.push(rj._index);
                found = true;
                break;
              }
              if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
                bridge.i.push(ri._index);
                bridge.j.unshift(rj._index);
                found = true;
                break;
              }
            }

            // this bridge cannot be attached anywhere, start a new sequence
            if (!found) {
              bridges.push({
                type,
                i: [ri._index],
                chainI: ri.getChain()._index,
                j: [rj._index],
                chainJ: rj.getChain()._index
              });
            }
          }
        }
      }
    }

    // extend ladders
    bridges.sort((a, b) => {
      if (a.chainI < b.chainI || a.chainI === b.chainI && a.i[0] < b.i[0]) {
        return -1;
      }
      return 1;
    });
    for (let i = 0; i < bridges.length; ++i) {
      for (let j = i + 1; j < bridges.length; ++j) {
        const ibi = bridges[i].i[0];
        const iei = bridges[i].i[bridges[i].i.length - 1];
        const jbi = bridges[i].j[0];
        const jei = bridges[i].j[bridges[i].j.length - 1];
        const ibj = bridges[j].i[0];
        const iej = bridges[j].i[bridges[j].i.length - 1];
        const jbj = bridges[j].j[0];
        const jej = bridges[j].j[bridges[j].j.length - 1];
        if (bridges[i].type !== bridges[j].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
          continue;
        }
        let bulge = false;
        if (bridges[i].type === BridgeType.PARALLEL) {
          bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
        } else {
          bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
        }
        if (bulge) {
          bridges[i].i = bridges[i].i.concat(bridges[j].i);
          if (bridges[i].type === BridgeType.PARALLEL) {
            bridges[i].j = bridges[i].j.concat(bridges[j].j);
          } else {
            bridges[i].j = bridges[j].j.concat(bridges[i].j);
          }
          bridges.splice(j--, 1);
        }
      }
    }

    // Sheet
    const ladderset = new Set();
    for (let i = 0; i < bridges.length; ++i) {
      ladderset.add(bridges[i]);
    }
    let sheet = 1;
    let ladder = 0;
    while (ladderset.size > 0) {
      let bridge = ladderset.values().next().value;
      ladderset.delete(bridge);
      const sheetset = new Set();
      sheetset.add(bridge);
      let toMove;
      do {
        toMove = new Set();
        for (const a of sheetset.values()) {
          for (const b of ladderset.values()) {
            if (this._areBridgesLinked(a, b)) {
              toMove.add(b);
            }
          }
        }
        for (bridge of toMove.values()) {
          sheetset.add(bridge);
          ladderset.delete(bridge);
        }
      } while (toMove.size > 0);
      for (bridge of sheetset.values()) {
        bridge.ladder = ladder;
        bridge.sheet = sheet;
        bridge.link = sheetset;
        ++ladder;
      }
      ++sheet;
    }
    for (let i = 0; i < bridges.length; ++i) {
      const bridge = bridges[i];

      // find out if any of the i and j set members already have
      // a bridge assigned, if so, we're assigning bridge 2

      let betai = 0;
      let betaj = 0;
      for (let l = 0; l < bridge.i.length; ++l) {
        if (this._betaPartners[bridge.i[l]][0]) {
          betai = 1;
          break;
        }
      }
      for (let l = 0; l < bridge.j.length; ++l) {
        if (this._betaPartners[bridge.j[l]][0]) {
          betaj = 1;
          break;
        }
      }
      let ss = StructureType.BRIDGE;
      if (bridge.i.length > 1) {
        ss = StructureType.STRAND;
      }
      if (bridge.type === BridgeType.PARALLEL) {
        let j = 0;
        for (let k = 0; k < bridge.i.length; ++k) {
          this._betaPartners[bridge.i[k]][betai] = {
            residue: bridge.j[j++],
            ladder: bridge.ladder,
            parallel: true
          };
        }
        j = 0;
        for (let k = 0; k < bridge.j.length; ++k) {
          this._betaPartners[bridge.j[k]][betaj] = {
            residue: bridge.i[j++],
            ladder: bridge.ladder,
            parallel: true
          };
        }
      } else {
        let j = bridge.j.length - 1;
        for (let k = 0; k < bridge.i.length; ++k) {
          this._betaPartners[bridge.i[k]][betai] = {
            residue: bridge.j[j--],
            ladder: bridge.ladder,
            parallel: false
          };
        }
        j = bridge.i.length - 1;
        for (let k = 0; k < bridge.j.length; ++k) {
          this._betaPartners[bridge.j[k]][betaj] = {
            residue: bridge.i[j--],
            ladder: bridge.ladder,
            parallel: false
          };
        }
      }
      for (let k = bridge.i[0]; k <= bridge.i[bridge.i.length - 1]; ++k) {
        if (this._ss[k] !== StructureType.STRAND) {
          this._ss[k] = ss;
          this._sheet[k] = bridge.sheet;
        }
      }
      for (let k = bridge.j[0]; k <= bridge.j[bridge.j.length - 1]; ++k) {
        if (this._ss[k] !== StructureType.STRAND) {
          this._ss[k] = ss;
          this._sheet[k] = bridge.sheet;
        }
      }
    }
  }
  _testBridge(chainA, from, chainB, to) {
    let result = BridgeType.NO_BRIDGE;
    const a = chainA[from - 1]._index;
    const b = chainA[from]._index;
    const c = chainA[from + 1]._index;
    const d = chainB[to - 1]._index;
    const e = chainB[to]._index;
    const f = chainB[to + 1]._index;
    const isBond = this._hbonds.isBond.bind(this._hbonds);
    if (isBond(c, e) && isBond(e, a) || isBond(f, b) && isBond(b, d)) {
      result = BridgeType.PARALLEL;
    } else if (isBond(c, d) && isBond(f, a) || isBond(e, b) && isBond(b, e)) {
      result = BridgeType.ANTI_PARALLEL;
    }
    return result;
  }

  // return true if any of the residues in bridge a is identical to any of the residues in bridge b
  _areBridgesLinked(a, b) {
    const ai = new Set(a.i);
    const aj = new Set(a.j);
    for (const i of b.i) {
      if (ai.has(i) || aj.has(i)) {
        return true;
      }
    }
    for (const i of b.j) {
      if (ai.has(i) || aj.has(i)) {
        return true;
      }
    }
    return false;
  }
  _hasChainBreak(from, to) {
    for (let i = from + 1; i <= to; ++i) {
      if (this._complex._residues[i]._sequence !== this._complex._residues[i - 1]._sequence + 1) {
        return true;
      }
    }
    return false;
  }
}
SecondaryStructureMap.StructureType = StructureType;
;// CONCATENATED MODULE: ./src/chem/Complex.js

















const VOXEL_SIZE = 5.0;
const {
  StructureType: Complex_StructureType
} = SecondaryStructureMap;
const Complex_StructuralElementType = chem_StructuralElement.Type;

// see http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX
const helixClassMap = {
  [Complex_StructureType.HELIX_ALPHA]: 1,
  [Complex_StructureType.HELIX_PI]: 3,
  [Complex_StructureType.HELIX_310]: 5
};
const loopMap = {
  [Complex_StructureType.BRIDGE]: Complex_StructuralElementType.BRIDGE,
  [Complex_StructureType.TURN]: Complex_StructuralElementType.TURN,
  [Complex_StructureType.BEND]: Complex_StructuralElementType.BEND,
  [Complex_StructureType.LOOP]: Complex_StructuralElementType.COIL
};

/**
 * The entire complex of the molecules under study.
 *
 * @exports Complex
 * @constructor
 */
class Complex {
  constructor() {
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this.structures = [];
    this._residueTypes = Object.create(chem_ResidueType.StandardTypes);
    this._atoms = [];
    this._residues = [];
    this._bonds = [];
    this._sgroups = [];
    this._molecules = [];
    this._maskNeedsUpdate = false;
    this.metadata = {};
    this.symmetry = [];
    this.units = [new chem_BiologicalUnit(this)];
    this._currentUnit = 0; // default biological unit is the asymmetric unit
  }
  addAtom(atom) {
    const index = this._atoms.length;
    this._atoms.push(atom);
    return index;
  }
  addSheet(sheet) {
    const index = this._sheets.length;
    this._sheets.push(sheet);
    return index;
  }
  addHelix(helix) {
    const index = this._helices.length;
    this._helices.push(helix);
    return index;
  }
  getAtoms() {
    return this._atoms;
  }
  getBonds() {
    return this._bonds;
  }
  getAtomCount() {
    return this._atoms.length;
  }
  addResidue(residue) {
    const index = this._residues.length;
    this._residues.push(residue);
    return index;
  }
  updateToFrame(frameData) {
    this.forEachChain(chain => {
      chain.updateToFrame(frameData);
    });
  }
  addResidueType(resName) {
    const rt = this._residueTypes[resName] = new chem_ResidueType(resName, 'Unknown', '');
    return rt;
  }
  getResidueCount() {
    return this._residues.length;
  }
  getResidues() {
    return this._residues;
  }
  getSGroupCount() {
    return this._sgroups.length;
  }
  getSGroups() {
    return this._sgroups;
  }

  /*
     Extract atom by its fullname: #chainName#.#residueId#.#atomName#
     */
  getAtomByFullname(fullName) {
    const parts = fullName.split('.');
    if (parts.length !== 3) {
      return null;
    }
    const chainName = parts[0];
    const resId = parseInt(parts[1], 10);
    if (Number.isNaN(resId)) {
      return null;
    }
    const atomName = parts[2].toUpperCase();
    let currAtom = null;
    this.forEachChain(chain => {
      if (currAtom) {
        return;
      }
      if (chain._name.localeCompare(chainName) === 0) {
        chain.forEachResidue(residue => {
          if (currAtom) {
            return;
          }
          if (residue._sequence === resId) {
            residue.forEachAtom(atom => {
              if (currAtom) {
                return;
              }
              if (atomName.localeCompare(atom.name) === 0) {
                currAtom = atom;
              }
            });
          }
        });
      }
    });
    return currAtom;
  }

  /**
   * Create a new chain.
   *
   * @param {string} name - Chain name.
   * @returns {Chain} - Newly created chain.
   */
  addChain(name) {
    const result = new chem_Chain(this, name);
    this._chains.push(result);
    return result;
  }
  getChain(name) {
    for (let i = 0, n = this._chains.length; i < n; ++i) {
      const chain = this._chains[i];
      if (chain.getName() === name) {
        return chain;
      }
    }
    return null;
  }
  getChainCount() {
    return this._chains.length;
  }
  getMolecules() {
    return this._molecules;
  }
  getMoleculeCount() {
    return this._molecules.length;
  }
  forEachAtom(process) {
    const atoms = this._atoms;
    for (let i = 0, n = atoms.length; i < n; ++i) {
      process(atoms[i]);
    }
  }
  forEachBond(process) {
    const bonds = this._bonds;
    for (let i = 0, n = bonds.length; i < n; ++i) {
      process(bonds[i]);
    }
  }
  forEachResidue(process) {
    const residues = this._residues;
    for (let i = 0, n = residues.length; i < n; ++i) {
      process(residues[i]);
    }
  }
  forEachChain(process) {
    const chains = this._chains;
    for (let i = 0, n = chains.length; i < n; ++i) {
      process(chains[i]);
    }
  }
  forEachMolecule(process) {
    const molecules = this._molecules;
    const n = molecules.length;
    for (let i = 0; i < n; ++i) {
      process(molecules[i]);
    }
  }
  forEachSGroup(process) {
    const groups = this._sgroups;
    for (let i = 0, n = groups.length; i < n; ++i) {
      process(groups[i]);
    }
  }
  forEachComponent(process) {
    const components = this._components;
    for (let i = 0, n = components.length; i < n; ++i) {
      process(components[i]);
    }
  }
  forEachVisibleComponent(process) {
    const components = this._components;
    for (let i = 0, n = components.length; i < n; ++i) {
      process(components[i]);
    }
  }
  addBond(left, right, order, type, fixed) {
    const bond = new chem_Bond(left, right, order, type, fixed);
    this._bonds.push(bond);
    return bond;
  }
  getBondCount() {
    return this._bonds.length;
  }
  getResidueType(name) {
    return this._residueTypes[name] || null;
  }
  getUnifiedSerial(chain, serial, iCode) {
    /* eslint-disable no-magic-numbers */
    const maxSerial = 65536;
    const chainShift = maxSerial * 256;
    /* eslint-enable no-magic-numbers */
    return serial + iCode * maxSerial + chain * chainShift;
  }
  splitUnifiedSerial(uniSerial) {
    /* eslint-disable no-magic-numbers */
    const maxSerial = 65536;
    const chainShift = maxSerial * 256;
    /* eslint-enable no-magic-numbers */
    const chainId = Math.floor(uniSerial / chainShift);
    const remnant = uniSerial - chainId * chainShift;
    const insCode = Math.floor(remnant / maxSerial);
    const ser = remnant - insCode * maxSerial;
    return {
      chain: chainId,
      serial: ser,
      iCode: insCode
    };
  }
  _fillCmpEdit() {
    const self = this;
    const components = this._components;
    function addComp() {
      const comp = new chem_Component(self);
      comp._index = components.length;
      components[comp._index] = comp;
      return comp;
    }
    this.forEachChain(chain => {
      const residues = chain._residues;
      const resCount = residues.length;
      if (resCount < 1) {
        return;
      }
      let comp = addComp();
      let currStart = residues[0]._index;
      for (let i = 0; i < resCount; ++i) {
        const currRes = residues[i];
        currRes._component = comp;
        const nextRes = i === resCount - 1 ? null : residues[i + 1];
        if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
          // the last condition is broken and incorrect
          // the refactoring of the Component is required in order to fix this issue
          comp.setSubDivs([{
            start: currStart,
            end: currRes._index
          }]);
          if (nextRes) {
            currStart = nextRes._index;
            comp = addComp();
          }
        }
      }
    });
  }

  // This function was added in the moment of despair
  // It was the dark times for miew
  _fillCmpNoedit() {
    const comp = new chem_Component(this);
    comp._index = 0;
    const residues = this._residues;
    const resCount = residues.length;
    if (resCount === 0) {
      return;
    }
    const currSubDivs = [];
    let currStart = 0;
    for (let i = 0; i < resCount; ++i) {
      const currRes = residues[i];
      currRes._component = comp;
      const nextRes = i === resCount - 1 ? null : residues[i + 1];
      if (!nextRes || !currRes.isConnected(nextRes)) {
        // wrap up this interval
        currSubDivs[currSubDivs.length] = {
          start: currStart,
          end: i
        };
        if (nextRes) {
          currStart = i + 1;
        }
      }
    }
    comp.setSubDivs(currSubDivs);
    this._components[comp._index] = comp;
  }

  /**
   * Fill components information.
   * @param {boolean} enableEditing - Restructure Complex to enable per-component editing.
   */
  _fillComponents(enableEditing) {
    if (enableEditing) {
      this._fillCmpEdit();
    } else {
      this._fillCmpNoedit();
    }
  }
  getCurrentUnit() {
    return this._currentUnit;
  }
  getDefaultBoundaries() {
    return this.units[0].getBoundaries();
  }
  getBoundaries() {
    return this.units[this._currentUnit].getBoundaries();
  }
  getTransforms() {
    return this.units[this._currentUnit].getTransforms();
  }
  getSelector() {
    return this.units[this._currentUnit].getSelector();
  }
  resetCurrentUnit() {
    this._currentUnit = 0;
    this.setCurrentUnit(1);
  }
  setCurrentUnit(newUnit) {
    if (newUnit !== null && newUnit !== undefined && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
      this._currentUnit = newUnit;
      return true;
    }
    return false;
  }
  _computeBounds() {
    const {
      units
    } = this;
    for (let i = 0, n = units.length; i < n; ++i) {
      units[i].computeBoundaries();
    }
  }
  onAtomPositionChanged() {
    this.forEachChain(a => {
      a._finalize();
    });
    this.forEachComponent(c => {
      c.update();
    });
    // Update bounding sphere and box
    this._computeBounds();
    this._finalizeBonds();
    this.forEachSGroup(s => {
      s._rebuildSGroupOnAtomChange();
    });
  }
  update() {
    if (this._maskNeedsUpdate) {
      this.updateStructuresMask();
      this._maskNeedsUpdate = false;
    }
  }
  _finalizeBonds() {
    const bonds = this.getBonds();
    const n = bonds.length;
    for (let i = 0; i < n; ++i) {
      bonds[i]._index = i;
    }
  }

  /**
   * Finalizes complex's inner data(i.e. after parsing).
   * @param {objects} opts - Build bonds automatically.
   * @param {boolean} opts.needAutoBonding     - Build bonds automatically.
   * @param {boolean} opts.detectAromaticLoops - Find/mark aromatic loops.
   * @param {boolean} opts.enableEditing       - Restructure Complex to enable per-component editing.
   * @param {Array<Atom>} [opts.serialAtomMap] - Array of atoms ordered by their serials.
   */
  finalize(opts) {
    opts = opts || {};
    // Put bonds into atoms
    const bonds = this._bonds;
    let i;
    let n;
    // remove invalid bonds
    for (i = bonds.length - 1; i >= 0; i--) {
      const bond = bonds[i];
      if (bond._left === null || bond._right === null) {
        bonds.splice(i, 1);
      } else {
        bond._left.bonds.push(bond);
        bond._right.bonds.push(bond);
      }
    }
    const residues = this._residues;
    for (i = 0, n = residues.length; i < n; ++i) {
      residues[i]._finalize();
    }
    this.forEachChain(a => {
      a._finalize();
    });

    // WARNING! this MUST be done BEFORE computeBounds is called
    const {
      units
    } = this;
    for (i = 0, n = units.length; i < n; ++i) {
      units[i].finalize();
    }
    // try setting first biomolecule by defaults
    this.setCurrentUnit(1);
    const residueHash = {};
    for (i = 0, n = residues.length; i < n; ++i) {
      const res = residues[i];
      // This code is extremely dangerous for non-PDB formats
      residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
    }
    const {
      structures
    } = this;
    for (i = 0, n = structures.length; i < n; ++i) {
      structures[i]._finalize(opts.serialAtomMap, residueHash, this);
    }
    const helices = this._helices;
    for (i = 0, n = helices.length; i < n; ++i) {
      helices[i]._finalize(opts.serialAtomMap, residueHash, this);
    }
    const sheets = this._sheets;
    for (i = 0, n = sheets.length; i < n; ++i) {
      sheets[i]._finalize(opts.serialAtomMap, residueHash, this);
    }

    // Update bounding sphere and box
    this._computeBounds();
    const atoms = this._atoms;
    for (i = 0, n = atoms.length; i < n; ++i) {
      const currAtom = atoms[i];
      currAtom.index = i;
    }
    if (opts.needAutoBonding) {
      const autoConnector = new chem_AutoBond(this);
      autoConnector.build();
      autoConnector.destroy();
    }
    const chains = this._chains;
    for (i = 0, n = chains.length; i < n; ++i) {
      chains[i]._index = i;
    }
    for (i = 0, n = residues.length; i < n; ++i) {
      residues[i]._index = i;
    }

    // mark non-polar hydrogens
    for (i = 0, n = atoms.length; i < n; ++i) {
      const atom = atoms[i];
      if (atom.flags & chem_Atom.Flags.HYDROGEN && atom.bonds.length === 1) {
        const bond = atom.bonds[0];
        const other = bond._left !== atom && bond._left || bond._right;
        if (other.flags & chem_Atom.Flags.CARBON) {
          atom.flags |= chem_Atom.Flags.NONPOLARH;
        }
      }
    }
    this._finalizeBonds();
    this._fillComponents(opts.enableEditing);
    const marker = new chem_AromaticLoopsMarker(this);
    marker.markCycles();
    if (opts.detectAromaticLoops) {
      // TODO remove this condition clause, it is for debug purposes only!
      marker.detectCycles(); // TODO add conditional detection
    }
    this._finalizeMolecules();
  }
  _finalizeMolecules() {
    // add reference to molecule into residue
    for (let i = 0; i < this._molecules.length; i++) {
      const molecule = this._molecules[i];
      const count = molecule.residues.length;
      for (let j = 0; j < count; j++) {
        const residue = molecule.residues[j];
        residue._molecule = molecule;
      }
    }
  }
  updateStructuresMask() {
    const updater = structure => structure.collectMask();
    this.forEachResidue(updater);
    this.forEachChain(updater);
    this.forEachMolecule(updater);
  }
  countAtomsByMask(mask) {
    let count = 0;
    this.forEachAtom(atom => {
      if ((atom.mask & mask) !== 0) {
        count++;
      }
    });
    return count;
  }
  getNumAtomsBySelector(selector) {
    let count = 0;
    this.forEachAtom(atom => {
      if (selector.includesAtom(atom)) {
        count++;
      }
    });
    return count;
  }
  resetAtomMask(mask) {
    this.forEachAtom(atom => {
      atom.mask = mask;
    });
  }
  markAtoms(selector, mask) {
    const setMask = mask;
    const clearMask = ~setMask;
    let count = 0;
    const totalSelector = chem_selectors.keyword('And')(selector, this.getSelector());
    this.forEachAtom(atom => {
      if (totalSelector.includesAtom(atom)) {
        atom.mask |= setMask;
        count++;
      } else {
        atom.mask &= clearMask;
      }
    });
    this._maskNeedsUpdate = true;
    return count;
  }
  markAtomsAdditionally(selector, mask) {
    const setMask = mask;
    let count = 0;
    this.forEachAtom(atom => {
      if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
        atom.mask |= setMask;
        count++;
      }
    });
    return count;
  }
  clearAtomBits(mask) {
    const clearMask = ~mask;
    this.forEachAtom(atom => {
      atom.mask &= clearMask;
    });
    const reseter = a => {
      a._mask &= clearMask;
    };
    this.forEachAtom(reseter);
    this.forEachResidue(reseter);
    this.forEachChain(reseter);
    this.forEachMolecule(reseter);
  }
  getAtomNames() {
    if (this.hasOwnProperty('_atomNames')) {
      return this._atomNames;
    }
    const dict = {};
    this.forEachAtom(atom => {
      dict[atom.name] = 1;
    });
    this._atomNames = Object.keys(dict);
    return this._atomNames;
  }
  getElements() {
    if (this.hasOwnProperty('_elements')) {
      return this._elements;
    }
    const dict = {};
    this.forEachAtom(atom => {
      dict[atom.element.name] = 1;
    });
    this._elements = Object.keys(dict);
    return this._elements;
  }
  getResidueNames() {
    if (this.hasOwnProperty('_residueNames')) {
      return this._residueNames;
    }
    const dict = {};
    this.forEachResidue(res => {
      dict[res._type._name] = 1;
    });
    this._residueNames = Object.keys(dict);
    return this._residueNames;
  }
  getChainNames() {
    if (this.hasOwnProperty('_chainNames')) {
      return this._chainNames;
    }
    const dict = {};
    this.forEachChain(chain => {
      dict[chain._name] = 1;
    });
    this._chainNames = Object.keys(dict);
    return this._chainNames;
  }
  getAltLocNames() {
    if (this.hasOwnProperty('_altlocNames')) {
      return this._altlocNames;
    }
    const dict = {};
    this.forEachAtom(atom => {
      dict[String.fromCharCode(atom.location)] = 1;
    });
    this._altlocNames = Object.keys(dict);
    return this._altlocNames;
  }
  getVoxelWorld() {
    if (!this.hasOwnProperty('_voxelWorld')) {
      try {
        this._voxelWorld = new chem_VoxelWorld(this.getDefaultBoundaries().boundingBox, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));
        this._voxelWorld.addAtoms(this);
      } catch (e) {
        logger.warn('Unable to create voxel world');
        this._voxelWorld = null;
      }
    }
    return this._voxelWorld;
  }

  /**
   * Simple function to make unified routine procedure without code duplication.
   * @param {Array} srcArray   - Source chemical structure array (will be part of resulting chemical structure array).
   * @param {Array} dstArray   - Resulting chemical structure array.
   * @param {number} param     - Parameter for processor.
   * @param {function} functor - Processor for every element in array.
   */
  addElement(srcArray, dstArray, param, functor) {
    const {
      length
    } = srcArray;
    for (let i = 0; i < length; ++i) {
      const elem = srcArray[i];
      functor(elem, param);
      dstArray.push(elem);
    }
  }

  // this function joins multiple complexes into one (this)
  // atom, bond, ... objects are reused -- so input complexes are no longer valid
  joinComplexes(complexes) {
    // clear target complex
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this.structures = [];
    this._atoms = [];
    this._residues = [];
    this._bonds = [];
    this._sgroups = [];
    const self = this;
    let atomBias = 0;
    let bondBias = 0;
    let residueBias = 0;
    let chainBias = 0;
    let componentBias = 0;
    function processAtom(atom, bias) {
      atom.serial += bias;
      atom.index += bias;
    }
    function processBond(bond, bias) {
      bond._index += bias;
    }
    function processResidue(residue, bias) {
      residue._index += bias;
    }
    function processChain(chain, bias) {
      chain._complex = self;
      chain._index += bias;
    }
    function processComponent(component, bias) {
      component._complex = self;
      component._index += bias;
    }

    /**
     * Simple function to do nothing.
     */
    function doNothing() {}
    for (let i = 0; i < complexes.length; ++i) {
      const c = complexes[i];
      this.addElement(c._atoms, this._atoms, atomBias, processAtom);
      this.addElement(c._bonds, this._bonds, bondBias, processBond);
      this.addElement(c._residues, this._residues, residueBias, processResidue);
      this.addElement(c._chains, this._chains, chainBias, processChain);
      this.addElement(c._sheets, this._sheets, 0, doNothing);
      this.addElement(c._helices, this._helices, 0, doNothing);
      this.addElement(c._sgroups, this._sgroups, 0, doNothing);
      this.addElement(c._components, this._components, componentBias, processComponent);
      this.addElement(c.structures, this.structures, 0, doNothing);
      // merge residue types
      for (const rt in c._residueTypes) {
        if (c._residueTypes.hasOwnProperty(rt)) {
          this._residueTypes[rt] = c._residueTypes[rt];
        }
      }
      atomBias += c._atoms.length;
      bondBias += c._bonds.length;
      residueBias += c._residues.length;
      chainBias += c._chains.length;
      componentBias += c._components.length;
    }
    this._computeBounds();
  }

  /**
   * Replace secondary structure with calculated one.
   *
   * DSSP algorithm implementation is used.
   *
   * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
   * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
   */
  dssp() {
    const ssMap = new SecondaryStructureMap(this);
    const structures = this.structures = [];
    const helices = this._helices = [];
    const sheets = this._sheets = [];
    const getSheet = index => {
      let item = sheets[index];
      if (!item) {
        item = sheets[index] = new chem_Sheet(String(index), 0);
      }
      return item;
    };
    let lastCode;
    let lastSheetIndex;
    let lastHelixIndex = 0;
    let curStructure = null;
    for (let i = 0, n = this._residues.length; i < n; ++i) {
      const curCode = ssMap._ss[i];
      const curResidue = this._residues[i];
      const curSheetIndex = ssMap._sheet[i];

      // expand the last structure
      if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
        curResidue._secondary = curStructure;
        if (curStructure) {
          curStructure.term = curResidue;
        }
        if (curStructure instanceof chem_Helix) {
          curStructure.length++;
        }
        continue;
      }

      // create a new structure
      const helixClass = helixClassMap[curCode];
      const loopType = loopMap[curCode];
      if (curCode === Complex_StructureType.STRAND) {
        const curSheet = getSheet(curSheetIndex);
        curStructure = new chem_Strand(curSheet, curResidue, curResidue, 0, null, null);
        curSheet.addStrand(curStructure);
      } else if (helixClass !== undefined) {
        lastHelixIndex++;
        curStructure = new chem_Helix(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), '', 1);
        helices.push(curStructure);
      } else if (loopType !== undefined) {
        curStructure = new chem_StructuralElement(loopType, curResidue, curResidue);
      } else {
        curStructure = null;
      }
      if (curStructure) {
        structures.push(curStructure);
      }
      curResidue._secondary = curStructure;
      lastCode = curCode;
      lastSheetIndex = curSheetIndex;
    }
    this._sheets = sheets.filter(_sheet => true); // squeeze sheets array
  }
}
Complex.prototype.id = 'Complex';
Complex.prototype.name = '';
/* harmony default export */ const chem_Complex = (Complex);
;// CONCATENATED MODULE: ./src/chem/Volume.js


function pow2ceil(v) {
  let p = 2;
  v = v - 1 >> 1;
  while (v) {
    p <<= 1;
    v >>= 1;
  }
  return p;
}

/**
 * Volume constructor
 *
 * @param {Object} type - Float32Array, Int8Array, etc...
 * @param {Object|Array} dimensions - number of data points on each axis (x, y, z)
 * @param {Box3} box - bounding box defining data place in metric space,
 *                     it's corners correspond to extreme data points
 * @param {Number} vecSize - dimension of the field data point (1 = scalar, 3 = 3D vector)
 * @param {Object} data - typed array of the same type as specified by the 1st parameter,
 *                        layout: point by point along X,
 *                                row by row along Y,
 *                                plane by plane along Z
 * @param {Number} volumeInfo - volume info values to define threshold to filter the noise
 */

class Volume {
  constructor(type, dimensions, box, vecSize, data, volumeInfo) {
    this._box = box.clone();
    this._dimVec = Math.max(Math.floor(vecSize || 1), 1);
    this._volumeInfo = volumeInfo;
    if (dimensions instanceof Array) {
      [this._dimX, this._dimY, this._dimZ] = dimensions;
    } else {
      this._dimX = dimensions.x;
      this._dimY = dimensions.y;
      this._dimZ = dimensions.z;
    }
    this._dimX = Math.max(Math.floor(this._dimX), 1);
    this._dimY = Math.max(Math.floor(this._dimY), 1);
    this._dimZ = Math.max(Math.floor(this._dimZ), 1);
    this._rowElements = this._dimVec * this._dimX;
    this._planeElements = this._rowElements * this._dimY;
    this._totalElements = this._planeElements * this._dimZ;
    this._data = data || utils.allocateTyped(type, this._totalElements);

    // override getter/setter for vector fields
    switch (this._dimVec) {
      case 1:
        break;
      case 2:
        this.getValue = function (x, y, z) {
          const idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
          return [this._data[idx], this._data[idx + 1]];
        };
        this.setValue = function (x, y, z, a, b) {
          const idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
          this._data[idx] = a;
          this._data[idx + 1] = b;
        };
        this.addValue = function (x, y, z, a, b) {
          const idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
          this._data[idx] += a;
          this._data[idx + 1] += b;
        };
        break;
      case 3:
        this.getValue = function (x, y, z) {
          const idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
          return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
        };
        this.setValue = function (x, y, z, a, b, c) {
          const idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
          this._data[idx] = a;
          this._data[idx + 1] = b;
          this._data[idx + 2] = c;
        };
        this.addValue = function (x, y, z, a, b, c) {
          const idx = x * this._dimVec + y * this._rowElements + z * this._planeElements;
          this._data[idx] += a;
          this._data[idx + 1] += b;
          this._data[idx + 2] += c;
        };
        break;
      default:
        throw new Error('Volume: invalid vector dimension');
    }
  }

  // default getter assumes it's a scalar field
  getValue(x, y, z) {
    return this._data[x + y * this._rowElements + z * this._planeElements];
  }

  // default setter assumes it's a scalar field
  setValue(x, y, z, val) {
    this._data[x + y * this._rowElements + z * this._planeElements] = val;
  }

  // default adder assumes it's a scalar field
  addValue(x, y, z, val) {
    this._data[x + y * this._rowElements + z * this._planeElements] += val;
  }
  getDimensions() {
    return [this._dimX, this._dimY, this._dimZ];
  }
  getBox() {
    return this._box;
  }
  getVolumeInfo() {
    return this._volumeInfo;
  }
  getCellSize() {
    const boxSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._box.getSize(boxSize);
    const res = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
    res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
    res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
    return res;
  }
  computeGradient() {
    if (this._dimVec !== 1) {
      // gradient can only be computed for scalar fields
      return null;
    }

    // create a 3D vector field of gradients
    const gradient = new Volume(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3);

    // calculate cell side lengths
    const vl = this.getCellSize();

    // gradient axis scaling values and averaging factors, to correctly
    // calculate the gradient for volumes with irregular cell spacing
    const vs = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z);

    // TODO Check for intended bug in VMD (min is zero)
    function clamp(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }
    const xSize = this._dimX;
    const ySize = this._dimY;
    const zSize = this._dimZ;
    const volMap = this._data;
    function _voxelValue(x, y, z) {
      return volMap[z * xSize * ySize + y * xSize + x];
    }
    for (let zi = 0; zi < zSize; ++zi) {
      const zm = clamp(zi - 1, 0, zSize - 1);
      const zp = clamp(zi + 1, 0, zSize - 1);
      for (let yi = 0; yi < ySize; ++yi) {
        const ym = clamp(yi - 1, 0, ySize - 1);
        const yp = clamp(yi + 1, 0, ySize - 1);
        for (let xi = 0; xi < xSize; ++xi) {
          const xm = clamp(xi - 1, 0, xSize - 1);
          const xp = clamp(xi + 1, 0, xSize - 1);

          // Calculate the volume gradient at each grid cell.
          // Gradients are now stored unnormalized, since we need them in pure
          // form in order to draw field lines etc.  Shading code will now have
          // to do renormalization for itself on-the-fly.

          // XXX this gradient is only correct for orthogonal grids, since
          // we're using the array index offsets rather to calculate the gradient
          // rather than voxel coordinate offsets.  This will have to be
          // re-worked for non-orthogonal datasets.

          gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
        }
      }
    }
    return gradient;
  }
  normalize() {
    const data = this._data;

    // get min/max
    let min = data[0];
    let max = data[0];
    for (let i = 1; i < data.length; ++i) {
      min = Math.min(min, data[i]);
      max = Math.max(max, data[i]);
    }
    const d = 1.0 / (max - min);
    if (d === 0) {
      return;
    }

    // normalize
    for (let i = 0; i < data.length; ++i) {
      data[i] = d * (data[i] - min);
    }
  }
  getTiledTextureStride() {
    return [this._dimX + 2, this._dimY + 2];
  }
  buildTiledTexture() {
    let tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));
    let width = tilesX * (this._dimX + 2) - 1;
    width = pow2ceil(width);
    tilesX = Math.floor(width / (this._dimX + 2));
    const tilesY = Math.ceil(this._dimZ / tilesX);
    let height = tilesY * (this._dimY + 2) - 1;
    height = pow2ceil(height);
    const data = new Uint8Array(width * height);
    let src;
    let dst;
    for (let tileRow = 0; tileRow < tilesY; ++tileRow) {
      // process each pixel row of this tile row
      for (let row = 0; row < this._dimY; ++row) {
        src = tileRow * tilesX * this._planeElements + row * this._rowElements;
        dst = width * (tileRow * (this._dimY + 2) + row);
        // copy a series of rows through several XY planes
        for (let t = 0; t < tilesX; ++t) {
          // copy one row of one XY plane
          for (let x = 0; x < this._dimX; ++x) {
            data[dst++] = 255.0 * this._data[src++];
          }

          // repeat last pixel of previous tile
          data[dst++] = 255.0 * this._data[src - 1];
          if (t < tilesX - 1) {
            // skip to the same row of next XY plane
            src += this._planeElements - this._rowElements;
            // repeat first pixel of next tile
            data[dst++] = 255.0 * this._data[src];
          }
        }
      }
    }

    // fill pixels between tile rows with copy of edge pixels
    for (let tileRow = 0; tileRow < tilesY; ++tileRow) {
      // copy last pixel row of this tile row to the following pixel row of the texture
      src = width * (tileRow * (this._dimY + 2) + this._dimY - 1);
      dst = src + width;
      for (let x = 0; x < width; ++x) {
        data[dst++] = data[src++];
      }
      if (tileRow < tilesY - 1) {
        // copy first pixel row of next tile row to the preceding pixel row of the texture
        src = width * (tileRow + 1) * (this._dimY + 2);
        dst = src - width;
        for (let x = 0; x < width; ++x) {
          data[dst++] = data[src++];
        }
      }
    }
    const texture = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DataTexture(data, width, height, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LuminanceFormat, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UnsignedByteType, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UVMapping, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ClampToEdgeWrapping, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ClampToEdgeWrapping, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter);
    texture.needsUpdate = true;
    return texture;
  }

  /* ********************************************************************************
   *
   * Methods that provide direct access to internal array (for better performance)
   *
   ******************************************************************************** */

  getData() {
    return this._data;
  }
  getDirectIdx(x, y, z) {
    return x * this._dimVec + y * this._rowElements + z * this._planeElements;
  }
  getStrideX() {
    return this._dimVec;
  }
  getStrideY() {
    return this._rowElements;
  }
  getStrideZ() {
    return this._planeElements;
  }
}
Volume.prototype.id = 'Volume';
/* harmony default export */ const chem_Volume = (Volume);
;// CONCATENATED MODULE: ./src/chem/Molecule.js
/**
 * Residue Molecule.
 *
 * @param {Complex} complex - Molecular complex this Molecule belongs to.
 * @param {String} name - Molecule's name.
 * @param {Integer} index - Molecule's index in file.
 *
 * @exports Molecule
 * @constructor
 */
class Molecule {
  constructor(complex, name, index) {
    this.complex = complex;
    this.name = name || '';
    this.residues = [];
    this.mask = 1 | 0;
    this.index = index || -1; // start with 1
  }
  forEachResidue(process) {
    const {
      residues
    } = this;
    for (let i = 0, n = residues.length; i < n; ++i) {
      process(residues[i]);
    }
  }
  collectMask() {
    let mask = 0xffffffff;
    const {
      residues
    } = this;
    for (let i = 0, n = residues.length; i < n; ++i) {
      mask &= residues[i]._mask;
    }
    this.mask = mask;
  }
}
/* harmony default export */ const chem_Molecule = (Molecule);
;// CONCATENATED MODULE: ./src/chem.js
















/* harmony default export */ const chem = ({
  Atom: chem_Atom,
  Element: chem_Element,
  Bond: chem_Bond,
  Residue: chem_Residue,
  ResidueType: chem_ResidueType,
  Chain: chem_Chain,
  Helix: chem_Helix,
  Strand: chem_Strand,
  Sheet: chem_Sheet,
  SGroup: chem_SGroup,
  Assembly: chem_Assembly,
  Complex: chem_Complex,
  Volume: chem_Volume,
  VoxelWorld: chem_VoxelWorld,
  selectors: chem_selectors,
  Molecule: chem_Molecule
});
;// CONCATENATED MODULE: ./src/gfx/CSS2DObject.js
/**
 * @author mrdoob / http://mrdoob.com/
 */


class CSS2DObject extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D {
  constructor(element) {
    super();
    const self = this;
    this._element = element;
    this._element.style.position = 'absolute';
    this.addEventListener('removed', () => {
      if (self._element.parentNode !== null) {
        self._element.parentNode.removeChild(self._element);
      }
    });
  }
  getElement() {
    return this._element;
  }

  /**
   * Sets label transparency.
   *
   * @param {number} transp    - in [0; 1] 1 means fully transparent
   */
  setTransparency(transp) {
    const el = this.getElement();
    if (el === null) {
      return;
    }
    if (transp === 1.0) {
      el.style.display = 'none';
      return;
    }
    el.style.display = 'inline';
    const op = 1.0 - transp;
    const top = op.toString();
    const op100 = op * 100;
    el.style.opacity = top;
    el.style.filter = `alpha(opacity=${op100})`; // IE fallback
  }
  clone() {
    const obj = new CSS2DObject(this._element);
    obj.copy(this);
    return obj;
  }
}
/* harmony default export */ const gfx_CSS2DObject = (CSS2DObject);
;// CONCATENATED MODULE: ./src/gfx/RCGroup.js

class RCGroup extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group {
  raycast(raycaster, intersects) {
    if (!this.visible) {
      return;
    }
    const {
      children
    } = this;
    for (let i = 0, n = children.length; i < n; ++i) {
      children[i].raycast(raycaster, intersects);
    }
  }
  enableSubset(mask, innerOnly) {
    const {
      children
    } = this;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].enableSubset) {
        children[i].enableSubset(mask, innerOnly);
      }
    }
  }
  disableSubset(mask, innerOnly) {
    const {
      children
    } = this;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].disableSubset) {
        children[i].disableSubset(mask, innerOnly);
      }
    }
  }
  isEmpty() {
    return this.children.length === 0;
  }
  updateToFrame(frameData) {
    const {
      children
    } = this;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].updateToFrame) {
        children[i].updateToFrame(frameData);
      }
    }
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        Array.prototype.push.apply(totalSubset, children[i].getSubset(mask, innerOnly));
      }
    }
    return totalSubset;
  }
}
/* harmony default export */ const gfx_RCGroup = (RCGroup);
;// CONCATENATED MODULE: ./src/gfx/shaders/ScreenQuad.vert
const ScreenQuad_namespaceObject = "uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec2 uv;\r\nattribute vec3 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/ScreenQuadFromTex.frag
const ScreenQuadFromTex_namespaceObject = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color = texture2D(srcTex, vUv);\r\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/ScreenQuadFromTexWithDistortion.frag
const ScreenQuadFromTexWithDistortion_namespaceObject = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float coef;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  float r2 = dot(uv, uv);\r\n  vec2 tc = uv * (1.0 + coef * r2);\r\n  if (!all(lessThan(abs(tc), vec2(1.0))))\r\n    discard;\r\n  tc = 0.5 * (tc + 1.0);\r\n  gl_FragColor = texture2D(srcTex, tc);\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/gfxutils.js
/* eslint-disable no-magic-numbers */







const LAYERS = {
  DEFAULT: 0,
  VOLUME: 1,
  TRANSPARENT: 2,
  PREPASS_TRANSPARENT: 3,
  VOLUME_BFPLANE: 4,
  COLOR_FROM_POSITION: 5,
  SHADOWMAP: 6
};
const SELECTION_LAYERS = [
// These layers, that are used in the selection by ray casting
LAYERS.DEFAULT, LAYERS.TRANSPARENT];
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D.prototype.resetTransform = function () {
  this.position.set(0, 0, 0);
  this.quaternion.set(0, 0, 0, 1);
  this.scale.set(1, 1, 1);
};

// update world matrix of this object and all its ancestors
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D.prototype.updateMatrixWorldRecursive = function () {
  if (this.parent != null) {
    this.parent.updateMatrixWorldRecursive();
  }
  this.updateMatrixWorld();
};
// add object to parent, saving objects' world transform
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D.prototype.addSavingWorldTransform = function () {
  const _worldMatrixInverse = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  return function (object) {
    if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D) {
      _worldMatrixInverse.copy(this.matrixWorld).invert();
      _worldMatrixInverse.multiply(object.matrixWorld);
      object.matrix.copy(_worldMatrixInverse);
      object.matrix.decompose(object.position, object.quaternion, object.scale);
      this.add(object);
    }
  };
}();

// render a tiny transparent quad in the center of the screen
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderDummyQuad = function () {
  const _material = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MeshBasicMaterial({
    transparent: true,
    opacity: 0.0,
    depthWrite: false
  });
  const _scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const _quad = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(0.01, 0.01), _material);
  _scene.add(_quad);
  const _camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
  _camera.position.z = 100;
  return function () {
    this.render(_scene, _camera);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderScreenQuad = function () {
  const _scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const _quad = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(1.0, 1.0));
  _scene.add(_quad);
  const _camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10000, 10000);
  _camera.position.z = 100;
  return function (material) {
    _quad.material = material;
    this.render(_scene, _camera);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4.prototype.isIdentity = function () {
  const identity = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  return function () {
    return identity.equals(this);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4.prototype.applyToPointsArray = function (array, stride, w) {
  if (!array || !stride || stride < 3) {
    return array;
  }
  w = w || 0; // use point as normal by default
  const e = this.elements;
  for (let i = 0; i < array.length; i += stride) {
    const x = array[i];
    const y = array[i + 1];
    const z = array[i + 2];
    const persp = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    array[i] = (e[0] * x + e[4] * y + e[8] * z + e[12] * w) * persp;
    array[i + 1] = (e[1] * x + e[5] * y + e[9] * z + e[13] * w) * persp;
    array[i + 2] = (e[2] * x + e[6] * y + e[10] * z + e[14] * w) * persp;
  }
  return array;
};
class ScreenQuadMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    if (params.uniforms === undefined) {
      params.uniforms = {};
    }
    params.uniforms.srcTex = {
      type: 't',
      value: null
    };
    params.vertexShader = ScreenQuad_namespaceObject;
    params.transparent = false;
    params.depthTest = false;
    params.depthWrite = false;
    super(params);
  }
}
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderScreenQuadFromTex = function () {
  const _material = new ScreenQuadMaterial({
    uniforms: {
      opacity: {
        type: 'f',
        value: 1.0
      }
    },
    fragmentShader: ScreenQuadFromTex_namespaceObject,
    transparent: true
  });
  return function (srcTex, opacity) {
    _material.uniforms.srcTex.value = srcTex;
    _material.transparent = opacity < 1.0;
    _material.uniforms.opacity.value = opacity;
    this.renderScreenQuad(_material);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function () {
  const _material = new ScreenQuadMaterial({
    uniforms: {
      coef: {
        type: 'f',
        value: 1.0
      }
    },
    fragmentShader: ScreenQuadFromTexWithDistortion_namespaceObject
  });
  return function (srcTex, coef) {
    _material.uniforms.srcTex.value = srcTex;
    _material.uniforms.coef.value = coef;
    this.renderScreenQuad(_material);
  };
}();

/**
 * @param {number} angle - Field of view in degrees.
 */
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera.prototype.setMinimalFov = function (angle) {
  if (this.aspect >= 1.0) {
    this.fov = angle;
  } else {
    this.fov = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.radToDeg(2 * Math.atan(Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.degToRad(angle) * 0.5) / this.aspect));
  }
};

/**
 * @param {THREE.PerspectiveCamera} camera - Base camera for this stereo camera.
 * @param {number} angle - Field of view in degrees.
 */
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.StereoCamera.prototype.updateHalfSized = function (camera, angle) {
  const originalAspect = camera.aspect;
  const originalFov = camera.fov;
  camera.aspect = originalAspect / 2.0;
  camera.setMinimalFov(angle);
  camera.updateProjectionMatrix();
  this.update(camera);
  camera.aspect = originalAspect;
  camera.fov = originalFov;
  camera.updateProjectionMatrix();
};

/**
 * @param {number} radius - Radius of bounding sphere in angstroms to fit on screen.
 * @param {number} angle - Field of view in degrees.
 */
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera.prototype.setDistanceToFit = function (radius, angle) {
  this.position.z = radius / Math.sin(0.5 * external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.degToRad(angle));
};

/**
 * @param {RCGroup} gfxObj - All objects on scene.
 * @param {THREE.PerspectiveCamera} camera - Camera used for rendering.
 * @param {number} clipPlane - Distance to clip plane.
 * @param {number} fogFarPlane - Distance to fog far plane.
 */
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Raycaster.prototype.intersectVisibleObject = function (gfxObj, camera, clipPlane, fogFarPlane) {
  const intersects = this.intersectObject(gfxObj, false);
  if (intersects.length === 0) {
    return null;
  }

  // find point closest to camera that doesn't get clipped by camera near plane or clipPlane (if it exists)
  const nearPlane = Math.min(camera.near, clipPlane);
  let i;
  let p = intersects[0];
  const v = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  for (i = 0; i < intersects.length; ++i) {
    p = intersects[i];
    v.copy(p.point);
    v.applyMatrix4(camera.matrixWorldInverse);
    if (v.z <= -nearPlane) {
      break;
    }
  }
  if (i === intersects.length) {
    return null;
  }

  // check that selected intersection point is not clipped by camera far plane or occluded by fog (if it exists)
  const farPlane = Math.min(camera.far, fogFarPlane);
  v.copy(p.point);
  v.applyMatrix4(camera.matrixWorldInverse);
  if (v.z <= -farPlane) {
    return null;
  }
  return p;
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4.prototype.extractScale = function () {
  const _v = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (scale) {
    if (scale === undefined) {
      logger.debug('extractScale(): new is too expensive operation to do it on-the-fly');
      scale = _v.clone();
    }
    const te = this.elements;
    scale.x = _v.set(te[0], te[1], te[2]).length();
    scale.y = _v.set(te[4], te[5], te[6]).length();
    scale.z = _v.set(te[8], te[9], te[10]).length();

    // if determine is negative, we need to invert one scale
    const det = this.determinant();
    if (det < 0) {
      scale.x = -scale.x;
    }
    return scale;
  };
}();
function _calcCylinderMatrix(posBegin, posEnd, radius) {
  const posCenter = posBegin.clone().lerp(posEnd, 0.5);
  const matScale = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
  const matRotHalf = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matRotHalf.makeRotationX(Math.PI / 2);
  const matRotLook = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  const vUp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0);
  matRotLook.lookAt(posCenter, posEnd, vUp);
  matRotLook.multiply(matRotHalf);
  matRotLook.multiply(matScale);
  matRotLook.setPosition(posCenter);
  return matRotLook;
}
function _calcChunkMatrix(eye, target, up, rad) {
  const matScale = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matScale.makeScale(rad.x, rad.y, 0);
  const matRotLook = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matRotLook.lookAt(eye, target, up);
  matRotLook.multiply(matScale);
  matRotLook.setPosition(eye);
  return matRotLook;
}
function _groupHasGeometryToRender(group) {
  let hasGeoms = false;
  group.traverse(node => {
    if (node.hasOwnProperty('geometry') || node instanceof gfx_CSS2DObject) {
      hasGeoms = true;
    }
  });
  return hasGeoms;
}
function _buildDistorionMesh(widthSegments, heightSegements, coef) {
  // solve equation r_u = r_d * (1 + k * r_d^2)
  // for r_d using iterations
  // takes: r_u^2
  // returns: r_d / r_u  factor that can be used to distort point coords
  function calcInverseBarrel(r2) {
    const epsilon = 1e-5;
    let prevR2 = 0.0;
    let curR2 = r2;
    let dr = 1.0;
    while (Math.abs(curR2 - prevR2) > epsilon) {
      dr = 1.0 + coef * curR2;
      prevR2 = curR2;
      curR2 = r2 / (dr * dr);
    }
    return 1.0 / dr;
  }
  const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(2.0, 2.0, widthSegments, heightSegements);
  const pos = geo.getAttribute('position');
  for (let i = 0; i < pos.count; ++i) {
    const x = pos.array[3 * i];
    const y = pos.array[3 * i + 1];
    const c = calcInverseBarrel(x * x + y * y);
    pos.setXY(i, c * x, c * y);
  }
  return geo;
}
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute.prototype.copyAtList = function (attribute, indexList) {
  console.assert(this.itemSize === attribute.itemSize, 'DEBUG: BufferAttribute.copyAtList buffers have different item size.');
  const {
    itemSize
  } = this;
  for (let i = 0, n = indexList.length; i < n; ++i) {
    for (let j = 0; j < itemSize; ++j) {
      this.array[i * itemSize + j] = attribute.array[indexList[i] * itemSize + j];
    }
  }
  return this;
};
function fillArray(array, value, startIndex, endIndex) {
  startIndex = typeof startIndex !== 'undefined' ? startIndex : 0;
  endIndex = typeof endIndex !== 'undefined' ? endIndex : array.length;
  for (let i = startIndex; i < endIndex; ++i) {
    array[i] = value;
  }
}

/** @param {THREE.Object3D} object - Parent object. */
function removeChildren(object) {
  const {
    children
  } = object;
  for (let i = 0, n = children.length; i < n; ++i) {
    const child = children[i];
    child.parent = null;
    child.dispatchEvent({
      type: 'removed'
    });
  }
  object.children = [];
}
function clearTree(object) {
  object.traverse(obj => {
    if (obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line) {
      obj.geometry.dispose();
    }
  });
  removeChildren(object);
}
function destroyObject(object) {
  clearTree(object);
  if (object.parent) {
    object.parent.remove(object);
  } else {
    object.dispatchEvent({
      type: 'removed'
    });
  }
}
function belongToSelectLayers(object) {
  for (let i = 0; i < SELECTION_LAYERS.length; i++) {
    if ((object.layers.mask >> SELECTION_LAYERS[i] & 1) === 1) {
      return true;
    }
  }
  return false;
}
function processObjRenderOrder(root, idMaterial) {
  // set renderOrder to 0 for Backdrop and to 1 in other cases to render Backdrop earlier all other materials
  const renderOrder = +(idMaterial !== 'BA');
  root.traverse(object => {
    if (object.isGroup) {
      object.renderOrder = renderOrder;
    }
  });
}
function applySelectionMaterial(geo) {
  geo.traverse(node => {
    if ('material' in node) {
      node.material = node.material.clone(true);
      // using z-offset to magically fix selection rendering artifact (on z-sprites)
      node.material.setValues({
        depthFunc: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LessEqualDepth,
        overrideColor: true,
        fog: false,
        lights: false,
        shadowmap: false
      });
      node.material.setUberOptions({
        fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0xFFFF00),
        zOffset: -1e-6
      });
    }
  });
}
function getMiddlePoint(point1, point2, optionalTarget) {
  const result = optionalTarget || new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  result.set(0, 0, 0);
  result.addScaledVector(point1, 0.5);
  result.addScaledVector(point2, 0.5);
  return result;
}

// Monkey-patch for "InstancedBufferGeometry.instanceCount becomes undefined after copy()"
// https://github.com/mrdoob/three.js/issues/22151
const _oldInstancedBufferGeometryCopy = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry.prototype.copy;
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry.prototype.copy = function (source) {
  _oldInstancedBufferGeometryCopy.call(this, source);
  if (this.instanceCount === undefined) {
    this.instanceCount = Infinity;
  }
};
/* harmony default export */ const gfxutils = ({
  calcCylinderMatrix: _calcCylinderMatrix,
  calcChunkMatrix: _calcChunkMatrix,
  groupHasGeometryToRender: _groupHasGeometryToRender,
  buildDistorionMesh: _buildDistorionMesh,
  RCGroup: gfx_RCGroup,
  fillArray,
  clearTree,
  destroyObject,
  belongToSelectLayers,
  processObjRenderOrder,
  applySelectionMaterial,
  getMiddlePoint,
  LAYERS
});
;// CONCATENATED MODULE: ./src/Visual.js


const _defaultBoundaries = {
  boundingBox: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1, -1, -1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 1, 1)),
  boundingSphere: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0), 1)
};
class Visual extends gfxutils.RCGroup {
  constructor(name, dataSource) {
    super(name, dataSource);
    this.name = name;
    this._dataSource = dataSource;
  }
  release() {
    if (this.parent) {
      this.parent.remove(this);
    }
  }
  getDataSource() {
    return this._dataSource;
  }
  getBoundaries() {
    return _defaultBoundaries;
  }
}
/* harmony default export */ const src_Visual = (Visual);
;// CONCATENATED MODULE: ./src/utils/EntityList.js
function _ensureArray(x) {
  if (x === null || x === undefined || Array.isArray(x)) {
    return x;
  }
  return [x];
}

/** An indexed list of objects or classes. */
class EntityList {
  /**
   * Create a list of objects.
   * The objects can be indexed by one or more properties for the later retrieval.
   *
   * @param {!Array<Object>=} entities A list of objects to automatically register at creation time.
   * @param {!Array<string>=} indices A list of property names to use for case-insensitive indexing.
   *   By default, a single `.id` property is used.
   * @see EntityList#register
   */
  constructor() {
    let entities = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['id'];
    this._list = [];
    this._dict = {};
    this._indices = [...indices];
    this._indices.forEach(index => {
      this._dict[index] = {};
    });
    entities.forEach(entity => this.register(entity));
  }

  /**
   * Add a value to the end of a list.
   * The list will contain only one copy of the value.
   *
   * @param {!Array} list An array.
   * @param {*} value A value to add.
   * @see EntityList.unregisterFromList
   * @see EntityList.registerInDict
   */
  static registerInList(list, value) {
    if (!list.includes(value)) {
      list.push(value);
    }
  }

  /**
   * Remove a value from a list if it is there.
   *
   * @param {!Array} list An array.
   * @param {*} value A value to remove.
   * @see EntityList.registerInList
   */
  static unregisterFromList(list, value) {
    const pos = list.indexOf(value);
    if (pos !== -1) {
      list.splice(pos, 1);
    }
  }

  /**
   * Add a value to a dictionary.
   * The value may be stored under multiple different keys (aliases).
   * There might be multiples values stored under the same key.
   *
   * @param {!Object<string,*>} dict A dictionary.
   * @param {!Array<string>} keys An array of keys.
   * @param {*} value A value to add.
   * @see EntityList.unregisterFromDict
   * @see EntityList.registerInList
   */
  static registerInDict(dict, keys, value) {
    keys.forEach(key => {
      key = key.toLowerCase();
      const list = dict[key] = dict[key] || [];
      if (!list.includes(value)) {
        list.push(value);
      }
    });
  }

  /**
   * Remove a value from a dictionary.
   * The value may be stored under multiple different keys (aliases).
   * There might be multiples values stored under the same key.
   *
   * @param {!Object<string,*>} dict A dictionary.
   * @param {!Array<string>} keys An array of keys.
   * @param {*} value A value to add.
   * @see EntityList.registerInDict
   */
  static unregisterFromDict(dict, keys, value) {
    keys.forEach(key => {
      key = key.toLowerCase();
      const list = dict[key];
      if (list) {
        const pos = list.indexOf(value);
        if (pos !== -1) {
          list.splice(pos, 1);
        }
        if (list.length === 0) {
          delete dict[key];
        }
      }
    });
  }

  /**
   * Add an entity to this list.
   *
   * @param {!Object} entity An object or a class to register. The object must include all
   *   properties specified as indices on construction.
   * @see EntityList#unregister
   */
  register(entity) {
    EntityList.registerInList(this._list, entity);
    this._indices.forEach(index => {
      EntityList.registerInDict(this._dict[index], _ensureArray(entity[index]), entity);
    });
  }

  /**
   * Remove an entity from this list.
   *
   * @param {!Object} entity An object or a class to unregister. The object may be
   *   missing from the list but it must include all properties specified as indices
   *   on construction.
   * @see EntityList#register
   */
  unregister(entity) {
    EntityList.unregisterFromList(this._list, entity);
    this._indices.forEach(index => {
      EntityList.unregisterFromDict(this._dict[index], _ensureArray(entity[index]), entity);
    });
  }

  /**
   * An ordered list of all registered entities.
   * It is a read-only copy, use {@link EntityList#register} and {@link EntityList#unregister}
   * to modify it.
   *
   * @type {!Array<Object>}
   */
  get all() {
    return [...this._list];
  }

  /**
   * The first registered entity.
   * Use it if you do not care which entity you are referring to.
   *
   * @type {Object=}
   */
  get first() {
    return this._list[0];
  }

  /**
   * Retrieve a list of keys for the index.
   *
   * @param {string=} index One of the indices specified during the list construction. If omitted,
   *   the first of the indices is used.
   * @returns {!Array<string>} An unordered list of keys in the index, i.e. particular property
   *   values for all registered entities.
   */
  keys(index) {
    return Object.keys(this._dict[index || this._indices[0]]);
  }

  /**
   * Retrieve an entity by its key.
   *
   * @param {string} key A case-insensitive property value to look-up.
   * @param {string=} index One of the indices specified during the list construction. If omitted,
   *   the first of the indices is used.
   * @returns {Object=} An object registered in the index under the key. If there are multiple
   *   objects under the same key, the first one is returned.
   */
  get(key, index) {
    const dict = this._dict[index || this._indices[0]];
    if (dict) {
      const values = dict[key && key.toLowerCase()];
      return values && values.length > 0 ? values[0] : undefined;
    }
    return undefined;
  }
}
/* harmony default export */ const utils_EntityList = (EntityList);
;// CONCATENATED MODULE: ./src/utils/makeContextDependent.js


function makeContextDependent(prototype) {
  Object.defineProperties(prototype, {
    logger: {
      get() {
        return this.context && this.context.logger ? this.context.logger : logger;
      }
    },
    settings: {
      get() {
        return this.context && this.context.settings ? this.context.settings : settings;
      }
    }
  });
}
/* harmony default export */ const utils_makeContextDependent = (makeContextDependent);
;// CONCATENATED MODULE: ./src/gfx/geometries/SphereCollisionGeo.js

class CollisionSphere {
  constructor(position, radius) {
    this._position = position;
    this._radius = radius;
  }
  static _sphere = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere())();
  raycast(raycaster) {
    const sphere = CollisionSphere._sphere;
    sphere.set(this._position, this._radius);
    const p = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    if (raycaster.ray.intersectSphere(sphere, p)) {
      return {
        distance: raycaster.ray.origin.distanceTo(p),
        point: p
      };
    }
    return null;
  }
}
const SphereCollisionGeo = base => class extends base {
  constructor(count) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    super(...args);
    this._objects = new Array(count);
    this.boundingSphere = null;
    this.boundingBox = null;
  }
  setSphere(idx, position, radius) {
    this._objects[idx] = new CollisionSphere(position, radius);
  }
  raycast(raycaster, intersects) {
    // TODO raycast with bounding sphere? How to deal with updates?
    for (let i = 0, n = this._objects.length; i < n; ++i) {
      const inters = this._objects[i].raycast(raycaster);
      if (inters) {
        inters.chunkIdx = i;
        intersects.push(inters);
      }
    }
  }
  computeBoundingBox() {
    const objects = this._objects;
    let {
      boundingBox
    } = this;
    if (boundingBox === null) {
      this.boundingBox = boundingBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
    }
    boundingBox.makeEmpty();
    for (let i = 0, n = objects.length; i < n; ++i) {
      boundingBox.expandByPoint(objects[i]._position);
    }
  }
  computeBoundingSphere() {
    this.computeBoundingBox();
    const objects = this._objects;
    const {
      boundingBox
    } = this;
    // Build bounding sphere
    let radiusSquared = 0.0;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    boundingBox.getCenter(center);
    for (let i = 0, n = objects.length; i < n; ++i) {
      const pos = objects[i]._position;
      const lengthSquared = center.distanceToSquared(pos);
      if (radiusSquared < lengthSquared) {
        radiusSquared = lengthSquared;
      }
    }
    if (this.boundingSphere === null) {
      this.boundingSphere = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
    }
    this.boundingSphere.set(center, Math.sqrt(radiusSquared));
  }
};
/* harmony default export */ const geometries_SphereCollisionGeo = (SphereCollisionGeo);
;// CONCATENATED MODULE: ./src/gfx/geometries/InstancedSpheresGeometry.js




const tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
const OFFSET_SIZE = 4;
const COLOR_SIZE = 3;
const {
  copySubArrays: InstancedSpheresGeometry_copySubArrays
} = utils;
function setArrayXYZ(arr, idx, x, y, z) {
  arr[idx] = x;
  arr[idx + 1] = y;
  arr[idx + 2] = z;
}
function setArrayXYZW(arr, idx, x, y, z, w) {
  arr[idx] = x;
  arr[idx + 1] = y;
  arr[idx + 2] = z;
  arr[idx + 3] = w;
}
class InstancedSpheresGeometry extends geometries_SphereCollisionGeo(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry) {
  constructor(spheresCount, sphereComplexity, useZSprites) {
    super(spheresCount);
    this._sphGeometry = useZSprites ? new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(2, 2, 1, 1) : new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
    this._init(spheresCount, this._sphGeometry);
  }
  setItem(itemIdx, itemPos, itemRad) {
    setArrayXYZW(this._offsets, itemIdx * OFFSET_SIZE, itemPos.x, itemPos.y, itemPos.z, itemRad);
    this.setSphere(itemIdx, itemPos, itemRad);
  }
  setColor(itemIdx, colorVal) {
    tmpColor.set(colorVal);
    setArrayXYZ(this._colors, itemIdx * COLOR_SIZE, tmpColor.r, tmpColor.g, tmpColor.b);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute('offset').needsUpdate = true;
    this.getAttribute('color').needsUpdate = true;
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const alphaArr = this._alpha;
    for (let i = 0, n = chunkIndices.length; i < n; ++i) {
      alphaArr[chunkIndices[i]] = value;
    }
    this.getAttribute('alphaColor').needsUpdate = true;
  }
  getSubset(chunkIndices) {
    const instanceCount = chunkIndices.length;
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry();
    this._init.call(geom, instanceCount, this._sphGeometry);
    InstancedSpheresGeometry_copySubArrays(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE);
    InstancedSpheresGeometry_copySubArrays(this._colors, geom._colors, chunkIndices, COLOR_SIZE);
    geom.boundingSphere = this.boundingSphere;
    geom.boundingBox = this.boundingBox;
    return [geom];
  }
  _init(spheresCount, sphereGeo) {
    this.copy(sphereGeo);
    this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE);
    this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1.0);
    this.setAttribute('offset', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._offsets, OFFSET_SIZE, false, 1));
    this.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._colors, COLOR_SIZE, false, 1));
    this.setAttribute('alphaColor', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(alpha, 1, false, 1));
  }
}
/* harmony default export */ const geometries_InstancedSpheresGeometry = (InstancedSpheresGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/ChunkedObjectsGeometry.js



const MAX_IDC_16BIT = 65535;
const VEC_SIZE = 3;
const ChunkedObjectsGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();

/**
 * This class represents geometry which consists of separate chunks.
 * Each chunk has same index and similar geometry with equal points and faces count.
 * Each chunk has by default only one color.
 * @constructor
 */

class ChunkedObjectsGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(chunkGeo, chunksCount) {
    super();
    if (this.constructor === ChunkedObjectsGeometry) {
      throw new Error('Can not instantiate abstract class!');
    }
    this._chunkGeo = chunkGeo;
    this._init(chunkGeo, chunksCount);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute('position').needsUpdate = true;
    this.getAttribute('normal').needsUpdate = true;
    this.getAttribute('color').needsUpdate = true;
  }
  setColor(chunkIdx, colorVal) {
    ChunkedObjectsGeometry_tmpColor.set(colorVal);
    const colors = this._colors;
    const chunkSize = this._chunkSize;
    for (let i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
      const idx = i * VEC_SIZE;
      colors[idx] = ChunkedObjectsGeometry_tmpColor.r;
      colors[idx + 1] = ChunkedObjectsGeometry_tmpColor.g;
      colors[idx + 2] = ChunkedObjectsGeometry_tmpColor.b;
    }
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const alphaArr = this._alpha;
    const chunkSize = this._chunkSize;
    for (let i = 0, n = chunkIndices.length; i < n; ++i) {
      const left = chunkIndices[i] * chunkSize;
      external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alphaArr, value, left, left + chunkSize);
    }
    this.getAttribute('alphaColor').needsUpdate = true;
  }
  raycast(raycaster, intersects) {
    const inters = [];
    // use THREE.Mesh raycasting interface for the Geometry. The Mesh is
    // created with existed geometry and default material, so it doesn't slowdown.
    const mesh = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh();
    mesh.geometry = this;
    mesh.raycast(raycaster, inters);
    const facesPerChunk = this._chunkGeo.index.count / 3;
    for (let i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('faceIndex')) {
        continue;
      }
      inters[i].chunkIdx = Math.floor(inters[i].faceIndex / facesPerChunk);
      intersects.push(inters[i]);
    }
  }
  getSubset(chunkIndices) {
    const instanceCount = chunkIndices.length;
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    this._init.call(geom, this._chunkGeo, instanceCount);
    const srcPos = this._positions;
    const srcNorm = this._normals;
    const srcColor = this._colors;
    const dstPos = geom._positions;
    const dstNorm = geom._normals;
    const dstColor = geom._colors;
    const chunkSize = this._chunkSize * VEC_SIZE;
    for (let i = 0, n = chunkIndices.length; i < n; ++i) {
      const dstPtOffset = i * chunkSize;
      const ptIdxBegin = chunkIndices[i] * chunkSize;
      const ptIdxEnd = ptIdxBegin + chunkSize;
      dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
      dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
      dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
    }
    geom.boundingSphere = this.boundingSphere;
    geom.boundingBox = this.boundingBox;
    return [geom];
  }
  _init(chunkGeo, chunksCount) {
    const chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
    const chunkIndex = chunkGeo.index.array;
    const chunkIndexSize = chunkIndex.length;
    const pointsCount = this._chunkSize * chunksCount;
    const use32bitIndex = pointsCount > MAX_IDC_16BIT;
    const indexSize = chunkIndexSize * chunksCount;
    const index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
    this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
    this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
    this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1.0);
    for (let i = 0; i < chunksCount; ++i) {
      const offset = i * chunkIndexSize;
      const posOffset = i * chunkSize;
      index.set(chunkIndex, offset);
      for (let j = 0; j < chunkIndexSize; ++j) {
        index[offset + j] += posOffset;
      }
    }
    this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._index, 1));
    this.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._positions, VEC_SIZE));
    this.setAttribute('normal', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._normals, VEC_SIZE));
    this.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._colors, VEC_SIZE));
    this.setAttribute('alphaColor', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(alpha, 1));
  }
}
/* harmony default export */ const geometries_ChunkedObjectsGeometry = (ChunkedObjectsGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/SimpleSpheresGeometry.js




const SimpleSpheresGeometry_VEC_SIZE = 3;
class SimpleSpheresGeometry extends geometries_SphereCollisionGeo(geometries_ChunkedObjectsGeometry) {
  constructor(spheresCount, sphereComplexity) {
    const sphGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
    super(spheresCount, sphGeometry, spheresCount);
    const normals = this._normals;
    const geoNormals = sphGeometry.attributes.normal.array;
    const chunkSize = this._chunkSize;
    this._chunkPos = this._chunkGeo.attributes.position.array;
    this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * SimpleSpheresGeometry_VEC_SIZE);
    for (let i = 0; i < spheresCount; ++i) {
      normals.set(geoNormals, chunkSize * SimpleSpheresGeometry_VEC_SIZE * i);
    }
  }
  setItem(itemIdx, itemPos, itemRad) {
    const tmpPos = this._tmpPositions;
    const chunkSize = this._chunkSize;
    const geoPos = this._chunkPos;
    for (let i = 0; i < chunkSize; ++i) {
      const idx = i * 3;
      tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
      tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
      tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
    }
    this._positions.set(tmpPos, chunkSize * itemIdx * SimpleSpheresGeometry_VEC_SIZE);
    this.setSphere(itemIdx, itemPos, itemRad);
  }
}
/* harmony default export */ const geometries_SimpleSpheresGeometry = (SimpleSpheresGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/Simple2CCylindersGeometry.js




const Simple2CCylindersGeometry_VEC_SIZE = 3;
const centerPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const tmpVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const normMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
class Simple2CCylindersGeometry extends geometries_ChunkedObjectsGeometry {
  constructor(instanceCount, polyComplexity) {
    const cylGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.CylinderGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
    super(cylGeometry, 2 * instanceCount);
    const chunkSize = this._chunkSize;
    this._chunkPos = this._chunkGeo.attributes.position.array;
    this._chunkNorms = this._chunkGeo.attributes.normal.array;
    this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * Simple2CCylindersGeometry_VEC_SIZE);
  }
  setItem(itemIdx, botPos, topPos, itemRad) {
    const chunkSize = this._chunkSize;
    const firstOffset = chunkSize * 2 * itemIdx * Simple2CCylindersGeometry_VEC_SIZE;
    const secondOffset = firstOffset + chunkSize * Simple2CCylindersGeometry_VEC_SIZE;
    const tmpArray = this._tmpVector;
    const geoPos = this._chunkPos;
    const geoNorm = this._chunkNorms;
    centerPos.lerpVectors(botPos, topPos, 0.5);
    const mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
    normMtx.getNormalMatrix(mtx1);
    let idx;
    for (let i = 0; i < chunkSize; ++i) {
      idx = i * Simple2CCylindersGeometry_VEC_SIZE;
      tmpVector.fromArray(geoPos, idx);
      tmpVector.applyMatrix4(mtx1);
      tmpVector.toArray(tmpArray, idx);
    }
    this._positions.set(tmpArray, firstOffset);

    // now shift center to get another part of the cylinder
    centerPos.sub(botPos);
    for (let i = 0; i < chunkSize; ++i) {
      idx = i * Simple2CCylindersGeometry_VEC_SIZE;
      tmpArray[idx] += centerPos.x;
      tmpArray[idx + 1] += centerPos.y;
      tmpArray[idx + 2] += centerPos.z;
    }
    this._positions.set(tmpArray, secondOffset);
    for (let i = 0; i < chunkSize; ++i) {
      idx = i * Simple2CCylindersGeometry_VEC_SIZE;
      tmpVector.fromArray(geoNorm, idx);
      tmpVector.applyMatrix3(normMtx);
      tmpVector.toArray(tmpArray, idx);
    }
    this._normals.set(tmpArray, firstOffset);
    this._normals.set(tmpArray, secondOffset);
  }
  setColor(itemIdx, colorVal1, colorVal2) {
    const first = 2 * itemIdx;
    super.setColor(first, colorVal1);
    const second = first + 1;
    super.setColor(second, colorVal2);
  }
}
/* harmony default export */ const geometries_Simple2CCylindersGeometry = (Simple2CCylindersGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/CylinderBufferGeometry.js


const MAX_POINTS_COUNT_16BIT = 65536;
const PTS_PER_TRIANGLE = 3;
class CylinderBufferGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
    super();
    const thetaStart = 0;
    const thetaLength = 2 * Math.PI;
    this.type = 'CylinderBufferGeometry';
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded
    };
    const hasTop = openEnded === false && radiusTop > 0;
    const hasBottom = openEnded === false && radiusBottom > 0;
    const vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
    const facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
    const heightHalf = height / 2;

    /* eslint-disable no-magic-numbers */
    const positions = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    const normals = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    const indices = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
    /* eslint-enable no-magic-numbers */

    const uvs = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
    console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, 'DEBUG: Cylinder Geometry has too many vertices (65536 max).');
    let currVtxIdx = 0;
    let currFaceIdx = 0;
    const tanTheta = -(radiusBottom - radiusTop) / height;

    // setup cylinder data
    for (let y = 0; y <= heightSegments; y++) {
      // faces
      if (y !== heightSegments) {
        for (let i = 0; i < radialSegments; i++) {
          const v1 = currVtxIdx + i;
          const v2 = currVtxIdx + radialSegments + i;
          const v3 = currVtxIdx + radialSegments + (i + 1) % radialSegments;
          const v4 = currVtxIdx + (i + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v2);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v2, v4, v3);
          currFaceIdx++;
        }
      }

      // vertices
      const v = y / heightSegments;
      const radius = v * (radiusBottom - radiusTop) + radiusTop;
      for (let x = 0; x < radialSegments; x++) {
        const u = x / radialSegments;
        const vx = radius * Math.sin(u * thetaLength + thetaStart);
        const vy = v * height - heightHalf;
        const vz = radius * Math.cos(u * thetaLength + thetaStart);
        const normal = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
        positions.setXYZ(currVtxIdx, vx, vy, vz);
        normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
        uvs.setXY(currVtxIdx, u, v);
        ++currVtxIdx;
      }
    }

    // top cap
    if (hasTop) {
      const startTIdx = currVtxIdx;
      const lastIdx = currVtxIdx + radialSegments;
      for (let fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
        const currSrcIdx = currVtxIdx - radialSegments;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        const nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, 1, 0);
      uvs.setXY(currVtxIdx, 1, 1);
      ++currVtxIdx;
    }

    // bottom cap
    if (hasBottom) {
      const startBIdx = currVtxIdx;
      const lastBIdx = currVtxIdx + radialSegments;
      for (let fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
        const currSrcBIdx = fBIdx;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
        const nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, -1, 0);
      uvs.setXY(currVtxIdx, 0, 0);
    }
    this.setIndex(indices);
    this.setAttribute('position', positions);
    this.setAttribute('normal', normals);
    this.setAttribute('uv', uvs);
  }
  clone() {
    const {
      parameters
    } = this;
    return new CylinderBufferGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
  }
}
/* harmony default export */ const geometries_CylinderBufferGeometry = (CylinderBufferGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/Instanced2CCylindersGeometry.js






const Instanced2CCylindersGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
const invMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
const Instanced2CCylindersGeometry_OFFSET_SIZE = 4;
const Instanced2CCylindersGeometry_COLOR_SIZE = 3;
const {
  copySubArrays: Instanced2CCylindersGeometry_copySubArrays
} = utils;
function Instanced2CCylindersGeometry_setArrayXYZ(arr, idx, x, y, z) {
  arr[idx] = x;
  arr[idx + 1] = y;
  arr[idx + 2] = z;
}
function Instanced2CCylindersGeometry_setArrayXYZW(arr, idx, x, y, z, w) {
  arr[idx] = x;
  arr[idx + 1] = y;
  arr[idx + 2] = z;
  arr[idx + 3] = w;
}
function sortNumber(a, b) {
  return a - b;
}
function _prepareCylinderInfo(chunkIndices) {
  chunkIndices.sort(sortNumber);
  const chunksIdx = [];
  const cylinderInfo = [];
  for (let i = 0, n = chunkIndices.length; i < n; ++i) {
    const val = chunkIndices[i];
    const even = (val | 0) % 2 === 0;
    const newPar = {
      first: false,
      second: false
    };
    if (even) {
      newPar.first = true;
      newPar.second = i + 1 < n && chunkIndices[i + 1] === chunkIndices[i] + 1;
      if (newPar.second) {
        ++i;
      }
    } else {
      newPar.second = true;
    }
    chunksIdx.push(Math.floor(val / 2));
    cylinderInfo.push(newPar);
  }
  return {
    indices: chunksIdx,
    cylinderInfo
  };
}
function _assignOpacity(cylinderInfo, color1, color2) {
  for (let i = 0, n = cylinderInfo.length; i < n; ++i) {
    const info = cylinderInfo[i];
    if (!info.first) {
      color1[Instanced2CCylindersGeometry_COLOR_SIZE * i] = -0.5;
    }
    if (!info.second) {
      color2[Instanced2CCylindersGeometry_COLOR_SIZE * i] = -0.5;
    }
  }
}
class Instanced2CCylindersGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry {
  constructor(instanceCount, polyComplexity, useZSprites, openEnded) {
    super();
    this._useZSprites = useZSprites;
    this._cylGeometry = useZSprites ? new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(2, 2, 1, 1) : new geometries_CylinderBufferGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, openEnded);
    this._init(instanceCount, this._cylGeometry, this._useZSprites);
    this._collisionGeo = new geometries_Simple2CCylindersGeometry(instanceCount, 3);
  }
  setItem(itemIdx, botPos, topPos, itemRad) {
    const matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
    let me = matrix.elements;
    const mtxOffset = itemIdx * Instanced2CCylindersGeometry_OFFSET_SIZE;
    this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);
    Instanced2CCylindersGeometry_setArrayXYZW(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
    Instanced2CCylindersGeometry_setArrayXYZW(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
    Instanced2CCylindersGeometry_setArrayXYZW(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);
    if (this._useZSprites) {
      invMatrix.copy(matrix).invert();
      me = invMatrix.elements;
      Instanced2CCylindersGeometry_setArrayXYZW(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
      Instanced2CCylindersGeometry_setArrayXYZW(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
      Instanced2CCylindersGeometry_setArrayXYZW(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
    }
  }
  setColor(itemIdx, colorVal1, colorVal2) {
    const colorIdx = itemIdx * Instanced2CCylindersGeometry_COLOR_SIZE;
    Instanced2CCylindersGeometry_tmpColor.set(colorVal1);
    Instanced2CCylindersGeometry_setArrayXYZ(this._color1, colorIdx, Instanced2CCylindersGeometry_tmpColor.r, Instanced2CCylindersGeometry_tmpColor.g, Instanced2CCylindersGeometry_tmpColor.b);
    Instanced2CCylindersGeometry_tmpColor.set(colorVal2);
    Instanced2CCylindersGeometry_setArrayXYZ(this._color2, colorIdx, Instanced2CCylindersGeometry_tmpColor.r, Instanced2CCylindersGeometry_tmpColor.g, Instanced2CCylindersGeometry_tmpColor.b);
  }
  computeBoundingSphere() {
    this._collisionGeo.computeBoundingSphere();
    this.boundingSphere = this._collisionGeo.boundingSphere;
  }
  computeBoundingBox() {
    this._collisionGeo.computeBoundingBox();
    this.boundingBox = this._collisionGeo.boundingBox;
  }
  raycast(raycaster, intersects) {
    this._collisionGeo.raycast(raycaster, intersects);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute('matVector1').needsUpdate = true;
    this.getAttribute('matVector2').needsUpdate = true;
    this.getAttribute('matVector3').needsUpdate = true;
    this.getAttribute('color').needsUpdate = true;
    this.getAttribute('color2').needsUpdate = true;
    this.getAttribute('alphaColor').needsUpdate = true;
    if (this._useZSprites) {
      this.getAttribute('invmatVector1').needsUpdate = true;
      this.getAttribute('invmatVector2').needsUpdate = true;
      this.getAttribute('invmatVector3').needsUpdate = true;
    }
    this._collisionGeo.finishUpdate();
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const alphaArr = this._alpha;
    for (let i = 0, n = chunkIndices.length; i < n; ++i) {
      alphaArr[Math.floor(chunkIndices[i] / 2)] = value;
    }
    this.getAttribute('alphaColor').needsUpdate = true;
  }
  getSubset(chunkIndices) {
    const info = _prepareCylinderInfo(chunkIndices);
    const cylinderIndices = info.indices;
    const instanceCount = cylinderIndices.length;
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry();
    this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);
    Instanced2CCylindersGeometry_copySubArrays(this._matVector1, geom._matVector1, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    Instanced2CCylindersGeometry_copySubArrays(this._matVector2, geom._matVector2, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    Instanced2CCylindersGeometry_copySubArrays(this._matVector3, geom._matVector3, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    if (this._useZSprites) {
      Instanced2CCylindersGeometry_copySubArrays(this._invmatVector1, geom._invmatVector1, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
      Instanced2CCylindersGeometry_copySubArrays(this._invmatVector2, geom._invmatVector2, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
      Instanced2CCylindersGeometry_copySubArrays(this._invmatVector3, geom._invmatVector3, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    }
    Instanced2CCylindersGeometry_copySubArrays(this._color1, geom._color1, cylinderIndices, Instanced2CCylindersGeometry_COLOR_SIZE);
    Instanced2CCylindersGeometry_copySubArrays(this._color2, geom._color2, cylinderIndices, Instanced2CCylindersGeometry_COLOR_SIZE);
    _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);
    geom.boundingSphere = this.boundingSphere;
    geom.boundingBox = this.boundingBox;
    return [geom];
  }
  getGeoParams() {
    return this._cylGeometry.parameters;
  }
  _init(instanceCount, cylinderGeo, useZSprites) {
    this.copy(cylinderGeo);
    this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
    this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
    this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
    this._color1 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_COLOR_SIZE);
    this._color2 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_COLOR_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1.0);
    this.setAttribute('matVector1', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._matVector1, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    this.setAttribute('matVector2', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._matVector2, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    this.setAttribute('matVector3', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._matVector3, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    this.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._color1, Instanced2CCylindersGeometry_COLOR_SIZE, false, 1));
    this.setAttribute('color2', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._color2, Instanced2CCylindersGeometry_COLOR_SIZE, false, 1));
    this.setAttribute('alphaColor', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._alpha, 1, false, 1));
    if (useZSprites) {
      this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
      this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
      this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
      this.setAttribute('invmatVector1', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._invmatVector1, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
      this.setAttribute('invmatVector2', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._invmatVector2, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
      this.setAttribute('invmatVector3', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._invmatVector3, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    }
  }
}
/* harmony default export */ const geometries_Instanced2CCylindersGeometry = (Instanced2CCylindersGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/ExtrudedObjectsGeometry.js



const ExtrudedObjectsGeometry_VEC_SIZE = 3;
const TRI_SIZE = 3;
const tmpPrev = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const tmpNext = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const tmpRes = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const simpleNormal = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1.0, 0.0, 0.0);
const normalOnCut = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const nearRingPt = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
function _createExtrudedChunkGeometry(shape, ringsCount) {
  const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
  const ptsCount = shape.length;
  const totalPts = ptsCount * ringsCount;
  const type = totalPts <= 65536 ? Uint16Array : Uint32Array;
  const facesPerChunk = (ringsCount - 1) * ptsCount * 2;
  const indices = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);
  let currVtxIdx = 0;
  let currFaceIdx = 0;
  for (let y = 0; y < ringsCount; y++) {
    // faces
    if (y !== ringsCount - 1) {
      for (let i = 0; i < ptsCount; i++) {
        const v1 = currVtxIdx + i;
        const v2 = currVtxIdx + ptsCount + i;
        const v3 = currVtxIdx + ptsCount + (i + 1) % ptsCount;
        const v4 = currVtxIdx + (i + 1) % ptsCount;
        indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
        currFaceIdx++;
        indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
        currFaceIdx++;
      }
    }
    currVtxIdx += ptsCount;
  }
  geo.setIndex(indices);
  const pos = utils.allocateTyped(Float32Array, totalPts * ExtrudedObjectsGeometry_VEC_SIZE);
  geo.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(pos, ExtrudedObjectsGeometry_VEC_SIZE));
  geo._positions = shape;
  return geo;
}
class ExtrudedObjectsGeometry extends geometries_ChunkedObjectsGeometry {
  constructor(shape, ringsCount, chunksCount) {
    const chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);
    super(chunkGeo, chunksCount);
    this._ringsCount = ringsCount;
    const tmpShape = this._tmpShape = [];
    for (let i = 0; i < shape.length; ++i) {
      tmpShape[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
  }
  setItem(itemIdx, matrices) {
    let hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    let hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    const ptsCount = this._chunkGeo._positions.length;
    const ringsCount = this._ringsCount;
    const chunkStartIdx = ptsCount * this._ringsCount * itemIdx * ExtrudedObjectsGeometry_VEC_SIZE;
    this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx);
    if (hasSlope) {
      this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx);
    } else {
      this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx);
    }
    if (hasCut) {
      this._addCut(ptsCount, ringsCount, chunkStartIdx);
    }
  }
  _setPoints(matrices, ptsCount, ringsCount, chunkStartIdx) {
    const tmpShape = this._tmpShape;
    const positions = this._positions;
    const shape = this._chunkGeo._positions;
    for (let i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i) {
      const mtx = matrices[i];
      for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
        tmpShape[j].copy(shape[j]).applyMatrix4(mtx).toArray(positions, vtxIdx);
      }
    }
  }
  _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
    const nPtsInRing = ptsCount * ExtrudedObjectsGeometry_VEC_SIZE;
    for (let i = 0, vtxIdx = chunkStartIdx; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
      this._countNormalsInRing(ptsCount, vtxIdx, false);
    }
  }
  _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
    const normals = this._normals;
    const nPtsInRing = ptsCount * ExtrudedObjectsGeometry_VEC_SIZE;
    let vtxIdx = chunkStartIdx;
    // First ring
    // In all cases, besides cut, second ring is coincident to first. So values of first ring's normals doesn't
    // matter (In the cut case special handler will be applied later and will set them to correct values)
    for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
      simpleNormal.toArray(normals, vtxIdx);
    }
    // second ring
    // If it isn't first Item we take normals' values from the last ring of the previous item (these rings are coincident)
    // else we count normals' values based on next ring information
    if (vtxIdx - 2 * nPtsInRing > 0) {
      for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
        tmpRes.fromArray(normals, vtxIdx - 2 * nPtsInRing).toArray(normals, vtxIdx);
      }
    } else {
      this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing);
      vtxIdx += nPtsInRing;
    }
    // other rings
    // we count normals' values based on previous ring information
    for (let i = 2; i < ringsCount; ++i, vtxIdx += nPtsInRing) {
      this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing);
    }
  }

  // Counting normals:
  // - Slope
  //   Radius changes throught part => normals aren't parallel with the plane contains section points
  //   normal = vTangentInSectionPlane x vToSuchPointInPrevSection (all vectors are scaled for being 1 in length)
  // - No slope
  //   Radius doesn't change throught part => normals are parallel with the plane contains section points
  //   normal = vToPrevPointInSection + vToNextPointInSection (all vectors are scaled for being 1 in length)
  _countNormalsInRing(ptsCount, vtxIdx, isSlope, shiftToExtraPt) {
    const tmpShape = this._tmpShape;
    const normals = this._normals;
    tmpShape[0].fromArray(this._positions, vtxIdx);
    tmpShape[ptsCount - 1].fromArray(this._positions, vtxIdx + (ptsCount - 1) * ExtrudedObjectsGeometry_VEC_SIZE);
    for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
      if (j < ptsCount - 1) {
        tmpShape[j + 1].fromArray(this._positions, vtxIdx + ExtrudedObjectsGeometry_VEC_SIZE);
      }
      if (isSlope) {
        nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt);
        tmpPrev.subVectors(tmpShape[(j + ptsCount - 1) % ptsCount], tmpShape[(j + 1) % ptsCount]).normalize();
        tmpNext.subVectors(tmpShape[j], nearRingPt).normalize();
        tmpRes.crossVectors(tmpNext, tmpPrev).normalize().toArray(normals, vtxIdx);
      } else {
        tmpPrev.subVectors(tmpShape[j], tmpShape[(j + ptsCount - 1) % ptsCount]).normalize();
        tmpNext.subVectors(tmpShape[j], tmpShape[(j + 1) % ptsCount]).normalize();
        tmpRes.addVectors(tmpPrev, tmpNext).normalize().toArray(normals, vtxIdx);
      }
    }
  }
  _addCut(ptsCount, ringsCount, chunkStartIdx) {
    // Nothing to do if item is flat or only line
    if (ptsCount < 3 || ringsCount < 2) {
      return;
    }
    const positions = this._positions;
    const normals = this._normals;
    const tmpShape = this._tmpShape;
    const nPtsInRing = ptsCount * ExtrudedObjectsGeometry_VEC_SIZE;

    // Normal to the cut plane is equal to cross product of two vectors which are lying in it
    tmpShape[0].fromArray(positions, chunkStartIdx);
    tmpShape[1].fromArray(positions, chunkStartIdx + ExtrudedObjectsGeometry_VEC_SIZE);
    tmpShape[2].fromArray(positions, chunkStartIdx + 2 * ExtrudedObjectsGeometry_VEC_SIZE);
    tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize();
    tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize();
    normalOnCut.crossVectors(tmpPrev, tmpNext).normalize();
    let vtxIdx = chunkStartIdx;
    // First and second rings normals' values are equal to value of normal to the cutting plane
    for (let j = 0; j < ptsCount * 2; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
      normalOnCut.toArray(normals, vtxIdx);
    }
    if (ringsCount > 2) {
      // Third ring points are coincident to first ring points, but have different normals. It makes sharp angle near cut
      for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
        tmpRes.fromArray(positions, vtxIdx - nPtsInRing).toArray(positions, vtxIdx);
      }
    }
  }
}
/* harmony default export */ const geometries_ExtrudedObjectsGeometry = (ExtrudedObjectsGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/ThickLinesGeometry.js



const ThickLinesGeometry_MAX_IDC_16BIT = 65535;
const VERTEX_PER_SEGMENT = 4;
const POS_SIZE = 4;
const DIR_SIZE = 3;
const COL_SIZE = 3;
const ThickLinesGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
const direction = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
function ThickLinesGeometry_setArrayXYZ(arr, idx, x, y, z) {
  arr[idx] = x;
  arr[idx + 1] = y;
  arr[idx + 2] = z;
}
function ThickLinesGeometry_setArrayXYZW(arr, idx, x, y, z, w) {
  arr[idx] = x;
  arr[idx + 1] = y;
  arr[idx + 2] = z;
  arr[idx + 3] = w;
}
function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
  const start = startSegmentIdx * VERTEX_PER_SEGMENT;
  const end = start + segmentsCount * VERTEX_PER_SEGMENT;
  return arr.subarray(start * elemSize, end * elemSize);
}

/**
 * This class represents lines geometry which consists of screen-aligned narrow quad of variable width.
 *
 * @constructor
 *
 * @param {number}  segmentsCount   Number of segments per chunk.
 * collision geometry.
 */

class ThickLinesGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(segmentsCount) {
    super();
    this._initVertices(segmentsCount);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute('position').needsUpdate = true;
    this.getAttribute('color').needsUpdate = true;
    this.getAttribute('alphaColor').needsUpdate = true;
    this.getAttribute('direction').needsUpdate = true;
  }
  setColor(segmentIdx, colorVal) {
    ThickLinesGeometry_tmpColor.set(colorVal);
    let idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
    idx += COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
    idx += COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
    idx += COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
  }
  setSegment(segmentIdx, pos1, pos2) {
    direction.subVectors(pos1, pos2);
    direction.normalize();
    const positions = this._positions;
    const directions = this._directions;
    let idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
    let dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    idx += POS_SIZE;
    dirIdx += DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    idx += POS_SIZE;
    dirIdx += DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    idx += POS_SIZE;
    dirIdx += DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
  }
  setOpacity(startSegIdx, endSegIdx, value) {
    const start = startSegIdx * VERTEX_PER_SEGMENT;
    const end = endSegIdx * VERTEX_PER_SEGMENT;
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(this.alpha, value, end, start);
    this.getAttribute('alphaColor').needsUpdate = true;
  }
  getSubsetSegments(startSegmentIdx, segmentsCount) {
    return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
  }
  getSubsetColors(startSegmentIdx, segmentsCount) {
    return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
  }
  getSubsetOpacities(startSegmentIdx, segmentsCount) {
    return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
  }
  getNumVertexPerSegment() {
    return VERTEX_PER_SEGMENT;
  }
  getPositionSize() {
    return POS_SIZE;
  }
  setSegments(startSegmentIdx, positions) {
    const startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
    if (positions instanceof Array && positions.length === 2) {
      this._positions.set(positions[0], startPos);
      const startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
      this._directions.set(positions[1], startDir); // dirs are geo part of vertex
    } else {
      this._positions.set(positions, startPos);
    }
  }
  setColors(startSegmentIdx, colors) {
    const start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
    this._colors.set(colors, start);
  }
  _initVertices(segmentsCount) {
    this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
    const pointsCount = this._buffersSize;
    const use32bitIndex = pointsCount > ThickLinesGeometry_MAX_IDC_16BIT;
    this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
    this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
    this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
    this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1.0);
    const index = this._index;
    let indexOffset = 0;
    let pointOffset = 0;
    for (let j = 0; j < segmentsCount; j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
      index[indexOffset] = pointOffset;
      index[indexOffset + 1] = pointOffset + 1;
      index[indexOffset + 2] = pointOffset + 3;
      index[indexOffset + 3] = pointOffset;
      index[indexOffset + 4] = pointOffset + 2;
      index[indexOffset + 5] = pointOffset + 3;
    }
    this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._index, 1));
    this.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._positions, POS_SIZE));
    this.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._colors, COL_SIZE));
    this.setAttribute('alphaColor', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(alpha, 1));
    this.setAttribute('direction', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._directions, DIR_SIZE));
  }
}
/* harmony default export */ const geometries_ThickLinesGeometry = (ThickLinesGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/LinesGeometry.js



/**
 * This class represents geometry which consists lines. This can build bounding volumes
 * @constructor
 *
 * @param {number}  segmentsCount   Number of segments per chunk.
 */
class LinesGeometry extends geometries_ThickLinesGeometry {
  startUpdate() {
    return true;
  }
  computeBoundingSphere() {
    const {
      boundingBox
    } = this;
    // Build bounding sphere
    let radiusSquared = 0.0;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    if (boundingBox) {
      boundingBox.getCenter(center);
    }
    const positions = this._positions;
    const sphere = this.boundingSphere || new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
    const size = this._positions.length;
    const pos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const posSize = this.getPositionSize();
    for (let i = 0; i < size; i += posSize) {
      pos.set(positions[i], positions[i + 1], positions[i + 2]);
      const lengthSquared = center.distanceToSquared(pos);
      if (radiusSquared < lengthSquared) {
        radiusSquared = lengthSquared;
      }
    }
    sphere.set(center, Math.sqrt(radiusSquared));
    this.boundingSphere = sphere;
  }
  computeBoundingBox() {
    const positions = this._positions;
    const box = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
    const size = this._positions.length;
    const tmpVec = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const posSize = this.getPositionSize();
    for (let i = 0; i < size; i += posSize) {
      tmpVec.set(positions[i], positions[i + 1], positions[i + 2]);
      box.expandByPoint(tmpVec);
    }
    this.boundingBox = box;
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
}
/* harmony default export */ const geometries_LinesGeometry = (LinesGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/CylinderCollisionGeo.js




const CylinderCollisionGeo_VEC_SIZE = 3;
const CylinderCollisionGeo_tmpVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const CylinderCollisionGeo_normMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
class CylinderCollisionGeo extends geometries_ChunkedObjectsGeometry {
  constructor(instanceCount, polyComplexity) {
    const cylGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.CylinderGeometry(1, 1, 1.0, Math.max(3, polyComplexity), 2, true);
    super(cylGeometry, instanceCount);
    const chunkSize = this._chunkSize;
    this._chunkPos = this._chunkGeo.attributes.position.array;
    this._chunkNorms = this._chunkGeo.attributes.normal.array;
    this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * CylinderCollisionGeo_VEC_SIZE);
  }
  setItem(itemIdx, botPos, topPos, itemRad) {
    const chunkSize = this._chunkSize;
    const itemOffset = chunkSize * itemIdx * CylinderCollisionGeo_VEC_SIZE;
    const tmpArray = this._tmpVector;
    const geoPos = this._chunkPos;
    const geoNorm = this._chunkNorms;
    const mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
    CylinderCollisionGeo_normMtx.getNormalMatrix(mtx1);
    let idx;
    for (let i = 0; i < chunkSize; ++i) {
      idx = i * CylinderCollisionGeo_VEC_SIZE;
      CylinderCollisionGeo_tmpVector.fromArray(geoPos, idx);
      CylinderCollisionGeo_tmpVector.applyMatrix4(mtx1);
      CylinderCollisionGeo_tmpVector.toArray(tmpArray, idx);
    }
    this._positions.set(tmpArray, itemOffset);
    for (let i = 0; i < chunkSize; ++i) {
      idx = i * CylinderCollisionGeo_VEC_SIZE;
      CylinderCollisionGeo_tmpVector.fromArray(geoNorm, idx);
      CylinderCollisionGeo_tmpVector.applyMatrix3(CylinderCollisionGeo_normMtx);
      CylinderCollisionGeo_tmpVector.toArray(tmpArray, idx);
    }
    this._normals.set(tmpArray, itemOffset);
  }
}
/* harmony default export */ const geometries_CylinderCollisionGeo = (CylinderCollisionGeo);
;// CONCATENATED MODULE: ./src/gfx/geometries/ChunkedLinesGeometry.js


const COLLISION_RAD = 0.1;

/**
 * This class represents geometry which consists of separate chunks.
 * Each chunk has same index and similar geometry with equal points and faces count.
 * Each chunk has by default only one color.
 * @constructor
 *
 * @param {number}  chunksCount     Total chunks count.
 * @param {number}  segmentsCount   Number of segments per chunk.
 * @param {boolean} enableCollision Enable or disable collision where each segment is
 *                                  a collidable cylinder.
 * collision geometry.
 */
class ChunkedLinesGeometry extends geometries_LinesGeometry {
  constructor(chunksCount, segmentsCount, enableCollision) {
    super(chunksCount * segmentsCount);
    this._init(segmentsCount);
    this._collisionGeo = enableCollision ? new geometries_CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
  }
  startUpdate() {
    return true;
  }
  computeBoundingSphere() {
    const collisionGeo = this._collisionGeo;
    if (collisionGeo) {
      collisionGeo.computeBoundingSphere();
      this.boundingSphere = collisionGeo.boundingSphere;
      return;
    }
    super.computeBoundingSphere();
  }
  computeBoundingBox() {
    const collisionGeo = this._collisionGeo;
    if (collisionGeo) {
      collisionGeo.computeBoundingBox();
      this.boundingBox = collisionGeo.boundingBox;
      return;
    }
    super.computeBoundingBox();
  }
  raycast(raycaster, intersects) {
    const collisionGeo = this._collisionGeo;
    if (!collisionGeo) {
      return;
    }
    const segCount = this._chunkSize;
    this._collisionGeo.raycast(raycaster, intersects);
    for (let i = 0, n = intersects.length; i < n; ++i) {
      let {
        chunkIdx
      } = intersects[i];
      if (chunkIdx === undefined) {
        continue;
      }
      chunkIdx = chunkIdx / segCount | 0;
      intersects[i].chunkIdx = chunkIdx;
    }
  }
  setColor(chunkIdx, colorVal) {
    const chunkSize = this._chunkSize;
    for (let i = chunkIdx * chunkSize, end = i + chunkSize; i < end; ++i) {
      super.setColor(i, colorVal);
    }
  }
  setSegment(chunkIdx, segIdx, pos1, pos2) {
    const chunkSize = this._chunkSize;
    const idx = chunkIdx * chunkSize + segIdx;
    super.setSegment(idx, pos1, pos2);
    if (this._collisionGeo) {
      this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD);
    }
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const chunkSize = this._chunkSize;
    for (let i = 0, n = chunkIndices.length; i < n; ++i) {
      const left = chunkIndices[i] * chunkSize;
      super.setOpacity(left, left + chunkSize - 1, value);
    }
  }
  getSubset(chunkIndices) {
    const instanceCount = chunkIndices.length;
    const chunkSize = this._chunkSize;
    const subset = new ChunkedLinesGeometry(instanceCount, chunkSize, false);
    for (let i = 0, n = chunkIndices.length; i < n; ++i) {
      const dstPtOffset = i * chunkSize;
      const startSegIdx = chunkIndices[i] * chunkSize;
      subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
      subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
    }
    subset.boundingSphere = this.boundingSphere;
    subset.boundingBox = this.boundingBox;
    return [subset];
  }
  _init(chunkSize) {
    this._chunkSize = chunkSize;
  }
}
/* harmony default export */ const geometries_ChunkedLinesGeometry = (ChunkedLinesGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/TwoColorLinesGeometry.js



const TwoColorLinesGeometry_COLLISION_RAD = 0.3;
const TwoColorLinesGeometry_tmpVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
class TwoColorLinesGeometry extends geometries_LinesGeometry {
  constructor(segmentsCount) {
    super(segmentsCount * 2);
    this._init(segmentsCount);
    this._collisionGeo = new geometries_Simple2CCylindersGeometry(segmentsCount, 3);
  }
  setItem(itemIdx, botPos, topPos) {
    this._collisionGeo.setItem(itemIdx, botPos, topPos, TwoColorLinesGeometry_COLLISION_RAD);
    const offset = 2 * itemIdx; // there are two points per segment
    TwoColorLinesGeometry_tmpVector.lerpVectors(botPos, topPos, 0.5);
    super.setSegment(offset, botPos, TwoColorLinesGeometry_tmpVector);
    super.setSegment(offset + 1, TwoColorLinesGeometry_tmpVector, topPos);
  }
  setColor(itemIdx, colorVal1, colorVal2) {
    const offset = 2 * itemIdx; // there are two points per segment
    super.setColor(offset, colorVal1);
    super.setColor(offset + 1, colorVal2);
  }
  raycast(raycaster, intersects) {
    if (this._collisionGeo) {
      this._collisionGeo.raycast(raycaster, intersects);
    }
  }
  getSubset(segmentIndices) {
    const instanceCount = segmentIndices.length;
    const subset = new TwoColorLinesGeometry(instanceCount, false);
    for (let i = 0, n = instanceCount; i < n; ++i) {
      const startSegIdx = segmentIndices[i];
      subset.setSegments(i, this.getSubsetSegments(startSegIdx, 1));
      subset.setColors(i, this.getSubsetColors(startSegIdx, 1));
    }
    subset.boundingSphere = this.boundingSphere;
    subset.boundingBox = this.boundingBox;
    return [subset];
  }
  _init(segmentsCount) {
    this._segCounts = segmentsCount * 2;
  }
}
// (???)parent = LinesGeometry.prototype;

/* harmony default export */ const geometries_TwoColorLinesGeometry = (TwoColorLinesGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/CrossGeometry.js



const vectors = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1, 0, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, -1, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, -1)];
const vecCount = vectors.length;
const tempPos1 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
const tempPos2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
class CrossGeometry extends geometries_SphereCollisionGeo(geometries_ChunkedLinesGeometry) {
  constructor(chunksCount) {
    super(chunksCount, chunksCount, vecCount / 2 | 0, false);
  }
  setItem(itemIdx, itemPos, itemRad) {
    this.setSphere(itemIdx, itemPos, itemRad);
    for (let i = 0; i < vecCount / 2; ++i) {
      const first = i * 2;
      tempPos1.x = itemPos.x + vectors[first].x * itemRad;
      tempPos1.y = itemPos.y + vectors[first].y * itemRad;
      tempPos1.z = itemPos.z + vectors[first].z * itemRad;
      const second = first + 1;
      tempPos2.x = itemPos.x + vectors[second].x * itemRad;
      tempPos2.y = itemPos.y + vectors[second].y * itemRad;
      tempPos2.z = itemPos.z + vectors[second].z * itemRad;
      this.setSegment(itemIdx, i, tempPos1, tempPos2);
    }
  }
}
/* harmony default export */ const geometries_CrossGeometry = (CrossGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/IsoSurfaceGeometry.js


const POS_RAD_SIZE = 4;
const IsoSurfaceGeometry_COLOR_SIZE = 3;
const IsoSurfaceGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();

/**
 * This is a base class for isosurface algorithms.
 * @param spheresCount - number of atoms/spheres
 * @param opts - geometry specific options
 * @constructor
 */
class IsoSurfaceGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(spheresCount, opts) {
    super();
    this._opts = opts;
    this.zClip = this._opts.zClip;
    this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
    this._colors = utils.allocateTyped(Float32Array, spheresCount * IsoSurfaceGeometry_COLOR_SIZE);
  }
  setItem(chunkIdx, pos, radius) {
    const posRad = this._posRad;
    let idx = POS_RAD_SIZE * chunkIdx;
    posRad[idx++] = pos.x;
    posRad[idx++] = pos.y;
    posRad[idx++] = pos.z;
    posRad[idx] = radius;
  }
  setColor(chunkIdx, colorVal) {
    IsoSurfaceGeometry_tmpColor.set(colorVal);
    const colors = this._colors;
    let idx = IsoSurfaceGeometry_COLOR_SIZE * chunkIdx;
    colors[idx++] = IsoSurfaceGeometry_tmpColor.r;
    colors[idx++] = IsoSurfaceGeometry_tmpColor.g;
    colors[idx] = IsoSurfaceGeometry_tmpColor.b;
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  finishUpdate() {
    this._build();
  }
  setOpacity() {
    // not implemented
  }
  raycast() {}
  getSubset() {
    return [];
  }
}
/* harmony default export */ const geometries_IsoSurfaceGeometry = (IsoSurfaceGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/IsoSurfaceMarchCube.js


/**
 * Class for marching cube
 * Stores 8 points and 8 float values are stored together in linear array
 * Int values for has intersection or not - in integer32 linear array
 * Int values for bits flags - in integer32 linear array
 *
 */
class IsoSurfaceMarchCube {
  constructor() {
    this.pointsValuesLinear = null;
    this.hasIntersection = null;
    this.bitsInside = null;
  }
  create(numCellsPerSide) {
    const vx7000000 = 0x7000000;
    const n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;
    if (n3 > vx7000000) {
      throw new Error('Too large cube dimension: lead to memory huge uasge');
    }
    this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
    this.hasIntersection = utils.allocateTyped(Int32Array, n3);
    this.bitsInside = utils.allocateTyped(Int32Array, n3);
    return 0;
  }
  destroy() {
    this.bitsInside = null;
    this.hasIntersection = null;
    this.pointsValuesLinear = null;
  }
}

/* eslint-disable no-magic-numbers */
IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
/* eslint-enable no-magic-numbers */

/* harmony default export */ const geometries_IsoSurfaceMarchCube = (IsoSurfaceMarchCube);
;// CONCATENATED MODULE: ./src/gfx/geometries/IsoSurface.js



const edgeTable = [0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, 0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, 0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, 0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, 0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, 0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, 0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, 0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, 0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, 0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, 0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, 0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460, 0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0, 0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230, 0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190, 0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0];
function _voxelGradientFast(v, point, grad) {
  const g = v.getValue(point.x, point.y, point.z);
  grad.set(g[0], g[1], g[2]);
}

// Helper class GridCell
class GridCell {
  constructor() {
    this._arrSize = 8;
    this.p = new Array(this._arrSize);
    this.g = new Array(this._arrSize);
    this.val = new Array(this._arrSize);
    for (let i = 0; i < this._arrSize; ++i) {
      this.p[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      this.g[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
    this.cubeIndex = 0;
  }
}

// Helper class Triangle
class Triangle {
  constructor() {
    this.a = {
      p: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
      n: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
    };
    this.b = {
      p: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
      n: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
    };
    this.c = {
      p: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
      n: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
    };
  }
}
function createArray(arrSize) {
  const arr = new Array(arrSize);
  for (let i = 0; i < arrSize; ++i) {
    arr[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  }
  return arr;
}
class IsoSurface {
  constructor() {
    this._numTriangles = 0;
    this._numVertices = 0;
    this._position = [];
    this._normals = [];
    this._colors = null;
    this._indices = [];
    this._volumetricData = null;
    this._xAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._yAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._zAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._xDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._yDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._zDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  }
  _prepareAxesAndDirs() {
    const volData = this._volumetricData;
    const cellSize = volData.getCellSize();

    // calculate cell axes
    const xAxis = this._xAxis;
    const yAxis = this._yAxis;
    const zAxis = this._zAxis;
    const xDir = this._xDir;
    const yDir = this._yDir;
    const zDir = this._zDir;
    xAxis.set(cellSize.x, 0, 0);
    yAxis.set(0, cellSize.y, 0);
    zAxis.set(0, 0, cellSize.z);
    xDir.set(1, 0, 0);
    yDir.set(0, 1, 0);
    zDir.set(0, 0, 1);

    // flip normals if coordinate system is in the wrong handedness
    const tmp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    tmp.crossVectors(xDir, yDir);
    if (tmp.dot(zDir) < 0) {
      xDir.negate();
      yDir.negate();
      zDir.negate();
    }

    // check that the grid is in the all-positive octant of the coordinate system
    if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
      return false;
    }

    // check that the grid is axis-aligned
    const notZero = axe => Math.abs(axe) > Number.EPSILON;
    return !(notZero(xAxis.y) || notZero(xAxis.z) || notZero(yAxis.x) || notZero(yAxis.z) || notZero(zAxis.x) || notZero(zAxis.y));
  }
  _vertexInterp(isoLevel, grid, ind1, ind2, vertex, normal) {
    const p1 = grid.p[ind1];
    const p2 = grid.p[ind2];
    const n1 = grid.g[ind1];
    const n2 = grid.g[ind2];
    const valP1 = grid.val[ind1];
    const valP2 = grid.val[ind2];
    const isoDiffP1 = isoLevel - valP1;
    const diffValP2P1 = valP2 - valP1;
    let mu = 0.0;
    if (Math.abs(diffValP2P1) > 0.0) {
      mu = isoDiffP1 / diffValP2P1;
    }
    mu = mu > 1.0 ? 1.0 : mu;
    vertex.lerpVectors(p1, p2, mu);
    normal.lerpVectors(n1, n2, mu);
  }
  static _triTable = (() => geometries_IsoSurfaceMarchCube.prototype.striIndicesMarchCube)();
  static _arrSize = 12;
  static _firstIndices = [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3];
  static _secondIndices = [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7];
  static _vertexList = (() => createArray(IsoSurface._arrSize))();
  static _normalList = (() => createArray(IsoSurface._arrSize))();
  _polygonize(grid, isoLevel, triangles) {
    const {
      cubeIndex
    } = grid;
    let i = 0;
    const arrSize = IsoSurface._arrSize;
    const firstIndices = IsoSurface._firstIndices;
    const secondIndices = IsoSurface._secondIndices;
    const vertexList = IsoSurface._vertexList;
    const normalList = IsoSurface._normalList;
    for (; i < arrSize; ++i) {
      if (edgeTable[cubeIndex] & 1 << i) {
        this._vertexInterp(isoLevel, grid, firstIndices[i], secondIndices[i], vertexList[i], normalList[i]);
      }
    }
    let triCount = 0;
    const triTblIdx = cubeIndex * 16;
    const triTable = IsoSurface._triTable;
    for (i = 0; triTable[triTblIdx + i] !== -1; i += 3) {
      triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i]]);
      triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i]]);
      triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i + 1]]);
      triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i + 1]]);
      triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i + 2]]);
      triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i + 2]]);
      ++triCount;
    }
    return triCount;
  }
  _doGridPosNorms(isoValue, step, appendSimple) {
    const vol = this._volumetricData;
    const volData = this._volumetricData.getData();
    const dim = vol.getDimensions();
    const xSize = dim[0];
    const ySize = dim[1];
    const zSize = dim[2];
    const stepX = step * vol.getStrideX();
    const stepY = step * vol.getStrideY();
    const stepZ = step * vol.getStrideZ();
    const gc = new GridCell();
    const gcVal = gc.val;
    const gcValSize = gc.val.length;
    const additions = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
    // 0
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, 0, 0),
    // 1
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, step, 0),
    // 2
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, step, 0),
    // 3
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, step),
    // 4
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, 0, step),
    // 5
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, step, step),
    // 6
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, step, step) // 7
    ];
    const tmpTriCount = 5;
    const triangles = new Array(tmpTriCount);
    for (let j = 0; j < tmpTriCount; ++j) {
      triangles[j] = new Triangle();
    }
    let appendVertex;
    const self = this;
    const positions = this._position;
    const normals = this._normals;
    if (appendSimple) {
      // Special case for axis-aligned grid with positive unit vector normals
      appendVertex = function () {
        const axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(self._xAxis.x, self._yAxis.y, self._zAxis.z);
        return function (triVertex) {
          const vertex = triVertex.p.clone();
          vertex.multiply(axis);
          positions.push(vertex.add(self._origin));
          normals.push(triVertex.n.clone());
        };
      }();
    } else {
      appendVertex = function () {
        const posMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
        posMtx.set(self._xAxis.x, self._yAxis.x, self._zAxis.x, self._xAxis.y, self._yAxis.y, self._zAxis.y, self._xAxis.z, self._yAxis.z, self._zAxis.z);
        const normMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
        normMtx.set(self._xDir.x, self._yDir.x, self._zDir.x, self._xDir.y, self._yDir.y, self._zDir.y, self._xDir.z, self._yDir.z, self._zDir.z);
        return function (triVertex) {
          positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self._origin));
          normals.push(triVertex.n.clone().applyMatrix3(normMtx));
        };
      }();
    }
    const indices = this._indices;
    let globTriCount = 0;
    for (let z = 0; z < zSize - step; z += step) {
      for (let y = 0; y < ySize - step; y += step) {
        let idx = vol.getDirectIdx(0, y, z);
        for (let x = 0; x < xSize - step; x += step, idx += stepX) {
          /* eslint-disable no-multi-spaces */
          /* eslint-disable computed-property-spacing */
          gcVal[0] = volData[idx];
          gcVal[1] = volData[idx + stepX];
          gcVal[3] = volData[idx + stepY];
          gcVal[2] = volData[idx + stepX + stepY];
          gcVal[4] = volData[idx + stepZ];
          gcVal[5] = volData[idx + stepX + stepZ];
          gcVal[7] = volData[idx + stepY + stepZ];
          gcVal[6] = volData[idx + stepX + stepY + stepZ];
          /* eslint-enable no-multi-spaces */
          /* eslint-enable computed-property-spacing */

          // Determine the index into the edge table which
          // tells us which vertices are inside of the surface
          let cubeIndex = 0;
          let i = 0;
          for (; i < gcValSize; ++i) {
            if (gcVal[i] < isoValue) {
              cubeIndex |= 1 << i;
            }
          }
          if (edgeTable[cubeIndex] === 0) {
            continue;
          }
          gc.cubeIndex = cubeIndex;
          for (i = 0; i < gcValSize; ++i) {
            gc.p[i].set(x + additions[i].x, y + additions[i].y, z + additions[i].z);
            _voxelGradientFast(this._gradient, gc.p[i], gc.g[i]);
          }

          // calculate vertices and facets for this cube,
          // calculate normals by interpolating between the negated
          // normalized volume gradients for the 8 reference voxels
          const triCount = this._polygonize(gc, isoValue, triangles);
          globTriCount += triCount;

          // append triangles using different techniques
          for (i = 0; i < triCount; ++i) {
            indices.push(this._numTriangles * 3);
            indices.push(this._numTriangles * 3 + 1);
            indices.push(this._numTriangles * 3 + 2);
            ++this._numTriangles;
            appendVertex(triangles[i].a);
            appendVertex(triangles[i].b);
            appendVertex(triangles[i].c);
          }
        }
      }
    }
    return globTriCount;
  }
  compute(volData, origin, isoValue, step) {
    this._volumetricData = volData;
    this._origin = origin;
    this._gradient = volData.computeGradient();
    this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
  }
  _remapIndices(vertexMap, idcCount) {
    const indices = this._indices;
    const newIndices = utils.allocateTyped(Uint32Array, idcCount);
    for (let i = 0; i < idcCount; ++i) {
      indices[i] = vertexMap[indices[i]];
      newIndices[i] = indices[i];
    }
    this._indices = newIndices;
  }
  _remapVertices(vertices, normals, count) {
    const newPositions = utils.allocateTyped(Float32Array, count * 3);
    const newNormals = utils.allocateTyped(Float32Array, count * 3);
    for (let i = 0; i < count; ++i) {
      const pos = vertices[i];
      newPositions[i * 3] = pos.x;
      newPositions[i * 3 + 1] = pos.y;
      newPositions[i * 3 + 2] = pos.z;
      const norm = normals[i].normalize();
      newNormals[i * 3] = norm.x;
      newNormals[i * 3 + 1] = norm.y;
      newNormals[i * 3 + 2] = norm.z;
    }
    this._position = newPositions;
    this._normals = newNormals;
  }
  vertexFusion(offset, len) {
    const faceVer = this._indices.length;
    const vertices = this._position;
    const normals = this._normals;
    const oldVerCount = vertices.length | 0;
    if (faceVer === 0 || oldVerCount === 0) {
      return;
    }
    const vMap = utils.allocateTyped(Uint32Array, oldVerCount);
    vMap[0] = 0;
    let newVer = 1;
    let i = 1;
    for (; i < oldVerCount; ++i) {
      const start = newVer - offset < 0 ? 0 : newVer - offset;
      const end = start + len > newVer ? newVer : start + len;
      let matchedIndex = -1;
      for (let j = start; j < end; ++j) {
        if (Math.abs(vertices[i] - vertices[j]) < Number.EPSILON) {
          matchedIndex = j;
          break;
        }
      }
      if (matchedIndex !== -1) {
        vMap[i] = matchedIndex;
      } else {
        vertices[newVer].copy(vertices[i]);
        normals[newVer].copy(normals[i]);
        vMap[i] = newVer;
        ++newVer;
      }
    }
    this._remapIndices(vMap, faceVer);
    this._remapVertices(vertices, normals, newVer);
  }

  // Assign per-vertex colors from a volumetric texture map (same dimensions as the original volumetric data).
  // Along with color dominating atom is determined for each vertex
  // and vertices with atom out of "visible" subset get filtered out.
  // XXX only handles orthogonal volumes currently
  setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
    let i;
    let idx;
    const numVerts = this._position.length / 3;
    const vertices = this._position;
    const origin = this._origin;
    const dim = this._volumetricData.getDimensions();
    const xs = dim[0] - 1;
    const ys = dim[1] - 1;
    const zs = dim[2] - 1;
    const colorData = colorMap.getData();
    const strideX = colorMap.getStrideX();
    const strideY = colorMap.getStrideY();
    const strideZ = colorMap.getStrideZ();
    let atomWeightData;
    let atomStrideX;
    let atomStrideY;
    let atomStrideZ;
    if (visibilitySelector !== null) {
      atomWeightData = atomWeightMap.getData();
      atomStrideX = atomWeightMap.getStrideX();
      atomStrideY = atomWeightMap.getStrideY();
      atomStrideZ = atomWeightMap.getStrideZ();
    }
    const xInv = 1.0 / this._xAxis.x;
    const yInv = 1.0 / this._yAxis.y;
    const zInv = 1.0 / this._zAxis.z;
    let atomLookup = [];
    let atomWeights = [];
    const colors = utils.allocateTyped(Float32Array, numVerts * 3);
    function interp(mu, idx1, idx2, c) {
      c[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
      c[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
      c[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
    }
    function collectWeight(ai, coefX, coefY, coefZ) {
      const a = atomMap[ai]; // atomWeightMap is a scalar field, so index into atom map should be the same
      if (a != null) {
        atomLookup[a.index] = a;
        const w = coefX * coefY * coefZ * atomWeightData[ai];
        if (typeof atomWeights[a.index] === 'undefined') {
          atomWeights[a.index] = w;
        } else {
          atomWeights[a.index] += w;
        }
      }
    }
    const vMap = utils.allocateTyped(Int32Array, numVerts);
    let newVerCount = 0;
    for (i = 0; i < numVerts; i++) {
      const ind = i * 3;
      const vx = (vertices[ind] - origin.x) * xInv;
      const vy = (vertices[ind + 1] - origin.y) * yInv;
      const vz = (vertices[ind + 2] - origin.z) * zInv;
      const x = Math.min(Math.max(vx, 0), xs) | 0;
      const y = Math.min(Math.max(vy, 0), ys) | 0;
      const z = Math.min(Math.max(vz, 0), zs) | 0;
      const mux = vx - x;
      const muy = vy - y;
      const muz = vz - z;
      if (visibilitySelector != null) {
        // collect atom weights
        atomLookup = [];
        atomWeights = [];
        idx = atomWeightMap.getDirectIdx(x, y, z);
        collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
        collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
        collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
        collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
        collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
        collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
        collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
        collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz);

        // find dominant atom
        let maxWeight = 0.0;
        let dominantIdx = -1;
        for (const atomIdx in atomWeights) {
          if (atomWeights[atomIdx] > maxWeight) {
            dominantIdx = atomIdx;
            maxWeight = atomWeights[atomIdx];
          }
        }
        if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
          // this vertex doesn't belong to visible subset and will be skipped
          vMap[i] = -1;
          continue;
        }
      }
      vMap[i] = newVerCount++;

      // color tri-linear interpolation
      const dx = x < xs ? strideX : 0;
      const dy = y < ys ? strideY : 0;
      const dz = z < zs ? strideZ : 0;
      const c0 = [0, 0, 0];
      const c1 = [0, 0, 0];
      const c2 = [0, 0, 0];
      const c3 = [0, 0, 0];
      idx = colorMap.getDirectIdx(x, y, z);
      interp(mux, idx, idx + dx, c0);
      interp(mux, idx + dy, idx + dx + dy, c1);
      interp(mux, idx + dz, idx + dx + dz, c2);
      interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);
      const cz0 = [0, 0, 0];
      cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
      cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
      cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
      const cz1 = [0, 0, 0];
      cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
      cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
      cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
      colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
      colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
      colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
    }
    this._colors = colors;
    if (visibilitySelector != null) {
      // shift visible vertices towards beginning of array
      for (i = 0; i < numVerts; ++i) {
        const j = vMap[i];
        if (j < 0) {
          continue;
        }

        // assert: j <= i
        this._position[j * 3] = this._position[i * 3];
        this._position[j * 3 + 1] = this._position[i * 3 + 1];
        this._position[j * 3 + 2] = this._position[i * 3 + 2];
        this._normals[j * 3] = this._normals[i * 3];
        this._normals[j * 3 + 1] = this._normals[i * 3 + 1];
        this._normals[j * 3 + 2] = this._normals[i * 3 + 2];
        this._colors[j * 3] = this._colors[i * 3];
        this._colors[j * 3 + 1] = this._colors[i * 3 + 1];
        this._colors[j * 3 + 2] = this._colors[i * 3 + 2];
      }

      // rebuild index list
      const numTriangles = this._indices.length / 3;
      let newTriCount = 0;
      for (i = 0; i < numTriangles; ++i) {
        const i0 = vMap[this._indices[3 * i]];
        const i1 = vMap[this._indices[3 * i + 1]];
        const i2 = vMap[this._indices[3 * i + 2]];
        if (i0 >= 0 && i1 >= 0 && i2 >= 0) {
          this._indices[3 * newTriCount] = i0;
          this._indices[3 * newTriCount + 1] = i1;
          this._indices[3 * newTriCount + 2] = i2;
          ++newTriCount;
        }
      }

      // shrink arrays to data size
      this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
      this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
      this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
      this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
    }
  }
  toMesh() {
    const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    geo.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._indices, 1));
    geo.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._position, 3));
    geo.setAttribute('normal', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._normals, 3));
    geo.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._colors, 3));
    geo.computeBoundingSphere();
    return geo;
  }
}
/* harmony default export */ const geometries_IsoSurface = (IsoSurface);
;// CONCATENATED MODULE: ./src/gfx/geometries/VolumeSurfaceGeometry.js





/**
 * This is a base class for volumetric maps based isosurface algorithms.
 * @param spheresCount - number of atoms/spheres
 * @param opts - geometry specific options
 * @constructor
 */

class VolumeSurfaceGeometry extends geometries_IsoSurfaceGeometry {
  _build() {
    const params = this._opts;
    this.numVoxels = [128, 128, 128];
    this.xAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1.0, 0.0, 0.0);
    this.yAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 1.0, 0.0);
    this.zAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 1.0);
    this.origin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0);
    this._visibilitySelector = params.visibilitySelector;
    this._calcSurface(params);
  }
  _findMinMax(posRadArray) {
    const itemSize = 4;
    const itemsCount = posRadArray.length / itemSize;
    const maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
    const minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
    for (let i = 1; i < itemsCount; ++i) {
      const ind = i * itemSize;
      for (let itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
        const tmpVal = posRadArray[ind + itemIdx];
        maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
        minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
      }
    }
    return {
      maxPosRad,
      minPosRad
    };
  }
  _findNumVoxels(posRadArray, params) {
    const {
      numVoxels
    } = this;
    const minMaxValues = this._findMinMax(posRadArray);
    const minCoordRad = minMaxValues.minPosRad;
    const maxCoordRad = minMaxValues.maxPosRad;

    // minrad
    if (minCoordRad[3] > 4.0) {
      params.gridSpacing *= minCoordRad[3];
    }
    let gridPadding = params.radScale * maxCoordRad[3] * 1.7;
    let padRad = gridPadding;
    padRad = 0.65 * Math.sqrt(4.0 / 3.0 * Math.PI * padRad * padRad * padRad);
    gridPadding = Math.max(gridPadding, padRad);
    let i = 0;
    for (; i < 3; ++i) {
      minCoordRad[i] -= gridPadding;
      maxCoordRad[i] += gridPadding;
    }
    for (i = 0; i < 3; ++i) {
      numVoxels[i] = Math.ceil((maxCoordRad[i] - minCoordRad[i]) / params.gridSpacing);
    }
    this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
    this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
    this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;
    [this.origin.x, this.origin.y, this.origin.z] = minCoordRad;
    return {
      bbox: minMaxValues,
      dim: numVoxels
    };
  }
  _makeSurface(surface, params) {
    const isoSurf = new geometries_IsoSurface();
    isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
    isoSurf.vertexFusion(9, 9); // normalization is included

    if (isoSurf._numTriangles > 0) {
      isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
      this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._indices, 1));
      this.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._position, 3));
      this.setAttribute('normal', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._normals, 3));
      this.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._colors, 3));
    } else {
      // geometry should have at least empty position attributes to be processed in wireframe mode by three.js
      this.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
    }
  }
  _calcSurface(params) {
    const packedArrays = {
      posRad: this._posRad,
      colors: this._colors,
      atoms: this._opts.atoms
    };
    if (packedArrays.posRad.length === 0) {
      return;
    }
    const boundaries = this._findNumVoxels(packedArrays.posRad, params);
    const box = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(this.origin, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));
    const surface = this._computeSurface(packedArrays, box, boundaries, params);
    this._makeSurface(surface, params);
  }
}
/* harmony default export */ const geometries_VolumeSurfaceGeometry = (VolumeSurfaceGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/QuickSurfGeometry.js


const {
  Volume: QuickSurfGeometry_Volume
} = chem;

/**
 * This class implements 'quick' isosurface geometry generation algorithm.
 * @param spheresCount - number of atoms/spheres
 * @param opts - geometry specific options
 * @constructor
 */

class QuickSurfGeometry extends geometries_VolumeSurfaceGeometry {
  _computeSurface(packedArrays, box, boundaries, params) {
    // beware of shifting this multiple times!
    this._shiftByOrigin(packedArrays.posRad);
    const surface = {
      volMap: new QuickSurfGeometry_Volume(Float32Array, this.numVoxels, box),
      volTexMap: new QuickSurfGeometry_Volume(Float32Array, this.numVoxels, box, 3)
    };
    if (this._visibilitySelector != null) {
      surface.atomMap = [];
      surface.atomWeightMap = new QuickSurfGeometry_Volume(Float32Array, this.numVoxels, box);
    }
    this.gaussdensity(surface, packedArrays, null, params);
    return surface;
  }
  gaussdensity(surface, packedArrays, atomicNum, params) {
    const numAtoms = packedArrays.posRad.length / 4;
    const {
      posRad,
      colors
    } = packedArrays;
    const {
      numVoxels
    } = this;
    const {
      radScale,
      gaussLim,
      gridSpacing
    } = params;
    const invIsoValue = 1.0 / params.isoValue;
    const invGridSpacing = 1.0 / gridSpacing;
    const maxVoxelX = numVoxels[0] - 1;
    const maxVoxelY = numVoxels[1] - 1;
    const maxVoxelZ = numVoxels[2] - 1;
    // TODO is densityMap and volTexMap initialized?

    const {
      volMap,
      volTexMap
    } = surface;
    const volData = volMap.getData();
    const strideX = volMap.getStrideX();
    const volTexData = volTexMap.getData();
    const texStrideX = volTexMap.getStrideX();
    let atomWeightData;
    if (this._visibilitySelector != null) {
      atomWeightData = surface.atomWeightMap.getData();
    }
    const {
      atomMap
    } = surface;
    for (let i = 0; i < numAtoms; ++i) {
      const ind = i * 4;
      const scaledRad = posRad[ind + 3] * radScale;
      const atomicNumFactor = atomicNum === null ? 1.0 : atomicNum[i];
      const radInv = 1 / (2 * scaledRad * scaledRad);
      let radLim = gaussLim * scaledRad;
      const radLim2 = radLim * radLim;
      radLim *= invGridSpacing;
      let tmp = posRad[ind] * invGridSpacing;
      const xMin = Math.max(tmp - radLim | 0, 0);
      const xMax = Math.min(tmp + radLim | 0, maxVoxelX);
      tmp = posRad[ind + 1] * invGridSpacing;
      const yMin = Math.max(tmp - radLim | 0, 0);
      const yMax = Math.min(tmp + radLim | 0, maxVoxelY);
      tmp = posRad[ind + 2] * invGridSpacing;
      const zMin = Math.max(tmp - radLim | 0, 0);
      const zMax = Math.min(tmp + radLim | 0, maxVoxelZ);
      let dz = zMin * gridSpacing - posRad[ind + 2];
      for (let z = zMin; z <= zMax; ++z, dz += gridSpacing) {
        let dy = yMin * gridSpacing - posRad[ind + 1];
        for (let y = yMin; y <= yMax; ++y, dy += gridSpacing) {
          const dy2dz2 = dy * dy + dz * dz;
          if (dy2dz2 >= radLim2) {
            continue;
          }
          let addr = volMap.getDirectIdx(xMin, y, z);
          let texAddr = volTexMap.getDirectIdx(xMin, y, z);
          let dx = xMin * gridSpacing - posRad[ind];
          for (let x = xMin; x <= xMax; ++x, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
            const r2 = dx * dx + dy2dz2;
            const expVal = -r2 * radInv;
            let density = Math.exp(expVal) * atomicNumFactor;

            // store most relevant atom (with highest density)
            if (this._visibilitySelector != null && density > atomWeightData[addr]) {
              // NOSONAR
              atomWeightData[addr] = density;
              // we use same index into atom map and atomWeightMap
              atomMap[addr] = packedArrays.atoms[i];
            }
            volData[addr] += density;

            // TODO check for volTexMap routine?
            density *= invIsoValue;
            const colInd = i * 3;
            volTexData[texAddr] += density * colors[colInd];
            volTexData[texAddr + 1] += density * colors[colInd + 1];
            volTexData[texAddr + 2] += density * colors[colInd + 2];
          }
        }
      }
    }
  }
  _shiftByOrigin(posRadArray) {
    const originX = this.origin.x;
    const originY = this.origin.y;
    const originZ = this.origin.z;
    const itemSize = 4;
    const itemsCount = posRadArray.length / itemSize;
    for (let i = 0; i < itemsCount; ++i) {
      const ind = i * itemSize;
      posRadArray[ind] -= originX;
      posRadArray[ind + 1] -= originY;
      posRadArray[ind + 2] -= originZ;
    }
  }
}
/* harmony default export */ const geometries_QuickSurfGeometry = (QuickSurfGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/ContactSurface.js



/**
 * Modifed from SpatialHash
 *
 * Main differences are:
 * - Optimized grid size to ensure we only ever need to look +/-1 cell
 * - Aware of atomic radii and will only output atoms within rAtom + rExtra
 *   (see withinRadii method)
 *
 * (Uses rounding rather than bitshifting as consequence of arbitrary grid size)
 * @class
 * @param {Float32Array} posRad - x, y, z coordinates and radiuses
 * @param {Float32Array} min - xyz min coordinates
 * @param {Float32Array} max - xyz max coordinates
 * @param {number} maxDistance - max distance
 */
function AVHash(posRad, min, max, maxDistance) {
  const itemSize = 4;
  const nAtoms = posRad.length / itemSize;
  const minX = min[0];
  const minY = min[1];
  const minZ = min[2];
  const maxX = max[0];
  const maxY = max[1];
  const maxZ = max[2];
  function hashFunc(w, minW) {
    return Math.floor((w - minW) / maxDistance);
  }
  const iDim = hashFunc(maxX, minX) + 1;
  const jDim = hashFunc(maxY, minY) + 1;
  const kDim = hashFunc(maxZ, minZ) + 1;
  const nCells = iDim * jDim * kDim;
  const jkDim = jDim * kDim;

  /* Get cellID for cartesian x,y,z */
  const cellID = function (x, y, z) {
    return (hashFunc(x, minX) * jDim + hashFunc(y, minY)) * kDim + hashFunc(z, minZ);
  };

  /* Initial building, could probably be optimized further */
  const preHash = [];
  let i;
  let cid;
  for (i = 0; i < nAtoms; i++) {
    const iIdx = itemSize * i;
    cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);
    if (preHash[cid] === undefined) {
      preHash[cid] = [i];
    } else {
      preHash[cid].push(i);
    }
  }
  const cellOffsets = utils.allocateTyped(Uint32Array, nCells);
  const cellLengths = utils.allocateTyped(Uint16Array, nCells);
  const data = utils.allocateTyped(Uint32Array, nAtoms);
  let offset = 0;
  let maxCellLength = 0;
  let j;
  for (i = 0; i < nCells; i++) {
    const start = cellOffsets[i] = offset;
    const subArray = preHash[i];
    if (subArray !== undefined) {
      for (j = 0; j < subArray.length; j++) {
        data[offset] = subArray[j];
        offset++;
      }
    }
    const cellLength = offset - start;
    cellLengths[i] = cellLength;
    if (cellLength > maxCellLength) {
      maxCellLength = cellLength;
    }
  }

  // Maximum number of neighbours we could ever produce (27 adjacent cells of equal population)
  this.neighbourListLength = 27 * maxCellLength + 1;

  /**
   * Populate the supplied out array with atom indices that are within rAtom + rExtra
   * of x,y,z
   *
   * -1 in out array indicates the end of the list
   *
   * @param  {number} x - x coordinate
   * @param  {number} y - y coordinate
   * @param  {number} z - z coordinate
   * @param  {number} rExtra - additional radius
   * @param  {Float32Array} out - pre-allocated output array
   * @return {undefined}
   */
  this.withinRadii = function (x, y, z, rExtra, out) {
    let outIdx = 0;
    const nearI = hashFunc(x, minX);
    const nearJ = hashFunc(y, minY);
    const nearK = hashFunc(z, minZ);
    const loI = Math.max(0, nearI - 1);
    const loJ = Math.max(0, nearJ - 1);
    const loK = Math.max(0, nearK - 1);
    const hiI = Math.min(iDim - 1, nearI + 1);
    const hiJ = Math.min(jDim - 1, nearJ + 1);
    const hiK = Math.min(kDim - 1, nearK + 1);
    for (i = loI; i <= hiI; ++i) {
      const iOffset = i * jkDim;
      for (j = loJ; j <= hiJ; ++j) {
        const jOffset = j * kDim;
        for (let k = loK; k <= hiK; ++k) {
          cid = iOffset + jOffset + k;
          const cellStart = cellOffsets[cid];
          const cellEnd = cellStart + cellLengths[cid];
          for (let dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
            const atomIndex = data[dataIndex];
            const baseIndex = itemSize * atomIndex;
            const dx = posRad[baseIndex] - x;
            const dy = posRad[baseIndex + 1] - y;
            const dz = posRad[baseIndex + 2] - z;
            const rSum = posRad[baseIndex + 3] + rExtra;
            if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
              out[outIdx++] = data[dataIndex];
            }
          }
        }
      }
    }
    // Add terminator
    out[outIdx] = -1;
  };
}
function ContactSurface(packedArrays, boundaries, params, _indexList) {
  // Field generation method adapted from AstexViewer (Mike Hartshorn)
  // by Fred Ludlow.
  // Other parts based heavily on NGL (Alexander Rose) EDT Surface class
  //
  // Should work as a drop-in alternative to EDTSurface (though some of
  // the EDT paramters are not relevant in this method).

  const itemSize = 4;
  const {
    posRad,
    colors,
    atoms
  } = packedArrays;
  const nAtoms = posRad.length / itemSize;
  const {
    bbox
  } = boundaries;
  const min = bbox.minPosRad;
  const max = bbox.maxPosRad;
  let r2; // Atom positions, expanded radii (squared)
  let maxRadius;

  // Parameters
  let probeRadius;
  let scaleFactor;
  let probePositions;

  // Cache last value for obscured test
  let lastClip = -1;

  // Grid params
  let dim;
  let grid;
  let volTex;
  let weights;
  let weightsMap = null;
  let atomMap = null;
  let visibilitySelector = null;

  // grid indices -> xyz coords
  let gridx;
  let gridy;
  let gridz;

  // Lookup tables:
  let sinTable;
  let cosTable;

  // Spatial Hash
  let hash;

  // Neighbour array to be filled by hash
  let neighbours;

  // Vectors for Torus Projection
  const mid = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0);
  const n1 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0);
  const n2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0);
  let ngTorus;
  function uniformArray(TypeName, n, a) {
    const array = utils.allocateTyped(TypeName, n);
    for (let innI = 0; innI < n; ++innI) {
      array[innI] = a;
    }
    return array;
  }
  function fillGridDim(a, start, step) {
    for (let innI = 0; innI < a.length; innI++) {
      a[innI] = start + step * innI;
    }
  }
  function initializeGrid() {
    ({
      scaleFactor
    } = params);
    ({
      dim
    } = boundaries);
    ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
    const gridSize = dim[0] * dim[1] * dim[2];
    grid = uniformArray(Float32Array, gridSize, -1001.0);
    volTex = utils.allocateTyped(Float32Array, gridSize * 3);
    weights = utils.allocateTyped(Float32Array, gridSize);
    if (visibilitySelector) {
      weightsMap = utils.allocateTyped(Float32Array, gridSize);
      atomMap = [];
    }
    gridx = utils.allocateTyped(Float32Array, dim[0]);
    gridy = utils.allocateTyped(Float32Array, dim[1]);
    gridz = utils.allocateTyped(Float32Array, dim[2]);
    fillGridDim(gridx, min[0], 1 / scaleFactor);
    fillGridDim(gridy, min[1], 1 / scaleFactor);
    fillGridDim(gridz, min[2], 1 / scaleFactor);
  }
  function initializeAngleTables() {
    let theta = 0.0;
    const step = 2 * Math.PI / probePositions;
    cosTable = utils.allocateTyped(Float32Array, probePositions);
    sinTable = utils.allocateTyped(Float32Array, probePositions);
    for (let innI = 0; innI < probePositions; innI++) {
      cosTable[innI] = Math.cos(theta);
      sinTable[innI] = Math.sin(theta);
      theta += step;
    }
  }
  function initializeHash() {
    hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
    neighbours = new Int32Array(hash.neighbourListLength);
  }
  function init() {
    ({
      probeRadius,
      scaleFactor,
      probePositions,
      visibilitySelector
    } = params);
    r2 = utils.allocateTyped(Float32Array, nAtoms);
    maxRadius = 0;
    for (let innI = 0; innI < nAtoms; ++innI) {
      const rExt = posRad[innI * itemSize + 3] += probeRadius;
      if (rExt > maxRadius) {
        maxRadius = rExt;
      }
      r2[innI] = rExt * rExt;
    }
    initializeGrid();
    initializeAngleTables();
    initializeHash();
    lastClip = -1;
  }
  function singleAtomObscures(ai, innX, innY, innZ) {
    const innCI = itemSize * ai;
    const ra2 = r2[ai];
    const dx = posRad[innCI] - innX;
    const dy = posRad[innCI + 1] - innY;
    const dz = posRad[innCI + 2] - innZ;
    const d2 = dx * dx + dy * dy + dz * dz;
    return d2 < ra2;
  }
  function obscured(innX, innY, innZ, a, b) {
    // Is the point at x,y,z obscured by any of the atoms
    // specifeid by indices in neighbours. Ignore indices
    // a and b (these are the relevant atoms in projectPoints/Torii)

    // Cache the last clipped atom (as very often the same one in
    // subsequent calls)
    let ai;
    if (lastClip !== -1) {
      ai = lastClip;
      if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
        return ai;
      }
      lastClip = -1;
    }
    let ni = 0;
    ai = neighbours[ni];
    while (ai >= 0) {
      if (ai !== a && ai !== b && singleAtomObscures(ai, innX, innY, innZ)) {
        lastClip = ai;
        return ai;
      }
      ai = neighbours[++ni];
    }
    lastClip = -1;
    return -1;
  }
  function projectPoints() {
    // For each atom:
    //     Iterate over a subsection of the grid, for each point:
    //         If current value < 0.0, unvisited, set positive
    //
    //         In any case: Project this point onto surface of the atomic sphere
    //         If this projected point is not obscured by any other atom
    //             Calcualte delta distance and set grid value to minimum of
    //             itself and delta

    // Should we alias frequently accessed closure constiables??
    // Assume JS engine capable of optimizing this
    // anyway...
    const maxRad = 4.0;
    const sigma = maxRad / 3;
    const sigma2Inv = 1 / (2 * sigma * sigma);
    for (let innI = 0; innI < nAtoms; innI++) {
      const innCI = itemSize * innI;
      const ax = posRad[innCI];
      const ay = posRad[innCI + 1];
      const az = posRad[innCI + 2];
      const ar = posRad[innCI + 3];
      const ar2 = r2[innI];
      hash.withinRadii(ax, ay, az, ar, neighbours);

      // Number of grid points, round this up...
      const ng = Math.ceil(ar * scaleFactor);

      // Center of the atom, mapped to grid points (take floor)
      const iax = Math.floor(scaleFactor * (ax - min[0]));
      const iay = Math.floor(scaleFactor * (ay - min[1]));
      const iaz = Math.floor(scaleFactor * (az - min[2]));

      // Extents of grid to consider for this atom
      const minx = Math.max(0, iax - ng);
      const miny = Math.max(0, iay - ng);
      const minz = Math.max(0, iaz - ng);

      // Add two to these points:
      // - iax are floor'd values so this ensures coverage
      // - these are loop limits (exclusive)
      const maxx = Math.min(dim[0], iax + ng + 2);
      const maxy = Math.min(dim[1], iay + ng + 2);
      const maxz = Math.min(dim[2], iaz + ng + 2);
      const colIdx = innI * 3;
      const cr = colors[colIdx];
      const cg = colors[colIdx + 1];
      const cb = colors[colIdx + 2];
      for (let iz = minz; iz < maxz; iz++) {
        const dz = gridz[iz] - az;
        const zOffset = dim[1] * dim[0] * iz;
        for (let iy = miny; iy < maxy; iy++) {
          const dy = gridy[iy] - ay;
          const dzy2 = dz * dz + dy * dy;
          const zyOffset = zOffset + dim[0] * iy;
          for (let ix = minx; ix < maxx; ix++) {
            const idx = ix + zyOffset;
            const dx = gridx[ix] - ax;
            const d2 = dzy2 + dx * dx;
            if (d2 < ar2) {
              const w = Math.exp(-d2 * sigma2Inv);
              const cIdx = idx * 3;
              volTex[cIdx] += cr * w;
              volTex[cIdx + 1] += cg * w;
              volTex[cIdx + 2] += cb * w;
              weights[idx] += w;
              if (visibilitySelector !== null && w > weightsMap[idx]) {
                weightsMap[idx] = w;
                atomMap[idx] = atoms[innI];
              }
              if (grid[idx] < 0.0) {
                // Unvisited, make positive
                grid[idx] = -grid[idx];
              }
              // Project on to the surface of the sphere
              // sp is the projected point ( dx, dy, dz ) * ( ra / d )
              const d = Math.sqrt(d2);
              const ap = ar / d;
              let spx = dx * ap;
              let spy = dy * ap;
              let spz = dz * ap;
              spx += ax;
              spy += ay;
              spz += az;
              if (obscured(spx, spy, spz, innI, -1) === -1) {
                const dd = ar - d;
                if (dd < grid[idx]) {
                  grid[idx] = dd;
                }
              }
            }
          }
        }
      }
    }
  }
  function normalToLine(out, p) {
    out.x = out.y = out.z = 1.0;
    if (p.x !== 0) {
      out.x = (p.y + p.z) / -p.x;
    } else if (p.y !== 0) {
      out.y = (p.x + p.z) / -p.y;
    } else if (p.z !== 0) {
      out.z = (p.x + p.y) / -p.z;
    }
    return out;
  }
  function projectTorus(a, b) {
    const aIdx = itemSize * a;
    const bIdx = itemSize * b;
    const xa = posRad[aIdx];
    const ya = posRad[aIdx + 1];
    const za = posRad[aIdx + 2];
    const r1 = posRad[aIdx + 3];
    let dx = mid.x = posRad[bIdx] - xa;
    let dy = mid.y = posRad[bIdx + 1] - ya;
    let dz = mid.z = posRad[bIdx + 2] - za;
    const innR2 = posRad[bIdx + 3];
    let d2 = dx * dx + dy * dy + dz * dz;

    // This check now redundant as already done in AVHash.withinRadii
    // if( d2 > (( r1 + r2 ) * ( r1 + r2 )) ){ return; }

    const d = Math.sqrt(d2);

    // Find angle between a->b vector and the circle
    // of their intersection by cosine rule
    const cosA = (r1 * r1 + d * d - innR2 * innR2) / (2.0 * r1 * d);

    // distance along a->b at intersection
    const dmp = r1 * cosA;
    mid.normalize();

    // Create normal to line
    normalToLine(n1, mid);
    n1.normalize();

    // Cross together for second normal vector
    n2.crossVectors(mid, n1);
    n2.normalize();

    // r is radius of circle of intersection
    const rInt = Math.sqrt(r1 * r1 - dmp * dmp);
    n1.multiplyScalar(rInt);
    n2.multiplyScalar(rInt);
    mid.multiplyScalar(dmp);
    mid.x += xa;
    mid.y += ya;
    mid.z += za;
    lastClip = -1;
    const ng = ngTorus;
    for (let innI = 0; innI < probePositions; innI++) {
      const cost = cosTable[innI];
      const sint = sinTable[innI];
      const px = mid.x + cost * n1.x + sint * n2.x;
      const py = mid.y + cost * n1.y + sint * n2.y;
      const pz = mid.z + cost * n1.z + sint * n2.z;
      if (obscured(px, py, pz, a, b) === -1) {
        // As above, iterate over our grid...
        // px, py, pz in grid coords
        const iax = Math.floor(scaleFactor * (px - min[0]));
        const iay = Math.floor(scaleFactor * (py - min[1]));
        const iaz = Math.floor(scaleFactor * (pz - min[2]));
        const minx = Math.max(0, iax - ng);
        const miny = Math.max(0, iay - ng);
        const minz = Math.max(0, iaz - ng);
        const maxx = Math.min(dim[0], iax + ng + 2);
        const maxy = Math.min(dim[1], iay + ng + 2);
        const maxz = Math.min(dim[2], iaz + ng + 2);
        for (let iz = minz; iz < maxz; iz++) {
          dz = pz - gridz[iz];
          const zOffset = dim[1] * dim[0] * iz;
          for (let iy = miny; iy < maxy; iy++) {
            dy = py - gridy[iy];
            const dzy2 = dz * dz + dy * dy;
            const zyOffset = zOffset + dim[0] * iy;
            for (let ix = minx; ix < maxx; ix++) {
              dx = px - gridx[ix];
              d2 = dzy2 + dx * dx;
              const idx = ix + zyOffset;
              const current = grid[idx];
              if (current > 0.0 && d2 < current * current) {
                grid[idx] = Math.sqrt(d2);
              }
            }
          }
        }
      }
    }
  }
  function projectTorii() {
    for (let innI = 0; innI < nAtoms; innI++) {
      const innIdx = itemSize * innI;
      hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
      let ia = 0;
      let ni = neighbours[ia];
      while (ni >= 0) {
        if (innI < ni) {
          projectTorus(innI, ni);
        }
        ni = neighbours[++ia];
      }
    }
  }
  function fixNegatives() {
    for (let innI = 0, n = grid.length; innI < n; innI++) {
      if (grid[innI] < 0) grid[innI] = 0;
      let w = weights[innI];
      if (w > 0) {
        w = 1 / w;
        const innInnI = innI * 3;
        volTex[innInnI] *= w;
        volTex[innInnI + 1] *= w;
        volTex[innInnI + 2] *= w;
      }
    }
  }
  function getVolume() {
    // Basic steps are:
    // 1) Initialize
    // 2) Project points
    // 3) Project torii
    console.time('ContactSurface.getVolume');
    console.time('ContactSurface.init');
    init();
    console.timeEnd('ContactSurface.init');
    console.time('ContactSurface.projectPoints');
    projectPoints();
    console.timeEnd('ContactSurface.projectPoints');
    console.time('ContactSurface.projectTorii');
    projectTorii();
    console.timeEnd('ContactSurface.projectTorii');
    fixNegatives();
    console.timeEnd('ContactSurface.getVolume');
  }
  this.build = function () {
    // type and cutoff left in for compatibility with EDTSurface.getSurface
    // function signature
    getVolume();
    this.volTexMap = volTex;
    this.weightsMap = weightsMap;
    this.atomMap = atomMap;
    this.volMap = grid;
  };
}
/* harmony default export */ const geometries_ContactSurface = (ContactSurface);
;// CONCATENATED MODULE: ./src/gfx/geometries/ContactSurfaceGeometry.js



const {
  Volume: ContactSurfaceGeometry_Volume
} = chem;

/**
 * This class implements 'contact' isosurface geometry generation algorithm.
 * @param spheresCount - number of atoms/spheres
 * @param opts - geometry specific options
 * @constructor
 */

class ContactSurfaceGeometry extends geometries_VolumeSurfaceGeometry {
  _computeSurface(packedArrays, box, boundaries, params) {
    const contactSurface = new geometries_ContactSurface(packedArrays, boundaries, params);
    contactSurface.build();
    const surface = {
      volMap: new ContactSurfaceGeometry_Volume(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
      volTexMap: new ContactSurfaceGeometry_Volume(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
      atomMap: contactSurface.atomMap,
      atomWeightMap: new ContactSurfaceGeometry_Volume(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
    };
    return surface;
  }
}
/* harmony default export */ const geometries_ContactSurfaceGeometry = (ContactSurfaceGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/IsoSurfaceAtomColored.js


/**
 * Class for colored atom. Need for atom structure clusterization
 *
 * @param {Vector3} vCenter   Center of atom
 * @param {number}  radiusAt  Radius of atom
 */
class IsoSurfaceAtomColored {
  constructor(vCenter, radiusAt) {
    this.coord = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this.coord.copy(vCenter);
    this.radius = radiusAt;
    this.colorX = 0.99999;
    this.colorY = 0.0;
    this.colorZ = 0.0;
    this.atomType = 0;
    this.srcAtom = null;
  }
}
/* harmony default export */ const geometries_IsoSurfaceAtomColored = (IsoSurfaceAtomColored);
;// CONCATENATED MODULE: ./src/gfx/geometries/IsosurfaceBuildNormals.js



// suppress some JSHint warnings
/* jshint bitwise: false */

/**
 * Build normals for isosurface, using atoms information
 *
 * @param {number} numAtoms     - Number of atoms in molecule
 * @param {Element} atoms      - Array of atoms
 * @param {Vector3} vBoxMin     - Bounding box min
 * @param {Vector3} vBoxMax     - Bounding box max
 * @param {number} probeRadius     - Normals for output
 *
 */
class IsosurfaceBuildNormals {
  constructor(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
    this._numAtoms = numAtoms;
    this._atoms = atoms;
    this._vBoxMin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._vBoxMax = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._vBoxMin.copy(vBoxMin);
    this._vBoxMax.copy(vBoxMax);
    this._probeRadius = probeRadius;
    this._atomsList = null;
    this._voxelList = null;
  }
  createVoxels() {
    let numAtomsRefs;
    let rad;
    const ATOM_VOXEL_REF_SCALE = 4.5;
    const numAtoms = this._numAtoms | 0;
    const atoms = this._atoms;
    const dx = this._vBoxMax.x - this._vBoxMin.x;
    const dy = this._vBoxMax.y - this._vBoxMin.y;
    const dz = this._vBoxMax.z - this._vBoxMin.z;
    let w = dx < dy ? dx : dy;
    w = dz < w ? dz : w;
    let maxRad = 0.0;
    let aveRad = 0.0;
    let i;
    for (i = 0; i < numAtoms; i++) {
      rad = (atoms[i].radius + this._probeRadius) * 2.0;
      maxRad = rad > maxRad ? rad : maxRad;
      aveRad += rad;
    }
    let numCells = Math.floor(w / maxRad);
    if (numCells < 2) {
      numCells = 2;
    }
    aveRad /= numAtoms;
    this._numCells = numCells;
    this._aveRad = aveRad;
    this._maxRad = maxRad;
    const side = numCells;
    const side2 = numCells * numCells;
    const side3 = numCells * numCells * numCells;
    const xScale = this._xScale = 1.0 / (this._vBoxMax.x - this._vBoxMin.x);
    const yScale = this._yScale = 1.0 / (this._vBoxMax.y - this._vBoxMin.y);
    const zScale = this._zScale = 1.0 / (this._vBoxMax.z - this._vBoxMin.z);

    // estimate number of individual atom refs in each voxel list
    let maxAtomsRefs = 0;
    const xNumVoxMult = xScale * numCells;
    const yNumVoxMult = yScale * numCells;
    const zNumVoxMult = zScale * numCells;
    for (i = 0; i < numAtoms; i++) {
      const radAffect = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
      const diaAffect = radAffect * 2.0;
      let numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
      let numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
      let numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8);
      // avoid case numVox? == 0
      // also use loop i <=
      numVoxX++;
      numVoxY++;
      numVoxZ++;
      maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
    } // for (i)
    // maxAtomsRefs = numAtoms * MAX_ATOMS_IN_SINGLE_VOXEL;

    this._voxelList = utils.allocateTyped(Int32Array, side3);
    const atomsList = [];
    atomsList.length = maxAtomsRefs;
    if (this._voxelList === null || atomsList === null) {
      return 0 - 1;
    }
    // init voxel list
    for (i = 0; i < side3; i++) {
      this._voxelList[i] = -1;
    }
    numAtomsRefs = 0;

    // create voxel lists
    for (i = 0; i < numAtoms; i++) {
      // use multiplier 4 to locate this atom in different voxels
      rad = (atoms[i].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
      let xIndMin = Math.floor((atoms[i].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
      let yIndMin = Math.floor((atoms[i].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
      let zIndMin = Math.floor((atoms[i].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
      let xIndMax = Math.floor((atoms[i].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
      let yIndMax = Math.floor((atoms[i].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
      let zIndMax = Math.floor((atoms[i].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
      xIndMin = xIndMin >= 0 ? xIndMin : 0;
      yIndMin = yIndMin >= 0 ? yIndMin : 0;
      zIndMin = zIndMin >= 0 ? zIndMin : 0;
      xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
      yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
      zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;
      for (let z = zIndMin; z <= zIndMax; z++) {
        for (let y = yIndMin; y <= yIndMax; y++) {
          for (let x = xIndMin; x <= xIndMax; x++) {
            // add atom with index "i" to this voxel list
            const indVoxel = x + y * side + z * side2;
            // assert indVoxel >= 0
            // assert indVoxel < side3

            // add first
            if (this._voxelList[indVoxel] < 0) {
              atomsList[numAtomsRefs * 2 + 0] = i;
              atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
              this._voxelList[indVoxel] = numAtomsRefs;
              numAtomsRefs++;
              // assert numAtomsRefs < maxAtomsRefs - 1
              continue;
            }
            // insert into head of list
            const indexNext = this._voxelList[indVoxel];
            this._voxelList[indVoxel] = numAtomsRefs;
            atomsList[numAtomsRefs * 2 + 0] = i;
            atomsList[numAtomsRefs * 2 + 1] = indexNext;
            numAtomsRefs++;
          } // for (x)
        } // for (y)
      } // for (z)
    } // for (i)

    // convert Array to Int32Array
    this._atomsList = Int32Array.from(atomsList);
    return 0;
  }
  destroyVoxels() {
    this._atomsList = null;
    this._voxelList = null;
    this._atoms = null;
    this._vertices = null;
    this._vBoxMin = null;
    this._vBoxMax = null;
  }

  /**
   * Enumerate all atoms affecting specified point
   *
   * @param {Vector3}    point    - point in 3D
   * @param {func(atom)} process  - function to call for each atom
   */
  forEachRelatedAtom(point, process) {
    // find corresponding voxel
    const xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
    const yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
    const zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
    const indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells;

    // run through atoms affecting this voxel
    const atoms = this._atoms;
    for (let ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
      const indexAtom = this._atomsList[ref * 2];
      process(atoms[indexAtom]);
    }
  }

  /**
   * Get atom closest to specified point
   *
   * @param {Vector3} point  - point in 3D
   *
   * @returns {IsoSurfaceAtomColored} atom, or null if not found
   */
  getClosestAtom(point) {
    let closest = null;
    let minDist2 = Number.MAX_VALUE;
    this.forEachRelatedAtom(point, atom => {
      const dist2 = point.distanceToSquared(atom.coord);
      if (dist2 < minDist2) {
        minDist2 = dist2;
        closest = atom;
      }
    });
    return closest;
  }

  /**
   * Build normals for isosurface, using atoms information
   *
   * @param {number} numVertices  - Number of vertices in final geometry (to render)
   * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
   * @param {Vector3} normals     - Normals for output
   *
   * @returns {number} 0, if success
   */
  buildNormals(numVertices, vertices, normals) {
    const self = this;
    let numCloseAtoms = 0;
    let vx = 0;
    let vy = 0;
    let vz = 0;
    let dist2;
    let vNormalX = 0;
    let vNormalY = 0;
    let vNormalZ = 0;
    let koef = 0;
    let w = 0;
    const r25 = 2.5;
    const r01 = 0.1;
    const maxRadAffect = this._aveRad * r25;
    const maxRadAffect2 = maxRadAffect * maxRadAffect;
    const expScale = -this._aveRad * r01;

    // some stats
    // numSlowAtoms = 0;

    const gatherNormals = function (atom) {
      const dx = vx - atom.coord.x;
      const dy = vy - atom.coord.y;
      const dz = vz - atom.coord.z;
      dist2 = dx * dx + dy * dy + dz * dz;
      if (dist2 > maxRadAffect2) {
        return;
      }

      // get weight for gaussian smoothing
      const rad = atom.radius + self._probeRadius;
      koef = dist2 - rad * rad;
      if (koef < 0.0) {
        koef = -koef;
      }
      w = Math.exp(expScale * koef);
      vNormalX += dx * w;
      vNormalY += dy * w;
      vNormalZ += dz * w;
      numCloseAtoms++;
    };
    let maxClosedAtoms = 0;
    // process all vertices, one by one
    for (let i = 0; i < numVertices; i++) {
      vx = vertices[i].x;
      vy = vertices[i].y;
      vz = vertices[i].z;
      numCloseAtoms = 0;
      vNormalX = vNormalY = vNormalZ = 0.0;
      this.forEachRelatedAtom(vertices[i], gatherNormals);
      maxClosedAtoms = numCloseAtoms > maxClosedAtoms ? numCloseAtoms : maxClosedAtoms;

      // normalize vNormal
      dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;
      if (numCloseAtoms > 0) {
        koef = 1.0 / Math.sqrt(dist2);
        vNormalX *= koef;
        vNormalY *= koef;
        vNormalZ *= koef;
      }
      normals[i].x = vNormalX;
      normals[i].y = vNormalY;
      normals[i].z = vNormalZ;
    } // for (i) all vertices

    return 0;
  }

  /**
   * Build vertex colors for isosurface, using atoms information
   *
   * @param {number} numVertices  - Number of vertices in final geometry (to render)
   * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
   * @param {Vector3} colors                - Colors for output
   * @param {number} radiusColorSmoothness  - Radius of smoothness sphere
   *
   * @returns {number} 0, if success
   */
  buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
    const self = this;
    let vx = 0.0;
    let vy = 0.0;
    let vz = 0.0;
    let koef = 0.0;
    let w = 0.0;
    const KOEF_ADD = 0.8;
    const maxRadAffect = radiusColorSmoothness;
    const maxRadAffect2 = maxRadAffect * maxRadAffect;
    let colorsClose = [];
    let weights = [];
    let weightsSum = 0;
    const gatherColors = function (atom) {
      const dx = vx - atom.coord.x;
      const dy = vy - atom.coord.y;
      const dz = vz - atom.coord.z;
      const dist2 = dx * dx + dy * dy + dz * dz;
      if (dist2 > maxRadAffect2) {
        return;
      }

      // get weight for gaussian smoothing
      const rad = atom.radius + self._probeRadius;
      koef = dist2 - rad * rad;
      if (koef < 0.0) {
        koef = -koef;
      }
      w = 1.0 / (KOEF_ADD + koef);
      colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
      weights.push(w); // save weights for use
      weightsSum += w; // calc sum of weights fo further normalization
    };

    // process all vertices, one by one
    for (let i = 0; i < numVertices; i++) {
      vx = vertices[i].x;
      vy = vertices[i].y;
      vz = vertices[i].z;
      colorsClose = [];
      weights = [];
      weightsSum = 0;
      this.forEachRelatedAtom(vertices[i], gatherColors);

      // normalized weighted sum of colors
      for (let j = 0; j < colorsClose.length; ++j) {
        const weightNormalized = weights[j] / weightsSum;
        colors[i].x += colorsClose[j][0] * weightNormalized;
        colors[i].y += colorsClose[j][1] * weightNormalized;
        colors[i].z += colorsClose[j][2] * weightNormalized;
      }
    } // for (i) all vertices
    return 0;
  }
}
/* harmony default export */ const geometries_IsosurfaceBuildNormals = (IsosurfaceBuildNormals);
;// CONCATENATED MODULE: ./src/gfx/geometries/IsoSurfaceGeo.js


/**
 * Class for geometry (triangle mesh) representation
 *
 *
 * @param {number} maxNumVertices Maximum possible number of vertices in mesh
 * @param {number} maxNumTriangles Maximum possible number of triangles in mesh
 * @param {boolean} needVertexColors Obvious
 */
class IsoSurfaceGeo {
  constructor(maxNumVertices, maxNumTriangles, needVertexColors) {
    this._maxNumVertices = maxNumVertices;
    this._maxNumTriangles = maxNumTriangles;
    this._vertices = new Array(maxNumVertices);
    this._normals = new Array(maxNumVertices);
    this._colors = null;
    if (needVertexColors) {
      this._colors = new Array(maxNumVertices);
    }
    this._indices = new Array(maxNumTriangles * (1 + 2));
    this._numVertices = 0;
    this._numTriangles = 0;
    let i;
    for (i = 0; i < maxNumVertices; i++) {
      this._vertices[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      this._normals[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
    for (i = 0; i < maxNumTriangles * (1 + 2); i++) {
      this._indices[i] = -1;
    }
    if (needVertexColors) {
      for (i = 0; i < maxNumVertices; i++) {
        this._colors[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      }
    }
  }
  destroy() {
    this._vertices = null;
    this._normals = null;
    this._indices = null;
  }
}
/* harmony default export */ const geometries_IsoSurfaceGeo = (IsoSurfaceGeo);
;// CONCATENATED MODULE: ./src/gfx/geometries/SSIsosurfaceGeometry.js








const SSIsosurfaceGeometry_COLOR_SIZE = 3;
const HASH_SIZE = 32768;
const {
  Element: SSIsosurfaceGeometry_Element
} = chem;

/**
 * This class implements 'quick' isosurface geometry generation algorithm.
 * @param spheresCount - number of atoms/spheres
 * @param opts - geometry specific options
 * @constructor
 */

class SSIsosurfaceGeometry extends geometries_IsoSurfaceGeometry {
  _build() {
    // convert geoOut into arrays of positions, indices, normals
    this._innerBuild();
    const geoOut = this.getGeo();
    this.destroy();
    this._fromGeo(geoOut);
  }
  _fromGeo(geoOut) {
    let colors = null;
    const positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    const normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    if (geoOut._colors !== null) {
      colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    }
    const indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);
    for (let i = 0, j = 0; i < geoOut._numVertices; i++) {
      positions[j + 0] = geoOut._vertices[i].x;
      positions[j + 1] = geoOut._vertices[i].y;
      positions[j + 2] = geoOut._vertices[i].z;
      normals[j + 0] = geoOut._normals[i].x;
      normals[j + 1] = geoOut._normals[i].y;
      normals[j + 2] = geoOut._normals[i].z;
      j += 3;
    }
    if (colors !== null) {
      for (let i = 0, j = 0; i < geoOut._numVertices; i++, j += 3) {
        colors[j + 0] = geoOut._colors[i].x;
        colors[j + 1] = geoOut._colors[i].y;
        colors[j + 2] = geoOut._colors[i].z;
      }
    }
    const numTri3 = geoOut._numTriangles * (1 + 2);
    for (let i = 0; i < numTri3; i++) {
      indices[i] = geoOut._indices[i];
    }
    this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(indices, 1));
    this.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(positions, 3));
    this.setAttribute('normal', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(normals, 3));
    this.setAttribute('color', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(colors, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    geoOut.destroy();
  }
  convertToAtomsColored(packedArrays, atomsColored) {
    const {
      atoms,
      colors
    } = packedArrays;
    for (let i = 0, numAtoms = atoms.length; i < numAtoms; i++) {
      const vCenter = atoms[i].position;
      const {
        radius
      } = atoms[i].element;
      atomsColored[i] = new geometries_IsoSurfaceAtomColored(vCenter, radius);
      const nm = atoms[i].element.number;
      atomsColored[i].atomType = this.getType(nm);
      let cIdx = SSIsosurfaceGeometry_COLOR_SIZE * i;
      atomsColored[i].colorX = colors[cIdx++];
      atomsColored[i].colorY = colors[cIdx++];
      atomsColored[i].colorZ = colors[cIdx];
      atomsColored[i].srcAtom = atoms[i];
    }
  }
  getGeo() {
    return this.geoOut;
  }
  destroy() {
    this.atoms = null;
    this.hashLines = null;
    this.hashEntries = null;
  }

  /**
   * Calculates bounding box for array with spheres (atoms)
   *
   * @param {Object}  atoms      Atoms array
   * @param {Vector3} vBoxMin    Bounding box min point
   * @param {Vector3} vBoxMax    Bounding box max point
   */
  getBoundingBox(atoms, vBoxMin, vBoxMax) {
    const bigNum = 10000000.0;
    vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
    vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
    const probeRadius2 = this.probeRadius * this.atomRadiusScale;
    let radMax = 0.0;
    for (let i = 0, num = atoms.length; i < num; i++) {
      const vCenter = atoms[i].coord;
      const rad = atoms[i].radius + probeRadius2;
      radMax = rad > radMax ? rad : radMax;
      if (vCenter.x - rad < vBoxMin.x) {
        vBoxMin.x = vCenter.x - rad;
      }
      if (vCenter.y - rad < vBoxMin.y) {
        vBoxMin.y = vCenter.y - rad;
      }
      if (vCenter.z - rad < vBoxMin.z) {
        vBoxMin.z = vCenter.z - rad;
      }
      if (vCenter.x + rad > vBoxMax.x) {
        vBoxMax.x = vCenter.x + rad;
      }
      if (vCenter.y + rad > vBoxMax.y) {
        vBoxMax.y = vCenter.y + rad;
      }
      if (vCenter.z + rad > vBoxMax.z) {
        vBoxMax.z = vCenter.z + rad;
      }
    }
    vBoxMin.x -= radMax;
    vBoxMin.y -= radMax;
    vBoxMin.z -= radMax;
    vBoxMax.x += radMax;
    vBoxMax.y += radMax;
    vBoxMax.z += radMax;
  }

  /**
   * Calculate (x,y,z) cordinate of the cell corner point
   *
   * @param {Vector3} vBoxMin Bounding box min point
   * @param {Vector3} vBoxMax Bounding box max point
   * @param {number} x Cell integer x coordinate
   * @param {number} y Cell integer y coordinate
   * @param {number} z Cell integer z coordinate
   * @param {number} numPoints NUm points in cell on side
   * @param {Vector3} vOut Output vector
   */
  getCornerCoord(vBoxMin, vBoxMax, x, y, z, numPoints, vOut) {
    const invNP = 1.0 / (numPoints - 1.0);
    const tx = x * invNP;
    const ty = y * invNP;
    const tz = z * invNP;
    vOut.x = vBoxMin.x * (1.0 - tx) + vBoxMax.x * tx;
    vOut.y = vBoxMin.y * (1.0 - ty) + vBoxMax.y * ty;
    vOut.z = vBoxMin.z * (1.0 - tz) + vBoxMax.z * tz;
  }

  /**
   * Calculate point of intersection of sphere surface
   * and cell edge, given by [indexA, indexB] line
   *
   * @param {number} indexA Cell vertex index in [0..11]
   * @param {number} indexB Cell vertex index in [0..11]
   * @param {array}  sign   Sign array for all 8 vertices
   * @param {object} cube   Cube
   * @param {number} indexPointValue for value placement
   * @param {Vector3} vOut  Point of intersection
   */
  buildEdgePoint(indexA, indexB, sign, cube, indexPointValue, vOut) {
    if (sign[indexA] ^ sign[indexB]) {
      const cTwentyFour = 24;
      const t = (0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]) / (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]);
      const xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
      const ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
      const za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
      const xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
      const yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
      const zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
      vOut.x = xa * (1.0 - t) + xb * t;
      vOut.y = ya * (1.0 - t) + yb * t;
      vOut.z = za * (1.0 - t) + zb * t;
    }
  }

  /**
   * Check if triangle is visible (vertices are close to atoms included in visibility set)
   *
   * @param {Vector3} v0 Vertex #0
   * @param {Vector3} v1 Vertex #1
   * @param {Vector3} v2 Vertex #2
   * @returns {boolean} true if triangle is visible
   */
  isTriangleVisible(v0, v1, v2) {
    const a0 = this.voxelWorld.getClosestAtom(v0);
    const a1 = this.voxelWorld.getClosestAtom(v1);
    const a2 = this.voxelWorld.getClosestAtom(v2);
    if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
      return false;
    }
    return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
  }

  /**
   * Add triangle to result geometry
   *
   * @param {Vector3} v0 Vertex #0
   * @param {Vector3} v1 Vertex #1
   * @param {Vector3} v2 Vertex #2
   * @returns {boolean} false if no more triangles can be added
   */
  addTriangle(v0, v1, v2) {
    if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
      return true;
    }
    const geo = this.geoOut;
    if (geo._numTriangles >= this.maxNumTriangles) {
      return false;
    }

    // Add vertex with optimize
    const indInGeo0 = this.addVertexToGeo(geo, v0);
    const indInGeo1 = this.addVertexToGeo(geo, v1);
    const indInGeo2 = this.addVertexToGeo(geo, v2);
    if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
      return false;
    }
    const itr = 3 * geo._numTriangles;
    geo._indices[itr + 0] = indInGeo0;
    geo._indices[itr + 1] = indInGeo1;
    geo._indices[itr + 2] = indInGeo2;
    geo._numTriangles++;
    return true;
  }

  /**
   * Build result geometry (triangle mesh) from marching cube cells
   *
   * @param {number} meshRes Marchnig cube vertex count on each side
   * @param {Vector3} vBoxMin Bounding box point min
   * @param {Vector3} vBoxMax Bounding box point max
   * @param {number} corners float values array for each cube point
   * @param {Vector3} vCellStep vector to next cube cell diagonal point
   * @param {object} cube IsoSurfaceMarchCube object
   * @returns {number} 0, if success (<0) is error
   */
  buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
    const arrSize = 12;
    const cNumVerts = 8;
    const numCells = meshRes - 1;
    const side = meshRes;
    const side2 = meshRes * meshRes;
    const vaEdges = new Array(arrSize);
    for (let i = 0; i < arrSize; i++) {
      vaEdges[i] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
    const sign = [];
    for (let i = 0; i < cNumVerts; i++) {
      sign[i] = 1.0;
    }
    const vCorner = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let indCell = 0;
    let indY = 0;
    for (let y = 0; y < numCells; y++, indY += side2) {
      let indZ = 0;
      for (let z = 0; z < numCells; z++, indZ += side) {
        for (let x = 0; x < numCells; x++) {
          if (!cube.hasIntersection[indCell]) {
            // next cell
            indCell++;
            continue;
          }
          const bitsInside = cube.bitsInside[indCell];
          this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, meshRes, vCorner);
          const indPointValues = indCell * (2 << 2 + 2);
          for (let i = 0, j = 0; i < cNumVerts; i++) {
            cube.pointsValuesLinear[indPointValues + j++] = vCorner.x;
            cube.pointsValuesLinear[indPointValues + j++] = vCorner.y;
            cube.pointsValuesLinear[indPointValues + j++] = vCorner.z;
          }
          cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
          cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
          cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
          cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y;

          // now current cell has intersections (from -x to +x) on some cube edges
          const indValues = indPointValues + 24;
          for (let i = 0; i < cNumVerts; ++i) {
            sign[i] = cube.pointsValuesLinear[indValues + i] < 0.0 ? 1 : 0;
          }
          this.buildEdgePoint(0, 1, sign, cube, indPointValues, vaEdges[0]);
          this.buildEdgePoint(1, 2, sign, cube, indPointValues, vaEdges[1]);
          this.buildEdgePoint(2, 3, sign, cube, indPointValues, vaEdges[2]);
          this.buildEdgePoint(3, 0, sign, cube, indPointValues, vaEdges[3]);
          this.buildEdgePoint(4, 5, sign, cube, indPointValues, vaEdges[4]);
          this.buildEdgePoint(5, 6, sign, cube, indPointValues, vaEdges[5]);
          this.buildEdgePoint(6, 7, sign, cube, indPointValues, vaEdges[6]);
          this.buildEdgePoint(7, 4, sign, cube, indPointValues, vaEdges[7]);
          this.buildEdgePoint(0, 4, sign, cube, indPointValues, vaEdges[8]);
          this.buildEdgePoint(1, 5, sign, cube, indPointValues, vaEdges[9]);
          this.buildEdgePoint(2, 6, sign, cube, indPointValues, vaEdges[10]);
          this.buildEdgePoint(3, 7, sign, cube, indPointValues, vaEdges[11]);
          const offs = bitsInside * (2 << 1 + 2);
          for (let numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
            // s_triIndicesMarchCube is external array, defined in mold_ind.js
            const i0 = cube.striIndicesMarchCube[offs + indTri];
            if (i0 < 0) {
              break;
            }
            const i1 = cube.striIndicesMarchCube[offs + indTri + 1];
            const i2 = cube.striIndicesMarchCube[offs + indTri + 2];
            if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])) {
              return 0 - 2;
            }
          } // for numTri

          // next cell (cube)
          indCell++;
        } // for (x)
      } // for (z)
    } // for (y)
    return 0;
  }

  /**
   * Returns number of cell with intersection with at least one sphere.
   * Using this number, we can estimate required number of vertices
   * and triangles to build result mesh.
   *
   * @param {number} side Number of points in cube voxels
   * @param {number} numCells Number of cells in cube voxels (per direction)
   * @param {array} corners Array of float values for cube corner points
   * @param {object} cube IsoSurfaceMarchCube object
   * @returns {number} numIntersectedCells
   */
  getNumIntersectedCells(side, numCells, corners, cube) {
    const side2 = side * side;
    const cNumVerts = 8;
    let numIntersectedCells = 0;
    let indCell = 0;
    let indY = 0;
    for (let y = 0; y < numCells; y++, indY += side2) {
      let indZ = 0;
      for (let z = 0; z < numCells; z++, indZ += side) {
        for (let x = 0; x < numCells; x++) {
          const cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
          const indCorner = x + indZ + indY;
          cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
          cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
          cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
          cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side];

          // check read exception
          // assert(side2 + indCorner + side + 1 < side3);

          // get bit flags inside
          let bitsInside = 0;
          for (let i = 0; i < cNumVerts; ++i) {
            if (cube.pointsValuesLinear[cubeValuesIndex + i] < 0.0) {
              bitsInside |= 1 << i;
            }
          }
          if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
            cube.hasIntersection[indCell] = false;
          } else {
            cube.hasIntersection[indCell] = true;
            numIntersectedCells++;
          }
          cube.bitsInside[indCell] = bitsInside;
          // next cell
          indCell++;
        } // for (x)
      } // for (z)
    } // for (y)
    return numIntersectedCells;
  }
  getType(letter) {
    /* eslint-disable no-magic-numbers */
    const atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];
    /* eslint-enable no-magic-numbers */

    if (letter < 1 || letter > atomT.length / 2 || Object.keys(SSIsosurfaceGeometry_Element.ByAtomicNumber).length * 2 !== atomT.length) {
      throw new Error('atomT.length  should be equal Element.ByAtomicNumber.length * 2');
    }
    return atomT[letter * 2];
  }

  /**
   * Calculate values for marching cube grid points
   * positive values are outside sphere, negative - is inside
   *
   * @param {array} corners array of float values
   * @param {number} side Number of point in cube in 1 dimennsion
   * @param {Vector3} vBoxMin Bounding box min point
   * @param {Vector3} vBoxMax Bounding box max point
   * @param {array} atoms Array of input atoms
   * @param {number} probeRad radius for atom probing
   */
  calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
    const side2 = side * side;
    const side3 = side2 * side;
    const vCorner = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vDif = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    /* eslint-disable no-magic-numbers */
    const aLot = +1.0e12;
    /* eslint-enable no-magic-numbers */

    for (let i = 0; i < side3; i++) {
      corners[i] = aLot; // to large value
    }
    const xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
    const yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
    const zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
    for (let s = 0, numAtoms = atoms.length; s < numAtoms; s++) {
      const atom = atoms[s];
      const radius = atom.radius + probeRad;
      const fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
      const fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
      const fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
      const indXMin = Math.floor(fx);
      const indYMin = Math.floor(fy);
      const indZMin = Math.floor(fz);
      let indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
      let indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
      let indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
      indXMax++;
      indYMax++;
      indZMax++;
      indXMax = indXMax <= side - 1 ? indXMax : side - 1;
      indYMax = indYMax <= side - 1 ? indYMax : side - 1;
      indZMax = indZMax <= side - 1 ? indZMax : side - 1;
      for (let y = indYMin; y <= indYMax; y++) {
        const indY = y * side2;
        for (let z = indZMin; z <= indZMax; z++) {
          const indZ = z * side;
          for (let x = indXMin; x <= indXMax; x++) {
            const ind = indY + indZ + x;
            this.getCornerCoord(vBoxMin, vBoxMax, x, y, z, side, vCorner);
            vDif.x = vCorner.x - atom.coord.x;
            vDif.y = vCorner.y - atom.coord.y;
            vDif.z = vCorner.z - atom.coord.z;
            const distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z);
            // val: < 0, if inside sphere
            // val: > 0, if outside sphere
            const val = distToSphere - radius;
            if (val < corners[ind]) {
              corners[ind] = val;
            }
          } // for (x)
        } // for (z)
      } // for (y)
    } // for (s)
  }

  /**
   * Create memory pool for vertex hash management
   *
   * @param {number} maxNumVertices Maximum possible number of vertices (that will be build)
   * @param {number} maxNumTriangles Maximum possible number of triangles (that will be build)
   * @returns {number} 0, if success. (<0) is non memory
   */
  createVertexHash(maxNumVertices, maxNumTriangles) {
    this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);
    if (this.hashLines === null) {
      return 0 - 1;
    }
    for (let i = 0, j = 0; i < HASH_SIZE; i++) {
      this.hashLines[j++] = 0; // num vertices in this hash line
      this.hashLines[j++] = 0 - 1; // index of the first entry
    }
    this.maxNumVertices = maxNumVertices;
    this.maxNumTriangles = maxNumTriangles;
    this.numHashEtriesAllocated = maxNumVertices;
    this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);
    if (this.hashEntries === null) {
      return 0 - 1;
    }
    for (let i = 0, j = 0; i < this.numHashEtriesAllocated; i++) {
      this.hashEntries[j++] = 0 - 1; // index of vertex
      this.hashEntries[j++] = 0 - 1; // next hash entry index
    }
    this.numHashEntryIndex = 0;
    return 0;
  }

  /**
   * Allocate and return new hash entry. Just check possible amount.
   *
   * @returns {number} index of hash entry, that can be used for geometry add vertex functionality
   */
  getNewHashEntry() {
    if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
      const i = this.numHashEntryIndex;
      this.numHashEntryIndex++;
      return i;
    }
    return 0 - 1;
  }

  /**
   * Add vertex to geometry structure
   * using vertex hash table to quickly check, is this vertex already exist in geometry
   *
   * @param {object} geoOut Geometry to build
   * @param {Vector3} vAdd Vertex to add
   * @returns {number} index of added (or existing) vertex in geometry.
   */
  addVertexToGeo(geoOut, vAdd) {
    let entry;
    const oneHynberes = 0.01;
    const n815851 = 815851;
    const n37633 = 37633;
    const n2453543 = 2453543;
    const r106 = 1.0e-6;
    const hashResolution = this.marCubeResoultion << 2;
    const v = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
    const iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
    const iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
    let iHash = ix * n815851 + iz * n37633 + iy * n2453543;
    iHash &= HASH_SIZE - 1;
    const hLineIndex = iHash + iHash;

    // search vertex via hash
    // search in hash list
    if (this.vBoxMin !== null && this.vBoxMax !== null) {
      for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
        const ind = this.hashEntries[entry * 2 + 0]; // vertex index
        v.copy(geoOut._vertices[ind]);
        v.x -= vAdd.x;
        v.y -= vAdd.y;
        v.z -= vAdd.z;
        const dot2 = v.x * v.x + v.y * v.y + v.z * v.z;
        if (dot2 < r106) {
          return ind;
        } // if (found)
      } // for (entry)
    } // search

    // add new vertex to geometry
    if (geoOut._numVertices >= this.maxNumVertices) {
      return 0 - 1;
    }
    const iVertAdd = geoOut._numVertices;
    geoOut._vertices[iVertAdd].copy(vAdd);

    // add to hash
    if (this.vBoxMin !== null && this.vBoxMax !== null) {
      entry = this.getNewHashEntry();
      if (entry < 0) {
        return 0 - 1;
      }
      const entryFirst = this.hashLines[hLineIndex + 1];
      this.hashLines[hLineIndex + 1] = entry;
      this.hashEntries[entry * 2 + 0] = iVertAdd;
      this.hashEntries[entry * 2 + 1] = entryFirst;
      this.hashLines[hLineIndex + 0]++; // num vertices in line ++
    }
    geoOut._numVertices++;
    return iVertAdd;
  }

  /**
   *
   * @param {number} side some placeholder description
   * @param {number} probeSphereRadius some placeholder description
   * @param {object} vBoxMin some placeholder description
   * @param {object} vBoxMax some placeholder description
   * @param {object} geoOut some placeholder description
   * @param {object} corners some placeholder description
   * @returns {number} always 0
   */
  modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
    let ind;
    let distToSphere;
    let distToBorder;
    const r11 = 1.1;
    function innerBlockWorkAround() {
      if (distToBorder > 0.0) {
        // point is inside probe sphere
        if (corners[ind] < 0.0) {
          corners[ind] = distToBorder; // was inside surface, now is oustide ( > 0)
        }
        if (distToBorder > corners[ind]) {
          corners[ind] = distToBorder; // find positive maximum
        }
      } else if (distToBorder > corners[ind]) {
        // point is outside sphere
        corners[ind] = distToBorder; // find negative maximum
      }
    }
    const side2 = side * side;
    const xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
    const yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
    const zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
    const probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
    const sideInv = 1.0 / (side - 1);
    for (let i = 0; i < geoOut._numVertices; i++) {
      const vCenter = geoOut._vertices[i];
      const radEst = probeSphereRadius * r11;
      let indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
      let indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
      let indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
      let indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
      let indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
      let indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
      indXMin = indXMin >= 0 ? indXMin : 0;
      indYMin = indYMin >= 0 ? indYMin : 0;
      indZMin = indZMin >= 0 ? indZMin : 0;
      indXMax = indXMax <= side - 1 ? indXMax : side - 1;
      indYMax = indYMax <= side - 1 ? indYMax : side - 1;
      indZMax = indZMax <= side - 1 ? indZMax : side - 1;
      for (let iy = indYMin; iy <= indYMax; iy++) {
        const indY = iy * side2;
        for (let iz = indZMin; iz <= indZMax; iz++) {
          const indZ = iz * side;
          for (let ix = indXMin; ix <= indXMax; ix++) {
            ind = indY + indZ + ix;
            // getCornerCoord(vBoxMin, vBoxMax, ix, iy, iz, side, &vCorner);
            let t = ix * sideInv;
            const xCorner = vBoxMin.x * (1.0 - t) + vBoxMax.x * t;
            t = iy * sideInv;
            const yCorner = vBoxMin.y * (1.0 - t) + vBoxMax.y * t;
            t = iz * sideInv;
            const zCorner = vBoxMin.z * (1.0 - t) + vBoxMax.z * t;
            const dx = xCorner - vCenter.x;
            const dy = yCorner - vCenter.y;
            const dz = zCorner - vCenter.z;
            const dist2 = dx * dx + dy * dy + dz * dz;
            if (dist2 < probeSpRad2) {
              distToSphere = Math.sqrt(dist2);
              distToBorder = -(distToSphere - probeSphereRadius);
              innerBlockWorkAround();
            } // if (dist from corner point to sphere center more 2 radiuses)
          } // for (ix)
        } // for (iz)
      } // for (iy)
    } // for (i) all geo vertices
    return 0;
  }
  _innerBuild() {
    let ok;
    const expandFactor = 1.2;

    // performance test
    // this.performanceTest();

    // Create temporary atoms (but colored)
    const packedArrays = {
      posRad: this._posRad,
      colors: this._colors,
      atoms: this._opts.atoms
    };
    this.complex = this._opts.parent;
    this.atoms = packedArrays.atoms;
    this.meshResolution = this._opts.gridSpacing;
    this.atomRadiusScale = this._opts.radScale;
    this.colorMode = this._opts.colorMode;
    this.probeRadius = this._opts.probeRadius;
    this.useVertexColors = true;
    this.excludeProbe = this._opts.excludeProbe;
    this.visibilitySelector = this._opts.visibilitySelector;
    this.geoOut = null;
    this.hashLines = null;
    this.hashEntries = null;
    this.numHashEtriesAllocated = 0;
    this.numHashEntryIndex = 0;
    this.maxNumVertices = 0;
    this.maxNumTriangles = 0;
    const atomsColored = new Array(this.atoms.length);
    this.convertToAtomsColored(packedArrays, atomsColored);

    // find bbox for spheres scene
    const vBoxMin = this.vBoxMin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vBoxMax = this.vBoxMax = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
    const marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2);

    // build grid corners for Marching cube algorithm
    const side = marCubeResoultion;
    const side2 = side * side;
    const side3 = side2 * side;
    const corners = utils.allocateTyped(Float32Array, side3);
    const rProbeRadius = this.probeRadius * this.atomRadiusScale;
    this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
    const numCells = marCubeResoultion - 1;
    const cube = new geometries_IsoSurfaceMarchCube();
    ok = cube.create(numCells);
    if (ok < 0) {
      return ok;
    }
    // copy corners to cells
    const vCellStep = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
    vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
    vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
    let numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
    let maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
    let maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
    this.geoOut = new geometries_IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
    ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
    if (ok < 0) {
      return ok;
    }

    // build voxel world (used to check triangle-to-atom tie and to calculate normals and colors)
    let probeRadForNormalsColors = rProbeRadius;
    if (this.excludeProbe) {
      probeRadForNormalsColors = 0.01;
    }
    this.voxelWorld = new geometries_IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
    this.voxelWorld.createVoxels();
    ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);
    if (this.excludeProbe) {
      // using 3d mesh (geoOut) as a surface points
      // move probe sphere and try to minimuze corners values
      this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners);

      // delete old builded geo
      this.geoOut._vertices = null;
      this.geoOut._colors = null;
      this.geoOut._indices = null;
      this.geoOut._normals = null;
      this.geoOut._numVertices = 0;
      this.geoOut._numTriangles = 0;
      this.geoOut = null;

      // estimage geo vertices budget again
      numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
      maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
      maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);

      // creates empty new geometry
      this.geoOut = new geometries_IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
      ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
      if (ok < 0) {
        return ok;
      }
      // build vertices and triangles from corners values
      ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
    }

    // build vertex normals
    this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals);
    // More value : more smooth color mixing
    // value about 0.7: very rough colors borders
    let radiusColorSmoothness = 6.5;
    if (this.excludeProbe) {
      radiusColorSmoothness -= 1.5;
    }
    if (this.useVertexColors) {
      this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
    }
    this.voxelWorld.destroyVoxels();
    this.voxelWorld = null;

    // remove objects
    cube.destroy();
    return ok;
  }
}

// All code below must be erased from every device and each developer's memory

/* harmony default export */ const geometries_SSIsosurfaceGeometry = (SSIsosurfaceGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/LabelsGeometry.js


function createLabel(fieldTxt, className) {
  const text = document.createElement('div');
  text.className = className;
  if (typeof fieldTxt === 'string') {
    const spanText = document.createElement('span');
    spanText.style.fontSize = '150%';
    const strings = fieldTxt.split('\n');
    for (let i = 0, n = strings.length; i < n; ++i) {
      const spanNodeP = document.createElement('span');
      const spanNodeText = document.createTextNode(strings[i]);
      spanNodeP.appendChild(spanNodeText);
      spanText.appendChild(spanNodeP);
      if (i < n - 1) {
        spanText.appendChild(document.createElement('br'));
      }
    }
    text.appendChild(spanText);
  } else {
    text.appendChild(fieldTxt);
  }
  text.worldPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return text;
}
class LabelsGeometry extends utils_EventDispatcher {
  constructor(instanceCount, opts) {
    super();
    this._opts = opts;
    this.items = [];
    this.needsUpdate = false;
    let xTranslation = -50;
    let yTranslation = -50;
    switch (opts.horizontalAlign) {
      case 'left':
        xTranslation = 0;
        break;
      case 'right':
        xTranslation = -100;
        break;
      default:
        break;
    }
    switch (opts.verticalAlign) {
      case 'top':
        yTranslation = -100;
        break;
      case 'bottom':
        yTranslation = 0;
        break;
      default:
        break;
    }
    const deltaPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
    this.userData = {
      translation: `translate(${xTranslation}%, ${yTranslation}%)`,
      offset: deltaPos
    };
  }
  setItem(itemIdx, itemPos, fieldTxt) {
    const opts = this._opts;
    const text = this.items[itemIdx] || createLabel(fieldTxt, 'label');
    text.worldPos.copy(itemPos);
    text.style.textAlign = opts.horizontalAlign;
    text.style.verticalAlign = opts.verticalAlign;
    this.items[itemIdx] = text;
  }
  setColor(itemIdx, fColor, bColor) {
    const text = this.items[itemIdx];
    text.opts = {
      color: fColor,
      background: bColor
    };
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.needsUpdate = true;
    this.dispatchEvent({
      type: 'update'
    });
  }
  finalize() {
    this.finishUpdate();
  }

  // unimplemented functions
  raycast() {}
  setOpacity() {}
  getSubset() {
    return [];
  }
}
/* harmony default export */ const geometries_LabelsGeometry = (LabelsGeometry);
;// CONCATENATED MODULE: ./src/gfx/geometries/geometries.js












/* harmony default export */ const geometries = ({
  InstancedSpheresGeometry: geometries_InstancedSpheresGeometry,
  SimpleSpheresGeometry: geometries_SimpleSpheresGeometry,
  Simple2CCylindersGeometry: geometries_Simple2CCylindersGeometry,
  Instanced2CCylindersGeometry: geometries_Instanced2CCylindersGeometry,
  ExtrudedObjectsGeometry: geometries_ExtrudedObjectsGeometry,
  ChunkedLinesGeometry: geometries_ChunkedLinesGeometry,
  TwoColorLinesGeometry: geometries_TwoColorLinesGeometry,
  CrossGeometry: geometries_CrossGeometry,
  QuickSurfGeometry: geometries_QuickSurfGeometry,
  ContactSurfaceGeometry: geometries_ContactSurfaceGeometry,
  SSIsosurfaceGeometry: geometries_SSIsosurfaceGeometry,
  LabelsGeometry: geometries_LabelsGeometry
});
;// CONCATENATED MODULE: ./src/gfx/shaders/Uber.vert
const Uber_namespaceObject = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n    varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform mat4 projMatrixInv;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 objectNormal = vec3(\r\n    dot(normal, matVector1.xyz),\r\n    dot(normal, matVector2.xyz),\r\n    dot(normal, matVector3.xyz));\r\n#else\r\n  vec3 objectNormal = vec3( normal );\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n    spritePosEye = posEye;\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n    vec2 spriteSize;\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // In ortho projection we skip z coordinate\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r\n\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r\n    #else\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n      // full sprite size in eye coords\r\n      float minZ = min(abs(p1.z), abs(p2.z));\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r\n    #endif\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t  vec4 worldPosition;\r\n\t  // see THREE.WebGLProgram.unrollLoops\r\n\t  #pragma unroll_loop_start\r\n\t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r\n\t  }\r\n\t  #pragma unroll_loop_end\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/Uber.frag
const gfx_shaders_Uber_namespaceObject = "#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r\n\r\n    #ifdef SHADOWMAP_PCF_RAND\r\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r\n      // unroll_loop and unroll_loop has pattern:\r\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n      uniform sampler2D noiseTex;\r\n      uniform vec2 noiseTexelSize;\r\n      uniform vec2 srcTexelSize;\r\n      uniform mat4 projectionMatrix;\r\n    #endif\r\n\t#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n  uniform float nearPlaneValue;\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n\r\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r\n    uniform mat4 projectionMatrix;\r\n  #endif\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n\r\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point inside frustum\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r\n      // t1 is always smaller than t2 (from calculations)\r\n      point = p1;\r\n      frontFaced = 1.0;\r\n      return true;\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into sphere local coords\r\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\r\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r\n\r\n      // transform camera orientation vector into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into sphere local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n      // transform vector from camera pos to curPixel into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  varying vec4 spritePosEye;\r\n\r\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    float halfHeight = 0.5;\r\n\r\n    // choose nearest point\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\r\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n    vec4 v;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform camera orientation vector into cylinder local coords\r\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into cylinder local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform vector from camera pos to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n  vec4 r = vec4( fract( v * PackFactors ), v );\r\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n  return r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n  return dot( v, UnpackFactors );\r\n}\r\n\r\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n  struct DirectionalLightShadow {\r\n     vec2 shadowMapSize;\r\n     float shadowBias;\r\n     float shadowRadius;\r\n   };\r\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r\n\r\n  uniform vec3 ambientLightColor;\r\n\r\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r\n\r\n  #if defined(SHADOWMAP)\r\n  \tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n  \t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n  \t}\r\n\r\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r\n   \t  float shadow = 0.0;\r\n\r\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r\n      shadowCoord.xyz /= shadowCoord.w;\r\n\r\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n      bool inFrustum = all( inFrustumVec );\r\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n      bool frustumTest = all( frustumTestVec );\r\n\r\n      if ( frustumTest ) {\r\n        #ifdef SHADOWMAP_BASIC\r\n      \t  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n      \t#endif\r\n\r\n      \t#ifdef SHADOWMAP_PCF_SHARP\r\n      \t  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\r\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\r\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\r\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\r\n\r\n            shadow = (\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n            \ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n            ) * ( 1.0 / 9.0 );\r\n        #endif\r\n\r\n        #ifdef SHADOWMAP_PCF_RAND\r\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r\n\r\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r\n\r\n          vec2 offset;\r\n          #pragma unroll_loop_start\r\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r\n          }\r\n          #pragma unroll_loop_end\r\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n        #endif\r\n      }\r\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r\n   }\r\n  #endif\r\n\r\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color;\r\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor;\r\n\r\n    float shadowMask = 1.0;\r\n    // see THREE.WebGLProgram.unrollLoops\r\n  \t#pragma unroll_loop_start\r\n  \t  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n  \t    #ifdef SHADOWMAP\r\n  \t      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r\n        #endif\r\n\r\n  \t\t  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r\n  \t\t}\r\n  \t\t#pragma unroll_loop_end\r\n\r\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n  #if NUM_DIR_LIGHTS > 0\r\n    // see THREE.WebGLProgram.unrollLoops\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n  #ifdef ATTR_COLOR\r\n    vec3 vertexColor = vColor;\r\n  #else\r\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n  #endif\r\n\r\n  #ifdef ATTR_COLOR2\r\n    #ifdef CYLINDER_SPRITE\r\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n    #else\r\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n    #endif\r\n      // choose either color or color2\r\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n  #endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n  #ifdef DASHED_LINE\r\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n  #endif\r\n\r\n  // transparency prepass writes only z, so we don't need to calc the color\r\n  #ifdef PREPASS_TRANSP\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n    float totalOpacity = opacity;\r\n\r\n  #ifdef ATTR_ALPHA_COLOR\r\n    totalOpacity *= alphaCol;\r\n  #endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n  #ifdef FAKE_OPACITY\r\n    // discard pixels in checker pattern\r\n    vec2 dm_coord = floor(gl_FragCoord.xy);\r\n    dm_coord = fract(dm_coord * 0.5);\r\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n    vec4 diffuseColor = vec4(diffuse, 1.0);\r\n  #else\r\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n  #endif\r\n\r\n  float flipNormal;\r\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n    flipNormal = 1.0;\r\n    #ifdef DOUBLE_SIDED\r\n      flipNormal = float( gl_FrontFacing );\r\n    #endif\r\n    vec3 normal = normalize( vNormal ) * flipNormal;\r\n  #endif\r\n\r\n    diffuseColor.rgb *= vertexColor;\r\n\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n\r\n  #ifdef NORMALS_TO_G_BUFFER\r\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n      vec3 viewNormaInColor = viewNormalSprites;\r\n    #else\r\n      vec3 viewNormaInColor = viewNormal;\r\n      float frontFaced = float( gl_FrontFacing );\r\n    #endif\r\n    // [-1, 1] -> [0, 1]\r\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r\n  #endif\r\n\r\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n    vec3 viewDir;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDir = -pixelPosEye.xyz;\r\n    #else\r\n      viewDir = vViewPosition;\r\n    #endif\r\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r\n  #else\r\n    vec3 outgoingLight = diffuseColor.rgb;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_DEPTH\r\n    float depth = 0.0;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n      depth = gl_FragDepthEXT;\r\n    #else\r\n      depth = gl_FragCoord.z;\r\n    #endif\r\n    fragColor = packDepthToRGBA(depth);\r\n    return;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_POS\r\n    fragColor = world2colorMatrix * pixelPosWorld;\r\n  #else\r\n    #ifdef OVERRIDE_COLOR\r\n      fragColor = vec4(fixedColor, diffuseColor.a);\r\n    #else\r\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n    #endif\r\n\r\n    #ifdef USE_FOG\r\n      float viewDistance;\r\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n        viewDistance = abs(pixelPosEye.z);\r\n      #else\r\n        viewDistance = vViewPosition.z;\r\n      #endif\r\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n      #ifdef FOG_TRANSPARENT\r\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n      #else\r\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n      #endif\r\n    #endif\r\n\r\n  #endif\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/capabilities.js
/* harmony default export */ const capabilities = ({
  precision: 'mediump',
  /**
   *
   * @param {THREE.WebGLRenderer} renderer
   */
  init(renderer) {
    this.precision = renderer.capabilities.getMaxPrecision('highp');
  }
});
;// CONCATENATED MODULE: ./src/gfx/noiseTexture.js

const noiseWidth = 4;
const noiseHeight = 4;
const _noiseData = new Uint8Array([24, 52, 0, 255, 254, 145, 0, 255, 122, 0, 0, 255, 7, 170, 0, 255, 34, 214, 0, 255, 173, 8, 0, 255, 86, 249, 0, 255, 160, 4, 0, 255, 226, 46, 0, 255, 224, 211, 0, 255, 3, 157, 0, 255, 174, 247, 0, 255, 12, 182, 0, 255, 220, 216, 0, 255, 1, 109, 0, 255, 253, 154, 0, 255]);
const _noiseWrapS = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RepeatWrapping;
const _noiseWrapT = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RepeatWrapping;
const _noiseMinFilter = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter;
const _noiseMagFilter = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter;
const _noiseMapping = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UVMapping;
const noiseTexture = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DataTexture(_noiseData, noiseWidth, noiseHeight, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
noiseTexture.needsUpdate = true;
/* harmony default export */ const gfx_noiseTexture = ({
  noiseWidth,
  noiseHeight,
  noiseTexture
});
;// CONCATENATED MODULE: ./src/gfx/shaders/UberMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */






// Length of _samplesKernel is used in Uber.frag
// If you want to change length of _samplesKernel, please, remember change it in Uber.frag too.
// You can easy find places for replace using word:_samplesKernel
const _samplesKernel = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(-0.541978, 0.840393), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0.125533, -0.992089), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0.374329, 0.927296), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(-0.105475, 0.994422)];
const defaultUniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.merge([external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsLib.fog, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsLib.lights, {
  // are updated automatically by three.js (see THREE.ShaderLib.common)
  diffuse: {
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0xeeeeee)
  },
  opacity: {
    value: 1.0
  },
  specular: {
    type: 'c',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0x111111)
  },
  shininess: {
    type: 'f',
    value: 30
  },
  fixedColor: {
    type: 'c',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0xffffff)
  },
  zOffset: {
    type: 'f',
    value: 0.0
  },
  zClipValue: {
    type: 'f',
    value: 0.0
  },
  clipPlaneValue: {
    type: 'f',
    value: 0.0
  },
  nearPlaneValue: {
    type: 'f',
    value: -0.5
  },
  invModelViewMatrix: {
    type: '4fv',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
  },
  world2colorMatrix: {
    type: '4fv',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
  },
  dashedLineSize: {
    type: 'f',
    value: 0.1
  },
  dashedLinePeriod: {
    type: 'f',
    value: 0.2
  },
  projMatrixInv: {
    type: '4fv',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
  },
  viewport: {
    type: 'v2',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2()
  },
  lineWidth: {
    type: 'f',
    value: 2.0
  },
  // default value must be the same as settings
  fogAlpha: {
    type: 'f',
    value: 1.0
  },
  samplesKernel: {
    type: 'v2v',
    value: null
  },
  noiseTex: {
    type: 't',
    value: null
  },
  noiseTexelSize: {
    type: 'v2',
    value: null
  },
  srcTexelSize: {
    type: 'v2',
    value: null
  }
}]);
const uberOptionNames = ['shininess', 'opacity', 'zOffset', 'diffuse', 'specular', 'fixedColor', 'zClipCoef', 'zClipValue', 'clipPlaneValue', 'world2colorMatrix', 'dashedLineSize', 'dashedLinePeriod', 'projMatrixInv', 'viewport', 'lineWidth', 'fogAlpha', 'samplesKernel', 'noiseTex', 'noiseTexelSize', 'srcTexelSize'];

// properties that convert to uniforms
const uberOptions = {
  diffuse: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0xffffff),
  // used in phong lighting
  specular: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0x111111),
  // used in phong lighting
  shininess: 30,
  // used in phong lighting
  opacity: 1,
  // set mesh opacity
  fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0xffffff),
  // color to override (see OVERRIDE_COLOR)
  zOffset: 0.0,
  // used fo zsprites (see SPHERE_SPRITE CYLINDER_SPRITE)
  zClipCoef: 2.0,
  // use for Surfs clipping (mesh param, isn't used in shader)  FIXME move to representation param
  zClipValue: 0.0,
  //  value to clip Surfs in shader  (see ZCLIP)
  clipPlaneValue: 0.0,
  // value to clip scene globally (see CLIPPLANE)
  world2colorMatrix: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4(),
  dashedLineSize: 0.1,
  dashedLinePeriod: 0.3,
  projMatrixInv: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4(),
  viewport: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(800, 600),
  lineWidth: 2.0,
  fogAlpha: 1.0,
  samplesKernel: _samplesKernel,
  noiseTex: gfx_noiseTexture.noiseTexture,
  noiseTexelSize: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / gfx_noiseTexture.noiseWidth, 1.0 / gfx_noiseTexture.noiseHeight),
  srcTexelSize: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / 800.0, 1.0 / 600.0),
  copy(source) {
    this.diffuse.copy(source.diffuse);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.opacity = source.opacity;
    this.fixedColor.copy(source.fixedColor);
    this.zOffset = source.zOffset;
    this.zClipCoef = source.zClipCoef;
    this.zClipValue = source.zClipValue;
    this.clipPlaneValue = source.clipPlaneValue;
    this.world2colorMatrix.copy(source.world2colorMatrix);
    this.dashedLineSize = source.dashedLineSize;
    this.dashedLinePeriod = source.dashedLinePeriod;
    this.projMatrixInv = source.projMatrixInv;
    this.viewport = source.viewport;
    this.lineWidth = source.lineWidth; // used for thick lines only
    this.toonShading = source.toonShading;
    this.fogAlpha = source.fogAlpha;
    this.samplesKernel = source.samplesKernel;
    this.noiseTex = source.noiseTex;
    this.noiseTexelSize = source.noiseTexelSize;
    this.srcTexelSize = source.srcTexelSize;
  }
};
class UberMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);

    // add fog
    this.fog = true;
    // used for instanced geometry
    this.instancedPos = false;
    this.instancedMatrix = false;
    // atoms and links color
    this.attrColor = false;
    // second link color for cylinders
    this.attrColor2 = false;
    //
    this.attrAlphaColor = false;
    // overrides color for all vertices (used in selection)
    this.overrideColor = false;
    // zsrpites
    this.sphereSprite = false;
    this.cylinderSprite = false;
    // clip Surfs individually
    this.zClip = false;
    // clip scene with global clip plane
    this.clipPlane = false;
    // enable fake (chess-like) opacity
    this.fakeOpacity = false;
    // render only depth, don't take care about the pixel color (used for transparency depth prepass)
    this.prepassTransparancy = false;
    // used to render pixel positions
    this.colorFromPos = false;
    // used to render shadowmap
    this.shadowmap = false;
    // used to describe shadowmap type
    this.shadowmapType = 'random';
    // used to render pixel view deph
    this.colorFromDepth = false;
    // mark that rendering is for orthographic camera
    this.orthoCam = false;
    // used to render dashed line
    this.dashedLine = false;
    // mark as transparent
    this.transparent = true;
    // mark as thick lines
    this.thickLine = false;
    // makes fog begin transparency (required for transparent background)
    this.fogTransparent = false;
    // used to render surface normals to G buffer for ssao effect
    this.normalsToGBuffer = false;
    // used for toon material
    this.toonShading = false;

    // uber options of "root" materials are inherited from single uber-options object that resides in prototype
    this.uberOptions = Object.create(UberMaterial.prototype.uberOptions);

    // set default values
    super.setValues({
      uniforms: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.clone(defaultUniforms),
      vertexShader: this.precisionString() + Uber_namespaceObject,
      fragmentShader: this.precisionString() + gfx_shaders_Uber_namespaceObject,
      lights: true,
      fog: true,
      side: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DoubleSide
    });
    this.setValues(params);
  }
  precisionString() {
    const {
      precision
    } = capabilities;
    const str = `precision ${precision} float;\n` + `precision ${precision} int;\n\n`;
    return str;
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.clone(source.uniforms);
    this.defines = {
      ...source.defines
    };
    this.extensions = source.extensions;
    this.fog = source.fog;
    this.instancedPos = source.instancedPos;
    this.instancedMatrix = source.instancedMatrix;
    this.attrColor = source.attrColor;
    this.attrColor2 = source.attrColor2;
    this.attrAlphaColor = source.attrAlphaColor;
    this.overrideColor = source.overrideColor;
    this.sphereSprite = source.sphereSprite;
    this.cylinderSprite = source.cylinderSprite;
    this.zClip = source.zClip;
    this.clipPlane = source.clipPlane;
    this.fakeOpacity = source.fakeOpacity;
    this.colorFromPos = source.colorFromPos;
    this.shadowmap = source.shadowmap;
    this.shadowmapType = source.shadowmapType;
    this.colorFromDepth = source.colorFromDepth;
    this.orthoCam = source.orthoCam;
    this.prepassTransparancy = source.prepassTransparancy;
    this.dashedLine = source.dashedLine;
    this.thickLine = source.thickLine;
    this.fogTransparent = source.fogTransparent;
    this.normalsToGBuffer = source.normalsToGBuffer;
    this.toonShading = source.toonShading;
    this.uberOptions.copy(source.uberOptions);
    return this;
  }

  // create copy of this material
  // its options are prototyped after this material's options
  createInstance() {
    const inst = new UberMaterial();
    inst.copy(this);
    inst.uberOptions = Object.create(this.uberOptions);
    return inst;
  }
  setValues(values) {
    if (typeof values === 'undefined') {
      return;
    }

    // set direct values
    super.setValues(values);
    const defines = {};
    const extensions = {};
    if (this.fog) {
      defines.USE_FOG = 1;
    }
    if (this.instancedPos) {
      defines.INSTANCED_POS = 1;
    }
    if (this.instancedMatrix) {
      defines.INSTANCED_MATRIX = 1;
    }
    if (this.attrColor) {
      defines.ATTR_COLOR = 1;
    }
    if (this.attrColor2) {
      defines.ATTR_COLOR2 = 1;
    }
    if (this.attrAlphaColor) {
      defines.ATTR_ALPHA_COLOR = 1;
    }
    if (this.overrideColor) {
      defines.OVERRIDE_COLOR = 1;
    }
    if (this.sphereSprite) {
      defines.SPHERE_SPRITE = 1;
      extensions.fragDepth = true;
    }
    if (this.cylinderSprite) {
      defines.CYLINDER_SPRITE = 1;
      extensions.fragDepth = true;
    }
    if (this.zClip) {
      defines.ZCLIP = 1;
    }
    if (this.clipPlane) {
      defines.CLIP_PLANE = 1;
    }
    if (this.fakeOpacity) {
      defines.FAKE_OPACITY = 1;
    }
    if (this.lights) {
      defines.USE_LIGHTS = 1;
    }
    if (this.colorFromPos) {
      defines.COLOR_FROM_POS = 1;
    }
    if (this.shadowmap) {
      defines.SHADOWMAP = 1;
      if (this.shadowmapType === 'pcf') {
        defines.SHADOWMAP_PCF_SHARP = 1;
      } else if (this.shadowmapType === 'random') {
        defines.SHADOWMAP_PCF_RAND = 1;
      } else {
        defines.SHADOWMAP_BASIC = 1;
      }
    }
    if (this.colorFromDepth) {
      defines.COLOR_FROM_DEPTH = 1;
    }
    if (this.orthoCam) {
      defines.ORTHOGRAPHIC_CAMERA = 1;
    }
    if (this.prepassTransparancy) {
      defines.PREPASS_TRANSP = 1;
    }
    if (this.dashedLine) {
      defines.DASHED_LINE = 1;
    }
    if (this.thickLine) {
      defines.THICK_LINE = 1;
    }
    if (this.fogTransparent) {
      defines.FOG_TRANSPARENT = 1;
    }
    if (this.normalsToGBuffer) {
      extensions.drawBuffers = true;
      defines.NORMALS_TO_G_BUFFER = 1;
    }
    if (this.toonShading) {
      defines.TOON_SHADING = 1;
    }
    // set dependent values
    this.defines = defines;
    this.extensions = extensions;
  }
  setUberOptions(values) {
    if (typeof values === 'undefined') {
      return;
    }
    for (const key in values) {
      if (!values.hasOwnProperty(key)) {
        continue;
      }
      if (this.uberOptions[key] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color) {
        this.uberOptions[key] = values[key].clone();
      } else {
        this.uberOptions[key] = values[key];
      }
    }
  }
  clone(shallow) {
    if (!shallow) {
      return super.clone();
    }
    return this.createInstance();
  }
  updateUniforms() {
    const self = this;
    uberOptionNames.forEach(p => {
      if (self.uniforms.hasOwnProperty(p)) {
        if (self.uberOptions[p] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color || self.uberOptions[p] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4) {
          self.uniforms[p].value = self.uberOptions[p].clone();
        } else {
          self.uniforms[p].value = self.uberOptions[p];
        }
      }
    });
  }
}
UberMaterial.prototype.uberOptions = uberOptions;
/* harmony default export */ const shaders_UberMaterial = (UberMaterial);
;// CONCATENATED MODULE: ./src/gfx/meshes/UberObject.js

/* harmony default export */ function UberObject(SuperClass) {
  class NewObjectType extends SuperClass {
    constructor() {
      super(...arguments);
      this.onBeforeRender = NewObjectType.prototype.onBeforeRender;
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
      this._onBeforeRender(renderer, scene, camera, geometry, material, group);
      this._update();
    }
    _onBeforeRender() {}
    _update() {
      const {
        material
      } = this;
      if (!material) {
        return;
      }
      if (material instanceof shaders_UberMaterial) {
        material.updateUniforms();
      }
    }
  }
  return NewObjectType;
}
;// CONCATENATED MODULE: ./src/gfx/meshes/ZSpriteMesh.js


const Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
class ZSpriteMesh extends Mesh {
  constructor() {
    super(...arguments);
    this.castShadow = true;
    this.receiveShadow = true;
  }
  _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
    Mesh.prototype._onBeforeRender.call(this, renderer, scene, camera);
    const {
      material
    } = this;
    if (!material) {
      return;
    }
    if (material.uniforms.invModelViewMatrix) {
      // NOTE: update of modelViewMatrix inside threejs is done after onBeforeRender call,
      // so we have to do it manually in that place
      this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
      // get inverse matrix
      material.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert();
      material.uniforms.nearPlaneValue.value = camera.near;
      material.uniformsNeedUpdate = true;
    }
  }
}
/* harmony default export */ const meshes_ZSpriteMesh = (ZSpriteMesh);
;// CONCATENATED MODULE: ./src/gfx/meshes/ZClippedMesh.js


const ZClippedMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
class ZClippedMesh extends ZClippedMesh_Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.castShadow = true;
    this.receiveShadow = true;
  }
  static _mvLength = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  static _center = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  static _modelView = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4())();
  _onBeforeRender(renderer, scene, camera) {
    ZClippedMesh_Mesh.prototype._onBeforeRender.call(this, renderer, scene, camera);
    const geo = this.geometry;
    const {
      material
    } = this;
    if (!geo.zClip || !material.uberOptions) {
      return;
    }
    const zClipCoef = 0.5;
    const modelView = ZClippedMesh._modelView;
    const mvLength = ZClippedMesh._mvLength;
    const center = ZClippedMesh._center;
    modelView.multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
    const s = mvLength.setFromMatrixColumn(modelView, 0).length();
    center.copy(geo.boundingSphere.center);
    this.localToWorld(center);
    material.uberOptions.zClipValue = camera.position.z - center.z - s * (zClipCoef * geo.boundingSphere.radius);
  }
}
/* harmony default export */ const meshes_ZClippedMesh = (ZClippedMesh);
;// CONCATENATED MODULE: ./src/gfx/meshes/TextMesh.js




class TextMesh extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group {
  constructor(geometry, _material) {
    super();
    this.geometry = geometry;
    const self = this;
    self.initialized = false;
    this.geometry.addEventListener('update', () => {
      self.update();
    });
  }
  init() {
    const {
      children
    } = this;
    for (let i = children.length - 1; i >= 0; --i) {
      this.remove(children[i]);
    }
    const {
      items,
      userData
    } = this.geometry;
    for (let i = 0, n = items.length; i < n; ++i) {
      const srcItem = items[i];
      if (!srcItem) {
        continue;
      }
      const item = utils.shallowCloneNode(srcItem);
      const label = new gfx_CSS2DObject(item);
      label.userData = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].clone(userData);
      const el = label.getElement();
      el.style.visibility = 'visible';
      label.source = srcItem;
      this.add(label);
    }
    this.initialized = true;
  }
  update() {
    const geo = this.geometry;
    if (!geo.needsUpdate) {
      return;
    }
    const {
      children
    } = this;
    if (!this.initialized) {
      this.init();
    }
    for (let i = 0, n = children.length; i < n; ++i) {
      const child = children[i];
      const item = child.source;
      child.position.copy(item.worldPos);
      child.userData.color = item.opts.color;
      child.userData.background = item.opts.background;
    }
  }
}
/* harmony default export */ const meshes_TextMesh = (TextMesh);
;// CONCATENATED MODULE: ./src/gfx/meshes/SimpleMesh.js


const SimpleMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
class SimpleMesh extends SimpleMesh_Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}
/* harmony default export */ const meshes_SimpleMesh = (SimpleMesh);
;// CONCATENATED MODULE: ./src/gfx/meshes/ThickLineMesh.js


const ThickLineMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
const _viewport = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
class ThickLineMesh extends ThickLineMesh_Mesh {
  _onBeforeRender(renderer, scene, camera, _geometry, _material, _group) {
    const {
      material
    } = this;
    if (!material.uberOptions) {
      return;
    }
    material.uberOptions.projMatrixInv.copy(camera.projectionMatrix).invert();
    renderer.getSize(_viewport);
    material.uberOptions.viewport.set(_viewport.width, _viewport.height);
  }
}
/* harmony default export */ const meshes_ThickLineMesh = (ThickLineMesh);
;// CONCATENATED MODULE: ./src/gfx/meshes/InstancedMesh.js


const InstancedMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
class InstancedMesh extends InstancedMesh_Mesh {
  constructor() {
    super(...arguments);
    this.castShadow = true;
    this.receiveShadow = true;
  }
}
/* harmony default export */ const meshes_InstancedMesh = (InstancedMesh);
;// CONCATENATED MODULE: ./src/gfx/meshes/meshes.js








/* harmony default export */ const meshes = ({
  ZClipped: meshes_ZClippedMesh,
  ZSprite: meshes_ZSpriteMesh,
  Text: meshes_TextMesh,
  Line: UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line),
  LineSegments: UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments),
  Mesh: meshes_SimpleMesh,
  ThickLineMesh: meshes_ThickLineMesh,
  Instanced: meshes_InstancedMesh
});
;// CONCATENATED MODULE: ./src/gfx/meshes/MeshCreator.js



function setMatParams(params, uniforms) {
  return function (material) {
    material.setValues(params);
    material.setUberOptions(uniforms);
  };
}
function _createInstancedCylinders(useZSprites, openEnded) {
  function Geometry(a, b) {
    return new geometries.Instanced2CCylindersGeometry(a, b, useZSprites, openEnded);
  }
  return {
    Geometry,
    Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
    initMaterial: setMatParams({
      instancedMatrix: true,
      attrColor: true,
      attrColor2: true,
      attrAlphaColor: true,
      cylinderSprite: useZSprites
    })
  };
}
function _createLineSegmentsGeoTriplet(geo, renderParams) {
  const thickLines = geo.prototype instanceof geometries_ThickLinesGeometry;
  const lineWidth = renderParams.lineWidth || 0;
  return {
    Geometry: geo,
    Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
    initMaterial: setMatParams({
      lights: false,
      attrColor: true,
      attrAlphaColor: true,
      thickLine: thickLines
    }, {
      lineWidth
    })
  };
}
function _createSimpleGeoTriplet(geoClass) {
  return {
    Geometry: geoClass,
    Object: meshes.Mesh,
    initMaterial: setMatParams({
      attrColor: true,
      attrAlphaColor: true
    })
  };
}
function _createIsoSurfaceGeoTriplet(geoClass, caps, settings, renderParams) {
  const surfaceOpts = {
    wireframe: !!renderParams.wireframe,
    fakeOpacity: settings.now.isoSurfaceFakeOpacity,
    zClip: renderParams.zClip
  };
  return {
    Geometry: geoClass,
    Object: meshes.ZClipped,
    initMaterial: setMatParams({
      attrColor: true,
      attrAlphaColor: false,
      wireframe: surfaceOpts.wireframe,
      fakeOpacity: surfaceOpts.fakeOpacity,
      zClip: surfaceOpts.zClip
    })
  };
}
class MeshCreator {
  static createSpheres(caps, settings) {
    const useZSprites = settings.now.zSprites;
    function Geometry(a, b) {
      return new geometries.InstancedSpheresGeometry(a, b, useZSprites);
    }
    return {
      Geometry,
      Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
      initMaterial: setMatParams({
        instancedPos: true,
        attrColor: true,
        attrAlphaColor: true,
        sphereSprite: useZSprites
      })
    };
  }
  static create2CClosedCylinders(_caps, _settings) {
    return _createInstancedCylinders(false, false);
  }
  static create2CCylinders(caps, settings) {
    return _createInstancedCylinders(settings.now.zSprites, true);
  }
  static create2CLines(_caps, _settings, renderParams) {
    return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
  }
  static createCrosses(_caps, _settings, renderParams) {
    return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
  }
  static createExtrudedChains(_caps, _settings) {
    return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
  }
  static createChunkedLines(_caps, _settings, renderParams) {
    return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
  }
  static createQuickSurface(caps, settings, renderParams) {
    return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings, renderParams);
  }
  static createContactSurface(caps, settings, renderParams) {
    return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings, renderParams);
  }
  static createSASSES(caps, settings, renderParams) {
    return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings, renderParams);
  }
  static createLabels(_caps, _settings) {
    return {
      Geometry: geometries.LabelsGeometry,
      Object: meshes.Text,
      initMaterial() {}
    };
  }
}
/* harmony default export */ const meshes_MeshCreator = (MeshCreator);
;// CONCATENATED MODULE: ./src/gfx/meshes/TransformGroup.js


class TransformGroup extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D {
  static _inverseMatrix = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4())();
  static _ray = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Ray())();
  constructor(geometry, geoParams, material, transforms) {
    super();
    this._geometry = geometry;
    this._geoParams = geoParams;
    const mat = material.createInstance();
    geoParams.initMaterial(mat);
    this._material = mat;
    this._transforms = transforms.length > 0 ? transforms : [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()];
    const meshes = this._createMeshes(geometry);
    for (let i = 0, n = meshes.length; i < n; ++i) {
      this.add(meshes[i]);
    }
  }
  raycast(raycaster, intersects) {
    const ray = TransformGroup._ray;
    const inverseMatrix = TransformGroup._inverseMatrix;
    const {
      children
    } = this;
    ray.copy(raycaster.ray);
    for (let i = 0, n = children.length; i < n; ++i) {
      const child = children[i];
      if (!gfxutils.belongToSelectLayers(child)) {
        continue;
      }
      child.updateMatrixWorld();
      const mtx = child.matrixWorld;
      inverseMatrix.copy(mtx).invert();
      raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
      const childIntersects = [];
      this._geometry.raycast(raycaster, childIntersects);
      for (let j = 0, ciCount = childIntersects.length; j < ciCount; ++j) {
        const inters = childIntersects[j];
        if (inters.point) {
          inters.point.applyMatrix4(mtx);
          inters.distance = ray.origin.distanceTo(inters.point);
        }
        inters.object = child;
        intersects[intersects.length] = inters;
      }
    }
    raycaster.ray.copy(ray);
  }
  getSubset(chunkIndices) {
    const geos = this._geometry.getSubset(chunkIndices);
    const subset = [];
    let subIdx = 0;
    for (let i = 0, n = geos.length; i < n; ++i) {
      const meshes = this._createMeshes(geos[i]);
      for (let j = 0, meshCnt = meshes.length; j < meshCnt; ++j) {
        subset[subIdx++] = meshes[j];
      }
    }
    return subset;
  }
  _createMeshes(geometry) {
    const transforms = this._transforms;
    const Mesh = this._geoParams.Object;
    const material = this._material;
    const meshes = [];
    for (let i = 0, n = transforms.length; i < n; ++i) {
      const mesh = new Mesh(geometry, material);
      mesh.applyMatrix4(transforms[i]);
      meshes[i] = mesh;
    }
    return meshes;
  }
}
/* harmony default export */ const meshes_TransformGroup = (TransformGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/ChemGroup.js


function wrapper(Name, args) {
  const params = [Name].concat(args);
  return Name.bind(...params);
}
class ChemGroup extends gfx_RCGroup {
  constructor(geoParams, selection, colorer, mode, transforms, polyComplexity, material) {
    super();
    if (this.constructor === ChemGroup) {
      throw new Error('Can not instantiate abstract class!');
    }
    this._selection = selection;
    this._mode = mode;
    this._colorer = colorer;
    this._chunksIdc = selection.chunks;
    this._polyComplexity = polyComplexity;
    this._geo = new (wrapper(geoParams.Geometry, this._makeGeoArgs()))();
    this._mesh = new meshes_TransformGroup(this._geo, geoParams, material, transforms);
    this.add(this._mesh);
    this._build();
  }
  _makeGeoArgs() {
    throw new Error('ChemGroup subclass must override _makeGeoArgs() method');
  }

  /**
   * Builds subset geometry by ATOMS index list
   *
   * @param {Number} mask - Representation mask
   * @param {Boolean} innerOnly - if true returns inner bonds only - without halves
   * @returns {Array} Subset geometry
   */
  getSubset(mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : false;
    const chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return [];
    }
    return this._mesh.getSubset(chunksList);
  }
  _changeSubsetOpacity(mask, value, innerOnly) {
    const chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return;
    }
    this._geo.setOpacity(chunksList, value);
  }
  enableSubset(mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : true;
    this._changeSubsetOpacity(mask, 1.0, innerOnly);
  }
  disableSubset(mask, innerOnly) {
    innerOnly = innerOnly !== undefined ? innerOnly : true;
    this._changeSubsetOpacity(mask, 0.0, innerOnly);
  }
}
/* harmony default export */ const groups_ChemGroup = (ChemGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AtomsGroup.js

class AtomsGroup extends groups_ChemGroup {
  raycast(raycaster, intersects) {
    const {
      atoms
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const atomsIdc = this._chunksIdc;
    // process inters array - arr object references
    for (let i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      const atomIdx = atomsIdc[inters[i].chunkIdx];
      if (atomIdx < atoms.length) {
        inters[i].atom = atoms[atomIdx];
        intersects.push(inters[i]);
      }
    }
  }
  _calcChunksList(mask) {
    const chunksList = [];
    const {
      atoms
    } = this._selection;
    const atomsIdc = this._chunksIdc;
    for (let i = 0, n = atomsIdc.length; i < n; ++i) {
      const atom = atoms[atomsIdc[i]];
      if ((atom.mask & mask) !== 0) {
        chunksList.push(i);
      }
    }
    return chunksList;
  }
}
/* harmony default export */ const groups_AtomsGroup = (AtomsGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AtomsSphereGroup.js

class AtomsSphereGroup extends groups_AtomsGroup {
  _makeGeoArgs() {
    return [this._selection.chunks.length, this._polyComplexity];
  }
  _build() {
    const atomsIdc = this._selection.chunks;
    const {
      atoms,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    for (let i = 0, n = atomsIdc.length; i < n; ++i) {
      const atom = atoms[atomsIdc[i]];
      geo.setItem(i, atom.position, mode.calcAtomRadius(atom));
      geo.setColor(i, colorer.getAtomColor(atom, parent));
    }
    geo.finalize();
  }
  updateToFrame(frameData) {
    // This method looks like a copy paste. However, it
    // was decided to postpone animation refactoring until GFX is fixed.
    const atomsIdc = this._selection.chunks;
    const {
      atoms
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const updateColor = frameData.needsColorUpdate(colorer);
    const geo = this._geo;
    for (let i = 0, n = atomsIdc.length; i < n; ++i) {
      const atom = atoms[atomsIdc[i]];
      geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), mode.calcAtomRadius(atom));
      if (updateColor) {
        geo.setColor(i, frameData.getAtomColor(colorer, atom));
      }
    }
    geo.finalize();
  }
}
/* harmony default export */ const groups_AtomsSphereGroup = (AtomsSphereGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AtomsSurfaceGroup.js

class AtomsSurfaceGroup extends groups_AtomsSphereGroup {
  _makeGeoArgs() {
    const selectedAtoms = [];
    const {
      atoms,
      chunks
    } = this._selection;
    const n = chunks.length;
    for (let i = 0; i < n; ++i) {
      selectedAtoms[i] = atoms[chunks[i]];
    }
    const opts = this._mode.getSurfaceOpts();
    opts.atoms = selectedAtoms;
    return [n, opts];
  }
}
/* harmony default export */ const groups_AtomsSurfaceGroup = (AtomsSurfaceGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AtomsSASSESGroupStub.js
/* This is a stub class keep it until SAS/SES is refactored */


class AtomsSASSESGroupStub extends groups_AtomsSphereGroup {
  _makeGeoArgs() {
    const selectedAtoms = [];
    const {
      atoms,
      chunks
    } = this._selection;
    const n = chunks.length;
    for (let i = 0; i < n; ++i) {
      selectedAtoms[i] = atoms[chunks[i]];
    }
    const opts = this._mode.getSurfaceOpts();
    opts.atoms = selectedAtoms;
    opts.selection = this._selection;
    opts.colorMode = this._colorer;
    return [n, opts];
  }
}
/* harmony default export */ const groups_AtomsSASSESGroupStub = (AtomsSASSESGroupStub);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AtomsTextGroup.js


function adjustColor(color) {
  let r = color >> 16 & 255;
  let g = color >> 8 & 255;
  let b = color & 255;
  if (0.2126 * r + 0.7152 * g + 0.0722 * b > 127) {
    r = r * 3 / 10;
    g = g * 3 / 10;
    b = b * 3 / 10;
  } else {
    r = 255 - (255 - r) * 3 / 10;
    g = 255 - (255 - g) * 3 / 10;
    b = 255 - (255 - b) * 3 / 10;
  }
  return r << 16 | g << 8 | b;
}
function inverseColor(color) {
  const r = color >> 16 & 255;
  const g = color >> 8 & 255;
  const b = color & 255;
  return 255 - r << 16 | 255 - g << 8 | 255 - b;
}
function getAtomText(atom) {
  if (atom.name.getNode() !== null) {
    return atom.name.getNode();
  }
  return atom.getVisualName();
}
const colorMappings = {
  none(c) {
    return c;
  },
  adjust: adjustColor,
  inverse: inverseColor
};
function propagateColor(color, rule) {
  let result;
  if (colorMappings.hasOwnProperty(rule)) {
    result = utils.hexColor(colorMappings[rule](color));
  } else {
    const val = parseInt(rule, 16);
    if (!Number.isNaN(val) && rule.toLowerCase().startsWith('0x')) {
      result = utils.hexColor(val);
    } else {
      result = '#000000';
    }
  }
  return result;
}
const templateMappings = {
  serial(a) {
    return a.serial;
  },
  name(a) {
    return a.getVisualName();
  },
  elem(a) {
    return a.element.name;
  },
  residue(a) {
    return a.residue.getType().getName();
  },
  sequence(a) {
    return a.residue.getSequence();
  },
  chain(a) {
    return a.residue.getChain().getName();
  },
  hetatm(a) {
    return a.isHet();
  },
  water(a) {
    return a.residue.getType().getName() === 'HOH' || a.residue.getType().getName() === 'WAT';
  }
};
const parseTemplate = function (atom, str) {
  return str.replace(/\{\{(\s*\w+\s*)\}\}/g, m => {
    let key = m.replace(/\s+/g, '');
    key = key.substring(2, key.length - 2).toLowerCase();
    if (templateMappings.hasOwnProperty(key)) {
      return templateMappings[key](atom);
    }
    return 'null';
  });
};
class AtomsTextGroup extends groups_AtomsGroup {
  _makeGeoArgs() {
    const opts = this._mode.getLabelOpts();
    return [this._selection.chunks.length, opts];
  }
  _build() {
    const opts = this._mode.getLabelOpts();
    const atomsIdc = this._selection.chunks;
    const {
      atoms,
      parent
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    for (let i = 0, n = atomsIdc.length; i < n; ++i) {
      const atom = atoms[atomsIdc[i]];
      const text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
      if (!text) {
        continue;
      }
      const color = colorer.getAtomColor(atom, parent);
      const fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
      const bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
      geo.setItem(i, atom.position, text);
      geo.setColor(i, fgColor, bgColor);
    }
    geo.finalize();
  }
  updateToFrame(frameData) {
    // This method looks like a copy paste. However, it
    // was decided to postpone animation refactoring until GFX is fixed.
    const opts = this._mode.getLabelOpts();
    const atomsIdc = this._selection.chunks;
    const {
      atoms
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let i = 0, n = atomsIdc.length; i < n; ++i) {
      const atom = atoms[atomsIdc[i]];
      const text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
      if (!text) {
        continue;
      }
      const color = frameData.getAtomColor(colorer, atom);
      const fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
      const bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : 'transparent';
      geo.setItem(i, frameData.getAtomPos(atomsIdc[i]), text);
      if (updateColor) {
        geo.setColor(i, fgColor, bgColor);
      }
    }
    geo.finalize();
  }
}
/* harmony default export */ const groups_AtomsTextGroup = (AtomsTextGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AromaticGroup.js


function _slerp(omega, v1, v2, t) {
  const oSin = Math.sin(omega);
  return v1.clone().multiplyScalar(Math.sin((1 - t) * omega) / oSin).addScaledVector(v2, Math.sin(t * omega) / oSin);
}
class AromaticGroup extends groups_AtomsGroup {
  _buildInner(radOffset, addChunk) {
    const chunksToIdx = this._selection.chunks;
    const prevVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const currVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const segmentsHeight = this._segmentsHeight;
    const leprStep = 1.0 / segmentsHeight;
    const colorer = this._colorer;
    const {
      cycles,
      parent
    } = this._selection;
    let chunkIdx = 0;
    let currAtomIdx = chunksToIdx[chunkIdx];
    for (let cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
      const cycle = cycles[cIdx];
      const cycAtoms = cycle.atoms;
      const chunkPoints = [];
      const tmpDir = [];
      const {
        center
      } = cycle;
      const cycleRad = cycle.radius - radOffset;
      const n = cycAtoms.length;
      let i = 0;
      const prevPos = cycAtoms[n - 1].position;
      let currPos = cycAtoms[i].position;
      prevVector.subVectors(prevPos, center);
      currVector.subVectors(currPos, center);
      const upDir = currVector.clone().cross(prevVector).normalize();
      for (; i < n; ++i) {
        const omega = prevVector.angleTo(currVector);
        tmpDir[i] = _slerp(omega, prevVector, currVector, 0.5).normalize();
        currPos = cycAtoms[(i + 1) % n].position;
        prevVector.copy(currVector);
        currVector.subVectors(currPos, center);
      }
      for (i = 0; i < n; ++i) {
        if (cycAtoms[i].index !== currAtomIdx) {
          continue;
        }
        const start = tmpDir[i];
        const end = tmpDir[(i + 1) % n];
        const color = colorer.getAtomColor(cycAtoms[i], parent);
        const currAngle = start.angleTo(end);
        for (let j = 0; j <= segmentsHeight; ++j) {
          chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
        }
        addChunk(chunkIdx++, color, chunkPoints, center, upDir);
        currAtomIdx = chunksToIdx[chunkIdx];
      }
    }
  }
}
/* harmony default export */ const groups_AromaticGroup = (AromaticGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AromaticTorusGroup.js



function _createShape(rad, parts) {
  const pts = [];
  for (let i = 0; i < parts; ++i) {
    const a = -2 * i / parts * Math.PI;
    pts.push(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
  }
  return pts;
}
const {
  calcChunkMatrix
} = gfxutils;
class AromaticTorusGroup extends groups_AromaticGroup {
  _build() {
    const segmentsHeight = this._segmentsHeight;
    const torusRad = this._mode.getAromRadius();
    const radiusV = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(torusRad, torusRad);
    const radOffset = this._mode.calcStickRadius() + 2 * torusRad;
    const lookAtVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const mtc = [];
    const geo = this._geo;
    this._buildInner(radOffset, (chunkIdx, color, points, center, upDir) => {
      for (let j = 0; j <= segmentsHeight; ++j) {
        const currPoint = points[j];
        const currDir = currPoint.clone().sub(center).cross(upDir);
        lookAtVector.addVectors(currPoint, currDir);
        mtc[j] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
      }
      geo.setItem(chunkIdx, mtc);
      geo.setColor(chunkIdx, color);
    });
    geo.finalize();
  }
  _makeGeoArgs() {
    this._segmentsHeight = this._polyComplexity;
    return [_createShape(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
  }
}
/* harmony default export */ const groups_AromaticTorusGroup = (AromaticTorusGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/AromaticLinesGroup.js

class AromaticLinesGroup extends groups_AromaticGroup {
  _build() {
    const geo = this._geo;
    const radOffset = this._mode.getAromaticOffset();
    this._buildInner(radOffset, (chunkIdx, color, points) => {
      let prevPt = points[0]; // do not replace with start
      for (let j = 1; j <= this._segmentsHeight; ++j) {
        const currPoint = points[j];
        geo.setSegment(chunkIdx, j - 1, prevPt, currPoint);
        prevPt = currPoint;
      }
      geo.setColor(chunkIdx, color);
    });
    geo.finalize();
  }
  _makeGeoArgs() {
    this._segmentsHeight = this._mode.getAromaticArcChunks();
    return [this._selection.chunks.length, this._segmentsHeight, true];
  }
}
/* harmony default export */ const groups_AromaticLinesGroup = (AromaticLinesGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/ResiduesGroup.js

class ResiduesGroup extends groups_ChemGroup {
  raycast(raycaster, intersects) {
    const {
      residues
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const chunksIdc = this._chunksIdc;
    // process inters array - arr object references
    for (let i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      const resIdx = chunksIdc[inters[i].chunkIdx];
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  }
  _calcChunksList(mask) {
    const chunksList = [];
    const {
      residues
    } = this._selection;
    const resIdc = this._chunksIdc;
    for (let i = 0, n = resIdc.length; i < n; ++i) {
      const res = residues[resIdc[i]];
      if ((res._mask & mask) !== 0) {
        chunksList.push(i);
      }
    }
    return chunksList;
  }
}
/* harmony default export */ const groups_ResiduesGroup = (ResiduesGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/NucleicItemGroup.js

class NucleicItemGroup extends groups_ResiduesGroup {
  raycast(raycaster, intersects) {
    const {
      residues
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const chunksIdc = this._chunksIdc;
    // process inters array - arr object references
    for (let i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      const resIdx = chunksIdc[Math.floor(inters[i].chunkIdx / 2)];
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  }
  _build() {
    const {
      residues,
      parent
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    const stickRad = this._mode.calcStickRadius();
    let chunkIdx = 0;
    const resIdc = this._selection.chunks;
    for (let i = 0, n = resIdc.length; i < n; ++i) {
      const res = residues[resIdc[i]];
      const color = colorer.getResidueColor(res, parent);
      this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
    }
    geo.finalize();
  }
  _calcChunksList(mask) {
    const chunksList = [];
    let chunkIdx = 0;
    const {
      residues
    } = this._selection;
    const resIdc = this._chunksIdc;
    for (let i = 0, n = resIdc.length; i < n; ++i) {
      const res = residues[resIdc[i]];
      if ((res._mask & mask) !== 0) {
        chunksList[chunkIdx++] = 2 * i;
        chunksList[chunkIdx++] = 2 * i + 1;
      }
    }
    return chunksList;
  }
  updateToFrame(frameData) {
    // This method looks like a copy paste. However, it
    // was decided to postpone animation refactoring until GFX is fixed.
    const residues = frameData.getResidues();
    const {
      parent
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    const stickRad = this._mode.calcStickRadius();
    let chunkIdx = 0;
    const resIdc = this._selection.chunks;
    for (let i = 0, n = resIdc.length; i < n; ++i) {
      const res = residues[resIdc[i]];
      const color = colorer.getResidueColor(res, parent);
      this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
    }
    geo.finishUpdate();
  }
}
/* harmony default export */ const groups_NucleicItemGroup = (NucleicItemGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/NucleicCylindersGroup.js

class NucleicCylindersGroup extends groups_NucleicItemGroup {
  _makeGeoArgs() {
    return [this._selection.chunks.length, this._polyComplexity];
  }
  _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
    const geo = this._geo;
    geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
    geo.setColor(chunkIdx, color, color);
  }
}
/* harmony default export */ const groups_NucleicCylindersGroup = (NucleicCylindersGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/NucleicSpheresGroup.js

class NucleicSpheresGroup extends groups_NucleicItemGroup {
  _makeGeoArgs() {
    return [this._selection.chunks.length * 2, this._polyComplexity];
  }
  _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
    const geo = this._geo;
    let idx = chunkIdx * 2;
    geo.setItem(idx, cyl1, stickRad);
    geo.setColor(idx, color);
    idx++;
    geo.setItem(idx, cyl2, stickRad);
    geo.setColor(idx, color);
  }
}
/* harmony default export */ const groups_NucleicSpheresGroup = (NucleicSpheresGroup);
// EXTERNAL MODULE: ./vendor/js/Smooth.js
var Smooth = __webpack_require__(690);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/CartoonHelper.js




const {
  ResidueType: CartoonHelper_ResidueType
} = chem;
const calcMatrix = gfxutils.calcChunkMatrix;
function _buildStructureInterpolator(points, tension) {
  const path = (0,Smooth.Smooth)(points, {
    method: Smooth.Smooth.METHOD_CUBIC,
    clip: Smooth.Smooth.CLIP_CLAMP,
    cubicTension: tension,
    scaleTo: 1
  });
  return function (t, argTrans) {
    let transformT = argTrans;
    if (transformT === null) {
      // map our range to the [second .. last but one]
      transformT = function (tt) {
        return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
      };
    }
    const newt = transformT(t);
    const ans = path(newt);
    return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(ans[0], ans[1], ans[2]);
  };
}
function _addPoints(centerPoints, topPoints, idx, residue) {
  if (!residue._isValid) {
    centerPoints[idx] = centerPoints[idx - 1];
    topPoints[idx] = topPoints[idx - 1];
    return;
  }
  const cp = residue._controlPoint;
  centerPoints[idx] = [cp.x, cp.y, cp.z];
  const tp = cp.clone().add(residue._wingVector);
  topPoints[idx] = [tp.x, tp.y, tp.z];
}
function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
  const nucleic = (residue._type.flags & CartoonHelper_ResidueType.Flags.NUCLEIC) !== 0;
  const nameFrom = nucleic ? 'C5\'' : 'N';
  const nameTo = nucleic ? 'C3\'' : 'C';
  let posFrom;
  let posTo;
  residue.forEachAtom(atom => {
    const name = atom.getVisualName();
    if (!posFrom && name === nameFrom) {
      posFrom = atom.position;
    } else if (!posTo && name === nameTo) {
      posTo = atom.position;
    }
  });

  // provide a fallback for unknown residues
  if (!(posFrom && posTo)) {
    posFrom = residue._firstAtom.position;
    posTo = residue._lastAtom.position;
  }
  if (posFrom && posTo) {
    const shift = posTo.clone().sub(posFrom);
    const wing = residue._wingVector;
    const cp = residue._controlPoint;
    const tp = cp.clone().add(wing);
    const cpPrev = cp.clone().sub(shift);
    const tpPrev = cpPrev.clone().add(wing);
    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
    ++idx;
    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
    ++idx;
    centerPoints[idx] = [cp.x, cp.y, cp.z];
    topPoints[idx] = [tp.x, tp.y, tp.z];
    ++idx;
    const cpNext = cp.clone().add(shift);
    const tpNext = cpNext.clone().add(wing);
    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
    ++idx;
    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
  }
}
function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
  const left = boundaries.start;
  const right = boundaries.end;
  function _prevIdx(idx) {
    return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx;
  }
  function _nextIdx(idx) {
    return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx;
  }
  const topPoints = [];
  const centerPoints = [];
  let arrIdx = 0;
  function _extrapolate2(currIdx, otherIdx) {
    const cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);
    const tp = cp.clone().add(residues[currIdx]._wingVector);
    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
  }

  // a single disconnected residue
  const prevIdx = _prevIdx(firstIdx);
  const nextIdx = _nextIdx(lastIdx);
  if (prevIdx === nextIdx) {
    _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);
    return {
      centerPoints,
      topPoints
    };
  }

  // Two points (prev-prev and next-next) are added to support edge conditions for cubic splines, they are ignored
  // Another two (prev and next) were added to support the outside of the sub chain

  // prev and prev-prev
  if (firstIdx === prevIdx) {
    // do the extrapolation
    _extrapolate2(firstIdx, _nextIdx(firstIdx));
  } else {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);
    _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
  }

  // main loop
  for (let idx = firstIdx; idx <= lastIdx; ++idx) {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
  }

  // next and next-next
  if (nextIdx === _nextIdx(nextIdx)) {
    // do the extrapolation
    _extrapolate2(lastIdx, _prevIdx(lastIdx));
  } else {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);
    _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
  }
  return {
    centerPoints,
    topPoints
  };
}
class CartoonHelper {
  constructor(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
    const pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);
    this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
    this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
    this._shift = 0.5 / (endIdx - startIdx + 2);
    this._valueStep = (1.0 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
    this._segmentsCount = segmentsCount;
  }
  prepareMatrices(idx, firstRad, secondRad) {
    const mtcCount = this._segmentsCount;
    const outMtc = new Array(mtcCount);
    const currRad = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0, 0);
    const topInterp = this._topInterp;
    const cenInterp = this._centerInterp;
    let currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;
    for (let mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
      const lerpVal = Math.min(1.0, mtxIdx / (mtcCount - 1));
      currRad.lerpVectors(firstRad, secondRad, lerpVal);
      const currTop = topInterp(currentValue, null);
      const currCenter = cenInterp(currentValue, null);
      currentValue += this._valueStep;
      const nextCenter = cenInterp(currentValue, null);
      outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
    }
    return outMtc;
  }
}
/* harmony default export */ const groups_CartoonHelper = (CartoonHelper);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/ResiduesSubseqGroup.js



function ResiduesSubseqGroup_createShape(rad, parts) {
  const pts = [];
  for (let i = 0; i < parts; ++i) {
    // starts from pi/2 because it's important that points are lied on the angles of arrows (visual issues if not)
    const a = Math.PI / 2.0 - 2 * Math.PI * i / parts;
    pts.push(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.cos(a) * rad, Math.sin(a) * rad, 0));
  }
  return pts;
}
function _loopThrough(subDiv, residues, segmentsHeight, tension, mode, callback) {
  for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
    const subs = subDiv[subDivI].arr;
    const {
      boundaries
    } = subDiv[subDivI];
    for (let i = 0, n = subs.length; i < n; ++i) {
      const idc = [subs[i].start, subs[i].end];
      const matrixHelper = new groups_CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
      let prevLast = null;
      const startIdx = subs[i].start * 2;
      const endIdx = subs[i].end * 2 + 1;
      let prevSecondRad = mode.getResidueRadius(residues[0], 0);
      for (let idx = startIdx; idx <= endIdx; ++idx) {
        const resIdx = idx / 2 | 0;
        const currRes = residues[resIdx];
        const firstRad = mode.getResidueRadius(currRes, idx % 2);
        const secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);
        const mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
        mtc.unshift(prevLast === null ? mtc[0] : prevLast);

        // Slope - radius is changed along this residue part
        const hasSlope = firstRad.x !== secondRad.x || firstRad.y !== secondRad.y;
        // Cut - end radius of previous part not equal to start radius of this part. First section of this part lies in the orthogonal plane
        const hasCut = firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y;
        callback(currRes, mtc, hasSlope, hasCut);
        prevLast = mtc[segmentsHeight];
        prevSecondRad = secondRad;
      }
    }
  }
}
class ResiduesSubseqGroup extends groups_ResiduesGroup {
  _makeGeoArgs() {
    const cmpMultiplier = this._mode.getHeightSegmentsRatio();
    this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
    return [ResiduesSubseqGroup_createShape(1.0, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
  }
  _build() {
    const {
      residues,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const tension = mode.getTension();
    const geo = this._geo;
    let chunkIdx = 0;
    const chunkIdc = [];
    _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode, function (currRes, mtc) {
      let hasSlope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      let hasCut = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      const color = colorer.getResidueColor(currRes, parent);
      chunkIdc[chunkIdx] = currRes._index;
      geo.setItem(chunkIdx, mtc, hasSlope, hasCut);
      geo.setColor(chunkIdx++, color);
    });
    this._chunksIdc = chunkIdc;
    geo.finalize();
  }
  updateToFrame(frameData) {
    // This method looks like a copy paste. However, it
    // was decided to postpone animation refactoring until GFX is fixed.
    const {
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const tension = mode.getTension();
    const geo = this._geo;
    const frameRes = frameData.getResidues();
    let chunkIdx = 0;
    const updateColor = frameData.needsColorUpdate(colorer);
    _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode, (currRes, mtc) => {
      geo.setItem(chunkIdx, mtc);
      if (updateColor) {
        geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
      }
      chunkIdx++;
    });
    geo.finalize();
  }
}
/* harmony default export */ const groups_ResiduesSubseqGroup = (ResiduesSubseqGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/ResiduesTraceGroup.js

class ResiduesTraceGroup extends groups_ChemGroup {
  _makeGeoArgs() {
    const subDiv = this._selection.subdivs;
    let chunksCount = 0;
    for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      const subs = subDiv[subDivI].arr;
      for (let i = 0, n = subs.length; i < n; ++i) {
        chunksCount += subs[i].end - subs[i].start;
      }
    }
    return [chunksCount, this._polyComplexity];
  }
  _build() {
    const {
      residues,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    let chunkIdx = 0;
    const chunkIdc = [];
    const subDiv = this._selection.subdivs;
    const stickRad = mode.calcStickRadius();
    for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      const subs = subDiv[subDivI].arr;
      for (let i = 0, n = subs.length; i < n; ++i) {
        const startIdx = subs[i].start;
        const endIdx = subs[i].end;
        let prevRes = residues[startIdx];
        for (let idx = startIdx + 1; idx <= endIdx; ++idx) {
          const currRes = residues[idx];
          chunkIdc[chunkIdx] = {
            first: prevRes._index,
            second: currRes._index
          };
          geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
          geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
          chunkIdx++;
          prevRes = currRes;
        }
      }
    }
    this._chunksIdc = chunkIdc;
    geo.finalize();
  }
  updateToFrame(frameData) {
    // This method looks like a copy paste. However, it
    // was decided to postpone animation refactoring until GFX is fixed.

    const residues = frameData.getResidues();
    const {
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    let chunkIdx = 0;
    const subDiv = this._selection.subdivs;
    const stickRad = mode.calcStickRadius();
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      const subs = subDiv[subDivI].arr;
      for (let i = 0, n = subs.length; i < n; ++i) {
        const startIdx = subs[i].start;
        const endIdx = subs[i].end;
        let prevRes = residues[startIdx];
        for (let idx = startIdx + 1; idx <= endIdx; ++idx) {
          const currRes = residues[idx];
          geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
          if (updateColor) {
            geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
          }
          chunkIdx++;
          prevRes = currRes;
        }
      }
    }
    geo.finalize();
  }
  raycast(raycaster, intersects) {
    const inters = [];
    const {
      residues
    } = this._selection;
    this._mesh.raycast(raycaster, inters);
    const chunksToIdx = this._chunksIdc;
    // process inters array - arr object references
    for (let i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      const {
        chunkIdx
      } = inters[i];
      const chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
      const resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;
      if (resIdx < residues.length) {
        inters[i].residue = residues[resIdx];
        intersects.push(inters[i]);
      }
    }
  }
  _calcChunksList(mask) {
    const chunksList = [];
    const chunksToIdx = this._chunksIdc;
    const {
      residues
    } = this._selection;
    for (let i = 0, n = chunksToIdx.length; i < n; ++i) {
      const chunk = chunksToIdx[i];
      if (residues[chunk.first]._mask & mask) {
        chunksList.push(i * 2);
      }
      if (residues[chunk.second]._mask & mask) {
        chunksList.push(i * 2 + 1);
      }
    }
    return chunksList;
  }
}
/* harmony default export */ const groups_ResiduesTraceGroup = (ResiduesTraceGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/BondsGroup.js


function getCylinderCount(bondOrder) {
  return bondOrder < 2 ? 1 : bondOrder;
}
class BondsGroup extends groups_ChemGroup {
  _makeGeoArgs() {
    const drawMultiple = this._mode.drawMultiorderBonds();
    const showAromatic = this._mode.showAromaticLoops();
    const bondsIdc = this._selection.chunks;
    const {
      bonds
    } = this._selection;
    let bondsCount = 0;
    for (let i = 0, n = bondsIdc.length; i < n; ++i) {
      bondsCount += this.getBondOrder(bonds[bondsIdc[i]], drawMultiple, showAromatic);
    }
    return [bondsCount, this._polyComplexity];
  }
  getBondOrder(bond, drawMultiple, showAromatic) {
    let bondOrder = 1;
    if (drawMultiple && (!showAromatic || bond._type !== chem_Bond.BondType.AROMATIC)) {
      bondOrder = getCylinderCount(bond._order);
    }
    return bondOrder;
  }
  raycast(raycaster, intersects) {
    const {
      bonds
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const bondsIdc = this._chunksIdc;
    // process inters array - arr object references
    for (let i = 0, n = inters.length; i < n; ++i) {
      if (!inters[i].hasOwnProperty('chunkIdx')) {
        continue;
      }
      const {
        chunkIdx
      } = inters[i];
      const bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];
      if (bondIdx < bonds.length) {
        const bond = bonds[bondIdx];
        inters[i].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
        intersects.push(inters[i]);
      }
    }
  }
  _calcChunksList(mask, innerOnly) {
    const chunksList = [];
    const {
      bonds
    } = this._selection;
    const chunksToIdx = this._chunksIdc;
    for (let i = 0, n = chunksToIdx.length; i < n; ++i) {
      const bond = bonds[chunksToIdx[i]];
      if (bond._left.mask & mask && (!innerOnly || bond._right.mask & mask)) {
        chunksList.push(2 * i);
      }
      if (bond._right.mask & mask && (!innerOnly || bond._left.mask & mask)) {
        chunksList.push(2 * i + 1);
      }
    }
    return chunksList;
  }
}
/* harmony default export */ const groups_BondsGroup = (BondsGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/BondsCylinderGroup.js


class BondsCylinderGroup extends groups_BondsGroup {
  _build() {
    const bondsIdc = this._selection.chunks;
    const {
      bonds,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const stickRad = mode.calcStickRadius();
    const emptyOffset = mode.calcSpaceFraction();
    let normDir;
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const chunksToIdx = [];
    for (let i = 0, n = bondsIdc.length; i < n; ++i) {
      const bond = bonds[bondsIdc[i]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = atom1.position;
      const a2Pos = atom2.position;
      normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      const minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
      const dist = 2 * minRad / order;
      const currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;
      for (let j = 0; j < order; ++j) {
        const scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
        chunksToIdx[currBondIdx] = bond._index;
        leftPos.copy(a1Pos);
        leftPos.addScaledVector(normDir, scale);
        rightPos.copy(a2Pos);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
        geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
      }
    }
    geo.finalize();
    this._chunksIdc = chunksToIdx;
  }
  updateToFrame(frameData) {
    const bondsIdc = this._selection.chunks;
    const {
      bonds
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const stickRad = mode.calcStickRadius();
    const emptyOffset = mode.calcSpaceFraction();
    let normDir;
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let i = 0, n = bondsIdc.length; i < n; ++i) {
      const bond = bonds[bondsIdc[i]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = frameData.getAtomPos(atom1.index).clone();
      const a2Pos = frameData.getAtomPos(atom2.index);
      normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      const minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
      const dist = 2 * minRad / order;
      const currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1.0 - emptyOffset)) : stickRad;
      for (let j = 0; j < order; ++j) {
        const scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
        leftPos.copy(a1Pos);
        leftPos.addScaledVector(normDir, scale);
        rightPos.copy(a2Pos);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
        if (updateColor) {
          geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
        }
        currBondIdx++;
      }
    }
    geo.finalize();
  }
}
/* harmony default export */ const groups_BondsCylinderGroup = (BondsCylinderGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/BondsLinesGroup.js


const STEP_SIZE = 0.15;
class BondsLinesGroup extends groups_BondsGroup {
  _build() {
    const bondsIdc = this._selection.chunks;
    const {
      bonds,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const bondDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const chunksToIdx = [];
    for (let i = 0, n = bondsIdc.length; i < n; ++i) {
      const bond = bonds[bondsIdc[i]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = atom1.position;
      const a2Pos = atom2.position;
      const a1Hangs = atom1.bonds.length === 1;
      const a2Hangs = atom2.bonds.length === 1;
      bondDir.subVectors(a2Pos, a1Pos);
      const len = bondDir.length();
      const normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      for (let j = 0; j < order; ++j) {
        leftPos.copy(a1Pos);
        rightPos.copy(a2Pos);
        let scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
        chunksToIdx[currBondIdx] = bond._index;
        if (order === 2 && !a1Hangs && !a2Hangs) {
          scale -= 0.5;
          scale *= -1;
        }
        if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
          leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
          rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
        }
        scale *= STEP_SIZE;
        leftPos.addScaledVector(normDir, scale);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos);
        geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
      }
    }
    geo.finalize();
    this._chunksIdc = chunksToIdx;
  }
  updateToFrame(frameData) {
    // This method looks like a copy paste. However, it
    // was decided to postpone animation refactoring until GFX is fixed.
    const bondsIdc = this._selection.chunks;
    const {
      bonds
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const bondDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let i = 0, n = bondsIdc.length; i < n; ++i) {
      const bond = bonds[bondsIdc[i]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = frameData.getAtomPos(atom1.index).clone();
      const a2Pos = frameData.getAtomPos(atom2.index);
      const a1Hangs = atom1.bonds.length === 1;
      const a2Hangs = atom2.bonds.length === 1;
      bondDir.subVectors(a2Pos, a1Pos);
      const len = bondDir.length();
      const normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      for (let j = 0; j < order; ++j) {
        leftPos.copy(a1Pos);
        rightPos.copy(a2Pos);
        let scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
        if (order === 2 && !a1Hangs && !a2Hangs) {
          scale -= 0.5;
          scale *= -1;
        }
        if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
          leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
          rightPos.lerpVectors(a1Pos, a2Pos, 1.0 - STEP_SIZE / len);
        }
        scale *= STEP_SIZE;
        leftPos.addScaledVector(normDir, scale);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos);
        if (updateColor) {
          geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
        }
        currBondIdx++;
      }
    }
    geo.finalize();
  }
}
/* harmony default export */ const groups_BondsLinesGroup = (BondsLinesGroup);
;// CONCATENATED MODULE: ./src/gfx/modes/groups/groups.js












/* harmony default export */ const groups = ({
  AtomsSphereGroup: groups_AtomsSphereGroup,
  AtomsSurfaceGroup: groups_AtomsSurfaceGroup,
  AtomsSASSESGroupStub: groups_AtomsSASSESGroupStub,
  AtomsTextGroup: groups_AtomsTextGroup,
  AromaticTorusGroup: groups_AromaticTorusGroup,
  AromaticLinesGroup: groups_AromaticLinesGroup,
  NucleicCylindersGroup: groups_NucleicCylindersGroup,
  NucleicSpheresGroup: groups_NucleicSpheresGroup,
  ResiduesSubseqGroup: groups_ResiduesSubseqGroup,
  ResiduesTraceGroup: groups_ResiduesTraceGroup,
  BondsCylinderGroup: groups_BondsCylinderGroup,
  BondsLinesGroup: groups_BondsLinesGroup
});
;// CONCATENATED MODULE: ./src/gfx/modes/processors/AtomsProcessor.js

class AtomsProcessor extends gfx_RCGroup {
  constructor(AtomsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self = this;
    this._complex = complex;
    this._mode = mode;
    const atoms = complex.getAtoms();
    const transforms = complex.getTransforms();
    complex.forEachComponent(component => {
      const atomsIdc = [];
      let atomCount = 0;
      component.forEachAtom(atom => {
        if (!self._checkAtom(atom, mask)) {
          return;
        }
        atomsIdc[atomCount++] = atom.index;
      });
      if (atomCount === 0) {
        return;
      }
      const atomsGroup = new AtomsGroup(geoParams, {
        atoms,
        chunks: atomsIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      atomsGroup._component = component;
      self.add(atomsGroup);
    });
  }
  _checkAtom(atom, mask) {
    return atom.mask & mask;
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        const chSubset = children[i].getSubset(mask, innerOnly);
        for (let j = 0, m = chSubset.length; j < m; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
}
/* harmony default export */ const processors_AtomsProcessor = (AtomsProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/OrphanAtomsProcessor.js

class OrphanAtomsProcessor extends processors_AtomsProcessor {
  _checkAtom(atom, mask) {
    if (!(atom.mask & mask)) {
      return false;
    }
    const {
      bonds
    } = atom;
    for (let i = 0, n = bonds.length; i < n; ++i) {
      if (bonds[i]._left.mask & mask && bonds[i]._right.mask & mask) {
        return false;
      }
    }
    return true;
  }
}
/* harmony default export */ const processors_OrphanAtomsProcessor = (OrphanAtomsProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/ResiduesProcessor.js

class ResiduesProcessor extends gfx_RCGroup {
  constructor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self = this;
    this._complex = complex;
    const residues = complex.getResidues();
    const transforms = complex.getTransforms();
    complex.forEachComponent(component => {
      let chunksCount = 0;
      const resIdc = [];
      component.forEachResidue(residue => {
        if (self._checkResidue(residue, mask)) {
          resIdc[chunksCount++] = residue._index;
        }
      });
      if (chunksCount === 0) {
        return;
      }
      const residuesGroup = new ResidueGroup(geoParams, {
        residues,
        chunks: resIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      residuesGroup._component = component;
      self.add(residuesGroup);
    });
  }
  checkResidue(residue, mask) {
    return residue._mask & mask;
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        const chSubset = children[i].getSubset(mask, innerOnly);
        for (let j = 0, m = chSubset.length; j < m; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
}
/* harmony default export */ const processors_ResiduesProcessor = (ResiduesProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/NucleicProcessor.js

class NucleicProcessor extends processors_ResiduesProcessor {
  _checkResidue(residue, mask) {
    return mask & residue._mask && residue._cylinders !== null;
  }
}
/* harmony default export */ const processors_NucleicProcessor = (NucleicProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/SubseqsProcessor.js

class SubseqsProcessor extends gfx_RCGroup {
  constructor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self = this;
    this._complex = complex;
    const residues = complex.getResidues();
    const transforms = complex.getTransforms();
    complex.forEachComponent(component => {
      const subDivs = component.getMaskedSubdivSequences(mask);
      let chunksCount = 0;
      const resIdc = [];
      for (let subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
        const subs = subDivs[subDivI].arr;
        for (let i = 0, n = subs.length; i < n; ++i) {
          for (let j = subs[i].start, jEnd = subs[i].end; j <= jEnd; ++j) {
            resIdc[chunksCount++] = residues[j]._index;
          }
        }
      }
      if (chunksCount === 0) {
        return;
      }
      const residuesGroup = new ResidueGroup(geoParams, {
        residues,
        chunks: resIdc,
        subdivs: subDivs,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      residuesGroup._component = component;
      self.add(residuesGroup);
    });
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        const chSubset = children[i].getSubset(mask, innerOnly);
        for (let j = 0, m = chSubset.length; j < m; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
}
/* harmony default export */ const processors_SubseqsProcessor = (SubseqsProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/BondsProcessor.js

class BondsProcessor extends gfx_RCGroup {
  constructor(BondsGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self = this;
    this._complex = complex;
    const bonds = complex.getBonds();
    const transforms = complex.getTransforms();
    complex.forEachComponent(component => {
      const bondsIdc = [];
      let bondsCount = 0;
      component.forEachBond(bond => {
        const atom1 = bond._left;
        const atom2 = bond._right;
        if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
          return;
        }
        bondsIdc[bondsCount++] = bond._index;
      });
      if (bondsCount === 0) {
        return;
      }
      const bondsGroup = new BondsGroup(geoParams, {
        bonds,
        chunks: bondsIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      bondsGroup._component = component;
      self.add(bondsGroup);
    });
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        const chSubset = children[i].getSubset(mask, innerOnly);
        for (let j = 0, m = chSubset.length; j < m; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
}
/* harmony default export */ const processors_BondsProcessor = (BondsProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/AromaticProcessor.js

class AromaticProcessor extends gfx_RCGroup {
  constructor(AromaticGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self = this;
    this._complex = complex;
    const atoms = complex.getAtoms();
    const transforms = complex.getTransforms();
    if (!mode.showAromaticLoops()) {
      return;
    }
    complex.forEachComponent(component => {
      const atomsIdc = [];
      let chunksCount = 0;
      const cycles = [];
      let cycleIdx = 0;
      component.forEachCycle(cycle => {
        const cycAtoms = cycle.atoms;
        let perCycle = 0;
        for (let i = 0, n = cycAtoms.length; i < n; ++i) {
          if ((cycAtoms[i].mask & mask) !== 0) {
            ++perCycle;
            atomsIdc[chunksCount++] = cycAtoms[i].index;
          }
        }
        if (perCycle > 0) {
          cycles[cycleIdx++] = cycle;
        }
      });
      const atomsGroup = new AromaticGroup(geoParams, {
        cycles,
        atoms,
        chunks: atomsIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      atomsGroup._component = component;
      self.add(atomsGroup);
    });
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i = 0, n = children.length; i < n; ++i) {
      if (children[i].getSubset) {
        const chSubset = children[i].getSubset(mask, innerOnly);
        for (let j = 0, m = chSubset.length; j < m; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
}
/* harmony default export */ const processors_AromaticProcessor = (AromaticProcessor);
;// CONCATENATED MODULE: ./src/gfx/modes/processors/processors.js







/* harmony default export */ const processors = ({
  Atoms: processors_AtomsProcessor,
  OrphanAtoms: processors_OrphanAtomsProcessor,
  Residues: processors_ResiduesProcessor,
  Nucleic: processors_NucleicProcessor,
  Subseqs: processors_SubseqsProcessor,
  Bonds: processors_BondsProcessor,
  Aromatic: processors_AromaticProcessor
});
;// CONCATENATED MODULE: ./src/gfx/modes/groups/GroupsFactory.js



function _bakeGroup(triplet, Processor, Group) {
  return function (complex, colorer, mode, polyComplexity, mask, material) {
    return new Processor(Group, triplet, complex, colorer, mode, polyComplexity, mask, material);
  };
}
class GroupsFactory {
  static AtomsSpheres(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.createSpheres(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
  }
  static OrphanedAtomsCrosses(caps, settings, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createCrosses(caps, settings, renderParams);
    return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
  }
  static BondsCylinders(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.create2CCylinders(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
  }
  static BondsLines(caps, settings, renderParams) {
    const gfxTriplet = meshes_MeshCreator.create2CLines(caps, settings, renderParams);
    return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
  }
  static CartoonChains(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.createExtrudedChains(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
  }
  static TraceChains(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.create2CClosedCylinders(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
  }
  static NucleicSpheres(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.createSpheres(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
  }
  static NucleicCylinders(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.create2CCylinders(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
  }
  static ALoopsTorus(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.createExtrudedChains(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
  }
  static ALoopsLines(caps, settings, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createChunkedLines(caps, settings, renderParams);
    return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
  }
  static QuickSurfGeo(caps, settings, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createQuickSurface(caps, settings, renderParams);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
  }
  static ContactSurfaceGeo(caps, settings, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createContactSurface(caps, settings, renderParams);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
  }
  static SASSESSurfaceGeo(caps, settings, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createSASSES(caps, settings, renderParams);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
  }
  static TextLabelsGeo(caps, settings) {
    const gfxTriplet = meshes_MeshCreator.createLabels(caps, settings);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
  }
}
/* harmony default export */ const groups_GroupsFactory = (GroupsFactory);
;// CONCATENATED MODULE: ./src/gfx/modes/Mode.js






/**
 * Create new mode.
 *
 * @param {object=} opts - Options to override defaults with.
 *
 *   These options are copied locally and not kept by reference, so the created instance will not reflect further
 *   changes to the `opts` object. However, changes in defaults **will** affect the mode after its creation.
 *
 * @exports Mode
 * @this Mode
 * @abstract
 * @constructor
 * @classdesc Basic class for all available modes used for building and displaying molecule geometry.
 */
class Mode {
  constructor(opts) {
    if (this.constructor === Mode) {
      throw new Error('Can not instantiate abstract class!');
    }
    /**
     * Mode options inherited (prototyped) from defaults.
     * @type {object}
     */
    this.opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
  }

  /**
   * Get mode identification, probably with options.
   * @returns {string|Array} Mode identifier string ({@link Mode#id}) or two-element array containing both mode
   *   identifier and options ({@link Mode#opts}).
   * Options are returned if they were changed during or after the mode creation.
   */
  identify() {
    const diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      return [this.id, diff];
    }
    return this.id;
  }
  buildGeometry(complex, colorer, mask, material) {
    const polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
    const groupList = this.depGroups;
    const groupCount = groupList.length;
    const group = new gfxutils.RCGroup();
    const self = this;
    for (let i = 0; i < groupCount; ++i) {
      let currGroup = groupList[i];
      let renderParams = {};
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(currGroup)) {
        renderParams = currGroup[1].call(this);
        [currGroup] = currGroup;
      }
      const Group = groups_GroupsFactory[currGroup](null, this.settings, renderParams);
      const newGroup = new Group(complex, colorer, self, polyComplexity, mask, material);
      if (newGroup.children.length > 0) {
        group.add(newGroup);
      }
    }
    return group;
  }
}
utils_makeContextDependent(Mode.prototype);

/**
* Mode identifier.
* @type {string}
*/
Mode.prototype.id = '__';

/**
 * Mode geo groups.
 * @type {Array}
 */
Mode.prototype.depGroups = [];
/* harmony default export */ const modes_Mode = (Mode);
;// CONCATENATED MODULE: ./src/gfx/modes/LinesMode.js

function getRenderParams() {
  return {
    lineWidth: this.opts.lineWidth
  };
}
class LinesMode extends modes_Mode {
  static id = 'LN';
  constructor(opts) {
    super(opts);
    this.depGroups = this.depGroups.slice(0); // clone depGroups to prevent prototype edits
    const groups = this.depGroups;
    for (let i = 0, n = groups.length; i < n; ++i) {
      groups[i] = [groups[i], getRenderParams];
    }
  }
  drawMultiorderBonds() {
    return this.opts.multibond;
  }
  calcAtomRadius() {
    return this.opts.atom;
  }
  getAromaticOffset() {
    return this.opts.offsarom;
  }
  getAromaticArcChunks() {
    return this.opts.chunkarom;
  }
  showAromaticLoops() {
    return this.opts.showarom;
  }
}
LinesMode.prototype.id = 'LN';
LinesMode.prototype.name = 'Lines';
LinesMode.prototype.shortName = 'Lines';
LinesMode.prototype.depGroups = ['ALoopsLines', 'BondsLines', 'OrphanedAtomsCrosses'];
/* harmony default export */ const modes_LinesMode = (LinesMode);
;// CONCATENATED MODULE: ./src/gfx/modes/LicoriceMode.js
/* eslint-disable no-magic-numbers */

class LicoriceMode extends modes_Mode {
  static id = 'LC';
  calcAtomRadius(_atom) {
    return this.opts.bond;
  }
  calcStickRadius() {
    return this.opts.bond;
  }
  calcSpaceFraction() {
    return this.opts.space;
  }
  getAromRadius() {
    return this.opts.aromrad;
  }
  showAromaticLoops() {
    return this.opts.showarom;
  }
  drawMultiorderBonds() {
    return this.opts.multibond;
  }
}
LicoriceMode.prototype.id = 'LC';
LicoriceMode.prototype.name = 'Licorice';
LicoriceMode.prototype.shortName = 'Licorice';
LicoriceMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];
/* harmony default export */ const modes_LicoriceMode = (LicoriceMode);
;// CONCATENATED MODULE: ./src/gfx/modes/BallsAndSticksMode.js
/* eslint-disable no-magic-numbers */

class BallsAndSticksMode extends modes_Mode {
  static id = 'BS';
  calcAtomRadius(atom) {
    return atom.element.radius * this.opts.atom;
  }
  calcStickRadius() {
    return this.opts.bond;
  }
  getAromRadius() {
    return this.opts.aromrad;
  }
  showAromaticLoops() {
    return this.opts.showarom;
  }
  calcSpaceFraction() {
    return this.opts.space;
  }
  drawMultiorderBonds() {
    return this.opts.multibond;
  }
}
BallsAndSticksMode.prototype.id = 'BS';
BallsAndSticksMode.prototype.name = 'Balls and Sticks';
BallsAndSticksMode.prototype.shortName = 'Balls';
BallsAndSticksMode.prototype.depGroups = ['AtomsSpheres', 'BondsCylinders', 'ALoopsTorus'];
/* harmony default export */ const modes_BallsAndSticksMode = (BallsAndSticksMode);
;// CONCATENATED MODULE: ./src/gfx/modes/VanDerWaalsMode.js

class VanDerWaalsMode extends modes_Mode {
  static id = 'VW';
  calcAtomRadius(atom) {
    return atom.element.radius;
  }
}
VanDerWaalsMode.prototype.id = 'VW';
VanDerWaalsMode.prototype.name = 'Van der Waals';
VanDerWaalsMode.prototype.shortName = 'VDW';
VanDerWaalsMode.prototype.depGroups = ['AtomsSpheres'];
/* harmony default export */ const modes_VanDerWaalsMode = (VanDerWaalsMode);
;// CONCATENATED MODULE: ./src/gfx/modes/TraceMode.js

class TraceMode extends modes_Mode {
  static id = 'TR';
  calcStickRadius() {
    return this.opts.radius;
  }
}
TraceMode.prototype.id = 'TR';
TraceMode.prototype.name = 'Trace';
TraceMode.prototype.shortName = 'Trace';
TraceMode.prototype.depGroups = ['TraceChains'];
/* harmony default export */ const modes_TraceMode = (TraceMode);
;// CONCATENATED MODULE: ./src/gfx/modes/TubeMode.js


class TubeMode extends modes_Mode {
  static id = 'TU';
  getResidueRadius(_residue) {
    return this.TUBE_RADIUS;
  }
  getHeightSegmentsRatio() {
    return this.opts.heightSegmentsRatio;
  }
  getTension() {
    return this.opts.tension;
  }
  buildGeometry(complex, colorer, mask, material) {
    const rad = this.opts.radius;
    this.TUBE_RADIUS = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(rad, rad);
    return modes_Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
  }
}
TubeMode.prototype.id = 'TU';
TubeMode.prototype.name = 'Tube';
TubeMode.prototype.shortName = 'Tube';
TubeMode.prototype.depGroups = ['CartoonChains'];
/* harmony default export */ const modes_TubeMode = (TubeMode);
;// CONCATENATED MODULE: ./src/gfx/modes/CartoonMode.js


class CartoonMode extends modes_Mode {
  static id = 'CA';
  constructor(opts) {
    super(opts);
    // cache for secondary structure options
    this.secCache = {};
  }
  getResidueStartRadius(residue) {
    const second = residue.getSecondary();
    if (!second || !second.generic) {
      return this.TUBE_RADIUS;
    }
    const secOpts = this.secCache[second.generic];
    if (!secOpts) {
      return this.TUBE_RADIUS;
    }
    if (second.term === residue) {
      return secOpts.start;
    }
    return secOpts.center;
  }
  getResidueEndRadius(residue) {
    const second = residue.getSecondary();
    if (second === null || !second.generic) {
      return this.TUBE_RADIUS;
    }
    const secOpts = this.secCache[second.generic];
    if (!secOpts) {
      return this.TUBE_RADIUS;
    }
    if (second.term === residue) {
      return this.ARROW_END;
    }
    return secOpts.center;
  }
  getResidueRadius(residue, val) {
    const startRad = this.getResidueStartRadius(residue);
    if (val === 0) {
      return startRad;
    }
    const endRad = this.getResidueEndRadius(residue);
    if (val === 2) {
      return endRad;
    }
    return startRad.clone().lerp(endRad, val / 2.0);
  }
  calcStickRadius(_res) {
    return this.opts.radius;
  }
  getHeightSegmentsRatio() {
    return this.opts.heightSegmentsRatio;
  }
  getTension() {
    return this.opts.tension;
  }
  buildGeometry(complex, colorer, mask, material) {
    const tubeRad = this.opts.radius;
    const secHeight = this.opts.depth;
    this.TUBE_RADIUS = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(tubeRad, tubeRad);
    this.ARROW_END = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(secHeight, tubeRad);
    const secCache = {};
    const secData = this.opts.ss;
    /* eslint-disable guard-for-in */
    for (const prop in secData) {
      secCache[prop] = {
        center: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(secHeight, secData[prop].width),
        start: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(secHeight, secData[prop].arrow)
      };
    }
    this.secCache = secCache;
    /* eslint-enable guard-for-in */

    return modes_Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
  }
}
CartoonMode.prototype.id = 'CA';
CartoonMode.prototype.name = 'Cartoon';
CartoonMode.prototype.shortName = 'Cartoon';
CartoonMode.prototype.depGroups = ['CartoonChains', 'NucleicSpheres', 'NucleicCylinders'];
/* harmony default export */ const modes_CartoonMode = (CartoonMode);
;// CONCATENATED MODULE: ./src/gfx/modes/SurfaceMode.js


const {
  selectors: SurfaceMode_selectors
} = chem;
function SurfaceMode_getRenderParams() {
  return {
    wireframe: this.opts.wireframe,
    zClip: this.opts.zClip
  };
}
class SurfaceMode extends modes_Mode {
  constructor(opts) {
    super(opts);
    this.depGroups = this.depGroups.slice(0); // clone depGroups to prevent prototype edits
    const surfaces = this.surfaceNames;
    const groups = this.depGroups;
    for (let i = 0, n = surfaces.length; i < n; ++i) {
      groups[groups.length] = [surfaces[i], SurfaceMode_getRenderParams];
    }
  }
  calcAtomRadius(atom) {
    return atom.element.radius;
  }
  getVisibilitySelector() {
    let visibilitySelector = null;
    if (this.opts.subset !== '') {
      const res = SurfaceMode_selectors.parse(this.opts.subset);
      if (!res.error) {
        visibilitySelector = res.selector;
      }
    }
    return visibilitySelector;
  }
}
SurfaceMode.prototype.isSurface = true;
SurfaceMode.prototype.surfaceNames = [];
/* harmony default export */ const modes_SurfaceMode = (SurfaceMode);
;// CONCATENATED MODULE: ./src/gfx/modes/QuickSurfaceMode.js

class QuickSurfaceMode extends modes_SurfaceMode {
  static id = 'QS';
  getSurfaceOpts() {
    return {
      useBeads: false,
      isoValue: this.opts.isoValue,
      gaussLim: this.opts.gaussLim[this.settings.now.resolution],
      radScale: this.opts.scale,
      gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
      zClip: this.opts.zClip,
      visibilitySelector: this.getVisibilitySelector()
    };
  }
}
QuickSurfaceMode.prototype.id = 'QS';
QuickSurfaceMode.prototype.name = 'Quick Surface';
QuickSurfaceMode.prototype.shortName = 'Quick Surf';
QuickSurfaceMode.prototype.surfaceNames = ['QuickSurfGeo'];
/* harmony default export */ const modes_QuickSurfaceMode = (QuickSurfaceMode);
;// CONCATENATED MODULE: ./src/gfx/modes/IsoSurfaceMode.js

class IsoSurfaceMode extends modes_SurfaceMode {
  constructor(excludeProbe, opts) {
    super(opts);
    this._excludeProbe = excludeProbe;
  }
  calcAtomRadius(atom) {
    return atom.element.radius;
  }
  getSurfaceOpts() {
    return {
      gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
      radScale: this._radScale,
      zClip: this.opts.zClip,
      visibilitySelector: this.getVisibilitySelector(),
      probeRadius: this.opts.probeRadius,
      excludeProbe: this._excludeProbe
    };
  }
}
IsoSurfaceMode.prototype.id = 'SU';
IsoSurfaceMode.prototype.name = 'Surface';
IsoSurfaceMode.prototype.shortName = 'Surface';
IsoSurfaceMode.prototype.surfaceNames = ['SASSESSurfaceGeo'];
IsoSurfaceMode.prototype._radScale = 1;
IsoSurfaceMode.prototype._excludeProbe = false;
/* harmony default export */ const modes_IsoSurfaceMode = (IsoSurfaceMode);
;// CONCATENATED MODULE: ./src/gfx/modes/IsoSurfaceSASMode.js

class IsoSurfaceSASMode extends modes_IsoSurfaceMode {
  static id = 'SA';
  constructor(opts) {
    super(false, opts);
  }
}
IsoSurfaceSASMode.prototype.id = 'SA';
IsoSurfaceSASMode.prototype.name = 'Solvent Accessible Surface';
IsoSurfaceSASMode.prototype.shortName = 'SAS';
/* harmony default export */ const modes_IsoSurfaceSASMode = (IsoSurfaceSASMode);
;// CONCATENATED MODULE: ./src/gfx/modes/IsoSurfaceSESMode.js

class IsoSurfaceSESMode extends modes_IsoSurfaceMode {
  static id = 'SE';
  constructor(opts) {
    super(true, opts);
  }
}
IsoSurfaceSESMode.prototype.id = 'SE';
IsoSurfaceSESMode.prototype.name = 'Solvent Excluded Surface';
IsoSurfaceSESMode.prototype.shortName = 'SES';
/* harmony default export */ const modes_IsoSurfaceSESMode = (IsoSurfaceSESMode);
;// CONCATENATED MODULE: ./src/gfx/modes/ContactSurfaceMode.js

class ContactSurfaceMode extends modes_SurfaceMode {
  static id = 'CS';
  getSurfaceOpts() {
    return {
      probeRadius: this.opts.probeRadius,
      radScale: this.opts.polyComplexity[this.settings.now.resolution],
      scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
      gridSpacing: 1.0 / this.opts.polyComplexity[this.settings.now.resolution],
      isoValue: this.opts.isoValue,
      probePositions: this.opts.probePositions,
      zClip: this.opts.zClip,
      visibilitySelector: this.getVisibilitySelector()
    };
  }
}
ContactSurfaceMode.prototype.id = 'CS';
ContactSurfaceMode.prototype.name = 'Contact Surface';
ContactSurfaceMode.prototype.shortName = 'Contact Surf';
ContactSurfaceMode.prototype.isSurface = true;
ContactSurfaceMode.prototype.surfaceNames = ['ContactSurfaceGeo'];
/* harmony default export */ const modes_ContactSurfaceMode = (ContactSurfaceMode);
;// CONCATENATED MODULE: ./src/gfx/modes/TextMode.js


class TextMode extends modes_Mode {
  static id = 'TX';
  getTemplateOptions() {
    return this.opts.template;
  }
  getLabelOpts() {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(this.opts, {
      colors: true,
      adjustColor: true,
      transparent: true
    });
  }
}
TextMode.prototype.id = 'TX';
TextMode.prototype.name = 'Text mode';
TextMode.prototype.shortName = 'Text';
TextMode.prototype.depGroups = ['TextLabelsGeo'];
/* harmony default export */ const modes_TextMode = (TextMode);
;// CONCATENATED MODULE: ./src/gfx/modes.js













const modes = new utils_EntityList([modes_LinesMode, modes_LicoriceMode, modes_BallsAndSticksMode, modes_VanDerWaalsMode, modes_TraceMode, modes_TubeMode, modes_CartoonMode, modes_QuickSurfaceMode, modes_IsoSurfaceSASMode, modes_IsoSurfaceSESMode, modes_ContactSurfaceMode, modes_TextMode]);
/* harmony default export */ const gfx_modes = (modes);
;// CONCATENATED MODULE: ./src/gfx/palettes/Palette.js

function clamp(x, a, b) {
  return x <= b ? x < 0 ? 0 : x : b;
}
function lerpColor(c1, c2, alpha) {
  const beta = 1 - alpha;
  const r1 = c1 >> 16 & 0xff;
  const g1 = c1 >> 8 & 0xff;
  const b1 = c1 & 0xff;
  const r2 = c2 >> 16 & 0xff;
  const g2 = c2 >> 8 & 0xff;
  const b2 = c2 & 0xff;
  const r = beta * r1 + alpha * r2;
  const g = beta * g1 + alpha * g2;
  const b = beta * b1 + alpha * b2;
  return r << 16 | g << 8 | b;
}
class Palette {
  constructor(name, id) {
    this.name = name || 'Custom';
    this.id = id || 'CP';
  }
  getElementColor(name) {
    let asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const color = this.elementColors[name];
    return color === undefined && !asIs ? this.defaultElementColor : color;
  }
  getResidueColor(name) {
    let asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const color = this.residueColors[name];
    return color === undefined && !asIs ? this.defaultResidueColor : color;
  }
  getChainColor(name) {
    let chain = name.charCodeAt(0);
    chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 0x1F) % this.chainColors.length;
    return this.chainColors[chain];
  }
  getSecondaryColor(type) {
    let asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const color = this.secondaryColors[type];
    return color === undefined && !asIs ? this.defaultSecondaryColor : color;
  }
  getSequentialColor(index) {
    const {
      colors
    } = this;
    const len = colors.length;
    return index < 0 ? colors[index % len + len] : colors[index % len];
  }
  getGradientColor(value, gradientName) {
    const gradient = this.gradients[gradientName];
    if (!gradient) {
      return this.defaultNamedColor;
    }
    const count = gradient.length;
    const index = value * (count - 1);
    let left = Math.floor(index);
    const right = clamp(left + 1, 0, count - 1);
    left = clamp(left, 0, count - 1);
    return lerpColor(gradient[left], gradient[right], index - left);
  }
  getNamedColor(name) {
    let asIs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    const color = this.namedColors[name];
    return color === undefined && !asIs ? this.defaultNamedColor : color;
  }
}
external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(Palette.prototype, {
  colors: [0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0x808080],
  minRangeColor: 0x000000,
  midRangeColor: 0x7F7F7F,
  maxRangeColor: 0xFFFFFF,
  defaultElementColor: 0xFFFFFF,
  elementColors: {},
  defaultResidueColor: 0xFFFFFF,
  residueColors: {},
  chainColors: [0xFFFFFF],
  defaultSecondaryColor: 0xFFFFFF,
  secondaryColors: {},
  defaultGradientColor: 0x000000,
  defaultNamedColor: 0xFFFFFF,
  namedColorsArray: [/* eslint-disable no-multi-spaces */
  ['indianred', 0xcd5c5c], ['lightcoral', 0xf08080], ['salmon', 0xfa8072], ['darksalmon', 0xe9967a], ['lightsalmon', 0xffa07a], ['crimson', 0xdc143c], ['red', 0xff0000], ['firebrick', 0xb22222], ['darkred', 0x8b0000], ['pink', 0xffc0cb], ['lightpink', 0xffb6c1], ['hotpink', 0xff69b4], ['deeppink', 0xff1493], ['mediumvioletred', 0xc71585], ['palevioletred', 0xdb7093], ['coral', 0xff7f50], ['tomato', 0xff6347], ['orangered', 0xff4500], ['darkorange', 0xff8c00], ['orange', 0xffa500], ['gold', 0xffd700], ['yellow', 0xffff00], ['lightyellow', 0xffffe0], ['lemonchiffon', 0xfffacd], ['lightgoldenrodyellow', 0xfafad2], ['papayawhip', 0xffefd5], ['moccasin', 0xffe4b5], ['peachpuff', 0xffdab9], ['palegoldenrod', 0xeee8aa], ['khaki', 0xf0e68c], ['darkkhaki', 0xbdb76b], ['lavender', 0xe6e6fa], ['thistle', 0xd8bfd8], ['plum', 0xdda0dd], ['violet', 0xee82ee], ['orchid', 0xda70d6], ['fuchsia', 0xff00ff], ['magenta', 0xff00ff], ['mediumorchid', 0xba55d3], ['mediumpurple', 0x9370db], ['rebeccapurple', 0x663399], ['blueviolet', 0x8a2be2], ['darkviolet', 0x9400d3], ['darkorchid', 0x9932cc], ['darkmagenta', 0x8b008b], ['purple', 0x800080], ['indigo', 0x4b0082], ['slateblue', 0x6a5acd], ['mediumslateblue', 0x7b68ee], ['darkslateblue', 0x483d8b], ['greenyellow', 0xadff2f], ['chartreuse', 0x7fff00], ['lawngreen', 0x7cfc00], ['lime', 0x00ff00], ['limegreen', 0x32cd32], ['palegreen', 0x98fb98], ['lightgreen', 0x90ee90], ['mediumspringgreen', 0x00fa9a], ['springgreen', 0x00ff7f], ['mediumseagreen', 0x3cb371], ['seagreen', 0x2e8b57], ['forestgreen', 0x228b22], ['green', 0x008000], ['darkgreen', 0x006400], ['yellowgreen', 0x9acd32], ['olivedrab', 0x6b8e23], ['olive', 0x808000], ['darkolivegreen', 0x556b2f], ['mediumaquamarine', 0x66cdaa], ['darkseagreen', 0x8fbc8f], ['lightseagreen', 0x20b2aa], ['darkcyan', 0x008b8b], ['teal', 0x008080], ['aqua', 0x00ffff], ['cyan', 0x00ffff], ['lightcyan', 0xe0ffff], ['paleturquoise', 0xafeeee], ['aquamarine', 0x7fffd4], ['turquoise', 0x40e0d0], ['mediumturquoise', 0x48d1cc], ['darkturquoise', 0x00ced1], ['cadetblue', 0x5f9ea0], ['steelblue', 0x4682b4], ['lightsteelblue', 0xb0c4de], ['powderblue', 0xb0e0e6], ['lightblue', 0xadd8e6], ['skyblue', 0x87ceeb], ['lightskyblue', 0x87cefa], ['deepskyblue', 0x00bfff], ['dodgerblue', 0x1e90ff], ['cornflowerblue', 0x6495ed], ['royalblue', 0x4169e1], ['blue', 0x0000ff], ['mediumblue', 0x0000cd], ['darkblue', 0x00008b], ['navy', 0x000080], ['midnightblue', 0x191970], ['cornsilk', 0xfff8dc], ['blanchedalmond', 0xffebcd], ['bisque', 0xffe4c4], ['navajowhite', 0xffdead], ['wheat', 0xf5deb3], ['burlywood', 0xdeb887], ['tan', 0xd2b48c], ['rosybrown', 0xbc8f8f], ['sandybrown', 0xf4a460], ['goldenrod', 0xdaa520], ['darkgoldenrod', 0xb8860b], ['peru', 0xcd853f], ['chocolate', 0xd2691e], ['saddlebrown', 0x8b4513], ['sienna', 0xa0522d], ['brown', 0xa52a2a], ['maroon', 0x800000], ['white', 0xffffff], ['snow', 0xfffafa], ['honeydew', 0xf0fff0], ['mintcream', 0xf5fffa], ['azure', 0xf0ffff], ['aliceblue', 0xf0f8ff], ['ghostwhite', 0xf8f8ff], ['whitesmoke', 0xf5f5f5], ['seashell', 0xfff5ee], ['beige', 0xf5f5dc], ['oldlace', 0xfdf5e6], ['floralwhite', 0xfffaf0], ['ivory', 0xfffff0], ['antiquewhite', 0xfaebd7], ['linen', 0xfaf0e6], ['lavenderblush', 0xfff0f5], ['mistyrose', 0xffe4e1], ['gainsboro', 0xdcdcdc], ['lightgray', 0xd3d3d3], ['silver', 0xc0c0c0], ['darkgray', 0xa9a9a9], ['gray', 0x808080], ['dimgray', 0x696969], ['lightslategray', 0x778899], ['slategray', 0x708090], ['darkslategray', 0x2f4f4f], ['black', 0x000000]
  /* eslint-enable no-multi-spaces */],
  namedColors: {},
  /* eslint-enable no-magic-numbers */

  gradients: {
    rainbow: [0x0000ff,
    // blue
    0x00ffff,
    // cyan
    0x00ff00,
    // green
    0xffff00,
    // yellow
    0xff0000 // red
    ],
    temp: [0x0000ff,
    // blue
    0x007fff,
    // light-blue
    0xffffff,
    // white
    0xff7f00,
    // orange
    0xff0000 // red
    ],
    hot: [0xffffff,
    // white
    0xff7f00,
    // orange
    0xff0000 // red
    ],
    cold: [0xffffff,
    // white
    0x007fff,
    // light-blue
    0x0000ff // blue
    ],
    'blue-red': [0x0000ff,
    // blue
    0xffffff,
    // white
    0xff0000 // red
    ],
    reds: [0xffffff,
    // white
    0xff0000 // red
    ],
    blues: [0xffffff,
    // white
    0x0000ff // blue
    ]
  }
});
const {
  namedColorsArray,
  namedColors
} = Palette.prototype;
for (let i = 0, {
    length
  } = namedColorsArray; i < length; ++i) {
  const [name, value] = namedColorsArray[i];
  namedColors[name] = value;
}
/* harmony default export */ const palettes_Palette = (Palette);
;// CONCATENATED MODULE: ./src/gfx/palettes/cpkPalette.js

const palette = new palettes_Palette('CPK', 'CP');

// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
palette.elementColors = {
  /* eslint-disable no-magic-numbers */
  H: 0xFFFFFF,
  C: 0x202020,
  N: 0x2060FF,
  O: 0xEE2010,
  F: 0x00FF00,
  P: 0x8020FF,
  S: 0xFFFF00,
  CL: 0x00BB00,
  FE: 0xD0D0D0,
  CO: 0xD0D0D0,
  NI: 0xD0D0D0,
  CU: 0xD0D0D0,
  BR: 0x008800,
  I: 0x005500
  /* eslint-enable no-magic-numbers */
};
/* harmony default export */ const cpkPalette = (palette);
;// CONCATENATED MODULE: ./src/gfx/palettes/jmolPalette.js


const jmolPalette_palette = new palettes_Palette('Jmol', 'JM');
jmolPalette_palette.colors = [/* eslint-disable no-magic-numbers */
0x0000FF,
// blue
0x0055FF,
//
0x00ABFF,
//
0x00FFFF,
// cyan
0x00FFAB,
//
0x00FF55,
//
0x00FF00,
// green
0x55FF00,
//
0xABFF00,
//
0xFFFF00,
// yellow
0xFFAB00,
//
0xFF5500,
//
0xFF0000,
// red
0xFF0055,
//
0xFF00AB,
//
0xFF00FF,
// magenta
0xAB00FF,
//
0x5500FF //
/* eslint-enable no-magic-numbers */];

// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
jmolPalette_palette.elementColors = {
  /* eslint-disable no-magic-numbers */
  H: 0xFFFFFF,
  D: 0xFFFFC0,
  T: 0xFFFFA0,
  HE: 0xD9FFFF,
  LI: 0xCC80FF,
  BE: 0xC2FF00,
  B: 0xFFB5B5,
  C: 0x909090,
  N: 0x3050F8,
  O: 0xFF0D0D,
  F: 0x90E050,
  NE: 0xB3E3F5,
  NA: 0xAB5CF2,
  MG: 0x8AFF00,
  AL: 0xBFA6A6,
  SI: 0xF0C8A0,
  P: 0xFF8000,
  S: 0xFFFF30,
  CL: 0x1FF01F,
  AR: 0x80D1E3,
  K: 0x8F40D4,
  CA: 0x3DFF00,
  SC: 0xE6E6E6,
  TI: 0xBFC2C7,
  V: 0xA6A6AB,
  CR: 0x8A99C7,
  MN: 0x9C7AC7,
  FE: 0xE06633,
  CO: 0xF090A0,
  NI: 0x50D050,
  CU: 0xC88033,
  ZN: 0x7D80B0,
  GA: 0xC28F8F,
  GE: 0x668F8F,
  AS: 0xBD80E3,
  SE: 0xFFA100,
  BR: 0xA62929,
  KR: 0x5CB8D1,
  RB: 0x702EB0,
  SR: 0x00FF00,
  Y: 0x94FFFF,
  ZR: 0x94E0E0,
  NB: 0x73C2C9,
  MO: 0x54B5B5,
  TC: 0x3B9E9E,
  RU: 0x248F8F,
  RH: 0x0A7D8C,
  PD: 0x006985,
  AG: 0xC0C0C0,
  CD: 0xFFD98F,
  IN: 0xA67573,
  SN: 0x668080,
  SB: 0x9E63B5,
  TE: 0xD47A00,
  I: 0x940094,
  XE: 0x429EB0,
  CS: 0x57178F,
  BA: 0x00C900,
  LA: 0x70D4FF,
  CE: 0xFFFFC7,
  PR: 0xD9FFC7,
  ND: 0xC7FFC7,
  PM: 0xA3FFC7,
  SM: 0x8FFFC7,
  EU: 0x61FFC7,
  GD: 0x45FFC7,
  TB: 0x30FFC7,
  DY: 0x1FFFC7,
  HO: 0x00FF9C,
  ER: 0x00E675,
  TM: 0x00D452,
  YB: 0x00BF38,
  LU: 0x00AB24,
  HF: 0x4DC2FF,
  TA: 0x4DA6FF,
  W: 0x2194D6,
  RE: 0x267DAB,
  OS: 0x266696,
  IR: 0x175487,
  PT: 0xD0D0E0,
  AU: 0xFFD123,
  HG: 0xB8B8D0,
  TL: 0xA6544D,
  PB: 0x575961,
  BI: 0x9E4FB5,
  PO: 0xAB5C00,
  AT: 0x754F45,
  RN: 0x428296,
  FR: 0x420066,
  RA: 0x007D00,
  AC: 0x70ABFA,
  TH: 0x00BAFF,
  PA: 0x00A1FF,
  U: 0x008FFF,
  NP: 0x0080FF,
  PU: 0x006BFF,
  AM: 0x545CF2,
  CM: 0x785CE3,
  BK: 0x8A4FE3,
  CF: 0xA136D4,
  ES: 0xB31FD4,
  FM: 0xB31FBA,
  MD: 0xB30DA6,
  NO: 0xBD0D87,
  LR: 0xC70066,
  RF: 0xCC0059,
  DB: 0xD1004F,
  SG: 0xD90045,
  BH: 0xE00038,
  HS: 0xE6002E,
  MT: 0xEB0026
  /* eslint-enable no-magic-numbers */
};
jmolPalette_palette.defaultResidueColor = 0xBEA06E;

// DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
jmolPalette_palette.residueColors = {
  /* eslint-disable no-magic-numbers */
  ALA: 0xC8C8C8,
  ARG: 0x145AFF,
  ASN: 0x00DCDC,
  ASP: 0xE60A0A,
  CYS: 0xE6E600,
  GLN: 0x00DCDC,
  GLU: 0xE60A0A,
  GLY: 0xEBEBEB,
  HIS: 0x8282D2,
  ILE: 0x0F820F,
  LEU: 0x0F820F,
  LYS: 0x145AFF,
  MET: 0xE6E600,
  PHE: 0x3232AA,
  PRO: 0xDC9682,
  SER: 0xFA9600,
  THR: 0xFA9600,
  TRP: 0xB45AB4,
  TYR: 0x3232AA,
  VAL: 0x0F820F,
  A: 0xA0A0FF,
  C: 0xFF8C4B,
  G: 0xFF7070,
  I: 0x80FFFF,
  T: 0xA0FFA0,
  U: 0xFF8080,
  DA: 0xA0A0FF,
  DC: 0xFF8C4B,
  DG: 0xFF7070,
  DI: 0x80FFFF,
  DT: 0xA0FFA0,
  DU: 0xFF8080,
  '+A': 0xA0A0FF,
  '+C': 0xFF8C4B,
  '+G': 0xFF7070,
  '+I': 0x80FFFF,
  '+T': 0xA0FFA0,
  '+U': 0xFF8080
  /* eslint-enable no-magic-numbers */
};
jmolPalette_palette.chainColors = [
// ' '->0 'A'->1, 'B'->2
0xFFffffff,
// ' ' & '0' white
//
0xFFC0D0FF,
// skyblue
0xFFB0FFB0,
// pastel green
0xFFFFC0C8,
// pink
0xFFFFFF80,
// pastel yellow
0xFFFFC0FF,
// pastel magenta
0xFFB0F0F0,
// pastel cyan
0xFFFFD070,
// pastel gold
0xFFF08080,
// lightcoral

0xFFF5DEB3,
// wheat
0xFF00BFFF,
// deepskyblue
0xFFCD5C5C,
// indianred
0xFF66CDAA,
// mediumaquamarine
0xFF9ACD32,
// yellowgreen
0xFFEE82EE,
// violet
0xFF00CED1,
// darkturquoise
0xFF00FF7F,
// springgreen
0xFF3CB371,
// mediumseagreen

0xFF00008B,
// darkblue
0xFFBDB76B,
// darkkhaki
0xFF006400,
// darkgreen
0xFF800000,
// maroon
0xFF808000,
// olive
0xFF800080,
// purple
0xFF008080,
// teal
0xFFB8860B,
// darkgoldenrod
0xFFB22222 // firebrick
];
const jmolPalette_StructuralElementType = chem_StructuralElement.Type;
jmolPalette_palette.secondaryColors = {
  [jmolPalette_StructuralElementType.HELIX_ALPHA]: 0xFF0080,
  [jmolPalette_StructuralElementType.HELIX_PI]: 0x600080,
  [jmolPalette_StructuralElementType.HELIX_310]: 0xA00080,
  [jmolPalette_StructuralElementType.STRAND]: 0xFFC800,
  [jmolPalette_StructuralElementType.TURN]: 0x6080FF,
  dna: 0xAE00FE,
  rna: 0xFD0162
};
/* harmony default export */ const jmolPalette = (jmolPalette_palette);
;// CONCATENATED MODULE: ./src/gfx/palettes/vmdPalette.js


const vmdPalette_palette = new palettes_Palette('VMD', 'VM');
vmdPalette_palette.colors = [/* eslint-disable no-magic-numbers */
0x0000FF,
// blue
0xFF0000,
// red
0x606060,
// gray
0xFF8000,
// orange
0xFFFF00,
// yellow
0x808033,
// tan
0x999999,
// silver
0x00FF00,
// green
0xFFFFFF,
// white
0xFF9999,
// pink
0x40C0C0,
// cyan
0xA600A6,
// purple
0x80E666,
// lime
0xE666B3,
// mauve
0x804D00,
// ochre
0x8080C0 // ice blue
/* eslint-enable no-magic-numbers */];
vmdPalette_palette.defaultElementColor = 0x804D00;

// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
vmdPalette_palette.elementColors = {
  /* eslint-disable no-magic-numbers */
  H: 0xFFFFFF,
  C: 0x40BFBF,
  N: 0x0000FF,
  O: 0xFF0000,
  P: 0x808033,
  S: 0xFFFF00
  /* eslint-enable no-magic-numbers */
};
vmdPalette_palette.defaultResidueColor = 0x40C0C0;

// DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
vmdPalette_palette.residueColors = {
  /* eslint-disable no-magic-numbers */
  ALA: 0x0000FF,
  ARG: 0xFFFFFF,
  ASN: 0x808033,
  ASP: 0xFF0000,
  CYS: 0xFFFF00,
  GLN: 0xFF8000,
  GLU: 0xFF9999,
  GLY: 0xFFFFFF,
  HIS: 0x40C0C0,
  ILE: 0x00FF00,
  LEU: 0xFF9999,
  LYS: 0x40C0C0,
  MET: 0xFFFF00,
  PHE: 0xA600A6,
  PRO: 0x804C00,
  SER: 0xFFFF00,
  THR: 0xE666B3,
  TRP: 0x999999,
  TYR: 0x00FF00,
  VAL: 0x808033,
  A: 0x0000FF,
  C: 0xFF8000,
  G: 0xFFFF00,
  T: 0xA600A6,
  U: 0x00FF00,
  DA: 0x0000FF,
  DC: 0xFF8000,
  DG: 0xFFFF00,
  DT: 0xA600A6,
  DU: 0x00FF00,
  '+A': 0x0000FF,
  '+C': 0xFF8000,
  '+G': 0xFFFF00,
  '+T': 0xA600A6,
  '+U': 0x00FF00,
  WAT: 0x40C0C0,
  H2O: 0x40C0C0,
  HOH: 0x40C0C0
  /* eslint-enable no-magic-numbers */
};
vmdPalette_palette.chainColors = [0xFFFFFF].concat(vmdPalette_palette.colors);
const vmdPalette_StructuralElementType = chem_StructuralElement.Type;
vmdPalette_palette.secondaryColors = {
  [vmdPalette_StructuralElementType.HELIX_ALPHA]: 0xA600A6,
  [vmdPalette_StructuralElementType.HELIX_310]: 0x0000FF,
  [vmdPalette_StructuralElementType.HELIX_PI]: 0xFF0000,
  [vmdPalette_StructuralElementType.STRAND]: 0xFFFF00,
  [vmdPalette_StructuralElementType.BRIDGE]: 0x808033,
  [vmdPalette_StructuralElementType.TURN]: 0x40C0C0
};
/* harmony default export */ const vmdPalette = (vmdPalette_palette);
;// CONCATENATED MODULE: ./src/gfx/palettes.js




const palettes = new utils_EntityList([cpkPalette, jmolPalette, vmdPalette]);
/* harmony default export */ const gfx_palettes = (palettes);
;// CONCATENATED MODULE: ./src/gfx/colorers/Colorer.js





/**
 * Create new colorer.
 *
 * @param {object=} opts - Options to override defaults with.
 *
 *   These options are copied locally and not kept by reference, so the created instance will not reflect further
 *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
 *
 * @exports Colorer
 * @this Colorer
 * @abstract
 * @constructor
 * @classdesc Basic class for all available coloring algorithms used for building and displaying molecule geometry.
 */
class Colorer {
  constructor(opts) {
    if (this.constructor === Colorer) {
      throw new Error('Can not instantiate abstract class!');
    }
    /**
     * Colorer options inherited (prototyped) from defaults.
     * @type {object}
     */
    this.opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(utils.deriveDeep(settings.now.colorers[this.id], true), opts);
    /**
     * Palette in use.
     * @type {Palette}
     */
    this.palette = gfx_palettes.first;
  }

  /**
   * Get Colorer identification, probably with options.
   * @returns {string|Array} Colorer identifier string ({@link Colorer#id}) or two-element array containing both colorer
   *   identifier and options ({@link Colorer#opts}).
   * Options are returned if they were changed during or after colorer creation.
   */
  identify() {
    const diff = utils.objectsDiff(this.opts, settings.now.colorers[this.id]);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      return [this.id, diff];
    }
    return this.id;
  }
}

/**
 * Colorer identifier.
 * @type {string}
 */

Colorer.prototype.id = '__';
/* harmony default export */ const colorers_Colorer = (Colorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/ElementColorer.js


/**
 * Create new colorer.
 *
 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
 *
 * @see Element
 *
 * @exports ElementColorer
 * @augments Colorer
 * @constructor
 * @classdesc Coloring algorithm based on chemical element.
 */
class ElementColorer extends colorers_Colorer {
  static id = 'EL';
  getAtomColor(atom, _complex) {
    const type = atom.element.name;
    if (type === 'C' && this.opts.carbon >= 0) {
      return this.opts.carbon;
    }
    return this.palette.getElementColor(type);
  }
  getResidueColor(_residue, _complex) {
    return this.palette.defaultResidueColor;
  }
}
ElementColorer.prototype.id = 'EL';
ElementColorer.prototype.name = 'Element';
ElementColorer.prototype.shortName = 'Element';
/* harmony default export */ const colorers_ElementColorer = (ElementColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/ResidueTypeColorer.js


/**
 * Coloring algorithm based on residue type.
 *
 * @see ResidueType
 *
 * @exports ResidueTypeColorer
 * @constructor
 */
class ResidueTypeColorer extends colorers_Colorer {
  static id = 'RT';
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    return this.palette.getResidueColor(residue._type._name);
  }
}
ResidueTypeColorer.prototype.id = 'RT';
ResidueTypeColorer.prototype.name = 'Residue Type';
ResidueTypeColorer.prototype.shortName = 'Residue';
/* harmony default export */ const colorers_ResidueTypeColorer = (ResidueTypeColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/SequenceColorer.js

class SequenceColorer extends colorers_Colorer {
  static id = 'SQ';
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    const chain = residue._chain;
    if (chain.minSequence === Number.POSITIVE_INFINITY && chain.maxSequence === Number.NEGATIVE_INFINITY) {
      return this.palette.defaultNamedColor;
    }
    const min = chain.minSequence;
    const max = chain.maxSequence > min ? chain.maxSequence : min + 1;
    return this.palette.getGradientColor((residue._sequence - min) / (max - min), this.opts.gradient);
  }
}
SequenceColorer.prototype.id = 'SQ';
SequenceColorer.prototype.name = 'Sequence';
SequenceColorer.prototype.shortName = 'Sequence';
/* harmony default export */ const colorers_SequenceColorer = (SequenceColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/ChainColorer.js

class ChainColorer extends colorers_Colorer {
  static id = 'CH';
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    return this.palette.getChainColor(residue.getChain()._name);
  }
}
ChainColorer.prototype.id = 'CH';
ChainColorer.prototype.name = 'Chain';
ChainColorer.prototype.shortName = 'Chain';
/* harmony default export */ const colorers_ChainColorer = (ChainColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/SecondaryStructureColorer.js


class SecondaryStructureColorer extends colorers_Colorer {
  static id = 'SS';
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    if (residue._type.flags & chem_ResidueType.Flags.DNA) {
      return this.palette.getSecondaryColor('dna');
    }
    if (residue._type.flags & chem_ResidueType.Flags.RNA) {
      return this.palette.getSecondaryColor('rna');
    }
    const secondary = residue.getSecondary();
    if (secondary) {
      let color = this.palette.getSecondaryColor(secondary.type, true);
      if (color === undefined) {
        color = this.palette.getSecondaryColor(secondary.generic);
      }
      return color;
    }
    return this.palette.defaultSecondaryColor;
  }
}
SecondaryStructureColorer.prototype.id = 'SS';
SecondaryStructureColorer.prototype.name = 'Secondary Structure';
SecondaryStructureColorer.prototype.shortName = 'Structure';
/* harmony default export */ const colorers_SecondaryStructureColorer = (SecondaryStructureColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/UniformColorer.js

class UniformColorer extends colorers_Colorer {
  static id = 'UN';
  getAtomColor(_atom, _complex) {
    return this.opts.color;
  }
  getResidueColor(_residue, _complex) {
    return this.opts.color;
  }
}
UniformColorer.prototype.id = 'UN';
UniformColorer.prototype.name = 'Uniform';
UniformColorer.prototype.shortName = 'Uniform';
/* harmony default export */ const colorers_UniformColorer = (UniformColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/ConditionalColorer.js



/**
 * Create new colorer.
 *
 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
 *
 * @exports ConditionalColorer
 * @augments Colorer
 * @constructor
 * @classdesc Bicolor coloring algorithm based on a selector string used as a condition.
 */
class ConditionalColorer extends colorers_Colorer {
  static id = 'CO';
  constructor(opts) {
    super(opts);
    const parsed = chem_selectors.parse(this.opts.subset);
    this._subsetCached = parsed.error ? chem_selectors.none() : parsed.selector;
  }
  getAtomColor(atom, _complex) {
    return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
  }
  getResidueColor(residue, _complex) {
    const subset = this._subsetCached;
    const atoms = residue._atoms;
    for (let i = 0, n = atoms.length; i < n; ++i) {
      if (!subset.includesAtom(atoms[i])) {
        return this.opts.baseColor;
      }
    }
    return this.opts.color;
  }
}
ConditionalColorer.prototype.id = 'CO';
ConditionalColorer.prototype.name = 'Conditional';
ConditionalColorer.prototype.shortName = 'Conditional';
/* harmony default export */ const colorers_ConditionalColorer = (ConditionalColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/ConformationColorer.js

class ConformationColorer extends colorers_Colorer {
  static id = 'CF';
  getAtomColor(atom, _complex) {
    return this.palette.getChainColor(String.fromCharCode(atom.location));
  }
  getResidueColor(_residue, _complex) {
    return this.palette.defaultResidueColor;
  }
}
ConformationColorer.prototype.id = 'CF';
ConformationColorer.prototype.name = 'Conformation';
ConformationColorer.prototype.shortName = 'Conformation';
/* harmony default export */ const colorers_ConformationColorer = (ConformationColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/TemperatureColorer.js


/**
 * Create new colorer.
 *
 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
 *
 * @see Temperature
 *
 * @exports TemperatureColorer
 * @augments Colorer
 * @constructor
 * @classdesc Coloring algorithm based on temperature of chemical element.
 */
class TemperatureColorer extends colorers_Colorer {
  static id = 'TM';
  getAtomColor(atom, _complex) {
    const {
      opts
    } = this;
    let factor = 1;
    if (atom.temperature && opts) {
      if (opts.min === opts.max) {
        factor = atom.temperature > opts.max ? 1 : 0;
      } else {
        factor = (atom.temperature - opts.min) / (opts.max - opts.min);
      }
      return this.palette.getGradientColor(factor, opts.gradient);
    }
    return this.palette.defaultGradientColor;
  }
  getResidueColor(residue, _complex) {
    const {
      opts
    } = this;
    if (!opts) {
      return this.palette.defaultGradientColor;
    }
    if (residue.temperature) {
      let factor = 0;
      if (opts.min === opts.max) {
        factor = residue.temperature > opts.max ? 1 : 0;
      } else {
        factor = (residue.temperature - opts.min) / (opts.max - opts.min);
      }
      return this.palette.getGradientColor(factor, opts.gradient);
    }
    return this.palette.defaultGradientColor;
  }
}
TemperatureColorer.prototype.id = 'TM'; // [T]e[M]perature
TemperatureColorer.prototype.name = 'Temperature';
TemperatureColorer.prototype.shortName = 'Temperature';
/* harmony default export */ const colorers_TemperatureColorer = (TemperatureColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/OccupancyColorer.js


/**
 * Create new colorer.
 *
 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
 *
 * @see Occupancy
 *
 * @exports OccupancyColorer
 * @augments Occupancy
 * @constructor
 * @classdesc Coloring algorithm based on occupancy of chemical element.
 */
class OccupancyColorer extends colorers_Colorer {
  static id = 'OC';
  _getColorByOccupancy(occupancy, opts) {
    if (occupancy !== undefined) {
      const factor = 1 - occupancy;
      return this.palette.getGradientColor(factor, opts.gradient);
    }
    return this.palette.defaultGradientColor;
  }
  getAtomColor(atom, _complex) {
    const {
      opts
    } = this;
    return this._getColorByOccupancy(atom.occupancy, opts);
  }
  getResidueColor(residue, _complex) {
    const {
      opts
    } = this;
    return this._getColorByOccupancy(residue.occupancy, opts);
  }
}
OccupancyColorer.prototype.id = 'OC'; // [OC]cupancy
OccupancyColorer.prototype.name = 'Occupancy';
OccupancyColorer.prototype.shortName = 'Occupancy';
/* harmony default export */ const colorers_OccupancyColorer = (OccupancyColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/HydrophobicityColorer.js

class HydrophobicityColorer extends colorers_Colorer {
  static id = 'HY';
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    let color = this.palette.defaultResidueColor;
    if (residue._type.hydrophobicity !== undefined) {
      // Kyte Doolitle hydro [-4.5,4.5]->[0.1]
      const min = -4.5;
      const max = 4.5;
      color = this.palette.getGradientColor((residue._type.hydrophobicity - min) / (max - min), this.opts.gradient);
    }
    return color;
  }
}
HydrophobicityColorer.prototype.id = 'HY';
HydrophobicityColorer.prototype.name = 'Hydrophobicity';
HydrophobicityColorer.prototype.shortName = 'Hydrophobicity';
/* harmony default export */ const colorers_HydrophobicityColorer = (HydrophobicityColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/MoleculeColorer.js

class MoleculeColorer extends colorers_Colorer {
  static id = 'MO';
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    const molecule = residue._molecule;
    const count = _complex.getMoleculeCount();
    if (count > 1) {
      return this.palette.getGradientColor((molecule.index - 1) / (count - 1), this.opts.gradient);
    }
    return this.palette.getGradientColor(0, this.opts.gradient);
  }
}
MoleculeColorer.prototype.id = 'MO';
MoleculeColorer.prototype.name = 'Molecule';
MoleculeColorer.prototype.shortName = 'Molecule';
/* harmony default export */ const colorers_MoleculeColorer = (MoleculeColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers/CarbonColorer.js


function scaleColor(c, factor) {
  const r1 = c >> 16 & 0xff;
  const g1 = c >> 8 & 0xff;
  const b1 = c & 0xff;
  const r = factor * r1;
  const g = factor * g1;
  const b = factor * b1;
  return r << 16 | g << 8 | b;
}

/**
 * Create new colorer.
 *
 * @param {object=} opts - Options to override defaults with. See {@link Colorer}.
 *
 * @exports CarbonColorer
 * @augments Colorer
 * @constructor
 * @classdesc Bicolor coloring algorithm based on selection carbon atoms.
 */
class CarbonColorer extends colorers_Colorer {
  static id = 'CB';
  getAtomColor(atom, _complex) {
    const colorCarbon = this.opts.color;
    const colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
    return atom.flags & chem_Atom.Flags.CARBON ? colorCarbon : colorNotCarbon;
  }
  getResidueColor(_residue, _complex) {
    return this.opts.color;
  }
}
CarbonColorer.prototype.id = 'CB';
CarbonColorer.prototype.name = 'Carbon';
CarbonColorer.prototype.shortName = 'Carbon';
/* harmony default export */ const colorers_CarbonColorer = (CarbonColorer);
;// CONCATENATED MODULE: ./src/gfx/colorers.js














const colorers = new utils_EntityList([colorers_ElementColorer, colorers_ResidueTypeColorer, colorers_SequenceColorer, colorers_ChainColorer, colorers_SecondaryStructureColorer, colorers_UniformColorer, colorers_ConditionalColorer, colorers_ConformationColorer, colorers_TemperatureColorer, colorers_OccupancyColorer, colorers_HydrophobicityColorer, colorers_MoleculeColorer, colorers_CarbonColorer]);
/* harmony default export */ const gfx_colorers = (colorers);
;// CONCATENATED MODULE: ./src/gfx/materials.js


function neutralColor(intensity) {
  return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(intensity, intensity, intensity);
}
const materialList = [{
  id: 'DF',
  name: 'Diffuse',
  shortName: 'Diffuse',
  uberOptions: {
    diffuse: neutralColor(1.0),
    specular: neutralColor(0.0),
    shininess: 1,
    opacity: 1.0
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: 'SF',
  name: 'Soft Plastic',
  shortName: 'Soft',
  uberOptions: {
    diffuse: neutralColor(1.0),
    specular: neutralColor(0.1),
    shininess: 30,
    opacity: 1.0
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: 'PL',
  name: 'Glossy Plastic',
  shortName: 'Glossy',
  uberOptions: {
    diffuse: neutralColor(0.56),
    specular: neutralColor(0.28),
    shininess: 100,
    opacity: 1.0
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: 'ME',
  name: 'Metal',
  shortName: 'Metal',
  uberOptions: {
    diffuse: neutralColor(0.56),
    specular: neutralColor(0.55),
    shininess: 30,
    opacity: 1.0
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: 'TR',
  name: 'Transparent',
  shortName: 'Transparent',
  uberOptions: {
    diffuse: neutralColor(1.0),
    specular: neutralColor(0.0),
    shininess: 1,
    opacity: 0.5
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: true,
    toonShading: false
  }
}, {
  id: 'GL',
  name: 'Glass',
  shortName: 'Glass',
  uberOptions: {
    diffuse: neutralColor(0.50),
    specular: neutralColor(0.65),
    shininess: 100,
    opacity: 0.5
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: true,
    toonShading: false
  }
}, {
  id: 'BA',
  name: 'Backdrop',
  shortName: 'Backdrop',
  uberOptions: {
    diffuse: neutralColor(1.0),
    specular: neutralColor(0.0),
    shininess: 1,
    opacity: 1.0
  },
  values: {
    lights: false,
    fog: false,
    depthWrite: false,
    transparent: false,
    toonShading: false
  }
}, {
  id: 'TN',
  name: 'Toon',
  shortName: 'Toon',
  uberOptions: {
    diffuse: neutralColor(1.0),
    specular: neutralColor(0.0),
    shininess: 1,
    opacity: 1.0
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: true
  }
}, {
  id: 'FL',
  name: 'Flat',
  shortName: 'Flat',
  uberOptions: {
    diffuse: neutralColor(1.0),
    specular: neutralColor(0.0),
    shininess: 0,
    opacity: 1.0
  },
  values: {
    lights: false,
    fog: true,
    depthWrite: true,
    transparent: false
  }
}];
const materials = new utils_EntityList(materialList);
/* harmony default export */ const gfx_materials = (materials);
;// CONCATENATED MODULE: ./src/gfx/meshutils.js
/**
 * Utils functions which is worked with meshes
 *
 * functions for doing something with all/specified meshes
 * functions for traversihg tree and create auxiliary meshes for transparency/shadowmaps...
 * functions for calculating data connected with meshes
 */



function _gatherObjects(root, meshTypes) {
  const meshes = [];
  root.traverse(object => {
    for (let i = 0; i < meshTypes.length; i++) {
      if (object instanceof meshTypes[i]) {
        meshes[meshes.length] = object;
        break;
      }
    }
  });
  return meshes;
}

// new mesh with the same geometry and specified material values and layer
function createDerivativeMesh(mesh, values, layer) {
  const material = mesh.material.createInstance();
  material.setValues(values);
  const newMesh = new mesh.constructor(mesh.geometry, material);
  newMesh.material.needsUpdate = true;
  newMesh.applyMatrix4(mesh.matrix);
  newMesh.layers.set(layer);
  return newMesh;
}
function traverseMeshes(root, meshTypes, func) {
  const meshes = _gatherObjects(root, meshTypes);
  for (let i = 0, n = meshes.length; i < n; ++i) {
    const mesh = meshes[i];
    if (!mesh.parent) {
      continue;
    }
    func(mesh);
  }
}
function applyTransformsToMeshes(root, mtc) {
  const mtcCount = mtc.length;
  if (mtcCount < 1) {
    return;
  }
  const meshTypes = [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line];
  traverseMeshes(root, meshTypes, mesh => {
    mesh.applyMatrix4(mtc[0]);
    for (let j = 1; j < mtcCount; ++j) {
      const newMesh = new mesh.constructor(mesh.geometry, mesh.material);
      mesh.parent.add(newMesh);
      newMesh.applyMatrix4(mtc[j]);
    }
  });
}
const processTransparentMaterial = function () {
  const matValues = {
    prepassTransparancy: true,
    fakeOpacity: false,
    transparent: false,
    colorFromDepth: false,
    lights: false,
    shadowmap: false,
    fog: false
  };
  return function (root, material) {
    if (!(material instanceof shaders_UberMaterial)) {
      return;
    }
    traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], mesh => {
      mesh.material.setValues({
        prepassTransparancy: false,
        fakeOpacity: false
      });
      mesh.material.needsUpdate = true;
      mesh.layers.set(gfxutils.LAYERS.TRANSPARENT);
      const prepassTranspMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.PREPASS_TRANSPARENT);
      mesh.parent.add(prepassTranspMesh);
    });
  };
}();
const processColFromPosMaterial = function () {
  const matValues = {
    colorFromPos: true,
    transparent: false,
    colorFromDepth: false,
    lights: false,
    shadowmap: false,
    fog: false,
    overrideColor: false,
    fogTransparent: false,
    attrColor: false,
    attrColor2: false,
    attrAlphaColor: false,
    fakeOpacity: false
  };
  return function (root, material) {
    if (!(material instanceof shaders_UberMaterial)) {
      return;
    }
    traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], mesh => {
      const colFromPosMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.COLOR_FROM_POSITION);
      mesh.parent.add(colFromPosMesh);
    });
  };
}();
const createShadowmapMaterial = function () {
  const matValues = {
    colorFromDepth: true,
    orthoCam: true,
    lights: false,
    shadowmap: false,
    fog: false
  };
  return function (root, material) {
    if (!(material instanceof shaders_UberMaterial)) {
      return;
    }
    traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], mesh => {
      if (!mesh.receiveShadow && mesh.material.shadowmap) {
        // remove shadow from non-receivers
        mesh.material.setValues({
          shadowmap: false
        });
      }
      if (!mesh.material.lights) {
        // skip creating shadowmap meshes for materials without lighting
        return;
      }
      if (!mesh.castShadow) {
        // skip creating shadowmap meshes for non-casters
        return;
      }
      if (!gfxutils.belongToSelectLayers(mesh)) {
        // skip creating shadowmap meshes for selection layer
        return;
      }
      const shadowmapMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.SHADOWMAP);
      shadowmapMesh.isShadowmapMesh = true;
      mesh.parent.add(shadowmapMesh);
    });
  };
}();
function removeShadowmapMaterial(root, material) {
  if (!(material instanceof shaders_UberMaterial)) {
    return;
  }
  traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], mesh => {
    if (mesh.isShadowmapMesh) {
      mesh.parent.remove(mesh);
    }
  });
}
function forEachMeshInGroup(group, process) {
  function processObj(object) {
    if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh) {
      process(object);
    }
    for (let i = 0, l = object.children.length; i < l; i++) {
      processObj(object.children[i]);
    }
  }
  processObj(group);
}
function _countMeshTriangles(mesh) {
  const geom = mesh.geometry;
  if (geom instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry) {
    const attribs = geom.attributes;
    for (const property in attribs) {
      if (attribs.hasOwnProperty(property) && attribs[property] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute) {
        const currAttr = attribs[property];
        const indexSize = geom.index ? geom.index.array.length / 3 : 0;
        return indexSize * currAttr.array.length / currAttr.itemSize;
      }
    }
    return 0;
  }
  if (geom instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry) {
    return geom.index ? geom.index.array.length / 3 : 0;
  }
  return geom.faces ? geom.faces.length : 0;
}
function countTriangles(group) {
  let totalCount = 0;
  forEachMeshInGroup(group, mesh => {
    totalCount += _countMeshTriangles(mesh);
  });
  return totalCount;
}
/* harmony default export */ const meshutils = ({
  applyTransformsToMeshes,
  processTransparentMaterial,
  processColFromPosMaterial,
  createShadowmapMaterial,
  removeShadowmapMaterial,
  forEachMeshInGroup,
  countTriangles
});
;// CONCATENATED MODULE: ./src/gfx/Representation.js








const {
  selectors: Representation_selectors
} = chem;
class Representation {
  constructor(index, mode, colorer, selector) {
    const startMaterialValues = {
      clipPlane: settings.now.draft.clipPlane,
      fogTransparent: settings.now.bg.transparent,
      shadowmap: settings.now.shadow.on,
      shadowmapType: settings.now.shadow.type
    };
    this.index = index;
    this.mode = mode;
    this.colorer = colorer;
    this.selector = selector;
    this.selectorString = '';
    this.count = 0;
    this.material = new shaders_UberMaterial();
    this.material.setValues(startMaterialValues);
    this.material.setUberOptions({
      fogAlpha: settings.now.fogAlpha
    });
    this.materialPreset = gfx_materials.first;
    this.needsRebuild = true;
    this.visible = true;

    // apply mode params & preset
    this.setMode(mode);
  }
  markAtoms(complex) {
    this.count = complex.markAtoms(this.selector, 1 << this.index);
    this.needsRebuild = true;
    return this.count;
  }
  unmarkAtoms(complex) {
    complex.clearAtomBits(1 << this.index);
    this.count = 0;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setMaterialPreset(preset) {
    this.materialPreset = preset;
    this.material.setUberOptions(preset.uberOptions);
    this.material.setValues(preset.values);
  }
  reset() {
    this.geo = null;
    this.selectionGeo = null;
  }
  buildGeometry(complex) {
    this.reset();
    this.needsRebuild = false;
    if (settings.now.ao) {
      this.material.setValues({
        normalsToGBuffer: settings.now.ao
      });
    }
    this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);
    if (this.material.uberOptions.opacity < 0.99 && settings.now.transparency === 'prepass') {
      meshutils.processTransparentMaterial(this.geo, this.material);
    }
    this.geo.visible = this.visible;
    gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id);
    meshutils.processColFromPosMaterial(this.geo, this.material);
    if (settings.now.shadow.on) {
      meshutils.createShadowmapMaterial(this.geo, this.material);
    }
    return this.geo;
  }
  buildSelectionGeometry(mask) {
    let sg = null;
    if (this.geo && 'getSubset' in this.geo) {
      const meshes = this.geo.getSubset(mask);
      if (meshes && meshes.length > 0) {
        sg = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
        sg.matrixAutoUpdate = false;
        sg.matrix = this.geo.matrix;
        for (let j = 0; j < meshes.length; j++) {
          const m = meshes[j];
          sg.add(m);
        }
      }
    }
    if (sg) {
      sg.visible = this.visible;
    }
    this.selectionGeo = sg;
    return this.selectionGeo;
  }

  /**
   * Create object that represents difference between current and another rep
   * anotherRep could be undefined. In this case everything is reported.
   */
  compare(repSettings) {
    const diff = {};
    const selStr = String(this.selector);
    if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
      diff.selector = selStr;
    }
    const modeDiff = this.mode.identify();
    if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
      diff.mode = modeDiff;
    }
    const colorerDiff = this.colorer.identify();
    if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
      diff.colorer = colorerDiff;
    }
    if (!repSettings || this.materialPreset.id !== repSettings.material) {
      diff.material = this.materialPreset.id;
    }
    return diff;
  }

  /**
   * Change representation. Write fields what was changed into new object, return it.
   */
  change(repSettings, complex, mode, color) {
    const diff = {};

    // modify selector
    if (repSettings.selector) {
      const newSelectorObject = Representation_selectors.parse(repSettings.selector).selector;
      const newSelector = String(newSelectorObject);
      if (this.selectorString !== newSelector) {
        diff.selector = newSelector;
        this.selectorString = newSelector;
        this.selector = newSelectorObject;
        this.markAtoms(complex);
      }
    }

    // modify mode
    if (repSettings.mode) {
      const newMode = repSettings.mode;
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(this.mode.identify(), newMode)) {
        diff.mode = newMode;
        this.setMode(mode);
      }
    }

    // modify colorer
    if (repSettings.colorer) {
      const newColorer = repSettings.colorer;
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(this.colorer.identify(), newColorer)) {
        diff.colorer = newColorer;
        this.colorer = color;
      }
    }

    // modify material
    if (repSettings.material) {
      const newMaterial = repSettings.material;
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(this.materialPreset.id, newMaterial)) {
        diff.material = newMaterial;
        this.setMaterialPreset(gfx_materials.get(repSettings.material));
      }
    }
    return diff;
  }
  show(visible) {
    this.visible = visible;
    if (this.geo) {
      this.geo.visible = visible;
    }
    if (this.selectionGeo) {
      this.selectionGeo.visible = visible;
    }
  }
}
/* harmony default export */ const gfx_Representation = (Representation);
;// CONCATENATED MODULE: ./src/ComplexVisualEdit.js




function _traverseComponentGroups(root, component, callback) {
  const {
    children
  } = root;
  if (!children) {
    return;
  }
  for (let i = 0, n = children.length; i < n; ++i) {
    const child = children[i];
    if (child._component === component) {
      callback(child);
    }
    if (child instanceof gfxutils.RCGroup) {
      _traverseComponentGroups(child, component, callback);
    }
  }
}
function ComplexEditor() {}
class ComplexComponentEditor extends ComplexEditor {
  constructor(complexVisual) {
    super();
    this._complexVisual = complexVisual;
    this._inProgress = false;
  }
  begin() {
    const complex = this._complexVisual.getComplex();

    // init component matrices
    this._componentTransforms = [];
    for (let i = 0; i < complex._components.length; ++i) {
      const component = complex._components[i];
      this._componentTransforms[component._index] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D();
    }
    this._inProgress = true;
    return true;
  }
  apply() {
    if (!this._inProgress) {
      return;
    }
    const complex = this._complexVisual.getComplex();
    for (let i = 0; i < complex._components.length; ++i) {
      this._bakeComponentTransform(complex._components[i]);
    }
    complex.onAtomPositionChanged();
    this._resetComponentTransform();
    this._complexVisual.finalizeEdit();
  }
  discard() {
    if (!this._inProgress) {
      return;
    }
    this._resetComponentTransform();
    this._complexVisual.finalizeEdit();
  }
  getAltObj() {
    const res = {
      objects: [],
      pivot: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    };
    const visual = this._complexVisual;
    const component = visual.getSelectedComponent();
    if (component === null) {
      return res;
    }
    const selection = this._complexVisual.getSelectionGeo();
    const selectionMask = 1 << visual.getSelectionBit();
    let i;
    let j;
    let reprNode;
    let geo;

    // find all geo nodes for this component
    _traverseComponentGroups(visual, component, child => {
      res.objects.push(child);
    });

    // find all selection nodes for this component
    for (i = 0; i < selection.children.length; ++i) {
      reprNode = selection.children[i];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty('_component') && geo._component === component) {
          res.objects.push(geo);
        }
      }
    }

    // add dummy object that stores component transformation
    res.objects.push(this._componentTransforms[component._index]);
    const bbmin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const bbmax = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    component.forEachResidue(residue => {
      const atoms = residue._atoms;
      for (j = 0; j < atoms.length; ++j) {
        if (atoms[j].mask & selectionMask) {
          bbmin.min(atoms[j].position);
          bbmax.max(atoms[j].position);
        }
      }
    });
    res.pivot.lerpVectors(bbmin, bbmax, 0.5);
    return res;
  }
  _bakeComponentTransform(component) {
    const t = this._componentTransforms[component._index];
    if (t && (!(t.position.x === 0 && t.position.y === 0 && t.position.z === 0) || !(t.quaternion.x === 0 && t.quaternion.y === 0 && t.quaternion.z === 0 && t.quaternion.w === 1))) {
      t.updateMatrix();
      component.forEachResidue(residue => {
        const atoms = residue._atoms;
        for (let j = 0; j < atoms.length; ++j) {
          atoms[j].position.applyMatrix4(t.matrix);
        }
      });
    }
  }
  _resetComponentTransform() {
    const visual = this._complexVisual;
    const selection = this._complexVisual.getSelectionGeo();
    let i;
    let j;
    let reprNode;
    let geo;
    for (i = 0; i < this._componentTransforms.length; ++i) {
      geo = this._componentTransforms[i];
      geo.position.set(0, 0, 0);
      geo.quaternion.set(0, 0, 0, 1);
    }

    // reset all geo nodes
    for (i = 0; i < visual.children.length; ++i) {
      reprNode = visual.children[i];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty('_component')) {
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }
      }
    }

    // reset all selection nodes
    for (i = 0; i < selection.children.length; ++i) {
      reprNode = selection.children[i];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty('_component')) {
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }
      }
    }
  }
}
class ComplexFragmentEditor extends ComplexEditor {
  constructor(complexVisual) {
    super();
    this._complexVisual = complexVisual;
    this._inProgress = false;
  }
  begin() {
    const visual = this._complexVisual;
    const selection = this._complexVisual.getSelectionGeo();
    const atoms = this._getSelectionBorderAtoms();
    if (atoms.length < 1 || atoms.length > 2) {
      logger.error('Can only edit fragments with one or two bound atoms.');
      return false;
    }
    this._fragmentBoundAtoms = atoms;
    const selectionMask = 1 << visual.getSelectionBit();

    // hide selected fragment in main model
    visual.disableSubset(selectionMask, true);

    // hide selection geo in main model
    for (let k = 0; k < selection.children.length; ++k) {
      selection.children[k].visible = false;
    }

    // create visible fragment representation to rotate
    const pivotPos = atoms[0].position.clone();
    if (atoms.length === 2) {
      pivotPos.lerp(atoms[1].position, 0.5);
    }
    this._fragmentGeo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
    visual.add(this._fragmentGeo);
    this._fragmentGeo.position.copy(pivotPos);
    this._fragmentSelectionGeo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
    selection.add(this._fragmentSelectionGeo);
    this._fragmentSelectionGeo.position.copy(pivotPos);
    const offset = pivotPos.clone();
    offset.negate();
    for (let i = 0; i < visual.children.length; ++i) {
      const g = visual.children[i];
      if (!('getSubset' in g)) {
        continue;
      }
      const vg = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
      this._fragmentGeo.add(vg);
      const sg = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
      this._fragmentSelectionGeo.add(sg);
      const meshes = g.getSubset(selectionMask, true);
      for (let j = 0; j < meshes.length; j++) {
        const m = meshes[j];
        vg.add(m);
        m.position.copy(offset);
      }
      const smeshes = g.getSubset(selectionMask, true);
      for (let h = 0; h < smeshes.length; h++) {
        const sm = smeshes[h];
        sg.add(sm);
        sm.position.copy(offset);
      }
    }
    gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);
    this._inProgress = true;
    return true;
  }
  apply() {
    if (!this._inProgress) {
      return;
    }
    const visual = this._complexVisual;
    const selectionBit = visual.getSelectionBit();
    const p = this._fragmentGeo.position;
    const m = this._fragmentGeo.matrix.clone();
    m.multiply(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().makeTranslation(-p.x, -p.y, -p.z));
    this._bakeAtomTransform(m, 1 << selectionBit);

    // show selected fragment in main model
    visual.enableSubset(1 << selectionBit, true);
    visual.getComplex().onAtomPositionChanged();
    visual.finalizeEdit();
  }
  discard() {
    if (!this._inProgress) {
      return;
    }
    const visual = this._complexVisual;
    const selection = this._complexVisual.getSelectionGeo();
    this._fragmentGeo.parent.remove(this._fragmentGeo);

    // show selected fragment in main model
    visual.enableSubset(1 << visual.getSelectionBit(), true);

    // show selection geo in main model (+ remove fragment selection geo)
    for (let i = 0; i < selection.children.length; ++i) {
      const node = selection.children[i];
      if (node.visible) {
        selection.remove(node);
      } else {
        node.visible = true;
      }
    }
    visual.finalizeEdit();
  }
  isFreeRotationAllowed() {
    return this._fragmentBoundAtoms.length < 2;
  }
  getAltObj() {
    const res = {
      objects: [],
      pivot: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    };
    res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
    const boundAtoms = this._fragmentBoundAtoms;
    if (boundAtoms.length === 1) {
      if (boundAtoms[0].bonds.length === 1) {
        // single external bond allows rotation about bond axis
        const bond = boundAtoms[0].bonds[0];
        res.axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3().subVectors(bond._right.position, bond._left.position);
        res.axis.normalize();
        res.axis.transformDirection(this._complexVisual.matrixWorld);
      }
    } else if (boundAtoms.length === 2) {
      // two bound atoms allow rotation only about axis running through their centers
      res.axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3().subVectors(boundAtoms[1].position, boundAtoms[0].position);
      res.axis.normalize();
      res.axis.transformDirection(this._complexVisual.matrixWorld);
    }
    return res;
  }
  _getSelectionBorderAtoms() {
    const complex = this._complexVisual.getComplex();
    const selectionMask = 1 << this._complexVisual.getSelectionBit();
    const atomHash = {};
    complex.forEachBond(bond => {
      if (bond._left.mask & selectionMask) {
        if ((bond._right.mask & selectionMask) === 0) {
          atomHash[bond._left.index] = 1;
        }
      } else if (bond._right.mask & selectionMask) {
        atomHash[bond._right.index] = 1;
      }
    });
    const atoms = [];
    const keys = Object.keys(atomHash);
    for (let i = 0, n = keys.length; i < n; ++i) {
      const idx = keys[i];
      atoms.push(complex._atoms[idx]);
    }
    return atoms;
  }
  _bakeAtomTransform(matrix, mask) {
    this._complexVisual.getComplex().forEachAtom(atom => {
      if (atom.mask & mask) {
        atom.position.applyMatrix4(matrix);
      }
    });
  }
}
/* harmony default export */ const ComplexVisualEdit = ({
  ComponentEditor: ComplexComponentEditor,
  FragmentEditor: ComplexFragmentEditor
});
;// CONCATENATED MODULE: ./src/ComplexVisual.js















const {
  selectors: ComplexVisual_selectors
} = chem;
function lookupAndCreate(entityList, specs) {
  if (!Array.isArray(specs)) {
    specs = [specs];
  }
  const [id, opts] = specs;
  const Entity = entityList.get(id) || entityList.first;
  return new Entity(opts);
}
class ComplexVisual extends src_Visual {
  constructor(name, dataSource) {
    super(name, dataSource);
    this._complex = dataSource;

    /** @type {Representation[]} */
    this._reprList = [];
    /** @type {?Representation} */
    this._repr = null;
    this._reprListChanged = true;
    this._selectionBit = 0;
    this._reprUsedBits = 0;
    this._selectionCount = 0;
    this._selectionGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
  }
  getBoundaries() {
    return this._complex.getBoundaries();
  }
  release() {
    if (this._selectionGeometry.parent) {
      this._selectionGeometry.remove(this._selectionGeometry);
    }
    src_Visual.prototype.release.call(this);
  }
  getComplex() {
    return this._complex;
  }
  getSelectionCount() {
    return this._selectionCount;
  }
  getSelectionGeo() {
    return this._selectionGeometry;
  }
  getSelectionBit() {
    return this._selectionBit;
  }
  getEditor() {
    return this._editor;
  }
  resetReps(reps) {
    // Create all necessary representations
    if (this._complex) {
      this._complex.clearAtomBits(~0);
    }
    this._reprListChanged = true;
    this._reprUsedBits = 0;
    this._reprList.length = reps.length;
    for (let i = 0, n = reps.length; i < n; ++i) {
      const rep = reps[i];
      let selector;
      let selectorString;
      if (typeof rep.selector === 'string') {
        selectorString = rep.selector;
        ({
          selector
        } = ComplexVisual_selectors.parse(selectorString));
      } else if (typeof rep.selector === 'undefined') {
        selectorString = settings.now.presets.default[0].selector;
        ({
          selector
        } = ComplexVisual_selectors.parse(selectorString));
      } else {
        ({
          selector
        } = rep);
        selectorString = selector.toString();
      }
      const mode = lookupAndCreate(gfx_modes, rep.mode);
      const colorer = lookupAndCreate(gfx_colorers, rep.colorer);
      const material = gfx_materials.get(rep.material) || gfx_materials.first;
      this._reprList[i] = new gfx_Representation(i, mode, colorer, selector);
      this._reprList[i].setMaterialPreset(material);
      this._reprList[i].selectorString = selectorString;
      if (this._complex) {
        this._complex.markAtoms(selector, 1 << i);
      }
      this._reprUsedBits |= 1 << i;
    }
    this._repr = reps.length > 0 ? this._reprList[0] : null;
    this._selectionBit = reps.length;
    this._reprUsedBits |= 1 << this._selectionBit; // selection uses one bit
    this._selectionCount = 0;
    if (this._complex) {
      this._complex.update();
    }
  }

  /**
   * Get number of representations created so far.
   * @returns {number} Number of reps.
   */
  repCount() {
    return this._reprList.length;
  }

  /**
   * Get or set the current representation index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @returns {number} The current index.
   */
  repCurrent(index) {
    if (index >= 0 && index < this._reprList.length) {
      this._repr = this._reprList[index];
    } else {
      index = this._reprList.indexOf(this._repr);
    }
    return index;
  }

  /**
   * Get or set representation by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @param {object=} rep - Optional representation description.
   * @param {string=} rep.selector - Selector string.
   * @param {string=} rep.mode - Mode id.
   * @param {string=} rep.colorer - Colorer id.
   * @param {string=} rep.material - Material id.
   * @returns {Object} {desc, index, status} field desc contains rep description, index - index of correspondent rep,
   * status - one of three strings: 'created', 'changed', ''. 'created' means new rep was created during this function,
   * 'changed' - rep was changed during this function. '' - something else.
   */
  rep(index, rep) {
    // if index is missing then it is the current
    if (!rep && (index === undefined || index instanceof Object)) {
      rep = index;
      index = this.repCurrent();
    }

    // fail if out of bounds
    if (index < 0 || index > this._reprList.length) {
      logger.error(`Rep ${index} does not exist!`);
      return null;
    }

    // a special case of adding just after the end
    if (index === this._reprList.length) {
      const res = this.repAdd(rep);
      logger.warn(`Rep ${index} does not exist! New representation was created.`);
      return {
        desc: res.desc,
        index,
        status: 'created'
      };
    }

    // gather description
    const target = this._reprList[index];
    const desc = {
      selector: target.selectorString,
      mode: target.mode.identify(),
      colorer: target.colorer.identify(),
      material: target.materialPreset.id
    };

    // modification is requested
    if (rep) {
      // modify
      const diff = target.change(rep, this._complex, lookupAndCreate(gfx_modes, rep.mode), lookupAndCreate(gfx_colorers, rep.colorer));

      // something was changed
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
        target.needsRebuild = true;
        for (const key in diff) {
          if (diff.hasOwnProperty(key)) {
            desc[key] = diff[key];
            logger.debug(`rep[${index}].${key} changed to ${diff[key]}`);
          }
        }

        // safety trick: lower resolution for surface modes
        if (diff.mode && target.mode.isSurface && (settings.now.resolution === 'ultra' || settings.now.resolution === 'high')) {
          logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
          settings.set('resolution', 'medium');
        }
        return {
          desc,
          index,
          status: 'changed'
        };
      }
    }
    return {
      desc,
      index,
      status: ''
    };
  }

  /**
   * Get representation (not just description) by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @returns {?object} Representation.
   */
  repGet(index) {
    // if index is missing then it is the current
    if (index === undefined || index instanceof Object) {
      index = this.repCurrent();
    }

    // fail if out of bounds
    if (index < 0 || index >= this._reprList.length) {
      return null;
    }
    return this._reprList[index];
  }
  _getFreeReprIdx() {
    let bits = this._reprUsedBits;
    for (let i = 0; i <= ComplexVisual.NUM_REPRESENTATION_BITS; ++i, bits >>= 1) {
      if ((bits & 1) === 0) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Add new representation.
   * @param {object=} rep - Representation description.
   * @returns {Object} {desc, index} field desc contains added rep description, index - index of this rep.
   */
  repAdd(rep) {
    if (this._reprList.length >= ComplexVisual.NUM_REPRESENTATION_BITS) {
      return null;
    }
    const newSelectionBit = this._getFreeReprIdx();
    if (newSelectionBit < 0) {
      return null; // no more slots for representations
    }
    const originalSelection = this.buildSelectorFromMask(1 << this._selectionBit);

    // Fill in default values
    const def = settings.now.presets.default[0];
    const desc = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({
      selector: def.selector,
      mode: def.mode,
      colorer: def.colorer,
      material: def.material
    }, rep);
    const selector = typeof desc.selector === 'string' ? ComplexVisual_selectors.parse(desc.selector).selector : desc.selector;
    const target = new gfx_Representation(this._selectionBit, lookupAndCreate(gfx_modes, desc.mode), lookupAndCreate(gfx_colorers, desc.colorer), selector);
    target.selectorString = selector.toString();
    target.setMaterialPreset(gfx_materials.get(desc.material));
    target.markAtoms(this._complex);
    this._reprList.push(target);

    // change selection bit
    this._selectionBit = newSelectionBit;
    this._reprUsedBits |= 1 << this._selectionBit;

    // restore selection using new selection bit
    this._complex.markAtoms(originalSelection, 1 << this._selectionBit);
    return {
      desc,
      index: this._reprList.length - 1
    };
  }

  /**
   * Remove representation.
   * @param {number=} index - Zero-based representation index.
   */
  repRemove(index) {
    if (index === undefined) {
      index = this.repCurrent();
    }

    // catch out of bounds case
    let count = this._reprList.length;
    if (index < 0 || index >= count || count <= 1) {
      // do not allow to remove the single rep
      return;
    }
    const target = this._reprList[index];
    target.unmarkAtoms(this._complex);
    this._reprUsedBits &= ~(1 << target.index);
    this._reprList.splice(index, 1);

    // update current rep
    if (target === this._repr) {
      --count;
      index = index < count ? index : count - 1;
      this._repr = this._reprList[index];
    }
    this._reprListChanged = true;
  }

  /**
   * Hide representation.
   * @param {number} index - Zero-based representation index.
   * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
   */
  repHide(index, hide) {
    if (hide === undefined) {
      hide = true;
    }

    // fail if out of bounds
    if (index < 0 || index >= this._reprList.length) {
      return;
    }
    const target = this._reprList[index];
    target.show(!hide);
  }

  /**
   * Select atoms with selector
   * @param {Selector} selector - selector
   * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
   */
  select(selector, append) {
    if (append) {
      this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
    } else {
      this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
    }
    this._complex.updateStructuresMask();
    this.rebuildSelectionGeometry();
  }
  resetSelectionMask() {
    if (this._selectionCount !== 0) {
      this._selectionCount = 0;
      if (this._complex) {
        this._complex.clearAtomBits(1 << this._selectionBit);
      }
    }
  }
  updateSelectionMask(pickedObj) {
    const self = this;
    const {
      atom
    } = pickedObj;
    let {
      residue,
      chain,
      molecule
    } = pickedObj;
    const setMask = 1 << this._selectionBit;
    const clearMask = ~setMask;
    if (atom) {
      residue = atom.residue;
      chain = residue._chain;
      molecule = residue._molecule;
      if (atom.mask & setMask) {
        atom.mask &= clearMask;
        residue._mask &= clearMask;
        chain._mask &= clearMask;
        if (molecule) {
          molecule.mask &= clearMask;
        }
        this._selectionCount--;
      } else {
        atom.mask |= setMask;
        this._selectionCount++;

        // select residue if all atoms in it are selected
        residue.collectMask();
        // select chain and molecule if all residues in it are selected
        chain.collectMask();
        if (molecule) {
          molecule.collectMask();
        }
      }
    } else if (residue) {
      chain = residue._chain;
      molecule = residue._molecule;
      if (residue._mask & setMask) {
        residue._mask &= clearMask;
        chain._mask &= clearMask;
        residue.forEachAtom(a => {
          if (a.mask & setMask) {
            a.mask &= clearMask;
            self._selectionCount--;
          }
        });
      } else {
        residue._mask |= setMask;
        residue.forEachAtom(a => {
          if (!(a.mask & setMask)) {
            a.mask |= setMask;
            self._selectionCount++;
          }
        });

        // select chain and molecule if all residues in it are selected
        chain.collectMask();
        if (molecule) {
          molecule.collectMask();
        }
      }
    } else if (chain || molecule) {
      const obj = chain || molecule;
      if (obj._mask & setMask) {
        obj._mask &= clearMask;
        obj.forEachResidue(r => {
          if (r._mask & setMask) {
            r._mask &= clearMask;
            r.forEachAtom(a => {
              if (a.mask & setMask) {
                a.mask &= clearMask;
                self._selectionCount--;
              }
            });
            r._mask &= clearMask;
          }
        });
      } else {
        obj._mask |= setMask;
        obj.forEachResidue(r => {
          if (!(r._mask & setMask)) {
            r._mask |= setMask;
            r.forEachAtom(a => {
              if (!(a.mask & setMask)) {
                a.mask |= setMask;
                self._selectionCount++;
              }
            });
            const otherObj = chain ? r.getMolecule() : r.getChain();
            if (otherObj) {
              otherObj.collectMask();
            }
          }
        });
      }
    } else {
      this.resetSelectionMask();
    }
  }
  expandSelection() {
    const self = this;
    const selectionMask = 1 << this._selectionBit;
    const tmpMask = 1 << 31;

    // mark atoms to add
    this._complex.forEachBond(bond => {
      if (bond._left.mask & selectionMask) {
        if ((bond._right.mask & selectionMask) === 0) {
          bond._right.mask |= tmpMask;
        }
      } else if (bond._right.mask & selectionMask) {
        bond._left.mask |= tmpMask;
      }
    });

    // select marked atoms
    const deselectionMask = ~tmpMask;
    this._complex.forEachAtom(atom => {
      if (atom.mask & tmpMask) {
        atom.mask = atom.mask & deselectionMask | selectionMask;
        ++self._selectionCount;
      }
    });
    this._complex.updateStructuresMask();
  }
  shrinkSelection() {
    const self = this;
    const selectionMask = 1 << this._selectionBit;
    const tmpMask = 1 << 31;

    // mark atoms neighbouring to unselected ones
    this._complex.forEachBond(bond => {
      if (bond._left.mask & selectionMask) {
        if ((bond._right.mask & selectionMask) === 0) {
          bond._left.mask |= tmpMask;
        }
      } else if (bond._right.mask & selectionMask) {
        bond._right.mask |= tmpMask;
      }
    });

    // mark hanging atoms
    this._complex.forEachAtom(atom => {
      if (atom.mask & selectionMask && atom.bonds.length === 1) {
        atom.mask |= tmpMask;
      }
    });

    // deselect marked atoms
    const deselectionMask = ~(selectionMask | tmpMask);
    this._complex.forEachAtom(atom => {
      if (atom.mask & tmpMask) {
        atom.mask &= deselectionMask;
        --self._selectionCount;
      }
    });
    this._complex.updateStructuresMask();
  }
  getSelectedComponent() {
    const selectionMask = 1 << this._selectionBit;
    let component = null;
    let multiple = false;

    // find which component is selected (exclusively)
    this._complex.forEachAtom(atom => {
      if (atom.mask & selectionMask) {
        if (component === null) {
          component = atom.residue._component;
        } else if (component !== atom.residue._component) {
          multiple = true;
        }
      }
    });
    return multiple ? null : component;
  }
  getSelectionCenter(center, includesAtom, selRule) {
    center.set(0.0, 0.0, 0.0);
    let count = 0;
    this._complex.forEachAtom(atom => {
      if (includesAtom(atom, selRule)) {
        center.add(atom.position);
        count++;
      }
    });
    if (count === 0) {
      return false;
    }
    center.divideScalar(count);
    center.applyMatrix4(this.matrix);
    return true;
  }
  needsRebuild() {
    if (this._reprListChanged) {
      return true;
    }
    const reprList = this._reprList;
    for (let i = 0, n = reprList.length; i < n; ++i) {
      const repr = reprList[i];
      if (repr.needsRebuild) {
        return true;
      }
    }
    return false;
  }

  /**
   * Rebuild molecule geometry asynchronously.
   */
  rebuild() {
    const self = this;

    // Destroy current geometry
    gfxutils.clearTree(this);
    return new Promise(resolve => {
      // Nothing to do?
      const complex = self._complex;
      if (!complex) {
        resolve();
        return;
      }
      let errorOccured = false;
      setTimeout(() => {
        console.time('build');
        const reprList = self._reprList;
        const palette = gfx_palettes.get(settings.now.palette) || gfx_palettes.first;
        let hasGeometry = false;
        for (let i = 0, n = reprList.length; i < n; ++i) {
          const repr = reprList[i];
          repr.colorer.palette = palette;
          if (repr.needsRebuild) {
            repr.reset();
            try {
              repr.buildGeometry(complex);
            } catch (e) {
              if (e instanceof utils.OutOfMemoryError) {
                repr.needsRebuild = false;
                repr.reset();
                logger.error(`Not enough memory to build geometry for representation ${repr.index + 1}`);
                errorOccured = true;
              } else {
                throw e;
              }
            }
            if (false) {}
          }
          hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);
          if (repr.geo) {
            self.add(repr.geo);
          }
        }
        self._reprListChanged = false;
        console.timeEnd('build');
        resolve();
      }, 10);
    });
  }
  setNeedsRebuild() {
    // invalidate all representations
    const reprList = this._reprList;
    for (let i = 0, n = reprList.length; i < n; ++i) {
      reprList[i].needsRebuild = true;
    }
  }
  rebuildSelectionGeometry() {
    const mask = 1 << this._selectionBit;
    gfxutils.clearTree(this._selectionGeometry);
    for (let i = 0, n = this._reprList.length; i < n; ++i) {
      const repr = this._reprList[i];
      const sg = repr.buildSelectionGeometry(mask);
      if (!sg) {
        continue;
      }
      this._selectionGeometry.add(sg);
      for (let j = 0; j < sg.children.length; j++) {
        const m = sg.children[j];

        // copy component transform (that's not applied yet)
        // TODO make this code obsolete, accessing editor is bad
        if (this._editor && this._editor._componentTransforms) {
          const t = this._editor._componentTransforms[m._component._index];
          if (t) {
            m.position.copy(t.position);
            m.quaternion.copy(t.quaternion);
          }
        }
      }
      gfxutils.applySelectionMaterial(sg);
    }
  }
  _buildSelectorFromSortedLists(atoms, residues, chains) {
    const complex = this._complex;
    function optimizeList(list) {
      const result = [];
      let k = 0;
      let first = NaN;
      let last = NaN;
      for (let i = 0, n = list.length; i < n; ++i) {
        const value = list[i];
        if (value === last + 1) {
          last = value;
        } else {
          if (!Number.isNaN(first)) {
            result[k++] = new ComplexVisual_selectors.Range(first, last);
          }
          first = last = value;
        }
      }
      if (!Number.isNaN(first)) {
        result[k] = new ComplexVisual_selectors.Range(first, last);
      }
      return result;
    }
    let expression = null;
    if (chains.length === complex._chains.length) {
      expression = ComplexVisual_selectors.all();
    } else {
      let selector;
      if (chains.length > 0) {
        selector = ComplexVisual_selectors.chain(chains);
        expression = expression ? ComplexVisual_selectors.or(expression, selector) : selector; // NOSONAR
      }
      if (Object.keys(residues).length > 0) {
        for (const ch in residues) {
          if (residues.hasOwnProperty(ch)) {
            selector = ComplexVisual_selectors.and(ComplexVisual_selectors.chain(ch), ComplexVisual_selectors.residx(optimizeList(residues[ch])));
            expression = expression ? ComplexVisual_selectors.or(expression, selector) : selector;
          }
        }
      }
      if (atoms.length > 0) {
        selector = ComplexVisual_selectors.serial(optimizeList(atoms));
        expression = expression ? ComplexVisual_selectors.or(expression, selector) : selector;
      }
      if (!expression) {
        expression = ComplexVisual_selectors.none();
      }
    }
    return expression;
  }
  buildSelectorFromMask(mask) {
    const complex = this._complex;
    const chains = [];
    const residues = {};
    const atoms = [];
    complex.forEachChain(chain => {
      if (chain._mask & mask) {
        chains.push(chain._name);
      }
    });
    complex.forEachResidue(residue => {
      if (residue._mask & mask && !(residue._chain._mask & mask)) {
        const c = residue._chain._name;
        if (!(c in residues)) {
          residues[c] = [residue._index];
        } else {
          residues[c].push(residue._index);
        }
      }
    });
    complex.forEachAtom(atom => {
      if (atom.mask & mask && !(atom.residue._mask & mask)) {
        atoms.push(atom.serial);
      }
    });
    return this._buildSelectorFromSortedLists(atoms, residues, chains);
  }
  forSelectedResidues(process) {
    const selectionMask = 1 << this._selectionBit;
    this._complex.forEachResidue(residue => {
      if (residue._mask & selectionMask) {
        process(residue);
      }
    });
  }
  beginComponentEdit() {
    if (this._editor) {
      return null;
    }
    const editor = new ComplexVisualEdit.ComponentEditor(this);
    if (!editor.begin()) {
      return null;
    }
    this._editor = editor;
    return editor;
  }
  beginFragmentEdit() {
    if (this._editor) {
      return null;
    }
    const editor = new ComplexVisualEdit.FragmentEditor(this);
    if (!editor.begin()) {
      return null;
    }
    this._editor = editor;
    return editor;
  }

  // should only be called by editors
  finalizeEdit() {
    this._editor = null;
  }
  setMaterialValues(values) {
    let needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    for (let i = 0, n = this._reprList.length; i < n; ++i) {
      const rep = this._reprList[i];
      rep.material.setValues(values);
      if (needTraverse) {
        rep.geo.traverse(object => {
          if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh) {
            object.material.setValues(values);
            if (process !== undefined) {
              process(object);
            }
            object.material.needsUpdate = true;
          }
        });
      }
    }
  }
  setUberOptions(values) {
    for (let i = 0, n = this._reprList.length; i < n; ++i) {
      const rep = this._reprList[i];
      rep.material.setUberOptions(values);
    }
  }

  /**
   * Build selector that contains all atoms within given distance from group of atoms
   * @param {Selector} selector - selector describing source group of atoms
   * @param {number} radius - distance
   * @returns {Selector} selector describing result group of atoms
   */
  within(selector, radius) {
    const vw = this._complex.getVoxelWorld();
    if (vw === null) {
      return false;
    }

    // mark atoms of the group as selected
    const selectionMask = 1 << this._selectionBit;
    this._complex.markAtoms(selector, selectionMask);

    // mark all atoms within distance as selected
    if (vw) {
      vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), atom => {
        atom.mask |= selectionMask;
      });
    }

    // update selection count
    this._selectionCount = this._complex.countAtomsByMask(selectionMask);

    // update secondary structure mask
    this._complex.updateStructuresMask();
    return this.buildSelectorFromMask(selectionMask);
  }
}
// 32 bits = 30 bits for reps + 1 for selection + 1 for selection expansion
ComplexVisual.NUM_REPRESENTATION_BITS = 30;
/* harmony default export */ const src_ComplexVisual = (ComplexVisual);
;// CONCATENATED MODULE: ./src/gfx/shaders/VolumeFaces.vert
const VolumeFaces_namespaceObject = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  pos = position.xyz + 0.5;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";
;// CONCATENATED MODULE: ./src/gfx/shaders/VolumeFaces.frag
const gfx_shaders_VolumeFaces_namespaceObject = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(pos, 0.5);\r\n}";
;// CONCATENATED MODULE: ./src/gfx/shaders/Volume.vert
const shaders_Volume_namespaceObject = "varying vec4 screenSpacePos;\r\n\r\nvoid main() {\r\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = screenSpacePos;\r\n}";
;// CONCATENATED MODULE: ./src/gfx/shaders/Volume.frag
const src_gfx_shaders_Volume_namespaceObject = "uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r\n\r\nuniform vec3 _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\n#define NO_COLOR vec4(0., 0., 0., 0.)\r\n\r\nvec4 sample3DTexture(vec3 texCoord) {\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r\n  vec3 textCoord = boxCoord;\r\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r\n\r\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r\n    return NO_COLOR;\r\n\r\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r\n\r\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r\n    return NO_COLOR;\r\n\r\n  return sample3DTexture(textCoord);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir) {\r\n  float d = 1. / 128.;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n\r\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r\n  vec3 coordInc = mix(\r\n    vec3(\r\n      sample3DTextureInclined(iter + dx).x,\r\n      sample3DTextureInclined(iter + dy).x,\r\n      sample3DTextureInclined(iter + dz).x\r\n    ),\r\n    vec3(0. ,0. , 0.),\r\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r\n  );\r\n\r\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r\n  vec3 coordDec = mix(\r\n    vec3(0. ,0. , 0.),\r\n    vec3(\r\n      sample3DTextureInclined(iter - dx).x,\r\n      sample3DTextureInclined(iter - dy).x,\r\n      sample3DTextureInclined(iter - dz).x\r\n    ),\r\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r\n  );\r\n\r\n  vec3 N = normalize(coordInc - coordDec);\r\n  float dif = max(0.0, dot(N, dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r\n  for (int i = 0; i < 5; i++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\r\n  for (int j = 0; j < 5; j++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r\n  vec3 step = stepSize * dir, iterator = start, left, right;\r\n  vec4 acc = NO_COLOR;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    iterator = iterator + step;\r\n    vol = sample3DTextureInclined(iterator).r;\r\n    if (length(iterator - back) <= stepSize || (vol > tr))\r\n      break;\r\n  }\r\n\r\n  if (vol > tr)\r\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r\n\r\n  return acc;\r\n}\r\n\r\nfloat easeOut(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return 1.0 - (1.0 - t) * (1.0 - t);\r\n}\r\n\r\nfloat easeIn(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return t * t;\r\n}\r\n\r\nvec3 GetColSimple(float vol) {\r\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 acc = NO_COLOR, iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r\n  vec3 step, col, colOld, right;\r\n  float tr0 = _isoLevel0.x;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n\r\n  for (int k = 0; k < 3; k++) {\r\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r\n    kd = 140. * tr0 * stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize * dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r\n      break;\r\n    iterator = iso.xyz;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetColSimple(tr0);\r\n    curStepSize = stepSize;\r\n    for (int i = 0; i < STEPS_COUNT; i++) {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTextureInclined(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetColSimple(vol);\r\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r\n      vec3 colMid = GetColSimple(vol);\r\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n\r\n    if (molD > molDist) {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist) * dir;\r\n      vol = sample3DTextureInclined(right).r;\r\n    } else {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n\r\n    alpha = (1. - r) * curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetColSimple(vol);\r\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r\n    vec3 colMid = GetColSimple(vol);\r\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1. * sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  float stepSize = 1.0 / float(STEPS_COUNT);\r\n  float len = length(back - start);\r\n  vec3 step = stepSize * dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    if (float(i) * stepSize > len)\r\n      break;\r\n    iterator = iterator + step;\r\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r\n  }\r\n\r\n  return vec4(1.,1.,1., acc);\r\n}\r\n\r\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r\n  vec4 col = NO_COLOR;\r\n\r\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r\n    float dif =  CalcColor(tst.xyz, dir);\r\n    dif = 0.9 * dif * dif;\r\n    col = vec4(dif, dif, dif, 1);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main() {\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0) {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  } else {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001) {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  #ifdef ISO_MODE\r\n    gl_FragColor = IsoRender(start, back, molDist, dir);\r\n  #else\r\n    gl_FragColor = VolRender(start, back, molDist, dir);\r\n  #endif\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/VolumeFarPlane.vert
const VolumeFarPlane_namespaceObject = "varying vec4 volPos;\r\nuniform float aspectRatio;\r\nuniform float farZ;\r\nuniform float tanHalfFOV;\r\nuniform mat4  matWorld2Volume;\r\n\r\nvoid main() {\r\n  // rescale plane to fill in the whole far plane area seen from camera\r\n  vec3 pos = position.xyz;\r\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r\n  pos.y = pos.y * tanHalfFOV * farZ;\r\n  // common transformation\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  // calc pos in volume CS\r\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  volPos = volPos + 0.5;\r\n  volPos.w = 0.5;\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/VolumeFarPlane.frag
const gfx_shaders_VolumeFarPlane_namespaceObject = "varying vec4 volPos;\r\n\r\nvoid main() {\r\n  gl_FragColor = volPos;\r\n}";
;// CONCATENATED MODULE: ./src/gfx/shaders/VolumeMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */








const volumeUniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.merge([{
  volumeDim: {
    type: 'v3',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(512, 512, 512)
  },
  tileTex: {
    type: 't',
    value: null
  },
  tileTexSize: {
    type: 'v2',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(512, 512)
  },
  tileStride: {
    type: 'v2',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(512, 512)
  },
  boxAngles: {
    type: 'v3',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 1, 1)
  },
  delta: {
    type: 'v3',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
  },
  _isoLevel0: {
    type: 'v2',
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.5, 0.75, 1.0)
  },
  _flipV: {
    type: 'f',
    value: 0.0
  },
  _BFLeft: {
    type: 't',
    value: null
  },
  _BFRight: {
    type: 't',
    value: null
  },
  _FFLeft: {
    type: 't',
    value: null
  },
  _FFRight: {
    type: 't',
    value: null
  },
  _WFFLeft: {
    type: 't',
    value: null
  },
  _WFFRight: {
    type: 't',
    value: null
  }
}]);
function overrideUniforms(params, defUniforms) {
  const uniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.clone(defUniforms);
  for (const p in params) {
    if (uniforms.hasOwnProperty(p)) {
      uniforms[p].value = params[p];
    }
  }
  return uniforms;
}
function facesPosMaterialParams(params, sideType) {
  return {
    uniforms: overrideUniforms(params, {}),
    vertexShader: VolumeFaces_namespaceObject,
    fragmentShader: gfx_shaders_VolumeFaces_namespaceObject,
    transparent: false,
    depthTest: false,
    depthWrite: false,
    side: sideType
  };
}
class BackFacePosMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const backFaceParams = facesPosMaterialParams(params, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BackSide);
    super(backFaceParams);
  }
}
class ShaderParams {
  constructor(params, uniforms, vertexShader, fragmentShader) {
    this.uniforms = overrideUniforms(params, uniforms);
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.transparent = false;
    this.depthTest = false;
    this.depthWrite = false;
    this.side = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FrontSide;
  }
}
class BackFacePosMaterialFarPlane extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const matUniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.merge([{
      aspectRatio: {
        type: 'f',
        value: 0.0
      },
      farZ: {
        type: 'f',
        value: 0.0
      },
      tanHalfFOV: {
        type: 'f',
        value: 0.0
      },
      matWorld2Volume: {
        type: '4fv',
        value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
      }
    }]);
    const shaderParams = new ShaderParams(params, matUniforms, VolumeFarPlane_namespaceObject, gfx_shaders_VolumeFarPlane_namespaceObject);
    super(shaderParams);
  }
}
class FrontFacePosMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const frontFaceParams = facesPosMaterialParams(params, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FrontSide);
    super(frontFaceParams);
  }
}
class VolumeMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const shaderParams = new ShaderParams(params, volumeUniforms, shaders_Volume_namespaceObject, src_gfx_shaders_Volume_namespaceObject);
    shaderParams.transparent = true;
    shaderParams.depthTest = true;
    super(shaderParams);
    this.updateDefines();
  }
  updateDefines() {
    this.defines = {
      ISO_MODE: settings.now.modes.VD.isoMode,
      STEPS_COUNT: settings.now.modes.VD.polyComplexity[settings.now.resolution] * 100
    };
    this.needsUpdate = true;
  }
}
/* harmony default export */ const shaders_VolumeMaterial = ({
  BackFacePosMaterial,
  BackFacePosMaterialFarPlane,
  FrontFacePosMaterial,
  VolumeMaterial
});
;// CONCATENATED MODULE: ./src/gfx/VolumeMesh.js



class VolumeMesh extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh {
  volumeInfo = {}; // data for noise filter

  constructor() {
    const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    super(geo);
    this.clipPlane = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Plane();
    const size = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.5, 0.5, 0.5);
    this.size = size;
    this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];
    this.faces = [{
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, -1)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, -1, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1, 0, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    }];
    this.vertices = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, -size.y, -size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, size.y, -size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, -size.y, -size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, size.y, -size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, -size.y, size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, size.y, size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, -size.y, size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, size.y, size.z), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0),
    // Placeholder for section
    new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0)];
    geo.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(new Float32Array(this.vertices.length * 3), 3));
    this.name = 'VolumeMesh';
  }
  static _corners = (() => [
  // x, y, z, edge1, edge2, edge3
  [-1, -1, -1, 0, 4, 8], [1, -1, -1, 0, 5, 9], [1, 1, -1, 1, 5, 10], [-1, 1, -1, 1, 4, 11], [-1, -1, 1, 2, 6, 8], [1, -1, 1, 2, 7, 9], [1, 1, 1, 3, 7, 10], [-1, 1, 1, 3, 6, 11]])();
  static _edges = (() => [
  // corner1, corner2, center_x, center_y, center_z
  [0, 1, 0, -1, -1], [2, 3, 0, 1, -1], [4, 5, 0, -1, 1], [6, 7, 0, 1, 1], [0, 3, -1, 0, -1], [1, 2, 1, 0, -1], [4, 7, -1, 0, 1], [5, 6, 1, 0, 1], [0, 4, -1, -1, 0], [1, 5, 1, -1, 0], [2, 6, -1, 1, 0], [3, 7, 1, 1, 0]])();
  static _edgeIntersections = function () {
    const edgeIntersections = [];
    for (let j = 0; j < 12; ++j) {
      edgeIntersections.push(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3());
    }
    return edgeIntersections;
  }();
  _updateVertices() {
    // Algorithm:
    // 1. Get plane parameters
    // 2. Compute culling flags for all vertices
    // 3. If intersection occurs => compute from 3 to 6 intersection points
    const corners = VolumeMesh._corners;
    const edges = VolumeMesh._edges;
    const edgeIntersections = VolumeMesh._edgeIntersections;
    let i;
    const norm = this.clipPlane.normal;
    const D = this.clipPlane.constant;
    const vert = this.vertices;
    const {
      size
    } = this;
    const cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
    const edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    const curEdge = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let curEdgeInter = null;
    function CheckX() {
      if (norm.x === 0) return 0;
      const x = -(norm.dot(curEdge) + D) / norm.x;
      if (-size.x <= x && x <= size.x) {
        curEdgeInter.set(x, curEdge.y, curEdge.z);
        if (x === size.x) return 2;
        if (x === -size.x) return -2;
        return 1;
      }
      return 0;
    }
    function CheckY() {
      if (norm.y === 0) return 0;
      const y = -(norm.dot(curEdge) + D) / norm.y;
      if (-size.y <= y && y <= size.y) {
        curEdgeInter.set(curEdge.x, y, curEdge.z);
        if (y === size.y) return 2;
        if (y === -size.y) return -2;
        return 1;
      }
      return 0;
    }
    function CheckZ() {
      if (norm.z === 0) return 0;
      const z = -(norm.dot(curEdge) + D) / norm.z;
      if (-size.z <= z && z <= size.z) {
        curEdgeInter.set(curEdge.x, curEdge.y, z);
        if (z === size.z) return 2;
        if (z === -size.z) return -2;
        return 1;
      }
      return 0;
    }

    // for each edge
    for (let curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
      const curEdgeSource = edges[curEdgeIdx];
      curEdgeInter = edgeIntersections[curEdgeIdx];
      curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
      curEdge.multiply(size);

      // calculate intersection point
      let flag = 0;
      if (curEdgeSource[2] === 0) flag = CheckX();
      if (curEdgeSource[3] === 0) flag = CheckY();
      if (curEdgeSource[4] === 0) flag = CheckZ();

      // mark corresponding corner (if plane cuts through one)
      if (flag === -2) {
        cornerMark[curEdgeSource[0]] = 1;
      } else if (flag === 2) {
        cornerMark[curEdgeSource[1]] = 1;
      } else if (flag === 0) {
        // edge is not intersected by the plane (doesn't produce a vertex)
        edgeMark[curEdgeIdx] = 0;
      }
    }
    const face = {
      indices: [],
      norm: norm.clone().negate()
    };
    let nextVertex = 8;

    // for each marked corner
    for (i = 0; i < 8; ++i) {
      if (cornerMark[i] === 1) {
        // add corner as vertex to the face
        vert[nextVertex].set(corners[i][0], corners[i][1], corners[i][2]).multiply(size);
        face.indices.push(nextVertex++);
        // skip adjacent edges
        edgeMark[corners[i][3]] = 0;
        edgeMark[corners[i][4]] = 0;
        edgeMark[corners[i][5]] = 0;
      }
    }

    // for each edge that has internal intersection
    for (i = 0; i < 12; ++i) {
      if (edgeMark[i] === 1) {
        // add intersection point as vertex to the face
        vert[nextVertex].copy(edgeIntersections[i]);
        face.indices.push(nextVertex++);
      }
    }
    this.faces[6] = face;
    const diff = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const coplanarPoint = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this.clipPlane.coplanarPoint(coplanarPoint);
    for (i = 0; i < vert.length; ++i) {
      this.cullFlag[i] = false;
      if (i < 8) {
        // corners should be culled by clipping plane
        diff.subVectors(vert[i], coplanarPoint);
        this.cullFlag[i] = norm.dot(diff) >= 0.0;
      } else if (i < 8 + face.indices.length) {
        // cross section vertices don't get culled
        this.cullFlag[i] = true;
      }
    }

    // write data to vertex buffer
    const positions = this.geometry.getAttribute('position');
    let idx = 0;
    for (i = 0; i < vert.length; ++i) {
      positions.array[idx++] = vert[i].x;
      positions.array[idx++] = vert[i].y;
      positions.array[idx++] = vert[i].z;
    }
    positions.needsUpdate = true;
  }
  _collectVertices(face, filter) {
    let i;
    const vert = this.vertices;
    face.indices = [];
    for (i = 0; i < vert.length; ++i) {
      if (this.cullFlag[i] && filter(vert[i])) {
        face.indices.push(i);
      }
    }
  }
  _sortIndices(face, right) {
    let i;
    let j;
    const vert = this.vertices;
    const angle = [];
    const dir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    for (i = 1; i < face.indices.length; ++i) {
      dir.subVectors(vert[face.indices[i]], vert[face.indices[0]]);
      dir.normalize();
      dir.cross(right);
      dir.negate();
      angle[i] = face.norm.dot(dir);
    }

    // Exchange sort
    for (i = 1; i < face.indices.length - 1; ++i) {
      for (j = i + 1; j < face.indices.length; ++j) {
        if (angle[j] < angle[i]) {
          // swap
          let t = angle[i];
          angle[i] = angle[j];
          angle[j] = t;
          t = face.indices[i];
          face.indices[i] = face.indices[j];
          face.indices[j] = t;
        }
      }
    }
  }
  _updateIndices() {
    // Algorithm:
    // 1. Get plane vertices (from 3 to 6 vertices)
    // 2. Get "right" vector in plane
    // 3. Sort vertices using Graham-like method
    // 4. Create indices

    let i;
    let faceIdx;
    let face;
    const vert = this.vertices;
    const {
      size
    } = this;
    this._collectVertices(this.faces[0], vertex => vertex.z === -size.z);
    this._collectVertices(this.faces[1], vertex => vertex.z === size.z);
    this._collectVertices(this.faces[2], vertex => vertex.y === -size.y);
    this._collectVertices(this.faces[3], vertex => vertex.y === size.y);
    this._collectVertices(this.faces[4], vertex => vertex.x === -size.x);
    this._collectVertices(this.faces[5], vertex => vertex.x === size.x);
    const vCenter = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vRight = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
      face = this.faces[faceIdx];
      if (face.indices.length === 0) continue;
      vCenter.set(0, 0, 0);
      for (i = 0; i < face.indices.length; ++i) {
        vCenter.add(vert[face.indices[i]]);
      }
      vCenter.multiplyScalar(1.0 / face.indices.length);
      vRight.subVectors(vert[face.indices[0]], vCenter);
      vRight.normalize();
      const rightProj = [];
      for (i = 0; i < face.indices.length; ++i) {
        vDir.subVectors(vert[face.indices[i]], vCenter);
        rightProj[i] = vDir.dot(vRight);
      }
      for (i = 1; i < face.indices.length; ++i) {
        if (rightProj[i] < rightProj[0]) {
          // swap
          let t = rightProj[0];
          rightProj[0] = rightProj[i];
          rightProj[i] = t;
          [t] = face.indices;
          face.indices[0] = face.indices[i];
          face.indices[i] = t;
        }
      }
      this._sortIndices(face, vRight);
    }
    let numIndices = 0;
    for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
      face = this.faces[faceIdx];
      if (face.indices.length >= 3) {
        numIndices += 3 * (face.indices.length - 2);
      }
    }
    let offset = 0;
    const indices = new Uint16Array(numIndices);
    for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
      face = this.faces[faceIdx];
      for (i = 0; i < face.indices.length - 2; ++i) {
        indices[offset] = face.indices[0]; // eslint-disable-line prefer-destructuring
        indices[offset + 1] = face.indices[i + 1];
        indices[offset + 2] = face.indices[i + 2];
        offset += 3;
      }
    }
    this.geometry.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(indices, 1));
  }
  setDataSource(dataSource) {
    const vm = new shaders_VolumeMaterial.VolumeMaterial();
    const dim = dataSource.getDimensions();
    const stride = dataSource.getTiledTextureStride();
    const texture = dataSource.buildTiledTexture();
    const bbox = dataSource.getBox();
    vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
    vm.uniforms.tileTex.value = texture;
    vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
    vm.uniforms.tileStride.value.set(stride[0], stride[1]);
    Object.assign(this.volumeInfo, dataSource.getVolumeInfo());
    const volInfo = this.volumeInfo;
    vm.uniforms.delta.value.copy(volInfo.delta);
    vm.uniforms.boxAngles.value.set(volInfo.obtuseAngle[0], volInfo.obtuseAngle[1], volInfo.obtuseAngle[2]);
    this.material = vm;
    bbox.getSize(this.scale);
    bbox.getCenter(this.position);
  }
  _updateIsoLevel() {
    const {
      kSigma,
      kSigmaMed,
      kSigmaMax
    } = settings.now.modes.VD;
    const volInfo = this.volumeInfo;
    const mean = volInfo.dmean - volInfo.dmin;
    const span = volInfo.dmax - volInfo.dmin;
    const level = k => (mean + k * volInfo.sd) / span;
    this.material.uniforms._isoLevel0.value.set(level(kSigma), level(kSigmaMed), level(kSigmaMax));
  }
  static _nearClipPlaneOffset = 0.2;
  static _pos = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  static _norm = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  static _norm4D = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4())();
  static _matrixWorldToLocal = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4())();
  static _clipPlane = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Plane())();
  rebuild(camera) {
    const nearClipPlaneOffset = VolumeMesh._nearClipPlaneOffset;
    const pos = VolumeMesh._pos;
    const norm = VolumeMesh._norm;
    const norm4D = VolumeMesh._norm4D;
    const matrixWorldToLocal = VolumeMesh._matrixWorldToLocal;
    const clipPlane = VolumeMesh._clipPlane;
    this._updateIsoLevel();

    // get clip plane in local space
    camera.getWorldDirection(norm);
    camera.getWorldPosition(pos);
    pos.addScaledVector(norm, camera.near + nearClipPlaneOffset);

    // transform pos to local CS
    matrixWorldToLocal.copy(this.matrixWorld).invert();
    pos.applyMatrix4(matrixWorldToLocal);

    // transform norm to local CS
    norm4D.set(norm.x, norm.y, norm.z, 0.0); // NOTE: use homogeneous norm for proper transformation
    norm4D.applyMatrix4(matrixWorldToLocal);
    norm.copy(norm4D);
    norm.normalize();
    clipPlane.setFromNormalAndCoplanarPoint(norm, pos);
    if (!this.clipPlane.equals(clipPlane)) {
      this.clipPlane = clipPlane.clone();
      this._updateVertices();
      this._updateIndices();
    }
  }
}
/* harmony default export */ const gfx_VolumeMesh = (VolumeMesh);
;// CONCATENATED MODULE: ./src/gfx/VolumeBounds.js


function _flattenArray(input) {
  const n = input.length;
  const output = new Float32Array(n * 3);
  for (let i = 0; i < n; ++i) {
    const j = 3 * i;
    const v = input[i];
    output[j] = v.x;
    output[j + 1] = v.y;
    output[j + 2] = v.z;
  }
  return output;
}
class VolumeBounds {
  static _projectionTable = {
    // corresponds between (origin axes and angles between them) and between saving vector coordinates
    XY: ['x', 2],
    XZ: ['y', 1],
    YZ: ['z', 0]
  };
  constructor(bBox, volInfo) {
    const {
      delta
    } = volInfo; // {x: XY, y : XZ, z: YZ}
    const {
      obtuseAngle
    } = volInfo; // 1 - obtuse, 0 - acute

    const bSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    bBox.getSize(bSize);
    bSize.multiplyScalar(0.5);
    const offsetVert = this._getBaseVertices(delta, obtuseAngle);
    const geometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    const vertices = [];
    for (let i = 0; i < 4; i++) {
      vertices.push(offsetVert[i].clone().multiply(bSize));
      vertices.push(offsetVert[(i + 1) % 4].clone().multiply(bSize));
    }
    const translation = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(2 * bSize.x * (1 - delta.x - delta.y), 0, 0);
    for (let i = 0; i < 8; i++) {
      vertices.push(vertices[i].clone().add(translation));
    }
    for (let i = 0; i < 4; i++) {
      vertices.push(vertices[i * 2].clone());
      vertices.push(vertices[i * 2 + 8].clone());
    }
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    bBox.getCenter(center);
    vertices.forEach(vertex => vertex.add(center)); // pivot shift

    const flatVertices = _flattenArray(vertices);
    geometry.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(flatVertices, 3));
    this._lines = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments(geometry, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineBasicMaterial({
      color: 0xFFFFFF
    }));
    this._lines.layers.set(gfxutils.LAYERS.VOLUME);
  }

  // Set one edge (4 points) of frame, from which with parallel transfer  the rest of the frame points can be obtained
  _getBaseVertices(delta, obtuseAngle) {
    const projTable = VolumeBounds._projectionTable;
    const proj = (index, inv) => {
      // tricky function to take account of projections: their position(related to box) and sign
      const currDelta = delta[projTable[index][0]];
      const angleValue = -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]]; // inv = 1: alpha; inv = -1: 1 - alpha
      return angleValue * currDelta;
    };
    const offsetVert = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', 1)), -1 + 2 * proj('YZ', 1), -1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', 1)), -1 + 2 * proj('YZ', -1), 1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj('XZ', -1) + proj('XY', -1)), 1 - 2 * proj('YZ', 1), 1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj('XZ', 1) + proj('XY', -1)), 1 - 2 * proj('YZ', -1), -1)];
    return offsetVert;
  }
  getMesh() {
    return this._lines;
  }
}
/* harmony default export */ const gfx_VolumeBounds = (VolumeBounds);
;// CONCATENATED MODULE: ./src/gfx/VolumeFarPlane.js





// Thes geometric far plane is required for correct filling in the BFTexture in case, when far plane cuts the volume
// cube. In cut place of cube there is no correct data in BFTexture and volume rendering integral is calculated
// with errors.
// Far plane cuts the cube in case of large volume scale (zoom), because farplane doesn't change
class VolumeFarPlane {
  // create plane with unit corners coords (for future rescale in vshader according to camera properties)
  constructor(volume, width, height) {
    const planeGeo = this._initPlaneGeo(width, height);
    const mat = new shaders_VolumeMaterial.BackFacePosMaterialFarPlane();
    this._plane = new meshes.Mesh(planeGeo, mat);
    this._plane.frustumCulled = false;
    this._plane.doubleSided = true;
    const matWorldToVolume = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    this._plane._onBeforeRender = function (_renderer, _scene, camera, _geometry, _material, _group) {
      const {
        material
      } = this;
      if (!volume || !material) {
        return;
      }

      // count point in world at farplane place
      const planeCamPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0, -(camera.far - 0.1), 1);
      planeCamPos.applyMatrix4(camera.matrixWorld);

      // recalc matrices to make plane be placed as farplane in the World relative to camera
      this.matrix.identity();
      this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
      this.matrixWorld.copy(this.matrix);
      this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);

      // build worldToVolume matrix to transform plane into volumeCS (volumeCS coords are written to BackFaceTexture)
      const volumeMatrix = volume.matrixWorld;
      matWorldToVolume.copy(volumeMatrix).invert();

      // update material props
      material.uniforms.aspectRatio.value = camera.aspect;
      material.uniforms.farZ.value = camera.far;
      material.uniforms.tanHalfFOV.value = Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.DEG2RAD * 0.5 * camera.fov);
      material.uniforms.matWorld2Volume.value = matWorldToVolume;
    };

    // set it to special layer to draw only into BFTexture
    this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
  }
  _initPlaneGeo(width, height) {
    const planeGeo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    width = width || 1;
    height = height || 1;
    const vertices = new Float32Array([-0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0, -0.5 * width, -0.5 * height, 0, 0.5 * width, -0.5 * height, 0]);
    planeGeo.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(vertices, 3));
    planeGeo.setIndex([0, 2, 1, 2, 3, 1]);
    return planeGeo;
  }
  getMesh() {
    return this._plane;
  }
}
/* harmony default export */ const gfx_VolumeFarPlane = (VolumeFarPlane);
;// CONCATENATED MODULE: ./src/VolumeVisual.js






class VolumeVisual extends src_Visual {
  constructor(name, dataSource) {
    super(name, dataSource);
    this._mesh = new gfx_VolumeMesh();
    this._mesh.setDataSource(dataSource);
    this.add(this._mesh);
    this._frame = new gfx_VolumeBounds(this.getBoundaries().boundingBox, this._mesh.volumeInfo);
    this.add(this._frame.getMesh());
    this.showFrame(settings.now.modes.VD.frame);
    this._farPlane = new gfx_VolumeFarPlane(this._mesh, 2, 2);
    this.add(this._farPlane.getMesh());
  }
  getBoundaries() {
    const box = this._dataSource.getBox();
    const sphere = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
    box.getBoundingSphere(sphere);
    return {
      boundingBox: box,
      boundingSphere: sphere
    };
  }
  getMesh() {
    return this._mesh;
  }
  showFrame(needShow) {
    this._frame.getMesh().material.visible = needShow;
  }
}
/* harmony default export */ const src_VolumeVisual = (VolumeVisual);
;// CONCATENATED MODULE: ./src/io/loaders/LoaderList.js


/**
 * A list of available loaders.
 * @extends EntityList
 */
class LoaderList extends utils_EntityList {
  /**
   * Create a list of loaders.
   * The loaders are indexed by supported source types (`.types` property of a Loader
   * subclass).
   * The loaders can be retrieved later by matching against specs (see {@link LoaderList#find}).
   *
   * @param {!Array<function(new:Loader)>=} someLoaders A list of {@link Loader} subclasses to
   *   automatically register at creation time.
   * @see LoaderList#register
   */
  constructor() {
    let someLoaders = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(someLoaders, ['types']);
  }

  /**
   * Find a suitable loader for a source type.
   *
   * @param {Object} specs Loader specifications.
   * @param {string=} specs.type Supported source type.
   * @param {*=} specs.source Source to load from.
   */
  find(specs) {
    let list = [];
    if (specs.type) {
      list = this._dict.types[specs.type.toLowerCase()] || [];
    } else if (specs.source) {
      return this._list.filter(SomeLoader => SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source));
    }
    return [...list];
  }
}
/* harmony default export */ const loaders_LoaderList = (LoaderList);
;// CONCATENATED MODULE: ./src/io/loaders/Loader.js


class Loader extends utils_EventDispatcher {
  constructor(source, options) {
    super();
    this._source = source;
    this._options = options || {};
    this._abort = false;
    this._agent = null;
  }
  load() {
    return Promise.reject(new Error('Loading from this source is not implemented'));
  }
  abort() {
    this._abort = true;
    if (this._agent) {
      this._agent.abort();
    }
  }
  static extractName(_source) {
    return undefined;
  }
}
utils_makeContextDependent(Loader.prototype);
;// CONCATENATED MODULE: ./src/io/loaders/FileLoader.js

class FileLoader extends Loader {
  constructor(source, options) {
    super(source, options);
    options = this._options;
    this._binary = options.binary === true;
  }
  load() {
    return new Promise((resolve, reject) => {
      if (this._abort) {
        throw new Error('Loading aborted');
      }
      const blob = this._source;
      const reader = this._agent = new FileReader();
      reader.addEventListener('load', () => {
        resolve(reader.result);
      });
      reader.addEventListener('error', () => {
        reject(reader.error);
      });
      reader.addEventListener('abort', () => {
        reject(new Error('Loading aborted'));
      });
      reader.addEventListener('progress', event => {
        this.dispatchEvent(event);
      });
      if (this._binary) {
        reader.readAsArrayBuffer(blob);
      } else {
        reader.readAsText(blob);
      }
    });
  }
  static canProbablyLoad(source) {
    return File && source instanceof File || Blob && source instanceof Blob;
  }
  static extractName(source) {
    return source && source.name;
  }
}
FileLoader.types = ['file', 'blob'];
;// CONCATENATED MODULE: ./src/io/loaders/XHRLoader.js



// we don't need to detect all kinds of URLs, just the evident ones
const urlStartRegexp = /^(https?|ftp):\/\//i;
class XHRLoader extends Loader {
  constructor(source, options) {
    super(source, options);
    options = this._options;
    this._binary = options.binary === true;
  }
  load() {
    return new Promise((resolve, reject) => {
      if (this._abort) {
        throw new Error('Loading aborted');
      }
      const url = this._source;
      const request = this._agent = new XMLHttpRequest();
      request.addEventListener('load', () => {
        if (request.status === 200) {
          resolve(request.response);
        } else {
          reject(new Error(`HTTP ${request.status} while fetching ${url}`));
        }
      });
      request.addEventListener('error', () => {
        reject(new Error('HTTP request failed'));
      });
      request.addEventListener('abort', () => {
        reject(new Error('Loading aborted'));
      });
      request.addEventListener('progress', event => {
        this.dispatchEvent(event);
      });
      request.open('GET', url);
      if (this._binary) {
        request.responseType = 'arraybuffer';
      } else {
        request.responseType = 'text';
      }
      request.send();
    });
  }
  static canProbablyLoad(source) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(source) && urlStartRegexp.test(source);
  }
  static extractName(source) {
    if (source) {
      const last = (source.indexOf('?') + 1 || source.lastIndexOf('#') + 1 || source.length + 1) - 1;
      return source.slice(source.lastIndexOf('/', last) + 1, last);
    }
    return undefined;
  }
}
XHRLoader.types = ['url'];
;// CONCATENATED MODULE: ./src/io/loaders/ImmediateLoader.js

class ImmediateLoader extends Loader {
  load() {
    return new Promise(resolve => {
      if (this._abort) {
        throw new Error('Loading aborted');
      }
      resolve(this._source);
    });
  }
  static canProbablyLoad(_source) {
    return false;
  }
}
ImmediateLoader.types = ['immediate'];
;// CONCATENATED MODULE: ./src/io/loaders.js




/* harmony default export */ const loaders = (new loaders_LoaderList([
// note: order might be important
FileLoader, XHRLoader, ImmediateLoader]));
;// CONCATENATED MODULE: ./src/io/parsers/ParserList.js


/**
 * A list of available parsers.
 * @extends EntityList
 */
class ParserList extends utils_EntityList {
  /**
   * Create a list of parsers.
   * The parsers are indexed by supported data formats and file extensions (`.formats` and
   * `.extensions` properties of a Parser subclass).
   * The parsers can be retrieved later by matching against specs (see {@link ParsrerList#find}).
   *
   * @param {!Array<function(new:Parser)>=} someParsers A list of {@link Parser} subclasses to
   *   automatically register at creation time.
   * @see ParserList#register
   */
  constructor() {
    let someParsers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(someParsers, ['formats', 'extensions']);
  }

  /**
   * Find a suitable parser for data.
   *
   * @param {Object} specs Parser specifications.
   * @param {string=} specs.format Supported data format.
   * @param {string=} specs.ext Supported filename extension.
   * @param {*=} specs.data Data to parse.
   */
  find(specs) {
    let list = [];
    if (specs.format) {
      list = this._dict.formats[specs.format.toLowerCase()] || [];
    } else if (specs.ext) {
      list = this._dict.extensions[specs.ext.toLowerCase()] || [];
    }
    // autodetect only if no format is forced
    if (list.length === 0 && !specs.format && specs.data) {
      return this._list.filter(SomeParser => SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data));
    }
    return [...list];
  }
}
/* harmony default export */ const parsers_ParserList = (ParserList);
;// CONCATENATED MODULE: ./src/io/parsers/Parser.js

class Parser {
  constructor(data, options) {
    this._data = data;
    this._options = options || {};
    this._abort = false;
  }
  parseSync() {
    throw new Error('Parsing this type of data is not implemented');
  }
  parse() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          if (this._abort) {
            return reject(new Error('Parsing aborted'));
          }
          return resolve(this.parseSync());
        } catch (error) {
          return reject(error);
        }
      });
    });
  }

  // only for volume Parsers
  getModel() {
    this.model._parseHeader(this._data);
    return this.model;
  }
  abort() {
    this._abort = true;
  }
}
utils_makeContextDependent(Parser.prototype);
;// CONCATENATED MODULE: ./src/io/parsers/pdb/Remark290.js


/**
 * Parser helper for PDB tag "REMARK 290".
 *
 * @exports Remark290
 * @constructor
 */
class Remark290 {
  constructor() {
    /** @type {THREE.Matrix4[]} */
    this.matrices = [];

    /** @type {?THREE.Matrix4} */
    this._matrix = null;
    /** @type {number} */
    this._matrixIndex = -1;
  }

  /**
   * Parse a single line of a stream.
   * @param {PDBStream} stream - stream to parse
   */

  parse(stream) {
    /** @type {?THREE.Matrix4} */
    let matrix = this._matrix;
    if (stream.readString(12, 18) === '  SMTRY') {
      const matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2
      const matrixData = stream.readString(20, 80).trim().split(/\s+/);
      const matrixIndex = parseInt(matrixData[0], 10);
      if (this._matrix === null || matrixIndex !== this._matrixIndex) {
        // TODO: assert(matrixIndex === this.matrices.length + 1);
        this._matrixIndex = matrixIndex;
        this._matrix = matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
        this.matrices[this.matrices.length] = matrix;
      }
      const {
        elements
      } = matrix;
      elements[matrixRow] = parseFloat(matrixData[1]);
      elements[matrixRow + 4] = parseFloat(matrixData[2]);
      elements[matrixRow + 8] = parseFloat(matrixData[3]);
      elements[matrixRow + 12] = parseFloat(matrixData[4]);
    }
  }
}
Remark290.prototype.id = 290;
/* harmony default export */ const pdb_Remark290 = (Remark290);
;// CONCATENATED MODULE: ./src/io/parsers/pdb/Remark350.js


const {
  Assembly: Remark350_Assembly
} = chem;

/**
 * Parser helper for PDB tag "REMARK 350".
 *
 * @exports Remark350
 * @constructor
 */
class Remark350 {
  constructor(complex) {
    /** @type {Complex} */
    this._complex = complex;
    /** @type {Assembly[]} */
    this.assemblies = [];

    /** @type {?Assembly} */
    this._assembly = null;
    /** @type {?THREE.Matrix4} */
    this._matrix = null;
    /** @type {number} */
    this._matrixIndex = -1;
  }

  /**
   * Parse a single line of a stream.
   * @param {PDBStream} stream - stream to parse
   */

  parse(stream) {
    /** @type {?Assembly} */
    let assembly = this._assembly;
    /** @type {?THREE.Matrix4} */
    let matrix = this._matrix;
    if (assembly && stream.readString(12, 18) === '  BIOMT') {
      const matrixRow = stream.readCharCode(19) - 49; // convert '1', '2', or '3' -> 0, 1, or 2
      const matrixData = stream.readString(20, 80).trim().split(/\s+/);
      const matrixIndex = parseInt(matrixData[0], 10);
      if (this._matrix === null || matrixIndex !== this._matrixIndex) {
        // TODO: assert(matrixIndex === assembly.matrices.length + 1);
        this._matrixIndex = matrixIndex;
        this._matrix = matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
        assembly.addMatrix(matrix);
      }
      const {
        elements
      } = matrix;
      elements[matrixRow] = parseFloat(matrixData[1]);
      elements[matrixRow + 4] = parseFloat(matrixData[2]);
      elements[matrixRow + 8] = parseFloat(matrixData[3]);
      elements[matrixRow + 12] = parseFloat(matrixData[4]);
    } else if (assembly && stream.readString(35, 41) === 'CHAINS:') {
      const entries = stream.readString(42, 80).split(',');
      for (let i = 0, n = entries.length; i < n; ++i) {
        const chain = entries[i].trim();
        if (chain.length > 0) {
          assembly.addChain(chain);
        }
      }
    } else if (stream.readString(12, 23) === 'BIOMOLECULE:') {
      // assert molIndex === this.assemblies.length + 1
      this._matrix = null;
      this._matrixIndex = -1;
      this._assembly = assembly = new Remark350_Assembly(this._complex);
      this.assemblies.push(assembly);
    }
  }
}
Remark350.prototype.id = 350;
/* harmony default export */ const pdb_Remark350 = (Remark350);
;// CONCATENATED MODULE: ./src/io/parsers/PDBStream.js
/** Helper class for stream-like reading input files. */
class PDBStream {
  /**
   * Create a stream
   * @param {String} data Input data
   */
  constructor(data) {
    /** @type String */
    this._data = data; // Input file
    /** @type Number */
    this._start = 0; // Starting position of line
    /** @type Number */
    this._nextCR = -1; // Position of next CR (0x0D)
    /** @type Number */
    this._nextLF = -1; // Position of next LF (0x0A)
    /** @type Number */
    this._next = -1; // End position of line
    /** @type Number */
    this._end = data.length; // End of data

    this.next();
  }

  /**
   * Reading next line.
   * @returns {String} Next line in data (ending with LF or CR)
   */
  readLine() {
    return this._data.slice(this._start, this._next);
  }

  /**
   * Reading character from position.
   * @param {Number} pos - Position in current line.
   * @returns {String} Character from position
   */
  readChar(pos) {
    pos = this._start + pos - 1;
    return pos < this._next ? this._data[pos] : ' ';
  }

  /**
   * Reading character code from position.
   * @param {Number} pos - Position in current line.
   * @returns {Number} Character code from position
   */
  readCharCode(pos) {
    pos = this._start + pos - 1;
    return pos < this._next ? this._data.charCodeAt(pos) : 32;
  }

  /**
   * Reading string from begin to end points.
   * For a reason unknown, numbering assumed not to start from 0, but from 1.
   * @param {Number} begin - Begin point in current line.
   * @param {Number} end - End point in current line.
   * @returns {String} String from begin to end
   */
  readString(begin, end) {
    const from = this._start + begin - 1;
    const to = this._start + end;
    return this._data.slice(from, to < this._next ? to : this._next);
  }

  /**
   * Reading integer from begin to end points.
   * @param {Number} begin - Begin point in current line.
   * @param {Number} end - End point in current line.
   * @returns {Number} Integer from begin to end
   */
  readInt(begin, end) {
    return parseInt(this.readString(begin, end), 10);
  }

  /**
   * Reading float from begin to end points.
   * @param {Number} begin - Begin point in current line.
   * @param {Number} end - End point in current line.
   * @returns {Number} Float from begin to end
   */
  readFloat(begin, end) {
    return parseFloat(this.readString(begin, end));
  }

  /**
   * Checking for end of data.
   * @returns {boolean} True if data is ended, false otherwise
   */
  end() {
    return this._start >= this._end;
  }

  /**
   * Procedure to re-arrange current pointers in data.
   */
  next() {
    const start = this._next + 1;
    this._start = start < this._end ? start : this._end;

    // support CR, LF, CR+LF line endings
    // do not support LF+CR, CR+CR+LF, and other strange combinations

    if (this._start > this._nextCR) {
      this._nextCR = (this._data.indexOf('\r', this._start) + 1 || this._end + 1) - 1;
    }
    if (this._start > this._nextLF) {
      this._nextLF = (this._data.indexOf('\n', this._start) + 1 || this._end + 1) - 1;
    }
    this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
  }
}
/* harmony default export */ const parsers_PDBStream = (PDBStream);
;// CONCATENATED MODULE: ./src/io/parsers/PDBParser.js







const {
  Complex: PDBParser_Complex,
  Element: PDBParser_Element,
  Helix: PDBParser_Helix,
  Sheet: PDBParser_Sheet,
  Strand: PDBParser_Strand,
  Bond: PDBParser_Bond,
  Molecule: PDBParser_Molecule
} = chem;
const TAG_LENGTH = 6;
function nameToElement(name) {
  // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
  //
  // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
  //
  // Atom names start with element symbols right-justified in columns 13-14
  // as permitted by the length of the name. For example, the symbol FE for
  // iron appears in columns 13-14, whereas the symbol C for carbon appears
  // in column 14 (see Misaligned Atom Names). If an atom name has four
  // characters, however, it must start in column 13 even if the element
  // symbol is a single character (for example, see Hydrogen Atoms).

  const veryLong = name.trim().length === 4;
  return name.slice(0, veryLong ? 1 : 2).trim();
}

// the most frequently used beginnings; although HEADER is mandatory, it is often missing in handmade files
const pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;
const remarkParsers = {
  // NOTE: please forget the idea to build the method name in runtime, it can be obfuscated.
  290: pdb_Remark290,
  350: pdb_Remark350
};
class PDBParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._sheet = null;
    this._serialAtomMap = null;
    this._modelId = 1;
    this._compaundFound = false;
    this._biomoleculeFound = false;
    this._allowedChainsIDs = null;
    this._lastMolId = -1;
    this._remarks = {};
    this._remark = null;
    this._molecules = [];
    this._molecule = null;
    this._compndCurrToken = '';
    this._options.fileType = 'pdb';
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && pdbStartRegexp.test(data);
  }
  _finalize() {
    this._fixBondsArray();
    this._fixChains();

    // keep crystallographic symmetry transformations
    const remark290 = this._remarks[290];
    this._complex.symmetry = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark290) ? [] : remark290.matrices;

    // add loaded biological assemblies
    const remark350 = this._remarks[350];
    this._complex.units = this._complex.units.concat(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark350) ? [] : remark350.assemblies);

    // add loaded macromolecules
    this._finalizeMolecules();

    // create secondary structure etc.
    this._complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
  }
  _finalizeMolecules() {
    // get chains from complex
    const chainDict = {};
    let i;
    const chains = this._complex._chains;
    for (i = 0; i < chains.length; ++i) {
      const chainObj = chains[i];
      const chainName = chainObj._name;
      chainDict[chainName] = chainObj;
    }

    // aggregate residues from chains
    for (i = 0; i < this._molecules.length; i++) {
      const m = this._molecules[i];
      let residues = [];
      for (let j = 0; j < m._chains.length; j++) {
        const name = m._chains[j];
        const chain = chainDict[name];
        residues = residues.concat(chain._residues.slice());
      }
      const molecule = new PDBParser_Molecule(this._complex, m._name, i + 1);
      molecule.residues = residues;
      this._complex._molecules[i] = molecule;
    }
  }
  _fixChains() {
    const idChainMap = {};
    const complex = this._complex;

    // prepare
    for (let i = 0; i < complex._chains.length; i++) {
      const chain = complex._chains[i];
      idChainMap[chain._name.charCodeAt(0)] = chain;
    }
  }

  // FIXME: This function is redundant, CONECT records always follow ATOM and HETATM. Build the map online.
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap = {};
    const complex = this._complex;
    const atoms = complex._atoms;
    for (let i = 0, ni = atoms.length; i < ni; ++i) {
      const atom = atoms[i];
      serialAtomMap[atom.serial] = atom;
    }
    const bonds = complex._bonds;
    const {
      logger
    } = this;
    for (let j = 0, nj = bonds.length; j < nj; ++j) {
      const bond = bonds[j];
      if (bond._right < bond._left) {
        logger.debug('_fixBondsArray: Logic error.');
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _parseATOM(stream) {
    if (this._modelId !== 1) {
      return;
    }

    /* eslint-disable no-magic-numbers */
    const het = stream.readCharCode(1) === 0x48;

    // field names according to wwPDB Format
    // NOTE: Chimera allows (nonstandard) use of columns 6-11 for the integer atom serial number in ATOM records.
    const serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
    let name = stream.readString(13, 16);
    const altLoc = stream.readChar(17);
    const resName = stream.readString(18, 20).trim();
    const chainID = stream.readChar(22);
    const resSeq = stream.readInt(23, 26);
    const iCode = stream.readChar(27);
    const x = stream.readFloat(31, 38);
    const y = stream.readFloat(39, 46);
    const z = stream.readFloat(47, 54);
    const occupancy = stream.readFloat(55, 60);
    const tempFactor = stream.readFloat(61, 66);
    const element = stream.readString(77, 78).trim() || nameToElement(name);
    const charge = stream.readInt(79, 80) || 0;
    /* eslint-enable no-magic-numbers */
    // skip waters (there may be lots of them)
    if (this.settings.now.nowater) {
      if (resName === 'HOH' || resName === 'WAT') {
        return;
      }
    }

    // PDB uses positional system for atom names. It helps derive element type from the name
    // but names may include extra spaces. From this point on we don't need those spaces anymore.
    name = name.trim();
    const type = PDBParser_Element.getByName(element);
    const role = PDBParser_Element.Role[name]; // FIXME: Maybe should use type as additional index (" CA " vs. "CA  ")

    // NOTE: Residues of a particular chain are not required to be listed next to each other.
    // https://github.com/biasmv/pv/commit/7319b898b7473ba380c26699e3b028b2b1a7e1a1
    let chain = this._chain;
    if (!chain || chain.getName() !== chainID) {
      this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
      this._residue = null;
    }
    let residue = this._residue;
    if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
      this._residue = residue = chain.addResidue(resName, resSeq, iCode);
    }
    const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x, y, z);
    residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
  }
  _parseENDMDL() {
    this._modelId += 1;
  }
  _parseCONECT(stream) {
    /* eslint-disable no-magic-numbers */
    const serial0 = stream.readInt(7, 11);
    const serial1 = stream.readInt(12, 16);
    const serial2 = stream.readInt(17, 21);
    const serial3 = stream.readInt(22, 26);
    const serial4 = stream.readInt(27, 31);
    /* eslint-enable no-magic-numbers */

    const complex = this._complex;

    // Keep bonds ordered by atom serial
    if (serial1 && serial1 > serial0) {
      complex.addBond(serial0, serial1, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
    if (serial2 && serial2 > serial0) {
      complex.addBond(serial0, serial2, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
    if (serial3 && serial3 > serial0) {
      complex.addBond(serial0, serial3, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
    if (serial4 && serial4 > serial0) {
      complex.addBond(serial0, serial4, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
  }
  _parseCOMPND(stream) {
    /* eslint-disable no-magic-numbers */
    const str = stream.readString(11, 80);
    const tokenIdx = str.indexOf(':');
    this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;
    /* eslint-enable no-magic-numbers */

    // start reading new molecule
    if (this._compndCurrToken === 'MOL_ID') {
      this._molecule = {
        _index: '',
        _chains: []
      };
      this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(';')), 10);
      this._molecules.push(this._molecule);
      // parse molecule name
    } else if (this._compndCurrToken === 'MOLECULE' && this._molecule != null) {
      this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(';')).trim();
      // parse molecule chains
    } else if (this._compndCurrToken === 'CHAIN' && this._molecule != null) {
      let chainStr = str.substring(tokenIdx + 1, 80).trim();
      const lastChar = chainStr[chainStr.length - 1];
      if (lastChar === ';' || lastChar === ',') {
        chainStr = chainStr.slice(0, -1);
      }
      chainStr = chainStr.replace(/\s+/g, '');
      const chains = chainStr.split(',');
      this._molecule._chains = this._molecule._chains.concat(chains);
    }
  }
  _parseREMARK(stream) {
    /* eslint-disable no-magic-numbers */
    const remarkNum = stream.readInt(8, 10);
    /* eslint-enable no-magic-numbers */

    // create remark parser if needed
    let remark = this._remarks[remarkNum];
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark)) {
      const RemarkParser = remarkParsers[remarkNum];
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(RemarkParser)) {
        this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
      }
    }

    // delegate parsing
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark)) {
      remark.parse(stream);
    }
  }
  _parseHELIX(stream) {
    /* eslint-disable no-magic-numbers */
    const fields = [20, 22, 32, 34];
    /* eslint-enable no-magic-numbers */
    this._parseSTRUCTURE(stream, fields, obj => {
      this._complex.addHelix(obj);
      this._complex.structures.push(obj);
    });
  }
  _parseSHEET(stream) {
    /* eslint-disable no-magic-numbers */
    const fields = [22, 23, 33, 34];
    /* eslint-enable no-magic-numbers */
    this._parseSTRUCTURE(stream, fields, obj => {
      this._complex.addSheet(obj);
    });
  }
  _parseSTRUCTURE(stream, pars, adder) {
    const startId = 0;
    const startIndex = 1;
    const endId = 2;
    const endIndex = 3;

    // identify fields: debugging and stuff
    /* eslint-disable no-magic-numbers */
    const codeOfS = 0x53;
    const serialNumber = stream.readInt(8, 10);
    const structureName = stream.readString(12, 14).trim(); // FIXME: LString(3) forbids trim()
    const comment = stream.readString(41, 70).trim();
    const helLength = stream.readInt(72, 76);
    const helixClass = stream.readInt(39, 40);
    const shWidth = stream.readInt(15, 16);
    const shCur = stream.readInt(42, 45);
    const shPrev = stream.readInt(57, 60);
    /* eslint-enable no-magic-numbers */
    // file fields
    const startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
    const endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
    const startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
    let iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
    let startICode = 0;
    if (iCodeStr.length > 0) {
      startICode = iCodeStr.charCodeAt(0);
    }
    const endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
    iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
    let endICode = 0;
    if (iCodeStr.length > 0) {
      endICode = iCodeStr.charCodeAt(0);
    }
    let obj;
    let cs = this._sheet;
    if (stream.readCharCode(1) === codeOfS) {
      if (cs !== null && cs.getName() !== structureName) {
        cs = null;
        this._sheet = null;
      }
      if (cs === null) {
        this._sheet = obj = new PDBParser_Sheet(structureName, shWidth);
        adder(obj);
      } else {
        obj = cs;
      }
      const strand = new PDBParser_Strand(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
      obj.addStrand(strand);
      this._complex.structures.push(strand);
    } else {
      obj = new PDBParser_Helix(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
      adder(obj);
    }
  }
  _parseHEADER(stream) {
    const {
      metadata
    } = this._complex;
    metadata.classification = stream.readString(11, 50).trim();
    metadata.date = stream.readString(51, 59).trim();
    const id = stream.readString(63, 66).trim();
    metadata.id = id;
    if (id) {
      this._complex.name = id;
    }
    metadata.format = 'pdb';
  }
  _parseTITLE(stream) {
    const {
      metadata
    } = this._complex;
    metadata.title = metadata.title || [];
    const line = stream.readInt(9, 10) || 1;
    metadata.title[line - 1] = stream.readString(11, 80).trim();
  }
  static tagParsers = (() => ({
    HEADER: PDBParser.prototype._parseHEADER,
    'TITLE ': PDBParser.prototype._parseTITLE,
    'ATOM  ': PDBParser.prototype._parseATOM,
    HETATM: PDBParser.prototype._parseATOM,
    ENDMDL: PDBParser.prototype._parseENDMDL,
    CONECT: PDBParser.prototype._parseCONECT,
    COMPND: PDBParser.prototype._parseCOMPND,
    REMARK: PDBParser.prototype._parseREMARK,
    // 'SOURCE': PDBParser.prototype._parseSOURCE,
    'HELIX ': PDBParser.prototype._parseHELIX,
    'SHEET ': PDBParser.prototype._parseSHEET,
    // nonstandard extension to allow range 100,000 - 999,999
    'ATOM 1': PDBParser.prototype._parseATOM,
    'ATOM 2': PDBParser.prototype._parseATOM,
    'ATOM 3': PDBParser.prototype._parseATOM,
    'ATOM 4': PDBParser.prototype._parseATOM,
    'ATOM 5': PDBParser.prototype._parseATOM,
    'ATOM 6': PDBParser.prototype._parseATOM,
    'ATOM 7': PDBParser.prototype._parseATOM,
    'ATOM 8': PDBParser.prototype._parseATOM,
    'ATOM 9': PDBParser.prototype._parseATOM
  }))();
  parseSync() {
    const stream = new parsers_PDBStream(this._data);
    const result = this._complex = new PDBParser_Complex();

    // parse PDB line by line
    while (!stream.end()) {
      const tag = stream.readString(1, TAG_LENGTH);
      const func = PDBParser.tagParsers[tag];
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(func)) {
        func.call(this, stream);
      }
      stream.next();
    }

    // Resolve indices and serials to objects
    this._finalize();

    // cleanup
    this._serialAtomMap = null;
    this._sheet = null;
    this._residue = null;
    this._chain = null;
    this._complex = null;
    if (result.getAtomCount() === 0) {
      throw new Error('The data does not contain valid atoms');
    }
    return result;
  }
}
PDBParser.formats = ['pdb'];
PDBParser.extensions = ['.pdb', '.ent'];
/* harmony default export */ const parsers_PDBParser = (PDBParser);
;// CONCATENATED MODULE: ./src/io/parsers/CMLParser.js




const {
  Complex: CMLParser_Complex,
  Element: CMLParser_Element,
  SGroup: CMLParser_SGroup,
  Bond: CMLParser_Bond
} = chem;
const cOrderCharCodes = {
  A: 0,
  S: 1,
  D: 2,
  T: 3
};
const cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;
class CMLParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._complex = null;
    this._residue = null;
    this._serialAtomMap = null;
    this._modelId = 1;
    this._lastMolId = -1;
    this._readOnlyOneMolecule = false;
    this._options.fileType = 'cml';
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && cmlStartRegexp.test(data);
  }
  _rebuidBondIndexes(atoms, bonds) {
    const count = atoms.length;
    for (let i = 0; i < count; i++) {
      const atomId = atoms[i].id;
      const countBonds = bonds.length;
      for (let j = 0; j < countBonds; j++) {
        const idxs = bonds[j].atomRefs2.split(' ');
        if (idxs[0] === atomId) {
          bonds[j].start = i;
        }
        if (idxs[1] === atomId) {
          bonds[j].end = i;
        }
      }
    }
  }
  _createSGroup(molecule, moleculeArr) {
    const newGroup = new CMLParser_SGroup(molecule.id, molecule.fieldData, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);
    if (molecule.placement === 'Relative') {
      newGroup._center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    }
    if (molecule.fieldName === 'MDLBG_FRAGMENT_CHARGE') {
      newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
    }
    if (molecule.fieldName === 'MDLBG_FRAGMENT_COEFFICIENT') {
      newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
    }
    moleculeArr.push(newGroup);
  }
  _extractSGroup(molecule, moleculeArr) {
    if (!Array.isArray(moleculeArr)) {
      moleculeArr = [];
    }
    if (molecule) {
      if (Array.isArray(molecule)) {
        const count = molecule.length;
        for (let i = 0; i < count; i++) {
          if (molecule[i].molecule) {
            moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i].molecule));
          }
          this._createSGroup(molecule[i], moleculeArr);
        }
      } else {
        if (molecule.molecule) {
          if (molecule.molecule) {
            moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
          }
        }
        this._createSGroup(molecule, moleculeArr);
      }
    }
    return moleculeArr;
  }
  _extractSGroups(molecule, atoms) {
    const moleculeArr = this._extractSGroup(molecule);
    const count = atoms.length;
    let i;
    let j;
    for (i = 0; i < count; i++) {
      const atomId = atoms[i].id;
      for (j = 0; j < moleculeArr.length; j++) {
        const firstAtomRef = moleculeArr[j]._atoms.split(' ')[0];
        if (firstAtomRef === atomId) {
          if (!atoms[i].sgroupRef) {
            atoms[i].sgroupRef = [];
          }
          atoms[i].sgroupRef.push(moleculeArr[j]);
        }
      }
    }
    // build sGroups centers
    let atomMap = {}; // sgrpmap cache
    let mapEntry = null;
    const nLimon = 100000000;
    const bLow = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(nLimon, nLimon, nLimon);
    const bHight = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-nLimon, -nLimon, -nLimon);
    function cycleFuncInner(e) {
      mapEntry = atomMap[e];
      if (mapEntry) {
        moleculeArr[j]._atoms.push(mapEntry.a);
      }
    }
    function cycleFunc(e) {
      mapEntry = atomMap[e];
      if (mapEntry) {
        bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
        bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
        cycleFuncInner(e);
      }
    }
    for (i = 0; i < atoms.length; i++) {
      atomMap[atoms[i].id] = {};
      atomMap[atoms[i].id].x = atoms[i].x2;
      if (atoms[i].x3) {
        atomMap[atoms[i].id].x = atoms[i].x3;
      }
      atomMap[atoms[i].id].x = parseFloat(atomMap[atoms[i].id].x);
      atomMap[atoms[i].id].y = atoms[i].y2;
      if (atoms[i].y3) {
        atomMap[atoms[i].id].y = atoms[i].y3;
      }
      atomMap[atoms[i].id].y = parseFloat(atomMap[atoms[i].id].y);
      atomMap[atoms[i].id].z = '0.0';
      if (atoms[i].z3) {
        atomMap[atoms[i].id].z = atoms[i].z3;
      }
      atomMap[atoms[i].id].z = parseFloat(atomMap[atoms[i].id].z);
      atomMap[atoms[i].id].a = atoms[i];
    }
    let atomsRef;
    for (j = 0; j < moleculeArr.length; j++) {
      if (moleculeArr[j]._center !== null) {
        bLow.set(nLimon, nLimon, nLimon);
        bHight.set(-nLimon, -nLimon, -nLimon);
        atomsRef = moleculeArr[j]._atoms.split(' ');
        moleculeArr[j]._atoms = [];
        atomsRef.forEach(cycleFunc);
        moleculeArr[j]._center.addVectors(bLow, bHight);
        moleculeArr[j]._center.multiplyScalar(0.5);
      } else {
        atomsRef = moleculeArr[j]._atoms.split(' ');
        moleculeArr[j]._atoms = [];
        atomsRef.forEach(cycleFuncInner);
      }
    }
    atomMap = null;
  }
  _traverseData(dom) {
    function isArray(o) {
      return Object.prototype.toString.apply(o) === '[object Array]';
    }
    function parseNode(xmlNode, result) {
      if (xmlNode.nodeName === '#text' && xmlNode.nodeValue.trim() === '') {
        return;
      }
      const jsonNode = {};
      jsonNode.xmlNode = xmlNode;
      const existing = result[xmlNode.nodeName];
      if (existing) {
        if (!isArray(existing)) {
          result[xmlNode.nodeName] = [existing, jsonNode];
        } else {
          result[xmlNode.nodeName].push(jsonNode);
        }
      } else {
        result[xmlNode.nodeName] = jsonNode;
      }
      let length;
      let i;
      if (xmlNode.attributes) {
        ({
          length
        } = xmlNode.attributes);
        for (i = 0; i < length; i++) {
          const attribute = xmlNode.attributes[i];
          jsonNode[attribute.nodeName] = attribute.nodeValue;
        }
      }
      ({
        length
      } = xmlNode.childNodes);
      for (i = 0; i < length; i++) {
        parseNode(xmlNode.childNodes[i], jsonNode);
      }
    }
    const result = {};
    if (dom.childNodes.length) {
      parseNode(dom.childNodes[0], result);
    }
    return result;
  }
  _findSuitableMolecule(data, molSet) {
    for (const key in data) {
      if (key === 'xmlNode') {
        continue;
      } else if (key === 'molecule') {
        if (data.molecule) {
          if (data.molecule.atomArray && data.molecule.atomArray.atom) {
            molSet.push(data);
          }
          if (Array.isArray(data.molecule)) {
            for (let i = 0; i < data.molecule.length; i++) {
              if (data.molecule[i].atomArray && data.molecule[i].atomArray.atom) {
                molSet.push({
                  molecule: data.molecule[i]
                });
              }
            }
          }
        }
      } else if (data[key] && data[key] !== null && typeof data[key] === 'object') {
        this._findSuitableMolecule(data[key], molSet);
      }
    }
  }
  _selectComponents(text) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, 'application/xml');
    const traversedData = this._traverseData(doc);
    let rawData;
    const self = this;
    function prepareComponentCompound(data) {
      let atoms = [];
      if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
        if (!Array.isArray(data.molecule.atomArray.atom)) {
          atoms.push(data.molecule.atomArray.atom);
        } else {
          atoms = data.molecule.atomArray.atom;
        }
      } else if (!data.molecule) {
        const ret = {};
        ret.atomLabels = null;
        ret.labelsCount = 1;
        return ret;
      }
      if (data.molecule.molecule) {
        self._extractSGroups(data.molecule.molecule, atoms);
      }
      let atom;
      let count = atoms.length;
      for (let i = 0; i < count; i++) {
        atom = atoms[i];
        atom.edges = [];
      }
      let localBond = [];
      if (data.molecule.bondArray && data.molecule.bondArray.bond) {
        if (!Array.isArray(data.molecule.bondArray.bond)) {
          localBond.push(data.molecule.bondArray.bond);
        } else {
          localBond = data.molecule.bondArray.bond;
        }
      }
      let bond;
      count = localBond.length;
      self._rebuidBondIndexes(atoms, localBond);
      function addCurrBond(index) {
        bond = localBond[index];
        atom = atoms[bond.start];
        if (!atom) {
          return false;
        }
        atom.edges.push(bond.end);
        atom = atoms[bond.end];
        if (!atom) {
          return false;
        }
        atom.edges.push(bond.start);
        return true;
      }
      for (let i = 0; i < count; i++) {
        if (!addCurrBond(i)) {
          // ignore invalid bond
          continue;
        }
        const orderAttr = bond.xmlNode.getAttribute('order');
        const tc = parseInt(orderAttr, 10);
        // the default bond order is unknown
        localBond[i].order = 0;
        localBond[i].type = CMLParser_Bond.BondType.UNKNOWN;
        if (tc > 1) {
          localBond[i].order = tc;
        } else {
          // another option - bond order is a string
          const order = cOrderCharCodes[orderAttr];
          if (order !== undefined) {
            localBond[i].order = order;
            if (orderAttr === 'A') {
              localBond[i].type = CMLParser_Bond.BondType.AROMATIC;
            }
          }
        }
      }
      count = atoms.length;
      for (let i = 0; i < count; i++) {
        atom = atoms[i];
        atom.edges.sort();
      }
      const labels = self._breadWidthSearch(atoms, 0); // for now

      const retStruct = {};
      retStruct.atoms = atoms;
      retStruct.bonds = localBond;
      retStruct.labels = labels.atomLabels;
      retStruct.count = Math.min(1, labels.labelsCount); // for now
      retStruct.curr = -1;
      retStruct.originalCML = doc;
      return retStruct;
    }
    if (traversedData.cml) {
      rawData = traversedData.cml;
    } else {
      rawData = traversedData;
    }
    const retData = [];
    const filteredData = [];
    this._findSuitableMolecule(rawData, filteredData);
    if (this._readOnlyOneMolecule && filteredData.length > 1) {
      filteredData.splice(1, filteredData.length - 1);
    }
    filteredData.forEach(d => {
      const rd = prepareComponentCompound(d);
      if (rd.atoms.length > 0) {
        retData.push(rd);
      }
    });
    return retData;
  }
  _packLabel(compId, molId) {
    const shift = 16;
    return (molId << shift) + compId;
  }
  _unpackLabel(l) {
    const shift = 16;
    const mask = (1 << shift) - 1;
    return {
      molId: l >>> shift,
      compId: l & mask
    };
  }
  _breadWidthSearch(atoms, molID) {
    const atomLabels = new Array(atoms.length);
    let id;
    for (id = 0; id < atomLabels.length; id++) {
      atomLabels[id] = this._packLabel(0, molID);
    }
    const breadthQueue = [];
    let componentID = 0;
    let labeledAtoms = atoms.length;
    while (labeledAtoms > 0) {
      componentID++;
      let startID = -1;
      for (id = 0; id < atomLabels.length; id++) {
        if (this._unpackLabel(atomLabels[id]).compId === 0) {
          startID = id;
          break;
        }
      }
      if (startID < 0) {
        break;
      }

      // Bread first search
      breadthQueue.push(atoms[startID]);
      atomLabels[startID] = this._packLabel(componentID, molID);
      labeledAtoms--;
      while (breadthQueue.length > 0) {
        const curr = breadthQueue.shift();
        if (!curr) {
          continue;
        }
        for (let i = 0; i < curr.edges.length; i++) {
          if (atomLabels[curr.edges[i]] !== componentID) {
            breadthQueue.push(atoms[curr.edges[i]]);
            atomLabels[curr.edges[i]] = componentID;
            labeledAtoms--;
          }
        }
      }
    }
    const ret = {};
    ret.atomLabels = atomLabels;
    ret.labelsCount = componentID;
    return ret;
  }
  _parseBond(eAtom, mainAtom, order, type) {
    if (eAtom >= 0) {
      const h = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];
      this._complex.addBond(h[0], h[1], order, type, true);
    }
  }
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap = {};
    const complex = this._complex;
    const atoms = complex._atoms;
    for (let i = 0, ni = atoms.length; i < ni; ++i) {
      const atom = atoms[i];
      serialAtomMap[atom.serial] = atom;
    }
    const bonds = complex._bonds;
    const {
      logger
    } = this;
    for (let j = 0, nj = bonds.length; j < nj; ++j) {
      const bond = bonds[j];
      if (bond._right < bond._left) {
        logger.debug('_fixBondsArray: Logic error.');
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _parseSet(varData) {
    const complex = this._complex = new CMLParser_Complex();
    const data = varData;
    const currentLabel = data.curr;
    const {
      atoms,
      labels
    } = data;
    let atom = null;
    let i;
    let j;
    const count = atoms.length;
    function addFunc(a) {
      a.xmlNodeRef = atom;
      if (atom.x2) {
        atom.x3 = atom.x2;
        delete atom.x2;
      }
      if (atom.y2) {
        atom.y3 = atom.y2;
        delete atom.y2;
      }
      if (!atom.z3) {
        atom.z3 = '0.0';
      }
      atom.complexAtom = a;
    }
    let chains = {};
    // parse atoms in label order
    const reorder = [];
    for (i = 0; i < count; i++) {
      reorder.push(i);
    }
    reorder.sort((a, b) => labels[a] - labels[b]);
    for (i = 0; i < count; i++) {
      const atomCharge = 0;
      const lLabel = labels[reorder[i]];
      if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[reorder[i]];
        const atomFullNameStruct = atom.elementType;
        if (atom.sgroupRef) {
          const countRef = atom.sgroupRef.length;
          for (let k = 0; k < countRef; ++k) {
            complex._sgroups.push(atom.sgroupRef[k]);
          }
        }
        if (atom.x3 || atom.x2) {
          const currAtomComp = this._unpackLabel(lLabel).compId;
          // use ' ' by default instead of synthetic creation of chain names
          const chainID = ' '; //= String.fromCharCode('A'.charCodeAt(0) + currAtomComp);
          const resSeq = currAtomComp;
          const iCode = ' ';
          let strLabel = currAtomComp.toString();
          if (strLabel.length === 1) {
            strLabel = `0${strLabel}`;
          }
          const resName = `N${strLabel}`;
          let chain = chains[chainID];
          if (!chain || chain.getName() !== chainID) {
            chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
            this._residue = null;
          }
          let residue = this._residue;
          if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
            this._residue = residue = chain.addResidue(resName, resSeq, iCode);
          }

          // _x, _y, _z, mname, mindex, atomNameFull, atomName, chainID, serial, isHet, atlLocInd, atomNameToTypeF
          let xyz = null;
          if (atom.x3) {
            xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
          } else if (atom.x2) {
            xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
          }
          let element = CMLParser_Element.ByName[atom.elementType.toUpperCase()];
          if (!element) {
            element = JSON.parse(JSON.stringify(CMLParser_Element.ByName[Object.keys(CMLParser_Element.ByName)[Object.keys(CMLParser_Element.ByName).length - 1]]));
            element.number += 1;
            element.name = atom.elementType.toUpperCase();
            element.fullName = 'Unknown';
            CMLParser_Element.ByName[atom.elementType.toUpperCase()] = element;
          }
          const atomSerial = parseInt(atom.id.replace(/[^0-9]/, ''), 10);
          const added = residue.addAtom(atomFullNameStruct, element, xyz, CMLParser_Element.Role.SG, true, atomSerial, ' ', 1.0, 0.0, atomCharge);
          if (atom.hydrogenCount) {
            added.hydrogenCount = parseInt(atom.hydrogenCount, 10);
          }
          if (atom.mrvValence) {
            added.valence = parseInt(atom.mrvValence, 10);
          }
          addFunc(added);
        }
      }
    }
    chains = null; // NOSONAR
    for (i = 0; i < data.bonds.length; i++) {
      const cb = data.bonds[i];
      if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[cb.start];
        if (!atom || !atoms[cb.end]) {
          continue; // skip invalid
        }
        this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ''), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ''), 10), cb.order, cb.type);
      }
    }
    for (i = 0; i < this._complex.getSGroupCount(); i++) {
      const sGrp = this._complex.getSGroups()[i];
      for (j = 0; j < sGrp._atoms.length; j++) {
        sGrp._atoms[j] = sGrp._atoms[j].complexAtom;
      }
    }
    for (i = 0; i < count; i++) {
      if (this._unpackLabel(labels[i]).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[i];
        atom.complexAtom = null;
        delete atom.complexAtom;
      }
    }
    this._complex.originalCML = data.originalCML;
    this._fixBondsArray();
    complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
    this._serialAtomMap = null;
    this._complex = null;
    return complex;
  }
  parseSync() {
    const complexes = [];
    const self = this;
    const moleculaSet = this._selectComponents(this._data);
    moleculaSet.forEach(molSet => {
      molSet.curr = 2;
      if (molSet.count === 0) {
        molSet.count = 1;
      }
      for (let i = 0; i < molSet.count; i++) {
        molSet.curr = i + 1;
        complexes.push(self._parseSet(molSet, false));
      }
    });
    let totalAtomsParsed = 0;
    complexes.forEach(c => {
      totalAtomsParsed += c.getAtomCount();
    });
    if (totalAtomsParsed <= 0) {
      throw new Error('The data does not contain valid atoms');
    }
    if (complexes.length > 1) {
      const joinedComplex = new CMLParser_Complex();
      joinedComplex.joinComplexes(complexes);
      joinedComplex.originalCML = complexes[0].originalCML;
      return joinedComplex;
    }
    if (complexes.length === 1) {
      return complexes[0];
    }
    return new CMLParser_Complex();
  }
}
CMLParser.formats = ['cml'];
CMLParser.extensions = ['.cml'];
/* harmony default export */ const parsers_CMLParser = (CMLParser);
// EXTERNAL MODULE: ./vendor/js/mmtf.js
var mmtf = __webpack_require__(660);
var mmtf_default = /*#__PURE__*/__webpack_require__.n(mmtf);
;// CONCATENATED MODULE: ./src/io/parsers/MMTFParser.js






const {
  Complex: MMTFParser_Complex,
  Chain: MMTFParser_Chain,
  Atom: MMTFParser_Atom,
  Element: MMTFParser_Element,
  Helix: MMTFParser_Helix,
  Sheet: MMTFParser_Sheet,
  Strand: MMTFParser_Strand,
  Bond: MMTFParser_Bond,
  Assembly: MMTFParser_Assembly,
  Molecule: MMTFParser_Molecule
} = chem;
class ArrayComparator {
  constructor(original) {
    this._original = Array.from(original);
    this._original.sort();
    this._sum = 0;
    for (let i = 0; i < this._original.length; ++i) {
      this._sum += this._original[i];
    }
  }
  compare(candidate) {
    const len = candidate.length;
    if (len !== this._original.length) {
      return false;
    }
    let sum = 0;
    let i;
    for (i = 0; i < len; ++i) {
      sum += candidate[i];
    }
    if (sum !== this._sum) {
      return false;
    }
    const sorted = Array.from(candidate);
    sorted.sort();
    for (i = 0; i < len; ++i) {
      if (sorted[i] !== this._original[i]) {
        return false;
      }
    }
    return true;
  }
}
ArrayComparator.prototype.constructor = ArrayComparator;
const MMTFParser_StructuralElementType = chem_StructuralElement.Type;

// see https://github.com/rcsb/mmtf-javascript/blob/master/src/mmtf-traverse.js
const secStructToType = [MMTFParser_StructuralElementType.HELIX_PI,
// 0
MMTFParser_StructuralElementType.BEND,
// 1
MMTFParser_StructuralElementType.HELIX_ALPHA,
// 2
MMTFParser_StructuralElementType.STRAND,
// 3
MMTFParser_StructuralElementType.HELIX_310,
// 4
MMTFParser_StructuralElementType.BRIDGE,
// 5
MMTFParser_StructuralElementType.TURN,
// 6
MMTFParser_StructuralElementType.COIL // 7
];
function getFirstByte(buf) {
  const bytes = new Uint8Array(buf, 0, 1);
  return bytes[0];
}
class MMTFParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._options.fileType = 'mmtf';
  }
  static canProbablyParse(data) {
    // check if it's binary MessagePack format containing a map (dictionary)
    // see https://github.com/msgpack/msgpack/blob/master/spec.md
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArrayBuffer(data) && (getFirstByte(data) | 1) === 0xDF;
  }
  _onModel(_modelData) {}
  _onChain(chainData) {
    if (chainData.modelIndex !== 0) {
      return;
    }
    const chain = new MMTFParser_Chain(this._complex, chainData.chainName);
    this._complex._chains[chainData.chainIndex] = chain;
    chain._index = chainData.chainIndex;
  }
  _onGroup(groupData) {
    if (groupData.modelIndex !== 0) {
      return;
    }
    if (this.settings.now.nowater) {
      // skip water
      if (groupData.groupName === 'HOH' || groupData.groupName === 'WAT') {
        return;
      }
    }
    const chain = this._complex._chains[groupData.chainIndex];
    const icode = !groupData.insCode.charCodeAt(0) ? '' : groupData.insCode;
    const residue = chain.addResidue(groupData.groupName, groupData.groupId, icode);
    residue._index = groupData.groupIndex;
    this._updateSecStructure(this._complex, residue, groupData);
  }
  _onAtom(atomData) {
    if (atomData.modelIndex !== 0) {
      return;
    }
    const altLoc = !atomData.altLoc.charCodeAt(0) ? '' : atomData.altLoc;
    const atom = new MMTFParser_Atom(atomData.groupIndex,
    // we store residue index here to replace it later with actual reference
    atomData.atomName, MMTFParser_Element.getByName(atomData.element.toUpperCase()), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord), MMTFParser_Element.Role[atomData.atomName], false,
    // hetero atoms will be marked later
    atomData.atomId, altLoc, atomData.occupancy, atomData.bFactor, atomData.formalCharge);
    this._complex._atoms[atomData.atomIndex] = atom;
    atom.index = atomData.atomIndex;
    this._serialAtomMap[atomData.atomId] = atom;
  }
  _onBond(bondData) {
    const right = Math.max(bondData.atomIndex1, bondData.atomIndex2);
    if (right >= this._complex._atoms.length) {
      return;
    }
    const left = Math.min(bondData.atomIndex1, bondData.atomIndex2);
    this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, MMTFParser_Bond.BondType.UNKNOWN, true);
  }
  _updateSecStructure(complex, residue, groupData) {
    const helixClasses = [3, -1, 1, -1, 5];
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(groupData) && groupData.secStruct === this._ssType) {
      residue._secondary = this._ssStruct;
      if (this._ssStruct) {
        this._ssStruct.term = residue;
      }
      return;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(groupData)) {
      // start new secondary structure
      const type = secStructToType[groupData.secStruct];
      this._ssType = groupData.secStruct;
      this._ssStart = residue;
      let struct = null;
      switch (this._ssType) {
        case -1: // undefined
        case 7:
          // coil
          break;
        case 0: // pi helix
        case 2: // alpha helix
        case 4:
          // 3-10 helix
          struct = new MMTFParser_Helix(helixClasses[this._ssType], residue, residue, 0, '', '', 0);
          complex._helices.push(struct);
          break;
        case 3:
          {
            // extended
            const sheet = new MMTFParser_Sheet('', 0);
            complex._sheets.push(sheet);
            struct = new MMTFParser_Strand(sheet, residue, residue, 0, null, null);
            break;
          }
        default:
          if (type !== undefined) {
            struct = new chem_StructuralElement(type, residue, residue);
          }
          break;
      }
      this._ssStruct = struct;
      residue._secondary = struct;
      if (struct) {
        complex.structures.push(struct);
      }
    }
  }
  _updateMolecules(mmtfData) {
    const entities = mmtfData.entityList;
    if (!entities) {
      return;
    }
    const chainsInModel0 = mmtfData.chainsPerModel[0];
    for (let i = 0; i < entities.length; i++) {
      const entity = entities[i];
      const chains = entity.chainIndexList;
      let residues = [];
      for (let j = 0; j < chains.length; j++) {
        const chainIndex = chains[j];
        // skip chains in models other than the first one
        if (chainIndex >= chainsInModel0) {
          continue;
        }
        const chain = this._complex._chains[chainIndex];
        residues = residues.concat(chain._residues.slice());
      }
      const molecule = new MMTFParser_Molecule(this._complex, entity.description, i + 1);
      molecule.residues = residues;
      this._complex._molecules[i] = molecule;
    }
  }

  // populate complex with chains, residues and atoms
  _traverse(mmtfData) {
    const self = this;

    // get metadata
    const {
      metadata
    } = this._complex;
    metadata.id = mmtfData.structureId;
    metadata.title = [];
    metadata.title[0] = mmtfData.title;
    metadata.date = mmtfData.releaseDate;
    metadata.format = 'mmtf';

    // create event callback functions
    const eventCallbacks = {
      onModel(modelData) {
        self._onModel(modelData);
      },
      onChain(chainData) {
        self._onChain(chainData);
      },
      onGroup(groupData) {
        self._onGroup(groupData);
      },
      onAtom(atomData) {
        self._onAtom(atomData);
      },
      onBond(bondData) {
        self._onBond(bondData);
      }
    };

    // temporary variables used during traversal to track secondary structures
    this._ssType = -1;
    this._ssStruct = null;
    this._ssStart = null;

    // traverse the structure and listen to the events
    mmtf_default().traverse(mmtfData, eventCallbacks);
    this._updateSecStructure(this._complex);
    this._updateMolecules(mmtfData);
  }

  // During traversal atoms and residues don't come sequentially
  // so a residue for certain atom can be unavailable. Thus we
  // store residue index in atom.
  // This function being called after traversal replaces the index
  // with actual reference, and also populates atom lists in residues.
  _linkAtomsToResidues() {
    for (let i = 0; i < this._complex._atoms.length; ++i) {
      const atom = this._complex._atoms[i];
      const residue = this._complex._residues[atom.residue];
      atom.residue = residue;
      residue._atoms.push(atom);
    }
  }
  _findSynonymousChains() {
    const named = {};
    for (let i = 0; i < this._complex._chains.length; ++i) {
      const chain = this._complex._chains[i];
      const name = chain.getName();
      if (!named.hasOwnProperty(name)) {
        named[name] = [];
      }
      named[name].push(chain._index);
    }
    return named;
  }

  // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.
  _parseAssemblyInfo(mmtfData) {
    let i;
    let j;
    let k;
    const assemblies = [];
    const {
      logger
    } = this;
    for (i = 0; i < mmtfData.bioAssemblyList.length; ++i) {
      const baInfo = mmtfData.bioAssemblyList[i];
      if (baInfo.transformList.length === 0) {
        continue;
      }
      const chains = baInfo.transformList[0].chainIndexList;
      const chainListCheck = new ArrayComparator(chains);

      // build list of chain names
      const chainNames = {};
      for (j = 0; j < chains.length; ++j) {
        chainNames[this._complex._chains[chains[j]].getName()] = 1;
      }

      // all chains with the same name should belong to assembly if one of them belongs
      const allChains = [];
      let name;
      for (name in chainNames) {
        if (chainNames.hasOwnProperty(name)) {
          // just concat arrays -- there should be no duplicates
          Array.prototype.push.apply(allChains, this._chainsByName[name]);
        }
      }
      if (!chainListCheck.compare(allChains)) {
        // assembly is missing some of the chains
        logger.debug('MMTF: Assembly is missing some of the synonymous chains. Skipping...');
      }
      const a = new MMTFParser_Assembly(this._complex);

      // add chains to assembly
      for (name in chainNames) {
        if (chainNames.hasOwnProperty(name)) {
          a.addChain(name);
        }
      }

      // add unique matrices to assembly
      a.addMatrix(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());
      for (j = 1; j < baInfo.transformList.length; ++j) {
        const transform = baInfo.transformList[j];
        if (!chainListCheck.compare(transform.chainIndexList)) {
          // list of chains for this transform doesn't match that for other transforms
          // this is illegal in our structure
          logger.debug('MMTF: Chain lists differ for different transforms in one assembly. Skipping...');
          continue;
        }
        const m = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().fromArray(transform.matrix).transpose();

        // check if matrix is already in the list
        for (k = 0; k < a.matrices.length; ++k) {
          if (a.matrices[k].equals(m)) {
            break;
          }
        }
        if (k === a.matrices.length) {
          a.addMatrix(m);
        }
      }
      a.finalize();
      assemblies.push(a);
    }
    return assemblies;
  }

  // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.
  _markHeteroAtoms(mmtfData) {
    const chainsInModel0 = mmtfData.chainsPerModel[0];
    for (let i = 0; i < mmtfData.entityList.length; ++i) {
      const entity = mmtfData.entityList[i];
      if (entity.type !== 'polymer') {
        for (let j = 0; j < entity.chainIndexList.length; ++j) {
          const chainIndex = entity.chainIndexList[j];
          // skip chains in models other than the first one
          if (chainIndex >= chainsInModel0) {
            continue;
          }
          const chain = this._complex._chains[chainIndex];
          for (let k = 0; k < chain._residues.length; ++k) {
            const res = chain._residues[k];
            for (let m = 0; m < res._atoms.length; ++m) {
              res._atoms[m].het = true;
            }
          }
        }
      }
    }
  }

  // joins chains with the same name into single chain
  _joinSynonymousChains() {
    let i;
    let j;
    const primaryChainsArray = [];
    const primaryChainsHash = {};

    // join chains
    for (i = 0; i < this._complex._chains.length; ++i) {
      const chain = this._complex._chains[i];
      const name = chain.getName();
      if (!primaryChainsHash.hasOwnProperty(name)) {
        // new name -- this is a primary chain
        primaryChainsHash[name] = chain;
        chain._index = primaryChainsArray.length; // update index as this array will later replace original chain list
        primaryChainsArray.push(chain);
        continue;
      }

      // this chain should be joined with the primary chain of the same name
      const primary = primaryChainsHash[name];
      for (j = 0; j < chain._residues.length; ++j) {
        const residue = chain._residues[j];
        primary._residues.push(residue);
        residue._chain = primary;
      }
    }

    // replace chains list with one containing only primary chains
    // dropping references to all chains but primary
    this._complex._chains = primaryChainsArray;
  }
  parseSync() {
    const mmtfData = mmtf_default().decode(this._data);
    this._complex = new MMTFParser_Complex();
    this._serialAtomMap = {}; // filled during traversal

    this._traverse(mmtfData);
    this._linkAtomsToResidues();
    this._markHeteroAtoms(mmtfData);
    this._chainsByName = this._findSynonymousChains();
    Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));
    this._joinSynonymousChains();
    this._complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
    return this._complex;
  }
}
MMTFParser.formats = ['mmtf'];
MMTFParser.extensions = ['.mmtf'];
MMTFParser.binary = true;
/* harmony default export */ const parsers_MMTFParser = (MMTFParser);
;// CONCATENATED MODULE: ./src/io/parsers/ParsingError.js
class ParsingError extends Error {
  constructor(message, line, column) {
    super(`data:${line}:${column}: ${message}`);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ParsingError);
    }
    this.name = 'ParsingError';
    this.parseLine = line;
    this.parseColumn = column;
  }
}
/* harmony default export */ const parsers_ParsingError = (ParsingError);
;// CONCATENATED MODULE: ./src/io/parsers/readCIF.js



// Implemented and being tested against: https://www.iucr.org/resources/cif/spec/version1.1/cifsyntax

function _isWhitespace(ch) {
  return ch === 32 || ch === 10 || ch === 13 || ch === 9;
}
function _inlineIndexOf(ch0, str, idx) {
  const len = str.length;
  let ch = -1;
  while (idx < len) {
    ch = str.charCodeAt(idx);
    if (ch === ch0 || ch === 10) {
      break;
    }
    ++idx;
  }
  return ch === ch0 ? idx : -1;
}
function readCIF(source) {
  let i = 0;
  let j = 0;
  const n = source.length;
  let code = NaN;
  let newline = true;
  let line = 1;
  let column = 1;
  let begin;
  let state = 0; // 0 - start, 1 - block, 2 - item, 3 - loop, 4 - values, 5 - value
  const result = {};
  let block = {};
  let keys = [];
  let keysCount = 0;
  let key = '';
  let values = [];
  let valuesCount = 0;
  let value;
  function _parseValue() {
    let val;
    if ((code === 46 || code === 63) && (i + 1 >= n || _isWhitespace(source.charCodeAt(i + 1)))) {
      // '.' or '?' .....
      // it's a missing value
      ++column;
      ++i;
      return undefined;
    }
    if (newline && code === 59) {
      // ';' ......................................................................
      // parse multi-line string
      j = i;
      let lines = 0;
      do {
        j = _inlineIndexOf(10, source, j + 1); // '\n'
        if (j === -1) {
          throw new parsers_ParsingError('Unterminated text block found', line, column);
        }
        ++lines;
      } while (j + 1 < n && source.charCodeAt(j + 1) !== code || j + 1 >= n);
      val = source.substring(i + 1, j).replace(/\r/g, '');
      i = j + 2;
      line += lines;
      column = 1;
      newline = false;
      return val;
    }
    if (code === 39 || code === 34) {
      // ''' or '"' ...........................................................
      // parse quoted string
      j = i;
      do {
        j = _inlineIndexOf(code, source, j + 1);
        if (j === -1) {
          throw new parsers_ParsingError('Unterminated quoted string found', line, column);
        }
      } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)));
      val = source.substring(i + 1, j);
      column += j - i + 1;
      i = j + 1;
      return val;
    } // ......................................................................................................
    // parse until the first whitespace
    j = i;
    while (j < n && !_isWhitespace(source.charCodeAt(j))) {
      ++j;
    }
    val = source.substring(i, j);
    column += j - i;
    i = j;
    // try to convert to a number
    const num = Number(val);
    if (!Number.isNaN(num)) {
      return num;
    }
    // or leave as an unquoted string
    return val;
  }
  function _storeKey(tag) {
    keys[keysCount++] = tag;
  }
  function _storeValue(val) {
    const keyIndex = valuesCount % keysCount;
    values[keyIndex].push(val);
    ++valuesCount;
    return val;
  }
  while (i <= n) {
    code = source.charCodeAt(i); // 'NaN' in place of '<eof>'
    if (code === 13) {// '\r' .......................................................................................
      // just ignore
    } else if (code === 10) {
      // '\n' ................................................................................
      // take note of new lines
      newline = true;
      ++line;
      column = 1;
    } else {
      // process inline characters
      if (code === 32 || code === 9) {// ' ' or '\t' ................................................................
        // just ignore
      } else if (code === 35) {
        // '#' ...............................................................................
        // skip the comment until before the end of the line
        i = _inlineIndexOf(10, source, i + 1); // '\n'
        if (i === -1) {
          break;
        } else {
          continue; // don't forget to process the new line
        }
      } else if (state === 0) {
        // start =============================================================================
        if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
          // 'data_' ..........
          j = i + 5;
          begin = j;
          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
            ++j;
          }
          column += j - i;
          i = j;
          if (begin < i) {
            // add new data block
            result[source.substring(begin, i)] = block = {};
            state = 1; // block
            continue; // don't forget to process the whitespace
          } else {
            throw new parsers_ParsingError('Data block name missing', line, column);
          }
        } else if (Number.isNaN(code)) {
          // <eof> ....................................................................
          break;
        } else {
          // ..................................................................................................
          throw new parsers_ParsingError(`Unexpected character in state ${state}`, line, column);
        }
      } else if (state === 1) {
        // block =============================================================================
        if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
          // 'data_' ..........
          state = 0; // start
          continue; // parse again in a different state
        } else if (code === 95) {
          // '_' .............................................................................
          j = i + 1;
          begin = j;
          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
            ++j;
          }
          column += j - i;
          i = j;
          if (begin < i) {
            // start new item
            key = source.substring(begin, i);
            state = 2; // item
            continue; // don't forget to process the whitespace
          } else {
            throw new parsers_ParsingError('Tag name missing', line, column);
          }
        } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
          // 'loop_' ...
          i += 5;
          column += 5;
          if (i < n && !_isWhitespace(source.charCodeAt(i))) {
            throw new parsers_ParsingError(`Unexpected character in state ${state}`, line, column);
          } else {
            // start new loop
            keys = [];
            keysCount = 0;
            values = [];
            valuesCount = 0;
            state = 3; // loop
            continue; // don't forget to process the whitespace
          }
        } else if (Number.isNaN(code)) {
          // <eof> ....................................................................
          break;
        } else {
          // ..................................................................................................
          throw new parsers_ParsingError(`Unexpected character in state ${state}`, line, column);
        }
      } else if (state === 2) {
        // item ==============================================================================
        if (Number.isNaN(code)) {
          break;
        }
        value = _parseValue();
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(block, key, value);
        state = 1; // block
        continue;
      } else if (state === 3) {
        // loop ==============================================================================
        if (code === 95) {
          // '_' ....................................................................................
          j = i + 1;
          begin = j;
          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
            ++j;
          }
          column += j - i;
          i = j;
          if (begin < i) {
            // add new key
            _storeKey(source.substring(begin, i));
            continue; // don't forget to process the whitespace
          } else {
            throw new parsers_ParsingError('Tag name missing', line, column);
          }
        } else {
          // ..................................................................................................
          if (keysCount > 0) {
            for (let keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
              value = [];
              values[keyIndex] = value;
              external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(block, keys[keyIndex], value);
            }
            state = 4;
            continue; // parse again in a different state
          }
          throw new parsers_ParsingError('Data tags are missing inside a loop', line, column);
        }
      } else if (state === 4) {
        // values ============================================================================
        if ((code === 68 || code === 100) && source.substr(i + 1, 4).toLowerCase() === 'ata_') {
          // 'data_' ..........
          state = 0; // start
        } else if (code === 95) {
          // '_' .............................................................................
          state = 1; // block
        } else if ((code === 76 || code === 108) && source.substr(i + 1, 4).toLowerCase() === 'oop_') {
          // 'loop_' ...
          state = 1; // block
        } else if (Number.isNaN(code)) {
          // <eof> ....................................................................
          state = 0;
        } else {
          // ..................................................................................................
          _storeValue(_parseValue());
        }
        continue; // parse again in a different state
      } else {
        // ====================================================================================================
        throw new parsers_ParsingError(`Unexpected internal state ${state}`, line, column);
      }
      newline = false;
      ++column;
    }
    ++i;
  }
  if (state === 2) {
    // item
    throw new parsers_ParsingError(`Unexpected end of file in state ${state}`, line, column);
  }
  return result;
}
;// CONCATENATED MODULE: ./src/io/parsers/CIFParser.js






const {
  Complex: CIFParser_Complex,
  Element: CIFParser_Element,
  Helix: CIFParser_Helix,
  Sheet: CIFParser_Sheet,
  Strand: CIFParser_Strand,
  Assembly: CIFParser_Assembly,
  Molecule: CIFParser_Molecule
} = chem;
const cRequiredAtomFields = ['auth_seq_id', 'Cartn_x', 'Cartn_y', 'Cartn_z', 'label_atom_id'];
const cSecondaryCoding = {
  helx: 'helix',
  turn: 'turn',
  strn: 'strand'
};
function getTypeFromId(string) {
  const typeId = /[A-Za-z]+/.exec(string);
  if (!typeId) {
    return null;
  }
  return cSecondaryCoding[typeId[0].toLowerCase()];
}

/**
 * Make valid object an array
 * @param arrayLikeObject
 * @return {array, object} array or object
 */
function arrize(arrayLikeObject) {
  if (arrayLikeObject === null || arrayLikeObject === undefined || external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(arrayLikeObject)) {
    return arrayLikeObject;
  }
  return [arrayLikeObject];
}
function CIFParser_nameToElement(name) {
  // http://www.wwpdb.org/documentation/file-format-content/format33/sect9.html#ATOM
  //
  // http://www.cgl.ucsf.edu/chimera/docs/UsersGuide/tutorials/pdbintro.html#note1
  //
  // Atom names start with element symbols right-justified in columns 13-14
  // as permitted by the length of the name. For example, the symbol FE for
  // iron appears in columns 13-14, whereas the symbol C for carbon appears
  // in column 14 (see Misaligned Atom Names). If an atom name has four
  // characters, however, it must start in column 13 even if the element
  // symbol is a single character (for example, see Hydrogen Atoms).

  const veryLong = name.trim().length === 4;
  return name.slice(0, veryLong ? 1 : 2).trim();
}
class AtomDataError extends Error {
  constructor(message) {
    super();
    this.name = 'AtomDataError';
    this.message = message;
  }
}
function _getOperations(operList) {
  if (!operList) {
    return null;
  }
  const idc = arrize(operList.id);
  const {
    matrix,
    vector
  } = operList;
  if (!idc || !matrix || !vector) {
    return null;
  }
  const ops = [];
  for (let i = 0, n = idc.length; i < n; ++i) {
    const mtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const {
      elements
    } = mtx;
    for (let row = 0; row < 3; ++row) {
      const matrixData = matrix[row + 1];
      elements[row] = arrize(matrixData[1])[i];
      elements[row + 4] = arrize(matrixData[2])[i];
      elements[row + 8] = arrize(matrixData[3])[i];
      elements[row + 12] = arrize(vector[row + 1])[i];
    }
    ops[idc[i]] = mtx;
  }
  return ops;
}
function _extractOperations(assemblyGen, opsDict) {
  assemblyGen = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(assemblyGen) ? assemblyGen : `${assemblyGen}`;
  const l = assemblyGen.replace(/\)\s*\(/g, '!').replace(/[()']/g, '');
  const groupStr = l.split('!');
  const gps = [];
  for (let grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
    const gr = groupStr[grIdx].split(',');
    const gp = [];
    let idx = 0;
    for (let i = 0, n = gr.length; i < n; ++i) {
      const s = gr[i];
      if (s.includes('-')) {
        const es = s.split('-');
        let j = parseInt(es[0], 10);
        const m = parseInt(es[1], 10);
        for (; j <= m; ++j) {
          gp[idx++] = opsDict[j];
        }
      } else {
        gp[idx++] = opsDict[s];
      }
    }
    gps.push(gp);
  }

  // traverse all groups from the end of array and make all mults
  const matrices = [];
  let cnt = 0;
  function traverse(level, mtx) {
    for (let ii = 0, nn = gps[level].length; ii < nn; ++ii) {
      const newMtx = mtx ? mtx.clone() : new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
      newMtx.multiplyMatrices(gps[level][ii], newMtx);
      if (level === 0) {
        matrices[cnt++] = newMtx;
      } else {
        traverse(level - 1, newMtx);
      }
    }
  }
  traverse(gps.length - 1);
  return matrices;
}
class CIFParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this.asymDict = {};
    this.molecules = [];
    this._options.fileType = 'cif';
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && /^\s*data_/i.test(data);
  }
  parseSync() {
    this.logger.info('Parsing CIF file..');
    const data = readCIF(this._data);
    return this._toComplex(data);
  }

  /**
   * Convert intermediate structure into our valid Complex object
   * @param cifData intermediate CIF object
   * @returns {Complex} complex
   * @private
   */
  _toComplex(cifData) {
    const complex = new CIFParser_Complex();
    const complexData = cifData[Object.keys(cifData)[0]];
    this._extractAtoms(complex, complexData);
    this._extractSecondary(complex, complexData);
    this._extractAssemblies(complex, complexData);
    this._extractMolecules(complex, complexData);
    this._extractMetadata(complex, complexData);
    complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing
    });
    return complex;
  }

  /**
   * Extract metadata
   * @param complex structure to fill
   * @param complexData complex data from CIF file
   * @private
   */

  _extractMetadata(complex, complexData) {
    const {
      metadata
    } = complex;
    metadata.id = complexData.entry.id;
    metadata.classification = complexData.struct_keywords.pdbx_keywords;
    const databaserev = complexData.database_PDB_rev;
    metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : '';
    metadata.format = 'cif';
    metadata.title = [];
    metadata.title[0] = complexData.struct.title;
  }

  /**
   * Extract molecules information from CIF structure (should be called strictly after _extractAtoms)
   * @param complexData complex data from CIF file
   * @private
   */
  _extractMolecules(complex, complexData) {
    const molData = complexData.entity;
    const names = arrize(molData.pdbx_description);
    const count = names.length;
    let i;

    // molecules names from cif
    for (i = 0; i < count; i++) {
      if (this.molecules[i]) {
        // molecule was created during atoms processing
        this.molecules[i].name = names[i];
      } else {
        // molecule wasn't created, because there is no atom which is contained
        this.molecules[i] = {
          name: names[i],
          residues: []
        };
      }
    }

    // reorganize molecules for complex and check chains
    const molecules = complex.getMolecules();
    for (i = 0; i < count; i++) {
      const molecule = this.molecules[i];
      molecules[i] = new CIFParser_Molecule(complex, molecule.name, i + 1);
      molecules[i].residues = molecule.residues;
    }
  }

  /**
   * Extract atom information from CIF structure and fill complex
   * @param {Complex} complex
   * @param complexData complex data from CIF file
   * @private
   */
  _extractAtoms(complex, complexData) {
    const atomData = complexData.atom_site;
    if (!atomData) {
      throw new AtomDataError('CIF parsing error: atom_site is not specified!');
    }
    for (let f = 0, n = cRequiredAtomFields.length; f < n; ++f) {
      if (!atomData[cRequiredAtomFields[f]]) {
        throw new AtomDataError(`CIF parsing error: requires field ${cRequiredAtomFields[f]} not found!`);
      }
    }
    const {
      asymDict
    } = this;
    // required fields
    const resIdc = arrize(atomData.auth_seq_id);
    const x = arrize(atomData.Cartn_x);
    const y = arrize(atomData.Cartn_y);
    const z = arrize(atomData.Cartn_z);
    const names = arrize(atomData.label_atom_id);
    const count = names.length;
    // optional fields
    const group = arrize(atomData.group_PDB) || [];
    const chainIdc = arrize(atomData.auth_asym_id) || [];
    const chainLabelIdc = arrize(atomData.label_asym_id) || [];
    const serials = arrize(atomData.id) || [];
    const iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
    const resNames = arrize(atomData.label_comp_id) || [];
    const elements = arrize(atomData.type_symbol) || [];
    const tempFactors = arrize(atomData.B_iso_or_equiv) || [];
    const occupancies = arrize(atomData.occupancy) || [];
    const charges = arrize(atomData.pdbx_formal_charge) || [];
    const altLocs = arrize(atomData.label_alt_id) || [];
    const models = arrize(atomData.pdbx_PDB_model_num) || [];
    const molecules = arrize(atomData.label_entity_id) || [];
    let chain = null;
    let residue = null;
    for (let i = 0; i < count; ++i) {
      const model = models[i] || 1;
      if (model !== 1) {
        continue;
      }
      const chainID = String(chainIdc[i] || ' ');
      if (!chain || chain.getName() !== chainID) {
        chain = complex.getChain(chainID) || complex.addChain(chainID);
      }
      asymDict[String(chainLabelIdc[i] || ' ')] = chainID;
      const resSeq = resIdc[i];
      const iCode = String(iCodes[i] || ' ');
      const resName = String(resNames[i] || '');
      if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
        residue = chain.addResidue(resName, resSeq, iCode);

        // store residue in appropriate molecule
        const moleculeIdx = molecules[i] - 1;
        let entity = this.molecules[moleculeIdx];
        if (!entity) {
          // create new molecule if it hasn't been created
          this.molecules[moleculeIdx] = {
            name: '',
            residues: []
          };
          entity = this.molecules[moleculeIdx];
        }
        entity.residues.push(residue);
      }
      const name = names[i];
      const element = elements[i] || CIFParser_nameToElement(name);
      const type = CIFParser_Element.getByName(element);
      const role = CIFParser_Element.Role[name.trim()];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x[i], y[i], z[i]);
      const het = group[i] === 'HETATM' || false;
      const serial = serials[i] || i;
      const tempFactor = tempFactors[i] || 0.0;
      const occupancy = occupancies[i] || 0.0;
      const altLoc = String(altLocs[i] || '');
      const charge = charges[i] || 0;
      residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    }
  }

  /**
   * Extracts secondary structure information from CIF intermediate data
   * and adds it into complex
   * @param {Complex} complex - complex to fill
   * @param complexData - CIF complex data
   * @private
   */
  _extractSecondary(complex, complexData) {
    if (complexData.struct_conf) {
      this._extractConfs(complex, complexData.struct_conf);
    }
    if (complexData.struct_sheet_range) {
      this._extractSheets(complex, complexData.struct_sheet_range);
    }
  }

  /**
   * Extracts sheets information from CIF intermediate data
   * and adds it into complex
   * @param {Complex} complex
   * @param sheetData
   * @private
   */
  _extractSheets(complex, sheetData) {
    const {
      asymDict
    } = this;
    if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
      return;
    }
    // Strand(sheet, start, end, sense, cur, prev)
    const sheets = complex._sheets;
    function getSheet(name) {
      const n = sheets.length;
      for (let i = 0; i < n; ++i) {
        if (sheets[i]._name === name) {
          return sheets[i];
        }
      }
      sheets[n] = new CIFParser_Sheet(name, 0);
      return sheets[n];
    }
    const sheetNames = arrize(sheetData.sheet_id);
    const strandNames = arrize(sheetData.id);
    const starts = arrize(sheetData.beg_auth_seq_id);
    const ends = arrize(sheetData.end_auth_seq_id);
    const chains = arrize(sheetData.beg_label_asym_id);
    const stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
    const endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];
    for (let i = 0, n = strandNames.length; i < n; ++i) {
      const chain = complex.getChain(asymDict[chains[i]]);
      const sheet = getSheet(sheetNames[i]);
      const startIdx = starts[i];
      const endIdx = ends[i];
      const startICode = stICodes[i] || ' ';
      const endICode = endICodes[i] || ' ';
      const start = chain.findResidue(startIdx, startICode);
      const end = chain.findResidue(endIdx, endICode);

      // TODO think about last condition
      if (!start || !end) {
        continue;
      }
      const strand = new CIFParser_Strand(sheet, start[0], end[0], 0, null, null);
      const residues = chain.getResidues();
      for (let r = start[1]; r <= end[1]; ++r) {
        residues[r]._secondary = strand;
      }
      sheet.addStrand(strand);
      complex.structures.push(strand);
    }
  }

  /**
   * Extracts helix/turn/strand(?) information from CIF intermediate data
   * and adds it into complex
   * @param {Complex} complex
   * @param helicesData
   * @private
   */
  _extractConfs(complex, helicesData) {
    const {
      asymDict
    } = this;
    if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
      return;
    }
    const types = arrize(helicesData.conf_type_id);
    const starts = arrize(helicesData.beg_auth_seq_id);
    const stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
    const ends = arrize(helicesData.end_auth_seq_id);
    const endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
    const comments = arrize(helicesData.details) || [];
    const lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
    const helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
    const names = arrize(helicesData.id) || [];
    const chains = arrize(helicesData.beg_label_asym_id);
    for (let i = 0, n = types.length; i < n; ++i) {
      const type = getTypeFromId(types[i]);
      if (!type) {
        continue;
      }
      const name = names[i] || types[i];
      const chain = complex.getChain(asymDict[chains[i]]);
      const startIdx = starts[i];
      const endIdx = ends[i];
      const startICode = stICodes[i] || ' ';
      const endICode = endICodes[i] || ' ';
      const start = chain.findResidue(startIdx, startICode);
      const end = chain.findResidue(endIdx, endICode);

      // TODO think about last condition
      if (!start || !end) {
        continue;
      }
      const comment = comments[i] || '';
      const length = lengths[i] || 0;
      const helixClass = helixClasses[i] || ' ';
      let struct;
      if (type === 'helix') {
        const idx = complex._helices.length;
        struct = new CIFParser_Helix(helixClass, start[0], end[0], idx, name, comment, length);
        complex.addHelix(struct);
        complex.structures.push(struct);
      } else if (type === 'turn') {
        struct = new chem_StructuralElement(chem_StructuralElement.Type.TURN, start[0], end[0]);
        complex.structures.push(struct);
      } else {
        struct = null;
      }
      if (!struct) {
        continue;
      }
      const residues = chain.getResidues();
      for (let r = start[1]; r <= end[1]; ++r) {
        residues[r]._secondary = struct;
      }
    }
  }

  /**
   * Extract biological assemblies information from CIF structure and fill complex
   * @param {Complex} complex
   * @param complexData complex data from CIF file
   * @private
   */
  _extractAssemblies(complex, complexData) {
    const {
      asymDict
    } = this;
    const asmGen = complexData.pdbx_struct_assembly_gen;
    if (!asmGen) {
      return;
    }
    const asmIdx = arrize(asmGen.assembly_id);
    const asmOper = arrize(asmGen.oper_expression);
    const asmList = arrize(asmGen.asym_id_list);
    if (!asmIdx || !asmOper || !asmList) {
      return;
    }
    const operList = _getOperations(complexData.pdbx_struct_oper_list);
    if (!operList) {
      return;
    }
    for (let i = 0, n = asmIdx.length; i < n; ++i) {
      const asm = new CIFParser_Assembly(complex);
      const assemblyOps = _extractOperations(asmOper[i], operList);
      const entries = asmList[i].split(',');
      for (let ii = 0, nn = entries.length; ii < nn; ++ii) {
        const chain = entries[ii].trim();
        if (chain.length > 0) {
          asm.addChain(asymDict[chain]);
        }
      }
      asm.matrices = assemblyOps;
      complex.units.push(asm);
    }
  }
}
CIFParser.formats = ['cif', 'mmcif'];
CIFParser.extensions = ['.cif', '.mmcif'];
/* harmony default export */ const parsers_CIFParser = (CIFParser);
;// CONCATENATED MODULE: ./src/io/parsers/VolumeModel.js



const valueType = {
  singular: 0,
  vector: 1,
  array: 2,
  buffer: 3
};
class VolumeModel {
  _xyz2crs = [];
  _origin = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0))();
  constructor() {
    this._header = {};
    this._boxSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._boxStart = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._header.delta = {};
    this._header.extent = [];
    this._header.nstart = [];
    this._header.grid = [];
    this._header.crs2xyz = [];
    this._header.cellDims = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._header.angles = [];
    this._header.origin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    this._header.dmin = 0;
    this._header.dmean = 0;
    this._header.dmax = 0;
  }
  _typedCheck() {
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isTypedArray(this._buff)) {
      this._buff = this._buff.buffer;
    } else if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArrayBuffer(this._buff)) {
      throw new TypeError('Expected ArrayBuffer or TypedArray');
    }
  }
  _fillHeader(headerFormat, arrays) {
    for (const key in headerFormat) {
      if (headerFormat.hasOwnProperty(key)) {
        switch (headerFormat[key][0]) {
          case valueType.singular:
            this._header[key] = arrays[headerFormat[key][1]][headerFormat[key][2]];
            break;
          case valueType.array:
            this._parseArray(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);
            break;
          case valueType.vector:
            this._parseVector(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);
            break;
          case valueType.buffer:
            this._header[key] = new Uint8Array(arrays[headerFormat[key][1]], [headerFormat[key][2]] * 4, [headerFormat[key][3]] * 4);
            break;
          default:
            break;
        }
      }
    }
  }
  _parseVector(vector, arr, pos) {
    [vector.x, vector.y, vector.z] = [arr[pos], arr[pos + 1], arr[pos + 2]];
  }
  _parseArray(vector, arr, pos) {
    vector[0] = arr[pos];
    vector[1] = arr[pos + 1];
    vector[2] = arr[pos + 2];
  }
  _parseHeader(_buffer) {}
  _setAxisIndices() {}
  _setOrigins() {}
  _getAxis() {
    const header = this._header;
    const xScale = header.cellDims.x / header.grid[0];
    const yScale = header.cellDims.y / header.grid[1];
    const zScale = header.cellDims.z / header.grid[2];
    const [alpha, beta, gamma] = header.angles;
    const z1 = Math.cos(beta);
    const z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
    const z3 = Math.sqrt(1.0 - z1 * z1 - z2 * z2);
    const xaxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(xScale, 0, 0);
    const yaxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0);
    const zaxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(z1 * zScale, z2 * zScale, z3 * zScale);
    return [xaxis, yaxis, zaxis];
  }
  _getXYZdim() {
    return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
  }
  _getVolumeInfo() {
    const volInfo = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].pick(this._header, ['dmean', 'dmin', 'dmax', 'sd', 'delta']);
    volInfo.obtuseAngle = this._header.angles.map(angle => Number(angle >= Math.PI / 2));
    return volInfo;
  }
  _setBoxParams(xaxis, yaxis, zaxis) {
    // if axes are not orthogonal, the origins might not match with box coordinates - need to make shift
    let shiftX = 0;
    let shiftY = 0;
    const [alpha, beta, gamma] = this._header.angles;
    if (gamma >= Math.PI / 2) {
      shiftX += Math.abs(yaxis.x);
    }
    if (beta >= Math.PI / 2) {
      shiftX += Math.abs(zaxis.x);
    }
    if (alpha >= Math.PI / 2) {
      shiftY += Math.abs(zaxis.y);
    }
    this._boxStart = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(this._origin.x - shiftX, this._origin.y - shiftY, this._origin.z);
    this._boxSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x), Math.abs(yaxis.y) + Math.abs(zaxis.y), Math.abs(zaxis.z));
    const delta = (axe, proj) => Math.abs(axe[proj]) / this._boxSize[proj];
    this._header.delta.x = delta(yaxis, 'x');
    this._header.delta.y = delta(zaxis, 'x');
    this._header.delta.z = delta(zaxis, 'y');
  }
  _getXYZbox() {
    return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(this._boxStart.clone(), this._boxStart.clone().add(this._boxSize));
  }
  _toXYZData() {}
  parse(data) {
    this._parseHeader(data);
    this._setOrigins();
    return new chem_Volume(Float32Array, this._getXYZdim(), this._getXYZbox(), 1, this._toXYZData(), this._getVolumeInfo());
  }
}
/* harmony default export */ const parsers_VolumeModel = (VolumeModel);
;// CONCATENATED MODULE: ./src/io/parsers/CCP4Parser.js


const CCP4Header = {
  extent: [valueType.array, 'u32', 0],
  type: [valueType.singular, 'u32', 3],
  nstart: [valueType.array, 'i32', 4],
  grid: [valueType.array, 'u32', 7],
  cellDims: [valueType.vector, 'f32', 10],
  angles: [valueType.array, 'f32', 13],
  crs2xyz: [valueType.array, 'i32', 16],
  dmin: [valueType.singular, 'f32', 19],
  dmax: [valueType.singular, 'f32', 20],
  dmean: [valueType.singular, 'f32', 21],
  ispg: [valueType.singular, 'u32', 22],
  nsymbt: [valueType.singular, 'u32', 23],
  lksflg: [valueType.singular, 'u32', 24],
  customData: [valueType.buffer, 'buffer', 25, 9],
  origin: [valueType.vector, 'f32', 34],
  map: [valueType.buffer, 'buffer', 52, 1],
  machine: [valueType.singular, 'u32', 53],
  sd: [valueType.singular, 'f32', 54],
  nlabel: [valueType.singular, 'f32', 55],
  label: [valueType.buffer, 'buffer', 56, 200]
};
class Ccp4Model extends parsers_VolumeModel {
  // read header (http://www.ccp4.ac.uk/html/maplib.html)
  _parseHeader(_buffer) {
    this._buff = _buffer;
    this._typedCheck();
    const arrays = {};
    arrays.u32 = new Uint32Array(this._buff, 0, 56);
    arrays.i32 = new Int32Array(this._buff, 0, 56);
    arrays.f32 = new Float32Array(this._buff, 0, 56);
    arrays.buffer = this._buff;
    const header = this._header;
    this._fillHeader(CCP4Header, arrays);

    // calculate non-orthogonal unit cell coordinates
    header.angles.forEach((angle, i, a) => {
      a[i] *= Math.PI / 180.0;
    });
  }
  _setAxisIndices() {
    const header = this._header;
    if (header.cellDims.x === 0.0 && header.cellDims.y === 0.0 && header.cellDims.z === 0.0) {
      header.cellDims.set(1.0, 1.0, 1.0);
    }
    // Apply header conversion
    // Mapping between CCP4 column, row, section and VMD x, y, z.
    const {
      crs2xyz
    } = this._header;
    if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
      crs2xyz[0] = 1;
      crs2xyz[1] = 2;
      crs2xyz[2] = 3;
    }
    const xyz2crs = this._xyz2crs;
    xyz2crs[crs2xyz[0] - 1] = 0; // column
    xyz2crs[crs2xyz[1] - 1] = 1; // row
    xyz2crs[crs2xyz[2] - 1] = 2; // section
  }
  _setOrigins() {
    const [xaxis, yaxis, zaxis] = this._getAxis();
    this._setAxisIndices();
    const header = this._header;
    const xyz2crs = this._xyz2crs;
    // Handle both MRC-2000 and older format maps
    if (header.origin.x === 0.0 && header.origin.y === 0.0 && header.origin.z === 0.0) {
      this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]]);
      this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]]);
      this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]]);
    } else {
      this._origin = header.origin;
      // Use ORIGIN records rather than old n[xyz]start records
      //   http://www2.mrc-lmb.cam.ac.uk/image2000.html
      // XXX the ORIGIN field is only used by the EM community, and
      // has undefined meaning for non-orthogonal maps and/or non-cubic voxels, etc.
    }
    xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1);
    yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1);
    zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1);
    if (header.type === 2) {
      this._data = new Float32Array(this._buff, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
    } else {
      throw new Error(`CCP4: Unsupported format ${header.type}`);
    }
    this._setBoxParams(xaxis, yaxis, zaxis);
  }
  _toXYZData() {
    const header = this._header;
    const data = this._data;
    const xyz2crs = this._xyz2crs;
    const xyzData = new Float32Array(data.length);
    const dim = this._getXYZdim();
    const xSize = dim[0];
    const ySize = dim[1];
    let crsIdx = 0;
    const coord = [];
    let x;
    let y;
    let z;
    for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
      // Site
      for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
        // Row
        for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
          // Column
          x = coord[xyz2crs[0]];
          y = coord[xyz2crs[1]];
          z = coord[xyz2crs[2]];
          xyzData[x + xSize * (y + ySize * z)] = data[crsIdx];
        }
      }
    }
    return xyzData;
  }
}
class CCP4Parser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._options.fileType = 'ccp4';
    this.model = new Ccp4Model();
  }
  static canProbablyParse(_data) {
    return false; // Autodetection is not implemented yet
  }
  parseSync() {
    return this.model.parse(this._data);
  }
}
CCP4Parser.formats = ['ccp4'];
CCP4Parser.extensions = ['.ccp4', '.map', '.mrc'];
CCP4Parser.binary = true;
/* harmony default export */ const parsers_CCP4Parser = (CCP4Parser);
;// CONCATENATED MODULE: ./src/io/parsers/XYZParser.js




const {
  Complex: XYZParser_Complex,
  Element: XYZParser_Element,
  Molecule: XYZParser_Molecule
} = chem;
class XYZParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._complex = null;
    this._atomsInf = null;
    this._options.fileType = 'xyz';
    this._fileName = options.name;
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data);
  }
  _parseToAtomsInf(source) {
    const endnAtoms = source.indexOf('\n');
    const nAtoms = parseInt(source.substring(0, endnAtoms), 10);
    const endComment = source.indexOf('\n', endnAtoms + 1);
    let comment = source.slice(endnAtoms + 1, endComment).trim();
    if (comment.length === 0) {
      comment = this._fileName;
    }
    const startAtomsInf = endComment + source.substring(endComment).search(/\S/);
    this._atomsInf = source.substring(startAtomsInf).split(/[\s,]*\n[\s,]*/);
    if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
      this._complex.error = {
        message: 'wrong number of atoms'
      };
      return;
    }
    this._complex.metadata.format = 'xyz';
    this._complex.name = comment;
  }
  _parseAtomsInf() {
    const het = true;
    const altLoc = ' ';
    const occupancy = 1;
    const tempFactor = 1;
    const charge = 0;
    const chain = this._complex.addChain('A');
    const residue = chain.addResidue('UNK', 1, ' ');
    for (let i = 0; i < this._atomsInf.length - 1; i++) {
      const words = this._atomsInf[i].split(/[\s,]+/);
      if (words.length !== 4) {
        this._complex.error = {
          message: 'missed parameters'
        };
        break;
      }
      const serial = i + 1;
      const name = words[0];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(words[1]), parseFloat(words[2]), parseFloat(words[3]));
      const type = XYZParser_Element.getByName(name);
      const role = undefined;
      residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    }
    const molecule = new XYZParser_Molecule(this._complex, this._complex.name, 1);
    molecule.residues = residue;
    this._complex._molecules[0] = molecule;
  }
  parseSync() {
    const result = this._complex = new XYZParser_Complex();
    this._parseToAtomsInf(this._data);
    this._parseAtomsInf();
    this._complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
    this._complex = null;
    this._atomsInf = null;
    if (result.error) {
      throw new Error(result.error.message);
    }
    return result;
  }
  static formats = ['xyz'];
  static extensions = ['.xyz'];
}
/* harmony default export */ const parsers_XYZParser = (XYZParser);
;// CONCATENATED MODULE: ./src/io/parsers/PubChemParser.js




const {
  Complex: PubChemParser_Complex,
  Element: PubChemParser_Element
} = chem;
class PubChemParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._options.fileType = 'pubchem+json';
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && data[0] === '{';
  }
  parseSync() {
    this.logger.info('Parsing PubChem JSON file...');
    return this._toComplex(JSON.parse(this._data));
  }
  _toComplex(jsonData) {
    const complex = new PubChemParser_Complex();
    const complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];
    if (complexData) {
      this._extractAtoms(complex, complexData);
      complex.finalize({
        needAutoBonding: false,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing
      });
    }
    return complex;
  }
  _extractAtoms(complex, complexData) {
    let aids = complexData.atoms && complexData.atoms.aid;
    let elements = aids && complexData.atoms.element;
    if (!elements || aids.length !== elements.length) {
      throw new Error('Unable to parse atom elements');
    }
    elements = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fromPairs(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].zip(aids, elements));
    const atoms = {};
    const coords = complexData.coords && complexData.coords[0];
    const model = coords && coords.conformers && coords.conformers[0];
    const xs = model && model.x;
    const ys = model && model.y;
    const zs = model && model.z || [];
    aids = coords && coords.aid;
    if (!aids || !xs || !ys) {
      throw new Error('Coordinates are not found in the file');
    }
    const chain = complex.addChain(' ');
    const residue = chain.addResidue('UNK', 1, ' ');
    for (let i = 0, n = aids.length; i < n; ++i) {
      const aid = aids[i];
      const element = PubChemParser_Element.ByAtomicNumber[elements[aid]];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(xs[i], ys[i], zs[i] || 0.0);
      atoms[aid] = residue.addAtom(element.name, element, xyz, undefined, true, aid, ' ', 1.0, 0.0, 0);
    }
    const aids1 = complexData.bonds && complexData.bonds.aid1;
    const aids2 = complexData.bonds && complexData.bonds.aid2;
    const orders = complexData.bonds && complexData.bonds.order || [];
    if (!aids1 || !aids2 || aids1.length !== aids2.length) {
      return;
    }
    for (let j = 0, m = aids1.length; j < m; ++j) {
      complex.addBond(atoms[aids1[j]], atoms[aids2[j]], orders[j] || 1, 0, true);
    }
  }
}
PubChemParser.formats = ['pubchem', 'pubchem+json', 'pc'];
PubChemParser.extensions = ['.json'];
/* harmony default export */ const parsers_PubChemParser = (PubChemParser);
;// CONCATENATED MODULE: ./src/io/parsers/SDFStream.js

class SDFStream {
  constructor(data) {
    this._strings = data.split(/\r?\n|\r/);
    this._currentStart = 0;
    this._currentStringIndx = 0;
  }
  setStart(start) {
    if (start >= this._strings.length) {
      this._currentStart = this._strings.length - 1;
      this._currentStringIndx = this._strings.length - 1;
    } else {
      this._currentStart = start;
      this._currentStringIndx = start;
    }
  }
  getNextString() {
    return this._strings[++this._currentStringIndx];
  }
  getCurrentString() {
    return this._strings[this._currentStringIndx];
  }
  getStringFromStart(numb) {
    this._currentStringIndx = this._currentStart + numb;
    return this._strings[this._currentStart + numb];
  }
  findNextDataItem() {
    let curStr = this.getNextString();
    let res = false;
    while (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(curStr) && curStr.trim() !== '$$$$') {
      if (curStr.match(/>\s+<(.*)>/)) {
        res = true;
        break;
      }
      curStr = this.getNextString();
    }
    return res;
  }
  findNextCompoundStart() {
    let curStr = this.getCurrentString();
    while (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(curStr) && curStr.trim() !== '$$$$') {
      curStr = this.getNextString();
    }
    this.setStart(++this._currentStringIndx);
    return this.probablyHaveDataToParse();
  }
  probablyHaveDataToParse() {
    return this._currentStringIndx < this._strings.length - 2;
  }
}
;// CONCATENATED MODULE: ./src/io/parsers/SDFParser.js






const {
  Complex: SDFParser_Complex,
  Element: SDFParser_Element,
  Bond: SDFParser_Bond,
  Molecule: SDFParser_Molecule
} = chem;
const chargeMap = [0, 3, 2, 1, 0, -1, -2, -3];
const orderMap = [0, 1, 2, 3, 1, 1, 1, 2];
const typeMap = [SDFParser_Bond.BondType.UNKNOWN,
// 0 - error
SDFParser_Bond.BondType.COVALENT,
// 1 - single
SDFParser_Bond.BondType.COVALENT,
// 2 - double
SDFParser_Bond.BondType.COVALENT,
// 3 - triple
SDFParser_Bond.BondType.AROMATIC,
// 4 - aromatic
SDFParser_Bond.BondType.UNKNOWN,
// 5 - single or double
SDFParser_Bond.BondType.AROMATIC,
// 6 - single or aromatic
SDFParser_Bond.BondType.AROMATIC // 7 - double or aromatic
// 8 - any
// 9 - coordination
// 10 - hydrogen
];
const sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/;
const sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/;
const fileFormat = {
  SDF: 'sdf',
  MOL: 'mol'
};
const possibleNameTags = ['PUBCHEM_IUPAC_TRADITIONAL_NAME', /PUBCHEM_(.+)_NAME/, /(.+)name/, /(.+)NAME/];
const possibleIDTags = ['PUBCHEM_COMPOUND_CID', 'id', 'ID', /.*CID/, /.*ID/, /.*id/];
const possibleTitleTags = ['msg', 'MSG', 'message', 'title', 'description', 'desc'];
const tagsNames = ['name', 'id', 'title'];
const tags = {
  name: possibleNameTags,
  id: possibleIDTags,
  title: possibleTitleTags
};
function buildChainID(index) {
  if (!index) {
    return 'A';
  }
  const codes = [];
  while (index) {
    codes.push(65 + index % 26);
    index = Math.trunc(index / 26);
  }
  if (codes.length > 1) {
    codes.reverse();
    codes[0] -= 1;
  }
  return String.fromCharCode(...codes);
}
class SDFParser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._format = 'sdf';
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._molecules = null;
    this._metadata = {};
    this._metadata.molecules = [];
    this._currentMolProps = {};
    this._compoundIndx = -1;
    this._assemblies = [];
    this._atomsParsed = 0;
    this._atomsIndexes = [];
  }
  canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && sdfAndMolRegexp.test(data);
  }
  _parseHeader(stream) {
    const molecule = {};
    molecule.name = stream.getStringFromStart(0);
    const date = parseInt(stream.getStringFromStart(1).substr(10, 6).trim(), 10);
    molecule.date = date.toString() || '';
    molecule.title = stream.getStringFromStart(2);
    this._metadata.molecules.push(molecule);
  }
  _parseAtoms(stream, atomsNum) {
    let curStr;
    let serial = this._atomsParsed;

    // each molecule = chain\residue
    const chainID = buildChainID(this._compoundIndx);
    const resName = 'UNK';
    const resSeq = 1;
    this._chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
    this._residue = this._chain.addResidue(resName, resSeq, ' ');
    for (let i = 0; i < atomsNum; i++) {
      curStr = stream.getNextString();
      serial++;
      const x = parseFloat(curStr.substr(0, 10));
      const y = parseFloat(curStr.substr(10, 10));
      const z = parseFloat(curStr.substr(20, 10));
      const charge = chargeMap[parseInt(curStr.substr(36, 3), 10)];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x, y, z);
      let name = curStr.substr(31, 3).trim().toUpperCase();
      const type = SDFParser_Element.getByName(name);
      if (!this._atomsIndexes[name]) {
        this._atomsIndexes[name] = 0;
      }
      this._atomsIndexes[name] += 1;
      name += this._atomsIndexes[name]; // every atom need to have unique name.

      this._residue.addAtom(name, type, xyz, undefined, true, serial, ' ', 1.0, 0.0, charge);
    }
  }
  _parseBonds(stream, bondsNum) {
    let curStr;
    for (let i = 0; i < bondsNum; i++) {
      curStr = stream.getNextString();
      let atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed;
      let atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed;
      const bondType = parseInt(curStr.substr(6, 3), 10);
      if (atom1 > atom2) {
        [atom1, atom2] = [atom2, atom1];
      }
      this._complex.addBond(atom1, atom2, orderMap[bondType] || 1, typeMap[bondType] || SDFParser_Bond.BondType.UNKNOWN, true);
    }
  }
  _parseMOL(stream) {
    this._compoundIndx++;
    this._parseHeader(stream);
    const countsLine = stream.getStringFromStart(3);
    const atomsNum = parseInt(countsLine.substr(0, 3), 10);
    const bondsNum = parseInt(countsLine.substr(3, 3), 10);
    this._parseAtoms(stream, atomsNum);
    this._parseBonds(stream, bondsNum);
    this._atomsParsed += atomsNum;
    this._metadata.molecules[this._compoundIndx]._residues = [];
    this._metadata.molecules[this._compoundIndx]._residues.push(this._residue);
  }
  _parseDataItem(stream) {
    const tag = stream.getCurrentString();
    let data = [];
    let curStr = stream.getNextString();

    // read data
    while (curStr.trim() !== '') {
      data.push(curStr);
      curStr = stream.getNextString();
    }
    if (data.length === 1) {
      [data] = data;
    }
    this._currentMolProps[tag.replace(/[<>]/g, '').trim()] = data;
  }
  _parseCompound(stream) {
    this._parseMOL(stream);

    // parse data items block
    if (this._format === fileFormat.SDF) {
      this._currentMolProps = {};
      while (stream.findNextDataItem()) {
        this._parseDataItem(stream);
      }
      if (Object.keys(this._currentMolProps).length !== 0) {
        const molecule = this._metadata.molecules[this._compoundIndx];
        molecule.props = this._currentMolProps;
        this._tryToUpdateMoleculeData(molecule);
      }
    }
  }
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap;
    const complex = this._complex;
    const bonds = complex._bonds;
    for (let j = 0; j < bonds.length; j++) {
      const bond = bonds[j];
      if (bond._right < bond._left) {
        console.log('_fixBondsArray: Logic error.');
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _buildAssemblies() {
    const chains = this._complex._chains;
    if (chains.length === 1) {
      return this._assemblies;
    }
    for (let i = 0; i < chains.length; i++) {
      const assembly = new chem_Assembly(this._complex);
      const matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
      assembly.addMatrix(matrix);
      assembly.addChain(chains[i]._name);
      this._assemblies.push(assembly);
    }
    return this._assemblies;
  }
  _buildMolecules() {
    this._complex._molecules = [];
    const {
      molecules
    } = this._metadata;
    for (let i = 0; i < molecules.length; i++) {
      const molecule = new SDFParser_Molecule(this._complex, molecules[i].name, i + 1);
      molecule.residues = molecules[i]._residues;
      this._complex._molecules[i] = molecule;
    }
    return this._complex._molecules;
  }
  _searchTag(tag, props) {
    for (let i = 0; i < props.length; i++) {
      if (tag instanceof RegExp && tag.test(props[i].tag) || tag === props[i].tag) {
        return props[i].data;
      }
    }
    return undefined;
  }
  _tryToFind(tagsList, props) {
    for (let j = 0; j < tagsList.length; j++) {
      const res = this._searchTag(tagsList[j], props);
      if (res) {
        return res;
      }
    }
    return undefined;
  }
  _tryToUpdateMoleculeData(molecule) {
    let res = false;
    for (let i = 0; i < tagsNames.length; i++) {
      const tagPossibleNames = tags[tagsNames[i]];
      const data = this._tryToFind(tagPossibleNames, molecule.props);
      if (data) {
        molecule[tagsNames[i]] = data;
        res = true;
      }
    }
    molecule.name = molecule.name || molecule.id;
    if (molecule.name.match(/^\d+$/)) {
      molecule.name = `CID: ${molecule.name}`;
    }
    return res;
  }
  _finalizeMetadata() {
    const {
      molecules
    } = this._metadata;
    const {
      metadata
    } = this._complex;
    const complex = this._complex;
    if (molecules.length === 1) {
      complex.name = molecules[0].name;
      metadata.title = molecules[0].title;
      metadata.date = molecules[0].date;
      metadata.properties = molecules[0].props;
    } else if (molecules.length > 1) {
      metadata.molecules = [];
      for (let i = 0; i < molecules.length; i++) {
        metadata.molecules.push({
          name: molecules[i].name,
          date: molecules[i].date,
          title: molecules[i].title,
          properties: molecules[i].props
        });
      }
    }
  }
  _finalize() {
    const serialAtomMap = this._serialAtomMap = {};
    const atoms = this._complex._atoms;
    for (let i = 0; i < atoms.length; i++) {
      const atom = atoms[i];
      serialAtomMap[atom.serial] = atom;
    }
    this._complex._finalizeBonds();
    this._fixBondsArray();
    this._finalizeMetadata();
    this._buildAssemblies();
    this._complex.units = this._complex.units.concat(this._assemblies);
    this._buildMolecules();
    this._complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: false,
      enableEditing: false,
      serialAtomMap: this._serialAtomMap
    });
  }
  defineFormat(data) {
    let format;
    if (sdfRegExp.test(data)) {
      format = fileFormat.SDF;
    } else {
      format = fileFormat.MOL;
    }
    return format;
  }
  parseSync() {
    const result = this._complex = new SDFParser_Complex();
    const stream = new SDFStream(this._data);
    this._format = this.defineFormat(this._data);
    result.metadata.format = this._format;
    do {
      this._parseCompound(stream);
    } while (stream.findNextCompoundStart());
    this._finalize();
    return result;
  }
}
SDFParser.formats = ['mol', 'sdf'];
SDFParser.extensions = ['.mol', '.sdf'];
;// CONCATENATED MODULE: ./src/io/parsers/DSN6Parser.js




// http://www.uoxray.uoregon.edu/tnt/manual/node104.html
const DSN6Header = {
  nstart: [valueType.array, 'i16', 0],
  extent: [valueType.array, 'i16', 3],
  grid: [valueType.array, 'i16', 6],
  cellDims: [valueType.vector, 'i16', 9],
  angles: [valueType.array, 'i16', 12],
  div: [valueType.singular, 'i16', 15],
  adder: [valueType.singular, 'i16', 16],
  scaleFactor: [valueType.singular, 'i16', 17]
};
class DSN6Model extends parsers_VolumeModel {
  _parseHeader(_buffer) {
    this._buff = _buffer;
    this._typedCheck();
    const arrays = {};
    arrays.i16 = new Int16Array(this._buff);

    // check and reverse if big endian
    if (arrays.i16[18] !== 100) {
      for (let i = 0, n = arrays.i16.length; i < n; ++i) {
        const val = arrays.i16[i];
        arrays.i16[i] = (val & 0xff) << 8 | val >> 8 & 0xff;
      }
    }
    if (arrays.i16[18] !== 100) {
      throw new Error('DSN6: Incorrect format ');
    }
    const header = this._header;
    this._fillHeader(DSN6Header, arrays);
    header.cellDims.multiplyScalar(1.0 / header.scaleFactor);
    header.angles.forEach((angle, i, a) => {
      a[i] *= Math.PI / 180.0 / header.scaleFactor;
    });
    header.div /= 100;
  }
  _setAxisIndices() {
    this._xyz2crs[0] = 0;
    this._xyz2crs[1] = 1;
    this._xyz2crs[2] = 2;
  }
  _setOrigins() {
    const header = this._header;
    const [xaxis, yaxis, zaxis] = this._getAxis();
    this._setAxisIndices();
    this._origin.addScaledVector(xaxis, header.nstart[0]);
    this._origin.addScaledVector(yaxis, header.nstart[1]);
    this._origin.addScaledVector(zaxis, header.nstart[2]);
    xaxis.multiplyScalar(header.extent[0]);
    yaxis.multiplyScalar(header.extent[1]);
    zaxis.multiplyScalar(header.extent[2]);
    this._setBoxParams(xaxis, yaxis, zaxis);
  }
  _pointCalculate(xyzData, byteBuffer, z, y, x, pos, i) {
    const header = this._header;
    if (x < header.extent[0] && y < header.extent[1] && z < header.extent[2]) {
      const idx = x + header.extent[0] * (y + header.extent[1] * z);
      xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div;
      ++pos.counter;
    } else {
      pos.counter += 8 - i;
      return false;
    }
    return true;
  }
  _blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos) {
    for (let k = 0; k < 8; ++k) {
      const z = 8 * zBlock + k;
      for (let j = 0; j < 8; ++j) {
        const y = 8 * yBlock + j;
        let inRange = true;
        let i = 0;
        while (inRange && i < 8) {
          const x = 8 * xBlock + i;
          inRange = this._pointCalculate(xyzData, byteBuffer, z, y, x, pos, i);
          i++;
        }
      }
    }
  }
  _toXYZData() {
    const header = this._header;
    const byteBuffer = new Uint8Array(this._buff);
    const xyzData = new Float32Array(header.extent[0] * header.extent[1] * header.extent[2]);
    const blocks = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(header.extent[0] / 8, header.extent[1] / 8, header.extent[2] / 8);
    const pos = {};
    pos.counter = 512;
    for (let zBlock = 0; zBlock < blocks.z; ++zBlock) {
      for (let yBlock = 0; yBlock < blocks.y; ++yBlock) {
        for (let xBlock = 0; xBlock < blocks.x; ++xBlock) {
          this._blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos);
        }
      }
    }
    this._calculateInfoParams(xyzData);
    return xyzData;
  }
  _calculateInfoParams(xyzData) {
    this._header.dmean /= xyzData.length;
    let dispersion = 0;
    let minDensity = xyzData[0];
    let maxDensity = xyzData[0];
    for (let j = 0; j < xyzData.length; j++) {
      dispersion += (this._header.dmean - xyzData[j]) ** 2;
      if (xyzData[j] < minDensity) {
        minDensity = xyzData[j];
      }
      if (xyzData[j] > maxDensity) {
        maxDensity = xyzData[j];
      }
    }
    this._header.sd = Math.sqrt(dispersion / xyzData.length);
    this._header.dmax = maxDensity;
    this._header.dmin = minDensity;
  }
}
class DSN6Parser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._options.fileType = 'dsn6';
    this.model = new DSN6Model();
  }
  static canParse(data, options) {
    if (!data) {
      return false;
    }
    return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options, 'dsn6');
  }
  static canProbablyParse(_data) {
    return false;
  }
  parseSync() {
    return this.model.parse(this._data);
  }
}
DSN6Parser.formats = ['dsn6'];
DSN6Parser.extensions = ['.dsn6', '.omap'];
DSN6Parser.binary = true;
/* harmony default export */ const parsers_DSN6Parser = (DSN6Parser);
;// CONCATENATED MODULE: ./src/io/parsers/GROReader.js


/**
 * Little helper class for GRO Parser usage.
 * @extends PDBStream
 */
class GROReader extends parsers_PDBStream {
  constructor(data) {
    super(data);
    /** @type Number */
    this._next = -1; // End position of line
    this.next();
  }

  /**
   * Getting end of string.
   * @returns {Number} Pointer to end of string
   */
  getNext() {
    return this._next;
  }
}
/* harmony default export */ const parsers_GROReader = (GROReader);
;// CONCATENATED MODULE: ./src/io/parsers/GROParser.js





const {
  Complex: GROParser_Complex,
  Element: GROParser_Element,
  Molecule: GROParser_Molecule
} = chem;

/**
 * Gromos87 file format parser.
 * @extends Parser
 */
class GROParser extends Parser {
  /**
   * Create parser for .gro file format
   *
   * @param {String} data Input file
   * @param {String} options Input options (optional field)
   */
  constructor(data, options) {
    super(data, options);
    /** @type Date */
    this._time = null; // Time in ps, optional field for animations
    /** @type Number */
    this._numAtoms = null; // Number of atoms in complex
    /** @type Number */
    this._residueNumber = null; // Number of exact residue
    /** @type String */
    this._residueName = ''; // Scientific name of exact residue
    /** @type String */
    this._atomName = ''; // Scientific name of exact atom
    /** @type Number */
    this._atomNumber = null; // Sorted number of exact atom
    /** @type Array */
    this._atomPosition = []; // Array which contains x, y, z position of exact atom
    /** @type Array */
    this._atomVelocity = []; // Array which contains x, y, z velocity of exact atom (optional)
    /** @type Complex */
    this._complex = null; // Complex structure for unified molecule representation
    /** @type Vector3 */
    this._molecules = []; // Molecules array
    /** @type Molecule */
    this._molecule = null; // Single molecule
    /** @type String */
    this._options.filetype = 'gro'; // Extension of data file.
  }

  /**
   * General check for possibility of parsing.
   * @param {String} data - Input file
   * @returns {boolean} true if this file is in ascii, false otherwise
   */
  canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(this._data) && /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(data);
  }

  /**
   * Parsing title of molecule complex.
   * NOTE: that names are ESTIMATES, there is no strict rules in Gromos87 standard for first line in input file.
   * @param {GROReader} line - Line containing title and time.
   */
  _parseTitle(line) {
    const {
      metadata
    } = this._complex;
    metadata.id = line.readLine().trim();
    metadata.name = metadata.id.slice(metadata.id.lastIndexOf('\\') + 1, metadata.id.lastIndexOf('.'));
    metadata.format = 'gro';
  }

  /**
   * Parsing line containing number of atoms information.
   * @param {GROReader} line - Line containing number of atoms.
   */
  _parseNumberOfAtoms(line) {
    this._numAtoms = line.readInt(0, line.getNext());
    if (Number.isNaN(this._numAtoms)) {
      throw new Error('Line 2 is not representing atom number. Consider checking input file');
    }
  }

  /**
   * Parsing line containing information about residues, atoms etc. Also information about box vectors.
   * Format of atoms MUST (by Gromos87 standard) be this: (note that numbering starts not from 0, but from 1!)
   * ResidueNumber[1 - 5]  ResidueName[6 - 10] AtomName[11 - 15] AtomNumber[16 - 20] Position[21 - 45] Velocity[46 - 69]
   * @param {GROReader} line - Line containing information about atom.
   */
  _parseAtom(line) {
    this._residueNumber = line.readInt(1, 5);
    this._residueName = line.readString(6, 10).trim();
    this._atomName = line.readString(11, 15).trim();
    this._atomNumber = line.readInt(16, 20);
    const positionX = line.readFloat(21, 28) * 10;
    const positionY = line.readFloat(29, 36) * 10;
    const positionZ = line.readFloat(37, 45) * 10;
    if (Number.isNaN(positionX) || Number.isNaN(positionY) || Number.isNaN(positionZ)) {
      this._complex.error = {
        message: `Atom position is invalid in "${line.readLine()}"`
      };
      return;
    }
    /* const velocityX = line.readFloat(46, 53);
    const velocityY = line.readFloat(54, 61);
    const velocityZ = line.readFloat(62, 69); */
    /* Adding residue and atom to complex structure */
    const type = GROParser_Element.getByName(this._atomName[0]); /* MAGIC 0. REASONS: This name is something like "CA", where
                                                       C - is an element an A is something else. But what about Calcium? */
    if (type.fullName === 'Unknown') {
      this._complex.error = {
        message: `${this._atomName[0]} hasn't been recognised as an atom name.`
      };
      return;
    }
    const role = GROParser_Element.Role[this._atomName];
    /* Firstly, create a dummy chain */
    let chain = this._chain;
    if (!chain) {
      this._chain = chain = this._complex.addChain('A');
    }
    /* Secondly, add residue to that chain */
    let residue = this._residue;
    if (!residue || residue.getSequence() !== this._residueNumber) {
      this._residue = residue = chain.addResidue(this._residueName, this._residueNumber, ' ');
    }
    /* Lastly, add atom to that residue */
    this._atomPosition = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(positionX, positionY, positionZ);
    /* Adding default constants to correct atom addition process */
    const het = true;
    const altLoc = ' ';
    const occupancy = 1;
    const tempFactor = 1;
    const charge = 0;
    residue.addAtom(this._atomName, type, this._atomPosition, role, het, this._atomNumber, altLoc, occupancy, tempFactor, charge);
  }

  /**
   * Some finalizing procedures. In '.gro' file format there is only 1 chain and 1 molecule.
   */
  _finalize() {
    const molecule = new GROParser_Molecule(this._complex, this._complex.metadata.name, 1);
    // aggregate residues from chain
    molecule.residues = this._chain._residues;
    molecule._chains = this._chain;
    this._complex._molecules[0] = molecule;
    this._molecules.push(molecule);
    this._complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
  }

  /**
   * Main parsing procedure.
   * @returns {Complex} Complex structure for visualizing.
   */
  parseSync() {
    /* Create "Complex" variable */
    const result = this._complex = new GROParser_Complex();
    /* Parse input file line-by-line */
    const reader = new parsers_GROReader(this._data);
    let counter = 0; /* Simple counter regarding to format of .gro file */
    /* First two lines - technical information, other lines - Atoms */
    this._parseTitle(reader);
    reader.next();
    this._parseNumberOfAtoms(reader);
    reader.next();
    for (counter = 0; counter < this._numAtoms; ++counter) {
      if (!reader.end()) {
        this._parseAtom(reader);
        reader.next();
      } else break;
    }
    /* If number of atoms in second line is less then actual atoms in file */
    if (counter < this._numAtoms) {
      this._complex.error = {
        message: 'File ended unexpectedly.'
      };
    }
    /* Catch errors occurred in parsing process */
    if (result.error) {
      throw new Error(result.error.message);
    }

    /* Finalizing data */
    this._finalize();

    /* Cleaning up */
    this._atomPosition = null;
    this._complex = null;
    this._molecules = null;
    this._molecule = null;

    /* Return resulting Complex variable */
    return result;
  }
}
GROParser.formats = ['gro'];
GROParser.extensions = ['.gro'];
/* harmony default export */ const parsers_GROParser = (GROParser);
;// CONCATENATED MODULE: ./src/io/parsers/MOL2Parser.js



const {
  Complex: MOL2Parser_Complex,
  Element: MOL2Parser_Element,
  Bond: MOL2Parser_Bond,
  Molecule: MOL2Parser_Molecule
} = chem;
const MOL2Parser_orderMap = {
  un: 0,
  1: 1,
  2: 2,
  3: 3,
  ar: 1,
  am: 1,
  nc: 0,
  du: 1
};
const MOL2Parser_typeMap = {
  un: MOL2Parser_Bond.BondType.UNKNOWN,
  // unknown (cannot be determined from the parameter tables)
  1: MOL2Parser_Bond.BondType.COVALENT,
  // single
  2: MOL2Parser_Bond.BondType.COVALENT,
  // double
  3: MOL2Parser_Bond.BondType.COVALENT,
  // triple
  ar: MOL2Parser_Bond.BondType.AROMATIC,
  // aromatic
  am: MOL2Parser_Bond.BondType.COVALENT,
  // amide
  nc: MOL2Parser_Bond.BondType.UNKNOWN,
  // not connected
  du: MOL2Parser_Bond.BondType.COVALENT // dummy
};
const resNumberRegex = /\d+$/;
const spacesRegex = /\s+/;
function splitToFields(str) {
  return str.trim().split(spacesRegex);
}
/* There is no jsdoc documentation because of eslint corrections:
 * not all Parser methods are implemented
 */

class MOL2Parser extends Parser {
  constructor(data, options) {
    super(data, options);
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._compoundIndx = -1;
    this._molecules = [];
    this._molecule = null;
    this._currPosIdx = 0;
    this._currStartIdx = 0;
    this._serialAtomMap = {};
    this._options.fileType = 'mol2';
  }
  _parseRawStrings(data) {
    return data.split(/\r?\n|\r/);
  }
  _toStringFromStart(numb, MOL2Data) {
    const newPosIdx = this._currStartIdx + numb;
    this._currPosIdx = newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx;
  }
  _toHeaderString(header, MOL2Data) {
    this._toStringFromStart(0, MOL2Data);
    while (this._currPosIdx < MOL2Data.length) {
      if (MOL2Data[this._currPosIdx].match(`@<TRIPOS>${header}`)) {
        return;
      }
      this._currPosIdx++;
    }
    this._toStringFromStart(0, MOL2Data);
  }
  _toStringFromHeader(header, numb, MOL2Data) {
    this._toHeaderString(header, MOL2Data);
    const newPosIdx = this._currPosIdx + numb;
    if (MOL2Data[this._currPosIdx].match(`@<TRIPOS>${header}`) && newPosIdx < MOL2Data.length) {
      this._currPosIdx = newPosIdx;
    }
  }
  _setStart(startPos, MOL2Data) {
    if (startPos >= MOL2Data.length) {
      this._currStartIdx = this._currPosIdx = MOL2Data.length - 1;
    } else {
      this._currStartIdx = this._currPosIdx = startPos;
    }
  }
  _probablyHaveDataToParse(MOL2Data) {
    return this._currPosIdx < MOL2Data.length - 2;
  }
  _findNextCompoundStart(MOL2Data) {
    while (this._currPosIdx < MOL2Data.length && MOL2Data[this._currPosIdx].trim() !== '@<TRIPOS>MOLECULE>') {
      this._currPosIdx++;
    }
    this._setStart(++this._currPosIdx, MOL2Data);
    return this._probablyHaveDataToParse(MOL2Data);
  }
  _parseMolecule(MOL2Data) {
    this._toHeaderString('MOLECULE', MOL2Data);
    const {
      metadata
    } = this._complex;
    metadata.name = MOL2Data[++this._currPosIdx];
    metadata.format = 'mol2';
    this._molecule = {
      _index: '',
      _chains: []
    };
    this._molecule._index = this._compoundIndx + 1;
    this._molecules.push(this._molecule);
  }

  /* Atom format description:
   * atomId atomName x y z element [resSeq [resName [charge [statusBit]]]]
   * statusBits is the internal SYBYL status bits associated with the atom.
   * These should never be set by the user.
   * Source: http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/mol2.pdf
   */
  _parseAtoms(atomsNum, MOL2Data) {
    this._toHeaderString('ATOM', MOL2Data);
    for (let i = 0; i < atomsNum; i++) {
      const parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);
      if (parsedStr.length < 6) {
        throw new Error('MOL2 parsing error: Not enough information to create atom!');
      }
      const atomId = parseInt(parsedStr[0], 10);
      const atomName = parsedStr[1];
      const x = parseFloat(parsedStr[2]);
      const y = parseFloat(parsedStr[3]);
      const z = parseFloat(parsedStr[4]);
      const element = parsedStr[5].split('.')[0].toUpperCase();
      let charge = 0;
      if (parsedStr.length >= 9) {
        charge = parseFloat(parsedStr[8]) || 0.0;
      }
      let chain = this._chain;
      if (!chain) {
        // .mol2 may contain information about multiple molecules, but they can't be visualized
        // at the same time now. There is no need to create different chain IDs then.
        this._chain = chain = this._complex.getChain('A') || this._complex.addChain('A');
        this._residue = null;
      }
      if (!this._setResidue(parsedStr)) {
        continue;
      }

      // These fields are not listed in mol2 format. Set them default.
      // Atoms and het atoms doesn't differ in .mol2,
      // but het atoms have special residues. It can be used in next updates
      const het = false;
      const altLoc = ' ';
      const occupancy = 1.0;
      const tempFactor = 0.0;
      const type = MOL2Parser_Element.getByName(element);
      const role = MOL2Parser_Element.Role[atomName];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x, y, z);
      this._residue.addAtom(atomName, type, xyz, role, het, atomId, altLoc, occupancy, tempFactor, charge);
    }
  }
  _setResidue(parsedStr) {
    let resSeq = 1;
    let resName = 'UNK'; // The same meaning has '<0>' in some mol2 files

    if (parsedStr.length >= 7) {
      resSeq = parseInt(parsedStr[6], 10);
    }
    if (parsedStr.length >= 8 && parsedStr[7] !== '<0>') {
      resName = parsedStr[7].replace(resNumberRegex, '');
    }
    if (this.settings.now.nowater) {
      if (resName === 'HOH' || resName === 'WAT') {
        return false;
      }
    }
    const residue = this._residue;
    const chain = this._chain;
    if (!residue || residue.getSequence() !== resSeq) {
      this._residue = chain.addResidue(resName, resSeq, 'A');
    }
    return true;
  }

  /* Bond format description
   * bondId originAtomId targetAtomId bondType [statusBits]
   */
  _parseBonds(bondsNum, MOL2Data) {
    this._toHeaderString('BOND', MOL2Data);
    for (let i = 0; i < bondsNum; i++) {
      const parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);
      if (parsedStr.length < 3) {
        throw new Error('MOL2 parsing error: Missing information about bonds!');
      }
      let originAtomId = parseInt(parsedStr[1], 10);
      let targetAtomId = parseInt(parsedStr[2], 10);
      const bondType = parsedStr[3];
      if (originAtomId > targetAtomId) {
        [originAtomId, targetAtomId] = [targetAtomId, originAtomId];
      }
      this._complex.addBond(originAtomId, targetAtomId, MOL2Parser_orderMap[bondType] || 0, MOL2Parser_typeMap[bondType] || MOL2Parser_Bond.BondType.UNKNOWN, true);
    }
  }
  _fixSerialAtoms() {
    const atoms = this._complex._atoms;
    for (let i = 0; i < atoms.length; i++) {
      const atom = atoms[i];
      this._serialAtomMap[atom.serial] = atom;
    }
  }
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap;
    const complex = this._complex;
    if (Object.keys(serialAtomMap).length === 0) {
      throw new Error('MOL2 parsing error: Missing atom information!');
    }
    const bonds = complex._bonds;
    for (let j = 0; j < bonds.length; j++) {
      const bond = bonds[j];
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _finalizeMolecules() {
    // Get chain from complex
    const chain = this._complex._chains[0];
    this._complex._molecules = [];

    // Aggregate residues from chains
    // (to be precise from the chain 'A')
    for (let i = 0; i < this._molecules.length; i++) {
      const currMolecule = this._molecules[i];
      const molResidues = chain._residues;
      const molecule = new MOL2Parser_Molecule(this._complex, currMolecule._name, i + 1);
      molecule.residues = molResidues;
      this._complex._molecules[i] = molecule;
    }
  }
  _finalize() {
    this._complex._finalizeBonds();
    this._fixSerialAtoms();
    this._fixBondsArray();
    this._finalizeMolecules();
    this._complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
  }
  _parseCompound(MOL2Data) {
    this._compoundIndx++;
    this._parseMolecule(MOL2Data);

    // Ignoring comments and everything before @<TRIPOS>MOLECULE block
    this._toStringFromHeader('MOLECULE', 2, MOL2Data);
    const parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex);
    const atomsNum = parsedStr[0];
    const bondsNum = parsedStr[1];
    this._parseAtoms(atomsNum, MOL2Data);
    this._parseBonds(bondsNum, MOL2Data);
  }
  parseSync() {
    const result = this._complex = new MOL2Parser_Complex();
    const MOL2Data = this._parseRawStrings(this._data);
    do {
      this._parseCompound(MOL2Data);
    } while (this._findNextCompoundStart(MOL2Data));
    this._finalize();
    return result;
  }
}
MOL2Parser.formats = ['mol2'];
MOL2Parser.extensions = ['.mol2', '.ml2', '.sy2'];
/* harmony default export */ const parsers_MOL2Parser = (MOL2Parser);
;// CONCATENATED MODULE: ./src/io/parsers.js












/* harmony default export */ const parsers = (new parsers_ParserList([
// note: order might be important
parsers_PDBParser, parsers_CIFParser, parsers_MMTFParser, parsers_XYZParser, parsers_CMLParser, parsers_PubChemParser, SDFParser, parsers_CCP4Parser, parsers_DSN6Parser, parsers_GROParser, parsers_MOL2Parser]));
;// CONCATENATED MODULE: ./src/io/exporters/ExporterList.js


/**
 * A list of available exporters.
 * @extends EntityList
 */
class ExporterList extends utils_EntityList {
  /**
   * Create a list of exporters.
   * The exporters are indexed by supported data formats (`.formats` and
   * `.extensions` properties of a Exporter subclass).
   * The Exporters can be retrieved later by matching against specs (see {@link ExporterList#find}).
   *
   * @param {!Array<function(new:Exporter)>=} someExporters A list of {@link Exporter} subclasses to
   *   automatically register at creation time.
   * @see ExporterList#register
   */
  constructor() {
    let someExporters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(someExporters, ['formats']);
  }

  /**
   * Find a suitable exporter for data.
   *
   * @param {Object} specs Exporter specifications.
   * @param {string=} specs.format Supported data format.
   * @param {*=} specs.data Data to export.
   */
  find(specs) {
    let list = [];
    if (specs.format) {
      list = this._dict.formats[specs.format.toLowerCase()] || [];
    }
    return [...list];
  }
}
/* harmony default export */ const exporters_ExporterList = (ExporterList);
;// CONCATENATED MODULE: ./src/io/exporters/Exporter.js

class Exporter {
  constructor(source, options) {
    this._source = source;
    this._options = options || {};
    this._abort = false;
  }
  exportSync() {
    throw new Error('Exporting to this source is not implemented');
  }
  export() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          if (this._abort) {
            return reject(new Error('Export aborted'));
          }
          return resolve(this.exportSync());
        } catch (error) {
          return reject(error);
        }
      });
    });
  }
  abort() {
    this._abort = true;
  }
}
utils_makeContextDependent(Exporter.prototype);
;// CONCATENATED MODULE: ./src/io/exporters/PDBResult.js


class PDBResult {
  constructor() {
    this._resultArray = [];
    this._currentStr = -1;
    this._tag = null;
    this._fixedNumeration = false;
    this._numeration = false;
    this._tagStrNum = 0;
  }
  getResult() {
    this.writeString('\n', 81, 81);
    return this._resultArray.join('');
  }
  _currentStrLength() {
    const curStr = this._resultArray[this._currentStr];
    return curStr ? curStr.length : 0;
  }

  // numeration can be number or boolean
  // if numeration is number then just put this number to 8-10 pos in string
  // if numeration is boolean then increase number for all new strings
  newTag(tag, numeration) {
    if (!tag) {
      this._tag = null;
    } else {
      this._tag = tag;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(numeration)) {
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(numeration)) {
        this._tagStrNum = numeration;
        this._numeration = true;
        this._fixedNumeration = true;
      } else if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isBoolean(numeration)) {
        this._tagStrNum = 0;
        this._numeration = numeration;
        this._fixedNumeration = false;
      }
    } else {
      this._numeration = false;
      this._fixedNumeration = false;
      this._tagStrNum = 0;
    }
  }
  newString(tag) {
    this.writeString('\n', 81, 81);
    this._currentStr++;
    this._resultArray.push('');
    if (tag) {
      this.writeString(tag, 1, 6);
    } else if (this._tag) {
      this.writeString(this._tag, 1, 6);
    }
    if (this._numeration) {
      if (!this._fixedNumeration) {
        this._tagStrNum++;
      }
      if (this._tagStrNum !== 1) {
        this.writeString(this._tagStrNum.toString(), 10, 8);
      }
    }
  }
  writeEntireString(string, maxStrPos, concat) {
    if (!maxStrPos) {
      maxStrPos = 81;
    }
    for (let j = 0; j < string.length; j++) {
      if (this._currentStrLength() === maxStrPos && j !== string.length - 1) {
        this.newString();
        if (concat) {
          // pretty hardcoddy
          this.writeString(concat.tag, concat.begin, concat.end);
        }
      }
      if (string[j] === '\n') {
        this.newString();
      } else {
        this.writeString(string[j]);
      }
    }
  }
  writeString(string, begin, end) {
    let curStr = this._resultArray[this._currentStr];
    let str;
    const curStrLength = curStr ? curStr.length : 0;
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(string)) {
      return;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(begin)) {
      begin = curStrLength + 1;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(end)) {
      end = curStrLength + string.length;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(string)) {
      str = string.toString();
    } else {
      str = string;
    }
    const finish = begin < end ? end : begin;
    const start = begin < end ? begin : end;
    if (str.length > Math.abs(begin - end) + 1) {
      str = str.substr(0, Math.abs(begin - end + 1));
    }

    // spaces before start of new data
    if (start > curStrLength + 1) {
      this._resultArray[this._currentStr] += ' '.repeat(start - curStrLength - 1);
    } else if (start <= curStrLength) {
      const cStr = this._resultArray[this._currentStr];
      this._resultArray[this._currentStr] = cStr.slice(0, start - 1);
    }

    // if reverse order
    // reverse order of end and begin means that user wants to align text right
    if (end < begin) {
      const len = begin - end + 1;
      str = ' '.repeat(len - str.length) + str;
    }

    // some hardcode fix for space between string numeration and data
    // (see pdb file format description)
    if (start === 11 && this._numeration && this._tagStrNum !== 1) {
      str = ` ${str}`;
    }

    // append new data to string
    this._resultArray[this._currentStr] += str;
    curStr = this._resultArray[this._currentStr];
    if (finish > curStr.length) {
      this._resultArray[this._currentStr] += ' '.repeat(finish - curStr.length);
    }
  }
  writeBondsArray(bonds, atom) {
    const bondsArrays = this._getSubArrays(bonds, 4);
    for (let k = 0; k < bondsArrays.length; k++) {
      this.newString();
      this.writeString(atom.serial, 11, 7);
      for (let j = 0; j < bondsArrays[k].length; j++) {
        const serial = bondsArrays[k][j]._left.serial === atom.serial ? bondsArrays[k][j]._right.serial : bondsArrays[k][j]._left.serial;
        this.writeString(serial, 16 + 5 * j, 12 + 5 * j);
      }
    }
  }
  _getSubArrays(arr, subArraySize) {
    const subArrays = [];
    for (let i = 0; i < arr.length; i += subArraySize) {
      subArrays.push(arr.slice(i, i + subArraySize));
    }
    return subArrays;
  }

  // function for writing matrix in Remark290 and Remark350 tags
  // (see pdb file description)
  writeMatrix(matrix, matrixIndx, tag) {
    for (let j = 0; j < 3; j++) {
      this.newString();
      this.writeString(tag, 14, 18);
      this.writeString((j + 1).toString(), 19, 19);
      this.writeString(matrixIndx.toString(), 23, 20);
      for (let k = 0; k < 3; k++) {
        const numb = parseFloat(matrix.elements[j * 4 + k]).toFixed(6);
        this.writeString(numb.toString(), 33 + k * 10, 24 + k * 10);
      }
      const numb = parseFloat(matrix.elements[j * 4 + 3]).toFixed(5);
      this.writeString(numb.toString(), 68, 55);
    }
  }
  writeMatrices(matrices, string) {
    if (!matrices) {
      return;
    }
    const matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    for (let j = 0; j < matrices.length; j++) {
      matrix.copy(matrices[j]).transpose();
      this.writeMatrix(matrix, j + 1, string);
    }
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/PDBExporter.js






class PDBExporter extends Exporter {
  constructor(source, options) {
    super(source, options);
    this._tags = ['HEADER', 'TITLE', 'COMPND', 'REMARK', 'HELIX', 'SHEET', 'ATOM and HETATM', 'CONECT'];
    this._result = null;
    this._tagExtractors = {
      HEADER: this._extractHEADER,
      TITLE: this._extractTITLE,
      'ATOM and HETATM': this._extractATOM,
      CONECT: this._extractCONECT,
      COMPND: this._extractCOMPND,
      REMARK: this._extractREMARK,
      HELIX: this._extractHELIX,
      SHEET: this._extractSHEET
    };
    this._stringForRemark350 = 'COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\n' + 'BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\n' + 'MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\n' + 'GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\n' + 'CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.';
    this._stringForRemark290 = 'CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\n' + 'THE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\n' + 'RECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\n' + 'RELATED MOLECULES.';
  }
  exportSync() {
    const result = new PDBResult();
    if (!this._source) {
      return this._result;
    }
    for (let i = 0; i < this._tags.length; i++) {
      const tag = this._tags[i];
      const func = this._tagExtractors[tag];
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(func)) {
        func.call(this, result);
      }
    }
    this._result = result.getResult();
    return this._result;
  }
  _extractHEADER(result) {
    if (!this._source.metadata) {
      return;
    }
    const {
      metadata
    } = this._source;
    result.newTag('HEADER');
    result.newString();
    if (metadata.classification) {
      result.writeString(metadata.classification, 11, 50);
    }
    if (metadata.date) {
      result.writeString(metadata.date, 51, 59);
    }
    if (metadata.id) {
      result.writeString(metadata.id, 63, 66);
    }
  }
  _extractTITLE(result) {
    if (!this._source.metadata) {
      return;
    }
    const {
      metadata
    } = this._source;
    if (!metadata.title) {
      return;
    }
    result.newTag('TITLE', true);
    for (let i = 0; i < metadata.title.length; i++) {
      result.newString();
      result.writeString(metadata.title[i], 11, 80);
    }
  }
  _extractCONECT(result) {
    if (!this._source._atoms) {
      return;
    }
    const atoms = this._source._atoms;
    result.newTag('CONECT');
    for (let i = 0; i < atoms.length; i++) {
      const fixedBonds = atoms[i].bonds.filter(bond => bond._fixed);
      if (fixedBonds.length !== 0) {
        result.writeBondsArray(fixedBonds.reverse(), atoms[i]);
      }
    }
  }
  _extractSHEET(result) {
    if (!this._source._sheets) {
      return;
    }
    result.newTag('SHEET');
    const sheets = this._source._sheets;
    for (let i = 0; i < sheets.length; i++) {
      if (sheets[i]._strands) {
        const strands = sheets[i]._strands;
        for (let j = 0; j < strands.length; j++) {
          result.newString();
          result.writeString(j + 1, 10, 8);
          result.writeString(sheets[i]._name, 14, 12);
          result.writeString(strands.length, 16, 15);
          result.writeString(strands[j].init._type._name, 18, 20);
          result.writeString(strands[j].init._chain._name, 22, 22);
          result.writeString(strands[j].init._sequence, 26, 23);
          result.writeString(strands[j].init._icode, 27, 27);
          result.writeString(strands[j].term._type._name, 29, 31);
          result.writeString(strands[j].init._chain._name, 33, 33);
          result.writeString(strands[j].term._sequence, 37, 34);
          result.writeString(strands[j].term._icode, 38, 38);
          result.writeString(strands[j].sense, 40, 39);
        }
      }
    }
  }
  _extractHELIX(result) {
    if (!this._source._helices) {
      return;
    }
    result.newTag('HELIX');
    const helices = this._source._helices;
    for (let i = 0; i < helices.length; i++) {
      const helix = helices[i];
      const helixClass = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].invert(typeByPDBHelixClass);
      result.newString();
      result.writeString(helix.serial, 10, 8);
      result.writeString(helix.name, 14, 12);
      result.writeString(helix.init._type._name, 16, 18);
      result.writeString(helix.init._chain._name, 20, 20);
      result.writeString(helix.init._sequence, 25, 22);
      result.writeString(helix.init._icode, 26, 26);
      result.writeString(helix.term._type._name, 28, 30);
      result.writeString(helix.term._chain._name, 32, 32);
      result.writeString(helix.term._sequence, 37, 34);
      result.writeString(helix.term._icode, 38, 38);
      result.writeString(helixClass[helix.type], 40, 39);
      result.writeString(helix.comment, 41, 70);
      result.writeString(helix.length, 76, 72);
    }
  }
  _extractATOM(result) {
    if (!this._source._atoms) {
      return;
    }
    const atoms = this._source._atoms;
    for (let i = 0; i < atoms.length; i++) {
      const tag = atoms[i].het ? 'HETATM' : 'ATOM';
      result.newString(tag);
      const startIndx = atoms[i].element.name.length > 1 || atoms[i].name.length > 3 ? 13 : 14;
      result.writeString(atoms[i].serial, 11, 7);
      result.writeString(atoms[i].name, startIndx, 16);
      result.writeString(String.fromCharCode(atoms[i].location), 17, 17);
      result.writeString(atoms[i].residue._type._name, 20, 18);
      result.writeString(atoms[i].residue._chain._name, 22, 22);
      result.writeString(atoms[i].residue._sequence, 26, 23);
      result.writeString(atoms[i].residue._icode, 27, 27);
      result.writeString(atoms[i].position.x.toFixed(3), 38, 31);
      result.writeString(atoms[i].position.y.toFixed(3), 46, 39);
      result.writeString(atoms[i].position.z.toFixed(3), 54, 47);
      result.writeString(atoms[i].occupancy.toFixed(2), 60, 55);
      result.writeString(atoms[i].temperature.toFixed(2), 66, 61);
      result.writeString(atoms[i].element.name, 78, 77);
      if (atoms[i].charge) {
        result.writeString(atoms[i].charge, 79, 80);
      }
    }
  }
  _extractCOMPND(result) {
    if (!this._source._molecules) {
      return;
    }
    const molecules = this._source._molecules;
    result.newTag('COMPND', true);
    for (let i = 0; i < molecules.length; i++) {
      const chains = this._getMoleculeChains(molecules[i]);
      result.newString();
      result.writeString(`MOL_ID: ${molecules[i].index};`, 11, 80);
      result.newString();
      result.writeString(`MOLECULE: ${molecules[i].name};`, 11, 80);
      result.newString();
      result.writeString('CHAIN: ', 11, 18);
      const chainsString = `${chains.join(', ')};`;
      result.writeEntireString(chainsString, 81);
    }
  }
  _extractREMARK(result) {
    this._Remark290(result);
    this._Remark350(result);
  }
  _Remark290(result) {
    if (!this._source.symmetry) {
      return;
    }
    if (this._source.symmetry.length !== 0) {
      const matrices = this._source.symmetry;
      result.newTag('REMARK', 290);
      result.newString();
      result.newString();
      result.writeEntireString(this._stringForRemark290);
      result.writeMatrices(matrices, 'SMTRY');
      result.newString();
      result.newString();
      result.writeString('REMARK: NULL', 11, 80);
    }
  }
  _Remark350(result) {
    if (!this._source.units) {
      return;
    }
    const {
      units
    } = this._source;
    let biomolIndx = 0;
    result.newTag('REMARK', 350);
    result.newString();
    result.newString();
    result.writeEntireString(this._stringForRemark350);
    const assemblies = units.filter(unit => unit instanceof chem_Assembly);
    for (let i = 0; i < assemblies.length; i++) {
      result.newString();
      result.newString();
      biomolIndx++;
      result.writeString(`BIOMOLECULE: ${biomolIndx}`, 11, 80);
      const chains = assemblies[i].chains.join(', ');
      result.newString();
      result.writeString('APPLY THE FOLLOWING TO CHAINS: ');
      result.writeEntireString(chains, 69, {
        tag: 'AND CHAINS: ',
        begin: 31,
        end: 42
      });
      const {
        matrices
      } = assemblies[i];
      result.writeMatrices(matrices, 'BIOMT');
    }
  }
  _getMoleculeChains(molecule) {
    function getChainName(residue) {
      return residue._chain._name;
    }
    const chainNames = molecule.residues.map(getChainName);
    return chainNames.filter((item, pos) => chainNames.indexOf(item) === pos);
  }
}
PDBExporter.formats = ['pdb'];
PDBExporter.SourceClass = chem_Complex;
;// CONCATENATED MODULE: ./src/io/exporters/fbx/FBXModel.js

const FBX_POS_SIZE = 3;
const FBX_NORM_SIZE = 3;
const FBX_COL_SIZE = 4;
function copyFbxPoint3(src, srcIdx, dst, dstIdx) {
  dst[dstIdx] = src[srcIdx];
  dst[dstIdx + 1] = src[srcIdx + 1];
  dst[dstIdx + 2] = src[srcIdx + 2];
}
function copyFbxPoint4(src, srcIdx, dst, dstIdx, value) {
  dst[dstIdx] = src[srcIdx];
  dst[dstIdx + 1] = src[srcIdx + 1];
  dst[dstIdx + 2] = src[srcIdx + 2];
  dst[dstIdx + 3] = value;
}
const vector4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4();
function copyTransformedPoint3(src, srcIdx, dst, dstIdx, opts) {
  vector4.set(src[srcIdx], src[srcIdx + 1], src[srcIdx + 2], opts.w);
  vector4.applyMatrix4(opts.matrix);
  dst[dstIdx] = vector4.x;
  dst[dstIdx + 1] = vector4.y;
  dst[dstIdx + 2] = vector4.z;
}
function setSubArray(src, dst, count, copyFunctor, functorOpts) {
  if ((dst.array.length - dst.start) / dst.stride < count || (src.array.length - src.start) / src.stride < count) {
    return; // we've got no space
  }
  if (src.stride === dst.stride) {
    // stride is the same
    dst.array.set(src.array, dst.start);
  } else {
    let idx = dst.start;
    let arridx = src.start;
    for (let i = 0; i < count; ++i, idx += dst.stride, arridx += src.stride) {
      copyFunctor(src.array, arridx, dst.array, idx, functorOpts);
    }
  }
}
class FBXModel {
  constructor() {
    this.positions = null;
    this.normals = null;
    this.colors = null;
    this.indices = null;
    this.lastPos = 0;
    this.lastNorm = 0;
    this.lastCol = 0;
    this.lastIdx = 0;
  }
  init(vertsCount, indsCount) {
    this.positions = new Float32Array(vertsCount * FBX_POS_SIZE);
    this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE);
    this.colors = new Float32Array(vertsCount * FBX_COL_SIZE);
    this.indices = new Int32Array(indsCount);
  }
  setPositions(array, start, count, stride) {
    const src = {
      array,
      start,
      stride
    };
    const dst = {
      array: this.positions,
      start: this.lastPos,
      stride: FBX_POS_SIZE
    };
    setSubArray(src, dst, count, copyFbxPoint3);
    this.lastPos += count * FBX_POS_SIZE;
  }
  setTransformedPositions(array, start, count, stride, matrix) {
    let idx = this.lastPos;
    let arrIdx = start;
    const opts = {
      matrix,
      w: 1
    };
    for (let i = 0; i < count; ++i, arrIdx += stride, idx += FBX_POS_SIZE) {
      copyTransformedPoint3(array, arrIdx, this.positions, idx, opts);
    }
    this.lastPos += count * FBX_POS_SIZE;
  }
  setNormals(array, start, count, stride) {
    const src = {
      array,
      start,
      stride
    };
    const dst = {
      array: this.normals,
      start: this.lastNorm,
      stride: FBX_NORM_SIZE
    };
    setSubArray(src, dst, count, copyFbxPoint3);
    this.lastNorm += count * FBX_NORM_SIZE;
  }
  setTransformedNormals(array, start, count, stride, matrix) {
    let idx = this.lastNorm;
    let arrIdx = start;
    const opts = {
      matrix,
      w: 0
    };
    for (let i = 0; i < count; ++i, arrIdx += stride, idx += FBX_NORM_SIZE) {
      copyTransformedPoint3(array, arrIdx, this.normals, idx, opts);
    }
    this.lastNorm += count * FBX_NORM_SIZE;
  }
  setColors(array, start, count, stride) {
    const src = {
      array,
      start,
      stride
    };
    const dst = {
      array: this.colors,
      start: this.lastCol,
      stride: FBX_COL_SIZE
    };
    setSubArray(src, dst, count, copyFbxPoint4, 1);
    this.lastCol += count * FBX_COL_SIZE;
  }
  setIndices(array, start, count) {
    this.indices.set(array, this.lastIdx);
    this.lastIdx += count;
  }
  setShiftedIndices(array, count, shift) {
    const shifted = array.map(x => x + shift);
    this.setIndices(shifted, 0, count);
  }
  getVerticesNumber() {
    return this.lastPos / FBX_POS_SIZE;
  }
  addInstance(matrix, geo) {
    // add indices at first to take old number of vertices for shift
    const currentCount = this.getVerticesNumber();
    this.setShiftedIndices(geo.indices, geo.indices.length, currentCount);
    // simply write vertices at empty space
    const size = geo.itemSize;
    this.setTransformedPositions(geo.positions, 0, geo.vertsCount, size.position, matrix);
    this.setTransformedNormals(geo.normals, 0, geo.vertsCount, size.normal, matrix);
    this.setColors(geo.colors, 0, geo.vertsCount, size.color);
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/fbx/FBXGeometry.js
/** Base class for fbx geometry contains simply organized attributes: positions+normals+colors, indices. */
class FBXGeometry {
  /**
   * Create a base geo with necessary members.
   */
  constructor() {
    this.positions = null;
    this.normals = null;
    this.colors = null;
    this.indices = null;
    this.vertsCount = 0;
    this.itemSize = null;
  }

  /**
   * Initialize base geo storing items info from attributes.
   * @param {Object} geo - THREE.BufferGeometry.
   */
  init(geo, _info) {
    const {
      attributes
    } = geo;
    // save item size
    this.itemSize = {
      position: attributes.position.itemSize,
      normal: attributes.normal.itemSize,
      color: attributes.color.itemSize
    };
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/fbx/FBX1CGeometry.js


/**
 * Fbx geometry, that copies positions+normals, indexes and creates colors filled with defined value.
 * @extends FBXGeometry
 */
class FBX1CGeometry extends FBXGeometry {
  /**
   * Initialize geo storing positions, normals, indices and create colors.
   * @param {Object} geo - THREE.BufferGeometry.
   */
  init(geo, _info) {
    super.init(geo, _info);
    const {
      attributes: {
        position,
        normal
      },
      index
    } = geo;
    // copy vertices attributes
    this.vertsCount = position.count;
    this.positions = position.array;
    this.normals = normal.array;
    // create color array
    this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
    // indices
    this.indices = index.array;
  }

  /**
   * Set defined color for all items in color attribute
   * @param {Object} color - THREE.Color.
   */
  setColors(color) {
    let offset = 0;
    for (let i = 0, l = this.colors.length, cl = this.itemSize.color; i < l; i += cl) {
      this.colors[offset++] = color.r;
      this.colors[offset++] = color.g;
      this.colors[offset++] = color.b;
    }
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/fbx/FBX2CCylinder.js


/**
 * Fbx geometry, that copies positions+normals, indexes from cylinder  geometry and creates colors filled with two
 * defined values.
 * @extends FBXGeometry
 */
class FBX2CCylinder extends FBXGeometry {
  constructor() {
    super();
    this._cutRawStart = 0;
    this._cutRawEnd = 0;
    this._facesPerSlice = 0;
  }

  /**
   * Initialize geo by creating new attributes, because we extend number of vertices to make cylinder two-colored.
   * Indices remain the same. We process open- end close-ended cylinders and consider cylinders od 2 segments
   * in height ONLY.
   * NOTE: cylinder consists of 2 height segments and stores parts in the order: tube, topCap, bottomCap
   * @param {Object} geo - THREE.BufferGeometry.
   * @param {Object} info - information needed for geo extend
   */
  init(geo, info) {
    super.init(geo, info);
    const {
      attributes: {
        position
      },
      index
    } = geo;
    // extend vertices arrays
    this.vertsCount = position.count + info.addPerCylinder;
    this._facesPerSlice = info.addPerCylinder;
    this.positions = new Float32Array(this.vertsCount * position.itemSize);
    this.normals = new Float32Array(this.vertsCount * this.itemSize.normal);
    this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
    this._extendVertices(geo, info);
    // number of indices stays the same
    this.indices = new Uint32Array(index.count);
    this._extendIndices(geo, info);
  }

  /** Extend vertex attributes to have one more slice to make sharp middle startColor-endColor line. */
  _extendVertices(geo, info) {
    const {
      position
    } = geo.attributes;
    const {
      normal
    } = geo.attributes;
    const geoParams = geo.getGeoParams();
    const cutRaw = 1; // we expect cylinders of 2 segments in height => so half segment = 1
    this._cutRawStart = cutRaw * geoParams.radialSegments;
    this._cutRawEnd = this._cutRawStart + info.addPerCylinder;
    {
      // write first half of cylinder
      let temp = position.array.slice(0, this._cutRawEnd * position.itemSize);
      this.positions.set(temp, 0);
      temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize);
      this.normals.set(temp, 0);
    }
    {
      // write second part of cylinder
      let temp = position.array.slice(this._cutRawStart * position.itemSize, position.array.length);
      this.positions.set(temp, this._cutRawEnd * position.itemSize);
      temp = normal.array.slice(this._cutRawStart * normal.itemSize, normal.array.length);
      this.normals.set(temp, this._cutRawEnd * normal.itemSize);
    }
  }

  /** Shift values of second part (+caps) indices by newly added vertices count. Number of faces remains the same. */
  _extendIndices(geo, info) {
    const {
      index
    } = geo;
    const indicesPerQuad = 6; // quad = 2 triangles => 6 indices
    const startToShift = info.addPerCylinder * indicesPerQuad;
    const shift = info.addPerCylinder;
    let shifted = index.array.slice(startToShift, index.count);
    shifted = shifted.map(x => x + shift); // shift only the endings
    this.indices.set(index.array, 0);
    this.indices.set(shifted, startToShift);
  }

  /**
   * Set defined colors: (first part + bottom cap), (second part + top cap)
   * @param {number} start - start color index
   * @param {number} end - start color index
   * @param {array} array - array of colors
   * @param {array} color - color value components
   */
  _setColorRange(start, end, array, color) {
    const colorSize = color.length;
    for (let i = start; i < end; i += colorSize) {
      array.set(color, i);
    }
  }

  /**
   * Set defined colors: (first part + bottom cap), (second part + top cap)
   * @param {Object} color1 - THREE.Color.
   * @param {Object} color2 - THREE.Color.
   */
  setColors(color1, color2) {
    const colorSize = this.itemSize.color;
    const part1End = this._cutRawEnd * colorSize;
    const part2End = part1End * 2;
    this._setColorRange(0, part1End, this.colors, color1.toArray());
    this._setColorRange(part1End, part2End, this.colors, color2.toArray());
    if (part2End < this.colors.length) {
      // cylinder has caps, lets paint them
      const capSize = (this._facesPerSlice + 1) * colorSize;
      const cap1End = part2End + capSize;
      this._setColorRange(part2End, cap1End, this.colors, color2.toArray());
      const cap2End = cap1End + capSize; // should be equal to this.colors.length;
      this._setColorRange(cap1End, cap2End, this.colors, color1.toArray());
    }
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/fbx/FBXInfoExtractor.js












class FBXInfoExtractor {
  constructor() {
    this._materials = [];
    this._models = [];
  }
  process(data) {
    this._extractModelsAndMaterials(data);
    const models = this._flattenModels();
    return {
      name: data.name,
      models,
      materials: this._materials
    };
  }

  /**
   * Extract fbx object information from ComplexVisual
   * @param {object} data - complexVisual to get geometry info from
   */
  _extractModelsAndMaterials(data) {
    const layersOfInterest = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Layers();
    layersOfInterest.set(gfxutils.LAYERS.DEFAULT);
    layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT);
    data.traverse(object => {
      if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh && object.layers.test(layersOfInterest) && this.checkExportAbility(object)) {
        if (object.geometry.type === 'InstancedBufferGeometry') {
          this._collectInstancedGeoInfo(object);
        } else {
          this._collectGeoInfo(object);
        }
      }
    });
  }

  /**
   * Reworking indices buffer, see https://banexdevblog.wordpress.com/2014/06/23/a-quick-tutorial-about-the-fbx-ascii-format/
   * basically, every triangle in Miew has been represented hat way (e.g.) : 0,1,7, but we must (for FBX) rework that
   * into: 0,1,-8.
   * @param {array} indices - belongs to [0, maxVertIndex]
   */
  _reworkIndices(indices) {
    const faceSize = 3;
    for (let i = faceSize - 1; i < indices.length; i += faceSize) {
      indices[i] *= -1;
      indices[i]--;
    }
  }

  /**
   * Combine geometry from several models having the same material into one Model and finally prepare indices
    * @returns {array} models, combined by material id
   */
  _flattenModels() {
    let overallVertsCount = 0;
    function shift(x) {
      return x + overallVertsCount;
    }
    const combined = [];
    // flatten models geometry
    for (let i = 0, n = this._models.length; i < n; i++) {
      const models = this._models[i];
      let indices = [];
      let positions = [];
      let normals = [];
      let colors = [];
      // reorganize every attributes as array of arrays
      overallVertsCount = 0;
      for (let j = 0; j < models.length; j++) {
        const m = models[j];
        indices.push(m.indices.map(shift));
        overallVertsCount += m.getVerticesNumber();
        positions.push(m.positions);
        normals.push(m.normals);
        colors.push(m.colors);
      }
      // join all subarrays into one
      indices = utils.mergeTypedArraysUnsafe(indices);
      this._reworkIndices(indices);
      positions = utils.mergeTypedArraysUnsafe(positions);
      normals = utils.mergeTypedArraysUnsafe(normals);
      colors = utils.mergeTypedArraysUnsafe(colors);
      combined.push({
        indices,
        positions,
        normals,
        colors,
        verticesCount: overallVertsCount
      });
    }
    return combined;
  }

  /**
   * Check ability to export the kind of mesh.
   * @param {object} mesh - given mesh to check
   * @returns {boolean} result of check
   */
  checkExportAbility(mesh) {
    // check mesh on not being empty
    if (mesh.geometry.attributes.position.count === 0) {
      return false;
    }
    // check type of mesh
    // if (mesh.geometry.isInstancedBufferGeometry && settings.now.zSprites) {
    if (mesh instanceof meshes_ZSpriteMesh) {
      logger.warn('Currently we cannot export \'sprites\' modes, like BS, WV, LC. Please turn of settings \'zSprites\' and try again');
      return false;
    }
    if (mesh instanceof meshes_ThickLineMesh) {
      logger.warn('Currently we cannot export Lines mode');
      return false;
    }
    return true;
  }

  /**
   * Save geometry info from common mesh, like Surface or Cartoon
   */
  _collectGeoInfo(mesh) {
    const {
      geometry: {
        attributes: {
          position,
          color,
          normal
        },
        index
      },
      matrix
    } = mesh;
    const model = new FBXModel();
    const vertCount = position.count;
    model.init(vertCount, index.count);
    if (matrix.isIdentity()) {
      model.setPositions(position.array, 0, vertCount, position.itemSize);
      model.setNormals(normal.array, 0, vertCount, normal.itemSize);
    } else {
      model.setTransformedPositions(position.array, 0, vertCount, position.itemSize, matrix);
      model.setTransformedNormals(normal.array, 0, vertCount, normal.itemSize, matrix);
    }
    model.setColors(color.array, 0, vertCount, color.itemSize);
    model.setIndices(index.array, 0, index.count);
    const material = this._collectMaterialInfo(mesh);
    this._addToPool(model, material);
  }

  /**
   * Collect instanced spheres geometry and materials.
   * @param {object} mesh - mesh with instanced spheres info
   */
  _collectSpheresInfo(mesh) {
    const {
      geometry: {
        attributes: {
          position,
          color
        },
        index
      },
      matrix
    } = mesh;
    const model = new FBXModel();
    const instCount = mesh.geometry.instanceCount;
    const vertCount = position.count;
    const indsCount = index.count;
    model.init(instCount * vertCount, instCount * indsCount);
    const geo = new FBX1CGeometry();
    geo.init(mesh.geometry);
    const instMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const objMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const sphereColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
    for (let instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
      // update colors in geometry
      const colorIdx = instanceIndex * color.itemSize;
      sphereColor.fromArray(color.array, colorIdx);
      geo.setColors(sphereColor);
      // add instance to the model
      this._getSphereInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);
      objMatrix.multiplyMatrices(matrix, instMatrix);
      model.addInstance(objMatrix, geo);
    }
    const material = this._collectMaterialInfo(mesh);
    this._addToPool(model, material);
  }

  /**
   * Getting all instanced cylinders from given mesh.
   * Divide cylinder (add additional vertexes) for prettiness therefore algorithm is a bit complicated
   * @param {object} mesh - given mesh with instanced cylinders
   */
  _collectCylindersInfo(mesh) {
    const {
      geometry: {
        attributes: {
          position,
          color,
          color2
        },
        index
      },
      matrix
    } = mesh;
    const model = new FBXModel();
    const instCount = mesh.geometry.instanceCount;
    const oneCCylinder = new FBX1CGeometry();
    oneCCylinder.init(mesh.geometry);
    const splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry);
    let twoCCylinder = null;
    if (splittingInfo.needToSplit > 0) {
      twoCCylinder = new FBX2CCylinder();
      twoCCylinder.init(mesh.geometry, splittingInfo);
    }
    const additionalVertsCount = splittingInfo.addPerCylinder * splittingInfo.needToSplit;
    const vertCount = position.count;
    const indsCount = index.count;
    model.init(instCount * vertCount + additionalVertsCount, instCount * indsCount);
    const instMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const objMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const colorStart = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
    const colorEnd = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
    let geo = {};
    for (let instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
      // update colors in geometry
      const colorIdx = instanceIndex * color.itemSize;
      if (splittingInfo.is2Colored[instanceIndex]) {
        // .color2 contains starting color, and .color contains starting color (see uber.frag ATTR_COLOR2)
        colorStart.fromArray(color2.array, colorIdx);
        colorEnd.fromArray(color.array, colorIdx);
        if (twoCCylinder) {
          twoCCylinder.setColors(colorStart, colorEnd);
          geo = twoCCylinder;
        }
      } else {
        // has one color per cylinder
        colorStart.fromArray(color.array, colorIdx);
        oneCCylinder.setColors(colorStart);
        geo = oneCCylinder;
      }
      // add instance to the model
      this._getCylinderInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);
      objMatrix.multiplyMatrices(matrix, instMatrix);
      model.addInstance(objMatrix, geo);
    }
    const material = this._collectMaterialInfo(mesh);
    this._addToPool(model, material);
  }

  /**
   * Adding model to pool of models or extend existing ones
   * @param {object} model - model to add
   * @param {object} material - material to add
   */
  _addToPool(model, material) {
    const materialIdx = this._checkExistingMaterial(material);
    if (materialIdx < 0) {
      // new model-material pair
      this._models.push([model]);
      this._materials.push(material);
    } else {
      // add model to existing model-material pair
      const models = this._models[materialIdx];
      models.push(model);
    }
  }

  /**
   * Checking if given material already was registered in materials pool (no need to create new one)
   * @param {object} material - given material
   * @returns {number} number of model-material pair
   */
  _checkExistingMaterial(material) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].findIndex(this._materials, m => external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(m, material));
  }
  _gatherCylindersColoringInfo(geo) {
    const instCount = geo.instanceCount;
    const color1 = geo.attributes.color.array;
    const color2 = geo.attributes.color2.array;
    const stride = geo.attributes.color.itemSize;
    const is2Colored = new Array(instCount);
    // analyze color instance attributes
    let needToSplit = 0;
    let colIdx = 0;
    for (let i = 0; i < instCount; i++, colIdx += stride) {
      const differs = Math.abs(color1[colIdx] - color2[colIdx]) > 0.0000001 // compare ending colors
      || Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 0.0000001 || Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 0.0000001;
      is2Colored[i] = differs;
      needToSplit += differs; // count number of 2-colored cylinders
    }
    // calc number of vertices to add into 2-colored
    const geoParams = geo.getGeoParams();
    const addPerCylinder = geoParams.radialSegments;
    return {
      is2Colored,
      needToSplit,
      addPerCylinder
    };
  }

  /**
   * Collect instanced models and materials.
   * @param {object} mesh - given mesh with instanced something (spheres or cylinders)
   */
  _collectInstancedGeoInfo(mesh) {
    if (mesh.geometry instanceof geometries_InstancedSpheresGeometry) {
      this._collectSpheresInfo(mesh);
    } else if (mesh.geometry instanceof geometries_Instanced2CCylindersGeometry) {
      this._collectCylindersInfo(mesh);
    }
  }

  /**
   * Collect Material info from given mesh.
   * @param {object} mesh - given mesh with material info
   * @returns {object} material
   */
  _collectMaterialInfo(mesh) {
    const {
      uberOptions
    } = mesh.material;
    return {
      diffuse: uberOptions.diffuse.toArray(),
      opacity: uberOptions.opacity,
      shininess: uberOptions.shininess,
      specular: uberOptions.specular.toArray()
    };
  }
  _getCylinderInstanceMatrix(geo, instIdx, matrix) {
    const matVector1 = geo.attributes.matVector1.array;
    const matVector2 = geo.attributes.matVector2.array;
    const matVector3 = geo.attributes.matVector3.array;
    const idxOffset = instIdx * 4; // used 4 because offset arrays are stored in quads
    matrix.set(matVector1[idxOffset], matVector1[idxOffset + 1], matVector1[idxOffset + 2], matVector1[idxOffset + 3], matVector2[idxOffset], matVector2[idxOffset + 1], matVector2[idxOffset + 2], matVector2[idxOffset + 3], matVector3[idxOffset], matVector3[idxOffset + 1], matVector3[idxOffset + 2], matVector3[idxOffset + 3], 0, 0, 0, 1);
  }
  _getSphereInstanceMatrix(geo, instIdx, matrix) {
    const {
      offset
    } = geo.attributes;
    const idx = instIdx * offset.itemSize;
    const x = offset.array[idx];
    const y = offset.array[idx + 1];
    const z = offset.array[idx + 2];
    const scale = offset.array[idx + 3];
    matrix.set(scale, 0, 0, x, 0, scale, 0, y, 0, 0, scale, z, 0, 0, 0, 1);
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/fbx/FBXResult.js
// Forming default definitions block
const defaultDefinitions = `
Definitions:  {
  Version: 100
  Count: 3
  ObjectType: "Model" {
    Count: 1
  }
  ObjectType: "Geometry" {
    Count: 1
  }
  ObjectType: "Material" {
    Count: 1
  }
  ObjectType: "Pose" {
    Count: 1
  }
  ObjectType: "GlobalSettings" {
    Count: 1
  }
} `;

// Default model properties
const defaultProperties = `Properties60: {
      Property: "QuaternionInterpolate", "bool", "",0
      Property: "Visibility", "Visibility", "A",1
      Property: "Lcl Translation", "Lcl Translation", "A",0.000000000000000,0.000000000000000,-1789.238037109375000
      Property: "Lcl Rotation", "Lcl Rotation", "A",0.000009334667643,-0.000000000000000,0.000000000000000
      Property: "Lcl Scaling", "Lcl Scaling", "A",1.000000000000000,1.000000000000000,1.000000000000000
      Property: "RotationOffset", "Vector3D", "",0,0,0
      Property: "RotationPivot", "Vector3D", "",0,0,0
      Property: "ScalingOffset", "Vector3D", "",0,0,0
      Property: "ScalingPivot", "Vector3D", "",0,0,0
      Property: "TranslationActive", "bool", "",0
      Property: "TranslationMin", "Vector3D", "",0,0,0
      Property: "TranslationMax", "Vector3D", "",0,0,0
      Property: "TranslationMinX", "bool", "",0
      Property: "TranslationMinY", "bool", "",0
      Property: "TranslationMinZ", "bool", "",0
      Property: "TranslationMaxX", "bool", "",0
      Property: "TranslationMaxY", "bool", "",0
      Property: "TranslationMaxZ", "bool", "",0
      Property: "RotationOrder", "enum", "",0
      Property: "RotationSpaceForLimitOnly", "bool", "",0
      Property: "AxisLen", "double", "",10
      Property: "PreRotation", "Vector3D", "",0,0,0
      Property: "PostRotation", "Vector3D", "",0,0,0
      Property: "RotationActive", "bool", "",0
      Property: "RotationMin", "Vector3D", "",0,0,0
      Property: "RotationMax", "Vector3D", "",0,0,0
      Property: "RotationMinX", "bool", "",0
      Property: "RotationMinY", "bool", "",0
      Property: "RotationMinZ", "bool", "",0
      Property: "RotationMaxX", "bool", "",0
      Property: "RotationMaxY", "bool", "",0
      Property: "RotationMaxZ", "bool", "",0
      Property: "RotationStiffnessX", "double", "",0
      Property: "RotationStiffnessY", "double", "",0
      Property: "RotationStiffnessZ", "double", "",0
      Property: "MinDampRangeX", "double", "",0
      Property: "MinDampRangeY", "double", "",0
      Property: "MinDampRangeZ", "double", "",0
      Property: "MaxDampRangeX", "double", "",0
      Property: "MaxDampRangeY", "double", "",0
      Property: "MaxDampRangeZ", "double", "",0
      Property: "MinDampStrengthX", "double", "",0
      Property: "MinDampStrengthY", "double", "",0
      Property: "MinDampStrengthZ", "double", "",0
      Property: "MaxDampStrengthX", "double", "",0
      Property: "MaxDampStrengthY", "double", "",0
      Property: "MaxDampStrengthZ", "double", "",0
      Property: "PreferedAngleX", "double", "",0
      Property: "PreferedAngleY", "double", "",0
      Property: "PreferedAngleZ", "double", "",0
      Property: "InheritType", "enum", "",0
      Property: "ScalingActive", "bool", "",0
      Property: "ScalingMin", "Vector3D", "",1,1,1
      Property: "ScalingMax", "Vector3D", "",1,1,1
      Property: "ScalingMinX", "bool", "",0
      Property: "ScalingMinY", "bool", "",0
      Property: "ScalingMinZ", "bool", "",0
      Property: "ScalingMaxX", "bool", "",0
      Property: "ScalingMaxY", "bool", "",0
      Property: "ScalingMaxZ", "bool", "",0
      Property: "GeometricTranslation", "Vector3D", "",0,0,0
      Property: "GeometricRotation", "Vector3D", "",0,0,0
      Property: "GeometricScaling", "Vector3D", "",1,1,1
      Property: "LookAtProperty", "object", ""
      Property: "UpVectorProperty", "object", ""
      Property: "Show", "bool", "",1
      Property: "NegativePercentShapeSupport", "bool", "",1
      Property: "DefaultAttributeIndex", "int", "",0
      Property: "Color", "Color", "A+",0,0,0
      Property: "Size", "double", "",100
      Property: "Look", "enum", "",1
    }`;

// Default materials layer
const defaultMaterialLayer = `
    LayerElementMaterial: 0 {
      Version: 101
      Name: ""
      MappingInformationType: "AllSame"
      ReferenceInformationType: "Direct"
      Materials: 0
    }`;

// Default layers block
const defaultLayerBlock = `
    Layer: 0 {
      Version: 100
      LayerElement:  {
        Type: "LayerElementNormal"
        TypedIndex: 0
      }
      LayerElement:  {
        Type: "LayerElementColor"
        TypedIndex: 0
      }
      LayerElement:  {
        Type: "LayerElementMaterial"
        TypedIndex: 0
      }
    }`;

/**
 * globalSettings info in output file.
 */
const globalSettings = `GlobalSettings: {
    Version: 1000
    Properties60:  {
      Property: "UpAxis", "int", "",1
      Property: "UpAxisSign", "int", "",1
      Property: "FrontAxis", "int", "",2
      Property: "FrontAxisSign", "int", "",1
      Property: "CoordAxis", "int", "",0
      Property: "CoordAxisSign", "int", "",1
      Property: "UnitScaleFactor", "double", "",1
    }
  }`;
class FBXResult {
  constructor() {
    this._resultArray = [];
    this._info = null;
  }
  getResult(info) {
    this._info = info;
    this._resultArray.push(this._writeHeader());
    this._resultArray.push(this._writeDefinitions());
    this._resultArray.push(this._writeObjects(info.models, info.materials));
    this._resultArray.push(this._writeRelations());
    this._resultArray.push(this._writeConnections()); // connections between models and materials)
    this._info = null;
    return this._resultArray.join('');
  }

  /**
   * Add FBXHeader info to output file.
   * Some fields are really confusing, but it seems that all listed fields are very informative
   */
  _writeHeader() {
    const FBXHeaderVersion = 1003; // 1003 is some number which appears to present in many 6.1 ASCII files
    const FBXVersion = 6100; // Mandatory and only supported version
    const date = new Date();
    const timeStampVersion = 1000;
    const creator = `Miew FBX Exporter v${this._info.version}`; // Supposed to be an engine

    return `; FBX 6.1.0 project file
; Created by ${creator} Copyright (c) 2015-2024 EPAM Systems, Inc.
; For support please contact miew@epam.com
; ----------------------------------------------------

FBXHeaderExtension:  {
  FBXHeaderVersion: ${FBXHeaderVersion}
  FBXVersion: ${FBXVersion}
  CreationTimeStamp:  {
    Version: ${timeStampVersion}
    Year: ${date.getFullYear()}
    Month: ${date.getMonth() + 1}
    Day: ${date.getDate()}
    Hour: ${date.getHours()}
    Minute: ${date.getMinutes()}
    Second: ${date.getSeconds()}
    Millisecond: ${date.getMilliseconds()}
  }
  Creator: "${creator}"
  OtherFlags:  {
    FlagPLE: 0
  }
}
CreationTime: "${date}"
Creator: "${creator}"
`;
  }

  /**
   * Add Definitions info to output file.
   * Not exactly sure if this section is template section (as it is in 7.4+) or it should every time be like this
   */
  _writeDefinitions() {
    return `
; Object definitions
;------------------------------------------------------------------

${defaultDefinitions}
`;
  }

  /**
   * Adding gathered information about Models to resulting string.
   * Reminder - there may be more then 1 model in scene, but we must place materials after ALL models.
   * @returns {string} string containing all models (vertices, indices, colors, normals etc)
   */
  _models() {
    const modelVersion = 232;
    let allModels = '';
    const {
      models
    } = this._info;
    for (let i = 0; i < models.length; ++i) {
      const model = models[i];
      const vertCount = model.verticesCount;
      allModels += `
  Model: "Model::${this._info.name}_${i}", "Mesh" {
    Version: ${modelVersion}
    ${defaultProperties}
    ${this._verticesIndices(model.positions, model.indices)}
    ${this._normalLayer(model.normals)}
    ${this._colorLayer(model.colors, vertCount)}
    ${defaultMaterialLayer}
    ${defaultLayerBlock}
  }`;
    }
    return allModels;
  }

  /**
   * Add Material info to result
   */
  _materials() {
    const materialVersion = 102;
    let allMaterials = '';
    const {
      materials
    } = this._info;
    for (let i = 0; i < materials.length; ++i) {
      const material = materials[i];
      allMaterials += `
  Material: "Material::${this._info.name}_${i}_default", "" {
    Version: ${materialVersion}
    ShadingModel: "lambert"
    MultiLayer: 0
    ${this._materialProperties(material)}
  }`;
    }
    return allMaterials;
  }

  /**
   * Add Objects info to output file.
   */
  _writeObjects() {
    return `
; Object properties
;------------------------------------------------------------------

Objects:  {
  ${this._models()}
  ${this._materials()}
  ${globalSettings}
}
`;
  }

  /**
   * Add Relations info to output file.
   */
  _writeRelations() {
    let modelsList = '';
    for (let i = 0; i < this._info.models.length; ++i) {
      modelsList += `
  Model: "Model::${this._info.name}_${i}", "Mesh" {
  }`;
    }
    let materialList = '';
    for (let i = 0; i < this._info.materials.length; ++i) {
      materialList += `
  Material: "Material::${this._info.name}_${i}_default", "" {
  }`;
    }
    return `
; Object relations
;------------------------------------------------------------------

Relations:  {
  ${modelsList}
  Model: "Model::Producer Perspective", "Camera" {
  }
  Model: "Model::Producer Top", "Camera" {
  }
  Model: "Model::Producer Bottom", "Camera" {
  }
  Model: "Model::Producer Front", "Camera" {
  }
  Model: "Model::Producer Back", "Camera" {
  }
  Model: "Model::Producer Right", "Camera" {
  }
  Model: "Model::Producer Left", "Camera" {
  }
  Model: "Model::Camera Switcher", "CameraSwitcher" {
  }
  ${materialList}
}`;
  }

  /**
   * Add Connections info to output file.
   */
  _writeConnections() {
    let modelsList = '';
    const {
      name
    } = this._info;
    for (let i = 0; i < this._info.models.length; ++i) {
      modelsList += `
  Connect: "OO", "Model::${name}_${i}", "Model::Scene"`;
    }
    let materialList = '';
    for (let i = 0; i < this._info.materials.length; ++i) {
      materialList += `
  Connect: "OO", "Material::${name}_${i}_default", "Model::${name}_${i}"`;
    }
    return `
; Object connections
;------------------------------------------------------------------

Connections:  {
  ${modelsList}
  ${materialList}
}`;
  }

  /**
   * Write float array to string with limited precision
   * @param {Float32Array} array - array to be fixed
   * @returns {String} String with fixed floats
   */
  _floatArrayToString(array) {
    const str = [];
    for (let i = 0; i < array.length; ++i) {
      str[i] = array[i].toFixed(6);
    }
    return str.join(',');
  }

  /**
   * Adding color layer to resulting file
   * @param {Float32Array} colorArray attribute
   * @param {number} vertCount - number of vertices in the model
   * @returns {string} color layer info
   */
  _colorLayer(colorArray, vertCount) {
    const layerElementColorNumber = 0;
    const layerElementColorVersion = 101;
    const layerElementColorName = '';
    const colorsStr = this._floatArrayToString(colorArray);
    // Mapping Information type and Reference Information type are mandatory for our Miew! Must not be changed
    // As said [..Array(...)] - fastest and easiest way to produce [0, 1, .....] array
    const colorIndices = [...Array(vertCount).keys()];
    return `
    LayerElementColor: ${layerElementColorNumber} {
      Version: ${layerElementColorVersion}
      Name: "${layerElementColorName}"
      MappingInformationType: "ByVertice"
      ReferenceInformationType: "Direct"
      Colors: ${colorsStr}
      ColorIndex: ${colorIndices}
    }`;
  }

  /**
   * Adding normal layer to resulting file
   * @param {Float32Array} normalArray attribute
   * @returns {string} normal layer info
   */
  _normalLayer(normalArray) {
    const layerElementNormalNumber = 0;
    const layerElementNormalVersion = 101;
    const layerElementNormalName = '';
    const normalsStr = this._floatArrayToString(normalArray);
    // Mapping Information type and Reference Information type are mandatory for our Miew! Must not be changed
    return `
    LayerElementNormal: ${layerElementNormalNumber} {
      Version: ${layerElementNormalVersion}
      Name: "${layerElementNormalName}"
      MappingInformationType: "ByVertice"
      ReferenceInformationType: "Direct"
      Normals: ${normalsStr}
    }`;
  }

  /**
   * Adding vertices and indices to resulting string
   * @return {string} resulting string in FBX notation
   */
  _verticesIndices(positions, indices) {
    const multiLayer = 0;
    const multiTake = 1;
    const shading = 'Y';
    const culling = 'CullingOff';
    const geometryVersion = 124;
    const vertStr = this._floatArrayToString(positions);
    /* About _correctArrayNotation: Float32Arrays will contains only Float32 numbers, which implies that it will be floating points with 17 numbers after point.
    * We cannot (and it's logically incorrect) save all this information, so we convert this Float32Array into Array-like object with numbers with only 6 numbers after point
    * Reminder - this is big memory loss (as we must save at one moment two arrays with similar information) */
    return `MultiLayer: ${multiLayer}
    MultiTake: ${multiTake}
    Shading: ${shading}
    Culling: "${culling}"
    Vertices: ${vertStr}
    PolygonVertexIndex: ${indices}
    GeometryVersion: ${geometryVersion}`;
  }

  /**
   * Forming material properties block.
   * @param {Object} material - given material of model
   * @returns {String} material properties string
   */
  _materialProperties(material) {
    return `Properties60:  {
      Property: "ShadingModel", "KString", "", "Lambert"
      Property: "MultiLayer", "bool", "",0
      Property: "EmissiveColor", "ColorRGB", "",0,0,0
      Property: "EmissiveFactor", "double", "",0.0000
      Property: "AmbientColor", "ColorRGB", "",1,1,1
      Property: "AmbientFactor", "double", "",0.0000
      Property: "DiffuseColor", "ColorRGB", "",${material.diffuse}
      Property: "DiffuseFactor", "double", "",1.0000
      Property: "Bump", "Vector3D", "",0,0,0
      Property: "TransparentColor", "ColorRGB", "",1,1,1
      Property: "TransparencyFactor", "double", "",0.0000
      Property: "SpecularColor", "ColorRGB", "",${material.specular}
      Property: "SpecularFactor", "double", "",1.0000
      Property: "ShininessExponent", "double", "",${material.shininess}
      Property: "ReflectionColor", "ColorRGB", "",0,0,0
      Property: "ReflectionFactor", "double", "",1
      Property: "Ambient", "ColorRGB", "",1,1,1
      Property: "Diffuse", "ColorRGB", "",${material.diffuse}
      Property: "Specular", "ColorRGB", "",${material.specular}
      Property: "Shininess", "double", "",${material.shininess}
      Property: "Opacity", "double", "",${material.opacity}
      Property: "Reflectivity", "double", "",0
    }`;
  }
}
;// CONCATENATED MODULE: ./src/io/exporters/FBXExporter.js




class FBXExporter extends Exporter {
  constructor(source, options) {
    super(source, options);
    // Data
    this._data = source;
    this._version = options.miewVersion || '0.0-UNSPECIFIED';
    this._extractor = new FBXInfoExtractor();
  }

  /**
   * Entry point to exporter.
   */
  exportSync() {
    // Creating mandatory blocks
    const result = new FBXResult();
    if (!this._source) {
      return this._result;
    }
    const info = this._extractor.process(this._data);
    info.version = this._version;
    this._result = result.getResult(info);
    return this._result;
  }
}
FBXExporter.formats = ['fbx'];
FBXExporter.SourceClass = src_ComplexVisual;
;// CONCATENATED MODULE: ./src/io/exporters.js



/* harmony default export */ const exporters = (new exporters_ExporterList([PDBExporter, FBXExporter]));
;// CONCATENATED MODULE: ./src/io/io.js



/* harmony default export */ const io = ({
  loaders: loaders,
  parsers: parsers,
  exporters: exporters
});
;// CONCATENATED MODULE: ./src/gfx/CSS2DRenderer.js
/**
 * @author mrdoob / http://mrdoob.com/
 */



const tempColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
class CSS2DRenderer {
  constructor() {
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this._vector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._viewMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    this._projectionMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    this._domElement = document.createElement('div');
    this._domElement.style.overflow = 'hidden';
    this._domElement.style.position = 'absolute';
    this._domElement.style.top = '0';
    this._domElement.style.zIndex = '0'; // start a new Stacking Context to enclose all z-ordered children
    this._domElement.style.pointerEvents = 'none';
  }
  getElement() {
    return this._domElement;
  }
  reset() {
    const myNode = this.getElement();
    while (myNode.firstChild) {
      myNode.removeChild(myNode.firstChild);
    }
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this._widthHalf = this._width / 2;
    this._heightHalf = this._height / 2;
    this._domElement.style.width = `${width}px`;
    this._domElement.style.height = `${height}px`;
  }
  _renderObject(object, camera, scene) {
    function lerpColorAsHex(a, b, t) {
      tempColor.setHex(a);
      tempColor.lerp(b, t);
      return `#${tempColor.getHexString()}`;
    }
    function colorAsHex(a) {
      tempColor.setHex(a);
      return `#${tempColor.getHexString()}`;
    }
    if (object instanceof gfx_CSS2DObject) {
      this._vector.setFromMatrixPosition(object.matrixWorld);
      if (object.userData !== undefined && object.userData.offset !== undefined) {
        const localOffset = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(object.userData.offset.x, object.userData.offset.y, 0);
        this._vector.add(localOffset.multiplyScalar(object.matrixWorld.getMaxScaleOnAxis()));
      }
      this._vector.applyMatrix4(this._viewMatrix);
      const visibility = this._vector.z > -camera.near ? 'hidden' : 'visible';
      const zIndex = 10000 * (camera.far - -this._vector.z) / (camera.far - camera.near);
      const element = object.getElement();
      if (typeof scene.fog === 'undefined') {
        element.style.color = colorAsHex(object.userData.color);
        if (object.userData.background !== 'transparent') {
          element.style.background = colorAsHex(object.userData.background);
        }
      } else {
        const fogFactor = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
        element.style.color = lerpColorAsHex(object.userData.color, scene.fog.color, fogFactor);
        if (object.userData.background !== 'transparent') {
          element.style.background = lerpColorAsHex(object.userData.background, scene.fog.color, fogFactor);
        }
      }
      this._vector.applyMatrix4(this._projectionMatrix);
      const style = `${object.userData !== {} ? object.userData.translation : 'translate(-50%, -50%) '}translate(${this._vector.x * this._widthHalf + this._widthHalf}px,${-this._vector.y * this._heightHalf + this._heightHalf}px)`;
      element.style.visibility = visibility;
      element.style.WebkitTransform = style;
      element.style.MozTransform = style;
      element.style.oTransform = style;
      element.style.transform = style;
      element.style.zIndex = Number(zIndex).toFixed(0);
      if (element.parentNode !== this._domElement) {
        this._domElement.appendChild(element);
      }
    }
    for (let i = 0, l = object.children.length; i < l; i++) {
      this._renderObject(object.children[i], camera, scene);
    }
  }
  render(scene, camera) {
    scene.updateMatrixWorld();
    if (camera.parent === null) {
      camera.updateMatrixWorld();
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    this._viewMatrix.copy(camera.matrixWorldInverse);
    this._projectionMatrix.copy(camera.projectionMatrix);
    this._renderObject(scene, camera, scene);
  }
}
/* harmony default export */ const gfx_CSS2DRenderer = (CSS2DRenderer);
;// CONCATENATED MODULE: ./src/utils/getTopWindow.js
function getTopWindow() {
  // intercept the exception if we have cross-origin iframe
  try {
    if (window.top.location.href !== undefined) {
      return window.top;
    }
  } catch (e) {
    // provide fallback
  }
  return window;
}
;// CONCATENATED MODULE: ./src/ui/ObjectControls.js





const VK_LEFT = 37;
const VK_UP = 38;
const VK_RIGHT = 39;
const VK_DOWN = 40;
const STATE = {
  NONE: -1,
  ROTATE: 0,
  TRANSLATE: 1,
  SCALE: 2,
  TRANSLATE_PIVOT: 3
};

// pausing for this amount of time before releasing mouse button prevents inertial rotation (seconds)
const FULL_STOP_THRESHOLD = 0.1;
const quaternion = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion();
const matrix4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();

// pivot -- local offset of the rotation pivot point
function ObjectHandler(objects, camera, pivot, options) {
  this.objects = objects;
  [this.object] = objects;
  this.camera = camera;
  this.pivot = pivot;
  this.axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1);
  this.options = options;
  this.lastRotation = {
    axis: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
    angle: 0.0
  };
}
ObjectHandler.prototype._rotate = function () {
  const p = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const q = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion();
  const s = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const m = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  return function (quat) {
    const zeroPivot = this.pivot.x === 0.0 && this.pivot.y === 0.0 && this.pivot.z === 0.0;
    m.copy(this.object.matrix);
    if (zeroPivot) {
      m.multiply(matrix4.makeRotationFromQuaternion(quat));
    } else {
      m.multiply(matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
      m.multiply(matrix4.makeRotationFromQuaternion(quat));
      m.multiply(matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
    }
    m.decompose(p, q, s);

    // update objects
    if (!zeroPivot) {
      for (let i = 0; i < this.objects.length; ++i) {
        this.objects[i].position.copy(p);
      }
    }
    for (let j = 0; j < this.objects.length; ++j) {
      this.objects[j].quaternion.copy(q);
      this.objects[j].updateMatrix();
    }
  };
}();
ObjectHandler.prototype.setObjects = function (objects) {
  this.objects = objects;
  [this.object] = objects;
};
ObjectHandler.prototype.rotate = function () {
  const rot = {
    axis: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
    angle: 0.0
  };
  return function (quat, mousePrevPos, mouseCurPos, aboutAxis) {
    this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis);
    quat.setFromAxisAngle(rot.axis, rot.angle);
    if (rot.angle) {
      this._rotate(quat);
    }
    this.lastRotation = rot;
  };
}();
ObjectHandler.prototype.translate = function () {
  const dir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const pivot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (delta) {
    // reverse-project viewport movement to view coords (compensate for screen aspect ratio)
    dir.set(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
    let dist = dir.length();
    dir.normalize();

    // transform movement direction to object local coords
    dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert());

    // visible translate distance shouldn't depend on camera-to-object distance
    pivot.copy(this.pivot);
    this.object.localToWorld(pivot);
    dist *= Math.abs(pivot.z - this.camera.position.z);

    // visible translate distance shouldn't depend on object scale
    dist /= this.object.matrixWorld.getMaxScaleOnAxis();

    // all objects are translated similar to principal object
    // (we assume they all have identical pivot and scale)
    for (let i = 0; i < this.objects.length; ++i) {
      this.objects[i].translateOnAxis(dir, dist);
    }
  };
}();
ObjectHandler.prototype.update = function () {
  const axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (timeSinceLastUpdate, timeSinceMove) {
    if (settings.now.autoRotation !== 0.0) {
      // auto-rotation with constant speed

      // if rotation axis is fixed or hasn't been defined yet
      if (settings.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0.0) {
        // use Y-axis (transformed to local object coords)
        axis.set(0, 1, 0).transformDirection(matrix4.copy(this.object.matrixWorld).invert());
      } else {
        // use axis defined by last user rotation
        axis.copy(this.lastRotation.axis);
      }
      this._rotate(quaternion.setFromAxisAngle(axis, settings.now.autoRotation * timeSinceLastUpdate));
      return true;
    }
    if (this.options.intertia && this.lastRotation.angle) {
      // inertial object rotation
      const angle = this.lastRotation.angle * (1.0 - this.options.dynamicDampingFactor) ** (40.0 * timeSinceMove);
      if (Math.abs(angle) <= this.options.intertiaThreshold) {
        this.lastRotation.angle = 0.0;
      } else {
        this._rotate(quaternion.setFromAxisAngle(this.lastRotation.axis, angle));
        return true;
      }
    }
    return false;
  };
}();
ObjectHandler.prototype.stop = function () {
  this.lastRotation.angle = 0.0;
};

// calculate (axis, angle) pair from mouse/touch movement
ObjectHandler.prototype.mouse2rotation = function () {
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const eye = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const eyeDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const cameraUpDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const cameraSidewaysDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const moveDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const mouseDelta = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function (rot, mousePrev, mouseCur, aboutAxis) {
    if (aboutAxis) {
      rot.axis.copy(this.axis);
      rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);

      /* cool method that allows rotation around Z axis to be "tied" to mouse cursor
          res.axis.copy(this.axis);
          var pivot = this.pivot.clone();
        this.object.localToWorld(pivot);
        pivot.project(this.camera);
          var v1 = new THREE.Vector3(mousePrev.x, mousePrev.y, this.camera.position.z);
        v1.sub(pivot);
        var v2 = new THREE.Vector3(mouseCur.x, mouseCur.y, this.camera.position.z);
        v2.sub(pivot);
          v1.sub(res.axis.clone().multiplyScalar(v1.dot(res.axis)));
        v2.sub(res.axis.clone().multiplyScalar(v2.dot(res.axis)));
          var abs = v1.length() * v2.length();
        if (abs > 0) {
          res.angle = res.axis.dot(v1.cross(v2)) / abs;
        }
      */
    } else {
      mouseDelta.subVectors(mouseCur, mousePrev);
      const angle = mouseDelta.length();
      if (angle === 0.0) {
        return;
      }
      center.copy(this.pivot);
      this.object.localToWorld(center);
      eye.subVectors(this.camera.position, center);
      eyeDirection.copy(eye).normalize();
      cameraUpDirection.copy(this.camera.up).normalize();
      cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();
      cameraUpDirection.setLength(mouseDelta.y);
      cameraSidewaysDirection.setLength(mouseDelta.x);
      moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));
      rot.axis.crossVectors(moveDirection, eye);
      rot.angle = -angle * this.options.rotateFactor;
    }
    rot.axis.transformDirection(matrix4.copy(this.object.matrixWorld).invert());

    // make sure angle is always positive (thus 'axis' defines both axis and direction of rotation)
    if (rot.angle < 0.0) {
      rot.axis.negate();
      rot.angle = -rot.angle;
    }
  };
}();
function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
  utils_EventDispatcher.call(this);
  const self = this;
  this.object = object;
  this.objectPivot = objectPivot;
  this.camera = camera;
  this.domElement = typeof domElement !== 'undefined' ? domElement : document;
  this.getAltObj = getAltObj;

  // API

  this.enabled = true;
  this.hotkeysEnabled = true;
  this.screen = {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  };
  this.options = {
    rotateFactor: Math.PI,
    // full screen slide (along short side) would roughly mean 180 deg. rotation
    axisRotateFactor: 4 * Math.PI,
    // full screen slide (along short side) would roughly mean 720 deg. rotation
    intertia: true,
    dynamicDampingFactor: 0.1,
    intertiaThreshold: 1e-3
  };

  // internals

  this._state = STATE.NONE;
  this._mousePrevPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  this._mouseCurPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  this._mainObj = new ObjectHandler([this.object], this.camera, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0), this.options);
  this._altObj = new ObjectHandler([this.object], this.camera, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0), this.options);
  this._affectedObj = this._mainObj;
  this._isAltObjFreeRotationAllowed = true;
  this._isTranslationAllowed = true;
  this._isKeysTranslatingObj = false;
  this._pressedKeys = [];
  this._clock = new Timer();
  this._clock.start();
  this._lastUpdateTime = this._clock.getElapsedTime();

  // events
  this._listeners = [{
    obj: self.domElement,
    type: 'mousedown',
    handler(e) {
      self.mousedown(e);
    }
  }, {
    obj: self.domElement,
    type: 'mouseup',
    handler(e) {
      self.mouseup(e);
    }
  }, {
    obj: self.domElement,
    type: 'mousemove',
    handler(e) {
      self.mousemove(e);
    }
  }, {
    obj: self.domElement,
    type: 'mousewheel',
    handler(e) {
      self.mousewheel(e);
    }
  }, {
    obj: self.domElement,
    type: 'DOMMouseScroll',
    handler(e) {
      self.mousewheel(e);
    }
  }, {
    obj: self.domElement,
    type: 'mouseout',
    handler(e) {
      self.mouseup(e);
    }
  }, {
    obj: self.domElement,
    type: 'touchstart',
    handler(e) {
      self.touchstartend(e);
    }
  }, {
    obj: self.domElement,
    type: 'touchend',
    handler(e) {
      self.touchstartend(e);
    }
  }, {
    obj: self.domElement,
    type: 'touchmove',
    handler(e) {
      self.touchmove(e);
    }
  }, {
    obj: self.getKeyBindObject(),
    type: 'keydown',
    handler(e) {
      self.keydownup(e);
    }
  }, {
    obj: self.getKeyBindObject(),
    type: 'keyup',
    handler(e) {
      self.keydownup(e);
    }
  }, {
    obj: window,
    type: 'resize',
    handler() {
      self.handleResize();
    }
  }, {
    obj: window,
    type: 'blur',
    handler() {
      self.resetKeys();
    }
  }, {
    obj: self.domElement,
    type: 'contextmenu',
    handler(e) {
      self.contextmenu(e);
    }
  }];
  for (let i = 0; i < this._listeners.length; i++) {
    const l = this._listeners[i];
    l.obj.addEventListener(l.type, l.handler);
  }
  this.handleResize();
  this.resetKeys();

  // force an update at start
  this.update();
}

// methods

ObjectControls.prototype = Object.create(utils_EventDispatcher.prototype);
ObjectControls.prototype.constructor = ObjectControls;
ObjectControls.prototype.resetKeys = function () {
  this._pressedKeys[VK_LEFT] = false;
  this._pressedKeys[VK_UP] = false;
  this._pressedKeys[VK_RIGHT] = false;
  this._pressedKeys[VK_DOWN] = false;
};
ObjectControls.prototype.contextmenu = function (e) {
  e.stopPropagation();
  e.preventDefault();
};
ObjectControls.prototype.handleResize = function () {
  if (this.domElement === document) {
    this.screen.left = 0;
    this.screen.top = 0;
    this.screen.width = window.innerWidth;
    this.screen.height = window.innerHeight;
  } else {
    const box = this.domElement.getBoundingClientRect();
    // adjustments come from similar code in the jquery offset() function
    const d = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
};
ObjectControls.prototype.enable = function (enable) {
  this.enabled = enable;
};
ObjectControls.prototype.enableHotkeys = function (enable) {
  this.hotkeysEnabled = enable;
};
ObjectControls.prototype.allowTranslation = function (allow) {
  this._isTranslationAllowed = allow;
};
ObjectControls.prototype.allowAltObjFreeRotation = function (allow) {
  this._isAltObjFreeRotationAllowed = allow;
};
ObjectControls.prototype.keysTranslateObj = function (on) {
  this._isKeysTranslatingObj = on;
};
ObjectControls.prototype.isEditingAltObj = function () {
  return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
};

// convert page coords of mouse/touch to uniform coords with smaller side being [-0.5, 0.5]
// (uniform coords keep direct proportion with screen distance travelled by mouse regardless of screen aspect ratio)
ObjectControls.prototype.convertMouseToOnCircle = function (coords, pageX, pageY) {
  const screenSize = Math.min(this.screen.width, this.screen.height);
  if (screenSize === 0) {
    coords.set(0, 0);
    return;
  }
  coords.set((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
};

// convert page coords of mouse/touch to viewport coords with both sides being [-1, 1]
// (those are non-uniform coords affected by screen aspect ratio)
ObjectControls.prototype.convertMouseToViewport = function (coords, pageX, pageY) {
  if (this.screen.width === 0 || this.screen.height === 0) {
    coords.set(0, 0);
    return;
  }
  coords.set(2.0 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2.0 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
};
ObjectControls.prototype.stop = function () {
  this._mainObj.stop();
  this._altObj.stop();
};

// rotate object based on latest mouse/touch movement
ObjectControls.prototype.rotateByMouse = function () {
  const quat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion();
  return function (aboutZAxis) {
    this._affectedObj.rotate(quat, this._mousePrevPos, this._mouseCurPos, aboutZAxis);
    this.dispatchEvent({
      type: 'change',
      action: 'rotate',
      quaternion: quat
    });
  };
}();

// rotate object by specified quaternion
ObjectControls.prototype.rotate = function (quat) {
  this.object.quaternion.multiply(quat);
  this.dispatchEvent({
    type: 'change',
    action: 'rotate',
    quaternion: quat
  });
};

// get object's orientation
ObjectControls.prototype.getOrientation = function () {
  return this.object.quaternion;
};

// set object's orientation
ObjectControls.prototype.setOrientation = function (quat) {
  this.object.quaternion.copy(quat);
};

// translate object based on latest mouse/touch movement
ObjectControls.prototype.translate = function () {
  const delta = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function () {
    delta.subVectors(this._mouseCurPos, this._mousePrevPos);
    this._affectedObj.translate(delta);
    this.dispatchEvent({
      type: 'change',
      action: 'translate'
    });
  };
}();

// get object scale
ObjectControls.prototype.getScale = function () {
  return this.object.scale.x;
};

// set uniform object scale
ObjectControls.prototype.setScale = function (scale) {
  this.object.scale.set(scale, scale, scale);
};

// scale object by factor (factor should be greater than zero)
ObjectControls.prototype.scale = function (factor) {
  if (factor <= 0) {
    return;
  }
  this.setScale(this.object.scale.x * factor);
  this.dispatchEvent({
    type: 'change',
    action: 'zoom',
    factor
  });
};
ObjectControls.prototype.update = function () {
  const shift = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function () {
    const curTime = this._clock.getElapsedTime();
    const timeSinceLastUpdate = curTime - this._lastUpdateTime;

    // update object handler
    if (this._state === STATE.NONE) {
      const timeSinceMove = curTime - this._lastMouseMoveTime;
      if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
        this.dispatchEvent({
          type: 'change',
          action: 'auto'
        });
      }
    }

    // apply arrow keys
    if (this._isKeysTranslatingObj) {
      const speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
      const speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);
      if (speedX !== 0.0 || speedY !== 0.0) {
        const delta = timeSinceLastUpdate;

        // update object translation
        const altObj = this.getAltObj();
        if (altObj.objects.length > 0) {
          this._altObj.setObjects(altObj.objects);
          this._altObj.pivot = altObj.pivot;
          if ('axis' in altObj) {
            this._altObj.axis = altObj.axis.clone();
          } else {
            this._altObj.axis.set(0, 0, 1);
          }
          shift.set(delta * speedX, delta * speedY);
          this._altObj.translate(shift);
          this.dispatchEvent({
            type: 'change',
            action: 'translate'
          });
        }
      }
    }
    this._lastUpdateTime = curTime;
  };
}();
ObjectControls.prototype.reset = function () {
  this._state = STATE.NONE;
  this.object.quaternion.copy(quaternion.set(0, 0, 0, 1));
};

// listeners

ObjectControls.prototype.mousedown = function (event) {
  if (this.enabled === false || this._state !== STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  if (this._state === STATE.NONE) {
    if (event.button === 0) {
      this._affectedObj.stop(); // can edit only one object at a time

      let workWithAltObj = false;
      if (event.altKey) {
        const altObj = this.getAltObj();
        workWithAltObj = altObj.objects.length > 0;
        if (workWithAltObj) {
          this._altObj.setObjects(altObj.objects);
          this._altObj.pivot = altObj.pivot;
          if ('axis' in altObj) {
            this._altObj.axis = altObj.axis.clone();
          } else {
            this._altObj.axis.set(0, 0, 1);
          }
        }
      }
      this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
      this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
    } else if (event.button === 2) {
      this._state = STATE.TRANSLATE_PIVOT;
    }
  }
  if (this._state === STATE.ROTATE) {
    this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
    this._mousePrevPos.copy(this._mouseCurPos);
  }
  if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
    this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
    this._mousePrevPos.copy(this._mouseCurPos);
  }
};
ObjectControls.prototype.mousemove = function (event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
      this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.TRANSLATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
      this.translate();
      break;
    case STATE.TRANSLATE_PIVOT:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
      this.translatePivotByMouse();
      break;
    default:
      break;
  }
};
ObjectControls.prototype.mousewheel = function (event) {
  if (this.enabled === false || !settings.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
    return;
  }
  event.preventDefault();
  let delta = 0;
  if (event.wheelDelta) {
    // WebKit / Opera / Explorer 9
    delta = event.wheelDelta / 40;
  } else if (event.detail) {
    // Firefox
    delta = -event.detail / 3;
  }
  let factor = 1.0 + delta * 0.05;
  factor = Math.max(factor, 0.01);
  this.scale(factor);
};
ObjectControls.prototype.mouseup = function (event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  this._state = STATE.NONE;
  if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
    this._affectedObj.stop();
  }
};
ObjectControls.prototype.touchstartend = function (event) {
  if (this.enabled === false) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (event.touches.length) {
    case 1:
      this._state = STATE.ROTATE;
      this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
      this._mousePrevPos.copy(this._mouseCurPos);
      break;
    case 2:
      {
        // prevent inertial rotation
        this._mainObj.stop();
        this._altObj.stop();
        this._state = STATE.SCALE;
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
        this._scaleStart = this.object.scale.x;
        break;
      }
    default:
      this._state = STATE.NONE;
  }
};
ObjectControls.prototype.touchmove = function (event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
      this.rotateByMouse(false);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.SCALE:
      if (settings.now.zooming) {
        // update scale
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
        const newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
        const factor = newScale / this.object.scale.x;
        this.scale(factor);
      }
      break;
    default:
  }
};
ObjectControls.prototype.keydownup = function (event) {
  if (this.enabled === false || this.hotkeysEnabled === false) {
    return;
  }
  switch (event.keyCode) {
    case VK_LEFT:
    case VK_UP:
    case VK_RIGHT:
    case VK_DOWN:
      this._pressedKeys[event.keyCode] = event.type === 'keydown';
      event.preventDefault();
      event.stopPropagation();
      break;
    default:
  }
};
ObjectControls.prototype.getKeyBindObject = function () {
  return getTopWindow();
};
ObjectControls.prototype.dispose = function () {
  for (let i = 0; i < this._listeners.length; i++) {
    const l = this._listeners[i];
    l.obj.removeEventListener(l.type, l.handler);
  }
};
ObjectControls.prototype.translatePivotByMouse = function () {
  const delta = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function () {
    delta.subVectors(this._mouseCurPos, this._mousePrevPos);
    this.translatePivotInWorld(settings.now.translationSpeed * delta.x, settings.now.translationSpeed * delta.y, 0);
  };
}();

// Translate in WorldCS, translation is scaled with root scale matrix
ObjectControls.prototype.translatePivotInWorld = function (x, y, z) {
  const pos = this.objectPivot.position;
  pos.applyMatrix4(this.object.matrixWorld);
  pos.setX(pos.x + x);
  pos.setY(pos.y + y);
  pos.setZ(pos.z + z);
  pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert());
  this.dispatchEvent({
    type: 'change',
    action: 'translatePivot'
  });
};

// Translate in ModelCS, x, y, z are Ang
ObjectControls.prototype.translatePivot = function (x, y, z) {
  const pos = this.objectPivot.position;
  pos.setX(pos.x + x);
  pos.setY(pos.y + y);
  pos.setZ(pos.z + z);
  this.dispatchEvent({
    type: 'change',
    action: 'translatePivot'
  });
};

// Set pivot
ObjectControls.prototype.setPivot = function (newPivot) {
  this.objectPivot.position.copy(newPivot);
  this.dispatchEvent({
    type: 'change',
    action: 'translatePivot'
  });
};
/* harmony default export */ const ui_ObjectControls = (ObjectControls);
;// CONCATENATED MODULE: ./src/ui/Picker.js




function Picker(gfxObj, camera, domElement) {
  utils_EventDispatcher.call(this);
  const self = this;
  this.gfxObj = gfxObj;
  this.camera = camera;
  this.domElement = typeof domElement !== 'undefined' ? domElement : document;
  this.screen = {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  };
  this._lastMousePos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0, 0);
  this._mouseTotalDist = 0.0;
  this._lastClickBeginTime = -1000.0;
  this._lastClickPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0, 0);
  this._clickBeginTime = 0.0;
  this._clock = new Timer();
  this._clock.start();
  this._listeners = [{
    obj: self.domElement,
    type: 'mousedown',
    handler(e) {
      self.mousedown(e);
    }
  }, {
    obj: self.domElement,
    type: 'mouseup',
    handler(e) {
      self.mouseup(e);
    }
  }, {
    obj: self.domElement,
    type: 'mousemove',
    handler(e) {
      self.mousemove(e);
    }
  }, {
    obj: self.domElement,
    type: 'touchstart',
    handler(e) {
      self.touchstart(e);
    }
  }, {
    obj: self.domElement,
    type: 'touchend',
    handler(e) {
      self.touchend(e);
    }
  }, {
    obj: window,
    type: 'resize',
    handler() {
      self.handleResize();
    }
  }];
  for (let i = 0; i < this._listeners.length; i++) {
    const l = this._listeners[i];
    l.obj.addEventListener(l.type, l.handler);
  }
  this.handleResize();
}
Picker.prototype = Object.create(utils_EventDispatcher.prototype);
Picker.prototype.constructor = Picker;
Picker.prototype.reset = function () {
  this.picked = {};
  this.dispatchEvent({
    type: 'newpick',
    obj: {}
  });
};
Picker.prototype.handleResize = function () {
  if (this.domElement === document) {
    this.screen.left = 0;
    this.screen.top = 0;
    this.screen.width = window.innerWidth;
    this.screen.height = window.innerHeight;
  } else {
    const box = this.domElement.getBoundingClientRect();
    // adjustments come from similar code in the jquery offset() function
    const d = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
};
Picker.prototype.pickObject = function (screenPos) {
  if (!this.gfxObj) {
    this.picked = {};
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    });
    return;
  }
  const {
    gfxObj
  } = this;
  const rayCaster = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Raycaster();
  rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld);
  rayCaster.ray.direction.set(screenPos.x, screenPos.y, 0.5).unproject(this.camera).sub(rayCaster.ray.origin).normalize();
  const clipPlane = settings.now.draft.clipPlane && this.clipPlaneValue ? this.clipPlaneValue : Infinity;
  const fogFarPlane = settings.now.fog && this.fogFarValue ? this.fogFarValue : Infinity;
  const point = rayCaster.intersectVisibleObject(gfxObj, this.camera, clipPlane, fogFarPlane);
  if (!point) {
    this.picked = {};
    this.dispatchEvent({
      type: 'newpick',
      obj: {}
    });
    return;
  }
  let picked = {};
  if (point.residue || point.atom) {
    const residue = point.residue || point.atom.residue;
    if (settings.now.pick === 'chain') {
      picked = {
        chain: residue.getChain()
      };
    } else if (settings.now.pick === 'molecule') {
      picked = {
        molecule: residue.getMolecule()
      };
    } else if (point.residue || settings.now.pick === 'residue') {
      picked = {
        residue
      };
    } else if (point.atom) {
      picked = {
        atom: point.atom
      };
    }
  }
  this.picked = picked;
  this.dispatchEvent({
    type: 'newpick',
    obj: picked
  });
};
Picker.prototype.getMouseInViewport = function (pageX, pageY) {
  return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
};
Picker.prototype.mousedown = function (event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.button === 0) {
    this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist = 0.0;
    this._clickBeginTime = this._clock.getElapsedTime();
  }
};
Picker.prototype.mousemove = function (event) {
  event.preventDefault();
  event.stopPropagation();
  const pos = this.getMouseInViewport(event.pageX, event.pageY);
  this._mouseTotalDist += pos.sub(this._lastMousePos).length();
};
Picker.prototype.mouseup = function (event) {
  const self = this;
  event.preventDefault();
  event.stopPropagation();
  if (event.button === 0) {
    if (this._mouseTotalDist < 0.01) {
      const curTime = this._clock.getElapsedTime();
      const curPos = this.getMouseInViewport(event.pageX, event.pageY);
      const timeSinceLastClickBegin = curTime - this._lastClickBeginTime;
      if (timeSinceLastClickBegin < 0.7) {
        const clickDist = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2().subVectors(curPos, this._lastClickPos);
        if (clickDist.length() < 0.01) {
          // it's a double click
          this.dispatchEvent({
            type: 'dblclick',
            obj: this.picked
          });
          this._lastClickPos = curPos;
          this._lastClickBeginTime = -1000; // this click cannot serve as first click in double-click
          return;
        }
      }
      setTimeout(() => {
        self.pickObject(curPos);
      }, 0);
      this._lastClickPos = curPos;
      this._lastClickBeginTime = this._clickBeginTime;
    }
  }
};
Picker.prototype.touchstart = function (event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.touches.length === 1) {
    this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
  }
};
Picker.prototype.touchend = function (event) {
  const self = this;
  event.preventDefault();
  event.stopPropagation();
  if (event.touches.length === 0 && event.changedTouches.length === 1) {
    const pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
    const dist = pos.sub(this._lastTouchdownPos).length();
    if (dist < 0.01) {
      setTimeout(() => {
        self.pickObject(self._lastTouchdownPos);
      }, 0);
    }
  }
};
Picker.prototype.dispose = function () {
  for (let i = 0; i < this._listeners.length; i++) {
    const l = this._listeners[i];
    l.obj.removeEventListener(l.type, l.handler);
  }
};
/* harmony default export */ const ui_Picker = (Picker);
;// CONCATENATED MODULE: ./src/gfx/Axes.js

class Axes {
  constructor(target, targetCamera) {
    this._target = target;
    this._targetCamera = targetCamera;
    this._camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
    this._object = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.AxesHelper(1);
    this._scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
    this._scene.add(this._object);
    this._full = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
    this._update();
  }
  _update() {
    const {
      fov
    } = this._targetCamera;
    const camera = this._camera;
    camera.aspect = this._targetCamera.aspect;
    camera.setMinimalFov(fov);
    camera.setDistanceToFit(1.0, fov);
    camera.updateProjectionMatrix();
    this._object.quaternion.copy(this._target.quaternion);
  }
  render(renderer) {
    this._update();
    renderer.getSize(this._full);
    const width = this._full.width * 0.25;
    const height = this._full.height * 0.25;
    const {
      autoClear
    } = renderer;
    renderer.autoClear = false;
    renderer.setViewport(0.0, 0.0, width, height);
    renderer.clear(false, true, false);
    renderer.render(this._scene, this._camera);
    renderer.setViewport(0, 0, this._full.width, this._full.height);
    renderer.autoClear = autoClear;
  }
}
/* harmony default export */ const gfx_Axes = (Axes);
;// CONCATENATED MODULE: ./src/gfx/FrameInfo.js


const cDataOffset = 12;
const cFirstMask = 0x0FFFFF00;
const cFirstShift = 8;
const cSecMask1 = 0x000000FF;
const cSecShift1 = 12;
const cSecMask2 = 0xFFF00000;
const cSecShift2 = 20;
const cThirdMask = 0x000FFFFF;
const cStrMask = 0xF0000000;
const cStrShift = 28;
const c219 = 1 << 19;
const c220 = 1 << 20;
const cHelixIdx = 1;
const cSheetIdx = 2;
const secTypes = ['helix', 'strand'];
const cSecNames = ['fs', 'ps', 'ns', 'us'];
function _createSecondary(strArray, complex) {
  const residues = complex._residues;
  const nRes = residues.length;
  const resid = new Uint8Array(nRes);
  const atoms = complex._atoms;
  for (let i = 0, n = strArray.length; i < n; ++i) {
    const atom = atoms[i];
    resid[atom.residue._index] = strArray[i];
  }
  const secondary = [];
  let rIdx = 0;
  while (rIdx < nRes) {
    if (resid[rIdx] !== 0) {
      const start = rIdx;
      const val = resid[rIdx];
      while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
        ++rIdx;
      }
      secondary.push({
        start,
        end: rIdx,
        type: secTypes[val - 1]
      });
    }
    ++rIdx;
  }
  return secondary;
}
function fromUInt20ToInt20(uint20) {
  return uint20 >= c219 ? uint20 - c220 : uint20;
}
class FrameInfo {
  constructor(complex, payload, callbacks) {
    this._complex = complex;
    this._secondary = null;
    this.isLoading = false;
    this._framesRange = {
      start: 0,
      end: -1
    };
    this.frameIsReady = false;
    this._buffer = null;
    this._frameRequest = null;
    this._callbacks = callbacks;
    if (typeof payload === 'function') {
      this._framesRequestLength = 1;
      this._downloadDataFn = payload;
    } else {
      this.parseBinaryData(payload, true);
    }
    this.reset();
    this.setFrame(0);
  }
  _prepareBuffer(framesStart, framesEnd) {
    if (framesStart === undefined || framesStart === null) {
      framesStart = 0;
    }
    if (framesEnd === undefined || framesEnd === null) {
      framesEnd = framesStart + this._framesRequestLength;
    }
    if (this._framesCount !== undefined) {
      framesEnd = Math.min(this._framesCount - 1, framesEnd);
    }
    if (this._downloadDataFn) {
      const self = this;
      const onDone = function (data) {
        self.isLoading = false;
        if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
          self._callbacks.onLoadStatusChanged();
        }
        self._buffer = {
          data,
          state: 'ready',
          start: framesStart,
          end: framesEnd
        };
        if (self._frameRequest !== null) {
          const idx = self._frameRequest;
          self._frameRequest = null;
          self.setFrame(idx);
        }
      };
      const onFail = function () {
        self.isLoading = false;
        if (self._callbacks && typeof self._callbacks.onError === 'function') {
          self._callbacks.onError('Streaming failed');
        }
      };
      if (!this._buffer) {
        this._buffer = {};
      }
      this._buffer.state = 'downloading';
      this.isLoading = true;
      if (self._callbacks && typeof self._callbacks.onLoadStatusChanged === 'function') {
        self._callbacks.onLoadStatusChanged();
      }
      this._downloadDataFn({
        start: framesStart,
        end: framesEnd + 1
      }, onDone, onFail);
    }
  }
  _parseBuffer() {
    if (this._buffer && this._buffer.state === 'ready') {
      this._framesRange = {
        start: this._buffer.start,
        end: this._buffer.end
      };
      this.parseBinaryData(this._buffer.data, false);
      let _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;
      if (_bufferRequestStart >= this._framesCount) {
        _bufferRequestStart = 0;
      }
      this._buffer = {
        state: 'none'
      };
      this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);
      if (this._frameRequest !== null) {
        const idx = this._frameRequest;
        this._frameRequest = null;
        this.setFrame(idx);
      }
    }
  }
  parseBinaryData(arrayBuffer) {
    const dataView = new DataView(arrayBuffer);
    let offset = 0;
    const atomsCount = dataView.getUint32(offset, true);
    offset += 4;
    const framesCount = dataView.getUint32(offset, true);
    this._framesCount = framesCount;
    this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
    offset += 4;
    this._atomsCount = atomsCount;
    const maxSize = 1024 * 1024; // 1 MB
    this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
    const chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;
    if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
      throw new Error();
    }
    const complex = this._complex;
    let timeStep = dataView.getUint32(offset, true);
    let iName = 0;
    while (timeStep > 1000 && iName < cSecNames.length - 1) {
      timeStep /= 1000;
      ++iName;
    }
    this._timeStep = `${timeStep.toString()} ${cSecNames[iName]}`;
    offset += 4;
    const secondary = [];
    const posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
    let coordIdx = 0;
    const secondaryArr = new Int8Array(atomsCount);
    for (let j = 0; j < chunkedFramesCount; ++j) {
      for (let i = 0; i < atomsCount; ++i) {
        const hiWord = dataView.getUint32(offset, true);
        offset += 4;
        const loWord = dataView.getUint32(offset, true);
        offset += 4;
        const str = (loWord & cStrMask) >>> cStrShift;
        const x = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
        const y = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
        const z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
        secondaryArr[i] = 0;
        if (str > 0 && str < 4) {
          secondaryArr[i] = cHelixIdx;
        } else if (str === 4) {
          secondaryArr[i] = cSheetIdx;
        }
        posData[coordIdx++] = x / 100;
        posData[coordIdx++] = y / 100;
        posData[coordIdx++] = z / 100;
      }
      secondary.push(_createSecondary(secondaryArr, complex));
    }
    this._secondaryData = secondary;
    this._data = posData;
  }
  nextFrame() {
    this.setFrame((this._currFrame + 1) % this._framesCount);
  }
  needsColorUpdate(colorer) {
    return colorer instanceof colorers_SecondaryStructureColorer;
  }
  getAtomColor(colorer, atom) {
    return colorer.getResidueColor(this._residues[atom.residue._index], this._complex);
  }
  getResidueColor(colorer, residue) {
    return colorer.getResidueColor(this._residues[residue._index], this._complex);
  }
  _updateSecondary() {
    let i;
    const myResidues = this._residues;
    let n = myResidues.length;
    for (i = 0; i < n; ++i) {
      myResidues[i]._secondary = null;
    }
    const sec = this._secondaryData[this._currFrame - this._framesRange.start];
    for (i = 0, n = sec.length; i < n; ++i) {
      const oldSec = sec[i];
      const {
        start,
        end
      } = oldSec;
      const nSec = {
        _start: myResidues[start],
        _end: myResidues[end],
        type: oldSec.type,
        generic: oldSec.generic
      };
      for (let j = start; j <= end; ++j) {
        myResidues[j]._secondary = nSec;
      }
    }
  }
  reset() {
    const compRes = this._complex._residues;
    const n = compRes.length;
    this._residues = new Array(n);
    const myResidues = this._residues;
    const getSec = function () {
      return this._secondary;
    };
    for (let i = 0; i < n; ++i) {
      myResidues[i] = {
        _type: compRes[i]._type,
        _isValid: compRes[i]._isValid,
        _controlPoint: null,
        _wingVector: null,
        _secondary: null,
        getSecondary: getSec
      };
    }
  }
  setFrame(frameIdx) {
    this.frameIsReady = false;
    if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
      this._currFrame = frameIdx;
      this._cachedResidues = false;
      this._updateSecondary();
      this.frameIsReady = true;
    } else {
      this._frameRequest = frameIdx;
      if (!this._buffer) {
        this._prepareBuffer(frameIdx);
      } else {
        const self = this;
        switch (this._buffer.state) {
          case 'none':
            this._prepareBuffer(frameIdx);
            break;
          case 'ready':
            self._parseBuffer();
            break;
          default:
            break;
        }
      }
    }
  }
  disableEvents() {
    this._callbacks = null;
  }

  /**
   * Returns link to atom pos vector, clone it if needed
   */

  static _vec = (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())();
  getAtomPos(atomIdx) {
    const vec = FrameInfo._vec;
    const self = this;
    const data = self._data;
    const idx = (self._atomsCount * (self._currFrame - self._framesRange.start) + atomIdx) * 3;
    vec.set(data[idx], data[idx + 1], data[idx + 2]);
    return vec;
  }
  getResidues() {
    if (this._cachedResidues) {
      return this._residues;
    }
    this._complex.updateToFrame(this);
    return this._residues;
  }
}
/* harmony default export */ const gfx_FrameInfo = (FrameInfo);
;// CONCATENATED MODULE: ./src/gfx/objects/SceneObject.js





/**
 * Create new scene object.
 *
 * @param {array=} params - Object required params.
 * @param {object=} opts - Options to override defaults with.
 *
 *   These options are copied locally and not kept by reference, so the created instance will not reflect further
 *   changes to the `opts` object. However, changes in defaults **will** affect the colorer after its creation.
 *
 * @exports SceneObject
 * @this SceneObject
 * @abstract
 * @constructor
 * @classdesc Basic class for all scene objects that are not reps.
 */
class SceneObject {
  constructor(params, opts) {
    if (this.constructor === SceneObject) {
      throw new Error('Can not instantiate abstract class!');
    }
    /**
     * Object's options inherited (prototyped) from defaults.
     * @type {object}
     */
    this.params = params;
    this.opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(utils.deriveDeep(settings.now.objects[this.type], true), opts);
    this.needsRebuild = false;
    this._mesh = null;
    this.id = null;
  }

  /**
   * Get object identification, probably with options.
   *  @returns {Object} field type contains type information, params - object's formal parameters,
   * opts - changed options
   * Options are returned if they were changed during or after object creation.
   */
  identify() {
    const result = {
      type: this.type,
      params: this.params
    };
    const diff = utils.objectsDiff(this.opts, settings.now.modes[this.id]);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      result.opts = diff;
    }
    return result;
  }
  toString() {
    const paramsStr = `o=${this.type},${this.params.join(',')}`;
    const optsStr = utils.compareOptionsWithDefaults(this.opts, settings.defaults.objects[this.type]);
    return paramsStr + optsStr;
  }
  getGeometry() {
    return this._mesh;
  }
  destroy() {
    if (this._mesh) {
      gfxutils.destroyObject(this._mesh);
    }
  }
}

/**
 * Scene object identifier.
 * @type {string}
 */
SceneObject.prototype.type = '__';
/* harmony default export */ const objects_SceneObject = (SceneObject);
;// CONCATENATED MODULE: ./src/gfx/objects/LinesObj.js






class LinesObj extends objects_SceneObject {
  constructor(params, opts) {
    super(params, opts);
    if (params.length < 2) {
      throw new Error('Wrong number of argumets on line object creation!');
    }
    [this._id1, this._id2] = params;
  }
  _getAtomFromName(complex, atomId) {
    const err = ' - Wrong atom format it must be \'#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME\' (e.g. \'A.38.CO1\')';
    const atom1 = complex.getAtomByFullname(atomId);
    if (!atom1) {
      throw new Error(atomId + err);
    }
    return atom1;
  }
  build(complex) {
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    this._atom1 = this._getAtomFromName(complex, this._id1);
    this._atom2 = this._getAtomFromName(complex, this._id2);
    const p1 = this._atom1.position;
    const p2 = this._atom2.position;
    const vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z]);
    geom.setAttribute('position', new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(vertices, 3));
    geom.computeBoundingBox();
    this._line = new meshes.Line(geom, new shaders_UberMaterial({
      lights: false,
      overrideColor: true,
      dashedLine: true,
      fogTransparent: settings.now.bg.transparent
    }));
    this._line.computeLineDistances();
    this._line.material.setUberOptions({
      fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(this.opts.color),
      dashedLineSize: this.opts.dashSize,
      dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
    });
    this._line.material.updateUniforms();
    this._line.raycast = function (_raycaster, _intersects) {};
    this._mesh = this._line;
    const transforms = complex.getTransforms();
    if (transforms.length > 0) {
      this._mesh = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
      this._mesh.add(this._line);
      meshutils.applyTransformsToMeshes(this._mesh, transforms);
    }
  }
  updateToFrame(frameData) {
    if (!this._atom1 || !this._atom2 || !this._line) {
      return;
    }
    const geo = this._line.geometry;
    geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index));
    geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index));
    this._line.computeLineDistances();
    geo.computeBoundingSphere();
    geo.verticesNeedUpdate = true;
  }
}
LinesObj.prototype.constructor = LinesObj;
LinesObj.prototype.type = 'line';
/* harmony default export */ const objects_LinesObj = (LinesObj);
;// CONCATENATED MODULE: ./src/gfx/shaders/Outline.frag
const Outline_namespaceObject = "precision highp float;\r\n\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nuniform vec2 thickness;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = thickness / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/OutlineMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */



class OutlineMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    // add depth outline
    super(params);
    const settings = {
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        srcDepthTex: {
          type: 't',
          value: null
        },
        srcTexSize: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(512, 512)
        },
        color: {
          type: 'v3',
          value: null
        },
        threshold: {
          type: 'f',
          value: null
        },
        opacity: {
          type: 'f',
          value: 1.0
        },
        thickness: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1, 1)
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: Outline_namespaceObject,
      transparent: true,
      depthTest: false,
      depthWrite: false
    };
    this.setValues(settings);
  }
  copy(source) {
    super.copy(source);
    this.depth = source.depth;
  }
  setValues(values) {
    if (typeof values === 'undefined') {
      return;
    }

    // set direct values
    super.setValues(values);
    const defines = {};
    if (this.depth) {
      defines.DEPTH_OUTLINE = 1;
    }

    // set dependent values
    this.defines = defines;
  }
}
OutlineMaterial.prototype.depth = false;
/* harmony default export */ const shaders_OutlineMaterial = (OutlineMaterial);
;// CONCATENATED MODULE: ./src/gfx/shaders/FXAA.frag
const FXAA_namespaceObject = "precision highp float;\r\n\r\n// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r\n  // visibly, thus we decided to leave calculation here for better readability.\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/FXAAMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */



class FXAAMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);

    // set default values
    this.setValues.call(this, {
      uniforms: {
        srcTex: {
          type: 't',
          value: null
        },
        srcTexelSize: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / 512.0, 1.0 / 512.0)
        },
        bgColor: {
          type: 'c',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0xffffff)
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: FXAA_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.depth = source.depth;
  }
  setValues(values) {
    if (typeof values === 'undefined') {
      return;
    }

    // set direct values
    super.setValues(values);
    const defines = {};
    if (this.bgTransparent) {
      defines.BG_TRANSPARENT = 1;
    }
    // set dependent values
    this.defines = defines;
  }
}
FXAAMaterial.prototype.bgTransparent = false;
/* harmony default export */ const shaders_FXAAMaterial = (FXAAMaterial);
;// CONCATENATED MODULE: ./src/gfx/shaders/AO.frag
const AO_namespaceObject = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 32\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  vec4 normalData = texture2D(normalTexture, vUv);\r\n  // return for background fragments (their normals are zero vectors)\r\n  if (length(normalData.rgb) < EPSILON) {\r\n    // 0.0 in alpha component means that it is background fragment\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r\n  // normalData.a store 1.0 if normal was build for frontfaced surface\r\n  // and 0.0 in other case\r\n  if (normalData.a < EPSILON) {\r\n    normal *= -1.0;\r\n  }\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/AOMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */




const AOMaterial_samplesKernel = [
// hemisphere samples adopted to sphere
new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.295184, 0.077723, 0.068429), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.271976, -0.365221, 0.838363), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.547713, 0.467576, 0.488515), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.662808, -0.031733, 0.584758), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.025717, 0.218955, 0.657094), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.310153, -0.365223, 0.370701), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.101407, -0.006313, 0.747665), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.769138, 0.360399, 0.086847), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.271988, -0.275140, 0.905353), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.096740, -0.566901, 0.700151), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.562872, -0.735136, 0.094647), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.379877, 0.359278, 0.190061), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.519064, -0.023055, 0.405068), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.301036, 0.114696, 0.088885), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.282922, 0.598305, 0.487214), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.181859, 0.251670, 0.679702), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.191463, -0.635818, 0.512919), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.293655, 0.427423, 0.078921), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.267983, 0.680534, 0.132880), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.139611, 0.319637, 0.477439), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.352086, 0.311040, 0.653913), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.321032, 0.805279, 0.487345), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.073516, 0.820734, 0.414183), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.155324, 0.589983, 0.411460), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.335976, 0.170782, 0.527627), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.463460, -0.355658, 0.167689), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.222654, 0.596550, 0.769406), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.922138, -0.042070, 0.147555), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.727050, -0.329192, 0.369826), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.090731, 0.533820, 0.463767), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.323457, -0.876559, 0.238524), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.663277, -0.372384, 0.342856)];
class AOMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor() {
    super();

    // set default values
    this.setValues.call(this, {
      uniforms: {
        noiseTexture: {
          type: 't',
          value: gfx_noiseTexture.noiseTexture
        },
        noiseTexelSize: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / gfx_noiseTexture.noiseWidth, 1.0 / gfx_noiseTexture.noiseHeight)
        },
        diffuseTexture: {
          type: 't',
          value: null
        },
        normalTexture: {
          type: 't',
          value: null
        },
        depthTexture: {
          type: 't',
          value: null
        },
        srcTexelSize: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / 512.0, 1.0 / 512.0)
        },
        camNearFar: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0, 10.0)
        },
        projMatrix: {
          type: 'mat4',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
        },
        aspectRatio: {
          type: 'f',
          value: 0.0
        },
        tanHalfFOV: {
          type: 'f',
          value: 0.0
        },
        samplesKernel: {
          type: 'v3v',
          value: AOMaterial_samplesKernel
        },
        kernelRadius: {
          type: 'f',
          value: 1.0
        },
        depthThreshold: {
          type: 'f',
          value: 1.0
        },
        factor: {
          type: 'f',
          value: 1.0
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: AO_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
  }
}
/* harmony default export */ const shaders_AOMaterial = (AOMaterial);
;// CONCATENATED MODULE: ./src/gfx/shaders/AOHorBlur.frag
const AOHorBlur_namespaceObject = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = res;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb = res.rgb / weightSum;\r\n  gl_FragColor = res;\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/AOHorBlurMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */



const _kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0];
class AOHorBlurMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor() {
    super();

    // set default values
    this.setValues.call(this, {
      uniforms: {
        depthTexture: {
          type: 't',
          value: null
        },
        srcTexelSize: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / 512.0, 1.0 / 512.0)
        },
        aoMap: {
          type: 't',
          value: null
        },
        samplesOffsets: {
          type: 'fv1',
          value: _kernelOffsets
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: AOHorBlur_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
  }
}
/* harmony default export */ const shaders_AOHorBlurMaterial = (AOHorBlurMaterial);
;// CONCATENATED MODULE: ./src/gfx/shaders/AOVertBlurWithBlend.frag
const AOVertBlurWithBlend_namespaceObject = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nuniform mat4  projMatrix;\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\n#ifdef USE_FOG\r\n  uniform vec2 fogNearFar;\r\n  uniform vec4 fogColor;\r\n#endif\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n  projPos.y * tanHalfFOV * abs(viewPos.z)\r\n  );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = color;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb /= weightSum;\r\n\r\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r\n    // Add fog to the result value\r\n    // Proper way to get an image with fog and ao requires formula:\r\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r\n    // We have:  AO, fogFactor, fogColor,\r\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r\n    //                                                                where molecule has been already drawn with fog)\r\n    // Transform:\r\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\r\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r\n  #else\r\n    gl_FragColor.rgb = color.rgb * res.rgb;\r\n  #endif\r\n  gl_FragColor.a = color.a;\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/AOVertBlurWithBlendMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */



const AOVertBlurWithBlendMaterial_kernelOffsets = [-2.0, -1.0, 0.0, 1.0, 2.0];
class AOVertBlurWithBlendMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);

    // set default values
    this.setValues.call(this, {
      uniforms: {
        diffuseTexture: {
          type: 't',
          value: null
        },
        depthTexture: {
          type: 't',
          value: null
        },
        srcTexelSize: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1.0 / 512.0, 1.0 / 512.0)
        },
        aoMap: {
          type: 't',
          value: null
        },
        samplesOffsets: {
          type: 'fv1',
          value: AOVertBlurWithBlendMaterial_kernelOffsets
        },
        projMatrix: {
          type: 'mat4',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
        },
        aspectRatio: {
          type: 'f',
          value: 0.0
        },
        tanHalfFOV: {
          type: 'f',
          value: 0.0
        },
        fogNearFar: {
          type: 'v2',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(100.0, 100.0)
        },
        fogColor: {
          type: 'v4',
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0.0, 0.5, 0.0, 1.0)
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: AOVertBlurWithBlend_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    this.setValues(params);
  }
  setValues(values) {
    if (typeof values === 'undefined') {
      return;
    }

    // set direct values
    super.setValues(values);
    const defines = {};
    if (this.useFog) {
      defines.USE_FOG = 1;
    }
    if (this.fogTransparent) {
      defines.FOG_TRANSPARENT = 1;
    }
    // set dependent values
    this.defines = defines;
  }
}
AOVertBlurWithBlendMaterial.prototype.useFog = true;
AOVertBlurWithBlendMaterial.prototype.fogTransparent = false;
/* harmony default export */ const shaders_AOVertBlurWithBlendMaterial = (AOVertBlurWithBlendMaterial);
;// CONCATENATED MODULE: ./src/gfx/shaders/Anaglyph.frag
const Anaglyph_namespaceObject = "precision highp float;\r\n\r\nuniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n";
;// CONCATENATED MODULE: ./src/gfx/shaders/AnaglyphMaterial.js
/* eslint-disable no-magic-numbers */
/* eslint-disable guard-for-in */



class AnaglyphMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor() {
    super();
    const settings = {
      uniforms: {
        srcL: {
          type: 't',
          value: null
        },
        srcR: {
          type: 't',
          value: null
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: Anaglyph_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    };
    this.setValues(settings);
  }
}
/* harmony default export */ const shaders_AnaglyphMaterial = (AnaglyphMaterial);
;// CONCATENATED MODULE: ./src/gfx/ViewInterpolator.js


class View {
  constructor() {
    this.position = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    this.scale = 1;
    this.orientation = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion(0, 0, 0, 1);
  }
  set(position, scale, orientation) {
    this.position = position;
    this.scale = scale;
    this.orientation = orientation;
  }
}
const _transitionTime = 1.5; // in seconds

class ViewInterpolator {
  setup(startView, endView) {
    this._startTime = undefined;
    this._endTime = undefined;
    this._isPaused = false;
    this._srcView = startView;
    this._dstView = endView;
    this._isMoving = false;
  }
  isMoving() {
    return this._isMoving;
  }
  wasStarted() {
    return typeof this._startTime !== 'undefined' && typeof this._endTime !== 'undefined';
  }
  start() {
    this._startTime = Date.now();
    const transTime = settings.now.interpolateViews ? _transitionTime * 1000 : 0;
    this._endTime = this._startTime + transTime;
    this._isMoving = true;
  }
  getCurrentView() {
    if (typeof this._srcView === 'undefined' || typeof this._dstView === 'undefined' || !this._isMoving || !this.wasStarted()) {
      return {
        success: false
      };
    }
    let view = this.createView();
    const time = Date.now();
    if (time > this._endTime) {
      view = this._dstView;
      this.reset();
      return {
        success: true,
        view
      };
    }
    const factor = (time - this._startTime) / (this._endTime - this._startTime);
    view.position.copy(this._srcView.position);
    view.position.lerp(this._dstView.position, factor);
    view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
    view.orientation.copy(this._srcView.orientation);
    view.orientation.slerp(this._dstView.orientation, factor);
    return {
      success: true,
      view
    };
  }
  reset() {
    this._startTime = this._endTime = 0;
    this._isMoving = false;
  }
  pause() {
    if (!this._isPaused) {
      this.setup(this.getCurrentView().view, this._dstView);
      this._isPaused = true;
    }
  }
  resume() {
    this._isPaused = false;
  }
  createView() {
    return new View();
  }
}
;// CONCATENATED MODULE: ./src/utils/Cookies.js


const MAX_COOKIE_LEN = 4000;
const COUNT_SUFFIX = 'Cnt';
function _chunkString(string, chunkLen) {
  const l = string.length;
  const chunks = [];
  for (let c = 0, lc = 0; lc < l; c++, lc += chunkLen) {
    chunks[c] = string.slice(lc, lc + chunkLen);
  }
  return chunks;
}

/**
 * Create new context dependent Cookie holder object.
 * @param context
 * @param {Object} opts - options
 * @param {string} opts.path - cookie path
 * @constructor
 */
function Cookies(context, opts) {
  this.context = context;
  this._opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({
    path: '/'
  }, opts);
}
utils_makeContextDependent(Cookies.prototype);

/**
 * Remove cookie by the name.
 * @param key
 */
Cookies.prototype.removeCookie = function (key) {
  const cntKey = this._toCount(key);
  let cntVal = this._getSimpleCookie(cntKey);
  if (!cntVal) {
    this._removeSimpleCookie(key);
    return;
  }
  this._removeSimpleCookie(cntKey);
  cntVal = parseInt(cntVal, 10);
  for (let i = 0; i < cntVal; ++i) {
    this._removeSimpleCookie(key + i);
  }
};

/**
 * Set new cookie value. Automatically splits
 * values that are too large into multiple cookies.
 * @param key
 * @param value
 */
Cookies.prototype.setCookie = function (key, value) {
  this.removeCookie(key);
  value = encodeURIComponent(value);
  const values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1);
  const cntVal = values.length;
  if (cntVal === 1) {
    this._setSimpleCookie(key, value);
    return;
  }
  const cntKey = this._toCount(key);
  this._setSimpleCookie(cntKey, cntVal.toString());
  for (let i = 0; i < cntVal; ++i) {
    this._setSimpleCookie(key + i, values[i]);
  }
};

/**
 * Obtain the value of a compound cookie.
 * @param key
 */
Cookies.prototype.getCookie = function (key) {
  const cntKey = this._toCount(key);
  let cntVal = this._getSimpleCookie(cntKey);
  if (!cntVal) {
    return this._getSimpleCookie(key);
  }
  cntVal = parseInt(cntVal, 10);
  const value = [];
  for (let i = 0; i < cntVal; ++i) {
    value[i] = this._getSimpleCookie(key + i);
  }
  return value.join('');
};
Cookies.prototype._toCount = function (key) {
  return key + COUNT_SUFFIX;
};
Cookies.prototype._removeSimpleCookie = function (key) {
  document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`;
};
Cookies.prototype._getExpirationDate = function () {
  const today = new Date();
  const EXP_PERIOD_YEARS = 10;
  today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
  return today;
};
Cookies.prototype._setSimpleCookie = function (key, value) {
  document.cookie = `${key}=${value};expires=${this._getExpirationDate().toUTCString()};path=${this._opts.path}`;
};
Cookies.prototype._getSimpleCookie = function (key) {
  const matches = document.cookie.match(new RegExp(`(?:^|; )${key}=([^;]*)`));
  return matches ? decodeURIComponent(matches[1]) : '';
};
Cookies.prototype._exists = function (key) {
  return document.cookie.match(new RegExp(`(?:^|; )${key}=([^;]*)`));
};
/* harmony default export */ const utils_Cookies = (Cookies);
;// CONCATENATED MODULE: ./src/gfx/vr/createWebVRButton.js
/*
 * Toggling WebVR is done through button.click because of limitations on calling requestPresent in webVR:
 * VRDisplay::requestPresent should be called from user gesture:
 * https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/requestPresent
 */
/* harmony default export */ function createWebVRButton(webVRPoC) {
  function showEnterVR(button) {
    button.style.display = '';
    button.style.cursor = 'pointer';
    button.style.left = 'calc(50% - 50px)';
    button.style.width = '100px';
    button.textContent = 'ENTER VR';
    let currentSession = null;
    function onSessionEnded( /* event */
    ) {
      currentSession.removeEventListener('end', onSessionEnded);
      button.textContent = 'ENTER VR';
      currentSession = null;
    }
    function onSessionStarted(session) {
      session.addEventListener('end', onSessionEnded);
      webVRPoC._gfx.renderer.xr.setReferenceSpaceType('local');
      webVRPoC._gfx.renderer.xr.setSession(session);
      button.textContent = 'EXIT VR';
      currentSession = session;
    }
    button.onmouseenter = function () {
      button.style.opacity = '1.0';
    };
    button.onmouseleave = function () {
      button.style.opacity = '0.5';
    };
    button.onclick = function () {
      if (currentSession === null) {
        // WebXR's requestReferenceSpace only works if the corresponding feature
        // was requested at session creation time. For simplicity, just ask for
        // the interesting ones as optional features, but be aware that the
        // requestReferenceSpace call will fail if it turns out to be unavailable.
        // ('local' is always available for immersive sessions and doesn't need to
        // be requested separately.)

        const sessionInit = {
          optionalFeatures: ['local-floor', 'bounded-floor']
        };
        navigator.xr.requestSession('immersive-vr', sessionInit).then(onSessionStarted);
        webVRPoC.moveSceneBehindHeadset();
      } else {
        currentSession.end();
      }
    };
  }
  function showWebXRNotFound(button) {
    button.style.display = '';
    button.style.cursor = 'auto';
    button.style.left = 'calc(50% - 75px)';
    button.style.width = '150px';
    button.textContent = 'VR NOT FOUND';
    button.onmouseenter = null;
    button.onmouseleave = null;
    button.onclick = null;
  }
  function stylizeElement(element) {
    element.style.position = 'absolute';
    element.style.bottom = '20px';
    element.style.padding = '12px 6px';
    element.style.border = '1px solid #fff';
    element.style.borderRadius = '4px';
    element.style.background = 'transparent';
    element.style.color = '#fff';
    element.style.font = 'normal 13px sans-serif';
    element.style.textAlign = 'center';
    element.style.opacity = '0.5';
    element.style.outline = 'none';
    element.style.zIndex = '999';
  }
  if ('xr' in navigator) {
    const button = document.createElement('button');
    button.style.display = 'none';
    stylizeElement(button);
    navigator.xr.isSessionSupported('immersive-vr').then(supported => supported ? showEnterVR(button) : showWebXRNotFound(button));
    return button;
  }
  const message = document.createElement('a');
  message.href = 'https://webvr.info';
  message.innerHTML = 'WEBXR NOT SUPPORTED';
  message.style.left = 'calc(50% - 90px)';
  message.style.width = '180px';
  message.style.textDecoration = 'none';
  stylizeElement(message);
  return message;
}
;// CONCATENATED MODULE: ./src/gfx/vr/WebVRPoC.js






class WebVRPoC {
  constructor(onToggle) {
    this._mainCamera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera();
    this._button = null;
    this._onToggle = onToggle;
    this._molContainer = new gfxutils.RCGroup();
    this._user = new gfxutils.RCGroup();
    this._scalingPivot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D();
    this._user.add(this._scalingPivot);
    this._controller1 = null;
    this._controller2 = null;
    this._pressedGripsCounter = 0;
    this._distance = 0;
    this._gfx = null;
  }
  startScalingByControllers() {
    // reset scale
    this._distance = this._controller1.position.distanceTo(this._controller2.position);
    gfxutils.getMiddlePoint(this._controller1.position, this._controller2.position, this._scalingPivot.position);
    this._scalingPivot.scale.set(1, 1, 1);
    this._scalingPivot.updateMatrix();
    this._scalingPivot.updateMatrixWorld();
    // link molecule to pivot
    this._scalingPivot.addSavingWorldTransform(this._molContainer);
  }
  stopScalingByControllers() {
    this._gfx.scene.addSavingWorldTransform(this._molContainer);
  }
  handleGripsDown(event) {
    this._pressedGripsCounter++;
    if (this._pressedGripsCounter === 2) {
      this.startScalingByControllers();
    } else if (this._pressedGripsCounter === 1) {
      event.target.addSavingWorldTransform(this._molContainer);
    }
  }
  handleGripsUp(event) {
    this._pressedGripsCounter--;
    if (this._pressedGripsCounter === 1) {
      this.stopScalingByControllers();
      // reattach molecule to other controller
      const anotherController = event.target === this._controller1 ? this._controller2 : this._controller1;
      anotherController.addSavingWorldTransform(this._molContainer);
    } else if (this._pressedGripsCounter === 0) {
      this._gfx.scene.addSavingWorldTransform(this._molContainer);
    }
  }
  enable(gfx) {
    if (!gfx) {
      logger.warn('WebVR couldn\'t be enabled, because gfx is not defined');
      return;
    }
    this._gfx = gfx;
    const {
      renderer,
      camera
    } = gfx;
    if (!renderer) {
      throw new Error('No renderer is available to toggle WebVR');
    }
    if (!camera) {
      throw new Error('No camera is available to toggle WebVR');
    }

    // enable xr in renderer
    renderer.xr.enabled = true;
    // add button for turning vr mode
    if (!this._button) {
      this._button = createWebVRButton(this);
      document.body.appendChild(this._button);
    } else {
      this._button.style.display = 'block';
    }
    // store fog setting
    this._mainFog = settings.now.fog;
    settings.set('fog', false);
    this._plugVRNodesIntoScene(gfx, renderer);
    this._setControllersListeners();

    // make some Miew job
    if (this._onToggle) {
      this._onToggle(true);
    }
  }
  _plugVRNodesIntoScene(gfx, renderer) {
    // store common scene camera
    this._mainCamera.copy(gfx.camera);
    // add hierarchical structure for webVR into scene
    gfx.scene.add(this._user);
    // turn on webvr transformation
    gfx.scene.add(this._molContainer);
    this._molContainer.add(gfx.root);
    this._controller1 = renderer.xr.getController(0);
    this._controller2 = renderer.xr.getController(1);
    const mesh = this._createControllerMesh();
    this._controller1.add(mesh);
    this._controller2.add(mesh.clone());
    this._user.add(this._controller1);
    this._user.add(this._controller2);
  }
  _setControllersListeners() {
    this._controller1.addEventListener('selectstart', event => {
      this.handleGripsDown(event);
    });
    this._controller1.addEventListener('selectend', event => {
      this.handleGripsUp(event);
    });
    this._controller2.addEventListener('selectstart', event => {
      this.handleGripsDown(event);
    });
    this._controller2.addEventListener('selectend', event => {
      this.handleGripsUp(event);
    });
    this._controller1.addEventListener('squeezestart', event => {
      this.handleGripsDown(event);
    });
    this._controller1.addEventListener('squeezeend', event => {
      this.handleGripsUp(event);
    });
    this._controller2.addEventListener('squeezestart', event => {
      this.handleGripsDown(event);
    });
    this._controller2.addEventListener('squeezeend', event => {
      this.handleGripsUp(event);
    });
  }
  disable() {
    if (!this._gfx) {
      return;
    }
    const {
      renderer,
      camera
    } = this._gfx;
    if (!renderer) {
      throw new Error('No renderer is available to toggle WebVR');
    }

    // nullify webxr callback for animation frame
    renderer.setAnimationLoop(null);
    const session = renderer.xr.getSession();
    if (session) {
      session.end();
    }
    renderer.xr.enabled = false;
    // remove button of VR entering
    if (this._button) {
      this._button.style.display = 'none';
    }
    // restore fog param
    settings.set('fog', this._mainFog);
    this._unplugVRNodesFromScene(camera);

    // make some Miew job
    if (this._onToggle) {
      this._onToggle(false);
    }
  }
  _unplugVRNodesFromScene(camera) {
    // restore common camera
    if (this._mainCamera && camera) {
      camera.copy(this._mainCamera);
    }
    // turn off webvr transformation
    const root = this._molContainer.children[0];
    if (root) {
      this._gfx.scene.add(root);
    }
    this._molContainer.parent.remove(this._molContainer);
    if (this._user) {
      this._gfx.scene.remove(this._user);
    }
    // free scene nodes
    this._molContainer = null;
    this._user = null;
    this._scalingPivot = null;
    this._user = null;
    this._controller1 = null;
    this._controller2 = null;
  }
  _createControllerMesh() {
    // visualize controllers with cylinders
    const geometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.CylinderGeometry(0.04, 0.04, 0.3);
    const material = new shaders_UberMaterial({
      lights: false,
      overrideColor: true
    });
    material.setUberOptions({
      fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(0x4444ff)
    });
    material.updateUniforms();
    const cylinder = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh(geometry, material);
    cylinder.rotateX(-Math.PI / 2);
    return cylinder;
  }
  updateMoleculeScale() {
    if (!this._controller1 || !this._controller2) {
      return;
    }
    const self = this;
    // update molecule scaling by controllers
    if (self._pressedGripsCounter === 2) {
      // recalc scaling pivot
      gfxutils.getMiddlePoint(self._controller1.position, self._controller2.position, self._scalingPivot.position);
      // recalc scaler
      const dist = self._controller1.position.distanceTo(self._controller2.position);
      const scaler = dist / self._distance;
      self._scalingPivot.scale.multiplyScalar(scaler);
      // save cur distance for next frame
      self._distance = dist;
    }
  }

  /**
   * Reposition molecule right before the camera.
   * @note The proper way is to initiate headset in the place of common Miew's camera.
   * But threejs limitations on setting new XRReferenceSpace enforce the molecule repositioning
   * Hope, something will change.
   */
  moveSceneBehindHeadset() {
    const gfx = this._gfx;
    const {
      camera
    } = gfx;

    // set container position in camera space
    const container = this._molContainer;
    container.matrix.identity();
    container.position.set(0, 0, -4.0);
    container.updateMatrix();

    // update container world matrix
    container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix);
    // readd to scene
    gfx.scene.addSavingWorldTransform(container);
    if (this._onToggle) {
      this._onToggle(true);
    }
  }
  getCanvas() {
    const gfx = this._gfx;
    return gfx && gfx.renderer ? gfx.renderer.domElement : null;
  }
}
;// CONCATENATED MODULE: ./src/gfx/shaders/ScreenQuadFromDistortionTex.frag
const ScreenQuadFromDistortionTex_namespaceObject = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform vec3 aberration;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  \r\n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r\n  gl_FragColor.a = 1.0;\r\n}";
;// CONCATENATED MODULE: ./src/Miew.js
/* global PACKAGE_VERSION:false */













































const {
  selectors: Miew_selectors,
  Atom: Miew_Atom,
  Residue: Miew_Residue,
  Chain: Miew_Chain,
  Molecule: Miew_Molecule
} = chem;
const EDIT_MODE = {
  COMPLEX: 0,
  COMPONENT: 1,
  FRAGMENT: 2
};
const LOADER_NOT_FOUND = 'Could not find suitable loader for this source';
const PARSER_NOT_FOUND = 'Could not find suitable parser for this source';

// Color management changed a lot in threejs 152+ version.
// To keep miew colors we disable the new color management system
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ColorManagement.enabled = false;
const {
  createElement: Miew_createElement
} = utils;
function updateFogRange(fog, center, radius) {
  fog.near = center - radius * settings.now.fogNearFactor;
  fog.far = center + radius * settings.now.fogFarFactor;
}
function removeExtension(fileName) {
  const dot = fileName.lastIndexOf('.');
  if (dot >= 0) {
    fileName = fileName.substr(0, dot);
  }
  return fileName;
}
function hasValidResidues(complex) {
  let hasValidRes = false;
  complex.forEachComponent(component => {
    component.forEachResidue(residue => {
      if (residue._isValid) {
        hasValidRes = true;
      }
    });
  });
  return hasValidRes;
}
function reportProgress(log, action, percent) {
  const TOTAL_PERCENT = 100;
  if (percent !== undefined) {
    log.debug(`${action}... ${Math.floor(percent * TOTAL_PERCENT)}%`);
  } else {
    log.debug(`${action}...`);
  }
}
function chooseFogColor() {
  return settings.now.fogColorEnable ? settings.now.fogColor : settings.now.bg.color;
}

// ////////////////////////////////////////////////////////////////////////////

/**
 * Main 3D Molecular Viewer class.
 *
 * @param {object} opts - Viewer options.
 * @param {HTMLElement=} opts.container - DOM element that serves as a viewer container.
 * @param {object=} opts.settings - An object with properties to override default settings.
 * @param {string=} opts.settingsCookie='settings' - The name of the cookie to save current settings to.
 * @param {string=} opts.cookiePath='/' - The path option for cookies. Defaults to root.
 *
 * @exports Miew
 * @constructor
 */
function Miew(opts) {
  utils_EventDispatcher.call(this);
  this._opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({
    settingsCookie: 'settings',
    cookiePath: '/'
  }, opts);
  /** @type {?object} */
  this._gfx = null;
  /** @type {ViewInterpolator} */
  this._interpolator = new ViewInterpolator();
  /** @type {HTMLElement} */
  this._container = opts && opts.container || document.getElementById('miew-container') || external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(document.getElementsByClassName('miew-container')) || document.body;
  /** @type {HTMLElement} */
  this._containerRoot = this._container;

  /** @type {boolean} */
  this._running = false;
  /** @type {boolean} */
  this._halting = false;
  /** @type {boolean} */
  this._building = false;
  /** @type {boolean} */
  this._needRender = true;
  /** @type {boolean} */
  this._hotKeysEnabled = true;

  /** @type {Settings} */
  this.settings = settings;
  const log = logger;
  log.console = false;
  log.level =  false ? 0 : 'info';
  /**
   * @type {Logger}
   * @example
   * miew.logger.addEventListener('message', function _onLogMessage(evt) {
   *   console.log(evt.message);
   * });
   */
  this.logger = log;
  this._cookies = new utils_Cookies(this);
  this.restoreSettings();
  if (opts && opts.settings) {
    this.settings.set(opts.settings);
  }

  /** @type {?Spinner} */
  this._spinner = null;
  /** @type {JobHandle[]} */
  this._loading = [];
  /** @type {?number}
   * @deprecated until Animation system refactoring
   */
  this._animInterval = null;

  /** @type {object} */
  this._visuals = {};
  /** @type {?string} */
  this._curVisualName = null;

  /** @type {array} */
  this._objects = [];

  /** @type {object} */
  this._sourceWindow = null;
  this.reset();
  if (this._repr) {
    log.debug(`Selected ${this._repr.mode.name} mode with ${this._repr.colorer.name} colorer.`);
  }
  const self = this;
  Miew.registeredPlugins.forEach(plugin => {
    plugin.call(self);
  });
  this._initOnSettingsChanged();
}
Miew.prototype = Object.create(utils_EventDispatcher.prototype);
Miew.prototype.constructor = Miew;
Miew.prototype.getMaxRepresentationCount = function () {
  return src_ComplexVisual.NUM_REPRESENTATION_BITS;
};

/**
 * Replace viewer container contents with a DOM element.
 * @param {HTMLElement} container - parent container.
 * @param {HTMLElement} element - DOM element to show.
 * @private
 */
function _setContainerContents(container, element) {
  const parent = container;
  while (parent.firstChild) {
    parent.removeChild(parent.firstChild);
  }
  parent.appendChild(element);
}

/**
 * Update Shadow Camera target position and frustum.
 * @private
 */
Miew.prototype._updateShadowCamera = function () {
  const shadowMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  const direction = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const OBB = {
    center: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
    halfSize: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
  };
  return function () {
    this._gfx.scene.updateMatrixWorld();
    for (let i = 0; i < this._gfx.scene.children.length; i++) {
      if (this._gfx.scene.children[i].type === 'DirectionalLight') {
        const light = this._gfx.scene.children[i];
        shadowMatrix.copy(light.shadow.camera.matrixWorldInverse);
        this.getOBB(shadowMatrix, OBB);
        direction.subVectors(light.target.position, light.position);
        light.position.subVectors(OBB.center, direction);
        light.target.position.copy(OBB.center);
        light.shadow.bias = 0.09;
        light.shadow.camera.bottom = -OBB.halfSize.y;
        light.shadow.camera.top = OBB.halfSize.y;
        light.shadow.camera.right = OBB.halfSize.x;
        light.shadow.camera.left = -OBB.halfSize.x;
        light.shadow.camera.near = direction.length() - OBB.halfSize.z;
        light.shadow.camera.far = direction.length() + OBB.halfSize.z;
        light.shadow.camera.updateProjectionMatrix();
      }
    }
  };
}();

/**
 * Initialize the viewer.
 * @returns {boolean} true on success.
 * @throws Forwards exception raised during initialization.
 * @see Miew#term
 */
Miew.prototype.init = function () {
  const container = this._container;
  const elem = utils.createElement('div', {
    class: 'miew-canvas'
  });
  _setContainerContents(container, elem);
  this._container = elem;
  const frag = document.createDocumentFragment();
  frag.appendChild(this._msgMode = Miew_createElement('div', {
    class: 'mode-message overlay'
  }, Miew_createElement('p', {}, 'COMPONENT EDIT MODE')));
  frag.appendChild(this._msgAtomInfo = Miew_createElement('div', {
    class: 'atom-info overlay'
  }, Miew_createElement('p', {}, '')));
  container.appendChild(frag);
  if (this._gfx !== null) {
    // block double init
    return true;
  }
  const self = this;
  this._showMessage('Viewer is being initialized...');
  try {
    this._initGfx();
    this._initListeners();
    this._spinner = new Spinner({
      lines: 13,
      length: 28,
      width: 14,
      radius: 42,
      color: '#fff',
      zIndex: 700
    });
    const target = getTopWindow();
    target.addEventListener('keydown', event => {
      self._onKeyDown(event);
    });
    target.addEventListener('keyup', event => {
      self._onKeyUp(event);
    });
    this._objectControls = new ui_ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, () => self._getAltObj());
    this._objectControls.addEventListener('change', e => {
      if (settings.now.shadow.on) {
        self._updateShadowCamera();
      }
      // route rotate, zoom, translate and translatePivot events to the external API
      switch (e.action) {
        case 'rotate':
          self.dispatchEvent({
            type: 'rotate',
            quaternion: e.quaternion
          });
          break;
        case 'zoom':
          self.dispatchEvent({
            type: 'zoom',
            factor: e.factor
          });
          break;
        default:
          self.dispatchEvent({
            type: e.action
          });
      }
      self.dispatchEvent({
        type: 'transform'
      });
      self._needRender = true;
    });
    const gfx = this._gfx;
    this._picker = new ui_Picker(gfx.root, gfx.camera, gfx.renderer.domElement);
    this._picker.addEventListener('newpick', event => {
      self._onPick(event);
    });
    this._picker.addEventListener('dblclick', event => {
      self.center(event);
    });
  } catch (error) {
    if (error.name === 'TypeError' && error.message === 'Cannot read property \'getExtension\' of null') {
      this._showMessage('Could not create WebGL context.');
    } else if (error.message.search(/webgl/i) > 1) {
      this._showMessage(error.message);
    } else {
      this._showMessage('Viewer initialization failed.');
      throw error;
    }
    return false;
  }

  // automatically load default file
  const file = this._opts && this._opts.load;
  if (file) {
    const type = this._opts && this._opts.type;
    this.load(file, {
      fileType: type,
      keepRepsInfo: true
    });
  }
  return true;
};

/**
 * Terminate the viewer completely.
 * @see Miew#init
 */
Miew.prototype.term = function () {
  this._showMessage('Viewer has been terminated.');
  this._loading.forEach(job => {
    job.cancel();
  });
  this._loading.length = 0;
  this.halt();
  this._gfx = null;
};

/**
 * Display message inside the viewer container, hiding WebGL canvas.
 * @param {string} msg - Message to show.
 * @private
 */
Miew.prototype._showMessage = function (msg) {
  const element = document.createElement('div');
  element.setAttribute('class', 'miew-message');
  element.appendChild(document.createElement('p')).appendChild(document.createTextNode(msg));
  _setContainerContents(this._container, element);
};

/**
 * Display WebGL canvas inside the viewer container, hiding any message shown.
 * @private
 */
Miew.prototype._showCanvas = function () {
  _setContainerContents(this._container, this._gfx.renderer.domElement);
};
Miew.prototype._requestAnimationFrame = function (callback) {
  const {
    xr
  } = this._gfx.renderer;
  if (xr && xr.enabled) {
    this._gfx.renderer.setAnimationLoop(callback);
    return;
  }
  requestAnimationFrame(callback);
};
function arezSpritesSupported(context) {
  return context.getExtension('EXT_frag_depth');
}
function isAOSupported(context) {
  return context.getExtension('WEBGL_depth_texture') && context.getExtension('WEBGL_draw_buffers');
}

/**
 * Initialize WebGL and set 3D scene up.
 * @private
 */
Miew.prototype._initGfx = function () {
  const gfx = {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
  const webGLOptions = {
    preserveDrawingBuffer: true,
    alpha: true,
    premultipliedAlpha: false
  };
  if (settings.now.antialias) {
    webGLOptions.antialias = true;
  }
  gfx.renderer2d = new gfx_CSS2DRenderer();
  gfx.renderer = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGL1Renderer(webGLOptions);
  gfx.renderer.shadowMap.enabled = settings.now.shadow.on;
  gfx.renderer.shadowMap.autoUpdate = false;
  gfx.renderer.shadowMap.type = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PCFShadowMap;
  capabilities.init(gfx.renderer);

  // z-sprites and ambient occlusion possibility
  if (!arezSpritesSupported(gfx.renderer.getContext())) {
    settings.set('zSprites', false);
  }
  if (!isAOSupported(gfx.renderer.getContext())) {
    settings.set('ao', false);
  }
  gfx.renderer.autoClear = false;
  gfx.renderer.setPixelRatio(window.devicePixelRatio);
  gfx.renderer.setSize(gfx.width, gfx.height);
  gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
  gfx.renderer.clearColor();
  gfx.renderer2d.setSize(gfx.width, gfx.height);
  gfx.camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera(settings.now.camFov, gfx.width / gfx.height, settings.now.camNear, settings.now.camFar);
  gfx.camera.setMinimalFov(settings.now.camFov);
  gfx.camera.position.z = settings.now.camDistance;
  gfx.camera.updateProjectionMatrix();
  gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
  gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
  gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);
  gfx.stereoCam = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.StereoCamera();
  gfx.scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const color = chooseFogColor();
  gfx.scene.fog = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Fog(color, settings.now.camNear, settings.now.camFar);
  gfx.root = new gfxutils.RCGroup();
  gfx.scene.add(gfx.root);
  gfx.pivot = new gfxutils.RCGroup();
  gfx.root.add(gfx.pivot);
  gfx.selectionScene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  gfx.selectionRoot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
  gfx.selectionRoot.matrixAutoUpdate = false;
  gfx.selectionScene.add(gfx.selectionRoot);
  gfx.selectionPivot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
  gfx.selectionPivot.matrixAutoUpdate = false;
  gfx.selectionRoot.add(gfx.selectionPivot);
  const light12 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DirectionalLight(0xffffff, 0.45);
  light12.position.set(0, 0.414, 1);
  light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
  light12.castShadow = true;
  light12.shadow.bias = 0.09;
  light12.shadow.radius = settings.now.shadow.radius;
  light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP);
  const pixelRatio = gfx.renderer.getPixelRatio();
  const shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio;
  light12.shadow.mapSize.width = shadowMapSize;
  light12.shadow.mapSize.height = shadowMapSize;
  light12.target.position.set(0.0, 0.0, 0.0);
  gfx.scene.add(light12);
  gfx.scene.add(light12.target);
  const light3 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.AmbientLight(0x666666);
  light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
  gfx.scene.add(light3);

  // add axes
  gfx.axes = new gfx_Axes(gfx.root, gfx.camera);
  const deviceWidth = gfx.width * pixelRatio;
  const deviceHeight = gfx.height * pixelRatio;
  gfx.offscreenBuf = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: true
  });
  if (gfx.renderer.getContext().getExtension('WEBGL_depth_texture')) {
    gfx.offscreenBuf.depthTexture = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DepthTexture();
    gfx.offscreenBuf.depthTexture.type = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UnsignedShortType;
  }
  gfx.offscreenBuf2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.offscreenBuf3 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.offscreenBuf4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.volBFTex = gfx.offscreenBuf3;
  gfx.volFFTex = gfx.offscreenBuf4;
  gfx.volWFFTex = gfx.offscreenBuf;

  // use float textures for volume rendering if possible
  if (gfx.renderer.getContext().getExtension('OES_texture_float')) {
    gfx.offscreenBuf5 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
      type: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FloatType,
      depthBuffer: false
    });
    gfx.offscreenBuf6 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
      type: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FloatType,
      depthBuffer: false
    });
    gfx.offscreenBuf7 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
      type: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FloatType,
      depthBuffer: true
    });
    gfx.volBFTex = gfx.offscreenBuf5;
    gfx.volFFTex = gfx.offscreenBuf6;
    gfx.volWFFTex = gfx.offscreenBuf7;
  } else {
    this.logger.warn('Device doesn\'t support OES_texture_float extension');
  }
  gfx.stereoBufL = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.stereoBufR = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  this._gfx = gfx;
  this._showCanvas();
  this._embedWebXR(settings.now.stereo === 'WEBVR');
  this._container.appendChild(gfx.renderer2d.getElement());

  // add FPS counter
  const stats = new gfx_Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.right = '0';
  stats.domElement.style.bottom = '0';
  this._container.appendChild(stats.domElement);
  this._fps = stats;
  this._fps.show(settings.now.fps);
};

/**
 * Setup event listeners.
 * @private
 */
Miew.prototype._initListeners = function () {
  const self = this;
  window.addEventListener('resize', () => {
    self._onResize();
  });
};

/**
 * Try to add numbers to the base name to make it unique among visuals
 * @private
 */
Miew.prototype._makeUniqueVisualName = function (baseName) {
  if (!baseName) {
    return Math.random().toString();
  }
  let name = baseName;
  let suffix = 1;
  while (this._visuals.hasOwnProperty(name)) {
    name = `${baseName} (${suffix.toString()})`;
    suffix++;
  }
  return name;
};

/**
 * Add visual to the viewer
 * @private
 */
Miew.prototype._addVisual = function (visual) {
  if (!visual) {
    return null;
  }

  // change visual name in order to make it unique
  const name = this._makeUniqueVisualName(visual.name);
  visual.name = name;
  this._visuals[name] = visual;
  this._gfx.pivot.add(visual);
  if (visual.getSelectionGeo) {
    this._gfx.selectionPivot.add(visual.getSelectionGeo());
  }
  return name;
};

/**
 * Remove visual from the viewer
 * @private
 */
Miew.prototype._removeVisual = function (visual) {
  let name = '';
  let obj = null;
  if (visual instanceof src_Visual) {
    ({
      name
    } = visual);
    obj = visual;
  } else if (typeof visual === 'string') {
    name = visual;
    obj = this._visuals[name];
  }
  if (!obj || !this._visuals.hasOwnProperty(name) || this._visuals[name] !== obj) {
    return;
  }
  if (name === this._curVisualName) {
    this._curVisualName = undefined;
  }
  delete this._visuals[name];
  obj.release(); // removes nodes from scene

  this._needRender = true;
};

/**
 * Call specified function for each Visual
 * @private
 */
Miew.prototype._forEachVisual = function (callback) {
  for (const name in this._visuals) {
    if (this._visuals.hasOwnProperty(name)) {
      callback(this._visuals[name]);
    }
  }
};

/**
 * Release (destroy) all visuals in the scene
 * @private
 */
Miew.prototype._releaseAllVisuals = function () {
  if (!this._gfx || !this._gfx.pivot) {
    return;
  }
  for (const name in this._visuals) {
    if (this._visuals.hasOwnProperty(name)) {
      this._visuals[name].release();
    }
  }
  this._visuals = {};
};

/**
 * Call specified function for each ComplexVisual
 * @private
 */
Miew.prototype._forEachComplexVisual = function (callback) {
  if (!this._gfx || !this._gfx.pivot) {
    return;
  }
  for (const name in this._visuals) {
    if (this._visuals.hasOwnProperty(name) && this._visuals[name] instanceof src_ComplexVisual) {
      callback(this._visuals[name]);
    }
  }
};

/**
 * Returns ComplexVisual with specified name, or current (if not found), or any, or null
 * @private
 */
Miew.prototype._getComplexVisual = function (name) {
  name = name || this._curVisualName;
  let any = null;
  let named = null;
  this._forEachComplexVisual(visual => {
    any = visual;
    if (visual.name === name) {
      named = visual;
    }
  });
  return named || any;
};

/**
 * Returns first found VolumeVisual (no more than one should be present actually)
 * @private
 */
Miew.prototype._getVolumeVisual = function () {
  let any = null;
  this._forEachVisual(visual => {
    if (visual instanceof src_VolumeVisual) {
      any = visual;
    }
  });
  return any;
};

/**
 * Returns ComplexVisual corresponding to specified complex
 * @private
 */
Miew.prototype._getVisualForComplex = function (complex) {
  if (!complex) {
    return null;
  }
  let found = null;
  this._forEachComplexVisual(visual => {
    if (visual.getComplex() === complex) {
      found = visual;
    }
  });
  return found;
};

/*
   * Get a list of names of visuals currently shown by the viewer
   */
Miew.prototype.getVisuals = function () {
  return Object.keys(this._visuals);
};

/*
   * Get complex visuals count
   */
Miew.prototype.getComplexVisualsCount = function () {
  let count = 0;
  this._forEachComplexVisual(() => count++);
  return count;
};

/*
   * Get current visual
   */
Miew.prototype.getCurrentVisual = function () {
  return this._curVisualName;
};

/*
   * Set current visual.
   * All further operations will be performed on this visual (complex) if not stated otherwise.
   */
Miew.prototype.setCurrentVisual = function (name) {
  if (!this._visuals[name]) {
    return;
  }
  this._curVisualName = name;
};

/**
 * Run the viewer, start processing update/render frames periodically.
 * Has no effect if already running.
 * @see Miew#halt
 */
Miew.prototype.run = function () {
  if (!this._running) {
    this._running = true;
    if (this._halting) {
      this._halting = false;
      return;
    }
    this._objectControls.enable(true);
    this._interpolator.resume();
    this._requestAnimationFrame(() => this._onTick());
  }
};

/**
 * Request the viewer to stop.
 * Will be processed during the next frame.
 * @see Miew#run
 */
Miew.prototype.halt = function () {
  if (this._running) {
    this._discardComponentEdit();
    this._discardFragmentEdit();
    this._objectControls.enable(false);
    this._interpolator.pause();
    this._halting = true;
  }
};

/**
 * Request the viewer to start / stop responsing
 * on hot keys.
 * @param enabled - start (true) or stop (false) response on hot keys.
 */
Miew.prototype.enableHotKeys = function (enabled) {
  this._hotKeysEnabled = enabled;
  this._objectControls.enableHotkeys(enabled);
};

/**
 * Callback which processes window resize.
 * @private
 */
Miew.prototype._onResize = function () {
  const gfx = this._gfx;
  if (!gfx) {
    return;
  }
  this._needRender = true;
  gfx.width = this._container.clientWidth;
  gfx.height = this._container.clientHeight;
  gfx.camera.aspect = gfx.width / gfx.height;
  gfx.camera.setMinimalFov(settings.now.camFov);
  gfx.camera.updateProjectionMatrix();
  gfx.renderer.setSize(gfx.width, gfx.height);
  gfx.renderer2d.setSize(gfx.width, gfx.height);
  this.dispatchEvent({
    type: 'resize'
  });
};
Miew.prototype._resizeOffscreenBuffers = function (width, height, stereo) {
  const gfx = this._gfx;
  stereo = stereo || 'NONE';
  const isAnaglyph = stereo === 'NONE' || stereo === 'ANAGLYPH';
  const multi = isAnaglyph ? 1 : 0.5;
  gfx.offscreenBuf.setSize(multi * width, height);
  gfx.offscreenBuf2.setSize(multi * width, height);
  gfx.offscreenBuf3.setSize(multi * width, height);
  gfx.offscreenBuf4.setSize(multi * width, height);
  if (gfx.offscreenBuf5) {
    gfx.offscreenBuf5.setSize(multi * width, height);
  }
  if (gfx.offscreenBuf6) {
    gfx.offscreenBuf6.setSize(multi * width, height);
  }
  if (gfx.offscreenBuf7) {
    gfx.offscreenBuf7.setSize(multi * width, height);
  }
  if (isAnaglyph) {
    gfx.stereoBufL.setSize(width, height);
    gfx.stereoBufR.setSize(width, height);
  }
};

/**
 * Callback which processes update/render frames.
 * @private
 */
Miew.prototype._onTick = function () {
  if (this._halting) {
    this._running = false;
    this._halting = false;
    return;
  }
  this._fps.update();
  this._requestAnimationFrame(() => this._onTick());
  this._onUpdate();
  if (this._needRender) {
    this._onRender();
    this._needRender = !settings.now.suspendRender || settings.now.stereo === 'WEBVR';
  }
};
Miew.prototype._getBSphereRadius = function () {
  // calculate radius that would include all visuals
  let radius = 0;
  this._forEachVisual(visual => {
    radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
  });
  return radius * this._objectControls.getScale();
};

/**
 * Calculate bounding box that would include all visuals and being axis aligned in world defined by
 * transformation matrix: matrix
 * @param {Matrix4} matrix - transformation matrix.
 * @param {object}  OBB           - calculating bounding box.
 * @param {Vector3} OBB.center    - OBB center.
 * @param {Vector3} OBB.halfSize  - half magnitude of OBB sizes.
 */
Miew.prototype.getOBB = function () {
  const _bSphereForOneVisual = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
  const _bBoxForOneVisual = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
  const _bBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
  const _invMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  const _points = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()];
  return function (matrix, OBB) {
    _bBox.makeEmpty();
    this._forEachVisual(visual => {
      _bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere);
      _bSphereForOneVisual.applyMatrix4(visual.matrixWorld).applyMatrix4(matrix);
      _bSphereForOneVisual.getBoundingBox(_bBoxForOneVisual);
      _bBox.union(_bBoxForOneVisual);
    });
    _bBox.getCenter(OBB.center);
    _invMatrix.copy(matrix).invert();
    OBB.center.applyMatrix4(_invMatrix);
    const {
      min
    } = _bBox;
    const {
      max
    } = _bBox;
    _points[0].set(min.x, min.y, min.z); // 000
    _points[1].set(max.x, min.y, min.z); // 100
    _points[2].set(min.x, max.y, min.z); // 010
    _points[3].set(min.x, min.y, max.z); // 001
    for (let i = 0, l = _points.length; i < l; i++) {
      _points[i].applyMatrix4(_invMatrix);
    }
    OBB.halfSize.set(Math.abs(_points[0].x - _points[1].x), Math.abs(_points[0].y - _points[2].y), Math.abs(_points[0].z - _points[3].z)).multiplyScalar(0.5);
  };
}();
Miew.prototype._updateFog = function () {
  const gfx = this._gfx;
  if (settings.now.fog) {
    if (typeof gfx.scene.fog === 'undefined' || gfx.scene.fog === null) {
      const color = chooseFogColor();
      gfx.scene.fog = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Fog(color);
      this._setUberMaterialValues({
        fog: settings.now.fog
      });
    }
    updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
  } else if (gfx.scene.fog) {
    gfx.scene.fog = undefined;
    this._setUberMaterialValues({
      fog: settings.now.fog
    });
  }
};
Miew.prototype._onUpdate = function () {
  if (this.isScriptingCommandAvailable !== undefined && this.isScriptingCommandAvailable() && !this._building) {
    this.callNextCmd();
  }
  this._objectControls.update();
  this._forEachComplexVisual(visual => {
    visual.getComplex().update();
  });
  if (settings.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
    this.rebuild();
  }
  if (!this._loading.length && !this._building && !this._needRebuild()) {
    this._updateView();
  }
  this._updateFog();
  if (this._gfx.renderer.xr.enabled) {
    this.webVR.updateMoleculeScale();
  }
};
Miew.prototype._onRender = function () {
  const gfx = this._gfx;

  // update all matrices
  gfx.scene.updateMatrixWorld();
  gfx.camera.updateMatrixWorld();
  this._clipPlaneUpdateValue(this._getBSphereRadius());
  this._fogFarUpdateValue();
  gfx.renderer.setRenderTarget(null);
  gfx.renderer.clear();
  this._renderFrame(settings.now.stereo);
};
Miew.prototype._renderFrame = function () {
  const _anaglyphMat = new shaders_AnaglyphMaterial();
  const _size = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function (stereo) {
    const gfx = this._gfx;
    const {
      renderer
    } = gfx;
    renderer.getSize(_size);
    if (stereo !== 'NONE') {
      gfx.camera.focus = gfx.camera.position.z; // set focus to the center of the object
      gfx.stereoCam.aspect = 1.0;

      // in anaglyph mode we render full-size image for each eye
      // while in other stereo modes only half-size (two images on the screen)
      if (stereo === 'ANAGLYPH') {
        gfx.stereoCam.update(gfx.camera);
      } else {
        gfx.stereoCam.updateHalfSized(gfx.camera, settings.now.camFov);
      }
    }

    // resize offscreen buffers to match the target
    const pixelRatio = gfx.renderer.getPixelRatio();
    this._resizeOffscreenBuffers(_size.width * pixelRatio, _size.height * pixelRatio, stereo);
    this._renderShadowMap();
    switch (stereo) {
      case 'WEBVR':
      case 'NONE':
        this._renderScene(gfx.camera, false);
        break;
      case 'SIMPLE':
      case 'DISTORTED':
        renderer.setScissorTest(true);
        renderer.setScissor(0, 0, _size.width / 2, _size.height);
        renderer.setViewport(0, 0, _size.width / 2, _size.height);
        this._renderScene(this._gfx.stereoCam.cameraL, stereo === 'DISTORTED');
        renderer.setScissor(_size.width / 2, 0, _size.width / 2, _size.height);
        renderer.setViewport(_size.width / 2, 0, _size.width / 2, _size.height);
        this._renderScene(this._gfx.stereoCam.cameraR, stereo === 'DISTORTED');
        renderer.setScissorTest(false);
        break;
      case 'ANAGLYPH':
        this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);
        this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);
        renderer.setRenderTarget(null);
        _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture;
        _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture;
        gfx.renderer.renderScreenQuad(_anaglyphMat);
        break;
      default:
    }
    gfx.renderer2d.render(gfx.scene, gfx.camera);
    if (settings.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
      gfx.axes.render(renderer);
    }
  };
}();
Miew.prototype._onBgColorChanged = function () {
  const gfx = this._gfx;
  const color = chooseFogColor();
  if (gfx) {
    if (gfx.scene.fog) {
      gfx.scene.fog.color.set(color);
    }
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
  }
  this._needRender = true;
};
Miew.prototype._onFogColorChanged = function () {
  const gfx = this._gfx;
  const color = chooseFogColor();
  if (gfx && gfx.scene.fog) {
    gfx.scene.fog.color.set(color);
  }
  this._needRender = true;
};
Miew.prototype._setUberMaterialValues = function (values) {
  this._gfx.root.traverse(obj => {
    if ((obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line) && obj.material instanceof shaders_UberMaterial) {
      obj.material.setValues(values);
      obj.material.needsUpdate = true;
    }
  });
};
Miew.prototype._enableMRT = function (on, renderBuffer, textureBuffer) {
  const gfx = this._gfx;
  const gl = gfx.renderer.getContext();
  const ext = gl.getExtension('WEBGL_draw_buffers');
  const {
    properties
  } = gfx.renderer;
  if (!on) {
    ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null]);
    return;
  }

  // take extra texture from Texture Buffer
  gfx.renderer.setRenderTarget(textureBuffer);
  const tx8 = properties.get(textureBuffer.texture).__webglTexture;
  gl.bindTexture(gl.TEXTURE_2D, tx8);

  // take texture and framebuffer from renderbuffer
  gfx.renderer.setRenderTarget(renderBuffer);
  const fb = properties.get(renderBuffer).__webglFramebuffer;
  const tx = properties.get(renderBuffer.texture).__webglTexture;

  // set framebuffer
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  fb.width = renderBuffer.width;
  fb.height = renderBuffer.height;
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0);

  // mapping textures
  ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
};
Miew.prototype._renderScene = function () {
  return function (camera, distortion, target) {
    distortion = distortion || false;
    target = target || null;
    const gfx = this._gfx;

    // render to offscreen buffer
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.setRenderTarget(target);
    gfx.renderer.clear();
    if (gfx.renderer.xr.enabled) {
      gfx.renderer.render(gfx.scene, camera);
      return;
    }

    // clean buffer for normals texture
    gfx.renderer.setClearColor(0x000000, 0.0);
    gfx.renderer.setRenderTarget(gfx.offscreenBuf4);
    gfx.renderer.clearColor();
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.setRenderTarget(gfx.offscreenBuf);
    gfx.renderer.clear();
    const bHaveComplexes = this._getComplexVisual() !== null;
    const volumeVisual = this._getVolumeVisual();
    const ssao = bHaveComplexes && settings.now.ao;
    if (ssao) {
      this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4);
    }
    if (settings.now.transparency === 'prepass') {
      this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
    } else if (settings.now.transparency === 'standard') {
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.render(gfx.scene, camera);
    }
    if (ssao) {
      this._enableMRT(false, null, null);
    }

    // when fxaa we should get resulting image in temp off-screen buff2 for further postprocessing with fxaa filter
    // otherwise we render to canvas
    const outline = bHaveComplexes && settings.now.outline.on;
    const fxaa = bHaveComplexes && settings.now.fxaa;
    const volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
    let dstBuffer = ssao || outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
    let srcBuffer = gfx.offscreenBuf;
    if (ssao) {
      this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);
      if (!fxaa && !distortion && !volume && !outline) {
        srcBuffer = dstBuffer;
        dstBuffer = target;
        gfx.renderer.setRenderTarget(dstBuffer);
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
      }
    } else {
      // just copy color buffer to dst buffer
      gfx.renderer.setRenderTarget(dstBuffer);
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1.0);
    }

    // outline
    if (outline) {
      srcBuffer = dstBuffer;
      dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;
      if (srcBuffer != null) {
        this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
      }
    }

    // render selected part with outline material
    this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);
    if (volume) {
      // copy current picture to the buffer that retains depth-data of the original molecule render
      // so that volume renderer could use depth-test
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
      dstBuffer = gfx.offscreenBuf;
      this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex);

      // if this is the last stage -- copy image to target
      if (!fxaa && !distortion) {
        gfx.renderer.setRenderTarget(target);
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1.0);
      }
    }
    srcBuffer = dstBuffer;
    if (fxaa) {
      dstBuffer = distortion ? gfx.offscreenBuf4 : target;
      this._performFXAA(srcBuffer, dstBuffer);
      srcBuffer = dstBuffer;
    }
    if (distortion) {
      dstBuffer = target;
      this._performDistortion(srcBuffer, dstBuffer, true);
    }
  };
}();
Miew.prototype._performDistortion = function () {
  const _scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const _camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.OrthographicCamera(-1.0, 1.0, 1.0, -1.0, -500, 1000);
  const _material = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial({
    uniforms: {
      srcTex: {
        type: 't',
        value: null
      },
      aberration: {
        type: 'fv3',
        value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1.0)
      }
    },
    vertexShader: ScreenQuad_namespaceObject,
    fragmentShader: ScreenQuadFromDistortionTex_namespaceObject,
    transparent: false,
    depthTest: false,
    depthWrite: false
  });
  const _geo = gfxutils.buildDistorionMesh(10, 10, settings.now.debug.stereoBarrel);
  _scene.add(new meshes.Mesh(_geo, _material));
  return function (srcBuffer, targetBuffer, mesh) {
    this._gfx.renderer.setRenderTarget(targetBuffer);
    this._gfx.renderer.clear();
    if (mesh) {
      _material.uniforms.srcTex.value = srcBuffer.texture;
      _material.uniforms.aberration.value.set(0.995, 1.0, 1.01);
      this._gfx.renderer.render(_scene, _camera);
    } else {
      this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings.now.debug.stereoBarrel);
    }
  };
}();
Miew.prototype._renderOutline = function () {
  const _outlineMaterial = new shaders_OutlineMaterial({
    depth: true
  });
  return function (camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
    const self = this;
    const gfx = self._gfx;

    // apply Sobel filter -- draw outline
    _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
    _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;
    _outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);
    _outlineMaterial.uniforms.color.value = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(settings.now.outline.color);
    _outlineMaterial.uniforms.threshold.value = settings.now.outline.threshold;
    _outlineMaterial.uniforms.thickness.value = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(settings.now.outline.thickness, settings.now.outline.thickness);
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.renderScreenQuad(_outlineMaterial);
  };
}();
Miew.prototype._renderShadowMap = function () {
  const pars = {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat
  };
  return function () {
    if (!settings.now.shadow.on) {
      return;
    }
    const gfx = this._gfx;
    const currentRenderTarget = gfx.renderer.getRenderTarget();
    const activeCubeFace = gfx.renderer.getActiveCubeFace();
    const activeMipmapLevel = gfx.renderer.getActiveMipmapLevel();
    const _state = gfx.renderer.state;

    // Set GL state for depth map.
    _state.setBlending(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i = 0; i < gfx.scene.children.length; i++) {
      if (gfx.scene.children[i].type === 'DirectionalLight') {
        const light = gfx.scene.children[i];
        if (light.shadow.map == null) {
          light.shadow.map = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(light.shadow.mapSize.width, light.shadow.mapSize.height, pars);
          light.shadow.camera.updateProjectionMatrix();
        }
        light.shadow.updateMatrices(light);
        gfx.renderer.setRenderTarget(light.shadow.map);
        gfx.renderer.clear();
        gfx.renderer.render(gfx.scene, light.shadow.camera);
      }
    }
    gfx.renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
}();

/**
 * Check if there is selection which must be rendered or not.
 * @private
 * @returns {boolean} true on existing selection to render
 */
Miew.prototype._hasSelectionToRender = function () {
  const selPivot = this._gfx.selectionPivot;
  for (let i = 0; i < selPivot.children.length; i++) {
    const selPivotChild = selPivot.children[i];
    if (selPivotChild.children.length > 0) {
      return true;
    }
  }
  return false;
};
Miew.prototype._renderSelection = function () {
  const _outlineMaterial = new shaders_OutlineMaterial();
  return function (camera, srcBuffer, targetBuffer) {
    const self = this;
    const gfx = self._gfx;

    // clear offscreen buffer (leave z-buffer intact)
    gfx.renderer.setClearColor('black', 0);

    // render selection to offscreen buffer
    gfx.renderer.setRenderTarget(srcBuffer);
    gfx.renderer.clear(true, false, false);
    if (self._hasSelectionToRender()) {
      gfx.selectionRoot.matrix = gfx.root.matrix;
      gfx.selectionPivot.matrix = gfx.pivot.matrix;
      gfx.renderer.render(gfx.selectionScene, camera);
    } else {
      // just render something to force "target clear" operation to finish
      gfx.renderer.renderDummyQuad();
    }

    // overlay to screen
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6);

    // apply Sobel filter -- draw outline
    _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;
    _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);
    gfx.renderer.renderScreenQuad(_outlineMaterial);
  };
}();
Miew.prototype._checkVolumeRenderingSupport = function (renderTarget) {
  if (!renderTarget) {
    return false;
  }
  const gfx = this._gfx;
  const oldRT = gfx.renderer.getRenderTarget();
  gfx.renderer.setRenderTarget(renderTarget);
  const context = gfx.renderer.getContext();
  const result = context.checkFramebufferStatus(context.FRAMEBUFFER);
  gfx.renderer.setRenderTarget(oldRT);
  if (result !== context.FRAMEBUFFER_COMPLETE) {
    // floatFrameBufferWarning = ;
    this.logger.warn('Device doesn\'t support electron density rendering');
    return false;
  }
  return true;
};
Miew.prototype._renderVolume = function () {
  const volumeBFMat = new shaders_VolumeMaterial.BackFacePosMaterial();
  const volumeFFMat = new shaders_VolumeMaterial.FrontFacePosMaterial();
  const cubeOffsetMat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().makeTranslation(0.5, 0.5, 0.5);
  const world2colorMat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  let volumeRenderingSupported;
  return function (volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
    const gfx = this._gfx;
    if (typeof volumeRenderingSupported === 'undefined') {
      volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
    }
    if (!volumeRenderingSupported) {
      return;
    }
    const mesh = volumeVisual.getMesh();
    mesh.rebuild(gfx.camera);

    // use main camera to prepare special textures to be used by volumetric rendering
    // these textures have the size of the window and are stored in offscreen buffers
    gfx.renderer.setClearColor('black', 0);
    gfx.renderer.setRenderTarget(tmpBuf1);
    gfx.renderer.clear();
    gfx.renderer.setRenderTarget(tmpBuf2);
    gfx.renderer.clear();
    gfx.renderer.setRenderTarget(tmpBuf3);
    gfx.renderer.clear();
    gfx.renderer.setRenderTarget(tmpBuf1);
    // draw plane with its own material, because it differs slightly from volumeBFMat
    camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
    gfx.renderer.render(gfx.scene, camera);
    camera.layers.set(gfxutils.LAYERS.VOLUME);
    gfx.scene.overrideMaterial = volumeBFMat;
    gfx.renderer.render(gfx.scene, camera);
    gfx.renderer.setRenderTarget(tmpBuf2);
    camera.layers.set(gfxutils.LAYERS.VOLUME);
    gfx.scene.overrideMaterial = volumeFFMat;
    gfx.renderer.render(gfx.scene, camera);
    gfx.scene.overrideMaterial = null;
    camera.layers.set(gfxutils.LAYERS.DEFAULT);

    // prepare texture that contains molecule positions
    world2colorMat.copy(mesh.matrixWorld).invert();
    shaders_UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
    camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION);
    gfx.renderer.setRenderTarget(tmpBuf3);
    gfx.renderer.render(gfx.scene, camera);

    // render volume
    const vm = mesh.material;
    vm.uniforms._BFRight.value = tmpBuf1.texture;
    vm.uniforms._FFRight.value = tmpBuf2.texture;
    vm.uniforms._WFFRight.value = tmpBuf3.texture;
    camera.layers.set(gfxutils.LAYERS.VOLUME);
    gfx.renderer.setRenderTarget(dstBuf);
    gfx.renderer.render(gfx.scene, camera);
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
  };
}();

/*  Render scene with 'ZPrepass transparency Effect'
   * Idea: transparent objects are rendered in two passes. The first one writes result only into depth buffer.
   * The second pass reads depth buffer and writes only to color buffer. The method results in
   * correct image of front part of the semi-transparent objects, but we can see only front transparent objects
   * and opaque objects inside, there is no transparent objects inside.
   * Notes: 1. Opaque objects should be rendered strictly before semi-transparent ones.
   * 2. Realization doesn't use camera layers because scene traversing is used for material changes and
   * we can use it to select needed meshes and don't complicate meshes builders with layers
  */
Miew.prototype._renderWithPrepassTransparency = function () {
  return function (camera, targetBuffer) {
    const gfx = this._gfx;
    gfx.renderer.setRenderTarget(targetBuffer);

    // opaque objects
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
    gfx.renderer.render(gfx.scene, camera);

    // transparent objects z prepass
    camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
    gfx.renderer.getContext().colorMask(false, false, false, false); // don't update color buffer
    gfx.renderer.render(gfx.scene, camera);
    gfx.renderer.getContext().colorMask(true, true, true, true); // update color buffer

    // transparent objects color pass
    camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
    gfx.renderer.render(gfx.scene, camera);

    // restore default layer
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
  };
}();
Miew.prototype._performFXAA = function () {
  const _fxaaMaterial = new shaders_FXAAMaterial();
  return function (srcBuffer, targetBuffer) {
    if (typeof srcBuffer === 'undefined' || typeof targetBuffer === 'undefined') {
      return;
    }
    const gfx = this._gfx;

    // clear canvas
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.clear();

    // do fxaa processing of offscreen buff2
    _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;
    _fxaaMaterial.uniforms.srcTexelSize.value.set(1.0 / srcBuffer.width, 1.0 / srcBuffer.height);
    _fxaaMaterial.uniforms.bgColor.value.set(settings.now.bg.color);
    if (_fxaaMaterial.bgTransparent !== settings.now.bg.transparent) {
      _fxaaMaterial.setValues({
        bgTransparent: settings.now.bg.transparent
      });
      _fxaaMaterial.needsUpdate = true;
    }
    gfx.renderer.renderScreenQuad(_fxaaMaterial);
  };
}();
Miew.prototype._performAO = function () {
  const _aoMaterial = new shaders_AOMaterial();
  const _horBlurMaterial = new shaders_AOHorBlurMaterial();
  const _vertBlurMaterial = new shaders_AOVertBlurWithBlendMaterial();
  const _scale = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {
    if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
      return;
    }
    const gfx = this._gfx;
    const tanHalfFOV = Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.DEG2RAD * 0.5 * gfx.camera.fov);
    _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
    _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
    _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;
    _aoMaterial.uniforms.srcTexelSize.value.set(1.0 / srcColorBuffer.width, 1.0 / srcColorBuffer.height);
    _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);
    _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
    _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
    _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
    gfx.root.matrix.extractScale(_scale);
    _aoMaterial.uniforms.kernelRadius.value = settings.now.debug.ssaoKernelRadius * _scale.x;
    _aoMaterial.uniforms.depthThreshold.value = 2.0 * this._getBSphereRadius(); // diameter
    _aoMaterial.uniforms.factor.value = settings.now.debug.ssaoFactor;
    // N: should be tempBuffer1 for proper use of buffers (see buffers using outside the function)
    gfx.renderer.setRenderTarget(tempBuffer1);
    gfx.renderer.renderScreenQuad(_aoMaterial);
    _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;
    _horBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer1.width, 1.0 / tempBuffer1.height);
    _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
    gfx.renderer.setRenderTarget(tempBuffer);
    gfx.renderer.renderScreenQuad(_horBlurMaterial);
    _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
    _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
    _vertBlurMaterial.uniforms.srcTexelSize.value.set(1.0 / tempBuffer.width, 1.0 / tempBuffer.height);
    _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
    _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
    _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
    _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
    const {
      fog
    } = gfx.scene;
    if (fog) {
      _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);
      _vertBlurMaterial.uniforms.fogColor.value.set(fog.color.r, fog.color.g, fog.color.b, settings.now.fogAlpha);
    }
    if (_vertBlurMaterial.useFog !== settings.now.fog || _vertBlurMaterial.fogTransparent !== settings.now.bg.transparent) {
      _vertBlurMaterial.setValues({
        useFog: settings.now.fog,
        fogTransparent: settings.now.bg.transparent
      });
      _vertBlurMaterial.needsUpdate = true;
    }
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.renderScreenQuad(_vertBlurMaterial);
  };
}();

/**
 * Reset the viewer, unload molecules.
 * @param {boolean=} keepReps - Keep representations while resetting viewer state.
 */
Miew.prototype.reset = function /* keepReps */
() {
  if (this._picker) {
    this._picker.reset();
  }
  this._lastPick = null;
  this._releaseAllVisuals();
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._resetObjects();
  if (this._gfx) {
    gfxutils.clearTree(this._gfx.pivot);
    this._gfx.renderer2d.reset();
  }
  this.setNeedRender();
};
Miew.prototype._resetScene = function () {
  this._objectControls.reset();
  this._objectControls.allowTranslation(true);
  this._objectControls.allowAltObjFreeRotation(true);
  this.resetReps();
  this.resetPivot();
  this.rebuildAll();
};
Miew.prototype.resetView = function () {
  // reset controls
  if (this._picker) {
    this._picker.reset();
  }
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._resetScene();

  // reset selection
  this._forEachComplexVisual(visual => {
    visual.updateSelectionMask({});
    visual.rebuildSelectionGeometry();
  });
};
Miew.prototype._export = function (format) {
  const TheExporter = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.exporters.find({
    format
  }));
  if (!TheExporter) {
    this.logger.error('Could not find suitable exporter for this source');
    return Promise.reject(new Error('Could not find suitable exporter for this source'));
  }
  this.dispatchEvent({
    type: 'exporting'
  });
  if (this._visuals[this._curVisualName] instanceof src_ComplexVisual) {
    let dataSource = null;
    if (TheExporter.SourceClass === src_ComplexVisual) {
      dataSource = this._visuals[this._curVisualName];
    } else if (TheExporter.SourceClass === chem_Complex) {
      dataSource = this._visuals[this._curVisualName]._complex;
    }
    const exporter = new TheExporter(dataSource, {
      miewVersion: Miew.VERSION
    });
    return exporter.export().then(data => data);
  }
  if (this._visuals[this._curVisualName] instanceof src_VolumeVisual) {
    return Promise.reject(new Error('Sorry, exporter for volume data not implemented yet'));
  }
  return Promise.reject(new Error('Unexpected format of data'));
};
const rePdbId = /^(?:(pdb|cif|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i;
const rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
const reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;
function resolveSourceShortcut(source, opts) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(source)) {
    return source;
  }

  // e.g. "cif:1CRN"
  const matchesPdbId = rePdbId.exec(source);
  if (matchesPdbId) {
    let [, format = 'pdb', id] = matchesPdbId;
    format = format.toLowerCase();
    id = id.toUpperCase();
    switch (format) {
      case 'pdb':
        source = `https://files.rcsb.org/download/${id}.pdb`;
        break;
      case 'cif':
        source = `https://files.rcsb.org/download/${id}.cif`;
        break;
      case 'ccp4':
        source = `https://www.ebi.ac.uk/pdbe/coordinates/files/${id.toLowerCase()}.ccp4`;
        break;
      case 'dsn6':
        source = `https://edmaps.rcsb.org/maps/${id.toLowerCase()}_2fofc.dsn6`;
        break;
      default:
        throw new Error('Unexpected data format shortcut');
    }
    opts.fileType = format;
    opts.fileName = `${id}.${format}`;
    opts.sourceType = 'url';
    return source;
  }

  // e.g. "pc:aspirin"
  const matchesPubchem = rePubchem.exec(source);
  if (matchesPubchem) {
    const compound = matchesPubchem[1].toLowerCase();
    source = `https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${compound}/JSON?record_type=3d`;
    opts.fileType = 'pubchem';
    opts.fileName = `${compound}.json`;
    opts.sourceType = 'url';
    return source;
  }

  // otherwise is should be an URL
  if (opts.sourceType === 'url' || opts.sourceType === undefined) {
    opts.sourceType = 'url';

    // e.g. "./data/1CRN.pdb"
    if (!reUrlScheme.test(source)) {
      source = utils.resolveURL(source);
    }
  }
  return source;
}
function updateBinaryMode(opts) {
  let {
    binary
  } = opts;

  // detect by format
  if (opts.fileType !== undefined) {
    const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
      format: opts.fileType
    }));
    if (TheParser) {
      binary = TheParser.binary || false;
    } else {
      throw new Error('Could not find suitable parser for this format');
    }
  }

  // detect by file extension
  if (binary === undefined && opts.fileExt !== undefined) {
    const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
      ext: opts.fileExt
    }));
    if (TheParser) {
      binary = TheParser.binary || false;
    }
  }

  // temporary workaround for animation
  if (opts.fileExt !== undefined && opts.fileExt.toLowerCase() === '.man') {
    opts.binary = true;
    opts.animation = true; // who cares?
  }

  // update if detected
  if (binary !== undefined) {
    if (opts.binary !== undefined && opts.binary !== binary) {
      opts.context.logger.warn('Overriding incorrect binary mode');
    }
  }
  opts.binary = binary || false;
}
function _fetchData(source, opts, job) {
  return new Promise(resolve => {
    if (job.shouldCancel()) {
      throw new Error('Operation cancelled');
    }
    job.notify({
      type: 'fetching'
    });

    // allow for source shortcuts
    source = resolveSourceShortcut(source, opts);

    // detect a proper loader
    const TheLoader = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.loaders.find({
      type: opts.sourceType,
      source
    }));
    if (!TheLoader) {
      throw new Error(LOADER_NOT_FOUND);
    }

    // split file name
    const fileName = opts.fileName || TheLoader.extractName(source);
    if (fileName) {
      const [name, fileExt] = utils.splitFileName(fileName);
      external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
        name,
        fileExt,
        fileName
      });
    }

    // should it be text or binary?
    updateBinaryMode(opts);

    // FIXME: All new settings retrieved from server are applied after the loading is complete. However, we need some
    // flags to alter the loading process itself. Here we apply them in advance. Dirty hack. Kill the server, remove
    // all hacks and everybody's happy.
    let newOptions = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(opts, 'preset.expression');
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(newOptions)) {
      newOptions = JSON.parse(newOptions);
      if (newOptions && newOptions.settings) {
        const keys = ['singleUnit'];
        for (let keyIndex = 0, keyCount = keys.length; keyIndex < keyCount; ++keyIndex) {
          const key = keys[keyIndex];
          const value = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(newOptions.settings, key);
          if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(value)) {
            settings.set(key, value);
          }
        }
      }
    }

    // create a loader
    const loader = new TheLoader(source, opts);
    loader.context = opts.context;
    job.addEventListener('cancel', () => loader.abort());
    loader.addEventListener('progress', event => {
      if (event.lengthComputable && event.total > 0) {
        reportProgress(loader.logger, 'Fetching', event.loaded / event.total);
      } else {
        reportProgress(loader.logger, 'Fetching');
      }
    });
    console.time('fetch');
    const promise = loader.load().then(data => {
      console.timeEnd('fetch');
      opts.context.logger.info('Fetching finished');
      job.notify({
        type: 'fetchingDone',
        data
      });
      return data;
    }).catch(error => {
      console.timeEnd('fetch');
      opts.context.logger.debug(error.message);
      if (error.stack) {
        opts.context.logger.debug(error.stack);
      }
      opts.context.logger.error('Fetching failed');
      job.notify({
        type: 'fetchingDone',
        error
      });
      throw error;
    });
    resolve(promise);
  });
}
function _parseData(data, opts, job) {
  if (job.shouldCancel()) {
    return Promise.reject(new Error('Operation cancelled'));
  }
  job.notify({
    type: 'parsing'
  });
  const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
    format: opts.fileType,
    ext: opts.fileExt,
    data
  }));
  if (!TheParser) {
    return Promise.reject(new Error('Could not find suitable parser'));
  }
  const parser = new TheParser(data, opts);
  parser.context = opts.context;
  job.addEventListener('cancel', () => parser.abort());
  console.time('parse');
  return parser.parse().then(dataSet => {
    console.timeEnd('parse');
    job.notify({
      type: 'parsingDone',
      data: dataSet
    });
    return dataSet;
  }).catch(error => {
    console.timeEnd('parse');
    opts.error = error;
    opts.context.logger.debug(error.message);
    if (error.stack) {
      opts.context.logger.debug(error.stack);
    }
    opts.context.logger.error('Parsing failed');
    job.notify({
      type: 'parsingDone',
      error
    });
    throw error;
  });
}

/**
 * Load molecule asynchronously.
 * @param {string|File} source - Molecule source to load (e.g. PDB ID, URL or File object).
 * @param {object=} opts - Options.
 * @param {string=} opts.sourceType - Data source type (e.g. 'url', 'file').
 * @param {string=} opts.fileType - Data contents type (e.g. 'pdb', 'cml').
 * @param {string=} opts.mdFile - .nc file path.
 * @param {boolean=} opts.keepRepsInfo - prevent reset of object and reps information.
 * @returns {Promise} name of the visual that was added to the viewer
 */
Miew.prototype.load = function (source, opts) {
  opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({}, opts, {
    context: this
  });

  // for a single-file scenario
  if (!this.settings.now.use.multiFile) {
    // abort all loaders in progress
    if (this._loading.length) {
      this._loading.forEach(job => {
        job.cancel();
      });
      this._loading.length = 0;
    }

    // reset
    if (!opts.animation) {
      // FIXME: sometimes it is set AFTERWARDS!
      this.reset(true);
    }
  }
  this._interpolator.reset();
  this.dispatchEvent({
    type: 'loading',
    options: opts,
    source
  });
  const job = new JobHandle();
  this._loading.push(job);
  job.addEventListener('notification', e => {
    this.dispatchEvent(e.slaveEvent);
  });
  this._spinner.spin(this._container);
  const onLoadEnd = anything => {
    const jobIndex = this._loading.indexOf(job);
    if (jobIndex !== -1) {
      this._loading.splice(jobIndex, 1);
    }
    this._spinner.stop();
    this._refreshTitle();
    job.notify({
      type: 'loadingDone',
      anything
    });
    return anything;
  };
  return _fetchData(source, opts, job).then(data => _parseData(data, opts, job)).then(object => {
    const name = this._onLoad(object, opts);
    return onLoadEnd(name);
  }).catch(err => {
    this.logger.error('Could not load data');
    this.logger.debug(err);
    throw onLoadEnd(err);
  });
};

/**
 * Unload molecule (delete corresponding visual).
 * @param {string=} name - name of the visual
 */
Miew.prototype.unload = function (name) {
  this._removeVisual(name || this.getCurrentVisual());
  this.resetPivot();
  if (settings.now.shadow.on) {
    this._updateShadowCamera();
  }
};

/**
 * Start new animation. Now is broken.
 * @param fileData - new data to animate
 * @private
 * @deprecated until animation system refactoring.
 */
Miew.prototype._startAnimation = function (fileData) {
  this._stopAnimation();
  const self = this;
  const visual = this._getComplexVisual();
  if (visual === null) {
    this.logger.error('Unable to start animation - no molecule is loaded.');
    return;
  }
  try {
    this._frameInfo = new gfx_FrameInfo(visual.getComplex(), fileData, {
      onLoadStatusChanged() {
        self.dispatchEvent({
          type: 'mdPlayerStateChanged',
          state: {
            isPlaying: self._isAnimating,
            isLoading: self._frameInfo ? self._frameInfo.isLoading : true
          }
        });
      },
      onError(message) {
        self._stopAnimation();
        self.logger.error(message);
      }
    });
  } catch (e) {
    this.logger.error('Animation file does not fit to current complex!');
    return;
  }
  this._continueAnimation();
};

/**
 * Pause current animation. Now is broken.
 * @private
 * @deprecated until animation system refactoring.
 */
Miew.prototype._pauseAnimation = function () {
  if (this._animInterval === null) {
    return;
  }
  this._isAnimating = false;
  clearInterval(this._animInterval);
  this._animInterval = null;
  if (this._frameInfo) {
    this.dispatchEvent({
      type: 'mdPlayerStateChanged',
      state: {
        isPlaying: this._isAnimating,
        isLoading: this._frameInfo.isLoading
      }
    });
  }
};

/**
 * Continue current animation after pausing. Now is broken.
 * @private
 * @deprecated until animation system refactoring.
 */
Miew.prototype._continueAnimation = function () {
  this._isAnimating = true;
  let minFrameTime = 1000 / settings.now.maxfps;
  minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
  const self = this;
  const {
    pivot
  } = self._gfx;
  const visual = this._getComplexVisual();
  if (visual) {
    visual.resetSelectionMask();
    visual.rebuildSelectionGeometry();
    this._msgAtomInfo.style.opacity = 0.0;
  }
  this._animInterval = setInterval(() => {
    self.dispatchEvent({
      type: 'mdPlayerStateChanged',
      state: {
        isPlaying: self._isAnimating,
        isLoading: self._frameInfo.isLoading
      }
    });
    if (self._frameInfo.frameIsReady) {
      pivot.updateToFrame(self._frameInfo);
      self._updateObjsToFrame(self._frameInfo);
      self._refreshTitle(` Frame ${self._frameInfo._currFrame} of ${self._frameInfo._framesCount} time interval - ${self._frameInfo._timeStep}`);
      try {
        self._frameInfo.nextFrame();
      } catch (e) {
        self.logger.error('Error during animation');
        self._stopAnimation();
        return;
      }
      self._needRender = true;
    }
  }, minFrameTime);
};

/**
 * Stop current animation. Now is broken.
 * @private
 * @deprecated until animation system refactoring.
 */
Miew.prototype._stopAnimation = function () {
  if (this._animInterval === null) {
    return;
  }
  clearInterval(this._animInterval);
  this._frameInfo.disableEvents();
  this._frameInfo = null;
  this._animInterval = null;
  this.dispatchEvent({
    type: 'mdPlayerStateChanged',
    state: null
  });
};

/**
 * Invoked upon successful loading of some data source
 * @param {DataSource} dataSource - Data source for visualization (molecular complex or other)
 * @param {object} opts - Options.
 * @private
 */
Miew.prototype._onLoad = function (dataSource, opts) {
  const gfx = this._gfx;
  let visualName = null;
  if (opts.animation) {
    this._refreshTitle();
    this._startAnimation(dataSource);
    return null;
  }
  this._stopAnimation();
  if (!opts || !opts.keepRepsInfo) {
    this._opts.reps = null;
    this._opts._objects = null;
  }
  if (dataSource.id === 'Complex') {
    const complex = dataSource;

    // update title
    if (opts.fileName) {
      complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
    } else if (opts.amberFileName) {
      complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
    } else {
      complex.name = `Dynamic ${opts.fileType} molecule`;
    }
    visualName = this._addVisual(new src_ComplexVisual(complex.name, complex));
    this._curVisualName = visualName;
    const desc = this.info();
    this.logger.info(`Parsed ${opts.fileName} (${desc.atoms} atoms, ${desc.bonds} bonds, ${desc.residues} residues, ${desc.chains} chains).`);
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(this._opts.unit)) {
      complex.setCurrentUnit(this._opts.unit);
    }
    if (opts.preset) {
      // ...removed server access...
    } else if (settings.now.autoPreset) {
      switch (opts.fileType) {
        case 'cml':
          this.resetReps('small');
          break;
        case 'pdb':
        case 'mmtf':
        case 'cif':
          if (hasValidResidues(complex)) {
            this.resetReps('macro');
          } else {
            this.resetReps('small');
          }
          break;
        default:
          this.resetReps('default');
          break;
      }
    } else {
      this.resetReps('default');
    }
  } else if (dataSource.id === 'Volume') {
    this.resetEd();
    visualName = this._onLoadEd(dataSource);
  }
  gfx.camera.updateProjectionMatrix();
  this._updateFog();

  // reset global transform
  gfx.root.resetTransform();
  this.resetPivot();

  // set scale to fit everything on the screen
  this._objectControls.setScale(settings.now.radiusToFit / this._getBSphereRadius());
  this._resetObjects();
  if (settings.now.autoResolution) {
    this._tweakResolution();
  }
  if (settings.now.shadow.on) {
    this._updateShadowCamera();
  }
  if (this._opts.view) {
    this.view(this._opts.view);
    delete this._opts.view;
  }
  this._refreshTitle();
  return visualName;
};
Miew.prototype.resetEd = function () {
  if (this._edLoader) {
    this._edLoader.abort();
    this._edLoader = null;
  }

  // free all resources
  this._removeVisual(this._getVolumeVisual());
  this._needRender = true;
};
Miew.prototype.loadEd = function (source) {
  this.resetEd();
  const TheLoader = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.loaders.find({
    source
  }));
  if (!TheLoader) {
    this.logger.error(LOADER_NOT_FOUND);
    return Promise.reject(new Error(LOADER_NOT_FOUND));
  }
  const loader = this._edLoader = new TheLoader(source, {
    binary: true
  });
  loader.context = this;
  return loader.load().then(data => {
    const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
      format: 'ccp4'
    }));
    if (!TheParser) {
      throw new Error(PARSER_NOT_FOUND);
    }
    const parser = new TheParser(data);
    parser.context = this;
    return parser.parse().then(dataSource => {
      this._onLoadEd(dataSource);
    });
  }).catch(error => {
    this.logger.error('Could not load ED data');
    this.logger.debug(error);
  });
};
Miew.prototype._onLoadEd = function (dataSource) {
  dataSource.normalize();
  const volumeVisual = new src_VolumeVisual('volume', dataSource);
  volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME); // volume mesh is not visible to common render
  const visualName = this._addVisual(volumeVisual);
  this._needRender = true;
  return visualName;
};
Miew.prototype._needRebuild = function () {
  let needsRebuild = false;
  this._forEachComplexVisual(visual => {
    needsRebuild = needsRebuild || visual.needsRebuild();
  });
  return needsRebuild;
};
Miew.prototype._rebuildObjects = function () {
  const self = this;
  const gfx = this._gfx;
  let i;
  let n;

  // remove old object geometry
  const toRemove = [];
  for (i = 0; i < gfx.pivot.children.length; ++i) {
    const child = gfx.pivot.children[i];
    if (!(child instanceof src_Visual)) {
      toRemove.push(child);
    }
  }
  for (i = 0; i < toRemove.length; ++i) {
    toRemove[i].parent.remove(toRemove[i]);
  }
  setTimeout(() => {
    const objList = self._objects;
    for (i = 0, n = objList.length; i < n; ++i) {
      const obj = objList[i];
      if (obj.needsRebuild) {
        obj.build();
      }
      if (obj.getGeometry()) {
        gfx.pivot.add(obj.getGeometry());
      }
    }
  }, 10);
};
Miew.prototype.changeUnit = function (unitIdx, name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    throw new Error('There is no complex to change!');
  }
  function currentUnitInfo() {
    const unit = visual ? visual.getComplex().getCurrentUnit() : 0;
    const type = unit > 0 ? `Bio molecule ${unit}` : 'Asymmetric unit';
    return `Current unit: ${unit} (${type})`;
  }
  if (unitIdx === undefined) {
    return currentUnitInfo();
  }
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(unitIdx)) {
    unitIdx = Math.max(parseInt(unitIdx, 10), 0);
  }
  if (visual.getComplex().setCurrentUnit(unitIdx)) {
    this._resetScene();
    this._updateInfoPanel();
  }
  return currentUnitInfo();
};

/**
 * Start to rebuild geometry asynchronously.
 */
Miew.prototype.rebuild = function () {
  if (this._building) {
    this.logger.warn('Miew.rebuild(): already building!');
    return;
  }
  this._building = true;
  this.dispatchEvent({
    type: 'rebuilding'
  });
  this._rebuildObjects();
  this._gfx.renderer2d.reset();
  const rebuildActions = [];
  this._forEachComplexVisual(visual => {
    if (visual.needsRebuild()) {
      rebuildActions.push(visual.rebuild().then(() => new Promise(resolve => {
        visual.rebuildSelectionGeometry();
        resolve();
      })));
    }
  });

  // Start asynchronous rebuild
  const self = this;
  this._spinner.spin(this._container);
  Promise.all(rebuildActions).then(() => {
    self._spinner.stop();
    self._needRender = true;
    self._refreshTitle();
    this.dispatchEvent({
      type: 'buildingDone'
    });
    self._building = false;
  });
};

/** Mark all representations for rebuilding */
Miew.prototype.rebuildAll = function () {
  this._forEachComplexVisual(visual => {
    visual.setNeedsRebuild();
  });
};
Miew.prototype._refreshTitle = function (appendix) {
  let title;
  appendix = appendix === undefined ? '' : appendix;
  const visual = this._getComplexVisual();
  if (visual) {
    title = visual.getComplex().name;
    const rep = visual.repGet(visual.repCurrent());
    title += rep ? ` – ${rep.mode.name} Mode` : '';
  } else {
    title = Object.keys(this._visuals).length > 0 ? 'Unknown' : 'No Data';
  }
  title += appendix;
  this.dispatchEvent({
    type: 'titleChanged',
    data: title
  });
};
Miew.prototype.setNeedRender = function () {
  this._needRender = true;
};
Miew.prototype._extractRepresentation = function () {
  const changed = [];
  this._forEachComplexVisual(visual => {
    if (visual.getSelectionCount() === 0) {
      return;
    }
    const selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
    const defPreset = settings.now.presets.default;
    const res = visual.repAdd({
      selector,
      mode: defPreset[0].mode.id,
      colorer: defPreset[0].colorer.id,
      material: defPreset[0].material.id
    });
    if (!res) {
      if (visual.repCount() === src_ComplexVisual.NUM_REPRESENTATION_BITS) {
        this.logger.warn(`Number of representations is limited to ${src_ComplexVisual.NUM_REPRESENTATION_BITS}`);
      }
      return;
    }
    this.dispatchEvent({
      type: 'repAdded',
      index: res.index,
      name: visual.name
    });
    visual.repCurrent(res.index);
    changed.push(visual.name);
  });
  if (changed.length > 0) {
    this.logger.report(`New representation from selection for complexes: ${changed.join(', ')}`);
  }
};

/**
 * Change current representation list.
 * @param {array} reps - Representation list.
 */
Miew.prototype._setReps = function (reps) {
  reps = reps || this._opts && this._opts.reps || [];
  this._forEachComplexVisual(visual => visual.resetReps(reps));
};

/**
 * Apply existing preset to current scene.
 * @param preset
 */
Miew.prototype.applyPreset = function (preset) {
  const {
    presets
  } = settings.now;
  const presList = [preset || settings.defaults.preset, settings.defaults.preset, Object.keys(presets)[0]];
  let reps = null;
  for (let i = 0; !reps && i < presList.length; ++i) {
    settings.set('preset', presList[i]);
    reps = presets[settings.now.preset];
    if (!reps) {
      this.logger.warn(`Unknown preset "${settings.now.preset}"`);
    }
  }
  this._setReps(reps);
};

/**
 * Reset current representation list to initial values.
 * @param {string} [preset] - The source preset in case of uninitialized representation list.
 */
Miew.prototype.resetReps = function (preset) {
  const reps = this._opts && this._opts.reps;
  if (reps) {
    this._setReps(reps);
  } else {
    this.applyPreset(preset);
  }
};

/**
 * Get number of representations created so far.
 * @returns {number} Number of reps.
 */
Miew.prototype.repCount = function (name) {
  const visual = this._getComplexVisual(name);
  return visual ? visual.repCount() : 0;
};

/**
 * Get or set the current representation index.
 * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
 * @param {string=} [name] - Complex name. Defaults to the current one.
 * @returns {number} The current index.
 */
Miew.prototype.repCurrent = function (index, name) {
  const visual = this._getComplexVisual(name);
  const newIdx = visual ? visual.repCurrent(index) : -1;
  if (index && newIdx !== index) {
    this.logger.warn(`Representation ${index} was not found. Current rep remains unchanged.`);
  }
  return newIdx;
};

/**
 * Get or set representation by index.
 * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
 * @param {object=} rep - Optional representation description.
 * @param {string=} rep.selector - Selector string.
 * @param {string=} rep.mode - Mode id.
 * @param {string=} rep.colorer - Colorer id.
 * @param {string=} rep.material - Material id.
 * @returns {?object} Representation description.
 */
Miew.prototype.rep = function (index, rep) {
  const visual = this._getComplexVisual('');
  if (!visual) {
    return null;
  }
  const res = visual.rep(index, rep);
  if (res.status === 'created') {
    this.dispatchEvent({
      type: 'repAdded',
      index: res.index,
      name: visual.name
    });
  } else if (res.status === 'changed') {
    this.dispatchEvent({
      type: 'repChanged',
      index: res.index,
      name: visual.name
    });
  }
  return res.desc;
};

/**
 * Get representation (not just description) by index.
 * @param {number=} index - Zero-based index, up to {@link Miew#repCount}(). Defaults to the current one.
 * @returns {?object} Representation.
 */
Miew.prototype.repGet = function (index, name) {
  const visual = this._getComplexVisual(name);
  return visual ? visual.repGet(index) : null;
};

/**
 * Add new representation.
 * @param {object=} rep - Representation description.
 * @returns {number} Index of the new representation.
 */
Miew.prototype.repAdd = function (rep, name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    return -1;
  }
  const res = visual.repAdd(rep);
  if (res) {
    this.dispatchEvent({
      type: 'repAdded',
      index: res.index,
      name
    });
    return res.index;
  }
  return -1;
};

/**
 * Remove representation.
 * @param {number=} index - Zero-based representation index.
 */
Miew.prototype.repRemove = function (index, name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    return;
  }
  visual.repRemove(index);
  this.dispatchEvent({
    type: 'repRemoved',
    index,
    name
  });
};

/**
 * Hide representation.
 * @param {number} index - Zero-based representation index.
 * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
 */
Miew.prototype.repHide = function (index, hide, name) {
  this._needRender = true;
  const visual = this._getComplexVisual(name);
  return visual ? visual.repHide(index, hide) : null;
};
Miew.prototype._setEditMode = function (mode) {
  this._editMode = mode;
  const elem = this._msgMode;
  if (elem) {
    elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0.0 : 1.0;
    if (mode !== EDIT_MODE.COMPLEX) {
      const t = elem.getElementsByTagName('p')[0];
      t.innerHTML = mode === EDIT_MODE.COMPONENT ? 'COMPONENT EDIT MODE' : 'FRAGMENT EDIT MODE';
    }
  }
  this.dispatchEvent({
    type: 'editModeChanged',
    data: mode === EDIT_MODE.COMPLEX
  });
};
Miew.prototype._enterComponentEditMode = function () {
  if (this._editMode !== EDIT_MODE.COMPLEX) {
    return;
  }
  const editors = [];
  this._forEachComplexVisual(visual => {
    const editor = visual.beginComponentEdit();
    if (editor) {
      editors.push(editor);
    }
  });
  if (editors === []) {
    return;
  }
  this._editors = editors;
  this.logger.info('COMPONENT EDIT MODE -- ON');
  this._setEditMode(EDIT_MODE.COMPONENT);
  this._objectControls.keysTranslateObj(true);
};
Miew.prototype._applyComponentEdit = function () {
  if (this._editMode !== EDIT_MODE.COMPONENT) {
    return;
  }
  this._objectControls.stop();
  this._objectControls.keysTranslateObj(false);
  for (let i = 0; i < this._editors.length; ++i) {
    this._editors[i].apply();
  }
  this._editors = [];
  this.logger.info('COMPONENT EDIT MODE -- OFF (applied)');
  this._setEditMode(EDIT_MODE.COMPLEX);
  this.rebuildAll();
};
Miew.prototype._discardComponentEdit = function () {
  if (this._editMode !== EDIT_MODE.COMPONENT) {
    return;
  }
  this._objectControls.stop();
  this._objectControls.keysTranslateObj(false);
  for (let i = 0; i < this._editors.length; ++i) {
    this._editors[i].discard();
  }
  this._editors = [];
  this.logger.info('COMPONENT EDIT MODE -- OFF (discarded)');
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._needRender = true;
  this.rebuildAll();
};
Miew.prototype._enterFragmentEditMode = function () {
  if (this._editMode !== EDIT_MODE.COMPLEX) {
    return;
  }
  const selectedVisuals = [];
  this._forEachComplexVisual(visual => {
    if (visual instanceof src_ComplexVisual && visual.getSelectionCount() > 0) {
      selectedVisuals.push(visual);
    }
  });
  if (selectedVisuals.length !== 1) {
    // either we have no selection or
    // we have selected atoms in two or more visuals -- not supported
    return;
  }
  const editor = selectedVisuals[0].beginFragmentEdit();
  if (!editor) {
    return;
  }
  this._editors = [editor];
  this.logger.info('FRAGMENT EDIT MODE -- ON (single bond)');
  this._setEditMode(EDIT_MODE.FRAGMENT);
  this._objectControls.allowTranslation(false);
  this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());
  this._needRender = true;
};
Miew.prototype._applyFragmentEdit = function () {
  if (this._editMode !== EDIT_MODE.FRAGMENT) {
    return;
  }
  this._objectControls.stop();
  for (let i = 0; i < this._editors.length; ++i) {
    this._editors[i].apply();
  }
  this._editors = [];
  this.logger.info('FRAGMENT EDIT MODE -- OFF (applied)');
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._objectControls.allowTranslation(true);
  this._objectControls.allowAltObjFreeRotation(true);
  this.rebuildAll();
};
Miew.prototype._discardFragmentEdit = function () {
  if (this._editMode !== EDIT_MODE.FRAGMENT) {
    return;
  }
  this._objectControls.stop();
  for (let i = 0; i < this._editors.length; ++i) {
    this._editors[i].discard();
  }
  this._editors = [];
  this.logger.info('FRAGMENT EDIT MODE -- OFF (discarded)');
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._objectControls.allowTranslation(true);
  this._objectControls.allowAltObjFreeRotation(true);
  this._needRender = true;
};
Miew.prototype._onPick = function (event) {
  if (!settings.now.picking) {
    // picking is disabled
    return;
  }
  if (this._animInterval !== null) {
    // animation playback is on
    return;
  }
  if (this._editMode === EDIT_MODE.FRAGMENT) {
    // prevent picking in fragment edit mode
    return;
  }
  if (this._objectControls.isEditingAltObj()) {
    // prevent picking during component rotation
    return;
  }

  // update last pick & find complex
  let complex = null;
  if (event.obj.atom) {
    complex = event.obj.atom.residue.getChain().getComplex();
    this._lastPick = event.obj.atom;
  } else if (event.obj.residue) {
    complex = event.obj.residue.getChain().getComplex();
    this._lastPick = event.obj.residue;
  } else if (event.obj.chain) {
    complex = event.obj.chain.getComplex();
    this._lastPick = event.obj.chain;
  } else if (event.obj.molecule) {
    complex = event.obj.molecule.complex;
    this._lastPick = event.obj.molecule;
  } else {
    this._lastPick = null;
  }
  function _updateSelection(visual) {
    visual.updateSelectionMask(event.obj);
    visual.rebuildSelectionGeometry();
  }

  // update visual
  if (complex) {
    const visual = this._getVisualForComplex(complex);
    if (visual) {
      _updateSelection(visual);
      this._needRender = true;
    }
  } else {
    this._forEachComplexVisual(_updateSelection);
    this._needRender = true;
  }
  this._updateInfoPanel();
  this.dispatchEvent(event);
};
Miew.prototype._onKeyDown = function (event) {
  if (!this._running || !this._hotKeysEnabled) {
    return;
  }

  // editing keys
  if (settings.now.editing) {
    switch (event.code) {
      case 'KeyC':
        this._enterComponentEditMode();
        break;
      case 'KeyF':
        this._enterFragmentEditMode();
        break;
      case 'KeyA':
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._applyComponentEdit();
            break;
          case EDIT_MODE.FRAGMENT:
            this._applyFragmentEdit();
            break;
          default:
            break;
        }
        break;
      case 'KeyD':
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._discardComponentEdit();
            break;
          case EDIT_MODE.FRAGMENT:
            this._discardFragmentEdit();
            break;
          default:
            break;
        }
        break;
      default:
    }
  }

  // other keys
  switch (event.code) {
    case 'NumpadAdd':
      if (event.altKey) {
        event.preventDefault();
        event.stopPropagation();
        this._forEachComplexVisual(visual => {
          visual.expandSelection();
          visual.rebuildSelectionGeometry();
        });
        this._updateInfoPanel();
        this._needRender = true;
      }
      break;
    case 'NumpadSubtract':
      if (event.altKey) {
        event.preventDefault();
        event.stopPropagation();
        this._forEachComplexVisual(visual => {
          visual.shrinkSelection();
          visual.rebuildSelectionGeometry();
        });
        this._updateInfoPanel();
        this._needRender = true;
      }
      break;
    default:
  }
};
Miew.prototype._onKeyUp = function (event) {
  if (!this._running || !this._hotKeysEnabled) {
    return;
  }
  if (event.code === 'KeyX') {
    this._extractRepresentation();
  }
};
Miew.prototype._updateInfoPanel = function () {
  const info = this._msgAtomInfo.getElementsByTagName('p')[0];
  let atom;
  let residue;
  let count = 0;
  this._forEachComplexVisual(visual => {
    count += visual.getSelectionCount();
  });
  while (info.firstChild) {
    info.removeChild(info.firstChild);
  }
  if (count === 0) {
    this._msgAtomInfo.style.opacity = 0.0;
    return;
  }
  let firstLine = `${String(count)} atom${count !== 1 ? 's' : ''} selected`;
  if (this._lastPick !== null) {
    firstLine += ', the last pick:';
  }
  let secondLine = '';
  let aName = '';
  let coordLine = '';
  if (this._lastPick instanceof Miew_Atom) {
    atom = this._lastPick;
    residue = atom.residue;
    aName = atom.name;
    const location = atom.location !== 32 ? String.fromCharCode(atom.location) : ''; // 32 is code of white-space
    secondLine = `${atom.element.fullName} #${atom.serial}${location}: \
      ${residue._chain._name}.${residue._type._name}${residue._sequence}${residue._icode.trim()}.`;
    secondLine += aName;
    coordLine = `Coord: (${atom.position.x.toFixed(2).toString()},\
     ${atom.position.y.toFixed(2).toString()},\
     ${atom.position.z.toFixed(2).toString()})`;
  } else if (this._lastPick instanceof Miew_Residue) {
    residue = this._lastPick;
    secondLine = `${residue._type._fullName}: \
      ${residue._chain._name}.${residue._type._name}${residue._sequence}${residue._icode.trim()}`;
  } else if (this._lastPick instanceof Miew_Chain) {
    secondLine = `chain ${this._lastPick._name}`;
  } else if (this._lastPick instanceof Miew_Molecule) {
    secondLine = `molecule ${this._lastPick._name}`;
  }
  info.appendChild(document.createTextNode(firstLine));
  if (secondLine !== '') {
    info.appendChild(document.createElement('br'));
    info.appendChild(document.createTextNode(secondLine));
  }
  if (coordLine !== '') {
    info.appendChild(document.createElement('br'));
    info.appendChild(document.createTextNode(coordLine));
  }
  this._msgAtomInfo.style.opacity = 1.0;
};
Miew.prototype._getAltObj = function () {
  if (this._editors) {
    let altObj = null;
    for (let i = 0; i < this._editors.length; ++i) {
      const nextAltObj = this._editors[i].getAltObj();
      if (nextAltObj.objects.length > 0) {
        if (altObj) {
          // we have selected atoms in two or more visuals -- not supported
          altObj = null;
          break;
        }
        altObj = nextAltObj;
      }
    }
    if (altObj) {
      return altObj;
    }
  }
  return {
    objects: [],
    pivot: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
  };
};
Miew.prototype.resetPivot = function () {
  const boundingBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function () {
    boundingBox.makeEmpty();
    this._forEachVisual(visual => {
      boundingBox.union(visual.getBoundaries().boundingBox);
    });
    boundingBox.getCenter(center);
    this._objectControls.setPivot(center.negate());
    this.dispatchEvent({
      type: 'transform'
    });
  };
}();
Miew.prototype.setPivotResidue = function () {
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (residue) {
    const visual = this._getVisualForComplex(residue.getChain().getComplex());
    if (!visual) {
      return;
    }
    if (residue._controlPoint) {
      center.copy(residue._controlPoint);
    } else {
      let x = 0;
      let y = 0;
      let z = 0;
      const amount = residue._atoms.length;
      for (let i = 0; i < amount; ++i) {
        const p = residue._atoms[i].position;
        x += p.x / amount;
        y += p.y / amount;
        z += p.z / amount;
      }
      center.set(x, y, z);
    }
    center.applyMatrix4(visual.matrix).negate();
    this._objectControls.setPivot(center);
    this.dispatchEvent({
      type: 'transform'
    });
  };
}();
Miew.prototype.setPivotAtom = function () {
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function (atom) {
    const visual = this._getVisualForComplex(atom.residue.getChain().getComplex());
    if (!visual) {
      return;
    }
    center.copy(atom.position);
    center.applyMatrix4(visual.matrix).negate();
    this._objectControls.setPivot(center);
    this.dispatchEvent({
      type: 'transform'
    });
  };
}();
Miew.prototype.getSelectionCenter = function () {
  const _centerInVisual = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0);
  return function (center, includesAtom, selector) {
    center.set(0.0, 0.0, 0.0);
    let count = 0;
    this._forEachComplexVisual(visual => {
      if (visual.getSelectionCenter(_centerInVisual, includesAtom, selector || visual.getSelectionBit())) {
        center.add(_centerInVisual);
        count++;
      }
    });
    if (count === 0) {
      return false;
    }
    center.divideScalar(count);
    center.negate();
    return true;
  };
}();
Miew.prototype.setPivotSubset = function () {
  const _center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.0, 0.0, 0.0);
  function _includesInCurSelection(atom, selectionBit) {
    return atom.mask & 1 << selectionBit;
  }
  function _includesInSelector(atom, selector) {
    return selector.selector.includesAtom(atom);
  }
  return function (selector) {
    const includesAtom = selector ? _includesInSelector : _includesInCurSelection;
    if (this.getSelectionCenter(_center, includesAtom, selector)) {
      this._objectControls.setPivot(_center);
      this.dispatchEvent({
        type: 'transform'
      });
    } else {
      this.logger.warn('selection is empty. Center operation not performed');
    }
  };
}();

/**
 * Makes a screenshot.
 * @param {number} [width] - Width of an image. Defaults to the canvas width.
 * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
 *        if width is omitted too.
 * @returns {string} Data URL representing the image contents.
 */
Miew.prototype.screenshot = function (width, height) {
  const gfx = this._gfx;
  const deviceWidth = gfx.renderer.domElement.width;
  const deviceHeight = gfx.renderer.domElement.height;
  function fov2Tan(fov) {
    return Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.degToRad(0.5 * fov));
  }
  function tan2Fov(tan) {
    return external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.radToDeg(Math.atan(tan)) * 2.0;
  }
  function getDataURL() {
    let dataURL;
    const currBrowser = utils.getBrowser();
    if (currBrowser === utils.browserType.SAFARI) {
      const canvas = document.createElement('canvas');
      const canvasContext = canvas.getContext('2d');
      canvas.width = width === undefined ? deviceWidth : width;
      canvas.height = height === undefined ? deviceHeight : height;
      canvasContext.drawImage(gfx.renderer.domElement, 0, 0, canvas.width, canvas.height);
      dataURL = canvas.toDataURL('image/png');
    } else {
      // Copy current canvas to screenshot
      dataURL = gfx.renderer.domElement.toDataURL('image/png');
    }
    return dataURL;
  }
  height = height || width;
  let screenshotURI;
  if (width === undefined && height === undefined || width === deviceWidth && height === deviceHeight) {
    // renderer.domElement.toDataURL('image/png') returns flipped image in Safari
    // It hasn't been resolved yet, but getScreenshotSafari()
    // fixes it using an extra canvas.
    screenshotURI = getDataURL();
  } else {
    const originalAspect = gfx.camera.aspect;
    const originalFov = gfx.camera.fov;
    const originalTanFov2 = fov2Tan(gfx.camera.fov);

    // screenshot should contain the principal area of interest (a centered square touching screen sides)
    const areaOfInterestSize = Math.min(gfx.width, gfx.height);
    const areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height;

    // set appropriate camera aspect & FOV
    const shotAspect = width / height;
    gfx.renderer.setPixelRatio(1);
    gfx.camera.aspect = shotAspect;
    gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1.0));
    gfx.camera.updateProjectionMatrix();

    // resize canvas to the required size of screenshot
    gfx.renderer.setDrawingBufferSize(width, height, 1);

    // make screenshot
    this._renderFrame(settings.now.stereo);
    screenshotURI = getDataURL();

    // restore original camera & canvas proportions
    gfx.renderer.setPixelRatio(window.devicePixelRatio);
    gfx.camera.aspect = originalAspect;
    gfx.camera.fov = originalFov;
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
    this._needRender = true;
  }
  return screenshotURI;
};

/**
 * Makes screenshot and initiates a download.
 * @param {string} [filename] - Name of a file. Default to a 'screenshot-XXXXX.png', where XXXXX is a current
 *        date/time in seconds.
 * @param {number} [width] - Width of an image. Defaults to the canvas width.
 * @param {number} [height] - Height of an image. Defaults to the width (square) or canvas height,
 *        if width is omitted too.
 */
Miew.prototype.screenshotSave = function (filename, width, height) {
  const uri = this.screenshot(width, height);
  utils.shotDownload(uri, filename);
};
Miew.prototype.save = function (opts) {
  this._export(opts.fileType).then(dataString => {
    const filename = this._visuals[this._curVisualName]._complex.name;
    utils.download(dataString, filename, opts.fileType);
    this._refreshTitle();
    this.dispatchEvent({
      type: 'exportingDone'
    });
  }).catch(error => {
    this.logger.error('Could not export data');
    this.logger.debug(error);
    this._refreshTitle();
    this.dispatchEvent({
      type: 'exportingDone',
      error
    });
  });
};
Miew.prototype._tweakResolution = function () {
  const maxPerf = [['poor', 100], ['low', 500], ['medium', 1000], ['high', 5000], ['ultra', Number.MAX_VALUE]];
  let atomCount = 0;
  this._forEachComplexVisual(visual => {
    atomCount += visual.getComplex().getAtomCount();
  });
  if (atomCount > 0) {
    const performance = this._gfxScore * 10e5 / atomCount;
    // set resolution based on estimated performance
    for (let i = 0; i < maxPerf.length; ++i) {
      if (performance < maxPerf[i][1]) {
        this._autoChangeResolution(maxPerf[i][0]);
        break;
      }
    }
  }
};
Miew.prototype._autoChangeResolution = function (resolution) {
  if (resolution !== settings.now.resolution) {
    this.logger.report(`Your rendering resolution was changed to "${resolution}" for best performance.`);
  }
  settings.now.resolution = resolution;
};

/**
 * Save current settings to cookies.
 */
Miew.prototype.saveSettings = function () {
  this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
};

/**
 * Load settings from cookies.
 */
Miew.prototype.restoreSettings = function () {
  try {
    const cookie = this._cookies.getCookie(this._opts.settingsCookie);
    const diffs = cookie ? JSON.parse(cookie) : {};
    this.settings.applyDiffs(diffs, true);
  } catch (e) {
    this.logger.error(`Cookies parse error: ${e.message}`);
  }
};

/**
 * Reset current settings to the defaults.
 */
Miew.prototype.resetSettings = function () {
  this.settings.reset();
};

/*
   * DANGEROUS and TEMPORARY. The method should change or disappear in future versions.
   * @param {string|object} opts - See {@link Miew} constructor.
   * @see {@link Miew#set}, {@link Miew#repAdd}, {@link Miew#rep}.
   */
Miew.prototype.setOptions = function (opts) {
  if (typeof opts === 'string') {
    opts = Miew.options.fromAttr(opts);
  }
  if (opts.reps) {
    this._opts.reps = null;
  }
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(this._opts, opts);
  if (opts.settings) {
    this.set(opts.settings);
  }
  this._opts._objects = opts._objects;
  this._resetObjects();
  if (opts.load) {
    this.load(opts.load, {
      fileType: opts.type
    });
  }
  if (opts.preset) {
    settings.now.preset = opts.preset;
  }
  if (opts.reps) {
    this.resetReps(opts.preset);
  }
  if (this._opts.view) {
    this.view(this._opts.view);
    delete this._opts.view;
  }
  const visual = this._getComplexVisual();
  if (visual) {
    visual.getComplex().resetCurrentUnit();
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(opts.unit)) {
      visual.getComplex().setCurrentUnit(opts.unit);
    }
    this.resetView();
    this.rebuildAll();
  }
};
Miew.prototype.info = function (name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    return {};
  }
  const complex = visual.getComplex();
  const {
    metadata
  } = complex;
  return {
    id: metadata.id || complex.name || 'UNKNOWN',
    title: metadata.title && metadata.title.join(' ') || 'UNKNOWN DATA',
    atoms: complex.getAtomCount(),
    bonds: complex.getBondCount(),
    residues: complex.getResidueCount(),
    chains: complex.getChainCount()
  };
};

/*
   * OBJECTS SEGMENT
   */

Miew.prototype.addObject = function (objData, bThrow) {
  let Ctor = null;
  if (objData.type === objects_LinesObj.prototype.type) {
    Ctor = objects_LinesObj;
  }
  if (Ctor === null) {
    throw new Error(`Unknown scene object type - ${objData.type}`);
  }
  try {
    const newObj = new Ctor(objData.params, objData.opts);
    this._addSceneObject(newObj);
  } catch (error) {
    if (!bThrow) {
      this.logger.debug(`Error during scene object creation: ${error.message}`);
    } else {
      throw error;
    }
  }
  this._needRender = true;
};
Miew.prototype._addSceneObject = function (sceneObject) {
  const visual = this._getComplexVisual();
  if (sceneObject.build && visual) {
    sceneObject.build(visual.getComplex());
    this._gfx.pivot.add(sceneObject.getGeometry());
  }
  const objects = this._objects;
  objects[objects.length] = sceneObject;
};
Miew.prototype._updateObjsToFrame = function (frameData) {
  const objs = this._objects;
  for (let i = 0, n = objs.length; i < n; ++i) {
    if (objs[i].updateToFrame) {
      objs[i].updateToFrame(frameData);
    }
  }
};
Miew.prototype._resetObjects = function () {
  const objs = this._opts._objects;
  this._objects = [];
  if (objs) {
    for (let i = 0, n = objs.length; i < n; ++i) {
      this.addObject(objs[i], false);
    }
  }
};
Miew.prototype.removeObject = function (index) {
  const obj = this._objects[index];
  if (!obj) {
    throw new Error(`Scene object with index ${index} does not exist`);
  }
  obj.destroy();
  this._objects.splice(index, 1);
  this._needRender = true;
};

/**
 * Get a string with a URL to reproduce the current scene.
 *
 * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
 * preset information regardless of the differences with settings
 * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
 * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
 * @returns {string} URL
 */
Miew.prototype.getURL = function (opts) {
  return options.toURL(this.getState(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
    compact: true,
    settings: false,
    view: false
  })));
};

/**
 * Get a string with a script to reproduce the current scene.
 *
 * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
 * preset information regardless of the differences with settings
 * @param {boolean} [opts.settings=true] - when this flag is true, changes in settings are included
 * @param {boolean} [opts.view=true] - when this flag is true, a view information is included
 * @returns {string} script
 */
Miew.prototype.getScript = function (opts) {
  return options.toScript(this.getState(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
    compact: true,
    settings: true,
    view: true
  })));
};

/*
   * Generates object that represents the current state of representations list
   * @param {boolean} compareWithDefaults - when this flag is true, reps list is compared (if possible)
   * to preset's defaults and only diffs are generated
   */
Miew.prototype._compareReps = function (complexVisual, compareWithDefaults) {
  const ans = {};
  let repCount = 0;
  if (complexVisual) {
    repCount = complexVisual.repCount();
  }
  const currPreset = settings.defaults.presets[settings.now.preset];
  let compare = compareWithDefaults;
  if (currPreset === undefined || currPreset.length > repCount) {
    compare = false;
    ans.preset = 'empty';
  } else if (settings.now.preset !== settings.defaults.preset) {
    ans.preset = settings.now.preset;
  }
  const repsDiff = [];
  let emptyReps = true;
  for (let i = 0, n = repCount; i < n; ++i) {
    repsDiff[i] = complexVisual.repGet(i).compare(compare ? currPreset[i] : null);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(repsDiff[i])) {
      emptyReps = false;
    }
  }
  if (!emptyReps) {
    ans.reps = repsDiff;
  }
  return ans;
};

/*
   * Obtain object that represents current state of miew (might be used as options in constructor).
   * @param {boolean} [opts.compact=true] - set this flag to false if you want to include full
   * preset information regardless of the differences with settings
   * @param {boolean} [opts.settings=false] - when this flag is true, changes in settings are included
   * @param {boolean} [opts.view=false] - when this flag is true, a view information is included
   * @returns {Object} State object.
   */
Miew.prototype.getState = function (opts) {
  const state = {};
  opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
    compact: true,
    settings: false,
    view: false
  });

  // load
  const visual = this._getComplexVisual();
  if (visual !== null) {
    const complex = visual.getComplex();
    const {
      metadata
    } = complex;
    if (metadata.id) {
      const format = metadata.format ? `${metadata.format}:` : '';
      state.load = format + metadata.id;
    }
    const unit = complex.getCurrentUnit();
    if (unit !== 1) {
      state.unit = unit;
    }
  }

  // representations
  const repsInfo = this._compareReps(visual, opts.compact);
  if (repsInfo.preset) {
    state.preset = repsInfo.preset;
  }
  if (repsInfo.reps) {
    state.reps = repsInfo.reps;
  }

  // objects
  const objects = this._objects;
  const objectsState = [];
  for (let i = 0, n = objects.length; i < n; ++i) {
    objectsState[i] = objects[i].identify();
  }
  if (objects.length > 0) {
    state._objects = objectsState;
  }

  // view
  if (opts.view) {
    state.view = this.view();
  }

  // settings
  if (opts.settings) {
    const diff = this.settings.getDiffs(false);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      state.settings = diff;
    }
  }
  return state;
};

/**
 * Get parameter value.
 * @param {string} param - Parameter name or path (e.g. 'modes.BS.atom').
 * @param {*=} value - Default value.
 * @returns {*} Parameter value.
 */
Miew.prototype.get = function (param, value) {
  return settings.get(param, value);
};
Miew.prototype._clipPlaneUpdateValue = function (radius) {
  const clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings.now.draft.clipPlaneFactor, settings.now.camNear);
  const opts = {
    clipPlaneValue
  };
  this._forEachComplexVisual(visual => {
    visual.setUberOptions(opts);
  });
  for (let i = 0, n = this._objects.length; i < n; ++i) {
    const obj = this._objects[i];
    if (obj._line) {
      obj._line.material.setUberOptions(opts);
    }
  }
  if (this._picker !== null) {
    this._picker.clipPlaneValue = clipPlaneValue;
  }
};
Miew.prototype._fogFarUpdateValue = function () {
  if (this._picker !== null) {
    if (this._gfx.scene.fog) {
      this._picker.fogFarValue = this._gfx.scene.fog.far;
    } else {
      this._picker.fogFarValue = undefined;
    }
  }
};
Miew.prototype._updateShadowmapMeshes = function (process) {
  this._forEachComplexVisual(visual => {
    const reprList = visual._reprList;
    for (let i = 0, n = reprList.length; i < n; ++i) {
      const repr = reprList[i];
      process(repr.geo, repr.material);
    }
  });
};
Miew.prototype._updateMaterials = function (values) {
  let needTraverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  this._forEachComplexVisual(visual => visual.setMaterialValues(values, needTraverse, process));
  for (let i = 0, n = this._objects.length; i < n; ++i) {
    const obj = this._objects[i];
    if (obj._line) {
      obj._line.material.setValues(values);
      obj._line.material.needsUpdate = true;
    }
  }
};
Miew.prototype._fogAlphaChanged = function () {
  this._forEachComplexVisual(visual => {
    visual.setUberOptions({
      fogAlpha: settings.now.fogAlpha
    });
  });
};
Miew.prototype._embedWebXR = function () {
  // switch off
  if (settings.now.stereo !== 'WEBVR') {
    if (this.webVR) {
      this.webVR.disable();
    }
    this.webVR = null;
    return;
  }
  // switch on
  if (!this.webVR) {
    this.webVR = new WebVRPoC(() => {
      this._requestAnimationFrame(() => this._onTick());
      this._needRender = true;
      this._onResize();
    });
  }
  this.webVR.enable(this._gfx);
};
Miew.prototype._initOnSettingsChanged = function () {
  const on = (props, func) => {
    props = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(props) ? props : [props];
    props.forEach(prop => {
      this.settings.addEventListener(`change:${prop}`, func);
    });
  };
  on('modes.VD.frame', () => {
    const volume = this._getVolumeVisual();
    if (volume === null) return;
    volume.showFrame(settings.now.modes.VD.frame);
    this._needRender = true;
  });
  on('modes.VD.isoMode', () => {
    const volume = this._getVolumeVisual();
    if (volume === null) return;
    volume.getMesh().material.updateDefines();
    this._needRender = true;
  });
  on('bg.color', () => {
    this._onBgColorChanged();
  });
  on('ao', () => {
    if (settings.now.ao && !isAOSupported(this._gfx.renderer.getContext())) {
      this.logger.warn('Your device or browser does not support ao');
      settings.set('ao', false);
    } else {
      const values = {
        normalsToGBuffer: settings.now.ao
      };
      this._setUberMaterialValues(values);
    }
  });
  on('zSprites', () => {
    if (settings.now.zSprites && !arezSpritesSupported(this._gfx.renderer.getContext())) {
      this.logger.warn('Your device or browser does not support zSprites');
      settings.set('zSprites', false);
    }
    this.rebuildAll();
  });
  on('fogColor', () => {
    this._onFogColorChanged();
  });
  on('fogColorEnable', () => {
    this._onFogColorChanged();
  });
  on('bg.transparent', evt => {
    const gfx = this._gfx;
    if (gfx) {
      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    }
    // update materials
    this._updateMaterials({
      fogTransparent: evt.value
    });
    this.rebuildAll();
  });
  on('draft.clipPlane', evt => {
    // update materials
    this._updateMaterials({
      clipPlane: evt.value
    });
    this.rebuildAll();
  });
  on('shadow.on', evt => {
    // update materials
    const values = {
      shadowmap: evt.value,
      shadowmapType: settings.now.shadow.type
    };
    const gfx = this._gfx;
    if (gfx) {
      gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap);
    }
    this._updateMaterials(values, true);
    if (values.shadowmap) {
      this._updateShadowCamera();
      this._updateShadowmapMeshes(meshutils.createShadowmapMaterial);
    } else {
      this._updateShadowmapMeshes(meshutils.removeShadowmapMaterial);
    }
    this._needRender = true;
  });
  on('shadow.type', evt => {
    // update materials if shadowmap is enable
    if (settings.now.shadow.on) {
      this._updateMaterials({
        shadowmapType: evt.value
      }, true);
      this._needRender = true;
    }
  });
  on('shadow.radius', evt => {
    for (let i = 0; i < this._gfx.scene.children.length; i++) {
      if (this._gfx.scene.children[i].shadow !== undefined) {
        const light = this._gfx.scene.children[i];
        light.shadow.radius = evt.value;
        this._needRender = true;
      }
    }
  });
  on('fps', () => {
    this._fps.show(settings.now.fps);
  });
  on(['fog', 'fogNearFactor', 'fogFarFactor'], () => {
    this._updateFog();
    this._needRender = true;
  });
  on('fogAlpha', () => {
    const {
      fogAlpha
    } = settings.now;
    if (fogAlpha < 0 || fogAlpha > 1) {
      this.logger.warn('fogAlpha must belong range [0,1]');
    }
    this._fogAlphaChanged();
    this._needRender = true;
  });
  on('autoResolution', evt => {
    if (evt.value && !this._gfxScore) {
      this.logger.warn('Benchmarks are missed, autoresolution will not work! ' + 'Autoresolution should be set during miew startup.');
    }
  });
  on('stereo', () => {
    this._embedWebXR(settings.now.stereo === 'WEBVR');
    this._needRender = true;
  });
  on(['transparency', 'palette'], () => {
    this.rebuildAll();
  });
  on('resolution', () => {
    // update complex visuals
    this.rebuildAll();

    // update volume visual
    const volume = this._getVolumeVisual();
    if (volume) {
      volume.getMesh().material.updateDefines();
      this._needRender = true;
    }
  });
  on(['axes', 'fxaa', 'ao', 'outline.on', 'outline.color', 'outline.threshold', 'outline.thickness'], () => {
    this._needRender = true;
  });
};

/**
 * Set parameter value.
 * @param {string|object} params - Parameter name or path (e.g. 'modes.BS.atom') or even settings object.
 * @param {*=} value - Value.
 */
Miew.prototype.set = function (params, value) {
  settings.set(params, value);
};

/**
 * Select atoms with selection string.
 * @param {string} expression - string expression of selection
 * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
 */
Miew.prototype.select = function (expression, append) {
  const visual = this._getComplexVisual();
  if (!visual) {
    return;
  }
  let sel = expression;
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(expression)) {
    sel = Miew_selectors.parse(expression).selector;
  }
  visual.select(sel, append);
  this._lastPick = null;
  this._updateInfoPanel();
  this._needRender = true;
};
const VIEW_VERSION = '1';

/**
 * Get or set view info packed into string.
 *
 * **Note:** view is stored for *left-handed* cs, euler angles are stored in radians and *ZXY-order*,
 *
 * @param {string=} expression - Optional string encoded the view
 */
Miew.prototype.view = function (expression) {
  const self = this;
  const {
    pivot
  } = this._gfx;
  let transform = [];
  const eulerOrder = 'ZXY';
  function encode() {
    const pos = pivot.position;
    const scale = self._objectControls.getScale() / settings.now.radiusToFit;
    const euler = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Euler();
    euler.setFromQuaternion(self._objectControls.getOrientation(), eulerOrder);
    transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
    return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
  }
  function decode() {
    // backwards compatible: old non-versioned view is the 0th version
    if (expression.length === 40) {
      expression = `0${expression}`;
    }
    const version = expression[0];
    transform = utils.arrayFromBase64(expression.substr(1), Float32Array);

    // apply adapter for old versions
    if (version !== VIEW_VERSION) {
      if (version === '0') {
        // cancel radiusToFit included in old views
        transform[3] /= 8.0;
      } else {
        // do nothing
        self.logger.warn(`Encoded view version mismatch, stored as ${version} vs ${VIEW_VERSION} expected`);
        return;
      }
    }
    const interpolator = self._interpolator;
    const srcView = interpolator.createView();
    srcView.position.copy(pivot.position);
    srcView.scale = self._objectControls.getScale();
    srcView.orientation.copy(self._objectControls.getOrientation());
    const dstView = interpolator.createView();
    dstView.position.set(transform[0], transform[1], transform[2]);

    // hack to make preset views work after we moved centering offset to visual nodes
    // FIXME should only store main pivot offset in preset
    if (self._getComplexVisual()) {
      dstView.position.sub(self._getComplexVisual().position);
    }
    dstView.scale = transform[3]; // eslint-disable-line prefer-destructuring
    dstView.orientation.setFromEuler(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Euler(transform[4], transform[5], transform[6], eulerOrder));
    interpolator.setup(srcView, dstView);
  }
  if (typeof expression === 'undefined') {
    return encode();
  }
  decode();
  return expression;
};

/*
   * Update current view due to viewinterpolator state
   */
Miew.prototype._updateView = function () {
  const self = this;
  const {
    pivot
  } = this._gfx;
  const interpolator = this._interpolator;
  if (!interpolator.wasStarted()) {
    interpolator.start();
  }
  if (!interpolator.isMoving()) {
    return;
  }
  const res = interpolator.getCurrentView();
  if (res.success) {
    const curr = res.view;
    pivot.position.copy(curr.position);
    self._objectControls.setScale(curr.scale * settings.now.radiusToFit);
    self._objectControls.setOrientation(curr.orientation);
    this.dispatchEvent({
      type: 'transform'
    });
    self._needRender = true;
  }
};

/**
 * Translate object by vector
 * @param {number} x - translation value (Ang) along model's X axis
 * @param {number} y - translation value (Ang) along model's Y axis
 * @param {number} z - translation value (Ang) along model's Z axis
 */
Miew.prototype.translate = function (x, y, z) {
  this._objectControls.translatePivot(x, y, z);
  this.dispatchEvent({
    type: 'transform'
  });
  this._needRender = true;
};

/**
 * Rotate object by Euler angles
 * @param {number} x - rotation angle around X axis in radians
 * @param {number} y - rotation angle around Y axis in radians
 * @param {number} z - rotation angle around Z axis in radians
 */
Miew.prototype.rotate = function (x, y, z) {
  this._objectControls.rotate(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion().setFromEuler(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Euler(x, y, z, 'XYZ')));
  this.dispatchEvent({
    type: 'transform'
  });
  this._needRender = true;
};

/**
 * Scale object by factor
 * @param {number} factor - scale multiplier, should greater than zero
 */
Miew.prototype.scale = function (factor) {
  if (factor <= 0) {
    throw new RangeError('Scale should be greater than zero');
  }
  this._objectControls.scale(factor);
  this.dispatchEvent({
    type: 'transform'
  });
  this._needRender = true;
};

/**
 * Center view on selection
 * @param {empty | subset | string} selector - defines part of molecule which must be centered (
 * empty - center on current selection;
 * subset - center on picked atom/residue/molecule;
 * string - center on atoms correspond to selection string)
 */
Miew.prototype.center = function (selector) {
  // no arguments - center on current selection;
  if (selector === undefined) {
    this.setPivotSubset();
    this._needRender = true;
    return;
  }
  // subset with atom or residue - center on picked atom/residue;
  if (selector.obj !== undefined && ('atom' in selector.obj || 'residue' in selector.obj)) {
    // from event with selection
    if ('atom' in selector.obj) {
      this.setPivotAtom(selector.obj.atom);
    } else {
      this.setPivotResidue(selector.obj.residue);
    }
    this._needRender = true;
    return;
  }
  // string - center on atoms correspond to selection string
  if (selector.obj === undefined && selector !== '') {
    const sel = Miew_selectors.parse(selector);
    if (sel.error === undefined) {
      this.setPivotSubset(sel);
      this._needRender = true;
      return;
    }
  }
  // empty subset or incorrect/empty string - center on all molecule;
  this.resetPivot();
  this._needRender = true;
};

/**
 * Build selector that contains all atoms within given distance from group of atoms
 * @param {Selector} selector - selector describing source group of atoms
 * @param {number} radius - distance
 * @returns {Selector} selector describing result group of atoms
 */
Miew.prototype.within = function (selector, radius) {
  const visual = this._getComplexVisual();
  if (!visual) {
    return Miew_selectors.None();
  }
  if (selector instanceof String) {
    selector = Miew_selectors.parse(selector);
  }
  const res = visual.within(selector, radius);
  if (res) {
    visual.rebuildSelectionGeometry();
    this._needRender = true;
  }
  return res;
};

/**
 * Get atom position in 2D canvas coords
 * @param {string} fullAtomName - full atom name, like A.38.CG
 * @returns {Object} {x, y} or false if atom not found
 */
Miew.prototype.projected = function (fullAtomName, complexName) {
  const visual = this._getComplexVisual(complexName);
  if (!visual) {
    return false;
  }
  const atom = visual.getComplex().getAtomByFullname(fullAtomName);
  if (atom === null) {
    return false;
  }
  const pos = atom.position.clone();
  // we consider atom position to be affected only by common complex transform
  // ignoring any transformations that may add during editing
  this._gfx.pivot.updateMatrixWorldRecursive();
  this._gfx.camera.updateMatrixWorldRecursive();
  this._gfx.pivot.localToWorld(pos);
  pos.project(this._gfx.camera);
  return {
    x: (pos.x + 1.0) * 0.5 * this._gfx.width,
    y: (1.0 - pos.y) * 0.5 * this._gfx.height
  };
};

/**
 * Replace secondary structure with calculated one.
 *
 * DSSP algorithm implementation is used.
 *
 * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
 * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
 *
 * @param {string=} complexName - complex name
 */
Miew.prototype.dssp = function (complexName) {
  const visual = this._getComplexVisual(complexName);
  if (!visual) {
    return;
  }
  visual.getComplex().dssp();

  // rebuild dependent representations (cartoon or ss-colored)
  visual._reprList.forEach(rep => {
    if (rep.mode.id === 'CA' || rep.colorer.id === 'SS') {
      rep.needsRebuild = true;
    }
  });
};
Miew.prototype.exportCML = function () {
  const self = this;
  function extractRotation(m) {
    const xAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const yAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const zAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    m.extractBasis(xAxis, yAxis, zAxis);
    xAxis.normalize();
    yAxis.normalize();
    zAxis.normalize();
    const retMat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    retMat.identity();
    retMat.makeBasis(xAxis, yAxis, zAxis);
    return retMat;
  }
  function updateCMLData(complex) {
    const {
      root
    } = self._gfx;
    const mat = extractRotation(root.matrixWorld);
    const v4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0, 0, 0);
    const vCenter = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0, 0, 0);
    let xml = null;
    let ap = null;

    // update atoms in cml
    complex.forEachAtom(atom => {
      if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
        xml = atom.xmlNodeRef.xmlNode;
        ap = atom.position;
        v4.set(ap.x, ap.y, ap.z, 1.0);
        v4.applyMatrix4(mat);
        xml.setAttribute('x3', v4.x.toString());
        xml.setAttribute('y3', v4.y.toString());
        xml.setAttribute('z3', v4.z.toString());
        xml.removeAttribute('x2');
        xml.removeAttribute('y2');
      }
    });
    // update stereo groups in cml
    complex.forEachSGroup(sGroup => {
      if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
        xml = sGroup.xmlNodeRef.xmlNode;
        ap = sGroup.getPosition();
        v4.set(ap.x, ap.y, ap.z, 1.0);
        const cp = sGroup.getCentralPoint();
        if (cp === null) {
          v4.applyMatrix4(mat);
        } else {
          vCenter.set(cp.x, cp.y, cp.z, 0.0);
          v4.add(vCenter);
          v4.applyMatrix4(mat); // pos in global space
          vCenter.set(cp.x, cp.y, cp.z, 1.0);
          vCenter.applyMatrix4(mat);
          v4.sub(vCenter);
        }
        xml.setAttribute('x', v4.x.toString());
        xml.setAttribute('y', v4.y.toString());
        xml.setAttribute('z', v4.z.toString());
      }
    });
  }
  const visual = self._getComplexVisual();
  const complex = visual ? visual.getComplex() : null;
  if (complex && complex.originalCML) {
    updateCMLData(complex);

    // serialize xml structure to string
    const oSerializer = new XMLSerializer();
    return oSerializer.serializeToString(complex.originalCML);
  }
  return null;
};

/**
 * Reproduce the RCSB PDB Molecule of the Month style by David S. Goodsell
 *
 * @see http://pdb101.rcsb.org/motm/motm-about
 */
Miew.prototype.motm = function () {
  settings.set({
    fogColorEnable: true,
    fogColor: 0x000000,
    outline: {
      on: true,
      threshold: 0.01
    },
    bg: {
      color: 0xffffff
    }
  });
  this._forEachComplexVisual(visual => {
    const rep = [];
    const complex = visual.getComplex();
    const palette = gfx_palettes.get(settings.now.palette);
    for (let i = 0; i < complex.getChainCount(); i++) {
      const curChainName = complex._chains[i]._name;
      const curChainColor = palette.getChainColor(curChainName);
      rep[i] = {
        selector: `chain ${curChainName}`,
        mode: 'VW',
        colorer: ['CB', {
          color: curChainColor,
          factor: 0.9
        }],
        material: 'FL'
      };
    }
    visual.resetReps(rep);
  });
};
Miew.prototype.VERSION =  true && "0.11.0" || 0;

// Uncomment this to get debug trace:
// Miew.prototype.debugTracer = new utils.DebugTracer(Miew.prototype);

external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(Miew, /** @lends Miew */{
  VERSION: Miew.prototype.VERSION,
  registeredPlugins: [],
  // export namespaces // TODO: WIP: refactoring external interface
  chem: chem,
  io: io,
  modes: gfx_modes,
  colorers: gfx_colorers,
  materials: gfx_materials,
  palettes: gfx_palettes,
  options: options,
  settings: settings,
  utils: utils,
  gfx: {
    Representation: gfx_Representation
  },
  /**
   * Third-party libraries packaged together with Miew.
   *
   * @property {object} lodash - [Lodash](https://lodash.com/), a modern JavaScript utility library delivering
   *   modularity, performance & extras.
   * @property {object} three - [three.js](https://threejs.org/), JavaScript 3D library.
   *
   * @example
   * var _ = Miew.thirdParty.lodash;
   * var opts = _.merge({ ... }, Miew.options.fromURL(window.location.search));
   * var miew = new Miew(opts);
   */
  thirdParty: {
    lodash: external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"],
    three: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject
  }
});
/* harmony default export */ const src_Miew = (Miew);
// EXTERNAL MODULE: ./src/utils/MiewCLIParser.js
var MiewCLIParser = __webpack_require__(89);
;// CONCATENATED MODULE: ./src/utils/MiewCLIHelp.js


const modeIdDesc = {
  $help: ['Rendering mode shortcut', '    BS - balls and sticks mode', '    LN - lines mode', '    LC - licorice mode', '    VW - van der waals mode', '    TR - trace mode', '    TU - tube mode', '    CA - cartoon mode', '    SA - isosurface mode', '    QS - quick surface mode', '    SE - solvent excluded mode', '    TX - text mode'],
  BS: {
    $help: ['   Balls and sticks', '      aromrad = <number> #aromatic radius', '      atom = <number>    #atom radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
  },
  CA: {
    $help: ['   Cartoon', '      arrow = <number>   #arrow size', '      depth = <number>   #depth of surface', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> #', '      width = <number>  #secondary width\n']
  },
  LN: {
    $help: ['   Lines', '      atom = <number>    #atom radius', '      chunkarom = <number>', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      offsarom = <number>\n']
  },
  LC: {
    $help: ['   Licorice', '      aromrad = <number> #aromatic radius', '      bond = <number>    #bond radius', '      multibond = <bool> #use multibond', '      showarom = <bool>  #show aromatic', '      space = <number>   #space value\n']
  },
  VW: {
    $help: ['   Van der Waals', '      nothing\n']
  },
  TR: {
    $help: ['   Trace', '      radius = <number>  #tube radius\n']
  },
  TU: {
    $help: ['   Tube', '      heightSegmentsRatio = <number>', '      radius = <number>  #tube radius', '      tension = <number> \n']
  },
  SA: {
    $help: ['   Surface', '      zClip = <bool> #clip z plane\n']
  },
  QS: {
    $help: ['   Quick surface', '      isoValue = <number>', '      scale = <number>', '      wireframe = <bool>', '      zClip = <bool> #clip z plane\n']
  },
  SE: {
    $help: ['   Solvent excluded surface', '      zClip = <bool> #clip z plane\n']
  },
  TX: {
    $help: ['   Text mode', '      template = <format string> string that can include "{{ id }}"', '          it will be replaced by value, id can be one of next:', '          serial, name, type, sequence, residue, chain, hetatm, water\n', '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', '      dx = <number> #offset along x', '      dy = <number> #offset along y', '      dz = <number> #offset along z', '      fg = <string> #text color modificator', '           could be keyword, named color or hex', '      fg = <string> #back color modificator', '           could be keyword, named color or hex', '      showBg = <bool> #if set show background', '           plate under text']
  }
};
const colorDesc = {
  $help: ['Coloring mode shortcut', '    EL - color by element', '    CH - color by chain', '    SQ - color by sequence', '    RT - color by residue type', '    SS - color by secondary structure', '    UN - uniform'],
  UN: {
    $help: ['Parameters of coloring modes customization', '   Uniform', '      color = <number|color> #RGB->HEX->dec\n'],
    color: {
      $help: Object.keys(gfx_palettes.get(settings.now.palette).namedColors).sort().join('\n')
    }
  }
};
const materialDesc = {
  $help: ['Material shortcut', '    DF - diffuse', '    TR - transparent', '    SF - soft plastic', '    PL - glossy plastic', '    ME - metal', '    GL - glass']
};
const addRepDesc = {
  $help: ['Short (packed) representation description as a set of variables', '    s=<EXPRESSION>', '        selector property', '    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]', '        render mode property', '    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]', '        color mode property', '    mt=<MATERIAL_ID>', '        material property'],
  s: {
    $help: 'Selection expression string as it is in menu->representations->selection'
  },
  m: modeIdDesc,
  c: colorDesc,
  mt: materialDesc
};
const setGetParameterDesc = {
  $help: ['Parameters of rendering modes customization: modes', 'Parameters of colorer customization: colorers', 'Autobuild: autobuild = (<number>|<bool>)'],
  modes: modeIdDesc,
  colorers: colorDesc
};
const help = {
  $help: ['help (<cmd name>| <path to property>)', 'You can get detailed information about command options', '   using "help cmd.opt.opt.[...]"\n', '   you can use one line comments', '   everything started from (#|//) will be skipped', '   Example: >build //some comment\n', 'List of available commands:'],
  reset: {
    $help: ['Reload current object, delete all representations', '    Nothing will work until load new object']
  },
  load: {
    $help: ['load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])', '    Load new pdb object from selected source'],
    PDBID: {
      $help: 'pdb id in remote molecule database'
    },
    URL: {
      $help: 'url to source file'
    },
    f: {
      $help: ['open file system dialog to fetch local file', 'optionally you can determine trajectory file', 'via URL for *.top model']
    }
  },
  clear: {
    $help: 'No args. Clear terminal'
  },
  add: {
    $help: ['add [<REP_NAME>] [<DESCRIPTION>]', '    Add new item to representation set with', '    default or <DESCRIPTION> params'],
    REP_NAME: {
      $help: 'Identifier string [_,a-z,A-Z,0-9] can not start from digit'
    },
    DESCRIPTION: addRepDesc
  },
  rep: {
    $help: ['rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]', '    set current representation by name or index', '    edit current representation by <DESCRIPTION>'],
    REP_NAME: {
      $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
    },
    REP_INDEX: {
      $help: 'Index of available representation'
    },
    DESCRIPTION: addRepDesc
  },
  remove: {
    $help: ['remove (<REP_NAME>|<REP_INDEX>)', 'Remove representation by name or index'],
    REP_NAME: {
      $help: ['Identifier string [_,a-z,A-Z,0-9] can not start from digit', 'Must be declared before']
    },
    REP_INDEX: {
      $help: 'Index of available representation'
    }
  },
  selector: {
    $help: ['selector <EXPRESSION>', '   set selector from EXPRESSION to current representation'],
    EXPRESSION: {
      $help: 'Selection expression string as it is in menu->representations->selection'
    }
  },
  mode: {
    $help: ['mode <MODE_ID> [<PARAMETER>=<VALUE>...]', '   set rendering mode and apply parameters to current representation'],
    MODE_ID: modeIdDesc
  },
  color: {
    $help: ['color <COLORER_ID> [<PARAMETER>=<VALUE>...]', '   set colorer and apply parameters to current representation'],
    COLORER_ID: colorDesc
  },
  material: {
    $help: ['material <MATERIAL_ID>', '   set material to current representation'],
    MATERIAL_ID: materialDesc
  },
  build: {
    $help: 'build help str',
    add: {
      $help: 'build.add',
      new: {
        $help: ['add.new', 'add.new new line 1', 'add.new new line 2', 'add.new new line 3']
      }
    },
    del: {
      $help: 'build.del'
    }
  },
  list: {
    $help: ['list [-e|-s|<REP_NAME>|<REP_INDEX>]', 'Print representations if no args print list of representations', '    -e expand list and show all representations', '    -s show all user-registered selectors', '    <REP_NAME>|<REP_INDEX> show only current representation']
  },
  hide: {
    $help: ['hide (<REP_NAME>|<REP_INDEX>)', 'Hide representation referenced in args']
  },
  show: {
    $help: ['show (<REP_NAME>|<REP_INDEX>)', 'Show representation referenced in args']
  },
  get: {
    $help: ['get <PARAMETER>', 'Print <PARAMETER> value', '    <PARAMETER> - path to option use get.PARAMETER to get more info'],
    PARAMETER: setGetParameterDesc
  },
  set: {
    $help: ['set <PARAMETER> <VALUE>', 'Set <PARAMETER> with <VALUE>', '    <PARAMETER> - path to option use set.PARAMETER to get more info'],
    PARAMETER: setGetParameterDesc
  },
  set_save: {
    $help: ['set_save', 'Save current settings to cookie']
  },
  set_restore: {
    $help: ['set_restore', 'Load and apply settings from cookie']
  },
  set_reset: {
    $help: ['set_reset', 'Reset current settings to the defaults']
  },
  preset: {
    $help: ['preset [<PRESET>]', 'Reset current representation or set preset to <PRESET>'],
    PRESET: {
      $help: ['default', 'wire', 'small', 'macro']
    }
  },
  unit: {
    $help: ['unit [<unit_id>]', 'Change current biological structure view. Zero <unit_id> value means asymmetric unit,', 'positive values set an assembly with corresponding number.', 'Being called with no parameters command prints current unit information.']
  },
  view: {
    $help: ['view [<ENCODED_VIEW>]', 'Get current encoded view or set if ENCODED_VIEW placed as argument'],
    ENCODED_VIEW: {
      $help: ['encoded view matrix string (binary code)']
    }
  },
  rotate: {
    $help: ['rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...', 'Rotate scene']
  },
  scale: {
    $help: ['scale <SCALE>', 'Scale scene']
  },
  select: {
    $help: ['select <SELECTOR_STRING> [as <SELECTOR_NAME>]', 'Select atoms using selector defined in SELECTOR_STRING', '    and if SELECTOR_NAME is defined register it in viewer', '    you can use it later as a complex selector']
  },
  within: {
    $help: ['within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>', 'Build within named selector', '    DISTANCE        <number>', '    SELECTOR_STRING <string(selection language)>', '    SELECTOR_NAME   <identifier>']
  },
  url: {
    $help: ['url [-s] [-v]', 'Report URL encoded scene', '    if -s set that include settings in the URL', '    if -v set that include view in the URL']
  },
  screenshot: {
    $help: ['screenshot [<WIDTH> [<HEIGHT>]]', 'Make a screenshot of the scene', '    WIDTH  <number> in pixels', '    HEIGHT <number> in pixels, equal to WIDTH by default']
  },
  line: {
    $help: ['line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]', 'Draw dashed line between two specified atoms']
  },
  removeobj: {
    $help: ['removeobj <id>', 'Remove scene object by its index. Indices could be obtained by <listobj> command']
  },
  listobj: {
    $help: ['listobj', 'Display the list of all existing scene objects']
  }
};
/* harmony default export */ const MiewCLIHelp = (help);
;// CONCATENATED MODULE: ./src/Miew-cli.js






const {
  chem: {
    selectors: Miew_cli_selectors
  },
  modes: Miew_cli_modes,
  colorers: Miew_cli_colorers,
  materials: Miew_cli_materials,
  palettes: Miew_cli_palettes,
  options: Miew_cli_options,
  settings: Miew_cli_settings
} = src_Miew;
function None() {}
const NULL = function () {
  const obj = new None();
  return function () {
    return obj;
  };
}();
class RepresentationMap {
  constructor() {
    this.representationMap = {};
    this.representationID = {};
  }
  get(strId) {
    return this.representationMap[strId] || this.representationID[strId] || '<no name>';
  }
  add(strId, index) {
    if (strId === -1) {
      return 'Can not create representation: there is no data';
    }
    if (index !== undefined) {
      if (!this.representationMap.hasOwnProperty(strId)) {
        this.representationMap[strId.toString()] = index;
        this.representationID[index] = strId.toString();
      } else {
        return 'This name has already existed, registered without name';
      }
    }
    return `Representation ${strId} successfully added`;
  }
  remove(index) {
    if (index && this.representationID.hasOwnProperty(index)) {
      delete this.representationMap[this.representationID[index]];
      delete this.representationID[index];
    }
    const sortedKeys = Object.keys(this.representationID).sort();
    for (const i in sortedKeys) {
      if (sortedKeys.hasOwnProperty(i)) {
        const id = sortedKeys[i];
        if (id > index) {
          this.representationID[id - 1] = this.representationID[id];
          this.representationMap[this.representationID[id]] -= 1;
          delete this.representationID[id];
        }
      }
    }
  }
  clear() {
    this.representationMap = {};
    this.representationID = {};
  }
}
const representationsStorage = new RepresentationMap();
function keyRemap(key) {
  const keys = {
    s: 'selector',
    m: 'mode',
    c: 'colorer',
    mt: 'material',
    mode: 'modes',
    color: 'colorers',
    colorer: 'colorers',
    select: 'selector',
    material: 'materials',
    selector: 'selector'
  };
  const ans = keys[key];
  return ans === undefined ? key : ans;
}
class CLIUtils {
  list(miew, repMap, key) {
    let ret = '';
    if (miew && repMap !== undefined) {
      if (key === undefined || key === '-e') {
        const count = miew.repCount();
        for (let i = 0; i < count; i++) {
          ret += this.listRep(miew, repMap, i, key);
        }
      }
    }
    return ret;
  }
  listRep(miew, repMap, repIndex, key) {
    let ret = '';
    const rep = miew.repGet(repIndex);
    if (!rep) {
      logger.warn(`Rep ${repIndex} does not exist!`);
      return ret;
    }
    const index = repIndex;
    const repName = repMap.get(index);
    const {
      mode,
      colorer
    } = rep;
    const selectionStr = rep.selectorString;
    const material = rep.materialPreset;
    ret += `#${index} : ${mode.name}${repName === '<no name>' ? '' : `, ${repName}`}\n`;
    if (key !== undefined) {
      ret += `    selection : "${selectionStr}"\n`;
      ret += `    mode      : (${mode.id}), ${mode.name}\n`;
      ret += `    colorer   : (${colorer.id}), ${colorer.name}\n`;
      ret += `    material  : (${material.id}), ${material.name}\n`;
    }
    return ret;
  }
  listSelector(miew, context) {
    let ret = '';
    for (const k in context) {
      if (context.hasOwnProperty(k)) {
        ret += `${k} : "${context[k]}"\n`;
      }
    }
    return ret;
  }
  listObjs(miew) {
    const objs = miew._objects;
    if (!objs || !Array.isArray(objs) || objs.length === 0) {
      return 'There are no objects on the scene';
    }
    const strList = [];
    for (let i = 0, n = objs.length; i < n; ++i) {
      strList[i] = `${i}: ${objs[i].toString()}`;
    }
    return strList.join('\n');
  }
  joinHelpStr(helpData) {
    if (helpData instanceof Array) {
      return helpData.join('\n');
    }
    return helpData;
  }
  help(path) {
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(path)) {
      return `${this.joinHelpStr(MiewCLIHelp.$help)}\n${external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].slice(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].sortBy(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].keys(MiewCLIHelp)), 1).join(', ')}\n`;
    }
    const helpItem = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(MiewCLIHelp, path);
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(helpItem) ? this.help() : `${this.joinHelpStr(helpItem.$help)}\n`;
  }
  load(miew, arg) {
    if (miew === undefined || arg === undefined || arg === '-f') {
      return;
    }
    miew.awaitWhileCMDisInProcess();
    const finish = () => miew.finishAwaitingCMDInProcess();
    miew.load(arg).then(finish, finish);
  }
  checkArg(key, arg, modificate) {
    if (key !== undefined && arg !== undefined) {
      if (keyRemap(key) === 'selector') {
        const res = Miew_cli_selectors.parse(arg);
        if (res.error !== undefined) {
          const selExc = {
            message: res.error
          };
          throw selExc;
        }
        if (modificate !== undefined && modificate) {
          return res.selector;
        }
        return arg;
      }
      const modificators = {
        colorers: Miew_cli_colorers,
        modes: Miew_cli_modes,
        materials: Miew_cli_materials
      };
      let modificator = key;
      let temp;
      while (modificator !== temp) {
        temp = modificator;
        modificator = keyRemap(temp);
      }
      if (modificators[modificator].get(arg) === undefined) {
        const exc = {
          message: `${arg} is not existed in ${modificator}`
        };
        throw exc;
      }
      return arg;
    }
    return NULL;
  }
  propagateProp(path, arg) {
    if (path !== undefined) {
      let argExc = {};
      const adapter = Miew_cli_options.adapters[typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(Miew_cli_settings.defaults, path)];
      if (adapter === undefined) {
        const pathExc = {
          message: `${path} is not existed`
        };
        throw pathExc;
      }
      if ((path.endsWith('.color') || path.endsWith('.baseColor') || path.endsWith('.EL.carbon')) && typeof arg !== 'number') {
        arg = Miew_cli_palettes.get(Miew_cli_settings.now.palette).getNamedColor(arg);
      }
      if (path.endsWith('.fg') || path.endsWith('.bg')) {
        if (typeof arg !== 'number') {
          const val = Miew_cli_palettes.get(Miew_cli_settings.now.palette).getNamedColor(arg, true);
          if (val !== undefined) {
            arg = `0x${val.toString(16)}`;
          }
        } else {
          arg = `0x${arg.toString(16)}`;
        }
      }
      if (path.endsWith('.template')) {
        arg = arg.replace(/\\n/g, '\n'); // NOSONAR
      }
      if (arg !== undefined && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
        argExc = {
          message: `${path} must be a "${typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(Miew_cli_settings.defaults, path)}"`
        };
        throw argExc;
      }
    }
    return arg;
  }
  unquoteString(value) {
    return utils.unquoteString(value);
  }
}
// repIndexOrRepMap could be RepresentationMap or index

const utilFunctions = new CLIUtils();
function CreateObjectPair(a, b) {
  const obj = {};
  obj[a] = b;
  return obj;
}
function ArgList(arg) {
  if (arg instanceof this.constructor) {
    return arg;
  }
  if (arg instanceof Array) {
    this._values = arg.slice(0);
  } else if (arg) {
    this._values = [arg];
  } else {
    this._values = [];
  }
}
ArgList.prototype.append = function (value) {
  const values = this._values;
  values[values.length] = value;
  return this;
};
ArgList.prototype.remove = function (value) {
  const values = this._values;
  const index = values.indexOf(value);
  if (index >= 0) {
    values.splice(index, 1);
  }
  return this;
};
ArgList.prototype.toJSO = function (cliUtils, cmd, arg) {
  const res = {};
  const list = this._values;
  for (let i = 0, n = list.length; i < n; ++i) {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(res, list[i].id, cliUtils.propagateProp(`${keyRemap(cmd)}.${arg}.${list[i].id}`, list[i].val));
  }
  return res;
};
function Arg(_id, _val) {
  this.id = _id;
  this.val = _val;
}
const cliutils = Object.create({});
cliutils.Arg = Arg;
cliutils.ArgList = ArgList;
cliutils.miew = null;
cliutils.echo = null;
cliutils.representations = representationsStorage;
cliutils.utils = utilFunctions;
cliutils._ = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"];
cliutils.CreateObjectPair = CreateObjectPair;
cliutils.keyRemap = keyRemap;
cliutils.Context = Miew_cli_selectors.Context;
cliutils.ClearContext = Miew_cli_selectors.ClearContext;
cliutils.NULL = NULL;
cliutils.notimplemented = function () {
  return this.NULL;
};
src_Miew.prototype.script = function (script, _printCallback, _errorCallback) {
  MiewCLIParser.parser.yy.miew = this;
  MiewCLIParser.parser.yy.echo = _printCallback;
  MiewCLIParser.parser.yy.error = _errorCallback;
  if (this.cmdQueue === undefined) {
    this.cmdQueue = [];
  }
  if (this.commandInAction === undefined) {
    this.commandInAction = false;
  }
  this.cmdQueue = this.cmdQueue.concat(script.split('\n'));
};
src_Miew.prototype.awaitWhileCMDisInProcess = function () {
  this.commandInAction = true;
};
src_Miew.prototype.finishAwaitingCMDInProcess = function () {
  this.commandInAction = false;
};
src_Miew.prototype.isScriptingCommandAvailable = function () {
  return this.commandInAction !== undefined && !this.commandInAction && this.cmdQueue !== undefined && this.cmdQueue.length > 0;
};
src_Miew.prototype.callNextCmd = function () {
  if (this.isScriptingCommandAvailable()) {
    const cmd = this.cmdQueue.shift();
    const res = {};
    res.success = false;
    try {
      MiewCLIParser.parser.parse(cmd);
      res.success = true;
    } catch (e) {
      res.error = e.message;
      MiewCLIParser.parser.yy.error(res.error);
      this.finishAwaitingCMDInProcess();
    }
    return res;
  }
  return '';
};
MiewCLIParser.parser.yy = cliutils;
// workaround for incorrect JISON parser generator for AMD module
MiewCLIParser.parser.yy.parseError = MiewCLIParser.parser.parseError;
;// CONCATENATED MODULE: ./src/index.js


/* harmony default export */ const src = (src_Miew);
var __webpack_exports__default = __webpack_exports__.A;
export { __webpack_exports__default as default };

//# sourceMappingURL=Miew.module.js.map